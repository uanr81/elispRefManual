@c -*- mode: texinfo; coding: utf-8 -*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2019 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Lisp Data Types
@chapter Типы Данных Lisp
@cindex объект
@cindex Lisp объект
@cindex тип
@cindex данные тип

  Lisp @dfn{объект} представляет собой часть данных, которые используют
  и которыми манипулируют программы Lisp.  Для преследуемых целей, @dfn{тип}
  или @dfn{тип данных} представляется набором возможных объектов.

  Каждый объект принадлежит, по крайней мере, к одному типу.  Объекты одного
  типа имеют сходные структуры и, как правило, могут быть использованы в
  одних и тех же контекстах.  Типы могут пересекаться, и объекты могут
  принадлежать двум или более типам.  Следовательно, можно спросить,
  принадлежит ли объект к определенному типу, но не какого @dfn{типа} объект.

@cindex примитивный тип
  В Emacs встроено несколько основных типов объектов.  Из этих типов строятся все
  остальные типы, они называются @dfn{примитивными типами}.  Каждый из таких объектов
  принадлежит одному и только одному элементарному типу.  Эти типы:
  @dfn{целое число}, @dfn{число с плавающей точкой}, @dfn{cons-ячейка},
  @dfn{символ}, @dfn{строка}, @dfn{вектор}, @dfn{хеш-таблица}, @dfn{subr},
  @dfn{скомпилированная функция}, @dfn{запись}, а также несколько
  специальных типов, таких как @dfn{буфер}, которые связаны с редактированием.
  (@xref{Editing Types}.)

  Каждый примитивный тип имеет соответствующую функцию Lisp, которая проверяет,
  является ли объект членом этого типа.

  Отличие Lisp от многих других языков, в том, что его объекты
  @dfn{self-typing(самотипируемые)}: примитивный тип каждого объекта неявно
  определяется в самом объекте.  Например, если объект является вектором, ничто не
  может рассматривать его как число; Lisp знает, что это вектор, а не число.

  В большинстве языков, программист должен объявить тип данных каждой переменной,
  и этот тип известен компилятору и не представляется в данными.  Такие объявления
  типов не существуют в Emacs Lisp.  Переменная Lisp может иметь любой тип значения,
  и она запоминает любое значение, которое в ней хранится.  (На самом деле,
  небольшое количество Emacs Lisp переменных могут принимать только значения
  определенного типа.  @xref{Variables with Restricted Values}.)

  В этой главе описывается назначение, печатное представление, синтаксис чтения
  каждого из стандартных типов в GNU Emacs Lisp.  Подробности о том, как
  использовать эти типы могут быть найдены в следующих главах.

@menu
* Printed Representation::      Как Lisp объекты представлены в виде текста.
* Comments::                    Комментарии и правила их форматирования.
* Programming Types::           Типы встречающиеся во всех системах Lisp.
* Editing Types::               Типы специфичные для Emacs.
* Circular Objects::            Синтаксис чтения для циклических структур.
* Type Predicates::             Тесты, связь с типами.
* Equality Predicates::         Проверка равенства между любыми двумя объектами.
@end menu

@node Printed Representation
@section Печатное Представление и Синтаксис Чтения
@cindex печатное представление
@cindex синтаксис чтения

  @dfn{Печатное представление (print)} объекта является форматом выходного сигнала,
генерируемого Lisp-печатью (функция @code{prin1}) для этого объекта.  Каждый тип
данных имеет уникальное печатное представление.  @dfn{Синтаксис чтения} объекта
является форматом ввода, принятого Lisp-чтением (функция @code{read}) для этого
объекта.  Это не обязательно является уникальным; многие типы объектов имеют более
одного синтаксиса.  @xref{Read and Print}.

@cindex хеш нотация
  В большинстве случаев, печатное представление объекта, является также синтаксисом
чтения для объекта.  Однако, у некоторых типов нет синтаксиса чтения, поскольку нет
смысла вводить объекты этих типов как константы в программе на Lisp. Эти объекты
печатаются как @dfn{хеш-нотация}, состоящая из символов @samp{#<}, описательной
строки (как правило, после имени типа следует имя объекта), и завершающего символа
@samp{>}.  Например:

@example
(current-buffer)
     @result{} #<buffer objects.texi>
@end example

@noindent
Хеш-нотация вообще не может быть прочитана, так что Lisp-чтение сигнализирует об
ошибке @code{invalid-read-syntax} всякий раз, когда встречает @samp{#<}.
@kindex invalid-read-syntax

  В других языках выражение - это текст; у него нет другой формы.  В Lisp выражение -
это прежде всего объект Lisp, и только потом текст, который является синтаксисом
чтения объекта.  Часто нет необходимости подчеркивать это различие, но всегда нужно
помнить об этом, иначе есть вероятность быть сильно сбитым с толку.

  Когда вычисляется выражение в интерактивном режиме, интерпретатор Lisp сначала
считывает его текстовое представление, создавая объект Lisp, а затем оценивает этот
объект (@pxref{Evaluation}).  Тем не менее, оценка и чтение являются отдельными видами
деятельности.  Чтение возвращает объект Lisp, прочитанный из текстового представления;
объект может оценён или не оценен позже.  @xref{Input Functions}, описывается
@code{read}, основная функция для чтения объектов.

@node Comments
@section Комментарии
@cindex комментарии
@cindex @samp{;} для комментариев

  @dfn{Коментарий} это текст, который написан в программе только ради людей,
которые читают код этой программы, и это не имеет никакого влияния на смысл программы.
В Lisp, неэкранированная точка с запятой (@samp{;}) начинает комментарий, если он не
находится внутри строковой или символьной константы.  Комментарий продолжается до
конца строки.  Lisp-чтение отбрасывает комментарии; они не становятся частью объектов
Lisp, которые представляют программу в рамках системы Lisp.

  @samp{#@@@var{count}} конструкция, которая пропускает следующее @var{count}
количество символов, полезна для сгенерированных программой комментариев, содержащих
двоичные данные.  Emacs Lisp использует это в своих выходных файлах
(@pxref{Byte Compilation}).  Однако это не предназначено для исходных файлов.
@xref{Comment Tips}, соглашения о форматировании комментариев.

@node Programming Types
@section Программные Типы
@cindex программные типы

  Есть две основные категории типов в Emacs Lisp: те, которые имеют дело с
программированием на Lisp, и те, которые имеют дело с редактированием. Первые
существует во многих реализациях Lisp, в той или иной форме.  Последние являются
уникальными для Emacs Lisp.

@menu
* Integer Type::        Числа без дробной части.
* Floating-Point Type:: Числа с дробной частью и большим диапазоном.
* Character Type::      Представление букв, цифр и управляющих символов.
* Symbol Type::         Многофункциональный объект, который ссылается на функцию,
                            переменную или список свойств, и имеет уникальный
                            идентификатор.
* Sequence Type::       Списки и Массивы классифицируются как последовательности.
* Cons Cell Type::      Cons-ячейки, а также списки (которые сделаны из cons-ячеек).
* Array Type::          Массивы включают строки и векторы.
* String Type::         (Эффективный) массив символов.
* Vector Type::         Одномерные массивы.
* Char-Table Type::     Одномерные разряженные массивы, индексированные по символам.
* Bool-Vector Type::    Одномерные массивы @code{t} или @code{nil}.
* Hash Table Type::     Сверх-быстрые таблицы поиска.
* Function Type::       Фрагмент исполняемого кода, который можно вызвать из любого
                            места программы.
* Macro Type::          Метод расширения выражения в другое выражение, более
                            фундаментальный, но менее красивый.
* Primitive Function Type::     Функция написана в C, вызываемая из Lisp.
* Byte-Code Type::      Функция написаная на Lisp, затем скомпилированная.
* Record Type::         Составные объекты с определенными программистом типами.
* Type Descriptors::    Объекты хранения информации о типах.
* Autoload Type::       Тип используется для автоматической загрузки редко
                            используемых функций.
* Finalizer Type::      Не запускать код больше, если он не доступен.

@end menu

@node Integer Type
@subsection Целочисленный Тип

  Диапазон значений для целого числа зависит от машины.  Минимальный диапазон
составляет от @minus{}536,870,912 to 536,870,911 (30 бит, то есть от
@ifnottex
@minus{}2**29
@end ifnottex
@tex
@math{-2^{29}}
@end tex
до
@ifnottex
2**29 @minus{} 1)
@end ifnottex
@tex
@math{2^{29}-1})
@end tex
но многие машины обеспечивают более широкий диапазон.  В Emacs Lisp арифметические
функции не проверяют целочисленное переполнение.  Таким образом выражение
@code{(1+ 536870911)} оценится в @minus{}536,870,912, если длинна целого числа Emacs
составляет 30 бит.

  Синтаксис чтения для целых чисел представляет собой последовательность цифр (по
основанию десять) с необязательным знаком в начале и дополнительной точкой в конце.
Печатное представление, созданное интерпретатором Lisp, никогда не имеет ведущего
символа @samp{+} или конечного @samp{.}.

@example
@group
-1               ; @r{Целое число @minus{}1.}
1                ; @r{Целое число 1.}
1.               ; @r{Также Целое число 1.}
+1               ; @r{Также Целое число 1.}
@end group
@end example

@noindent
В качестве особого исключения, если последовательность цифр определящая целое число
слишком большая или слишком малая, чтобы быть допустимым целочисленным объектом,
Lisp-чтение считывает её как число с плавающей точкой (@pxref{Floating-Point Type}).
Например, если в Emacs целое равно 30 бит, @code{536870912} считывается как число с
плавающей точкой @code{536870912.0}.  @xref{Numbers}, для детальной информации.

@node Floating-Point Type
@subsection Тип Число с Плавающей Точкой

  Числа с плавающей точкой являются компьютерным эквивалентом научной нотации;
Можно думать о числе с плавающей точкой как о дроби со степенью десять.  Точное число
значащих цифр и диапазон возможных показателей зависит от машины; Emacs использует тип
данных C @code{double} для хранения значения, и внутренне он записывает степень 2, а
не степень 10.

  Печатное представление чисел с плавающей точкой требует либо десятичной точки (как
минимум с одной следующей цифрой), либо экспоненты, либо и того и другого.  Например,
@samp{1500.0}, @samp{+15e2}, @samp{15.0e+2},@samp{+1500000e-3} и @samp{.15e4}
представляют собой пять способов записи числа с плавающей точкой, значение которого
1500.  Все они эквивалентны.  @xref{Numbers}, для детальной информации.

@node Character Type
@subsection Символьные Типы
@cindex @acronym{ASCII} коды символов

  @dfn{Символы} в Emacs Lisp - не более чем целое число.  Другими словами, символы
представлены их кодами символов.  Например, @kbd{A} символ представлен как
@w{integer 65}.

  Отдельные символы используются иногда в программах, но чаще для работы со
@emph{строками}, которые представляют собой последовательности, состоящие из символов.
@xref{String Type}.

  Символы в строках и буферах в настоящее время ограничены диапазоном от 0 до 4194303
--- двадцать два бита (@pxref{Character Codes}).  Коды от 0 до 127 - это
@acronym{ASCII} коды; остальные не-@acronym{ASCII} (@pxref{Non-ASCII Characters}).
Символы, которые представляют собой ввод с клавиатуры и имеют гораздо более широкий
диапазон, с использованием кодирования клавиш-модификаторов, таких как Control, Meta
и Shift.

  Существуют специальные функции для получения удобочитаемого текстового описания
символа для сообщений.  @xref{Describing Characters}.

@menu
* Basic Char Syntax::      Синтаксис обычных символов.
* General Escape Syntax::  Как определить символы по их кодам.
* Ctl-Char Syntax::        Синтаксис для управляющих символов.
* Meta-Char Syntax::       Синтаксис для мета-символов.
* Other Char Bits::        Синтаксис для hyper-, super-, и alt-символов.
@end menu

@node Basic Char Syntax
@subsubsection Базовый Синтаксис Символов
@cindex синтаксис чтения символов
@cindex печатное представление символов
@cindex синтаксис символов
@cindex @samp{?} константный символ
@cindex вопросительный знак в символьной константе

  Так как символы на самом деле целые числа, печатное представление символа
представляет собой десятичное число.  Это также возможный синтаксис чтения для
символа, но написание таким образом в программах на Lisp - не понятное
программирование.  Лучше @emph{всегда} использовать специальные форматы синтаксиса для
чтения, которые Emacs Lisp предоставляет для символов.  Эти форматы синтаксиса
начинаются со знака вопроса.

  Обычный синтаксис чтения для алфавитно-цифровых символов - это вопросительный знак,
за которым следует символ; таким образом, @samp{?A} для символа @kbd{A}, @samp{?B} для
символа @kbd{B} и @samp{?a} для символа @kbd{a}.

  Для примера:

@example
?Q @result{} 81     ?q @result{} 113
@end example

  Можно использовать тот же синтаксис для знаков пунктуации.  Однако, если знак
препинания имеет специальный синтаксический смысл в Lisp, потребуется экранировать его
с помощью @samp{\}.  Например, @samp{?\(} является способом написания символа открытой
скобки.  Точно так же, если нужно использовать символ @samp{\}, требуется использовать
второй @samp{\} чтобы процитировать его: @samp{?\\}.

@cindex пропуски
@cindex звуковой сигнал
@cindex @samp{\a}
@cindex Backspace
@cindex @samp{\b}
@cindex табуляция (ASCII символы)
@cindex @samp{\t}
@cindex вертикальная табуляция
@cindex @samp{\v}
@cindex подача формы
@cindex @samp{\f}
@cindex новая строка
@cindex @samp{\n}
@cindex возврат (ASCII символа)
@cindex @samp{\r}
@cindex escape (ASCII символ)
@cindex @samp{\e}
@cindex пробел (ASCII символ)
@cindex @samp{\s}
  Можно выразить символы control-g, backspace, tab, newline, vertical tab, formfeed,
space, return, del, и escape как @samp{?\a}, @samp{?\b}, @samp{?\t}, @samp{?\n},
@samp{?\v}, @samp{?\f}, @samp{?\s}, @samp{?\r}, @samp{?\d} и @samp{?\e}
соответственно.  (@samp{?\s} с последующим тире имеет другое значение --- он
применяет модификатор Super к следующиму символу.)  Таким образом,

@example
?\a @result{} 7                 ; @r{control-g, @kbd{C-g}}
?\b @result{} 8                 ; @r{возврат на одну позицию, @key{BS}, @kbd{C-h}}
?\t @result{} 9                 ; @r{табуляция, @key{TAB}, @kbd{C-i}}
?\n @result{} 10                ; @r{перевод строки, @kbd{C-j}}
?\v @result{} 11                ; @r{вертикальная табуляция, @kbd{C-k}}
?\f @result{} 12                ; @r{перевод страницы, @kbd{C-l}}
?\r @result{} 13                ; @r{возврат каретки, @key{RET}, @kbd{C-m}}
?\e @result{} 27                ; @r{escape-символ, @key{ESC}, @kbd{C-[}}
?\s @result{} 32                ; @r{пробел, @key{SPC}}
?\\ @result{} 92                ; @r{обратная косая черта, @kbd{\}}
?\d @result{} 127               ; @r{удалить символ, @key{DEL}}
@end example

@cindex escape последовательности
  Последовательности, которые начинаются с обратной косой черты также известные как
@dfn{escape последовательности}, потому что обратная косая черта играет роль
экранирующего символа; это не имеет ничего общего с символом @key{ESC}.  @samp{\s}
предназначен для использования в символьных константах; в строковых констант, просто
пишется пробел.

  Обратная косая черта допускается и безвредена, если предшествует символу без особого
escape-смысла;  Таким образом, @samp{?\+} эквивалентно @samp{?+}.  Нет причин, чтобы
добавить обратный слэш перед большинством символов.  Тем не менее, потребуется
добавить обратную косую черту перед любым из символов @samp{()[]\;"}  и потребуется
добавить обратную косую черту перед любым из символов @samp{|'`#.,}, чтобы не спутать
команды Emacs для редактирования кода Lisp.  Можно также добавить обратный слэш перед
пробельным символом, таким как пробел, табуляция, перевод строки и перевод страницы.
Тем не менее, лучше использовать один из легко понимаемых управляющих
последовательностей, таких как @samp{\t} или @samp{\s}, вместо фактического символа
пробела, такого как табуляция или пробел.  (Если писать обратную косую черту, а затем
пробел, потребуется написать дополнительный пробел после символьной константы, чтобы
отделить его от последующего текста.)

@node General Escape Syntax
@subsubsection Общий Escape Синтакс

  В дополнение к конкретным экранирующим последовательностям для специальных важных
управляющих символов, Emacs предоставляет несколько типов синтаксиса
escape-последовательностей, которые можно использовать, чтобы указать
не-@acronym{ASCII} текстовый символ.

@enumerate
@item
@cindex @samp{\} символьная константа
@cindex backslash символьная константа
@cindex escape символ unicode
Можно указать символ по его имени Unicode, если таковое имеется.
@code{?\N@{@var{NAME}@}} представляет символ Unicode с именем @var{NAME}.
Таким образом, @samp{?\N@{LATIN SMALL LETTER A WITH GRAVE@}} эквивалентно
@code{?à} и обозначает символ Unicode U+00E0.  Для упрощения ввода многостроковых
строк, можно заменить пробелы в именах непустыми последовательностями пробельных
символов (например, символом новая строка).

@item
Можно указать символы по их значениям Unicode. @code{?\N@{U+@var{X}@}} представляет
собой символ с кодовой точкой Unicode @var{X}, где @var{X} является шестнадцатеричным
числом.  Кроме того, @code{?\u@var{xxxx}} и @code{?\U@var{xxxxxxxx}} представляют
собой кодовые точки @var{xxxx} и @var{xxxxxxxx}, соответственно, где каждый @var{x}
является одной шестнадцатеричной цифрой.  Например, @code{?\N@{U+E0@}}, @code{?\u00e0}
и @code{?\U000000E0} все эквивалентны @code{?à} и
@samp{?\N@{LATIN SMALL LETTER A WITH GRAVE@}}.  Стандарт Unicode определяет
кодовые точки только до @samp{U+@var{10ffff}}, поэтому если указывается кодовая точка
кода выше, Emacs сигнализирует об ошибке.

@item
Можно указать символы, c помощью их шестнадцатиричных кодов.  Шестнадцатеричная
escape-последовательность состоит из обратной косой черты, @samp{x} и
шестнадцатеричного кода символа.  Таким образом, @samp{?\x41} - это символ @kbd{A},
@samp{?\x1} - это символ @kbd{C-a} и @code{?\xe0} - это символ @kbd{à} (@kbd{a} с
серьезным акцентом).  Можно использовать любое количество шестнадцатеричных цифр, так
что можно представить любой код символа таким образом.

@item
@cindex восьмеричный код символа
Можно указать символы по их восьмеричному коду.  Восьмеричная управляющая
последовательность состоит из обратной косой черты, за которой следует до трех
восьмеричных цифр;  Таким образом, @samp{?\101} для символа @kbd{A}, @samp{?\001} для
символа @kbd{C-a} и @code{?\002} для символа @kbd{C-b}.  Только символы до
восьмеричного кода 777 могут быть заданы таким образом.

@end enumerate

  Эти последовательности также могут быть использованы в строках.
@xref{Non-ASCII in Strings}.

@node Ctl-Char Syntax
@subsubsection Управляющие-Символы Синтаксис

@cindex управляющие символы
  Управляющие символы могут быть представлены с помощью еще одного синтаксиса чтения.
Он состоит из знака вопроса с последующей обратной косой чертой, кареткой, и
соответствующим неконтролирующим символом, в верхнем или нижнем регистре.  Например,
@samp{?\^I} и @samp{?\^i} допустимый синтаксис чтения для символа @kbd{C-i}, значение
которого равно 9.

  Вместо @samp{^}, можно использовать @samp{C-};  Таким образом, @samp{?\C-i}
эквивалентно @samp{?\^I} и @samp{?\^i}:

@example
?\^I @result{} 9     ?\C-I @result{} 9
@end example

  В строках и буферах, разрешены только управляющие символы, которые существуют в
@acronym{ASCII}; но для ввода с клавиатуры, можно превратить любой символ в
управляющий символ с @samp{C-}.  Коды символов для этих управляющих не-@acronym{ASCII}
символов включают
@tex
@math{2^{26}}
@end tex
@ifnottex
2**26
@end ifnottex
бит, а также код соответствующего неуправляющего символа.  Обычные текстовые терминалы
не имеют возможности генерации управляющих не-@acronym{ASCII} символов, но можно
создать их непосредственно с помощью X и других оконных систем.

  По историческим причинам, Emacs трактует @key{DEL} символ в качестве управляющего
символа эквивалентного @kbd{?}:

@example
?\^? @result{} 127     ?\C-? @result{} 127
@end example

@noindent
В результате, в настоящее время не представляется возможным представить управляющий
символ @kbd{Control-?}, который является значимым входным символом в X, используя
@samp{\C-}.  Это не так легко изменить, так как различные Lisp файлы ссылаются на
@key{DEL} таким образом.

  Для представления управляющих символов, которые можно найти в файлах или
строках, рекомендуется синтаксис @samp{^}; для управляющих символов ввода с
клавиатуры, предпочитается синтаксис @samp{C-}.  Какой из них использовать, не влияет
на смысл программы, но может способствовать пониманию людей, которые читают его.

@node Meta-Char Syntax
@subsubsection Синтаксис Мета-Символов

@cindex мета-символы
  @dfn{Мета-Символом} является введенный символ с помощью клавиши-модификатора
@key{META}.  Целое число, которое представляет собой такой символ имеет набор
@tex
@math{2^{27}}
@end tex
@ifnottex
2**27
@end ifnottex
бит.  Используются старшие биты для этого и других модификаторов, чтобы сделать
возможным широкий спектр базовых кодов символов.

  В строке,
@tex
@math{2^{7}}
@end tex
@ifnottex
2**7
@end ifnottex
бит, прикреплённого к символу @acronym{ASCII}, указывается мета-символ;  Таким
образом, мета-символы, которые могут поместиться в строке имеют коды в диапазоне от
128 до 255, и являются мета-версиями обычных символов @acronym{ASCII}.
@xref{Strings of Events}, для получения подробной информации о @key{META} обработки
в строках.

  Синтаксис чтения для мета-символов использует @samp{\M-}.  Например,  @samp{?\M-A}
означает @kbd{M-A}.  Можно использовать @samp{\M-} вместе с восьмеричными кодами
символов (смотреть ниже) и используя @samp{\C-} или с каким-либо другим синтаксисом
для символа.  Таким образом, возможно написать @kbd{M-A} как @samp{?\M-A} или как
@samp{?\M-\101}.  Кроме того, можно написать @kbd{C-M-b} как @samp{?\M-\C-b},
@samp{?\C-\M-b} или @samp{?\M-\002}.

@node Other Char Bits
@subsubsection Остальные Биты Модификации Символов

  Регистр графического символа указывается его кодом символа; например,
@acronym{ASCII} различает между символами @samp{a} и @samp{A}.  Но @acronym{ASCII} не
имеет возможности представлять является ли управляющий символ верхнего или нижнего
регистра.  Emacs использует
@tex
@math{2^{25}}
@end tex
@ifnottex
2**25
@end ifnottex
бит, чтобы указать, что клавиша Shift используется при наборе управляющего символа.
Это различие возможно только при использовании X терминалов или других специальных
терминалов; обычные текстовые терминалы не сообщают различия.  Синтаксис Lisp для бита
сдвига является @samp{\S-};  Таким образом, @samp{\C-\S-o} или @samp{?\C-\S-O}
представляет собой битовый сдвиг символа элемента управления.

@cindex символ hyper
@cindex символ super
@cindex символ alt
  Система X Window определяет три других бита @anchor{modifier bits} модификатора,
которые могут быть установлены в символе: @dfn{hyper}, @dfn{super} и @dfn{alt}.
Синтаксис для этих битов @samp{\H-}, @samp{\s-} и @samp{\A-}.  (Важен регистр в этих
префиксах.)  Таким образом, @samp{?\H-\M-\A-x} представляет @kbd{Alt-Hyper-Meta-x}.
(Обратить внимание, что @samp{\s} с не следующим за ним @samp{-} не представляет собой
символ пробела.)
@tex
Численно битовые значения @math{2^{22}} для alt, @math{2^{23}} для super и
@math{2^{24}} для hyper.
@end tex
@ifnottex
Численно битовые значения 2**22  для alt, 2**23 для super и 2**24 для hyper.
@end ifnottex

@node Symbol Type
@subsection Символьный Тип

  @dfn{Символ} в GNU Emacs Lisp является объектом с именем.  Имя символа служит его
печатным представлением символа.  При обычном использовании Lisp, с одним единственным
наложением (@pxref{Creating Symbols}), имя символа является уникальным --- нет двух
символов с одинаковым именем.

  Символ может служить в качестве переменной, как имя функции, или для хранения списка
свойств.  Или может служить только для того, чтобы быть отличием от всех других
объектов Lisp, так что его присутствие в структуре данных, может быть надежно
распознано.  В данном контексте, как правило, только одно из этих целей
предполагается.  Но можно использовать один символ всеми этими способами, независимо
друг от друга.

  Символ, имя которого начинается с двоеточия (@samp{:}) называется
@dfn{символом ключевого слова}.  Эти символы автоматически действуют как константы, и,
как правило, используются только для сравнения неизвестного символа с несколькими
определенными альтернативами.  @xref{Constant Variables}.

@cindex @samp{\} символ
@cindex backslash символ
  Имя символа может содержать любые символы.  Большинство имен символов написаны
буквами, цифрами и знаками препинания @samp{-+=*\}.  Такие имена не требуют
специальной пунктуации; символов имени достаточно, если имя не выглядит как число.
(Если это так, пишеться @samp{\} в начале имени для принудительной интерпретации как
символа.)  Символы @samp{_~!@@$%^&:<>@{@}?} реже используется, но также не требуют
специальной пунктуации.  Любые другие символы могут быть включены в имя символа путем
экранирования их обратной косой чертой.  В отличие от такого использования в строках,
обратный слэш в имени символа просто цитирует один символ, который следует за обратной
косой чертой.  Например, в строке, @samp{\t} представляет собой символ табуляции; в
имени символа, @samp{\t} просто цитирует запись @samp{t}.  Для того, чтобы иметь
имя с символом табуляции, потребуется фактически использовать табуляцию (перед которой
стоит обратная косая черта).  Но такое встречается редко.

@cindex CL примечание --- регистр букв
@quotation
@b{Common Lisp примечание:}  В Common Lisp, строчные буквы всегда переводятся в
в верхний регистр, если только они явно не экранированы.  В Emacs Lisp, строчные и
прописные буквы различны.
@end quotation

  Вот несколько примеров имен символов.  Обратить внимание, что @samp{+} в четвертом
примере экранируется, чтобы предотвратить его от чтения как число.  Это не является
необходимым в шестом примере, потому что остальная часть имени делает его
недействительным как число.

@example
@group
foo                 ; @r{Символ с именем @samp{foo}.}
FOO                 ; @r{Символ с именем @samp{FOO}, отличный от @samp{foo}.}
@end group
@group
1+                  ; @r{Символ с именем @samp{1+}}
                    ;   @r{(не @samp{+1}, который является целым числом).}
@end group
@group
\+1                 ; @r{Символ с именем @samp{+1}}
                    ;   @r{(не очень читаемое имя).}
@end group
@group
\(*\ 1\ 2\)         ; @r{Символ c именем @samp{(* 1 2)} (неудачное имя).}
@c the @'s в этой следующей строке использовать три символа,
@c следовательно, кажется смещение комментария.
+-*/_~!@@$%^&=:<>@{@}  ; @r{Символ с именем @samp{+-*/_~!@@$%^&=:<>@{@}}.}
                    ;   @r{Эти символы не нужно экранировать.}
@end group
@end example

@cindex @samp{##} синтаксис чтения
@ifinfo
@c При этом используется "colon" вместо буквального ':' потому,
@c что программ info не может справиться с ':' в меню.
@cindex @samp{#@var{colon}} чтение синтаксис
@end ifinfo
@ifnotinfo
@cindex @samp{#:} чтение синтаксис
@end ifnotinfo
  В качестве исключения из правила, согласно которому имя символа служит его печатным
представлением, @samp{##}---это печатное представление для интернированного символа,
имя которого является пустой строкой.  Кроме того, @samp{#:@var{foo}} это печатное
представление для неинтернированного символа, имя которого @var{foo}.  (Как правило,
Lisp-чтение обрабатывает все символы;  @pxref{Creating Symbols}.)

@node Sequence Type
@subsection Тип Последовательность

  @dfn{Последовательность} является объектом Lisp, который представляет собой
упорядоченный набор элементов.  Есть два вида последовательности в Emacs Lisp:
@dfn{списки} и @dfn{массивы}.

  Списки являются наиболее часто используемыми последовательностями.  Список может
содержать элементы любого типа, и его длина может быть легко изменена путем добавления
или удаления элементов.  Смотреть следующий подраздел для получения дополнительной
информации о списках.

  Массивы представляют собой последовательность фиксированной длины.  Они
подразделяются на строки, векторы, символ-таблицы и логические векторы.  Векторы
могут содержать элементы любого типа, в то время как строки должны содержать только
символы, логические векторы должны содержать лишь @code{t} или @code{nil}.
Символ-таблицы похожи на векторы, за исключением того, что они проиндексированы любым
допустимым кодом символа.  Символы в строке могут иметь свойства текста, такие как
символы в буфере (@pxref{Text Properties}), но векторы не поддерживают свойств текста,
даже если их элементы являются символами.

  Списки, строки и другие типы массивов также имеют важное сходство.  Например, все
они имеют длину @var{l}, и все они имеют элементы, которые могут быть проиндексированы
от нуля до @var{l} минус один.  Некоторые функции, называемые функциями
последовательностей, принимают либой вид последовательности.  Например, функция
@code{length} сообщает длину любого вида последовательности.
@xref{Sequences Arrays Vectors}.

  Как правило, невозможно читать ту же последовательность дважды, так как
последовательности всегда создается заново при чтении.  Если дважды прочесть один
синтакс чтения последовательности, получится две последовательности с одинаковым
содержимым.  Существует одно исключение: пустой список @code{()} всегда обозначает
тот же объект, @code{nil}.

@node Cons Cell Type
@subsection Типы Cons-Ячейка и Список
@cindex address field of register
@cindex decrement field of register
@cindex pointers

  @dfn{Cons-ячейка} это объект, который состоит из двух слотов, слот @sc{car} и слот
@sc{cdr}.  Каждый слот может @dfn{содержать} любой объект Lisp.  Также говорится, что
@sc{car} этой cons-ячейки является объектом, и слот @sc{car} в настоящее время
указывает на него, и тоже для слота @sc{cdr}.

@cindex последовательность список
  @dfn{Список} это ряд cons-ячеек, связаных друг с другом, так что @sc{cdr} слот
каждой cons-ячейки указывает на следующую cons-ячейку либо на пустой список.  Пустой
список на самом деле символ @code{nil}.  @xref{Lists},  для деталей.  Поскольку
большинство cons-ячеек используются как часть списков, такая структура, изготовленная
из cons-ячеек, называется @dfn{списочной структурой}.

@cindex связанный список
@quotation
Замечание для программистов C: список Lisp, таким образом, работает как
@dfn{связаный список} состоящий из cons-ячеек.  Поскольку указатели в Lisp неявные,
здесь не делается различия между выражениями слот cons-ячейки содержит значение
и слот указывает на значение.
@end quotation

@cindex атомы
  Сons-ячейка занимает центральное место в Lisp, но также есть объекты, которые не
являются cons-ячейками.  Эти объекты называются @dfn{атомами}.

@cindex скобки
@cindex @samp{(@dots{})} в списках
  Синтаксис чтения и печатное представление списков идентичны и состоят из левой
круглой скобки, произвольного числа элементов, и правой скобки.  Вот примеры списков:

@example
(A 2 "A")            ; @r{Список из трех элементов.}
()                   ; @r{Список без элементов (пустой список).}
nil                  ; @r{Список без элементов (пустой список).}
("A ()")             ; @r{Список из одного элемента: строка @code{"A ()"}}.
(A ())               ; @r{Список из двух элементов: @code{A} и пустой список.}
(A nil)              ; @r{Эквивалент к предыдущему.}
((A B C))            ; @r{Список из одного элемента}
                     ;   @r{(который представляет собой список из трех элементов).}
@end example

   При чтении, каждый объект внутри скобок становится элементом списка.  То есть, для
каждого элемента создаётся cons-ячейка.  Слот @sc{car} из cons-ячейки удерживает
элемент, а её @sc{cdr} слот указывает на следующую cons-ячейку списка, которая
содержит следующий элемент списка.  @sc{cdr} слот последней cons-ячейки содержит
@code{nil}.

  Имена @sc{car} и @sc{cdr} вытекают из истории Lisp. Оригинальная реализация Lisp
исполнялась на @w{IBM 704} компьютере, который разделял слово на две части, адрес и
декремент; @sc{car} была инструкция для извлечения содержимого адресной части
регистра а @sc{cdr} инструкция, чтобы извлечь содержимое декремента.  Напротив,
cons-ячейки названы в честь функции @code{cons}, которая создает их, в свою очередь,
была названа в честь своего назначения, конструирование ячеек.

@menu
* Box Diagrams::                Рисование изображений списков.
* Dotted Pair Notation::        Общий синтаксис для cons-ячейки.
* Association List Type::       Специально построенный список.
@end menu

@node Box Diagrams
@subsubsection Схема Списка в Виде Прямоугольников
@cindex прямоугольная диаграмма для списков
@cindex диаграмма, прямоугольник, для списков

  Список можно проиллюстрировать диаграммой, в которой cons-ячейки показаны в виде
пар прямоугольников, как домино.  (Lisp-чтение не может прочитать такую ​​иллюстрацию,
в отличие от текстовой нотации, которая может быть понята как людьми, так и
компьютерами, прямоугольные иллюстрации могут быть поняты только людьми.)  Эта картина
представляет собой трёхэлементный список @code{(роза фиалка лютик)}:

@example
@group
    --- ---      --- ---      --- ---
   |   |   |--> |   |   |--> |   |   |--> nil
    --- ---      --- ---      --- ---
     |            |            |
     |            |            |
      --> роза     --> фиалка   --> лютик
@end group
@end example

  На этой диаграмме каждый прямоугольник представляет собой слот, который может
содержать или ссылаться на любой объект Lisp.  Каждая пара прямоугольников
представляет собой cons-ячейку.  Каждая стрелка представляет собой ссылку на объект
Lisp, атом или другую cons-ячейку.

  В данном примере, первый прямоугольник, содержит слот @sc{car} первой cons-ячейки,
который ссылается или содержит @code{роза} (символ).  Второй прямоугольник, содержит
@sc{cdr} первой cons-ячейки, указывающий на следующую пару прямоугольников, второй
cons-ячейки.  @sc{car} второй cons-ячейки является символом @code{фиалка}, и его
@sc{cdr} является третьей cons-ячейкой.  @sc{cdr} из третьей (и последней) cons-ячейки
является @code{nil}.

  Вот еще одна схема того же списка, @code{(роза фиалка лютик)}, набросанная
по-другому:

@smallexample
@group
 ---------------       ----------------       -------------------
| car   | cdr   |     | car    | cdr   |     | car       | cdr   |
| роза  |   o-------->| фиалка |   o-------->| лютик     |  nil  |
|       |       |     |        |       |     |           |       |
 ---------------       ----------------       -------------------
@end group
@end smallexample

@cindex @code{nil} в списке
@cindex пустой список
  Список без элементов в нём --- это @dfn{пустой список}; он идентичен символу
@code{nil}.  Другими словами, @code{nil} является одновременно символом и списком.

  Вот список @code{(A ())}, или что то же самое @code{(A nil)}, изображен
прямоугольниками и стрелками:

@example
@group
    --- ---      --- ---
   |   |   |--> |   |   |--> nil
    --- ---      --- ---
     |            |
     |            |
      --> A        --> nil
@end group
@end example

  Вот более сложный рисунок, показывающий список из трех элементов,
@code{((сосна хвоя) дуб клён)}, первый элемент которого является списком из двух
элементов:

@example
@group
    --- ---      --- ---      --- ---
   |   |   |--> |   |   |--> |   |   |--> nil
    --- ---      --- ---      --- ---
     |            |            |
     |            |            |
     |             --> дуб      --> клён
     |
     |     --- ---      --- ---
      --> |   |   |--> |   |   |--> nil
           --- ---      --- ---
            |            |
            |            |
             --> сосна    --> хвоя
@end group
@end example

  Тот же список, представленный в другой нотации выглядит следующим образом:

@example
@group
 --------------       --------------       --------------
| car   | cdr  |     | car   | cdr  |     | car   | cdr  |
|   o   |   o------->| дуб   |   o------->| клён  |  nil |
|   |   |      |     |       |      |     |       |      |
 -- | ---------       --------------       --------------
    |
    |
    |        --------------       ----------------
    |       | car   | cdr  |     | car     | cdr  |
     ------>| сосна |   o------->| хвоя    |  nil |
            |       |      |     |         |      |
             --------------       ----------------
@end group
@end example

@node Dotted Pair Notation
@subsubsection Нотация Точечной Пары
@cindex точечная пара нотация
@cindex @samp{.} в списках

  @dfn{Нотация точечной пары} является общим синтаксисом cons-ячейки, который
представляет @sc{car} и @sc{cdr} явно.  В  этом синтаксисе,
@code{(@var{a} .@: @var{b})} обозначает cons-ячейку, у которой @sc{car} является
объектом @var{a} и чья @sc{cdr} является объектом @var{b}.  Нотация точечной пары
является более общей, чем синтаксис списка, потому что @sc{cdr} не обязательно может
быть списком.  Тем не менее, это более громоздкий синтаксис в тех случаях, когда
синтаксис списка будет работать.  В нотации точечной пары, список @samp{(1 2 3)}
записывается в виде @samp{(1 .  (2 . (3 . nil)))}.  Для списков заканчивающихся
@code{nil}, возможно использовать любую нотацию, но нотация списка, как правило, более
ясна и удобна.  При печати списка, нотация точечной пары используется только тогда,
когда @sc{cdr} из cons-ячейки не список.

  Вот пример c использованием прямоугольников для иллюстрации нотации точечной пары.
Этот пример показывает пару @code{(роза . фиалка)}:

@example
@group
    --- ---
   |   |   |--> фиалка
    --- ---
     |
     |
      --> роза
@end group
@end example

  Можно комбинировать нотацию точечной пары и нотацию списка, для удобного
представления цепочки cons-ячеек с не-@code{nil} в @sc{cdr} конечной cons-ячейки.
Пишется точка после @sc{car} последнего элемента списка,  за которой  следует @sc{cdr}
конечной cons-ячейки.  Например, @code{(роза фиалка . лютик)} эквивалентно
@code{(роза . (фиалка . лютик))}.  Объект выглядит следующим образом:

@example
@group
    --- ---      --- ---
   |   |   |--> |   |   |--> лютик
    --- ---      --- ---
     |            |
     |            |
      --> роза     --> фиалка
@end group
@end example

  Синтаксис @code{(роза .@: фиалка .@: лютик)} является недействительным, потому что
нет ничего, что это может означать.  Во всяком случае, это указание поставить
@code{лютик} в слот @sc{cdr} cons-ячейки которая уже используются для @code{фиалка}.

  Список @code{(роза фиалка)} эквивалентно @code{(роза . (фиалка))} и  выглядит
следующим образом:

@example
@group
    --- ---      --- ---
   |   |   |--> |   |   |--> nil
    --- ---      --- ---
     |            |
     |            |
      --> роза     --> фиалка
@end group
@end example

  Аналогичным образом, записи трёхэлементного списка @code{(роза фиалка лютик)} и
@code{(роза . (фиалка . (лютик)))} эквивалентны.
@ifnottex
Похоже, что это:

@example
@group
    --- ---      --- ---      --- ---
   |   |   |--> |   |   |--> |   |   |--> nil
    --- ---      --- ---      --- ---
     |            |            |
     |            |            |
      --> роза     --> фиалка   --> лютик
@end group
@end example
@end ifnottex

@node Association List Type
@subsubsection Тип Ассоциативный Список

  @dfn{Ассоциативный список} или @dfn{alist} представляет собой специально построенный
список, элементами которого является cons-ячейки.  В каждом элементе, @sc{car}
считается @dfn{ключом}, а @sc{cdr} считается @dfn{ассоциативным значением}.  (В
некоторых случаях, ассоциированное значение для @sc{cdr} сохраняется в @sc{car}.)
Ассоциативные списки часто используются как стеки, так как легко добавлять или удалять
ассоциации в передней части списка.

  Например,

@example
(setq alist-of-colors
      '((роза . красный) (лилия . белый) (лютик . жёлтый)))
@end example

@noindent
устанавливает переменную @code{alist-of-colors} в ассоциативный список из трех
элементов.  В первом элементе, @code{роза} является ключом а @code{красный} это его
ассоциативное значение.

  @xref{Association Lists}, для детального объяснения alist-ов и функций, для работы
с alist-ами.  @xref{Hash Tables}, для другого типа справочной таблицы, которая намного
быстрее обрабатывает большое количество ключей.

@node Array Type
@subsection Тип Массив

  @dfn{Массив} состоит из произвольного числа слотов для удержания или ссылок на
другие объекты Lisp, расположенных в непрерывном блоке памяти.  Доступ к любому
элементу массива занимает примерно одинаковое время.  В противоположность этому,
доступ к элементу списка требует времени, пропорциональному положению элемента в
списке.  (Доступ к элементам в конце списка занимает больше времени, чем доступ к
элементам в начале списка.)

  Emacs определяет четыре типа массива: строки, векторы, логические векторы, и
символьные-таблицы.

  Строка представляет собой массив символов, а вектор представляет собой массив
произвольных объектов.  Логический-вектор может содержать только @code{t} или
@code{nil}.  Эти типы массивов могут иметь любую длину до наибольшего целого числа.
Символ-таблицы --- это разреженные массивы, индексированные любым допустимым кодом
символа; они могут содержать произвольные объекты.

  Первый элемент массива имеет нулевой индекс, второй элемент имеет индекс --- 1, и
так далее.  Это называется индексацией с @dfn{нулевым происхождением}.  Например,
массив из четырех элементов имеет индексы 0, 1, 2, @w{и 3}.  Наибольшее возможное
значение индекса на единицу меньше, чем длина массива.  После того, как массив создан,
его длина фиксирована.

  Все Emacs Lisp массивы являются одномерными.  (Большинство других языков
программирования поддерживают многомерные массивы, но они не являются обязательными,
можно получить тот же эффект с вложенными одномерными массивами.)  Каждый тип массива
имеет свой собственный синтаксис чтения;  детали в следующих разделах.

  Тип массива представляет собой подмножество типов последовательностей и содержит:
тип строка, тип вектор, тип логический вектор и тип символ-таблица.

@node String Type
@subsection Тип Строка

  @dfn{Строка} представляет собой массив символов.  Строки используются для многих
целей в Emacs, как можно ожидать, в текстовом редакторе; например, как имена символов
Lisp, как сообщения для пользователя, а также для представления текста, извлеченного
из буферов.  Строки в Lisp константы: оценка строки возвращает ту же строку.
@xref{Strings and Characters} функции, которые работают со строками.

@menu
* Syntax for Strings::      Как определить Lisp строки.
* Non-ASCII in Strings::    Международные символы в строках.
* Nonprinting Characters::  Буквенные непечатные символы в строках.
* Text Props and Strings::  Строки с текстовыми свойствами.
@end menu

@node Syntax for Strings
@subsubsection Синтаксис Строк

@cindex @samp{"} в строках
@cindex двойные кавычки в строках
@cindex @samp{\} в строках
@cindex backslash в строках
  Синтаксисом чтения для строки является взятые в двойные кавычки произвольное число
символов, @code{"это строка"}.  Чтобы включить символ двойной кавычки в строку,
ставиться перед ним обратная косая черта;  Таким образом, @code{"\""} это строка,
содержащая только одну двойную кавычку.  Кроме того, можно включить обратную косую
черту, предварив её другим символом обратной косой черты, как здесь:
@code{"Здесь \\, стоит одна обратная косая черта"}.

@cindex символ новая строка в строке
  Символ новой строки не является специальным в синтаксисе чтения для строк; если
пишется новая строка между двойными кавычками, он становится символом в строке.  Но
экранированный символ новой строки --- тот, которому предшествует @samp{\} --- не
становится частью строки; то есть Lisp-чтение игнорирует экранированный символ новой
строки при чтении строки.  Экраннированный пробел @w{@samp{\ }} аналогичным образом
игнорируется.

@example
"Полезно включать в строках документации символы новой
строки строки, но символ новой
строки \
игнорируется, \
если \
он \
экранирован."
     @result{} "Полезно включать в строках документации символы новой
строки строки, но символ новой строки игнорируется, если он экранирован."
@end example

@node Non-ASCII in Strings
@subsubsection Не-@acronym{ASCII} Символы в Строках

  Есть два текстовых представления для не-@acronym{ASCII} символов в строках Emacs:
многобайтное и однобайтное (@pxref{Text Representations}).  Грубо говоря, однобайтная
строка хранит необработанные байты, в то время как многобайтная строка хранить
удобочитаемый текст.  Каждый символ в однобайтной строке составляет один байт, то
есть, его значение находится между 0 и 255.  В отличие от этого, каждый символ в
многобайтной строке может иметь значение в диапазоне от 0 до 4194303
(@pxref{Character Type}).  В обоих случаях символы со значением выше 127
не-@acronym{ASCII}.

  Можно включать не-@acronym{ASCII} символ в строковую константу, написав его в
буквальном смысле.  Если строковая константа считывается из многобайтного источника,
такого как многобайтный буфер или строка или если файл будет посещён как многобайтный,
то Emacs читает каждый не-@acronym{ASCII} как многобайтный символ и автоматически
делает строку многобайтной строкой.  Если строковая константа считывается из
однобайтного источника, то Emacs считывает не-@acronym{ASCII} символ как однобайтный
и делает строку однобайтной.

  Вместо того, чтобы писать символ буквально в многобайтной строке, можно записать его
в своем коде символа с помощью escape-последовательности.
@xref{General Escape Syntax}, для получения подробной информации о экранирующих
последовательностях.

  Если используется escape-последовательность в стиле Unicode @samp{\uNNNN} или
@samp{\U00NNNNNN} в строковой константе (даже для @acronym{ASCII} символа), Emacs
автоматически предполагает, что она многобайтная.

  Можно также использовать шестнадцатеричные escape-последовательности
(@samp{\x@var{n}}) и восьмеричные escape-последовательности (@samp{\@var{n}}) в
строковых константах.  @strong{Быть осторожным:}  Если строковая константа содержит
шестнадцатеричные или восьмеричные escape-последовательности, и все эти управляющие
последовательности указывают однобайтные символы (то есть меньше, чем 256), и в строке
нет никаких других буквальных не-@acronym{ASCII} символов или
escape-последовательностей в Unicode-стиле, то Emacs автоматически принимает что это
строка однобайтная.  То есть, предполагается, что все не-@acronym{ASCII} символы
встречающиеся в строке являются 8-битными необработанными байтами.

  В шестнадцатеричных и восьмиричных управляющих последовательностях, экранированый
код символа может содержать переменное число цифр, так что первый последующий символ,
который не является допустимой шестнадцатиричной или восьмеричной цифрой, завершает
escape-последовательность.  Если следующий символ в строке может быть интерпретирован
как шестнадцатеричная или восьмеричной цифра, пишется @w{@samp{\ }} (обратный слэш и
пробел), чтобы завершить escape-последовательность.  Например, @w{@samp{\xe0\ }}
представляет собой один символ, @samp{a} с серьезным акцентом.  @w{@samp{\ }} в
строковой константе точно так же как обратный слэш-символ новой строки; не вносит
какие-либо символы в строку, но прекращает любую предшествующую шестндадцатиричную
escape-последовательность.

@node Nonprinting Characters
@subsubsection Непечатаемые символы в строках

  Можно использовать те же escape-последовательности с обратной косой чертой,
используемые в строковых константах, и для символьных литералов (но не использовать
знак вопроса, с которого начинается символьная константа).  Например, можно написать
строку, содержащую непечатаемый символ табуляции и @kbd{C-a}, с запятой и пробелом
между ними, вот так: @code{"\t, \C-a"}.  @xref{Character Type}, для описания
синтаксиса чтения для символов.

  Однако, не все символы, которые можно написать с обратной косой чертой в
escape-последовательности допустимы в строках.  Единственные управляющие символами,
которая строка может содержать, - это управляющие символы @acronym{ASCII}.  Строки не
различают регистр в управляющих символах @acronym{ASCII}.

  Собственно говоря, строки не могут содержать метасимволы; но когда строка будет
использоваться в качестве ключевой последовательности, существует специальное
соглашение, которое обеспечивает способ представления мета-версий @acronym{ASCII}
символов в строке.  Если используется синтаксис @samp{\M-}, чтобы указать мета-символ
в строковой константе, это установит
@tex
@math{2^{7}}
@end tex
@ifnottex
2**7
@end ifnottex
бит символа в строке.  Если строка используются в @code{define-key} или
@code{lookup-key}, этот цифровой код переводится в эквивалентный метасимвол.
@xref{Character Type}.

  Строки не могут содержать символы, которые имеют модификаторы hyper, super, или alt.

@node Text Props and Strings
@subsubsection Текстовые Свойства Строки

@cindex @samp{#(} синтаксис чтения
@cindex текстовые свойства, чтение синтаксис
  Строка может содержать свойства для символов, которые она содержит, в дополнение к
самим символам.  Это позволяет программам, которые копируют текст между строками и
буферами, копировать свойства текста без особых усилий.  @xref{Text Properties}, для
объяснения того, что означает свойство текста.  Строки с текстовыми свойствами
используют специальный синтаксис для чтения и печати:

@example
#("@var{characters}" @var{property-data}...)
@end example

@noindent
где @var{property-data} состоит из нуля или более элементов, в группах по три еденицы
следующим образом:

@example
@var{beg} @var{end} @var{plist}
@end example

@noindent
Элементы @var{beg} и @var{end} являются целыми числами, и вместе определяют диапазон
индексов в строке; @var{plist} является списком свойств для этого диапазона.
Например,

@example
#("foo bar" 0 3 (face bold) 3 4 nil 4 7 (face italic))
@end example

@noindent
представляет собой строку, текстовое содержимое которой @samp{foo bar}, первые три
символа имеют свойство @code{face} со значением @code{bold}, а последние три имеют
свойство @code{face} со значением @code{italic}.  (Четвертый символ не имеет свойства
текста, поэтому его список свойств является @code{nil}.  На самом деле нет
необходимости отмечать диапазоны со списком свойств с @code{nil}, так как любые
символы, не упомянутые в любом диапазоне будут по умолчанию, не иметь никаких
свойств.)

@node Vector Type
@subsection Тип Вектор

  @dfn{Вектор} является одномерным массивом элементов любого типа.  Требуется
постоянное количество времени для доступа к любому элементу вектора.  (В списке,
время доступа элемента пропорционально расстоянию элемента от начала списка.)

  Печатное представление вектора состоит из левой квадратной скобки, элементов и
правой квадратной скобки.  Это также синтаксис чтения.  Как числа и строки, векторы
считаются константами при оценки.

@example
[1 "два" (три)]      ; @r{Вектор из трех элементов.}
     @result{} [1 "два" (три)]
@end example

  @xref{Vectors}, функции, работы с векторами.

@node Char-Table Type
@subsection Тип Символ-Таблица

  @dfn{Символ-таблица} является одномерным массивом элементов любого типа,
индексированного кодами символов.  Символ-таблицы имеют определенные дополнительные
функции, делающие их более полезными для многих задач, которые включают присвоение
информации символьным кодам --- например, символ-таблица может иметь родителя и
наследовать значения по умолчанию, а также небольшое количество дополнительных слотов
для использования в специальных целях.  Символ-таблица может также указать одно
значение для целого набора символов.

@cindex @samp{#^} чтение синтаксис
  Печатное представление символ-таблицы похоже на вектор, за исключением, что есть
дополнительный символ @samp{#^} в начале.@footnote{Также встречается @samp{#^^},
используемый для суб-символ-таблиц.}

  @xref{Char-Tables}, специальные функции для работы с символ-таблицами.
Использование символ-таблиц включает:

@itemize @bullet
@item
Таблицы регистра (@pxref{Case Tables}).

@item
Таблицы категорий символов (@pxref{Categories}).

@item
Таблицы отображения (@pxref{Display Tables}).

@item
Таблицы синтаксиса (@pxref{Syntax Tables}).
@end itemize

@node Bool-Vector Type
@subsection Тип Логический-Вектор

  @dfn{Bool-вектор} является одномерным массивом, элементы которого должны быть
@code{t} или @code{nil}.

  Печатное представление логического-вектора, похоже на печатное представление строки,
за исключением того, что оно начинается с @samp{#&} с последующим указанием длины.
Строковая константа, которая следует дальше, фактически определяет содержимое
bool-вектора в виде битовой карты---каждый символ в строке содержит 8 бит, которые
определяют следующие 8 элементов bool-вектора (1 обозначает @code{t}, и 0 обозначает
@code{nil}).  Младшие значащие биты символа соответствуют младшим индексам в
bool-векторе.

@example
(make-bool-vector 3 t)
     @result{} #&3"^G"
(make-bool-vector 3 nil)
     @result{} #&3"^@@"
@end example

@noindent
Результаты имеют смысл, потому что двоичный код @samp{C-g} равен 111 и @samp{C-@@} -
это символ с кодом 0.

  Если длина не кратна 8, печатанное представление показывает дополнительные элементы,
но эти дополнительные элементы не берутся во внимание.  Например, в следующем примере,
два bool-вектора равны, поскольку используются только первые 3 бита:

@example
(equal #&3"\377" #&3"\007")
     @result{} t
@end example

@node Hash Table Type
@subsection Тип Хеш Таблица

    Хэш-таблица является очень быстрым видом таблицы поиска, чем то похожей на список,
в котором ключи сопоставляются с соответствующими значениями, но намного быстрее.
Печатное представление хэш-таблицы определяет её свойства и содержание, например:

@example
(make-hash-table)
     @result{} #s(hash-table size 65 test eql rehash-size 1.5
                             rehash-threshold 0.8125 data ())
@end example

@noindent
@xref{Hash Tables}, для получения дополнительной информации о хэш-таблицах.

@node Function Type
@subsection Тип Функция

  Lisp функция --- исполняемый код, так же как и функция в других языках
программирования.  В Lisp, в отличии от большинства языков, функция также это Lisp
объект.  Не-скомпилированая функция в Lisp является лямбда-выражением: то есть, список
первый элемент которого является символом @code{lambda} (@pxref{Lambda Expressions}).

  В большинстве языков программирования, невозможно иметь функцию без имени.  В Lisp,
функция не имеет собственного имени.  Лямбда-выражения может быть вызвано как функция,
даже если оно не имеет имени; чтобы подчеркнуть это, называется она
@dfn{анонимной функцией} (@pxref{Anonymous Functions}).  Именованная функция Lisp ---
просто символ с действительной функцией в ячейки функции (@pxref{Defining Functions}).

  В большинстве случаев функции вызываются, когда их имена записаны в Lisp выражениях
в программах Lisp.  Тем не менее, можно построить или получить объект функции во время
выполнения, а затем вызвать её с помощью примитивных функций @code{funcall} и
@code{apply}.  @xref{Calling Functions}.

@node Macro Type
@subsection Тип Макрос

  @dfn{Lisp макрос} является определенная пользователем конструкция, которая расширяет
язык Lisp.  Представляется как объект, очень похожий на функцию, но с другой
семантикой передачи аргументов.  Lisp макрос имеет вид списка, первый элемент которого
является символом @code{macro} и чей @sc{cdr} является объектом функции Lisp, включая
символ @code{lambda}.

  Объекты Lisp макрос обычно определяются с помощью встроенного @code{defmacro}
макроса, но любой список, который начинается с @code{macro}, является макросом для
Emacs.  @xref{Macros}, чтобы узнать, как написать макрос.

  @strong{Предупреждение}: Lisp макрос и клавиатурный макрос (@pxref{Keyboard Macros})
совершенно разные вещи.  Когда используется слово ``macro'' без уточнения, имеется в
виду Lisp макрос, а не клавиатурный макрос.

@node Primitive Function Type
@subsection Тип Примитивная Функция
@cindex примитивная функция

  @dfn{Примитивная функция} - функция вызывается из Lisp но написана на языке
программирования Си.  Примитивные функции также называются
@dfn{subrs (вспомогательными)} или @dfn{встроенными функциями}.  (Слово ``subr''
происходит от ``subroutine'' (подпрограмма).)  Большинство примитивных функций
оценивает все свои аргументы, при их вызове.  Примитивная функция, которая не
оценивает все свои аргументы называется @dfn{специальной формой}
(@pxref{Special Forms}).

  Для вызывающей функции не имеет значения,является ли функция примитивной.  Однако,
это имеет значение, если попытаться переопределить примитив с помощью функции,
написанной на Lisp.  Причина заключается в том, что примитивная функция может быть
вызвана непосредственно из кода C.  Вызов переопределённой функцию из Lisp будет
использовать новое определение, но вызов из кода Cи может по-прежнему использовать
встроенное определение.  Поэтому, @strong{не рекомендуется переопределять примитивные
функции}.

  Термин @dfn{функция} относится ко всем функциям Emacs, будь то написаных на Lisp или
Cи@.  @xref{Function Type}, для получения информации о функциях, написанных на Lisp.

  Примитивные функции не имеют синтаксис для чтения и печатаются в хэш-нотации с
именем подпрограммы.

@example
@group
(symbol-function 'car)          ; @r{Доступ к функции}
                                ;   @r{ячейки символа.}
     @result{} #<subr car>
(subrp (symbol-function 'car))  ; @r{Это примитивная функция?}
     @result{} t                       ; @r{Да.}
@end group
@end example

@node Byte-Code Type
@subsection Тип Двоичная Функция

@dfn{Объект двоичная функция} создаётся путём байт-компиляции кода Lisp
(@pxref{Byte Compilation}).  Внутренне, объект двоичной функции очень похож на вектор;
однако, оценщик обрабатывает этот тип данных особенно когда он появляется в вызове
функции.  @xref{Byte-Code Objects}.

  Синтаксис печатного представления и чтения для объекта скомпилированной функции
аналогичен синтаксису вектора, с дополнительным @samp{#} перед открывающейся
@samp{[}.

@node Record Type
@subsection Тип Запись

  Тип @dfn{запись} очень похож на @code{вектор}.  Тем не менее, первый элемент
используется для хранения своего типа, возвращаемого @code{type-of}.  Назначение типа
@dfn{запись}, позволить программистам создавать объекты с новыми типами, которые не
встроены в Emacs.  @xref{Records}, функции для работы с объектами запись.

@node Type Descriptors
@subsection Тип Дескриптор

  @dfn{Тип дескриптор} является @code{объектом запись}, который содержит информацию о
типе.  Слот 1 в записи должен быть символом обозначающим тип и @code{type-of}
полагается на это, чтобы вернуть тип объектов @code{запись}.  Emacs не использует
остальные слоты дескриптора; они свободны для использования расширениями Lisp.

  Примером дескриптора типа является любой экземпляр @code{cl-structure-class}.

@node Autoload Type
@subsection Тип Автозагрузка

  @dfn{Объект автозагрузки} --- это список, первым элементом которого является символ
@code{autoload}.  Хранится как определение функции символа, где он служит
заполнителем для реального определения.  Объект автозагрузка сообщает, что реальное
определение находится в файле Lisp кода, которое должно быть загружено в случае
необходимости.  Содержит имя файла, а также некоторую другую информацию о реальном
определении.

  После загрузки файла, символ должен иметь новое определение функции, которое не
является объектом автозагрузки.  Затем вызывается новое, как если бы оно было
изначально.  С точки зрения пользователя, вызов функции работает как и ожидалось,
используя определение функции в загруженном файле.

  Объект автозагрузка обычно создается с помощью функции @code{autoload}, которая
сохранит объект в функциональной ячейки символа.  @xref{Autoload}, для деталей.

@node Finalizer Type
@subsection Тип Финализатор

  @dfn{Объект финализатор} помогает коду Lisp удалять объекты, которые больше не
нужны.  Финализатор содержит объект функции Lisp.  Когда объект финализатора
становится недоступным после сбора мусора, Emacs вызывает связанный объект функции
финализатора.  Решая, доступен ли финализатор, Emacs не учитывает ссылки от самих
объектов финализаторов, что позволяет использовать финализаторы без необходимости
беспокоиться о случайно захваченной ссылки на сами финализаторы.

  Ошибки в финализаторах печатаются на @code{*Messages*}.  Emacs выполняет функцию,
связанную с данным объектом финализатором, ровно один раз, даже если эта функция не
выполняется.

@defun make-finalizer function
Создаётся объект финализатор, который будет работать с @var{function}.
@var{function} будет вызываться после сборки мусора, когда возвращённый
объект финализатора становится недоступным.  Если объект финализатора
доступен только через ссылку из объектов финализатора, он не считается
достижимым с целью принятия решения, будет ли запущенна @var{function}.
@var{function} будет выполняться один раз для каждого объекта финализатора.
@end defun

@node Editing Types
@section Типы Редактирования
@cindex редактирование типы

  Типы в предыдущем разделе, используются для общих целей программирования и
большинство из них являются общими для большинства Lisp диалектов.  Emacs Lisp
предоставляет несколько дополнительных типов данных для целей, связанных с
редактированием.

@menu
* Buffer Type::         Основной объект редактирования.
* Marker Type::         Позиция в буфере.
* Window Type::         Буферы отображаются в окнах.
* Frame Type::          Окна подразделяют фреймы.
* Terminal Type::       Терминальное устройство отображает фреймы.
* Window Configuration Type::   Запись способа разделения фрейма.
* Frame Configuration Type::    Запись состояния всех фреймов.
* Process Type::        Подпроцесс Emacs работает на базовой ОС.
* Thread Type::         Поток исполнения Emacs Lisp.
* Mutex Type::          Исключительная блокировка для синхронизации потоков.
* Condition Variable Type::     Переменная условия для синхронизации потоков.
* Stream Type::         Получить или отправить символы.
* Keymap Type::         Какую функцию вызывает нажатия клавиши.
* Overlay Type::        Как представляется наложение.
* Font Type::           Шрифты для отображения текста.
@end menu

@node Buffer Type
@subsection Тип Буфер

  @dfn{Буфер} представляет собой объект, содержащий текст, который может быть
отредактирован (@pxref{Buffers}).  Большинство буферов содержат содержимое файла на
диске (@pxref{Files}) таким образом они могут быть отредактированы, но некоторые из
них используются для других целей.  Большая часть буферов также предназначены, чтобы
их видел пользователь, и поэтому они отображаются, в какой-то момент, в окне
(@pxref{Windows}).  Но буфер можно не отображать в окне.  Каждый буфер имеет
обозначенное положение, называемое @dfn{точкой} (@pxref{Positions}); большинство
команд редактирования действует на содержимом текущего буфера в окрестностях точки.
В любое время, один буфер является @dfn{текущим буфером}.

  Содержимое буфера очень похоже на строку, но буферы не используются, как строки в
Emacs Lisp, и доступные операции для них отличны.  Например, можно эффективно вставить
текст  в существующий буфер, изменяя содержимое буфера, в то время как вставки текста
в строку требуют конкатенаций подстрок, и в результат получается совсем новый объект
строки.

  Многие из стандартных функций Emacs манипулируют или проверяют символы в текущем
буфере; целая глава в этом руководстве посвящена описанию этих функций (@pxref{Text}).

  С каждым буфером связано несколько других структур данных:

@itemize @bullet
@item
локальная таблица синтаксиса (@pxref{Syntax Tables});

@item
локальная ключевая карта (@pxref{Keymaps}); и,

@item
список привязок локальных переменных буфера (@pxref{Buffer-Local Variables}).

@item
наложения (@pxref{Overlays}).

@item
свойства текста для текста в буфере (@pxref{Text Properties}).
@end itemize

@noindent
Локальная ключевая карта и список переменных содержат записи, которые по
отдельности индивидуально переопределяют глобальные привязки или значения.
Они используются для настройки поведения программ в различных буферах,
фактически не изменяя программы.

  Буфер может быть @dfn{косвенным}, что означает, что он разделяет текст другого
буфера, но представляет его по-другому.  @xref{Indirect Buffers}.

  У буферов нет синтаксиса чтения.  Они печатаются в хэш-нотации, с указанием имени
буфера.

@example
@group
(current-buffer)
     @result{} #<buffer objects.texi>
@end group
@end example

@node Marker Type
@subsection Тип Маркер

  @dfn{Маркер} обозначает положение в конкретном буфере.  Таким образом, маркеры имеют
два компонента: один для буфера, и один для позиции.  Изменения в тексте буфера
автоматически перемещают значение позиции по мере необходимости, чтобы маркер всегда
указывал между одними и теми же двумя символами в буфере.

  Маркеры не имеют синтаксиса чтения.  Они печатаются в хэш-нотации, указывая текущую
позицию символа и имя буфера.

@example
@group
(point-marker)
     @result{} #<marker at 10779 in objects.texi>
@end group
@end example

@xref{Markers}, для получения информации о том, как тестировать, создавать,
копировать и перемещать маркеры.

@node Window Type
@subsection Тип Окно

  @dfn{Окно} описывает часть экрана терминала, которое Emacs использует для
отображения буфера.  Каждое окно имеет один связанный с ним буфер, содержимое которого
отображается в окне.  В отличие от этого, данный буфер может появиться в одном окне,
без окна или в нескольких окнах.

  Хотя многие окна могут существовать одновременно, в любой момент времени одно окно
назначается @dfn{выбранным окноа}.  Это окно, в котором (обычно) отображается курсор,
когда Emacs готов для выполнения команды.  Выбранное окно обычно отображает текущий
буфер (@pxref{Current Buffer}), но это не обязательно так.

  Окна группируются на экране в фреймы; каждое окно принадлежит одному и только одному
фрейму.  @xref{Frame Type}.

  Окна не предоставляют синтаксис чтения.  Они печатаются в хэш-нотации, давая номер
окна и имя отображаемого буфера.  Номера окон существует для однозначной идентификации
окна, так как буфер, отображаемый в любом заданном окне, может часто меняться.

@example
@group
(selected-window)
     @result{} #<window 1 on objects.texi>
@end group
@end example

  @xref{Windows}, для описания функций, которые работают с окнами.

@node Frame Type
@subsection Тип Фрейм

  @dfn{Фрейм} это область экрана, которая содержит один или несколько окон Emacs;
также используется термин ``фрейм'' для обозначения объекта Lisp, который Emacs
использует для обозначения области экрана.

  У фрейма нет синтаксиса чтения.  Он печатается в хэш-нотации, давая название фрейма,
а также его адрес в ядре (полезно для уникальной идентификации фрейма).

@example
@group
(selected-frame)
     @result{} #<frame emacs@@psilocin.gnu.org 0xdac80>
@end group
@end example

  @xref{Frames}, для описания функций, работы с фреймами.

@node Terminal Type
@subsection Тип Терминал
@cindex terminal type

  @dfn{Терминал} является устройством, способным отображать один или несколько фреймов
Emacs (@pxref{Frame Type}).

  Терминалы не имеет синтаксиса чтения.  Они печатаются в хэш-нотации с указанием
порядкового номера терминала и его имени файла устройства TTY.

@example
@group
(get-device-terminal nil)
     @result{} #<terminal 1 on /dev/tty>
@end group
@end example

@c ИСПРАВТЕ МЕНЯ: добавте внешнюю ссылку, если терминал связанн с
@c описанием примитивов.

@node Window Configuration Type
@subsection Тип Конфигурация Окна
@cindex window layout in a frame

  @dfn{Конфигурация окна} хранит информацию о позиции, размерах и содержимого окна в
фрейме, так что можно воссоздать то же расположение окон позже.

  Конфигурация окна не имеет синтаксиса чтения; синтаксис печати выглядит
@samp{#<window-configuration>}.  @xref{Window Configurations}, для описания нескольких
функций, связанных с оконными конфигурациями.

@node Frame Configuration Type
@subsection Тип Конфигурация Фрейма
@cindex макет экрана
@cindex расположение окон, все фреймы

  @dfn{Конфигурация фрейма} хранит информацию о позиции, размерах и содержимого всех
окон во фрейме.  Это не примитивный тип --- это на самом деле список, чей @sc{car}
является @code{frame-configuration} а @sc{cdr} является ассоциативным списком.  Каждый
элемент этого ALIST описывает один фрейм, который появляется как @sc{car} этого
элемента.

  @xref{Frame Configurations}, для описания нескольких функций, связанных
с конфигурацией фреймов.

@node Process Type
@subsection Тип Процесс

  Слово @dfn{процесс} обычно означает запущенную программу.  Сам Emacs запускается в
процессе такого рода.  Однако, в Emacs Lisp, процесс является объектом Lisp, что
обозначает подпроцесс, созданный в процессе Emacs.  Такие программы, как shells, GDB,
ftp, и компиляторы, работающие в подпроцессах Emacs, расширяют возможности Emacs.
Подпроцесс Emacs принимает текстовый ввод из Emacs и возвращает текстовый вывод в
Emacs для дальнейших манипуляций.  Emacs также может посылать сигналы подпроцессу.

  У объекта типа процесс нет синтаксиса чтения.  Он печатается в хэш-нотации,
печатая имя процесса:

@example
@group
(process-list)
     @result{} (#<process shell>)
@end group
@end example

@xref{Processes}, для получения информации о функциях, которые могут создавать,
удалять, возвращать информацию, отправлять входные данные или сигналы и получать
выходные данные от процессов.

@node Thread Type
@subsection Тип Нитевой Поток

  @dfn{Нитевой Поток} в Emacs представляет собой отдельный поток выполнения Emacs
Lisp.  Он запускает свою собственную программу на Lisp, имеет свой собственный текущий
буфер, и может иметь заблокированные подпроцессы, то есть@: подпроцессы, вывод которых
может принимать только этот поток.  @xref{Threads}.

  У объекта типа нитевой поток нет синтаксиса чтения.  Он печатается в хэш-нотации,
выдавая имя потока (если имя было задано) или его адрес в ядре:

@example
@group
(all-threads)
    @result{} (#<thread 0176fc40>)
@end group
@end example

@node Mutex Type
@subsection Тип Мьютекс

  @dfn{Мьютекс} (Блокировки взаимного исключения) является эксклюзивной блокировкой,
чтобы дать возможность потокам устанавливать и снимать блокировку для синхронизации
данных между потоками.  @xref{Mutexes}.

  Объект Мьютекс не имеет синтаксиса чтения.  Печатается в хэш-нотации, давая имя
мьютекса (если ему было присвоено имя) или его адрес в ядре:

@example
@group
(make-mutex "my-mutex")
    @result{} #<mutex my-mutex>
(make-mutex)
    @result{} #<mutex 01c7e4e0>
@end group
@end example

@node Condition Variable Type
@subsection Тип Переменная Состояния

  @dfn{Переменная состояния} представляет собой средство для более сложной
синхронизации потоков, чем, поддержание взаимной блокировки.  Поток может ожидать
переменного состояния, чтобы отреагировать, когда другой поток уведомит о состоянии.

  Объект переменная состояния не имеет синтаксиса для чтения.  Он печатается в
хэш-нотации, давая имя переменной состояния (если оно было задано) или её адрес в
ядре:

@example
@group
(make-condition-variable (make-mutex))
    @result{} #<condvar 01c45ae8>
@end group
@end example

@node Stream Type
@subsection Тип Поток

  @dfn{Поток} это объект, который может быть использован в качестве источника или
приёмника символов---либо символов поставки для ввода или принятия их в качестве
выходного сигнала.  Много различных типов могут быть использованы таким образом:
маркеры, буфера, строки и функции.  Чаще всего, потоки ввода (источники символов)
являются символы клавиатуры, буфера, файлы а потоки выводов (приёмники
символов) отправляют символы в буфер, такие как буфер @file{*Help*}, или в эхо
область.

  Объект @code{nil}, в дополнение к другим его значениям, может быть использован в
качестве потока.  Он обозначает значение переменной @code{standard-input} или
@code{standard-output}.  Кроме того, объект @code{t} в виде потока указует вход с
использованием минибуфера (@pxref{Minibuffers}) или вывод в эхо область
(@pxref{The Echo Area}).

  Потоки не имеют специального печатного представления или синтаксиса чтения и
печатаются как любой примитивный тип.

  @xref{Read and Print}, для описания функций, связанных с потоками, включая функции
синтаксического анализа и печати.

@node Keymap Type
@subsection Тип Ключевая Карта

  @dfn{Ключевая Карта}, вводимые пользователем команды.  Это отображение определяет,
как выполняется ввод команды пользователя.  Ключевая карта на самом деле список, чей
@sc{car} является символом @code{keymap}.

  @xref{Keymaps}, для информации о создании ключевых карт, обработки префиксных
ключей, локальных и глобальных карт, а также об изменении ключевых привязок.

@node Overlay Type
@subsection Тип Наложение

  @dfn{Наложение} определяет свойства, которые относятся к части буфера. Каждое
наложение относится к заданному диапазону буфера, и содержит список свойств (список,
элементы которого представляет собой чередующиеся имена и значение свойств).  Свойства
наложения используется для временного представления частей буфера в другом стиле
отображения.  Объект наложение не имеет синтаксиса для чтения и печатается в
хэш-нотации с указанием имени буфера и диапазона позиций.

  @xref{Overlays}, информация о том, как можно создавать и использовать наложение.

@node Font Type
@subsection Тип Шрифт

  @dfn{Шрифт} определяет, как отображать текст на графическом терминале.
Есть на самом деле три отдельные типы шрифтов --- @dfn{объект шрифта},
@dfn{спецификация шрифта} и @dfn{отображение шрифта}--- каждый из которых имеет
несколько различных свойств.  Ни один из них не имеют синтаксис для чтения; их
синтаксис печати выглядит @samp{#<font-object>}, @samp{#<font-spec>}, и
@samp{#<font-entity>} соответственно.  @xref{Low-Level Font}, для описания этих
объектов Lisp.

@node Circular Objects
@section Синтаксис Чтения Закольцованных Объектов
@cindex циклическая структура, синтаксис чтения
@cindex общая структура, синтаксис чтения
@cindex @samp{#@var{n}=} синтаксис чтения
@cindex @samp{#@var{n}#} синтаксис чтения

  Для того, чтобы представлять общие или циклические структуры в комплексе объектов
Lisp, можно использовать конструкции чтения @samp{#@var{n}=} и @samp{#@var{n}#}.

  Использовать @code{#@var{n}=} перед объектом, чтобы пометить его для дальнейшего
использования; впоследствии, можно использовать @code{#@var{n}#} для ссылки на тот же
объект в другом месте.  Здесь @var{n} некоторое целое число.  Например, вот как
сделать список, в котором первый элемент повторяется в качестве третьего элемента:

@example
(#1=(a) b #1#)
@end example

@noindent
Это отличается от обычного синтаксиса, такого как этот

@example
((a) b (a))
@end example

@noindent
что приведёт к списку, первый и третий элементы которого выглядят одинаково, но не
являются одним и тем же объектом Lisp.  Это показывает разницу:

@example
(prog1 nil
  (setq x '(#1=(a) b #1#)))
(eq (nth 0 x) (nth 2 x))
     @result{} t
(setq x '((a) b (a)))
(eq (nth 0 x) (nth 2 x))
     @result{} nil
@end example

  Кроме того, можно использовать тот же синтаксис, чтобы сделать цикличесую структуру,
которая появляется как элемент внутри себя.  Вот пример:

@example
#1=(a #1#)
@end example

@noindent
Это делает список, вторым элементом которого является сам список.  Вот как можно
видеть, что это действительно так:

@example
(prog1 nil
  (setq x '#1=(a #1#)))
(eq x (cadr x))
     @result{} t
@end example

  Lisp-чтение может использовать этот синтаксис для записи циклических и общих
структур объектов Lisp, если связать переменную @code{print-circle} с не-@code{nil}
значением.  @xref{Output Variables}.

@node Type Predicates
@section Тип Предикат
@cindex проверка типа
@kindex wrong-type-argument

  Emacs Lisp интерпретатор сам по себе не выполняет проверку типов фактических
аргументов, передаваемых функциям при их вызове.  Он не может сделать это, так как
аргументы функции в Lisp не имеют объявленных типов данных, как в других языках
программирования.  Именно поэтому, каждая функция должна проверять, принадлежит ли
каждый фактический аргумент типу, которая функция может использовать.

  Все встроенные функции при необходимости проверяют типы своих фактических
аргументов и сигнализируют об ошибки @code{wrong-type-argument}, если аргумент имеет
неправильный тип.  Например, вот что происходит, если передать аргумент @code{+},
который он не может работать:

@example
@group
(+ 2 'a)
     @error{} Wrong type argument: number-or-marker-p, a
@end group
@end example

@cindex предикаты типа
@cindex виды тестирования
  Если требуется, чтобы программа по-разному обрабатывала различные типы, потребуется
явная проверка типов.  Наиболее распространенный способ проверить тип объекта, вызвать
функцию @dfn{тип предиката}.  Emacs имеет тип предиката для каждого типа, а также
некоторые предикаты для комбинаций типов.

  Функция типа предиката принимает один аргумент; возвращает @code{t}, если аргумент
принадлежит к соответствующему типу и @code{nil} в противном случае.  Следуя общему
соглашению Lisp, имена для большинства функций типа предиката заканчиваются на
@samp{p}.

  Вот пример, который использует предикаты @code{listp} для проверки списка
и @code{symbolp} для проверки символа.

@example
(defun add-on (x)
  (cond ((symbolp x)
         ;; Если @code{x} символ, поместить его в LIST.
         (setq list (cons x list)))
        ((listp x)
         ;; Если @code{x} список, добавить его элементы в LIST.
         (setq list (append x list)))
        (t
         ;; Обрабатываются только символы и списки.
         (error "Неверный аргумент %s для добавления" x))))
@end example

  Вот таблица предопределенных предикатов типа, в алфавитном порядке, со
ссылками на дополнительную информацию.

@table @code
@item atom
@xref{List-related Predicates, atom}.

@item arrayp
@xref{Array Functions, arrayp}.

@item bool-vector-p
@xref{Bool-Vectors, bool-vector-p}.

@item booleanp
@xref{nil and t, booleanp}.

@item bufferp
@xref{Buffer Basics, bufferp}.

@item byte-code-function-p
@xref{Byte-Code Type, byte-code-function-p}.

@item case-table-p
@xref{Case Tables, case-table-p}.

@item char-or-string-p
@xref{Predicates for Strings, char-or-string-p}.

@item char-table-p
@xref{Char-Tables, char-table-p}.

@item commandp
@xref{Interactive Call, commandp}.

@item condition-variable-p
@xref{Condition Variables, condition-variable-p}.

@item consp
@xref{List-related Predicates, consp}.

@item custom-variable-p
@xref{Variable Definitions, custom-variable-p}.

@item floatp
@xref{Predicates on Numbers, floatp}.

@item fontp
@xref{Low-Level Font}.

@item frame-configuration-p
@xref{Frame Configurations, frame-configuration-p}.

@item frame-live-p
@xref{Deleting Frames, frame-live-p}.

@item framep
@xref{Frames, framep}.

@item functionp
@xref{Functions, functionp}.

@item hash-table-p
@xref{Other Hash, hash-table-p}.

@item integer-or-marker-p
@xref{Predicates on Markers, integer-or-marker-p}.

@item integerp
@xref{Predicates on Numbers, integerp}.

@item keymapp
@xref{Creating Keymaps, keymapp}.

@item keywordp
@xref{Constant Variables}.

@item listp
@xref{List-related Predicates, listp}.

@item markerp
@xref{Predicates on Markers, markerp}.

@item mutexp
@xref{Mutexes, mutexp}.

@item nlistp
@xref{List-related Predicates, nlistp}.

@item number-or-marker-p
@xref{Predicates on Markers, number-or-marker-p}.

@item numberp
@xref{Predicates on Numbers, numberp}.

@item overlayp
@xref{Overlays, overlayp}.

@item processp
@xref{Processes, processp}.

@item recordp
@xref{Record Type, recordp}.

@item sequencep
@xref{Sequence Functions, sequencep}.

@item string-or-null-p
@xref{Predicates for Strings, string-or-null-p}.

@item stringp
@xref{Predicates for Strings, stringp}.

@item subrp
@xref{Function Cells, subrp}.

@item symbolp
@xref{Symbols, symbolp}.

@item syntax-table-p
@xref{Syntax Tables, syntax-table-p}.

@item threadp
@xref{Basic Thread Functions, threadp}.

@item vectorp
@xref{Vectors, vectorp}.

@item wholenump
@xref{Predicates on Numbers, wholenump}.

@item window-configuration-p
@xref{Window Configurations, window-configuration-p}.

@item window-live-p
@xref{Deleting Windows, window-live-p}.

@item windowp
@xref{Basic Windows, windowp}.
@end table

  Наиболее общий способ проверить тип объекта, вызвать функцию @code{type-of}.
Напоминание, каждый объект может принадлежит к одному и только одному примитивному
типу; @code{type-of} сообщит, к какому именно из них (@pxref{Lisp Data Types}).
Но @code{type-of} ничего не знает о непримитивных типах.  В большинстве случаев
удобнее использовать предикаты типа, чем @code{type-of}.

@defun type-of object
Функция возвращает именованный символ примитивного типа @var{object}.  Значение одного
из символов @code{bool-vector}, @code{buffer}, @code{char-table},
@code{compiled-function}, @code{condition-variable}, @code{cons}, @code{finalizer},
@code{float}, @code{font-entity}, @code{font-object},
@code{font-spec}, @code{frame}, @code{hash-table}, @code{integer},
@code{marker}, @code{mutex}, @code{overlay}, @code{process},
@code{string}, @code{subr}, @code{symbol}, @code{thread},
@code{vector}, @code{window} или @code{window-configuration}.  Однако, если
@var{object} представляет собой запись, то возвращается тип заданный в его первом
слоте; @ref{Records}.

@example
(type-of 1)
     @result{} integer
@group
(type-of 'nil)
     @result{} symbol
(type-of '())    ; @r{@code{()} это @code{nil}.}
     @result{} symbol
(type-of '(x))
     @result{} cons
(type-of (record 'foo))
     @result{} foo
@end group
@end example
@end defun

@node Equality Predicates
@section Предикаты Равенства
@cindex равенство

  Здесь описываются функции, которые проверяют равенство между двумя объектами.
Другие функции проверяют равенство содержимого между объектами определенных типов,
например, строки.  Для этих предикатов, смотреть соответствующий раздел, описывающий
тип данных.

@defun eq object1 object2
Функция возвращает @code{t} если @var{object1} и @var{object2} являются тем же
объектом, и @code{nil} в противном случае.

Если @var{object1} и @var{object2} представляют собой целые числа с одинаковым
значением, они считаются тем же объектом (то есть @code{eq} возвращает @code{t}).
Если @var{object1} и @var{object2} это символы с одинаковыми именами, то они, как
правило, представляют один и тот же объект --- чтобы увидеть исключения
@ref{Creating Symbols}.  Для других типов (например, списки, векторы, строки), два
аргумента с тем же содержимым или элементами не обязательно @code{eq} друг с другом:
они @code{eq} только если они есть один и тот же объект, а это означает, что изменение
в содержании одного отразится на содержании другого.

@example
@group
(eq 'foo 'foo)
     @result{} t
@end group

@group
(eq 456 456)
     @result{} t
@end group

@group
(eq "asdf" "asdf")
     @result{} nil
@end group

@group
(eq "" "")
     @result{} t
;; @r{Это исключение происходит потому, что Emacs Lisp делает только одну}
;; @r{многобайтовую пустую строку, для экономии места.}
@end group

@group
(eq '(1 (2 (3))) '(1 (2 (3))))
     @result{} nil
@end group

@group
(setq foo '(1 (2 (3))))
     @result{} (1 (2 (3)))
(eq foo foo)
     @result{} t
(eq foo '(1 (2 (3))))
     @result{} nil
@end group

@group
(eq [(1 2) 3] [(1 2) 3])
     @result{} nil
@end group

@group
(eq (point-marker) (point-marker))
     @result{} nil
@end group
@end example

@noindent
Функция @code{make-symbol} возвращает интернированый символ, отличный от символа,
который используется, если пишется имя в выражении Lisp.  Символы с одним и тем же
именем это ещё не залог равенства @code{eq}.  @xref{Creating Symbols}.

@example
@group
(eq (make-symbol "foo") 'foo)
     @result{} nil
@end group
@end example

@noindent
@cindex объекты с идентичным содержимым и байтовый компилятор
@cindex объекты с одинаковым содержимым и байт-компилятор
Emacs Lisp байт компилятор может сворачивать идентичные литеральные объекты,
такие как текстовые строки, в ссылки на один и тот же объект, с эффектом,
что скомпилированный байт-код будет сравнивать такие объекты, как @code{eq},
в то время как в интерпретируемой версии того же самого кода и эффекта
не будет.  Таким образом, код никогда не должен полагаться на объекты с одним и тем
же буквальным содержанием, сравниваемый либо @code{eq}, либо
не @code{eq}, вместо этого следует использовать функции, которые сравнивают
содержимое объекта, как @code{equal}, описанными ниже.  Кроме того, код
не должен изменять литеральных объектов (например, помещать текстовые свойства в
литеральные строки), поскольку это может повлиять на другие литеральные объекты одного
и того же содержания, если байт компилятор свернёт их.
@end defun

@defun equal object1 object2
Функция возвращает @code{t} если @var{object1} и @var{object2} имеют
равные компоненты, и @code{nil} в противном случае.  В то время как
@code{eq} проверяет, являются ли его аргументы одним и тем же объектом,
@code{equal} просматривает неидентичные аргументы, чтобы увидеть, совпадают
ли их элементы или содержание.  Таким образом, если два объекта @code{eq},
они всегда @code{equal}, но обратное не всегда верно.

@example
@group
(equal 'foo 'foo)
     @result{} t
@end group

@group
(equal 456 456)
     @result{} t
@end group

@group
(equal "asdf" "asdf")
     @result{} t
@end group
@group
(eq "asdf" "asdf")
     @result{} nil
@end group

@group
(equal '(1 (2 (3))) '(1 (2 (3))))
     @result{} t
@end group
@group
(eq '(1 (2 (3))) '(1 (2 (3))))
     @result{} nil
@end group

@group
(equal [(1 2) 3] [(1 2) 3])
     @result{} t
@end group
@group
(eq [(1 2) 3] [(1 2) 3])
     @result{} nil
@end group

@group
(equal (point-marker) (point-marker))
     @result{} t
@end group

@group
(eq (point-marker) (point-marker))
     @result{} nil
@end group
@end example

Сравнение строк чувствительно к регистру, но не учитывает свойств текста
--- это сравнивает только символы в строках.  @xref{Text Properties}.
Использование @code{equal-including-properties} также сравнивает свойства
текста.  По техническим причинам, однобайтная и многобайтовая строка
являются @code{equal} тогда и только тогда, когда они содержат одну и ту же
последовательность кодов символов, и все эти коды находятся в диапазоне
от 0 до 127 (@acronym{ASCII}).

@example
@group
(equal "asdf" "ASDF")
     @result{} nil
@end group
@end example

Тем не менее, два различных буфера никогда не считается @code{equal}, даже
если их текстовое содержани является одинаковым.
@end defun

  Тест на равенство реализуется рекурсивно; например, даны две cons-ячейки
@var{x} и @var{y}, @code{(equal @var{x} @var{y})} возвращает @code{t} тогда и только
тогда, когда оба выражения ниже возвращают @code{t}:

@example
(equal (car @var{x}) (car @var{y}))
(equal (cdr @var{x}) (cdr @var{y}))
@end example

Из-за этого рекурсивного метода, циклические списки могут, следовательно, вызвать
бесконечную рекурсию (что приводит к ошибке).

@defun equal-including-properties object1 object2
Функция ведет себя как @code{equal} во всех случаях, но также требует, чтобы две
сравниваемые строки, имели одинаковые свойства текста.

@example
@group
(equal "asdf" (propertize "asdf" 'asdf t))
     @result{} t
@end group
@group
(equal-including-properties "asdf"
                            (propertize "asdf" 'asdf t))
     @result{} nil
@end group
@end example
@end defun
