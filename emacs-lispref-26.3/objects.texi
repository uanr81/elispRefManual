@c -*- mode: texinfo; coding: utf-8 -*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2019 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Lisp Data Types
@chapter Типы Данных Lisp
@cindex object
@cindex Lisp object
@cindex type
@cindex data type

  Lisp @dfn{объект} представляет собой часть данных, которые использует
  и которыми манипулируют программы Лиспа. Для наших целей, @dfn{тип}
  или @dfn{тип данных} представляет собой набор возможных объектов.

  Каждый объект принадлежит, по крайней мере, к одному типу. Объекты одного
  типа имеют сходные структуры и, как правило, могут быть использованы в
  одних и тех же контекстах.  Типы могут пересекаться, и объекты могут
  принадлежать двум или более типам.  Следовательно, мы можем спросить,
  принадлежит ли объект к определенному типу, но не какого @dfn{типа} объект.

@cindex primitive type
  В Emacs встроено несколько основных типов объектов.  Из этих типов строятся все
  остальные типы, они называются @dfn{примитивными типами}.  Каждый из таких объектов
  принадлежит одному и только одному элементарному типу. Эти типы включают
  @dfn{целочисленное}, @dfn{число с плавающей точкой}, @dfn{cons-ячейка},
  @dfn{символ},@dfn{строка}, @dfn{вектор}, @dfn{хеш-таблица}, @dfn{subr},
  @dfn{скомпилированная функция}, @dfn{запись}, а также несколько специальных,
  таких как @dfn{buffer}, которые связаны с редактированием.
  (@xref{Editing Types}.)

  Каждый примитивный тип имеет соответствующую функцию Lisp, которая проверяет,
  является ли объект членом этого типа.

  Отличие Lisp от многих других языков, в том, что его объекты
  @dfn{self-typing (самотипирующие)}: примитивный тип каждого объекта неявен
  в самом объекте. Например, если объект является вектором, ничто не может
  рассматривать его как число; Lisp знает, что это вектор, а не число.

  В большинстве языков, программист должен объявить тип данных каждой переменной,
  и этот тип известен компилятору, но не представлен в данных. Такие заявления
  типов не существует в Emacs Lisp. Переменная Lisp может иметь любой тип значения,
  и она запоминает любое значение, которое вы в ней храните. (На самом деле,
  небольшое количество Emacs Lisp переменных может принимать только значение
  определенного типа. @xref{Variables with Restricted Values}.)

  В этой главе описывается назначение, печатное представление, синтаксис чтения
  каждого из стандартных типов в GNU Emacs Lisp. Подробности о том, как
  использовать эти типы могут быть найдены в следующих главах.

@menu
* Printed Representation::      Как Lisp объекты представлены в виде текста.
* Comments::                    Комментарии и правила их форматирования.
* Programming Types::           Типы встречающиеся во всех системах Lisp.
* Editing Types::               Типы специфичные для Emacs.
* Circular Objects::            Синтаксис чтения для циклических структур.
* Type Predicates::             Тесты, связь с типами.
* Equality Predicates::         Проверка равенства между любыми двумя объектами.
@end menu

@node Printed Representation
@section Печатное Представление и Чтение Синтаксиса
@cindex printed representation
@cindex read syntax

  @dfn{Печатное представление (print)} объекта является форматом выходного сигнала,
  генерируемого лисповсим принтером (функция @code{prin1}) для этого объекта.
  Каждый тип данных имеет уникальное печатное представление. @dfn{чтение синтаксиса}
  объекта является форматом ввода, принятого лисповским читателем (функция @code{read})
  для этого объекта. Это не обязательно является уникальным; многие типы объектов
  имеют более одного синтаксиса.  @xref{Read and Print}.

@cindex hash notation
  В большинстве случаев, печатное представление объекта, является также синтаксисом
  чтения для объекта. Однако, у некоторых типов нет синтаксиса чтения, поскольку нет
  смысла вводить оьъекты этих типов как константы в программе на Lisp. Эти объекты
  печатаются как @dfn{хеш-нотации}, состоящей из символов @samp{#<}, описательная
  строка (как правило, после имени типа следует имя объекта), и завершающей @samp{>}.
  Например:

@example
(current-buffer)
     @result{} #<buffer objects.texi>
@end example

@noindent
Хеш-нотация вообще не может быть прочитана, так что читатель Lisp сигнализирует
об ошибке @code{invalid-read-syntax} всякий раз, когда он встречает @samp{#<}.
@kindex invalid-read-syntax

  В других языках выражение - это текст; у него нет другой формы. В Lisp
  выражение - это прежде всего объект Lisp, и только потом текст, который
  является синтаксисом чтения объекта. Часто нет необходимости подчеркивать
  это различие, но вы всегда должны помнить об этом, иначе вы иногда будете
  сильно сбиты с толку.

  Когда вы вычислите выражение в интерактивном режиме, интерпретатор Lisp
  сначала считывает его текстовое представление, создавая объект Lisp,
  а затем оценивает этот объект (@pxref{Evaluation}). Тем не менее,
  оценка и чтение являются отдельными видами деятельности. Чтение
  возвращает объект Lisp, прочитанный из текстового представления;
  объект может оценён или не оценен позже. @xref{Input Functions},
  для описания @code{read}, основной функции для чтения объектов.

@node Comments
@section Коментарии
@cindex comments
@cindex @samp{;} for commenting

  @dfn{Коментарий} это текст, который написан в программе только ради людей,
  которые читают эту программу, и это не имеет никакого влияния на смысл
  программы. В Lisp, неэкранированная точка с запятой (@samp{;}) начинает
  комментарий, если он не находится внутри строковой или символьной константы.
  Комментарий продолжается до конца строки. Lisp читатель отбрасывает комментарии;
  они не становятся частью объектов Лиспа, которые представляют программу
  в рамках системы Lisp.

  @samp{#@@@var{count}} конструкция, которая пропускает следующие символы
  @var{count}, полезна для сгенерированных комментариев программой,
  содержащих двоичные данные. Emacs Lisp это в своих выходных файлах
  (@pxref{Byte Compilation}). Однако она не предназначена для исходных файлов.

  @xref{Comment Tips}, соглашения о форматировании комментариев.

@node Programming Types
@section Програмные Типы
@cindex programming types

  Есть две основные категории типов в Emacs Lisp: те, которые имеют дело с
  программированием на Lisp, и те, которые имеют дело с редактированием.
  Первые существует во многих реализациях Lisp, в той или иной форме.
  Последние являются уникальными для Emacs Lisp.

@menu
* Integer Type::        Числа без дробных частей.
* Floating-Point Type:: Числа с дробными частями и с большим диапазоном.
* Character Type::      Представление букв, цифр и управляющих символов.
* Symbol Type::         Многофункциональный объект, который ссылается на функцию,
                        переменную или список свойств, и имеет уникальный идентификатор.
* Sequence Type::       Списки и Массивы классифицируются как последовательности.
* Cons Cell Type::      Cons-ячейки, а также списки (которые сделаны из cons-ячеек).
* Array Type::          Массивы включают строки и векторы.
* String Type::         (Эффективный) массив символов.
* Vector Type::         Одномерные массивы.
* Char-Table Type::     Одномерные разреженные массивы, индексированные по символам.
* Bool-Vector Type::    Одномерные массивы @code{t} или @code{nil}.
* Hash Table Type::     Сверх-быстрые таблицы поиска.
* Function Type::       Фрагмент исполняемого, который можно вызвать из любого места.
* Macro Type::          Метод расширения выражения в другое выражение, более
                        фундаментального, но менее красивое.
* Primitive Function Type::     Функция написана в C, вызываемая из Lisp.
* Byte-Code Type::      Функция написана на Lisp, затем скомпилированная.
* Record Type::         Составные объекты с определенным программистом типами.
* Type Descriptors::    Объекты хранения информации о типах.
* Autoload Type::       Тип используется для автоматической загрузки редко используемых функций.
* Finalizer Type::      Не Запускается код больше, если не доступен.

@end menu

@node Integer Type
@subsection Целочисленный Тип

  Диапазон значений для целого числа зависит от машины. Минимальный диапазон
  составляет от @minus{}536,870,912 to 536,870,911 (30 bits; i.e.,
@ifnottex
@minus{}2**29
@end ifnottex
@tex
@math{-2^{29}}
@end tex
до
@ifnottex
2**29 @minus{} 1)
@end ifnottex
@tex
@math{2^{29}-1})
@end tex
но многие машины обеспечивают более широкий диапазон.
Emacs Lisp арифметические функции не проверяют целочисленное переполнение.
Таким образом, @code{(1+ 536870911)} получается @minus{}536,870,912,
если целые числа Emacs составляют 30 бит.

  Синтаксис чтения для целых чисел представляет собой последовательность цифр
  (по основанию десять) с необязательным знаком в начале и дополнительной
  точкой в конце. Печатное представление, созданное интерпретатором Лиспа,
  никогда не имеет ведущего символа @samp{+} или конечного @samp{.}.

@example
@group
-1               ; @r{Целое число @minus{}1.}
1                ; @r{Целое число 1.}
1.               ; @r{Также Целое число 1.}
+1               ; @r{Также Целое число 1.}
@end group
@end example

@noindent
В качестве особого исключения, если последовательность цифр определящая целое
число слишком большая или слишком мала, чтобы быть допустимым целочисленным
объектом, читатель Лисп считывает его как число с плавающей точкой
(@pxref{Floating-Point Type}). Например, если Emacs целые равны 30 бит,
@code{536870912} считывается как число с плавающей точкой @code{536870912.0}.

  @xref{Numbers}, для детальной информации.

@node Floating-Point Type
@subsection Тип Число с Плавающей Точкой

  Числа с плавающей точкой являются компьютерным эквивалентом научной нотации;
  Вы можете думать о числе с плавающей точкой как о дроби со степенью десять.
  Точное число значащих цифр и диапазон возможных показателей зависит от
  машины; Emacs использует тип данных C @code{double} для хранения значения,
  и внутренне он записывает степень 2, а не степень 10.

  Печатное представление для чисел с плавающей точкой требует либо десятичной
  точки (с как минимум с дной следующей цифрой), либо экспоненты, либо того и
  другого. Например, @samp{1500.0}, @samp{+15e2}, @samp{15.0e+2},@samp{+1500000e-3}
  и @samp{.15e4} представляют собой пять способов записи числа с плавающей точкой,
  значение которого 1500. Все они эквивалентны.

  @xref{Numbers}, для детальной информации.

@node Character Type
@subsection Символьные Типы
@cindex @acronym{ASCII} character codes

  @dfn{Символы} в Emacs Lisp - не более чем целое число. Другими словами,
  символы представлены их кодами символов. Например, @kbd{A} символ
  представлен как @w{integer 65}.

  Отдельные символы используются иногда в программах, но чаще для работы
  с @emph{strings}, которые представляют собой последовательности,
  состоящие из символов.  @xref{String Type}.

  Символы в строках и буферах в настоящее время ограничены в диапазоном
  от 0 до 4194303 --- двадцать два бита (@pxref{Character Codes}).
  Коды от 0 до 127 - это @acronym{ASCII} коды; остальные non-@acronym{ASCII}
  (@pxref{Non-ASCII Characters}). Символы, которые представляют ввод с
  клавиатуры имеют гораздо более широкий диапазон, чтобы кодирования
  клавиш-модификаторов, таких как Control, Meta и Shift.

  Существуют специальные функции для получения удобочитаемого текстового
  описания символа для сообщений.  @xref{Describing Characters}.

@menu
* Basic Char Syntax::      Синтаксис обычных символов.
* General Escape Syntax::  Как определить символы по их кодам.
* Ctl-Char Syntax::        Синтаксис для управляющих символов.
* Meta-Char Syntax::       Синтаксис для мета-символов.
* Other Char Bits::        Синтаксис для hyper-, super-, и alt-символов.
@end menu

@node Basic Char Syntax
@subsubsection Базовый Синтаксис Символов
@cindex read syntax for characters
@cindex printed representation for characters
@cindex syntax for characters
@cindex @samp{?} in character constant
@cindex question mark in character constant

  Так как символы на самом деле целые числа, печатное представление символа
  представляет собой десятичное число. Это также возможный синтаксис чтения
  для символа, но написание таким образом в программах на Лиспе - не
  понятное программирование. Вы @emph{всегда} должны использовать специальные
  форматы синтаксиса для чтения, которые Emacs Lisp предоставляет для символов.
  Эти форматы синтаксиса начинаются со знака вопроса.

  Обычный синтаксис чтения для алфавитно-цифровых символов - это вопросительный
  знак, за которым следует символ; Таким образом, @samp{?A} для символа @kbd{A},
  @samp{?B} для символа @kbd{B} и @samp{?a} для символа @kbd{a}.

  Для примера:

@example
?Q @result{} 81     ?q @result{} 113
@end example

  Вы можете использовать тот же синтаксис для знаков пунктуации. Однако, если знак
  препинания имеет специальный синтаксический смысл в Лиспе, вы должны экранировать
  его с помощью @samp{\}. Например, @samp{?\(} является способом написания символа
  открытой скобки.  Точно так же, если нужно использовать символ @samp{\}, вы должны
  использовать второй @samp{\} чтобы процитировать его: @samp{?\\}.

@cindex whitespace
@cindex bell character
@cindex @samp{\a}
@cindex backspace
@cindex @samp{\b}
@cindex tab (ASCII character)
@cindex @samp{\t}
@cindex vertical tab
@cindex @samp{\v}
@cindex formfeed
@cindex @samp{\f}
@cindex newline
@cindex @samp{\n}
@cindex return (ASCII character)
@cindex @samp{\r}
@cindex escape (ASCII character)
@cindex @samp{\e}
@cindex space (ASCII character)
@cindex @samp{\s}
  Вы можете выразить символы control-g, backspace, tab, newline, vertical tab,
  formfeed, space, return, del, и escape как @samp{?\a}, @samp{?\b}, @samp{?\t},
  @samp{?\n}, @samp{?\v}, @samp{?\f}, @samp{?\s}, @samp{?\r}, @samp{?\d}, и
  @samp{?\e} соответственно.
  (@samp{?\s} с последующим тире имеет другое значение --- он применяет модификатор
  Super к следующиму символу.)  Таким образом,

@example
?\a @result{} 7                 ; @r{control-g, @kbd{C-g}}
?\b @result{} 8                 ; @r{возврат на одну позицию, @key{BS}, @kbd{C-h}}
?\t @result{} 9                 ; @r{табуляция, @key{TAB}, @kbd{C-i}}
?\n @result{} 10                ; @r{перевод строки, @kbd{C-j}}
?\v @result{} 11                ; @r{вертикальная табуляция, @kbd{C-k}}
?\f @result{} 12                ; @r{перевод страницы, @kbd{C-l}}
?\r @result{} 13                ; @r{возврат каретки, @key{RET}, @kbd{C-m}}
?\e @result{} 27                ; @r{escape-символ, @key{ESC}, @kbd{C-[}}
?\s @result{} 32                ; @r{пробел, @key{SPC}}
?\\ @result{} 92                ; @r{обратная косая черта, @kbd{\}}
?\d @result{} 127               ; @r{удалить символ, @key{DEL}}
@end example

@cindex escape sequence
  Эти последовательности, которые начинаются с обратной косой черты также
  известны как @dfn{escape последовательности}, потому что обратная косая
  черта играет роль экранирующего символа; это не имеет ничего общего с
  символом @key{ESC}. @samp{\s} предназначен для использования в символьных
  константах; в строковых констант, просто напишите пробел.

  Обратная косая черта допускается и безвредена, если предшествует символу без
  особого escape-смысла; Таким образом, @samp{?\+} эквивалентно @samp{?+}. Нет
  причин, чтобы добавить обратный слэш перед большинством символов. Тем не менее,
  вы должны добавить обратную косую черту перед любым из символов @samp{()[]\;"},
  и вы должны добавить обратную косую черту перед любым из символов @samp{|'`#.,},
  чтобы не спутать команды Emacs для редактирования кода Lisp. Вы можете также
  добавить обратный слэш перед пробельных символов, таких как пробел, табуляция,
  перевод строки и перевод страницы. Тем не менее, лучше использовать один из
  легко понимаемых управляющих последовательностей, таких как @samp{\t} или @samp{\s},
  вместо фактического символа пробела, такого как табуляция или пробел. (Если вы пишите
  обратную косую черту, а затем пробел, вы должны написать дополнительный пробел
  после символьной константы, чтобы отделить его от последующего текста.)

@node General Escape Syntax
@subsubsection Общий Escape Синтакс

  В дополнение к конкретным экранирующим последовательностям для специальных важных
  управляющих символов, Emacs предоставляет несколько типов синтаксиса
  escape-последовательностей, которые можно использовать, чтобы указать
  не-@acronym{ASCII} текстового символа.

@enumerate
@item
@cindex @samp{\} in character constant
@cindex backslash in character constants
@cindex unicode character escape
Вы можете указать символ по его имени Unicode, если таковые имеются.
@code{?\N@{@var{NAME}@}} представляет символ Unicode с именем @var{NAME}.
Таким образом, @samp{?\N@{LATIN SMALL LETTER A WITH GRAVE@}} эквивалентно
@code{?à} и обозначает символ Unicode U + 00E0. Для упрощения ввода
многостроковых строк, вы можете заменить пробелы в именах непустыми
последовательностями пробельных символов (например, новая строка).

@item
Вы можете указать символы по их значениям Unicode. @code{?\N@{U+@var{X}@}}
представляет собой символ с кодовой точкой Unicode @var{X}, где @var{X} является
шестнадцатеричным числом. Кроме того, @code{?\u@var{xxxx}} и
@code{?\U@var{xxxxxxxx}} представляют собой кодовые точки @var{xxxx}
и @var{xxxxxxxx}, соответственно, где каждый @var{x} является одной
шестнадцатеричной цифрой. Например, @code{?\N@{U+E0@}}, @code{?\u00e0} и
@code{?\U000000E0} все эквивалентны @code{?à} и
@samp{?\N@{LATIN SMALL LETTER A WITH GRAVE@}}. Стандарт Unicode определяет
кодовые точки только до @samp{U+@var{10ffff}}, поэтому если вы указываете
кодовую точку кода выше, Emacs сигнализирует об ошибке.

@item
Вы можете указать символы, c помощью их шестнадцатиричных кодов. Шестнадцатеричная
escape-последовательность состоит из обратной косой черты, @samp{x} и
шестнадцатеричного кода символа. Таким образом, @samp{?\x41} - это символ
@kbd{A}, @samp{?\x1} - это символ @kbd{C-a} и @code{?\xe0} - это символ
@kbd{à} (@kbd{a} с серьезным акцентом). Вы можете использовать любое количество
шестнадцатеричных цифр, так что вы можете представить любой код символа
таким образом.

@item
@cindex octal character code
Вы можете указать символы по их восьмеричному коду. Восьмеричная управляющая
последовательность состоит из обратной косой черты, за которой следует до
трех восьмеричных цифр; Таким образом, @samp{?\101} для символа @kbd{A},
@samp{?\001} для символа @kbd{C-a} и @code{?\002} для символа @kbd{C-b}.
Только символы до восьмеричного кода 777 могут быть заданы таким образом.

@end enumerate

  Эти последовательности также могут быть использованы в строках.
  @xref{Non-ASCII in Strings}.

@node Ctl-Char Syntax
@subsubsection Управляющие-Символы Синтаксис

@cindex control characters
  Управляющие символы могут быть представлены с помощью еще одного синтаксиса
  чтения. Он состоит из знака вопроса с последующим обратной косой,
  кареткой, и соответствующей неконтролирующий символ, в верхнем или
  нижнем регистре. Например, @samp{?\^I} и @samp{?\^i} допустимый
  синтаксис чтения для символа @kbd{C-i}, значение которого равно 9.

  Вместо @samp{^}, вы можете использовать @samp{C-}; Таким образом,
  @samp{?\C-i} эквивалентно @samp{?\^I} и @samp{?\^i}:

@example
?\^I @result{} 9     ?\C-I @result{} 9
@end example

  В строках и буферах, разрешены только управляющие символы, которые
  существуют в @acronym{ASCII}; но для ввода с клавиатуры, вы можете
  превратить любой символ в управляющий символ с @samp{C-}. Коды
  символов для этих управляющих не-@acronym{ASCII} символов включают
@tex
@math{2^{26}}
@end tex
@ifnottex
2**26
@end ifnottex
бит, а также код соответствующего неуправляющего символа. Обычные текстовые
терминалы не имеют возможности генерации управляющих не-@acronym{ASCII}
символов, но вы можете создать их непосредственно с помощью X и других
оконных систем.

  По историческим причинам, Emacs трактует @key{DEL} символ в качестве
  управляющего символа эквивалента @kbd{?}:

@example
?\^? @result{} 127     ?\C-? @result{} 127
@end example

@noindent
В результате, в настоящее время не представляется возможным представить
управляющий символ @kbd{Control-?}, который является значимым входным
символом в X, используя @samp{\C-}. Это не так легко изменить, так как
различные Lisp файлы ссылаются на @key{DEL} таким образом.

  Для представления управляющих символов, которые можно найти в файлах или
  строках, мы рекомендуем синтаксис @samp{^}; для управляющих символов
  ввода с клавиатуры, мы предпочитаем синтаксис @samp{C-}. Какой из них
  вы используете, не влияет на смысл программы, но может способствовать
  пониманию людей, которые читают его.

@node Meta-Char Syntax
@subsubsection Мета-Символы Синтакс

@cindex meta characters
  @dfn{Мета-Символом} является введенный символ с помощью клавиши-модификатора
  @key{META}. Целое число, которое представляет собой такой символ имеет
  набор
@tex
@math{2^{27}}
@end tex
@ifnottex
2**27
@end ifnottex
бит. Мы используем старшие биты для этого и других модификаторов, чтобы сделать
возможным широкий спектр базовых кодов символов.

  В строке,
@tex
@math{2^{7}}
@end tex
@ifnottex
2**7
@end ifnottex
бит, прикреплённого к символу @acronym{ASCII}, указывается мета-символ;
Таким образом, мета-символы, которые могут поместиться в строке имеют
коды в диапазоне от 128 до 255, и являются мета-версии обычных символов
@acronym{ASCII}. @xref{Strings of Events}, для получения подробной
информации о @key{META} обработки в строках.

  Синтаксис чтения для мета-символов использует @samp{\M-}. Например,
  @samp{?\M-A} означает @kbd{M-A}. Вы можете использовать @samp{\M-}
  вместе с восьмеричными кодами символов (см ниже), с @samp{\C-}, или
  с каким-либо другим синтаксисом для символа. Таким образом, вы можете
  написать @kbd{M-A} в @samp{?\M-A}, или как @samp{?\M-\101}. Кроме того,
  вы можете написать @kbd{C-M-b} в @samp{?\M-\C-b}, @samp{?\C-\M-b} или
  @samp{?\M-\002}.

@node Other Char Bits
@subsubsection Другие Биты Модификации Символов

  Регистр графического символа указывается его кодом символа; например,
  @acronym{ASCII} различает между символами @samp{a} и @samp{A}. Но
  @acronym{ASCII} не имеет возможности представлять является ли управляющий
  символ верхнего или нижнего регистра. Emacs использует
@tex
@math{2^{25}}
@end tex
@ifnottex
2**25
@end ifnottex
бит, чтобы указать, что клавиша Shift используется при наборе управляющего символа.
Это различие возможно только при использовании X терминалов или других специальных
терминалов; обычные текстовые терминалы не сообщают различия. Синтаксис Лиспа
для бита сдвига является @samp{\S-}; Таким образом, @samp{\C-\S-o} или
@samp{?\C-\S-O} представляет собой символ сдвинутого элемента управления.

@cindex hyper characters
@cindex super characters
@cindex alt characters
  Система X Window определяет три других бита @anchor{modifier bits} модификатора,
  которые могут быть установлены в символе: @dfn{hyper}, @dfn{super} и @dfn{alt}.
  Синтаксис для этих битов @samp{\H-}, @samp{\s-} and @samp{\A-}. (Важен регистр
  в этих префиксах.) Таким образом, @samp{?\H-\M-\A-x} представляет
  @kbd{Alt-Hyper-Meta-x}. (Обратите внимание, что @samp{\s} с не следующими (здесь
  непонятно что имеет ввиду) @samp{-} не представляет собой символ пробела.)
@tex
Численно битовые значения @math{2^{22}} для alt, @math{2^{23}} для super и
@math{2^{24}} для гипер.
@end tex
@ifnottex
Численно битовые значения 2**22  для alt, 2**23 для super и 2**24 для hyper.
@end ifnottex

@node Symbol Type
@subsection Тип Символа

  @dfn{Символ} в GNU Emacs Lisp является объектом с именем.  Имя символа служит
  его печатным представлением символа.  При обычном использовании Lisp, с одной
  единственной obarray (@pxref{Creating Symbols}), имя символа является
  уникальным --- нет двух символов с одинаковым именем.

  Символ может служить в качестве переменной, как имя функции, или для хранения
  списка свойств.  Или он может служить только для того, чтобы быть отличным от
  всех других объектов Lisp, так что его присутствие в структуре данных, может
  быть надежно распознаются.  В данном контексте, как правило, только одно из
  этих целей предполагается.  Но вы можете использовать один символ всеми этими
  способами, независимо друг от друга.

  Символ, имя которого начинается с двоеточия (@samp{:}) называется
  @dfn{символом ключевого слова}.  Эти символы автоматически действуют как
  константы, и, как правило, используются только для сравнения неизвестного
  символа с несколькими определенными альтернативами.  @xref{Constant Variables}.

@cindex @samp{\} in symbols
@cindex backslash in symbols
  Имя символа может содержать любые символы.  Большинство имен символов
  написаны буквами, цифрами и знаками препинания @samp{-+=*\}.  Такие имена
  не требуют специальной пунктуации; символов имени достаточно, если имя
  не выглядит как число.  (Если это так, пишите @samp{\} в начале имени для
  принудительной интерпретации как символа.)  Символы
  @samp{_~!@@$%^&:<>@{@}?} реже используется, но также не требуют
  специальной пунктуации.  Любые другие символы могут быть включены в имя
  символа путем экранирования их обратной косой чертой.  В отличие от его
  использования в строках, однако, обратный слэш во имени символа просто
  цитирует один символ, который следует за обратной косой чертой. Например,
  в строке, @samp{\t} представляет собой символ табуляции; в имени символа,
  однако, @samp{\t} просто цитирует запись @samp{t}.  Для того, чтобы иметь
  символ с символом табуляции в своём имени, вы должны фактически
  использовать табуляцию (перед которой стоит обратная косая черта).  Но
  такое встречается редко.

@cindex CL note---case of letters
@quotation
@b{Common Lisp note:}  В Common Lisp, строчные буквы всегда переводятся в
в верхний регистр, если только они явно не экранированы.  В Emacs Lisp,
строчные и прописные буквы различны.
@end quotation

  Вот несколько примеров имен символов. Обратите внимание, что @samp{+}
  в четвертом примере экранируется, чтобы предотвратить его от чтения как
  число. Это не является необходимым в шестом примере, потому что
  остальная часть имени делает его недействительным как число.

@example
@group
foo                 ; @r{Символ с именем @samp{foo}.}
FOO                 ; @r{Символ с именем @samp{FOO}, отличный от @samp{foo}.}
@end group
@group
1+                  ; @r{Символ с именем @samp{1+}}
                    ;   @r{(не @samp{+1}, который является целым числом).}
@end group
@group
\+1                 ; @r{Символ с именем @samp{+1}}
                    ;   @r{(не очень читаемое имя).}
@end group
@group
\(*\ 1\ 2\)         ; @r{Символ c именем @samp{(* 1 2)} (неудачное имя).}
@c the @'s в этой следующей строке использовать три символа,
@c следовательно, кажущееся смещение комментария.
+-*/_~!@@$%^&=:<>@{@}  ; @r{Символ с именем @samp{+-*/_~!@@$%^&=:<>@{@}}.}
                    ;   @r{Эти символы не нужно экранировать.}
@end group
@end example

@cindex @samp{##} read syntax
@ifinfo
@c При этом используется "colon" вместо буквального ':' потому,
@c что информация не может справиться с ':' в меню.
@cindex @samp{#@var{colon}} read syntax
@end ifinfo
@ifnotinfo
@cindex @samp{#:} read syntax
@end ifnotinfo
  В качестве исключения из правила, согласно которому имя символа служит
  его печатным представлением, @samp{##}---это печатное представление для
  интернированного символа, имя которого является пустой строкой. Кроме
  того, @samp{#:@var{foo}} это печатное представление для uninterned
  (здесь неясность неорганизованного) символа, имя которого @var{foo}.
  (Как правило, читатель Lisp обрабатывает все символы;
  @pxref{Creating Symbols}.)

@node Sequence Type
@subsection Тип Последовательность

  @dfn{Последовательность} является объектом Lisp, который представляет
  собой упорядоченный набор элементов.  Есть два вида последовательности
  в Emacs Lisp: @dfn{списки} и @dfn{массивы}.

  Списки являются наиболее часто используемыми последовательностями. Список
  может содержать элементы любого типа, и его длина может быть легко
  изменена путем добавления или удаления элементов. Смотрите следующий
  подраздел для получения дополнительной информации о списках.

  Массивы представляют собой последовательность фиксированной длины.  Они
  подразделяются на строки, векторы, символ-таблицы и BOOL векторы.  Векторы
  могут содержать элементы любого типа, в то время как строки должны
  содержать только символы, и BOOL-векторы должны содержать лишь @code{t}
  или @code{nil}.  Символ-таблицы похожи на векторы, за исключением того, что
  они проиндексированы любым допустимым кодом символа.  Символы в строке
  могут иметь свойства текста, такие как символы в буфере
  (@pxref{Text Properties}), но векторы не поддерживают свойство текста,
  даже если их элементы являются символами.

  Списки, строки и другие типы массивов также имеют важное сходство.
  Например, все они имеют длину @var{l}, и все они имеют элементы, которые
  могут быть проиндексированы от нуля до @var{l} минус один.  Некоторые
  функции, называемые функциями последовательности, принимают либой вид
  последовательности. Например, функция @code{length} сообщает длину
  любого вида последовательности.  @xref{Sequences Arrays Vectors}.

  Как правило, невозможно читать ту же последовательность дважды, так как
  последовательности всегда создается заново при чтении.  Если вы дважды
  прочитаете синтакс чтения для последовательности, вы получите две
  последовательности с одинаковым содержимым. Существует одно исключение:
  пустой список @code{()} всегда обозначает тот же объект, @code{nil}.

@node Cons Cell Type
@subsection Типы Cons-Ячейка и Список
@cindex address field of register
@cindex decrement field of register
@cindex pointers

  @dfn{Cons-ячейка} это объект, который состоит из двух слотов, слот
  @sc{car} и слот @sc{cdr}. Каждый слот может @dfn{содержать} любой
  объект Lisp.  (здесь нужно отредактировать, непонятки) Мы также
  говорим, что @sc{car} этой cons-ячейки является
  любой объект, и слот @sc{car} в настоящее время имеет место, а также
  для @sc{cdr}.

@cindex list structure
  @dfn{Список} это ряд cons-ячеек, связаных друг с другом, так что @sc{cdr}
  слот каждой cons-ячейки имеет либо следующую cons-ячейку либо пустой
  список. Пустой список на самом деле символ @code{nil}. @xref{Lists},
  для деталей. Поскольку большинство cons-ячеек используются как часть
  списков, мы называем любую структуру, изготовленную из cons-ячеек,
  @dfn{структурой списка}.

@cindex linked list
@quotation
Замечание для программистов C: список Lisp, таким образом, работает как
@dfn{связаный список} состоящий из cons-ячеек.  Поскольку указатели в
Lisp неявные, мы не делаем различия между слот cons-ячейки содержит значение
и указывает на значение.
@end quotation

@cindex atoms
  Сons-ячейка занимает центральное место в Lisp, но также есть объекты,
  который не являются cons-ячейкой.  Эти объекты называются
  @dfn{атомами}.

@cindex parenthesis
@cindex @samp{(@dots{})} in lists
  Синтаксис чтения и печатное представление списков идентичны и состоят
  из левой круглой скобки, произвольного числа элементов, и правой скобки.
  Вот примеры списков:

@example
(A 2 "A")            ; @r{Список из трех элементов.}
()                   ; @r{Список без элементов (пустой список).}
nil                  ; @r{Список без элементов (пустой список).}
("A ()")             ; @r{Список из одного элемента: строка @code{"A ()"}}.
(A ())               ; @r{Список из двух элементов: @code{A} и пустой список.}
(A nil)              ; @r{Эквивалент к предыдущему.}
((A B C))            ; @r{Список из одного элемента}
                     ;   @r{(который представляет собой список из трех элементов).}
@end example

   При чтении, каждый объект внутри скобок становится элементом списка.  То
   есть, для каждого элемента создаётся cons-ячейка.  Слот @sc{car} из
   cons-ячейки удерживает элемент, а её @sc{cdr} слот относится к следующей
   cons-ячейки списка, которая содержит следующий элемент в списке. @sc{cdr}
   слот последней cons-ячейки содержит @code{nil}.

  Имена @sc{car} и @sc{cdr} вытекают из истории Lisp. Оригинальная
  реализация Lisp исполнялась на @w{IBM 704} компьютере, который разделял
  слово на две части, адрес и декремент; @sc{car} была инструкция для
  извлечения содержимого адресной части регистра, и @sc{cdr} инструкция,
  чтобы извлечь содержимое декремента. Напротив, cons-ячейки названы
  в честь функции @code{cons}, которая создает их, в свою очередь, была
  назван в честь своего назначения, конструирование ячеек.

@menu
* Box Diagrams::                Рисование изображений списков.
* Dotted Pair Notation::        Общий синтаксис для cons-ячейки.
* Association List Type::       Специально построенный список.
@end menu

@node Box Diagrams
@subsubsection Схема Списка в Виде Прямоугольников
@cindex box diagrams, for lists
@cindex diagrams, boxed, for lists

  Список можно проиллюстрировать диаграммой, в которой cons-ячейки показаны
  в виде пар прямоугольников, как домино.  (Читатель Lisp не может прочитать
  такую ​​иллюстрацию, в отличие от текстовой нотации, которая может быть
  понята как людьми, так и компьютерами, прямоугольные иллюстрации могут
  быть поняты только людьми.)  Эта картина представляет собой трёхэлементный
  список @code{(роза фиалка лютик)}:

@example
@group
    --- ---      --- ---      --- ---
   |   |   |--> |   |   |--> |   |   |--> nil
    --- ---      --- ---      --- ---
     |            |            |
     |            |            |
      --> роза     --> фиалка   --> лютик
@end group
@end example

  На этой диаграмме каждый прямоугольник представляет собой слот, который
  может содержать или ссылаться на любой объект Lisp.  Каждая пара
  прямоугольников представляет собой cons-ячейку.  Каждая стрелка
  представляет собой ссылку на объект Lisp, атом или другую cons-ячейку.

  В данном примере, первый прямоугольник, содержит @sc{car} первой
  cons-ячейки, которая ссылается или содержит @code{роза} (символ).
  Второй прямоугольник, содержит @sc{cdr} первой cons-ячейки, относится
  к следующей паре прямоугольников, второй cons-ячейки. @sc{car} второй
  cons-ячейки является @code{фиалка}, и его @sc{cdr} является третьей
  cons-ячейкой. @sc{cdr} из третьей (и последней) cons-ячейки является
  @code{nil}.

  Вот еще одна схема того же списка, @code{(роза фиалка лютик)},
  набросанная по-другому:

@smallexample
@group
 ---------------       ----------------       -------------------
| car   | cdr   |     | car    | cdr   |     | car       | cdr   |
| роза  |   o-------->| фиалка |   o-------->| лютик     |  nil  |
|       |       |     |        |       |     |           |       |
 ---------------       ----------------       -------------------
@end group
@end smallexample

@cindex @code{nil} as a list
@cindex empty list
  Список без элементов в нём --- это @dfn{пустой список}; он идентичен
  символу @code{nil}. Другими словами, @code{nil} является одновременно
  символом и списком.

  Вот список @code{(A ())}, или что то же самое @code{(A nil)}, изображен
  прямоугольниками и стрелками:

@example
@group
    --- ---      --- ---
   |   |   |--> |   |   |--> nil
    --- ---      --- ---
     |            |
     |            |
      --> A        --> nil
@end group
@end example

  Вот более сложный рисунок, показывающий список из трех элементов,
  @code{((сосна хвоя) дуб клён)}, первый элемент которого является
  список из двух элементов:

@example
@group
    --- ---      --- ---      --- ---
   |   |   |--> |   |   |--> |   |   |--> nil
    --- ---      --- ---      --- ---
     |            |            |
     |            |            |
     |             --> дуб      --> клён
     |
     |     --- ---      --- ---
      --> |   |   |--> |   |   |--> nil
           --- ---      --- ---
            |            |
            |            |
             --> сосна    --> хвоя
@end group
@end example

  Тот же список, представленный в другой нотации выглядит следующим образом:

@example
@group
 --------------       --------------       --------------
| car   | cdr  |     | car   | cdr  |     | car   | cdr  |
|   o   |   o------->| дуб   |   o------->| клён  |  nil |
|   |   |      |     |       |      |     |       |      |
 -- | ---------       --------------       --------------
    |
    |
    |        --------------       ----------------
    |       | car   | cdr  |     | car     | cdr  |
     ------>| сосна |   o------->| хвоя    |  nil |
            |       |      |     |         |      |
             --------------       ----------------
@end group
@end example

@node Dotted Pair Notation
@subsubsection Нотация Точечной Пары
@cindex dotted pair notation
@cindex @samp{.} in lists

  @dfn{Нотация точечной пары} является общим синтаксисом cons-ячейки,
  который представляет @sc{car} и @sc{cdr} явно. В  этом синтаксисе,
  @code{(@var{a} .@: @var{b})} обозначает cons-ячейку, у которой @sc{car}
  является объектом @var{a} и чья @sc{cdr} является объектом @var{b}.
  Нотация точечной пары является более общей, чем синтаксис списка, потому
  что @sc{cdr} не обязательно может быть списком.  Тем не менее, это более
  громоздкий синтаксис в тех случаях, когда синтаксис списка будет работать.
  В нотации точечной пары, список @samp{(1 2 3)} записывается в виде
  @samp{(1 .  (2 . (3 . nil)))}.  Для списков заканчивающихся @code{nil}, вы
  можете использовать любую нотацию, но нотация списка, как правило, более
  ясна и удобна.  При печати списка, нотация точечной пары используется
  только тогда, когда @sc{cdr} из cons-ячейки не список.

  Вот пример c использованием прямоугольников для иллюстрации нотации
  точечной пары.  Этот пример показывает пару @code{(роза . фиалка)}:

@example
@group
    --- ---
   |   |   |--> фиалка
    --- ---
     |
     |
      --> роза
@end group
@end example

  Вы можете комбинировать нотацию точечной пары и нотацию списка, для
  удобного представления цепочки cons-ячеек с не-@code{nil} в @sc{cdr}
  конечной cons-ячейки.   Вы пишете точку после @sc{car} последнего
  элемента списка,  за которой  следует @sc{cdr} конечной cons-ячейки.
  Например,  @code{(роза фиалка . лютик)} эквивалентно
  @code{(роза . (фиалка . лютик))}. Объект выглядит следующим образом:

@example
@group
    --- ---      --- ---
   |   |   |--> |   |   |--> лютик
    --- ---      --- ---
     |            |
     |            |
      --> роза     --> фиалка
@end group
@end example

  Синтаксис @code{(роза .@: фиалка .@: лютик)} является недействительным,
  потому что нет ничего, что это может означать.  Во всяком случае, это
  указание поставить @code{лютик} в слот @sc{cdr} cons-ячейки которая
  уже используются для @code{фиалка}.

  Список @code{(роза фиалка)} эквивалентно @code{(роза . (фиалка))}, и
  выглядит следующим образом:

@example
@group
    --- ---      --- ---
   |   |   |--> |   |   |--> nil
    --- ---      --- ---
     |            |
     |            |
      --> роза     --> фиалка
@end group
@end example

  Аналогичным образом, записи трёхэлементного списка
  @code{(роза фиалка лютик)} и
  @code{(роза . (фиалка . (лютик)))} эквивалентны.
@ifnottex
Похоже, что это:

@example
@group
    --- ---      --- ---      --- ---
   |   |   |--> |   |   |--> |   |   |--> nil
    --- ---      --- ---      --- ---
     |            |            |
     |            |            |
      --> роза     --> фиалка   --> лютик
@end group
@end example
@end ifnottex

@node Association List Type
@subsubsection Тип Ассоциативный Список

  @dfn{Ассоциативный список} или @dfn{alist} представляет собой специально
  построенный список, элементами которого является cons-ячейки. В каждом
  элементе, @sc{car} считается @dfn{ключом}, а @sc{cdr} считается
  @dfn{ассоциативным значением}. (В некоторых случаях, ассоциированное
  значение сохраняется в @sc{car} в @sc{cdr}.) Ассоциативные списки часто
  используются как стеки, так как легко добавлять или удалять ассоциации
  в передней части списка.

  Например,

@example
(setq alist-of-colors
      '((роза . красный) (лилия . белый) (лютик . жёлтый)))
@end example

@noindent
устанавливает переменную @code{alist-of-colors} в ассоциативный список
из трех элементов. В первом элементе, @code{роза} является ключом а
@code{красный} это ассоциативное значение.

  @xref{Association Lists}, для детального объяснения alists и функций,
  для работы с alists. @xref{Hash Tables}, для другого типа справочной
  таблицы, которая намного быстрее обрабатывает большое количество ключей.

@node Array Type
@subsection Тип Массив

  @dfn{Массив} состоит из произвольного числа слотов для удержания или
  ссылок на другие объекты Lisp, расположенных в непрерывном блоке памяти.
  Доступ к любому элементу массива занимает примерно одинаковое время.
  В противоположность этому, доступ к элементу списка требует времени,
  пропорционального положению элемента в списке. (Доступ к элементам в
  конце списка занимает больше времени, чем доступ к элементам в начале
  списка.)

  Emacs определяет четыре типа массива: строки, векторы, BOOL-векторы,
  и символьная-таблица.

  Строка представляет собой массив символов, а вектор представляет собой
  массив произвольных объектов.  Bool-вектор может содержать только @code{t}
  или @code{nil}.  Эти типы массивов могут иметь любую длину до наибольшего
  целого числа.  Символ-таблицы --- это разреженные массивы, индексированные
  любым допустимым кодом символа; они могут содержать произвольные объекты.

  Первый элемент массива имеет нулевой индекс, второй элемент имеет
  индекс --- 1, и так далее.  Это называется индексация с
  @dfn{нулевым происхождением}.  Например, массив из четырех элементов
  имеют индексы 0, 1, 2, @w{и 3}. Наибольшее возможное значение индекса на
  единицу меньше, чем длина массива. После того, как массив создан, его
  длина фиксирована.

  Все Emacs Lisp массивы являются одномерными.  (Большинство других языков
  программирования поддерживают многомерные массивы, но они не являются
  обязательными, вы можете получить тот же эффект с вложенными одномерными
  массивами.)  Каждый тип массива имеет свой собственный синтаксис чтения;
  детали в следующих разделах.

  Тип массива представляет собой подмножество типа последовательности,
  и содержит тип строка, тип вектора, тип BOOL-вектор и тип
  символ-таблица.

@node String Type
@subsection Тип Строка

  @dfn{Строка} представляет собой массив символов.  Строки используются для
  многих целей в Emacs, как можно ожидать, в текстовом редакторе; например,
  как имена символов Lisp, как сообщения для пользователя, а также для
  представления текста, извлеченного из буферов. Строки в Lisp константы:
  оценка строки возвращает ту же строку.

  @xref{Strings and Characters} функции, которые работают со строками.

@menu
* Syntax for Strings::      Как определить Lisp строки.
* Non-ASCII in Strings::    Международные символы в строках.
* Nonprinting Characters::  Буквенные непечатные символы в строках.
* Text Props and Strings::  Строки с текстовыми свойствами.
@end menu

@node Syntax for Strings
@subsubsection Синтаксис для Строк

@cindex @samp{"} in strings
@cindex double-quote in strings
@cindex @samp{\} in strings
@cindex backslash in strings
  Синтаксис чтения для строки является взятие в двойные кавычки,
  произвольное число символов, @code{"это строка"}.  Чтобы включить
  символ двойной кавычки в строке, поставьте перед ним обратную косуя
  черту;  Таким образом, @code{"\""} это строка, содержащая только одну
  двойную кавычку.  Кроме того, вы можете включить обратную косую черту,
  предварив её другим символом обратной косой черты, как здесь:
  @code{"Здесь \\, стоит одна обратная косая черта"}.

@cindex newline in strings
  Символ новой строки не является специальным в синтаксисе чтения для строк;
  если вы пишете новую строку между двойными кавычками, он становится
  символом в строке.  Но экранированный символ новой строки --- тот,
  которому предшествует @samp{\} --- не становится частью строки; т.е.
  читатель Lisp игнорирует экранированный символ новой строки при чтении
  строки.  Экраннированный пробел @w{@samp{\ }} аналогичным образом
  игнорируется.

@example
"Полезно включать в строках документации
символы новой строки строки, но символ новой строки \
игнорируется, \
если \
он \
экранирован."
     @result{} "Полезно включать в строках документации
символы новой строки строки, но символ новой строки игнорируется, если он экранирован."
@end example

@node Non-ASCII in Strings
@subsubsection Не-@acronym{ASCII} Символы в Строках

  Есть два текстовых представлений для не-@acronym{ASCII} символов в
  строках Emacs: многобайтное и однобайтное (@pxref{Text Representations}).
  Грубо говоря, однобайтная строка хранит необработанные байты, в то время
  как многобайтная строка хранить удобочитаемый текст.  Каждый символ в
  однобайтной строке составляет один байт, то есть, его значение находится
  между 0 и 255. В отличие от этого, каждый символ в многобайтной строке
  может иметь значение в диапазоне от 0 до 4194303 (@pxref{Character Type}).
  В обоих случаях символы со значением выше 127 не-@acronym{ASCII}.

  Вы можете включать не-@acronym{ASCII} символ в строковой константе,
  написав его в буквальном смысле.  Если строковая константа считывается
  из многобайтного источника, такого как многобайтный буфер или строка,
  или если файл будет посещён как многобайтный, то Emacs читает каждый
  не-@acronym{ASCII} как многобайтный символ и автоматически делает строку
  многобайтной строкой.  Если строковая константа считывается из
  однобайтного источника, то Emacs считывает не-@acronym{ASCII} символ как
  однобайтный и делает строку однобайтной.

  Вместо того, чтобы писать символ буквально в многобайтной строке, вы
  можете записать его в своем коде символа с помощью
  escape-последовательности. @xref{General Escape Syntax}, для получения
  подробной информации о экранирующих последовательностях.

  Если вы используете escape-последовательность в стиле Unicode
  @samp{\uNNNN} или @samp{\U00NNNNNN} в строковой константе
  (даже для @acronym{ASCII} символа), Emacs автоматически предполагает,
  что она многобайтная.

  Вы можете также использовать шестнадцатеричные escape-последовательности
  (@samp{\x@var{n}}) и восьмеричные escape-последовательности
  (@samp{\@var{n}}) в строковых константах.  @strong{Будьте осторожны:}
  Если строковая константа содержит шестнадцатеричные или восьмеричные
  escape-последовательности, и все эти управляющие последовательности
  указывают однобайтные символы (т.е. меньше, чем 256), и в строке нет
  никаких других буквальных не-@acronym{ASCII} символов или
  escape-последовательностей в Unicode-стиле, то Emacs автоматически
  принимает что это строка однобайтная.  То есть, предполагается, что все
  не-@acronym{ASCII} символы встречающиеся в строке являются 8-битными
  необработанными байтами.

  В шестнадцатеричных и восьмиричных управляющих последовательностях,
  экранированый код символа может содержать переменное число цифр, так
  что первый последующий символ, который не является допустимой
  шестнадцатиричной или восьмеричной цифрой, завершает
  escape-последовательность.  Если следующий символ в строке может быть
  интерпретирован как шестнадцатеричная или восьмеричной цифра, пишите
  @w{@samp{\ }} (обратный слэш и пробел), чтобы завершить
  escape-последовательность.  Например, @w{@samp{\xe0\ }} представляет
  собой один символ, @samp{a} с серьезным акцентом.  @w{@samp{\ }} в
  строковой константе точно так же как обратный слэш-символ новой строки;
  не вносит какие-либо символы в строку, но прекращает любую предшествующую
  шестндадцатиричную escape-последовательность.

@node Nonprinting Characters
@subsubsection Непечатаемые символы в строках

  Вы можете использовать те же escape-последовательности с обратной
  косой чертой, используемые в строковых константах, и для символьных
  литералов (но не используйте знак вопроса, с которого начинается
  символьная константа). Например, вы можете написать строку, содержащую
  непечатаемый символ табуляции и @kbd{C-a}, с запятой и пробелом между
  ними, вот так: @code{"\t, \C-a"}. @xref{Character Type}, для описания
  синтаксиса чтения для символов.

  Однако, не все символы, которые вы можете написать с обратной косой
  чертой в escape-последовательности допустимы в строках.  Единственные
  управляющие символами, которая строка может содержать, - это
  управляющие символы @acronym{ASCII}. Строки не различают регистр
  в управляющих символах @acronym{ASCII}.

  Собственно говоря, строки не могут содержать метасимволы; но когда
  строка будет использоваться в качестве ключевой последовательности,
  существует специальное соглашение, которое обеспечивает способ
  представления мета-версий @acronym{ASCII} символов в строке. Если вы
  используете синтаксис @samp{\M-}, чтобы указать мета-символ в
  строковой константе, это установит
@tex
@math{2^{7}}
@end tex
@ifnottex
2**7
@end ifnottex
бит символа в строке. Если строка используются в @code{define-key} или
@code{lookup-key}, этот цифровой код переводится в эквивалентный
метасимвол.  @xref{Character Type}.

  Строки не могут содержать символы, которые имеют модификаторы
  hyper, super, или alt.

@node Text Props and Strings
@subsubsection Текстовые Свойства Строки

@cindex @samp{#(} read syntax
@cindex text properties, read syntax
  Строка может содержать свойства для символов, которые она содержит,
  в дополнение к самим символам.  Это позволяет программам, которые
  копируют текст между строками и буферами, копировать свойства текста
  без особых усилий. @xref{Text Properties}, для объяснения того, что
  означает свойство текста. Строки с текстовыми свойствами используют
  специальный синтаксис для чтения и печати:

@example
#("@var{characters}" @var{property-data}...)
@end example

@noindent
где @var{property-data} состоит из нуля или более элементов,
в группах по три еденицы следующим образом:

@example
@var{beg} @var{end} @var{plist}
@end example

@noindent
Элементы @var{beg} и @var{end} являются целыми числами, и вместе определяют
диапазон индексов в строке; @var{plist} является список свойств для этого
диапазона. Например,

@example
#("foo bar" 0 3 (face bold) 3 4 nil 4 7 (face italic))
@end example

@noindent
представляет собой строку, текстовое содержимое которой @samp{foo bar},
первые три символа имеют свойство @code{face} со значением @code{bold},
а последние три имеют свойство @code{face} со значением @code{italic}.
(Четвертый символ не имеет свойства текста, поэтому его список свойств
является @code{nil}.  На самом деле нет необходимости отмечать диапазоны
со списком свойств с @code{nil}, так как любые символы, не упомянутые в
любом диапазоне будут по умолчанию, не иметь никаких свойств.)

@node Vector Type
@subsection Тип Вектор

  @dfn{Вектор} является одномерным массивом элементов любого типа.
  Требуется постоянное количество времени для доступа к любому элементу
  вектора.  (В списке, время доступа элемента пропорционально расстоянию
  элемента от начала списка.)

  Печатное представление вектора состоит из левой квадратной скобки,
  элементов и правой квадратной скобки.  Это также синтаксис чтения.
  Как числа и строки, векторы считаются константами при оценки.

@example
[1 "два" (три)]      ; @r{Вектор из трех элементов.}
     @result{} [1 "два" (три)]
@end example

  @xref{Vectors}, функции, работы с векторами.

@node Char-Table Type
@subsection Тип Символ-Таблица

  @dfn{Символ-таблица} является одномерным массивом элементов любого типа,
  индексированного кодами символов.  Символ-таблицы имеют определенные
  дополнительные функции, делающие их более полезными для многих задач,
  которые включают присвоение информации символьным кодам --- например,
  символ-таблица может иметь родителя и наследовать значения по умолчанию,
  а также небольшое количество дополнительных слотов для использования в
  специальных целях.  Символ-таблица может также указать одно значение для
  целого набора символов.

@cindex @samp{#^} read syntax
  Печатное представление символ-таблицы похоже на вектор, за исключением,
  что есть дополнительный символ @samp{#^} в начале.@footnote{Вы также можете встретить @samp{#^^}, используется для суб-символ-таблиц.}

  @xref{Char-Tables}, специальные функции для работы с символ-таблицами.
  Использование символ-таблиц включает:

@itemize @bullet
@item
Таблицы регистра (@pxref{Case Tables}).

@item
Таблицы категорий символов (@pxref{Categories}).

@item
Таблицы отображения (@pxref{Display Tables}).

@item
Таблицы синтаксиса (@pxref{Syntax Tables}).
@end itemize

@node Bool-Vector Type
@subsection Тип Bool-Вектор

  @dfn{Bool-вектор} является одномерным массивом, элементы которого
  должны быть @code{t} или @code{nil}.

  Печатное представление bool-вектора, похоже на печатное представление
  строки, за исключением того, что оно начинается с @samp{#&} с последующей
  указанной длиной.  Строковая константа, которая следует
  дальше, фактически определяет содержимое bool-вектора в виде битовой
  карты---каждый символ в строке содержит 8 бит, которые определяют
  следующие 8 элементов bool-вектора (1 обозначает @code{t}, и 0
  обозначает @code{nil}). Младшие значащие биты символа соответствуют
  младшим индексам в bool-векторе.

@example
(make-bool-vector 3 t)
     @result{} #&3"^G"
(make-bool-vector 3 nil)
     @result{} #&3"^@@"
@end example

@noindent
Эти результаты имеют смысл, потому что двоичный код @samp{C-g} равен
111 и @samp{C-@@} - ето символ с кодом 0.

  Если длина не кратна 8, печатанное представление показывает дополнительные
  элементы, но эти дополнительные элементы не берутся во внимание.  Например,
  в следующем примере, два bool-вектора равны, поскольку используются
  только первые 3 бита:

@example
(equal #&3"\377" #&3"\007")
     @result{} t
@end example

@node Hash Table Type
@subsection Тип Хеш Таблица

    Хэш-таблица является очень быстрым видом таблицы поиска, чем то похожа
    на список, в котором ключи сопоставляются с соответствующими значениями,
    но намного быстрее.  Печатное представление хэш-таблицы определяет её
    свойства и содержание, например:

@example
(make-hash-table)
     @result{} #s(hash-table size 65 test eql rehash-size 1.5
                             rehash-threshold 0.8125 data ())
@end example

@noindent
@xref{Hash Tables}, для получения дополнительной информации о хэш-таблицах.

@node Function Type
@subsection Function Type

  Lisp functions are executable code, just like functions in other
programming languages.  In Lisp, unlike most languages, functions are
also Lisp objects.  A non-compiled function in Lisp is a lambda
expression: that is, a list whose first element is the symbol
@code{lambda} (@pxref{Lambda Expressions}).

  In most programming languages, it is impossible to have a function
without a name.  In Lisp, a function has no intrinsic name.  A lambda
expression can be called as a function even though it has no name; to
emphasize this, we also call it an @dfn{anonymous function}
(@pxref{Anonymous Functions}).  A named function in Lisp is just a
symbol with a valid function in its function cell (@pxref{Defining
Functions}).

  Most of the time, functions are called when their names are written in
Lisp expressions in Lisp programs.  However, you can construct or obtain
a function object at run time and then call it with the primitive
functions @code{funcall} and @code{apply}.  @xref{Calling Functions}.

@node Macro Type
@subsection Macro Type

  A @dfn{Lisp macro} is a user-defined construct that extends the Lisp
language.  It is represented as an object much like a function, but with
different argument-passing semantics.  A Lisp macro has the form of a
list whose first element is the symbol @code{macro} and whose @sc{cdr}
is a Lisp function object, including the @code{lambda} symbol.

  Lisp macro objects are usually defined with the built-in
@code{defmacro} macro, but any list that begins with @code{macro} is a
macro as far as Emacs is concerned.  @xref{Macros}, for an explanation
of how to write a macro.

  @strong{Warning}: Lisp macros and keyboard macros (@pxref{Keyboard
Macros}) are entirely different things.  When we use the word ``macro''
without qualification, we mean a Lisp macro, not a keyboard macro.

@node Primitive Function Type
@subsection Primitive Function Type
@cindex primitive function

  A @dfn{primitive function} is a function callable from Lisp but
written in the C programming language.  Primitive functions are also
called @dfn{subrs} or @dfn{built-in functions}.  (The word ``subr'' is
derived from ``subroutine''.)  Most primitive functions evaluate all
their arguments when they are called.  A primitive function that does
not evaluate all its arguments is called a @dfn{special form}
(@pxref{Special Forms}).

  It does not matter to the caller of a function whether the function is
primitive.  However, this does matter if you try to redefine a primitive
with a function written in Lisp.  The reason is that the primitive
function may be called directly from C code.  Calls to the redefined
function from Lisp will use the new definition, but calls from C code
may still use the built-in definition.  Therefore, @strong{we discourage
redefinition of primitive functions}.

  The term @dfn{function} refers to all Emacs functions, whether written
in Lisp or C@.  @xref{Function Type}, for information about the
functions written in Lisp.

  Primitive functions have no read syntax and print in hash notation
with the name of the subroutine.

@example
@group
(symbol-function 'car)          ; @r{Access the function cell}
                                ;   @r{of the symbol.}
     @result{} #<subr car>
(subrp (symbol-function 'car))  ; @r{Is this a primitive function?}
     @result{} t                       ; @r{Yes.}
@end group
@end example

@node Byte-Code Type
@subsection Byte-Code Function Type

@dfn{Byte-code function objects} are produced by byte-compiling Lisp
code (@pxref{Byte Compilation}).  Internally, a byte-code function
object is much like a vector; however, the evaluator handles this data
type specially when it appears in a function call.  @xref{Byte-Code
Objects}.

The printed representation and read syntax for a byte-code function
object is like that for a vector, with an additional @samp{#} before the
opening @samp{[}.

@node Record Type
@subsection Record Type

  A @dfn{record} is much like a @code{vector}.  However, the first
element is used to hold its type as returned by @code{type-of}.  The
purpose of records is to allow programmers to create objects with new
types that are not built into Emacs.

  @xref{Records}, for functions that work with records.

@node Type Descriptors
@subsection Type Descriptors

  A @dfn{type descriptor} is a @code{record} which holds information
about a type.  Slot 1 in the record must be a symbol naming the type, and
@code{type-of} relies on this to return the type of @code{record}
objects.  No other type descriptor slot is used by Emacs; they are
free for use by Lisp extensions.

An example of a type descriptor is any instance of
@code{cl-structure-class}.

@node Autoload Type
@subsection Autoload Type

  An @dfn{autoload object} is a list whose first element is the symbol
@code{autoload}.  It is stored as the function definition of a symbol,
where it serves as a placeholder for the real definition.  The autoload
object says that the real definition is found in a file of Lisp code
that should be loaded when necessary.  It contains the name of the file,
plus some other information about the real definition.

  After the file has been loaded, the symbol should have a new function
definition that is not an autoload object.  The new definition is then
called as if it had been there to begin with.  From the user's point of
view, the function call works as expected, using the function definition
in the loaded file.

  An autoload object is usually created with the function
@code{autoload}, which stores the object in the function cell of a
symbol.  @xref{Autoload}, for more details.

@node Finalizer Type
@subsection Finalizer Type

  A @dfn{finalizer object} helps Lisp code clean up after objects that
are no longer needed.  A finalizer holds a Lisp function object.
When a finalizer object becomes unreachable after a garbage collection
pass, Emacs calls the finalizer's associated function object.
When deciding whether a finalizer is reachable, Emacs does not count
references from finalizer objects themselves, allowing you to use
finalizers without having to worry about accidentally capturing
references to finalized objects themselves.

Errors in finalizers are printed to @code{*Messages*}.  Emacs runs
a given finalizer object's associated function exactly once, even
if that function fails.

@defun make-finalizer function
Make a finalizer that will run @var{function}.  @var{function} will be
called after garbage collection when the returned finalizer object
becomes unreachable.  If the finalizer object is reachable only
through references from finalizer objects, it does not count as
reachable for the purpose of deciding whether to run @var{function}.
@var{function} will be run once per finalizer object.
@end defun

@node Editing Types
@section Editing Types
@cindex editing types

  The types in the previous section are used for general programming
purposes, and most of them are common to most Lisp dialects.  Emacs Lisp
provides several additional data types for purposes connected with
editing.

@menu
* Buffer Type::         The basic object of editing.
* Marker Type::         A position in a buffer.
* Window Type::         Buffers are displayed in windows.
* Frame Type::          Windows subdivide frames.
* Terminal Type::       A terminal device displays frames.
* Window Configuration Type::   Recording the way a frame is subdivided.
* Frame Configuration Type::    Recording the status of all frames.
* Process Type::        A subprocess of Emacs running on the underlying OS.
* Thread Type::         A thread of Emacs Lisp execution.
* Mutex Type::          An exclusive lock for thread synchronization.
* Condition Variable Type::     Condition variable for thread synchronization.
* Stream Type::         Receive or send characters.
* Keymap Type::         What function a keystroke invokes.
* Overlay Type::        How an overlay is represented.
* Font Type::           Fonts for displaying text.
@end menu

@node Buffer Type
@subsection Buffer Type

  A @dfn{buffer} is an object that holds text that can be edited
(@pxref{Buffers}).  Most buffers hold the contents of a disk file
(@pxref{Files}) so they can be edited, but some are used for other
purposes.  Most buffers are also meant to be seen by the user, and
therefore displayed, at some time, in a window (@pxref{Windows}).  But
a buffer need not be displayed in any window.  Each buffer has a
designated position called @dfn{point} (@pxref{Positions}); most
editing commands act on the contents of the current buffer in the
neighborhood of point.  At any time, one buffer is the @dfn{current
buffer}.

  The contents of a buffer are much like a string, but buffers are not
used like strings in Emacs Lisp, and the available operations are
different.  For example, you can insert text efficiently into an
existing buffer, altering the buffer's contents, whereas inserting
text into a string requires concatenating substrings, and the result
is an entirely new string object.

  Many of the standard Emacs functions manipulate or test the
characters in the current buffer; a whole chapter in this manual is
devoted to describing these functions (@pxref{Text}).

  Several other data structures are associated with each buffer:

@itemize @bullet
@item
a local syntax table (@pxref{Syntax Tables});

@item
a local keymap (@pxref{Keymaps}); and,

@item
a list of buffer-local variable bindings (@pxref{Buffer-Local Variables}).

@item
overlays (@pxref{Overlays}).

@item
text properties for the text in the buffer (@pxref{Text Properties}).
@end itemize

@noindent
The local keymap and variable list contain entries that individually
override global bindings or values.  These are used to customize the
behavior of programs in different buffers, without actually changing the
programs.

  A buffer may be @dfn{indirect}, which means it shares the text
of another buffer, but presents it differently.  @xref{Indirect Buffers}.

  Buffers have no read syntax.  They print in hash notation, showing the
buffer name.

@example
@group
(current-buffer)
     @result{} #<buffer objects.texi>
@end group
@end example

@node Marker Type
@subsection Marker Type

  A @dfn{marker} denotes a position in a specific buffer.  Markers
therefore have two components: one for the buffer, and one for the
position.  Changes in the buffer's text automatically relocate the
position value as necessary to ensure that the marker always points
between the same two characters in the buffer.

  Markers have no read syntax.  They print in hash notation, giving the
current character position and the name of the buffer.

@example
@group
(point-marker)
     @result{} #<marker at 10779 in objects.texi>
@end group
@end example

@xref{Markers}, for information on how to test, create, copy, and move
markers.

@node Window Type
@subsection Window Type

  A @dfn{window} describes the portion of the terminal screen that Emacs
uses to display a buffer.  Every window has one associated buffer, whose
contents appear in the window.  By contrast, a given buffer may appear
in one window, no window, or several windows.

  Though many windows may exist simultaneously, at any time one window
is designated the @dfn{selected window}.  This is the window where the
cursor is (usually) displayed when Emacs is ready for a command.  The
selected window usually displays the current buffer (@pxref{Current
Buffer}), but this is not necessarily the case.

  Windows are grouped on the screen into frames; each window belongs to
one and only one frame.  @xref{Frame Type}.

  Windows have no read syntax.  They print in hash notation, giving the
window number and the name of the buffer being displayed.  The window
numbers exist to identify windows uniquely, since the buffer displayed
in any given window can change frequently.

@example
@group
(selected-window)
     @result{} #<window 1 on objects.texi>
@end group
@end example

  @xref{Windows}, for a description of the functions that work on windows.

@node Frame Type
@subsection Frame Type

  A @dfn{frame} is a screen area that contains one or more Emacs
windows; we also use the term ``frame'' to refer to the Lisp object
that Emacs uses to refer to the screen area.

  Frames have no read syntax.  They print in hash notation, giving the
frame's title, plus its address in core (useful to identify the frame
uniquely).

@example
@group
(selected-frame)
     @result{} #<frame emacs@@psilocin.gnu.org 0xdac80>
@end group
@end example

  @xref{Frames}, for a description of the functions that work on frames.

@node Terminal Type
@subsection Terminal Type
@cindex terminal type

  A @dfn{terminal} is a device capable of displaying one or more
Emacs frames (@pxref{Frame Type}).

  Terminals have no read syntax.  They print in hash notation giving
the terminal's ordinal number and its TTY device file name.

@example
@group
(get-device-terminal nil)
     @result{} #<terminal 1 on /dev/tty>
@end group
@end example

@c FIXME: add an xref to where terminal-related primitives are described.

@node Window Configuration Type
@subsection Window Configuration Type
@cindex window layout in a frame

  A @dfn{window configuration} stores information about the positions,
sizes, and contents of the windows in a frame, so you can recreate the
same arrangement of windows later.

  Window configurations do not have a read syntax; their print syntax
looks like @samp{#<window-configuration>}.  @xref{Window
Configurations}, for a description of several functions related to
window configurations.

@node Frame Configuration Type
@subsection Frame Configuration Type
@cindex screen layout
@cindex window layout, all frames

  A @dfn{frame configuration} stores information about the positions,
sizes, and contents of the windows in all frames.  It is not a
primitive type---it is actually a list whose @sc{car} is
@code{frame-configuration} and whose @sc{cdr} is an alist.  Each alist
element describes one frame, which appears as the @sc{car} of that
element.

  @xref{Frame Configurations}, for a description of several functions
related to frame configurations.

@node Process Type
@subsection Process Type

  The word @dfn{process} usually means a running program.  Emacs itself
runs in a process of this sort.  However, in Emacs Lisp, a process is a
Lisp object that designates a subprocess created by the Emacs process.
Programs such as shells, GDB, ftp, and compilers, running in
subprocesses of Emacs, extend the capabilities of Emacs.
  An Emacs subprocess takes textual input from Emacs and returns textual
output to Emacs for further manipulation.  Emacs can also send signals
to the subprocess.

  Process objects have no read syntax.  They print in hash notation,
giving the name of the process:

@example
@group
(process-list)
     @result{} (#<process shell>)
@end group
@end example

@xref{Processes}, for information about functions that create, delete,
return information about, send input or signals to, and receive output
from processes.

@node Thread Type
@subsection Thread Type

  A @dfn{thread} in Emacs represents a separate thread of Emacs Lisp
execution.  It runs its own Lisp program, has its own current buffer,
and can have subprocesses locked to it, i.e.@: subprocesses whose
output only this thread can accept.  @xref{Threads}.

  Thread objects have no read syntax.  They print in hash notation,
giving the name of the thread (if it has been given a name) or its
address in core:

@example
@group
(all-threads)
    @result{} (#<thread 0176fc40>)
@end group
@end example

@node Mutex Type
@subsection Mutex Type

  A @dfn{mutex} is an exclusive lock that threads can own and disown,
in order to synchronize between them.  @xref{Mutexes}.

  Mutex objects have no read syntax.  They print in hash notation,
giving the name of the mutex (if it has been given a name) or its
address in core:

@example
@group
(make-mutex "my-mutex")
    @result{} #<mutex my-mutex>
(make-mutex)
    @result{} #<mutex 01c7e4e0>
@end group
@end example

@node Condition Variable Type
@subsection Condition Variable Type

  A @dfn{condition variable} is a device for a more complex thread
synchronization than the one supported by a mutex.  A thread can wait
on a condition variable, to be woken up when some other thread
notifies the condition.

  Condition variable objects have no read syntax.  They print in hash
notation, giving the name of the condition variable (if it has been
given a name) or its address in core:

@example
@group
(make-condition-variable (make-mutex))
    @result{} #<condvar 01c45ae8>
@end group
@end example

@node Stream Type
@subsection Stream Type

  A @dfn{stream} is an object that can be used as a source or sink for
characters---either to supply characters for input or to accept them as
output.  Many different types can be used this way: markers, buffers,
strings, and functions.  Most often, input streams (character sources)
obtain characters from the keyboard, a buffer, or a file, and output
streams (character sinks) send characters to a buffer, such as a
@file{*Help*} buffer, or to the echo area.

  The object @code{nil}, in addition to its other meanings, may be used
as a stream.  It stands for the value of the variable
@code{standard-input} or @code{standard-output}.  Also, the object
@code{t} as a stream specifies input using the minibuffer
(@pxref{Minibuffers}) or output in the echo area (@pxref{The Echo
Area}).

  Streams have no special printed representation or read syntax, and
print as whatever primitive type they are.

  @xref{Read and Print}, for a description of functions
related to streams, including parsing and printing functions.

@node Keymap Type
@subsection Keymap Type

  A @dfn{keymap} maps keys typed by the user to commands.  This mapping
controls how the user's command input is executed.  A keymap is actually
a list whose @sc{car} is the symbol @code{keymap}.

  @xref{Keymaps}, for information about creating keymaps, handling prefix
keys, local as well as global keymaps, and changing key bindings.

@node Overlay Type
@subsection Overlay Type

  An @dfn{overlay} specifies properties that apply to a part of a
buffer.  Each overlay applies to a specified range of the buffer, and
contains a property list (a list whose elements are alternating property
names and values).  Overlay properties are used to present parts of the
buffer temporarily in a different display style.  Overlays have no read
syntax, and print in hash notation, giving the buffer name and range of
positions.

  @xref{Overlays}, for information on how you can create and use overlays.

@node Font Type
@subsection Font Type

  A @dfn{font} specifies how to display text on a graphical terminal.
There are actually three separate font types---@dfn{font objects},
@dfn{font specs}, and @dfn{font entities}---each of which has slightly
different properties.  None of them have a read syntax; their print
syntax looks like @samp{#<font-object>}, @samp{#<font-spec>}, and
@samp{#<font-entity>} respectively.  @xref{Low-Level Font}, for a
description of these Lisp objects.

@node Circular Objects
@section Read Syntax for Circular Objects
@cindex circular structure, read syntax
@cindex shared structure, read syntax
@cindex @samp{#@var{n}=} read syntax
@cindex @samp{#@var{n}#} read syntax

  To represent shared or circular structures within a complex of Lisp
objects, you can use the reader constructs @samp{#@var{n}=} and
@samp{#@var{n}#}.

  Use @code{#@var{n}=} before an object to label it for later reference;
subsequently, you can use @code{#@var{n}#} to refer the same object in
another place.  Here, @var{n} is some integer.  For example, here is how
to make a list in which the first element recurs as the third element:

@example
(#1=(a) b #1#)
@end example

@noindent
This differs from ordinary syntax such as this

@example
((a) b (a))
@end example

@noindent
which would result in a list whose first and third elements
look alike but are not the same Lisp object.  This shows the difference:

@example
(prog1 nil
  (setq x '(#1=(a) b #1#)))
(eq (nth 0 x) (nth 2 x))
     @result{} t
(setq x '((a) b (a)))
(eq (nth 0 x) (nth 2 x))
     @result{} nil
@end example

  You can also use the same syntax to make a circular structure, which
appears as an element within itself.  Here is an example:

@example
#1=(a #1#)
@end example

@noindent
This makes a list whose second element is the list itself.
Here's how you can see that it really works:

@example
(prog1 nil
  (setq x '#1=(a #1#)))
(eq x (cadr x))
     @result{} t
@end example

  The Lisp printer can produce this syntax to record circular and shared
structure in a Lisp object, if you bind the variable @code{print-circle}
to a non-@code{nil} value.  @xref{Output Variables}.

@node Type Predicates
@section Type Predicates
@cindex type checking
@kindex wrong-type-argument

  The Emacs Lisp interpreter itself does not perform type checking on
the actual arguments passed to functions when they are called.  It could
not do so, since function arguments in Lisp do not have declared data
types, as they do in other programming languages.  It is therefore up to
the individual function to test whether each actual argument belongs to
a type that the function can use.

  All built-in functions do check the types of their actual arguments
when appropriate, and signal a @code{wrong-type-argument} error if an
argument is of the wrong type.  For example, here is what happens if you
pass an argument to @code{+} that it cannot handle:

@example
@group
(+ 2 'a)
     @error{} Wrong type argument: number-or-marker-p, a
@end group
@end example

@cindex type predicates
@cindex testing types
  If you want your program to handle different types differently, you
must do explicit type checking.  The most common way to check the type
of an object is to call a @dfn{type predicate} function.  Emacs has a
type predicate for each type, as well as some predicates for
combinations of types.

  A type predicate function takes one argument; it returns @code{t} if
the argument belongs to the appropriate type, and @code{nil} otherwise.
Following a general Lisp convention for predicate functions, most type
predicates' names end with @samp{p}.

  Here is an example which uses the predicates @code{listp} to check for
a list and @code{symbolp} to check for a symbol.

@example
(defun add-on (x)
  (cond ((symbolp x)
         ;; If X is a symbol, put it on LIST.
         (setq list (cons x list)))
        ((listp x)
         ;; If X is a list, add its elements to LIST.
         (setq list (append x list)))
        (t
         ;; We handle only symbols and lists.
         (error "Invalid argument %s in add-on" x))))
@end example

  Here is a table of predefined type predicates, in alphabetical order,
with references to further information.

@table @code
@item atom
@xref{List-related Predicates, atom}.

@item arrayp
@xref{Array Functions, arrayp}.

@item bool-vector-p
@xref{Bool-Vectors, bool-vector-p}.

@item booleanp
@xref{nil and t, booleanp}.

@item bufferp
@xref{Buffer Basics, bufferp}.

@item byte-code-function-p
@xref{Byte-Code Type, byte-code-function-p}.

@item case-table-p
@xref{Case Tables, case-table-p}.

@item char-or-string-p
@xref{Predicates for Strings, char-or-string-p}.

@item char-table-p
@xref{Char-Tables, char-table-p}.

@item commandp
@xref{Interactive Call, commandp}.

@item condition-variable-p
@xref{Condition Variables, condition-variable-p}.

@item consp
@xref{List-related Predicates, consp}.

@item custom-variable-p
@xref{Variable Definitions, custom-variable-p}.

@item floatp
@xref{Predicates on Numbers, floatp}.

@item fontp
@xref{Low-Level Font}.

@item frame-configuration-p
@xref{Frame Configurations, frame-configuration-p}.

@item frame-live-p
@xref{Deleting Frames, frame-live-p}.

@item framep
@xref{Frames, framep}.

@item functionp
@xref{Functions, functionp}.

@item hash-table-p
@xref{Other Hash, hash-table-p}.

@item integer-or-marker-p
@xref{Predicates on Markers, integer-or-marker-p}.

@item integerp
@xref{Predicates on Numbers, integerp}.

@item keymapp
@xref{Creating Keymaps, keymapp}.

@item keywordp
@xref{Constant Variables}.

@item listp
@xref{List-related Predicates, listp}.

@item markerp
@xref{Predicates on Markers, markerp}.

@item mutexp
@xref{Mutexes, mutexp}.

@item nlistp
@xref{List-related Predicates, nlistp}.

@item number-or-marker-p
@xref{Predicates on Markers, number-or-marker-p}.

@item numberp
@xref{Predicates on Numbers, numberp}.

@item overlayp
@xref{Overlays, overlayp}.

@item processp
@xref{Processes, processp}.

@item recordp
@xref{Record Type, recordp}.

@item sequencep
@xref{Sequence Functions, sequencep}.

@item string-or-null-p
@xref{Predicates for Strings, string-or-null-p}.

@item stringp
@xref{Predicates for Strings, stringp}.

@item subrp
@xref{Function Cells, subrp}.

@item symbolp
@xref{Symbols, symbolp}.

@item syntax-table-p
@xref{Syntax Tables, syntax-table-p}.

@item threadp
@xref{Basic Thread Functions, threadp}.

@item vectorp
@xref{Vectors, vectorp}.

@item wholenump
@xref{Predicates on Numbers, wholenump}.

@item window-configuration-p
@xref{Window Configurations, window-configuration-p}.

@item window-live-p
@xref{Deleting Windows, window-live-p}.

@item windowp
@xref{Basic Windows, windowp}.
@end table

  The most general way to check the type of an object is to call the
function @code{type-of}.  Recall that each object belongs to one and
only one primitive type; @code{type-of} tells you which one (@pxref{Lisp
Data Types}).  But @code{type-of} knows nothing about non-primitive
types.  In most cases, it is more convenient to use type predicates than
@code{type-of}.

@defun type-of object
This function returns a symbol naming the primitive type of
@var{object}.  The value is one of the symbols @code{bool-vector},
@code{buffer}, @code{char-table}, @code{compiled-function},
@code{condition-variable}, @code{cons}, @code{finalizer},
@code{float}, @code{font-entity}, @code{font-object},
@code{font-spec}, @code{frame}, @code{hash-table}, @code{integer},
@code{marker}, @code{mutex}, @code{overlay}, @code{process},
@code{string}, @code{subr}, @code{symbol}, @code{thread},
@code{vector}, @code{window}, or @code{window-configuration}.
However, if @var{object} is a record, the type specified by its first
slot is returned; @ref{Records}.

@example
(type-of 1)
     @result{} integer
@group
(type-of 'nil)
     @result{} symbol
(type-of '())    ; @r{@code{()} is @code{nil}.}
     @result{} symbol
(type-of '(x))
     @result{} cons
(type-of (record 'foo))
     @result{} foo
@end group
@end example
@end defun

@node Equality Predicates
@section Equality Predicates
@cindex equality

  Here we describe functions that test for equality between two
objects.  Other functions test equality of contents between objects of
specific types, e.g., strings.  For these predicates, see the
appropriate chapter describing the data type.

@defun eq object1 object2
This function returns @code{t} if @var{object1} and @var{object2} are
the same object, and @code{nil} otherwise.

If @var{object1} and @var{object2} are integers with the same value,
they are considered to be the same object (i.e., @code{eq} returns
@code{t}).  If @var{object1} and @var{object2} are symbols with the
same name, they are normally the same object---but see @ref{Creating
Symbols} for exceptions.  For other types (e.g., lists, vectors,
strings), two arguments with the same contents or elements are not
necessarily @code{eq} to each other: they are @code{eq} only if they
are the same object, meaning that a change in the contents of one will
be reflected by the same change in the contents of the other.

@example
@group
(eq 'foo 'foo)
     @result{} t
@end group

@group
(eq 456 456)
     @result{} t
@end group

@group
(eq "asdf" "asdf")
     @result{} nil
@end group

@group
(eq "" "")
     @result{} t
;; @r{This exception occurs because Emacs Lisp}
;; @r{makes just one multibyte empty string, to save space.}
@end group

@group
(eq '(1 (2 (3))) '(1 (2 (3))))
     @result{} nil
@end group

@group
(setq foo '(1 (2 (3))))
     @result{} (1 (2 (3)))
(eq foo foo)
     @result{} t
(eq foo '(1 (2 (3))))
     @result{} nil
@end group

@group
(eq [(1 2) 3] [(1 2) 3])
     @result{} nil
@end group

@group
(eq (point-marker) (point-marker))
     @result{} nil
@end group
@end example

@noindent
The @code{make-symbol} function returns an uninterned symbol, distinct
from the symbol that is used if you write the name in a Lisp expression.
Distinct symbols with the same name are not @code{eq}.  @xref{Creating
Symbols}.

@example
@group
(eq (make-symbol "foo") 'foo)
     @result{} nil
@end group
@end example

@noindent
@cindex identical-contents objects, and byte-compiler
@cindex objects with identical contents, and byte-compiler
The Emacs Lisp byte compiler may collapse identical literal objects,
such as literal strings, into references to the same object, with the
effect that the byte-compiled code will compare such objects as
@code{eq}, while the interpreted version of the same code will not.
Therefore, your code should never rely on objects with the same
literal contents being either @code{eq} or not @code{eq}, it should
instead use functions that compare object contents such as
@code{equal}, described below.  Similarly, your code should not modify
literal objects (e.g., put text properties on literal strings), since
doing that might affect other literal objects of the same contents, if
the byte compiler collapses them.
@end defun

@defun equal object1 object2
This function returns @code{t} if @var{object1} and @var{object2} have
equal components, and @code{nil} otherwise.  Whereas @code{eq} tests
if its arguments are the same object, @code{equal} looks inside
nonidentical arguments to see if their elements or contents are the
same.  So, if two objects are @code{eq}, they are @code{equal}, but
the converse is not always true.

@example
@group
(equal 'foo 'foo)
     @result{} t
@end group

@group
(equal 456 456)
     @result{} t
@end group

@group
(equal "asdf" "asdf")
     @result{} t
@end group
@group
(eq "asdf" "asdf")
     @result{} nil
@end group

@group
(equal '(1 (2 (3))) '(1 (2 (3))))
     @result{} t
@end group
@group
(eq '(1 (2 (3))) '(1 (2 (3))))
     @result{} nil
@end group

@group
(equal [(1 2) 3] [(1 2) 3])
     @result{} t
@end group
@group
(eq [(1 2) 3] [(1 2) 3])
     @result{} nil
@end group

@group
(equal (point-marker) (point-marker))
     @result{} t
@end group

@group
(eq (point-marker) (point-marker))
     @result{} nil
@end group
@end example

Comparison of strings is case-sensitive, but does not take account of
text properties---it compares only the characters in the strings.
@xref{Text Properties}.  Use @code{equal-including-properties} to also
compare text properties.  For technical reasons, a unibyte string and
a multibyte string are @code{equal} if and only if they contain the
same sequence of character codes and all these codes are in the range
0 through 127 (@acronym{ASCII}).

@example
@group
(equal "asdf" "ASDF")
     @result{} nil
@end group
@end example

However, two distinct buffers are never considered @code{equal}, even if
their textual contents are the same.
@end defun

  The test for equality is implemented recursively; for example, given
two cons cells @var{x} and @var{y}, @code{(equal @var{x} @var{y})}
returns @code{t} if and only if both the expressions below return
@code{t}:

@example
(equal (car @var{x}) (car @var{y}))
(equal (cdr @var{x}) (cdr @var{y}))
@end example

Because of this recursive method, circular lists may therefore cause
infinite recursion (leading to an error).

@defun equal-including-properties object1 object2
This function behaves like @code{equal} in all cases but also requires
that for two strings to be equal, they have the same text properties.

@example
@group
(equal "asdf" (propertize "asdf" 'asdf t))
     @result{} t
@end group
@group
(equal-including-properties "asdf"
                            (propertize "asdf" 'asdf t))
     @result{} nil
@end group
@end example
@end defun
