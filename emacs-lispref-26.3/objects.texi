@c -*- mode: texinfo; coding: utf-8 -*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2019 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Lisp Data Types
@chapter Типы Данных Lisp
@cindex object
@cindex Lisp object
@cindex type
@cindex data type

  Lisp @dfn{объект} представляет собой часть данных, которые использует
  и которыми манипулируют программы Лиспа. Для наших целей, @dfn{тип}
  или @dfn{тип данных} представляет собой набор возможных объектов.

  Каждый объект принадлежит, по крайней мере, к одному типу. Объекты одного
  типа имеют сходные структуры и, как правило, могут быть использованы в
  одних и тех же контекстах.  Типы могут пересекаться, и объекты могут
  принадлежать двум или более типам.  Следовательно, мы можем спросить,
  принадлежит ли объект к определенному типу, но не какого @dfn{типа} объект.

@cindex primitive type
  В Emacs встроено несколько основных типов объектов.  Из этих типов строятся все
  остальные типы, они называются @dfn{примитивными типами}.  Каждый из таких объектов
  принадлежит одному и только одному элементарному типу. Эти типы включают
  @dfn{целочисленное}, @dfn{число с плавающей точкой}, @dfn{cons-ячейка},
  @dfn{символ},@dfn{строка}, @dfn{вектор}, @dfn{хеш-таблица}, @dfn{subr},
  @dfn{скомпилированная функция}, @dfn{запись}, а также несколько специальных,
  таких как @dfn{buffer}, которые связаны с редактированием.
  (@xref{Editing Types}.)

  Каждый примитивный тип имеет соответствующую функцию Lisp, которая проверяет,
  является ли объект членом этого типа.

  Отличие Lisp от многих других языков, в том, что его объекты
  @dfn{self-typing (самотипирующие)}: примитивный тип каждого объекта неявен
  в самом объекте. Например, если объект является вектором, ничто не может
  рассматривать его как число; Lisp знает, что это вектор, а не число.

  В большинстве языков, программист должен объявить тип данных каждой переменной,
  и этот тип известен компилятору, но не представлен в данных. Такие заявления
  типов не существует в Emacs Lisp. Переменная Lisp может иметь любой тип значения,
  и она запоминает любое значение, которое вы в ней храните. (На самом деле,
  небольшое количество Emacs Lisp переменных может принимать только значение
  определенного типа. @xref{Variables with Restricted Values}.)

  В этой главе описывается назначение, печатное представление, синтаксис чтения
  каждого из стандартных типов в GNU Emacs Lisp. Подробности о том, как
  использовать эти типы могут быть найдены в следующих главах.

@menu
* Printed Representation::      Как Lisp объекты представлены в виде текста.
* Comments::                    Комментарии и правила их форматирования.
* Programming Types::           Типы встречающиеся во всех системах Lisp.
* Editing Types::               Типы специфичные для Emacs.
* Circular Objects::            Синтаксис чтения для циклических структур.
* Type Predicates::             Тесты, связь с типами.
* Equality Predicates::         Проверка равенства между любыми двумя объектами.
@end menu

@node Printed Representation
@section Печатное Представление и Чтение Синтаксиса
@cindex printed representation
@cindex read syntax

  @dfn{Печатное представление (print)} объекта является форматом выходного сигнала,
  генерируемого лисповсим принтером (функция @code{prin1}) для этого объекта.
  Каждый тип данных имеет уникальное печатное представление. @dfn{чтение синтаксиса}
  объекта является форматом ввода, принятого лисповским читателем (функция @code{read})
  для этого объекта. Это не обязательно является уникальным; многие типы объектов
  имеют более одного синтаксиса.  @xref{Read and Print}.

@cindex hash notation
  В большинстве случаев, печатное представление объекта, является также синтаксисом
  чтения для объекта. Однако, у некоторых типов нет синтаксиса чтения, поскольку нет
  смысла вводить оьъекты этих типов как константы в программе на Lisp. Эти объекты
  печатаются как @dfn{хеш-нотации}, состоящей из символов @samp{#<}, описательная
  строка (как правило, после имени типа следует имя объекта), и завершающей @samp{>}.
  Например:

@example
(current-buffer)
     @result{} #<buffer objects.texi>
@end example

@noindent
Хеш-нотация вообще не может быть прочитана, так что читатель Lisp сигнализирует
об ошибке @code{invalid-read-syntax} всякий раз, когда он встречает @samp{#<}.
@kindex invalid-read-syntax

  В других языках выражение - это текст; у него нет другой формы. В Lisp
  выражение - это прежде всего объект Lisp, и только потом текст, который
  является синтаксисом чтения объекта. Часто нет необходимости подчеркивать
  это различие, но вы всегда должны помнить об этом, иначе вы иногда будете
  сильно сбиты с толку.

  Когда вы вычислите выражение в интерактивном режиме, интерпретатор Lisp
  сначала считывает его текстовое представление, создавая объект Lisp,
  а затем оценивает этот объект (@pxref{Evaluation}). Тем не менее,
  оценка и чтение являются отдельными видами деятельности. Чтение
  возвращает объект Lisp, прочитанный из текстового представления;
  объект может оценён или не оценен позже. @xref{Input Functions},
  для описания @code{read}, основной функции для чтения объектов.

@node Comments
@section Коментарии
@cindex comments
@cindex @samp{;} for commenting

  @dfn{Коментарий} это текст, который написан в программе только ради людей,
  которые читают эту программу, и это не имеет никакого влияния на смысл
  программы. В Lisp, неэкранированная точка с запятой (@samp{;}) начинает
  комментарий, если он не находится внутри строковой или символьной константы.
  Комментарий продолжается до конца строки. Lisp читатель отбрасывает комментарии;
  они не становятся частью объектов Лиспа, которые представляют программу
  в рамках системы Lisp.

  @samp{#@@@var{count}} конструкция, которая пропускает следующие символы
  @var{count}, полезна для сгенерированных комментариев программой,
  содержащих двоичные данные. Emacs Lisp это в своих выходных файлах
  (@pxref{Byte Compilation}). Однако она не предназначена для исходных файлов.

  @xref{Comment Tips}, соглашения о форматировании комментариев.

@node Programming Types
@section Програмные Типы
@cindex programming types

  Есть две основные категории типов в Emacs Lisp: те, которые имеют дело с
  программированием на Lisp, и те, которые имеют дело с редактированием.
  Первые существует во многих реализациях Lisp, в той или иной форме.
  Последние являются уникальными для Emacs Lisp.

@menu
* Integer Type::        Числа без дробных частей.
* Floating-Point Type:: Числа с дробными частями и с большим диапазоном.
* Character Type::      Представление букв, цифр и управляющих символов.
* Symbol Type::         Многофункциональный объект, который ссылается на функцию,
                        переменную или список свойств, и имеет уникальный идентификатор.
* Sequence Type::       Списки и Массивы классифицируются как последовательности.
* Cons Cell Type::      Cons-ячейки, а также списки (которые сделаны из cons-ячеек).
* Array Type::          Массивы включают строки и векторы.
* String Type::         (Эффективный) массив символов.
* Vector Type::         Одномерные массивы.
* Char-Table Type::     Одномерные разреженные массивы, индексированные по символам.
* Bool-Vector Type::    Одномерные массивы @code{t} или @code{nil}.
* Hash Table Type::     Сверх-быстрые таблицы поиска.
* Function Type::       Фрагмент исполняемого, который можно вызвать из любого места.
* Macro Type::          Метод расширения выражения в другое выражение, более
                        фундаментального, но менее красивое.
* Primitive Function Type::     Функция написана в C, вызываемая из Lisp.
* Byte-Code Type::      Функция написана на Lisp, затем скомпилированная.
* Record Type::         Составные объекты с определенным программистом типами.
* Type Descriptors::    Объекты хранения информации о типах.
* Autoload Type::       Тип используется для автоматической загрузки редко используемых функций.
* Finalizer Type::      Не Запускается код больше, если не доступен.

@end menu

@node Integer Type
@subsection Целочисленный Тип

  Диапазон значений для целого числа зависит от машины. Минимальный диапазон
  составляет от @minus{}536,870,912 to 536,870,911 (30 bits; i.e.,
@ifnottex
@minus{}2**29
@end ifnottex
@tex
@math{-2^{29}}
@end tex
до
@ifnottex
2**29 @minus{} 1)
@end ifnottex
@tex
@math{2^{29}-1})
@end tex
но многие машины обеспечивают более широкий диапазон.
Emacs Lisp арифметические функции не проверяют целочисленное переполнение.
Таким образом, @code{(1+ 536870911)} получается @minus{}536,870,912,
если целые числа Emacs составляют 30 бит.

  Синтаксис чтения для целых чисел представляет собой последовательность цифр
  (по основанию десять) с необязательным знаком в начале и дополнительной
  точкой в конце. Печатное представление, созданное интерпретатором Лиспа,
  никогда не имеет ведущего символа @samp{+} или конечного @samp{.}.

@example
@group
-1               ; @r{Целое число @minus{}1.}
1                ; @r{Целое число 1.}
1.               ; @r{Также Целое число 1.}
+1               ; @r{Также Целое число 1.}
@end group
@end example

@noindent
В качестве особого исключения, если последовательность цифр определящая целое
число слишком большая или слишком мала, чтобы быть допустимым целочисленным
объектом, читатель Лисп считывает его как число с плавающей точкой
(@pxref{Floating-Point Type}). Например, если Emacs целые равны 30 бит,
@code{536870912} считывается как число с плавающей точкой @code{536870912.0}.

  @xref{Numbers}, для детальной информации.

@node Floating-Point Type
@subsection Тип Число с Плавающей Точкой

  Числа с плавающей точкой являются компьютерным эквивалентом научной нотации;
  Вы можете думать о числе с плавающей точкой как о дроби со степенью десять.
  Точное число значащих цифр и диапазон возможных показателей зависит от
  машины; Emacs использует тип данных C @code{double} для хранения значения,
  и внутренне он записывает степень 2, а не степень 10.

  Печатное представление для чисел с плавающей точкой требует либо десятичной
  точки (с как минимум с дной следующей цифрой), либо экспоненты, либо того и
  другого. Например, @samp{1500.0}, @samp{+15e2}, @samp{15.0e+2},@samp{+1500000e-3}
  и @samp{.15e4} представляют собой пять способов записи числа с плавающей точкой,
  значение которого 1500. Все они эквивалентны.

  @xref{Numbers}, для детальной информации.

@node Character Type
@subsection Символьные Типы
@cindex @acronym{ASCII} character codes

  @dfn{Символы} в Emacs Lisp - не более чем целое число. Другими словами,
  символы представлены их кодами символов. Например, @kbd{A} символ
  представлен как @w{integer 65}.

  Отдельные символы используются иногда в программах, но чаще для работы
  с @emph{strings}, которые представляют собой последовательности,
  состоящие из символов.  @xref{String Type}.

  Символы в строках и буферах в настоящее время ограничены в диапазоном
  от 0 до 4194303 --- двадцать два бита (@pxref{Character Codes}).
  Коды от 0 до 127 - это @acronym{ASCII} коды; остальные non-@acronym{ASCII}
  (@pxref{Non-ASCII Characters}). Символы, которые представляют ввод с
  клавиатуры имеют гораздо более широкий диапазон, чтобы кодирования
  клавиш-модификаторов, таких как Control, Meta и Shift.

  Существуют специальные функции для получения удобочитаемого текстового
  описания символа для сообщений.  @xref{Describing Characters}.

@menu
* Basic Char Syntax::      Синтаксис обычных символов.
* General Escape Syntax::  Как определить символы по их кодам.
* Ctl-Char Syntax::        Синтаксис для управляющих символов.
* Meta-Char Syntax::       Синтаксис для мета-символов.
* Other Char Bits::        Синтаксис для hyper-, super-, и alt-символов.
@end menu

@node Basic Char Syntax
@subsubsection Базовый Синтаксис Символов
@cindex read syntax for characters
@cindex printed representation for characters
@cindex syntax for characters
@cindex @samp{?} in character constant
@cindex question mark in character constant

  Так как символы на самом деле целые числа, печатное представление символа
  представляет собой десятичное число. Это также возможный синтаксис чтения
  для символа, но написание таким образом в программах на Лиспе - не
  понятное программирование. Вы @emph{всегда} должны использовать специальные
  форматы синтаксиса для чтения, которые Emacs Lisp предоставляет для символов.
  Эти форматы синтаксиса начинаются со знака вопроса.

  Обычный синтаксис чтения для алфавитно-цифровых символов - это вопросительный
  знак, за которым следует символ; Таким образом, @samp{?A} для символа @kbd{A},
  @samp{?B} для символа @kbd{B} и @samp{?a} для символа @kbd{a}.

  Для примера:

@example
?Q @result{} 81     ?q @result{} 113
@end example

  Вы можете использовать тот же синтаксис для знаков пунктуации. Однако, если знак
  препинания имеет специальный синтаксический смысл в Лиспе, вы должны экранировать
  его с помощью @samp{\}. Например, @samp{?\(} является способом написания символа
  открытой скобки.  Точно так же, если нужно использовать символ @samp{\}, вы должны
  использовать второй @samp{\} чтобы процитировать его: @samp{?\\}.

@cindex whitespace
@cindex bell character
@cindex @samp{\a}
@cindex backspace
@cindex @samp{\b}
@cindex tab (ASCII character)
@cindex @samp{\t}
@cindex vertical tab
@cindex @samp{\v}
@cindex formfeed
@cindex @samp{\f}
@cindex newline
@cindex @samp{\n}
@cindex return (ASCII character)
@cindex @samp{\r}
@cindex escape (ASCII character)
@cindex @samp{\e}
@cindex space (ASCII character)
@cindex @samp{\s}
  Вы можете выразить символы control-g, backspace, tab, newline, vertical tab,
  formfeed, space, return, del, и escape как @samp{?\a}, @samp{?\b}, @samp{?\t},
  @samp{?\n}, @samp{?\v}, @samp{?\f}, @samp{?\s}, @samp{?\r}, @samp{?\d}, и
  @samp{?\e} соответственно.
  (@samp{?\s} с последующим тире имеет другое значение --- он применяет модификатор
  Super к следующиму символу.)  Таким образом,

@example
?\a @result{} 7                 ; @r{control-g, @kbd{C-g}}
?\b @result{} 8                 ; @r{возврат на одну позицию, @key{BS}, @kbd{C-h}}
?\t @result{} 9                 ; @r{табуляция, @key{TAB}, @kbd{C-i}}
?\n @result{} 10                ; @r{перевод строки, @kbd{C-j}}
?\v @result{} 11                ; @r{вертикальная табуляция, @kbd{C-k}}
?\f @result{} 12                ; @r{перевод страницы, @kbd{C-l}}
?\r @result{} 13                ; @r{возврат каретки, @key{RET}, @kbd{C-m}}
?\e @result{} 27                ; @r{escape-символ, @key{ESC}, @kbd{C-[}}
?\s @result{} 32                ; @r{пробел, @key{SPC}}
?\\ @result{} 92                ; @r{обратная косая черта, @kbd{\}}
?\d @result{} 127               ; @r{удалить символ, @key{DEL}}
@end example

@cindex escape sequence
  Эти последовательности, которые начинаются с обратной косой черты также
  известны как @dfn{escape последовательности}, потому что обратная косая
  черта играет роль экранирующего символа; это не имеет ничего общего с
  символом @key{ESC}. @samp{\s} предназначен для использования в символьных
  константах; в строковых констант, просто напишите пробел.

  Обратная косая черта допускается и безвредена, если предшествует символу без
  особого escape-смысла; Таким образом, @samp{?\+} эквивалентно @samp{?+}. Нет
  причин, чтобы добавить обратный слэш перед большинством символов. Тем не менее,
  вы должны добавить обратную косую черту перед любым из символов @samp{()[]\;"},
  и вы должны добавить обратную косую черту перед любым из символов @samp{|'`#.,},
  чтобы не спутать команды Emacs для редактирования кода Lisp. Вы можете также
  добавить обратный слэш перед пробельных символов, таких как пробел, табуляция,
  перевод строки и перевод страницы. Тем не менее, лучше использовать один из
  легко понимаемых управляющих последовательностей, таких как @samp{\t} или @samp{\s},
  вместо фактического символа пробела, такого как табуляция или пробел. (Если вы пишите
  обратную косую черту, а затем пробел, вы должны написать дополнительный пробел
  после символьной константы, чтобы отделить его от последующего текста.)

@node General Escape Syntax
@subsubsection Общий Escape Синтакс

  В дополнение к конкретным экранирующим последовательностям для специальных важных
  управляющих символов, Emacs предоставляет несколько типов синтаксиса
  escape-последовательностей, которые можно использовать, чтобы указать
  не-@acronym{ASCII} текстового символа.

@enumerate
@item
@cindex @samp{\} in character constant
@cindex backslash in character constants
@cindex unicode character escape
Вы можете указать символ по его имени Unicode, если таковые имеются.
@code{?\N@{@var{NAME}@}} представляет символ Unicode с именем @var{NAME}.
Таким образом, @samp{?\N@{LATIN SMALL LETTER A WITH GRAVE@}} эквивалентно
@code{?à} и обозначает символ Unicode U + 00E0. Для упрощения ввода
многостроковых строк, вы можете заменить пробелы в именах непустыми
последовательностями пробельных символов (например, новая строка).

@item
Вы можете указать символы по их значениям Unicode. @code{?\N@{U+@var{X}@}}
представляет собой символ с кодовой точкой Unicode @var{X}, где @var{X} является
шестнадцатеричным числом. Кроме того, @code{?\u@var{xxxx}} и
@code{?\U@var{xxxxxxxx}} представляют собой кодовые точки @var{xxxx}
и @var{xxxxxxxx}, соответственно, где каждый @var{x} является одной
шестнадцатеричной цифрой. Например, @code{?\N@{U+E0@}}, @code{?\u00e0} и
@code{?\U000000E0} все эквивалентны @code{?à} и
@samp{?\N@{LATIN SMALL LETTER A WITH GRAVE@}}. Стандарт Unicode определяет
кодовые точки только до @samp{U+@var{10ffff}}, поэтому если вы указываете
кодовую точку кода выше, Emacs сигнализирует об ошибке.

@item
Вы можете указать символы, c помощью их шестнадцатиричных кодов. Шестнадцатеричная
escape-последовательность состоит из обратной косой черты, @samp{x} и
шестнадцатеричного кода символа. Таким образом, @samp{?\x41} - это символ
@kbd{A}, @samp{?\x1} - это символ @kbd{C-a} и @code{?\xe0} - это символ
@kbd{à} (@kbd{a} с серьезным акцентом). Вы можете использовать любое количество
шестнадцатеричных цифр, так что вы можете представить любой код символа
таким образом.

@item
@cindex octal character code
Вы можете указать символы по их восьмеричному коду. Восьмеричная управляющая
последовательность состоит из обратной косой черты, за которой следует до
трех восьмеричных цифр; Таким образом, @samp{?\101} для символа @kbd{A},
@samp{?\001} для символа @kbd{C-a} и @code{?\002} для символа @kbd{C-b}.
Только символы до восьмеричного кода 777 могут быть заданы таким образом.

@end enumerate

  Эти последовательности также могут быть использованы в строках.
  @xref{Non-ASCII in Strings}.

@node Ctl-Char Syntax
@subsubsection Управляющие-Символы Синтаксис

@cindex control characters
  Управляющие символы могут быть представлены с помощью еще одного синтаксиса
  чтения. Он состоит из знака вопроса с последующим обратной косой,
  кареткой, и соответствующей неконтролирующий символ, в верхнем или
  нижнем регистре. Например, @samp{?\^I} и @samp{?\^i} допустимый
  синтаксис чтения для символа @kbd{C-i}, значение которого равно 9.

  Вместо @samp{^}, вы можете использовать @samp{C-}; Таким образом,
  @samp{?\C-i} эквивалентно @samp{?\^I} и @samp{?\^i}:

@example
?\^I @result{} 9     ?\C-I @result{} 9
@end example

  В строках и буферах, разрешены только управляющие символы, которые
  существуют в @acronym{ASCII}; но для ввода с клавиатуры, вы можете
  превратить любой символ в управляющий символ с @samp{C-}. Коды
  символов для этих управляющих не-@acronym{ASCII} символов включают
@tex
@math{2^{26}}
@end tex
@ifnottex
2**26
@end ifnottex
бит, а также код соответствующего неуправляющего символа. Обычные текстовые
терминалы не имеют возможности генерации управляющих не-@acronym{ASCII}
символов, но вы можете создать их непосредственно с помощью X и других
оконных систем.

  По историческим причинам, Emacs трактует @key{DEL} символ в качестве
  управляющего символа эквивалента @kbd{?}:

@example
?\^? @result{} 127     ?\C-? @result{} 127
@end example

@noindent
В результате, в настоящее время не представляется возможным представить
управляющий символ @kbd{Control-?}, который является значимым входным
символом в X, используя @samp{\C-}. Это не так легко изменить, так как
различные Lisp файлы ссылаются на @key{DEL} таким образом.

  Для представления управляющих символов, которые можно найти в файлах или
  строках, мы рекомендуем синтаксис @samp{^}; для управляющих символов
  ввода с клавиатуры, мы предпочитаем синтаксис @samp{C-}. Какой из них
  вы используете, не влияет на смысл программы, но может способствовать
  пониманию людей, которые читают его.

@node Meta-Char Syntax
@subsubsection Мета-Символы Синтакс

@cindex meta characters
  @dfn{Мета-Символом} является введенный символ с помощью клавиши-модификатора
  @key{META}. Целое число, которое представляет собой такой символ имеет
  набор
@tex
@math{2^{27}}
@end tex
@ifnottex
2**27
@end ifnottex
бит. Мы используем старшие биты для этого и других модификаторов, чтобы сделать
возможным широкий спектр базовых кодов символов.

  В строке,
@tex
@math{2^{7}}
@end tex
@ifnottex
2**7
@end ifnottex
бит, прикреплённого к символу @acronym{ASCII}, указывается мета-символ;
Таким образом, мета-символы, которые могут поместиться в строке имеют
коды в диапазоне от 128 до 255, и являются мета-версии обычных символов
@acronym{ASCII}. @xref{Strings of Events}, для получения подробной
информации о @key{META} обработки в строках.

  Синтаксис чтения для мета-символов использует @samp{\M-}. Например,
  @samp{?\M-A} означает @kbd{M-A}. Вы можете использовать @samp{\M-}
  вместе с восьмеричными кодами символов (см ниже), с @samp{\C-}, или
  с каким-либо другим синтаксисом для символа. Таким образом, вы можете
  написать @kbd{M-A} в @samp{?\M-A}, или как @samp{?\M-\101}. Кроме того,
  вы можете написать @kbd{C-M-b} в @samp{?\M-\C-b}, @samp{?\C-\M-b} или
  @samp{?\M-\002}.

@node Other Char Bits
@subsubsection Другие Биты Модификации Символов

  Регистр графического символа указывается его кодом символа; например,
  @acronym{ASCII} различает между символами @samp{a} и @samp{A}. Но
  @acronym{ASCII} не имеет возможности представлять является ли управляющий
  символ верхнего или нижнего регистра. Emacs использует
@tex
@math{2^{25}}
@end tex
@ifnottex
2**25
@end ifnottex
бит, чтобы указать, что клавиша Shift используется при наборе управляющего символа.
Это различие возможно только при использовании X терминалов или других специальных
терминалов; обычные текстовые терминалы не сообщают различия. Синтаксис Лиспа
для бита сдвига является @samp{\S-}; Таким образом, @samp{\C-\S-o} или
@samp{?\C-\S-O} представляет собой символ сдвинутого элемента управления.

@cindex hyper characters
@cindex super characters
@cindex alt characters
  Система X Window определяет три других бита @anchor{modifier bits} модификатора,
  которые могут быть установлены в символе: @dfn{hyper}, @dfn{super} и @dfn{alt}.
  Синтаксис для этих битов @samp{\H-}, @samp{\s-} and @samp{\A-}. (Важен регистр
  в этих префиксах.) Таким образом, @samp{?\H-\M-\A-x} представляет
  @kbd{Alt-Hyper-Meta-x}. (Обратите внимание, что @samp{\s} с не следующими (здесь
  непонятно что имеет ввиду) @samp{-} не представляет собой символ пробела.)
@tex
Численно битовые значения @math{2^{22}} для alt, @math{2^{23}} для super и
@math{2^{24}} для гипер.
@end tex
@ifnottex
Численно битовые значения 2**22  для alt, 2**23 для super и 2**24 для hyper.
@end ifnottex

@node Symbol Type
@subsection Тип Символа

  @dfn{Символ} в GNU Emacs Lisp является объектом с именем.  Имя символа служит
  его печатным представлением символа.  При обычном использовании Lisp, с одной
  единственной obarray (@pxref{Creating Symbols}), имя символа является
  уникальным --- нет двух символов с одинаковым именем.

  Символ может служить в качестве переменной, как имя функции, или для хранения
  списка свойств.  Или он может служить только для того, чтобы быть отличным от
  всех других объектов Lisp, так что его присутствие в структуре данных, может
  быть надежно распознаются.  В данном контексте, как правило, только одно из
  этих целей предполагается.  Но вы можете использовать один символ всеми этими
  способами, независимо друг от друга.

  Символ, имя которого начинается с двоеточия (@samp{:}) называется
  @dfn{символом ключевого слова}.  Эти символы автоматически действуют как
  константы, и, как правило, используются только для сравнения неизвестного
  символа с несколькими определенными альтернативами.  @xref{Constant Variables}.

@cindex @samp{\} in symbols
@cindex backslash in symbols
  Имя символа может содержать любые символы.  Большинство имен символов
  написаны буквами, цифрами и знаками препинания @samp{-+=*\}.  Такие имена
  не требуют специальной пунктуации; символов имени достаточно, если имя
  не выглядит как число.  (Если это так, пишите @samp{\} в начале имени для
  принудительной интерпретации как символа.)  Символы
  @samp{_~!@@$%^&:<>@{@}?} реже используется, но также не требуют
  специальной пунктуации.  Любые другие символы могут быть включены в имя
  символа путем экранирования их обратной косой чертой.  В отличие от его
  использования в строках, однако, обратный слэш во имени символа просто
  цитирует один символ, который следует за обратной косой чертой. Например,
  в строке, @samp{\t} представляет собой символ табуляции; в имени символа,
  однако, @samp{\t} просто цитирует запись @samp{t}.  Для того, чтобы иметь
  символ с символом табуляции в своём имени, вы должны фактически
  использовать табуляцию (перед которой стоит обратная косая черта).  Но
  такое встречается редко.

@cindex CL note---case of letters
@quotation
@b{Common Lisp note:}  В Common Lisp, строчные буквы всегда переводятся в
в верхний регистр, если только они явно не экранированы.  В Emacs Lisp,
строчные и прописные буквы различны.
@end quotation

  Вот несколько примеров имен символов. Обратите внимание, что @samp{+}
  в четвертом примере экранируется, чтобы предотвратить его от чтения как
  число. Это не является необходимым в шестом примере, потому что
  остальная часть имени делает его недействительным как число.

@example
@group
foo                 ; @r{Символ с именем @samp{foo}.}
FOO                 ; @r{Символ с именем @samp{FOO}, отличный от @samp{foo}.}
@end group
@group
1+                  ; @r{Символ с именем @samp{1+}}
                    ;   @r{(не @samp{+1}, который является целым числом).}
@end group
@group
\+1                 ; @r{Символ с именем @samp{+1}}
                    ;   @r{(не очень читаемое имя).}
@end group
@group
\(*\ 1\ 2\)         ; @r{Символ c именем @samp{(* 1 2)} (неудачное имя).}
@c the @'s в этой следующей строке использовать три символа,
@c следовательно, кажущееся смещение комментария.
+-*/_~!@@$%^&=:<>@{@}  ; @r{Символ с именем @samp{+-*/_~!@@$%^&=:<>@{@}}.}
                    ;   @r{Эти символы не нужно экранировать.}
@end group
@end example

@cindex @samp{##} read syntax
@ifinfo
@c При этом используется "colon" вместо буквального ':' потому,
@c что информация не может справиться с ':' в меню.
@cindex @samp{#@var{colon}} read syntax
@end ifinfo
@ifnotinfo
@cindex @samp{#:} read syntax
@end ifnotinfo
  В качестве исключения из правила, согласно которому имя символа служит
  его печатным представлением, @samp{##}---это печатное представление для
  интернированного символа, имя которого является пустой строкой. Кроме
  того, @samp{#:@var{foo}} это печатное представление для uninterned
  (здесь неясность неорганизованного) символа, имя которого @var{foo}.
  (Как правило, читатель Lisp обрабатывает все символы;
  @pxref{Creating Symbols}.)

@node Sequence Type
@subsection Тип Последовательность

  @dfn{Последовательность} является объектом Lisp, который представляет
  собой упорядоченный набор элементов.  Есть два вида последовательности
  в Emacs Lisp: @dfn{списки} и @dfn{массивы}.

  Списки являются наиболее часто используемыми последовательностями. Список
  может содержать элементы любого типа, и его длина может быть легко
  изменена путем добавления или удаления элементов. Смотрите следующий
  подраздел для получения дополнительной информации о списках.

  Массивы представляют собой последовательность фиксированной длины.  Они
  подразделяются на строки, векторы, символ-таблицы и BOOL векторы.  Векторы
  могут содержать элементы любого типа, в то время как строки должны
  содержать только символы, и BOOL-векторы должны содержать лишь @code{t}
  или @code{nil}.  Символ-таблицы похожи на векторы, за исключением того, что
  они проиндексированы любым допустимым кодом символа.  Символы в строке
  могут иметь свойства текста, такие как символы в буфере
  (@pxref{Text Properties}), но векторы не поддерживают свойство текста,
  даже если их элементы являются символами.

  Списки, строки и другие типы массивов также имеют важное сходство.
  Например, все они имеют длину @var{l}, и все они имеют элементы, которые
  могут быть проиндексированы от нуля до @var{l} минус один.  Некоторые
  функции, называемые функциями последовательности, принимают либой вид
  последовательности. Например, функция @code{length} сообщает длину
  любого вида последовательности.  @xref{Sequences Arrays Vectors}.

  Как правило, невозможно читать ту же последовательность дважды, так как
  последовательности всегда создается заново при чтении.  Если вы дважды
  прочитаете синтакс чтения для последовательности, вы получите две
  последовательности с одинаковым содержимым. Существует одно исключение:
  пустой список @code{()} всегда обозначает тот же объект, @code{nil}.

@node Cons Cell Type
@subsection Типы Cons-Ячейка и Список
@cindex address field of register
@cindex decrement field of register
@cindex pointers

  @dfn{Cons-ячейка} это объект, который состоит из двух слотов, слот
  @sc{car} и слот @sc{cdr}. Каждый слот может @dfn{содержать} любой
  объект Lisp.  (здесь нужно отредактировать, непонятки) Мы также
  говорим, что @sc{car} этой cons-ячейки является
  любой объект, и слот @sc{car} в настоящее время имеет место, а также
  для @sc{cdr}.

@cindex list structure
  @dfn{Список} это ряд cons-ячеек, связаных друг с другом, так что @sc{cdr}
  слот каждой cons-ячейки имеет либо следующую cons-ячейку либо пустой
  список. Пустой список на самом деле символ @code{nil}. @xref{Lists},
  для деталей. Поскольку большинство cons-ячеек используются как часть
  списков, мы называем любую структуру, изготовленную из cons-ячеек,
  @dfn{структурой списка}.

@cindex linked list
@quotation
Замечание для программистов C: список Lisp, таким образом, работает как
@dfn{связаный список} состоящий из cons-ячеек.  Поскольку указатели в
Lisp неявные, мы не делаем различия между слот cons-ячейки содержит значение
и указывает на значение.
@end quotation

@cindex atoms
  Сons-ячейка занимает центральное место в Lisp, но также есть объекты,
  который не являются cons-ячейкой.  Эти объекты называются
  @dfn{атомами}.

@cindex parenthesis
@cindex @samp{(@dots{})} in lists
  Синтаксис чтения и печатное представление списков идентичны и состоят
  из левой круглой скобки, произвольного числа элементов, и правой скобки.
  Вот примеры списков:

@example
(A 2 "A")            ; @r{Список из трех элементов.}
()                   ; @r{Список без элементов (пустой список).}
nil                  ; @r{Список без элементов (пустой список).}
("A ()")             ; @r{Список из одного элемента: строка @code{"A ()"}}.
(A ())               ; @r{Список из двух элементов: @code{A} и пустой список.}
(A nil)              ; @r{Эквивалент к предыдущему.}
((A B C))            ; @r{Список из одного элемента}
                     ;   @r{(который представляет собой список из трех элементов).}
@end example

   При чтении, каждый объект внутри скобок становится элементом списка.  То
   есть, для каждого элемента создаётся cons-ячейка.  Слот @sc{car} из
   cons-ячейки удерживает элемент, а её @sc{cdr} слот относится к следующей
   cons-ячейки списка, которая содержит следующий элемент в списке. @sc{cdr}
   слот последней cons-ячейки содержит @code{nil}.

  Имена @sc{car} и @sc{cdr} вытекают из истории Lisp. Оригинальная
  реализация Lisp исполнялась на @w{IBM 704} компьютере, который разделял
  слово на две части, адрес и декремент; @sc{car} была инструкция для
  извлечения содержимого адресной части регистра, и @sc{cdr} инструкция,
  чтобы извлечь содержимое декремента. Напротив, cons-ячейки названы
  в честь функции @code{cons}, которая создает их, в свою очередь, была
  назван в честь своего назначения, конструирование ячеек.

@menu
* Box Diagrams::                Рисование изображений списков.
* Dotted Pair Notation::        Общий синтаксис для cons-ячейки.
* Association List Type::       Специально построенный список.
@end menu

@node Box Diagrams
@subsubsection Схема Списка в Виде Прямоугольников
@cindex box diagrams, for lists
@cindex diagrams, boxed, for lists

  Список можно проиллюстрировать диаграммой, в которой cons-ячейки показаны
  в виде пар прямоугольников, как домино.  (Читатель Lisp не может прочитать
  такую ​​иллюстрацию, в отличие от текстовой нотации, которая может быть
  понята как людьми, так и компьютерами, прямоугольные иллюстрации могут
  быть поняты только людьми.)  Эта картина представляет собой трёхэлементный
  список @code{(роза фиалка лютик)}:

@example
@group
    --- ---      --- ---      --- ---
   |   |   |--> |   |   |--> |   |   |--> nil
    --- ---      --- ---      --- ---
     |            |            |
     |            |            |
      --> роза     --> фиалка   --> лютик
@end group
@end example

  На этой диаграмме каждый прямоугольник представляет собой слот, который
  может содержать или ссылаться на любой объект Lisp.  Каждая пара
  прямоугольников представляет собой cons-ячейку.  Каждая стрелка
  представляет собой ссылку на объект Lisp, атом или другую cons-ячейку.

  В данном примере, первый прямоугольник, содержит @sc{car} первой
  cons-ячейки, которая ссылается или содержит @code{роза} (символ).
  Второй прямоугольник, содержит @sc{cdr} первой cons-ячейки, относится
  к следующей паре прямоугольников, второй cons-ячейки. @sc{car} второй
  cons-ячейки является @code{фиалка}, и его @sc{cdr} является третьей
  cons-ячейкой. @sc{cdr} из третьей (и последней) cons-ячейки является
  @code{nil}.

  Вот еще одна схема того же списка, @code{(роза фиалка лютик)},
  набросанная по-другому:

@smallexample
@group
 ---------------       ----------------       -------------------
| car   | cdr   |     | car    | cdr   |     | car       | cdr   |
| роза  |   o-------->| фиалка |   o-------->| лютик     |  nil  |
|       |       |     |        |       |     |           |       |
 ---------------       ----------------       -------------------
@end group
@end smallexample

@cindex @code{nil} as a list
@cindex empty list
  Список без элементов в нём --- это @dfn{пустой список}; он идентичен
  символу @code{nil}. Другими словами, @code{nil} является одновременно
  символом и списком.

  Вот список @code{(A ())}, или что то же самое @code{(A nil)}, изображен
  прямоугольниками и стрелками:

@example
@group
    --- ---      --- ---
   |   |   |--> |   |   |--> nil
    --- ---      --- ---
     |            |
     |            |
      --> A        --> nil
@end group
@end example

  Вот более сложный рисунок, показывающий список из трех элементов,
  @code{((сосна хвоя) дуб клён)}, первый элемент которого является
  список из двух элементов:

@example
@group
    --- ---      --- ---      --- ---
   |   |   |--> |   |   |--> |   |   |--> nil
    --- ---      --- ---      --- ---
     |            |            |
     |            |            |
     |             --> дуб      --> клён
     |
     |     --- ---      --- ---
      --> |   |   |--> |   |   |--> nil
           --- ---      --- ---
            |            |
            |            |
             --> сосна    --> хвоя
@end group
@end example

  Тот же список, представленный в другой нотации выглядит следующим образом:

@example
@group
 --------------       --------------       --------------
| car   | cdr  |     | car   | cdr  |     | car   | cdr  |
|   o   |   o------->| дуб   |   o------->| клён  |  nil |
|   |   |      |     |       |      |     |       |      |
 -- | ---------       --------------       --------------
    |
    |
    |        --------------       ----------------
    |       | car   | cdr  |     | car     | cdr  |
     ------>| сосна |   o------->| хвоя    |  nil |
            |       |      |     |         |      |
             --------------       ----------------
@end group
@end example

@node Dotted Pair Notation
@subsubsection Нотация Точечной Пары
@cindex dotted pair notation
@cindex @samp{.} in lists

  @dfn{Нотация точечной пары} является общим синтаксисом cons-ячейки,
  который представляет @sc{car} и @sc{cdr} явно. В  этом синтаксисе,
  @code{(@var{a} .@: @var{b})} обозначает cons-ячейку, у которой @sc{car}
  является объектом @var{a} и чья @sc{cdr} является объектом @var{b}.
  Нотация точечной пары является более общей, чем синтаксис списка, потому
  что @sc{cdr} не обязательно может быть списком.  Тем не менее, это более
  громоздкий синтаксис в тех случаях, когда синтаксис списка будет работать.
  В нотации точечной пары, список @samp{(1 2 3)} записывается в виде
  @samp{(1 .  (2 . (3 . nil)))}.  Для списков заканчивающихся @code{nil}, вы
  можете использовать любую нотацию, но нотация списка, как правило, более
  ясна и удобна.  При печати списка, нотация точечной пары используется
  только тогда, когда @sc{cdr} из cons-ячейки не список.

  Вот пример c использованием прямоугольников для иллюстрации нотации
  точечной пары.  Этот пример показывает пару @code{(роза . фиалка)}:

@example
@group
    --- ---
   |   |   |--> фиалка
    --- ---
     |
     |
      --> роза
@end group
@end example

  Вы можете комбинировать нотацию точечной пары и нотацию списка, для
  удобного представления цепочки cons-ячеек с не-@code{nil} в @sc{cdr}
  конечной cons-ячейки.   Вы пишете точку после @sc{car} последнего
  элемента списка,  за которой  следует @sc{cdr} конечной cons-ячейки.
  Например,  @code{(роза фиалка . лютик)} эквивалентно
  @code{(роза . (фиалка . лютик))}. Объект выглядит следующим образом:

@example
@group
    --- ---      --- ---
   |   |   |--> |   |   |--> лютик
    --- ---      --- ---
     |            |
     |            |
      --> роза     --> фиалка
@end group
@end example

  Синтаксис @code{(роза .@: фиалка .@: лютик)} является недействительным,
  потому что нет ничего, что это может означать.  Во всяком случае, это
  указание поставить @code{лютик} в слот @sc{cdr} cons-ячейки которая
  уже используются для @code{фиалка}.

  Список @code{(роза фиалка)} эквивалентно @code{(роза . (фиалка))}, и
  выглядит следующим образом:

@example
@group
    --- ---      --- ---
   |   |   |--> |   |   |--> nil
    --- ---      --- ---
     |            |
     |            |
      --> роза     --> фиалка
@end group
@end example

  Аналогичным образом, записи трёхэлементного списка
  @code{(роза фиалка лютик)} и
  @code{(роза . (фиалка . (лютик)))} эквивалентны.
@ifnottex
Похоже, что это:

@example
@group
    --- ---      --- ---      --- ---
   |   |   |--> |   |   |--> |   |   |--> nil
    --- ---      --- ---      --- ---
     |            |            |
     |            |            |
      --> роза     --> фиалка   --> лютик
@end group
@end example
@end ifnottex

@node Association List Type
@subsubsection Тип Ассоциативный Список

  @dfn{Ассоциативный список} или @dfn{alist} представляет собой специально
  построенный список, элементами которого является cons-ячейки. В каждом
  элементе, @sc{car} считается @dfn{ключом}, а @sc{cdr} считается
  @dfn{ассоциативным значением}. (В некоторых случаях, ассоциированное
  значение сохраняется в @sc{car} в @sc{cdr}.) Ассоциативные списки часто
  используются как стеки, так как легко добавлять или удалять ассоциации
  в передней части списка.

  Например,

@example
(setq alist-of-colors
      '((роза . красный) (лилия . белый) (лютик . жёлтый)))
@end example

@noindent
устанавливает переменную @code{alist-of-colors} в ассоциативный список
из трех элементов. В первом элементе, @code{роза} является ключом а
@code{красный} это ассоциативное значение.

  @xref{Association Lists}, для детального объяснения alists и функций,
  для работы с alists. @xref{Hash Tables}, для другого типа справочной
  таблицы, которая намного быстрее обрабатывает большое количество ключей.

@node Array Type
@subsection Тип Массив

  @dfn{Массив} состоит из произвольного числа слотов для удержания или
  ссылок на другие объекты Lisp, расположенных в непрерывном блоке памяти.
  Доступ к любому элементу массива занимает примерно одинаковое время.
  В противоположность этому, доступ к элементу списка требует времени,
  пропорционального положению элемента в списке. (Доступ к элементам в
  конце списка занимает больше времени, чем доступ к элементам в начале
  списка.)

  Emacs определяет четыре типа массива: строки, векторы, BOOL-векторы,
  и символьная-таблица.

  Строка представляет собой массив символов, а вектор представляет собой
  массив произвольных объектов.  Bool-вектор может содержать только @code{t}
  или @code{nil}.  Эти типы массивов могут иметь любую длину до наибольшего
  целого числа.  Символ-таблицы --- это разреженные массивы, индексированные
  любым допустимым кодом символа; они могут содержать произвольные объекты.

  Первый элемент массива имеет нулевой индекс, второй элемент имеет
  индекс --- 1, и так далее.  Это называется индексация с
  @dfn{нулевым происхождением}.  Например, массив из четырех элементов
  имеют индексы 0, 1, 2, @w{и 3}. Наибольшее возможное значение индекса на
  единицу меньше, чем длина массива. После того, как массив создан, его
  длина фиксирована.

  Все Emacs Lisp массивы являются одномерными.  (Большинство других языков
  программирования поддерживают многомерные массивы, но они не являются
  обязательными, вы можете получить тот же эффект с вложенными одномерными
  массивами.)  Каждый тип массива имеет свой собственный синтаксис чтения;
  детали в следующих разделах.

  Тип массива представляет собой подмножество типа последовательности,
  и содержит тип строка, тип вектора, тип BOOL-вектор и тип
  символ-таблица.

@node String Type
@subsection Тип Строка

  @dfn{Строка} представляет собой массив символов.  Строки используются для
  многих целей в Emacs, как можно ожидать, в текстовом редакторе; например,
  как имена символов Lisp, как сообщения для пользователя, а также для
  представления текста, извлеченного из буферов. Строки в Lisp константы:
  оценка строки возвращает ту же строку.

  @xref{Strings and Characters} функции, которые работают со строками.

@menu
* Syntax for Strings::      Как определить Lisp строки.
* Non-ASCII in Strings::    Международные символы в строках.
* Nonprinting Characters::  Буквенные непечатные символы в строках.
* Text Props and Strings::  Строки с текстовыми свойствами.
@end menu

@node Syntax for Strings
@subsubsection Синтаксис для Строк

@cindex @samp{"} in strings
@cindex double-quote in strings
@cindex @samp{\} in strings
@cindex backslash in strings
  Синтаксис чтения для строки является взятие в двойные кавычки,
  произвольное число символов, @code{"это строка"}.  Чтобы включить
  символ двойной кавычки в строке, поставьте перед ним обратную косуя
  черту;  Таким образом, @code{"\""} это строка, содержащая только одну
  двойную кавычку.  Кроме того, вы можете включить обратную косую черту,
  предварив её другим символом обратной косой черты, как здесь:
  @code{"Здесь \\, стоит одна обратная косая черта"}.

@cindex newline in strings
  Символ новой строки не является специальным в синтаксисе чтения для строк;
  если вы пишете новую строку между двойными кавычками, он становится
  символом в строке.  Но экранированный символ новой строки --- тот,
  которому предшествует @samp{\} --- не становится частью строки; т.е.
  читатель Lisp игнорирует экранированный символ новой строки при чтении
  строки.  Экраннированный пробел @w{@samp{\ }} аналогичным образом
  игнорируется.

@example
"Полезно включать в строках документации
символы новой строки строки, но символ новой строки \
игнорируется, \
если \
он \
экранирован."
     @result{} "Полезно включать в строках документации
символы новой строки строки, но символ новой строки игнорируется, если он экранирован."
@end example

@node Non-ASCII in Strings
@subsubsection Не-@acronym{ASCII} Символы в Строках

  Есть два текстовых представлений для не-@acronym{ASCII} символов в
  строках Emacs: многобайтное и однобайтное (@pxref{Text Representations}).
  Грубо говоря, однобайтная строка хранит необработанные байты, в то время
  как многобайтная строка хранить удобочитаемый текст.  Каждый символ в
  однобайтной строке составляет один байт, то есть, его значение находится
  между 0 и 255. В отличие от этого, каждый символ в многобайтной строке
  может иметь значение в диапазоне от 0 до 4194303 (@pxref{Character Type}).
  В обоих случаях символы со значением выше 127 не-@acronym{ASCII}.

  Вы можете включать не-@acronym{ASCII} символ в строковой константе,
  написав его в буквальном смысле.  Если строковая константа считывается
  из многобайтного источника, такого как многобайтный буфер или строка,
  или если файл будет посещён как многобайтный, то Emacs читает каждый
  не-@acronym{ASCII} как многобайтный символ и автоматически делает строку
  многобайтной строкой.  Если строковая константа считывается из
  однобайтного источника, то Emacs считывает не-@acronym{ASCII} символ как
  однобайтный и делает строку однобайтной.

  Вместо того, чтобы писать символ буквально в многобайтной строке, вы
  можете записать его в своем коде символа с помощью
  escape-последовательности. @xref{General Escape Syntax}, для получения
  подробной информации о экранирующих последовательностях.

  Если вы используете escape-последовательность в стиле Unicode
  @samp{\uNNNN} или @samp{\U00NNNNNN} в строковой константе
  (даже для @acronym{ASCII} символа), Emacs автоматически предполагает,
  что она многобайтная.

  Вы можете также использовать шестнадцатеричные escape-последовательности
  (@samp{\x@var{n}}) и восьмеричные escape-последовательности
  (@samp{\@var{n}}) в строковых константах.  @strong{Будьте осторожны:}
  Если строковая константа содержит шестнадцатеричные или восьмеричные
  escape-последовательности, и все эти управляющие последовательности
  указывают однобайтные символы (т.е. меньше, чем 256), и в строке нет
  никаких других буквальных не-@acronym{ASCII} символов или
  escape-последовательностей в Unicode-стиле, то Emacs автоматически
  принимает что это строка однобайтная.  То есть, предполагается, что все
  не-@acronym{ASCII} символы встречающиеся в строке являются 8-битными
  необработанными байтами.

  В шестнадцатеричных и восьмиричных управляющих последовательностях,
  экранированый код символа может содержать переменное число цифр, так
  что первый последующий символ, который не является допустимой
  шестнадцатиричной или восьмеричной цифрой, завершает
  escape-последовательность.  Если следующий символ в строке может быть
  интерпретирован как шестнадцатеричная или восьмеричной цифра, пишите
  @w{@samp{\ }} (обратный слэш и пробел), чтобы завершить
  escape-последовательность.  Например, @w{@samp{\xe0\ }} представляет
  собой один символ, @samp{a} с серьезным акцентом.  @w{@samp{\ }} в
  строковой константе точно так же как обратный слэш-символ новой строки;
  не вносит какие-либо символы в строку, но прекращает любую предшествующую
  шестндадцатиричную escape-последовательность.

@node Nonprinting Characters
@subsubsection Непечатаемые символы в строках

  Вы можете использовать те же escape-последовательности с обратной
  косой чертой, используемые в строковых константах, и для символьных
  литералов (но не используйте знак вопроса, с которого начинается
  символьная константа). Например, вы можете написать строку, содержащую
  непечатаемый символ табуляции и @kbd{C-a}, с запятой и пробелом между
  ними, вот так: @code{"\t, \C-a"}. @xref{Character Type}, для описания
  синтаксиса чтения для символов.

  Однако, не все символы, которые вы можете написать с обратной косой
  чертой в escape-последовательности допустимы в строках.  Единственные
  управляющие символами, которая строка может содержать, - это
  управляющие символы @acronym{ASCII}. Строки не различают регистр
  в управляющих символах @acronym{ASCII}.

  Собственно говоря, строки не могут содержать метасимволы; но когда
  строка будет использоваться в качестве ключевой последовательности,
  существует специальное соглашение, которое обеспечивает способ
  представления мета-версий @acronym{ASCII} символов в строке. Если вы
  используете синтаксис @samp{\M-}, чтобы указать мета-символ в
  строковой константе, это установит
@tex
@math{2^{7}}
@end tex
@ifnottex
2**7
@end ifnottex
бит символа в строке. Если строка используются в @code{define-key} или
@code{lookup-key}, этот цифровой код переводится в эквивалентный
метасимвол.  @xref{Character Type}.

  Строки не могут содержать символы, которые имеют модификаторы
  hyper, super, или alt.

@node Text Props and Strings
@subsubsection Текстовые Свойства Строки

@cindex @samp{#(} read syntax
@cindex text properties, read syntax
  Строка может содержать свойства для символов, которые она содержит,
  в дополнение к самим символам.  Это позволяет программам, которые
  копируют текст между строками и буферами, копировать свойства текста
  без особых усилий. @xref{Text Properties}, для объяснения того, что
  означает свойство текста. Строки с текстовыми свойствами используют
  специальный синтаксис для чтения и печати:

@example
#("@var{characters}" @var{property-data}...)
@end example

@noindent
где @var{property-data} состоит из нуля или более элементов,
в группах по три еденицы следующим образом:

@example
@var{beg} @var{end} @var{plist}
@end example

@noindent
Элементы @var{beg} и @var{end} являются целыми числами, и вместе определяют
диапазон индексов в строке; @var{plist} является список свойств для этого
диапазона. Например,

@example
#("foo bar" 0 3 (face bold) 3 4 nil 4 7 (face italic))
@end example

@noindent
представляет собой строку, текстовое содержимое которой @samp{foo bar},
первые три символа имеют свойство @code{face} со значением @code{bold},
а последние три имеют свойство @code{face} со значением @code{italic}.
(Четвертый символ не имеет свойства текста, поэтому его список свойств
является @code{nil}.  На самом деле нет необходимости отмечать диапазоны
со списком свойств с @code{nil}, так как любые символы, не упомянутые в
любом диапазоне будут по умолчанию, не иметь никаких свойств.)

@node Vector Type
@subsection Тип Вектор

  @dfn{Вектор} является одномерным массивом элементов любого типа.
  Требуется постоянное количество времени для доступа к любому элементу
  вектора.  (В списке, время доступа элемента пропорционально расстоянию
  элемента от начала списка.)

  Печатное представление вектора состоит из левой квадратной скобки,
  элементов и правой квадратной скобки.  Это также синтаксис чтения.
  Как числа и строки, векторы считаются константами при оценки.

@example
[1 "два" (три)]      ; @r{Вектор из трех элементов.}
     @result{} [1 "два" (три)]
@end example

  @xref{Vectors}, функции, работы с векторами.

@node Char-Table Type
@subsection Тип Символ-Таблица

  @dfn{Символ-таблица} является одномерным массивом элементов любого типа,
  индексированного кодами символов.  Символ-таблицы имеют определенные
  дополнительные функции, делающие их более полезными для многих задач,
  которые включают присвоение информации символьным кодам --- например,
  символ-таблица может иметь родителя и наследовать значения по умолчанию,
  а также небольшое количество дополнительных слотов для использования в
  специальных целях.  Символ-таблица может также указать одно значение для
  целого набора символов.

@cindex @samp{#^} read syntax
  Печатное представление символ-таблицы похоже на вектор, за исключением,
  что есть дополнительный символ @samp{#^} в начале.@footnote{Вы также можете встретить @samp{#^^}, используется для суб-символ-таблиц.}

  @xref{Char-Tables}, специальные функции для работы с символ-таблицами.
  Использование символ-таблиц включает:

@itemize @bullet
@item
Таблицы регистра (@pxref{Case Tables}).

@item
Таблицы категорий символов (@pxref{Categories}).

@item
Таблицы отображения (@pxref{Display Tables}).

@item
Таблицы синтаксиса (@pxref{Syntax Tables}).
@end itemize

@node Bool-Vector Type
@subsection Тип Bool-Вектор

  @dfn{Bool-вектор} является одномерным массивом, элементы которого
  должны быть @code{t} или @code{nil}.

  Печатное представление bool-вектора, похоже на печатное представление
  строки, за исключением того, что оно начинается с @samp{#&} с последующей
  указанной длиной.  Строковая константа, которая следует
  дальше, фактически определяет содержимое bool-вектора в виде битовой
  карты---каждый символ в строке содержит 8 бит, которые определяют
  следующие 8 элементов bool-вектора (1 обозначает @code{t}, и 0
  обозначает @code{nil}). Младшие значащие биты символа соответствуют
  младшим индексам в bool-векторе.

@example
(make-bool-vector 3 t)
     @result{} #&3"^G"
(make-bool-vector 3 nil)
     @result{} #&3"^@@"
@end example

@noindent
Эти результаты имеют смысл, потому что двоичный код @samp{C-g} равен
111 и @samp{C-@@} - ето символ с кодом 0.

  Если длина не кратна 8, печатанное представление показывает дополнительные
  элементы, но эти дополнительные элементы не берутся во внимание.  Например,
  в следующем примере, два bool-вектора равны, поскольку используются
  только первые 3 бита:

@example
(equal #&3"\377" #&3"\007")
     @result{} t
@end example

@node Hash Table Type
@subsection Тип Хеш Таблица

    Хэш-таблица является очень быстрым видом таблицы поиска, чем то похожа
    на список, в котором ключи сопоставляются с соответствующими значениями,
    но намного быстрее.  Печатное представление хэш-таблицы определяет её
    свойства и содержание, например:

@example
(make-hash-table)
     @result{} #s(hash-table size 65 test eql rehash-size 1.5
                             rehash-threshold 0.8125 data ())
@end example

@noindent
@xref{Hash Tables}, для получения дополнительной информации о хэш-таблицах.

@node Function Type
@subsection Тип Функция

  Lisp функция --- исполняемый код, так же как и функция в других языках
  программирования.  В Lisp, в отличии от большинства языков, функция также
  это Lisp объект.  Не-скомпилированая функция в Lisp является
  лямбда-выражением: то есть, список первый элемент которого является
  символом @code{lambda} (@pxref{Lambda Expressions}).

  В большинстве языков программирования, невозможно иметь функцию без имени.
  В Lisp, функция не имеет собственного имени.  Лямбда-выражения может
  быть вызвано как функция, даже если оно не имеет имени; чтобы подчеркнуть
  это, мы называем его @dfn{анонимной функцией}
  (@pxref{Anonymous Functions}).  Именованная функция Lisp --- просто символ
  с действительной функцией в ячейки функции (@pxref{Defining Functions}).

  В большинстве случаев функции вызываются, когда их имена записаны в Lisp
  выражениях в программах Lisp.  Тем не менее, вы можете построить или
  получить объект функции во время выполнения, а затем вызвать его с помощью
  примитивных функций @code{funcall} и @code{apply}.
  @xref{Calling Functions}.

@node Macro Type
@subsection Тип Макрос

  @dfn{Lisp макрос} является определенная пользователем конструкция, которая
  расширяет язык Lisp.  Она представлена как объект, очень похожий на
  функцию, но с другой семантикой передачи аргументов.  Lisp макрос имеет
  вид списка, первый элемент которого является символом @code{macro} и чей
  @sc{cdr} является объектом функции Lisp, включая символ @code{lambda}.

  Объекты Lisp макрос обычно определяются с помощью встроенного
  @code{defmacro} макроса, но любой список, который начинается с
  @code{macro}, является макросом для Emacs.  @xref{Macros}, чтобы узнать,
  как написать макрос.

  @strong{Предупреждение}: Lisp макрос и клавиатурный макрос
  (@pxref{Keyboard Macros}) совершенно разные вещи. Когда мы используем
  слово ``macro'' без уточнения, мы имеем в виду Lisp макрос, а не
  клавиатурный макрос.

@node Primitive Function Type
@subsection Тип Примитивная Функция
@cindex primitive function

  @dfn{Примитивная функция} функция вызывается из Lisp но написано на языке
  программирования Си.  Примитивные функции также называются
  @dfn{subrs (вспомогательными)} или @dfn{встроенными функциями}.  (Слово
  ``subr'' происходит от ``subroutine'' (подпрограмма).) Большинство
  примитивных функций оценивает все свои аргументы, при их вызове.
  Примитивная функция, которая не оценивает все свои аргументы называется
  @dfn{специальной формой} (@pxref{Special Forms}).

  Для вызывающей функции не имеет значения,является ли функция примитивной.
  Однако, это имеет значение, если вы попытаетесь переопределить примитив с
  помощью функции, написанной на Lisp.  Причина заключается в том, что
  примитивная функция может быть вызвана непосредственно из кода C.  Вызов
  переопределённой функцию из Lisp будет использовать новое определение, но
  вызов из кода Cи может по-прежнему использовать встроенное определение.
  Поэтому, @strong{мы не рекомендуем переопределять примитивные функции}.

  Термин @dfn{функция} относится ко всем функциям Emacs, будь то написаных
  на Lisp или C@.  @xref{Function Type}, для получения информации о
  функциях, написанных на Lisp.

  Примитивные функции не имеют синтаксис для чтения и печатаются в
  хэш-нотации с именем подпрограммы.

@example
@group
(symbol-function 'car)          ; @r{Доступ к функции}
                                ;   @r{ячейки символа.}
     @result{} #<subr car>
(subrp (symbol-function 'car))  ; @r{Это примитивная функция?}
     @result{} t                       ; @r{Да.}
@end group
@end example

@node Byte-Code Type
@subsection Тип Двоичная Функция

@dfn{Объект двоичная функция} создаётся путём байт-компиляции кода Lisp
(@pxref{Byte Compilation}).  Внутренне, объект двоичной функции очень похож
на вектор; однако, оценщик обрабатывает этот тип данных особенно когда он
появляется в вызове функции.  @xref{Byte-Code Objects}.

Синтаксис печатного представления и чтения для объекта двоичной функции
аналогичен синтаксису вектора, с дополнительным @samp{#} перед открывающейся
@samp{[}.

@node Record Type
@subsection Тип Запись

  @dfn{Запись} очень похож на @code{вектор}.  Тем не менее, первый элемент
  используется для хранения своего типа, возвращаемого @code{type-of}.
  Назначение типа @dfn{запись}, позволить программистам создавать объекты с
  новыми типами, которые не встроены в Emacs.

  @xref{Records}, функции для работы с объектами запись.

@node Type Descriptors
@subsection Тип Дескриптор

  @dfn{Тип дескриптор} является @code{объектом запись}, который содержит
  информацию о типе.  Слот 1 в записи должен быть символом обозначающим тип
  и @code{type-of} полагается на это, чтобы вернуть тип объектов
  @code{запись}.  Emacs не использует другой тип слота дескриптора; они
  свободны для использования расширениями Lisp.

  Примером дескриптора типа является любой экземпляр
  @code{cl-structure-class}.

@node Autoload Type
@subsection Тип Автозагрузка

  @dfn{Объект автозагрузки} --- это список, первым элементом которого
  является символ @code{autoload}.  Он хранится как определение функции
  символа, где он служит заполнителем для реального определения. Объект
  автозагрузки сообщает, что реальное определение находится в файл Lisp
  кода, который должен быть загружен в случае необходимости. Он содержит
  имя файла, а также некоторую другую информацию о реальном определении.

  После загрузки файла, символ должен иметь новое определение функции,
  которое не является объектом автозагрузки.  Затем вызывается новое,
  как если бы оно было изначально.  С точки зрения пользователя, вызов
  функции работает как и ожидалось, используя определение функции в
  загруженном файле.

  Объект автозагрузка обычно создается с помощью функции @code{autoload},
  которая соххранит объект в функциональной ячейки символа.
  @xref{Autoload}, для деталей.

@node Finalizer Type
@subsection Тип Финализатор

  @dfn{Объект финализатор} помогает коду Lisp удалять объекты, которые
  больше не нужны.  Финализатор содержит объект функции Lisp.  Когда объект
  финализатора становится недоступным после сбора мусора, Emacs вызывает
  связанный объект функции финализатора.  Решая, доступен ли финализатор,
  Emacs не учитывает ссылки от самих объектов финализаторов, что позволяет
  использовать финализаторы без необходимости беспокоиться о случайно
  захваченной ссылки на сами финализаторы.

  Ошибки в финализаторах печатаются на @code{*Messages*}.  Emacs выполняет
  функцию, связанную с данным объектом финализатором, ровно один раз, даже
  если эта функция не выполняется.

@defun make-finalizer function
Создаёт объект финализатор, который будет работать с @var{function}.
@var{function} будет вызываться после сборки мусора, когда возвращённый
объект финализатора становится недоступным.  Если объект финализатора
доступен только через ссылку из объектов финализатора, он не считается
достижимым с целью принятия решения, будет ли запущенна @var{function}.
@var{function} будет выполняться один раз для каждого объекта финализатора.
@end defun

@node Editing Types
@section Типы Редактирования
@cindex editing types

  Типы в предыдущем разделе, используются для общих целей программирования,
  и большинство из них являются общими для большинства Lisp диалектов. Emacs
  Lisp предоставляет несколько дополнительных типов данных для целей,
  связанных с редактированием.

@menu
* Buffer Type::         Основной объект редактирования.
* Marker Type::         Позиция в буфере.
* Window Type::         Буферы отображаются в окнах.
* Frame Type::          Окна подразделяют  фреймы.
* Terminal Type::       Терминальное устройство отображает кадры.
* Window Configuration Type::   Запись способа разделения кадра.
* Frame Configuration Type::    Запись состояния всех кадров.
* Process Type::        Подпроцесс Emacs работает на базовой ОС.
* Thread Type::         Поток исполнения Emacs Lisp.
* Mutex Type::          Исключительная блокировка для синхронизации потоков.
* Condition Variable Type::     Переменная Условие для синхронизации потоков.
* Stream Type::         Получить или отправить символы.
* Keymap Type::         Какую функцию вызывает нажатия клавиши.
* Overlay Type::        Как представляется наложение.
* Font Type::           Шрифты для отображения текста.
@end menu

@node Buffer Type
@subsection Тип Буфер

  @dfn{Буфер} представляет собой объект, содержащий текст, который может
  быть отредактирован (@pxref{Buffers}).  Большинство буферов содержат
  содержимое файла на диске (@pxref{Files}) таким образом они могут быть
  отредактированы, но некоторые из них используются для других целей.
  Большая часть буферов также предназначены, чтобы их видел пользователь,
  и поэтому они отображается, в какой-то момент, в окне (@pxref{Windows}).
  Но буфер можно не отображать в окне.  Каждый буфер имеет обозначенное
  положение, называемое @dfn{точка} (@pxref{Positions}); большинство
  команд редактирования действует на содержимом текущего буфера в
  окрестностях точки. В любое время, один буфер является
  @dfn{текущим буфером}.

  Содержимое буфера очень похоже на строку, но буферы не используются, как
  строки в Emacs Lisp, и доступные операции для них отличны.  Например, вы
  можете эффективно вставить текст  в существующий буфер, изменяя содержимое
  буфера, в то время как вставки текста в строку требуют конкатенаций
  подстрок, и в результат получается совсем новый объект строки.

  Многие из стандартных функций Emacs манипулируют или проверяют символы в
  текущем буфере; целая глава в этом руководстве посвящена описанию этих
  функций (@pxref{Text}).

  С каждым буфером связано несколько других структур данных:

@itemize @bullet
@item
локальная таблица синтаксиса (@pxref{Syntax Tables});

@item
локальная раскладка (@pxref{Keymaps}); и,

@item
список привязок локальных переменных буфера (@pxref{Buffer-Local Variables}).

@item
наложения (@pxref{Overlays}).

@item
свойства текста для текста в буфере (@pxref{Text Properties}).
@end itemize

@noindent
Локальная раскладка и список переменных содержат записи, которые по
отдельности индивидуально переопределяют глобальные привязки или значения.
Они используются для настройки поведения программ в различных буферах,
фактически не изменяя программы.

  Буфер может быть @dfn{косвенным}, что означает, что он разделяет текст
  другого буфера, но представляет его по-другому.  @xref{Indirect Buffers}.

  У буферов нет синтаксиса чтения.  Они печатаются в хэш-нотации, с
  указанием имени буфера.

@example
@group
(current-buffer)
     @result{} #<buffer objects.texi>
@end group
@end example

@node Marker Type
@subsection Тип Маркер

  @dfn{Маркер} обозначает положение в конкретном буфере.  Таким образом,
  маркеры имеют два компонента: один для буфера, и один для позиции.
  Изменения в тексте буфера автоматически перемещают значение позиции по
  мере необходимости, чтобы маркер всегда указывал между одними и теми же
  двумя символами в буфере.

  Маркеры не имеют не синтаксиса чтеие.  Они печатаются в хэш-нотации,
  указывая текущую позицию символа и имя буфера.

@example
@group
(point-marker)
     @result{} #<marker at 10779 in objects.texi>
@end group
@end example

@xref{Markers}, для получения информации о том, как тестировать, создавать,
копировать и перемещать маркеры.

@node Window Type
@subsection Тип Окно

  @dfn{Окно} описывает часть экрана терминала, которое Emacs использует для
  отображения буфера.  Каждое окно имеет один связанный с ним буфер,
  содержимое которого отображается в окне.  В отличие от этого, данный буфер
  может появиться в одном окне, без окна или в нескольких окнах.

  Хотя многие окна могут существовать одновременно, в любой момент времени
  одно окно назначается @dfn{выбранное окно}.  Это окно, в котором (обычно)
  отображается курсор, когда Emacs готов для выполнения команды.  Выбранное
  окно обычно отображает текущий буфер (@pxref{Current Buffer}), но это не
  обязательно так.

  Окна группируются на экране в фреймы; каждое окно принадлежит одному и
  только одному фрейму.  @xref{Frame Type}.

  Окна не предоставляют синтаксис чтения.  Они печатаются в хэш-нотации,
  давая номер окна и имя отображаемого буфера.  Номера окон существует для
  однозначной идентификации окна, так как буфер, отображаемый в любом
  заданном окне, может часто меняться.

@example
@group
(selected-window)
     @result{} #<window 1 on objects.texi>
@end group
@end example

  @xref{Windows}, для описания функций, которые работают с окнами.

@node Frame Type
@subsection Тип Фрейм

  @dfn{Фрейм} это область экрана, которая содержит один или несколько окон
  Emacs; мы также используем термин ``frame'' для обозначения объекта Lisp,
  который Emacs использует для обозначения области экрана.

  У фрейма нет синтаксиса чтения.  Они печатаются в хэш-нотации, давая
  название фрейма, а также его адрес в ядре (полезно для уникальной
  идентификации фрейма).

@example
@group
(selected-frame)
     @result{} #<frame emacs@@psilocin.gnu.org 0xdac80>
@end group
@end example

  @xref{Frames}, для описания функций, работы с фреймами.

@node Terminal Type
@subsection Тип Терминал
@cindex terminal type

  @dfn{Терминал} является устройством, способным отображать один или
  несколько фреймов Emacs (@pxref{Frame Type}).

  Терминалы не имеет синтаксиса чтения.  Они печатаются в хэш-нотации с
  указанием порядкового номера терминала и его имени файла устройства TTY.

@example
@group
(get-device-terminal nil)
     @result{} #<terminal 1 on /dev/tty>
@end group
@end example

@c ИСПРАВТЕ МЕНЯ: добавте внешнюю ссылку, если терминал связанн с
@c описанием примитивов.

@node Window Configuration Type
@subsection Тип Конфигурация Окна
@cindex window layout in a frame

  @dfn{Конфигурация окна} хранит информацию о позиции, размерах и
  содержимого окна в фрейме, так что вы можете воссоздать то же расположение
  окон позже.

  Конфигурация окна не имеют синтаксис чтения; их синтаксис печати выглядит
  @samp{#<window-configuration>}.  @xref{Window Configurations}, для
  описания нескольких функций, связанных с оконными конфигурациями.

@node Frame Configuration Type
@subsection Тип Конфигурация Фрейма
@cindex screen layout
@cindex window layout, all frames

  @dfn{Конфигурация фрейма} хранит информацию о позиции, размерах и
  содержимого всех окон во фрейме.  Это не примитивный тип --- это на
  самом деле список, чей @sc{car} является @code{frame-configuration} а
  @sc{cdr} является креном.  Каждый элемент ALIST описывает один фрейм,
  который появляется как @sc{car} этого элемента.

  @xref{Frame Configurations}, для описания нескольких функций, связанных
  с конфигурацией фреймов.

@node Process Type
@subsection Тип Процесс

  Слово @dfn{процесс} обычно означает запущенную программу.  Сам Emacs
  запускается в процессе такого рода.  Однако, в Emacs Lisp, процесс
  является объектом Lisp, что обозначает подпроцесс, созданный в процессе
  Emacs.  Такие программы, как shells, GDB, ftp, и компиляторы, работающие в
  подпроцессах Emacs, расширяют возможности Emacs.  Подпроцесс Emacs
  принимает текстовый ввод из Emacs и возвращает текстовый вывод в Emacs
  для дальнейших манипуляций.  Emacs также может посылать сигналы
  подпроцессу.

  У объекта типа процесс нет синтаксиса чтения.  Они печатаются в
  хэш-нотации,  печатая имя процесса:

@example
@group
(process-list)
     @result{} (#<process shell>)
@end group
@end example

@xref{Processes}, для получения информации о функциях, которые могут
создавать, удалять, возвращать информацию, отправлять входные данные или
сигналы и получать выходные данные от процессов.

@node Thread Type
@subsection Тип Поток

  @dfn{Поток} в Emacs представляет собой отдельный поток выполнения
  Emacs Lisp.  Он запускаетсвою собственную программу на Lisp, имеет свой
  собственный текущий буфер, и может иметь заблокированные подпроцессы,
  то есть @: подпроцессы, вывод которых может принимать только этот поток.
  @xref{Threads}.

  Thread objects have no read syntax.  They print in hash notation,
giving the name of the thread (if it has been given a name) or its
address in core:

@example
@group
(all-threads)
    @result{} (#<thread 0176fc40>)
@end group
@end example

@node Mutex Type
@subsection Mutex Type

  A @dfn{mutex} is an exclusive lock that threads can own and disown,
in order to synchronize between them.  @xref{Mutexes}.

  Mutex objects have no read syntax.  They print in hash notation,
giving the name of the mutex (if it has been given a name) or its
address in core:

@example
@group
(make-mutex "my-mutex")
    @result{} #<mutex my-mutex>
(make-mutex)
    @result{} #<mutex 01c7e4e0>
@end group
@end example

@node Condition Variable Type
@subsection Condition Variable Type

  A @dfn{condition variable} is a device for a more complex thread
synchronization than the one supported by a mutex.  A thread can wait
on a condition variable, to be woken up when some other thread
notifies the condition.

  Condition variable objects have no read syntax.  They print in hash
notation, giving the name of the condition variable (if it has been
given a name) or its address in core:

@example
@group
(make-condition-variable (make-mutex))
    @result{} #<condvar 01c45ae8>
@end group
@end example

@node Stream Type
@subsection Stream Type

  A @dfn{stream} is an object that can be used as a source or sink for
characters---either to supply characters for input or to accept them as
output.  Many different types can be used this way: markers, buffers,
strings, and functions.  Most often, input streams (character sources)
obtain characters from the keyboard, a buffer, or a file, and output
streams (character sinks) send characters to a buffer, such as a
@file{*Help*} buffer, or to the echo area.

  The object @code{nil}, in addition to its other meanings, may be used
as a stream.  It stands for the value of the variable
@code{standard-input} or @code{standard-output}.  Also, the object
@code{t} as a stream specifies input using the minibuffer
(@pxref{Minibuffers}) or output in the echo area (@pxref{The Echo
Area}).

  Streams have no special printed representation or read syntax, and
print as whatever primitive type they are.

  @xref{Read and Print}, for a description of functions
related to streams, including parsing and printing functions.

@node Keymap Type
@subsection Keymap Type

  A @dfn{keymap} maps keys typed by the user to commands.  This mapping
controls how the user's command input is executed.  A keymap is actually
a list whose @sc{car} is the symbol @code{keymap}.

  @xref{Keymaps}, for information about creating keymaps, handling prefix
keys, local as well as global keymaps, and changing key bindings.

@node Overlay Type
@subsection Overlay Type

  An @dfn{overlay} specifies properties that apply to a part of a
buffer.  Each overlay applies to a specified range of the buffer, and
contains a property list (a list whose elements are alternating property
names and values).  Overlay properties are used to present parts of the
buffer temporarily in a different display style.  Overlays have no read
syntax, and print in hash notation, giving the buffer name and range of
positions.

  @xref{Overlays}, for information on how you can create and use overlays.

@node Font Type
@subsection Font Type

  A @dfn{font} specifies how to display text on a graphical terminal.
There are actually three separate font types---@dfn{font objects},
@dfn{font specs}, and @dfn{font entities}---each of which has slightly
different properties.  None of them have a read syntax; their print
syntax looks like @samp{#<font-object>}, @samp{#<font-spec>}, and
@samp{#<font-entity>} respectively.  @xref{Low-Level Font}, for a
description of these Lisp objects.

@node Circular Objects
@section Read Syntax for Circular Objects
@cindex circular structure, read syntax
@cindex shared structure, read syntax
@cindex @samp{#@var{n}=} read syntax
@cindex @samp{#@var{n}#} read syntax

  To represent shared or circular structures within a complex of Lisp
objects, you can use the reader constructs @samp{#@var{n}=} and
@samp{#@var{n}#}.

  Use @code{#@var{n}=} before an object to label it for later reference;
subsequently, you can use @code{#@var{n}#} to refer the same object in
another place.  Here, @var{n} is some integer.  For example, here is how
to make a list in which the first element recurs as the third element:

@example
(#1=(a) b #1#)
@end example

@noindent
This differs from ordinary syntax such as this

@example
((a) b (a))
@end example

@noindent
which would result in a list whose first and third elements
look alike but are not the same Lisp object.  This shows the difference:

@example
(prog1 nil
  (setq x '(#1=(a) b #1#)))
(eq (nth 0 x) (nth 2 x))
     @result{} t
(setq x '((a) b (a)))
(eq (nth 0 x) (nth 2 x))
     @result{} nil
@end example

  You can also use the same syntax to make a circular structure, which
appears as an element within itself.  Here is an example:

@example
#1=(a #1#)
@end example

@noindent
This makes a list whose second element is the list itself.
Here's how you can see that it really works:

@example
(prog1 nil
  (setq x '#1=(a #1#)))
(eq x (cadr x))
     @result{} t
@end example

  The Lisp printer can produce this syntax to record circular and shared
structure in a Lisp object, if you bind the variable @code{print-circle}
to a non-@code{nil} value.  @xref{Output Variables}.

@node Type Predicates
@section Type Predicates
@cindex type checking
@kindex wrong-type-argument

  The Emacs Lisp interpreter itself does not perform type checking on
the actual arguments passed to functions when they are called.  It could
not do so, since function arguments in Lisp do not have declared data
types, as they do in other programming languages.  It is therefore up to
the individual function to test whether each actual argument belongs to
a type that the function can use.

  All built-in functions do check the types of their actual arguments
when appropriate, and signal a @code{wrong-type-argument} error if an
argument is of the wrong type.  For example, here is what happens if you
pass an argument to @code{+} that it cannot handle:

@example
@group
(+ 2 'a)
     @error{} Wrong type argument: number-or-marker-p, a
@end group
@end example

@cindex type predicates
@cindex testing types
  If you want your program to handle different types differently, you
must do explicit type checking.  The most common way to check the type
of an object is to call a @dfn{type predicate} function.  Emacs has a
type predicate for each type, as well as some predicates for
combinations of types.

  A type predicate function takes one argument; it returns @code{t} if
the argument belongs to the appropriate type, and @code{nil} otherwise.
Following a general Lisp convention for predicate functions, most type
predicates' names end with @samp{p}.

  Here is an example which uses the predicates @code{listp} to check for
a list and @code{symbolp} to check for a symbol.

@example
(defun add-on (x)
  (cond ((symbolp x)
         ;; If X is a symbol, put it on LIST.
         (setq list (cons x list)))
        ((listp x)
         ;; If X is a list, add its elements to LIST.
         (setq list (append x list)))
        (t
         ;; We handle only symbols and lists.
         (error "Invalid argument %s in add-on" x))))
@end example

  Here is a table of predefined type predicates, in alphabetical order,
with references to further information.

@table @code
@item atom
@xref{List-related Predicates, atom}.

@item arrayp
@xref{Array Functions, arrayp}.

@item bool-vector-p
@xref{Bool-Vectors, bool-vector-p}.

@item booleanp
@xref{nil and t, booleanp}.

@item bufferp
@xref{Buffer Basics, bufferp}.

@item byte-code-function-p
@xref{Byte-Code Type, byte-code-function-p}.

@item case-table-p
@xref{Case Tables, case-table-p}.

@item char-or-string-p
@xref{Predicates for Strings, char-or-string-p}.

@item char-table-p
@xref{Char-Tables, char-table-p}.

@item commandp
@xref{Interactive Call, commandp}.

@item condition-variable-p
@xref{Condition Variables, condition-variable-p}.

@item consp
@xref{List-related Predicates, consp}.

@item custom-variable-p
@xref{Variable Definitions, custom-variable-p}.

@item floatp
@xref{Predicates on Numbers, floatp}.

@item fontp
@xref{Low-Level Font}.

@item frame-configuration-p
@xref{Frame Configurations, frame-configuration-p}.

@item frame-live-p
@xref{Deleting Frames, frame-live-p}.

@item framep
@xref{Frames, framep}.

@item functionp
@xref{Functions, functionp}.

@item hash-table-p
@xref{Other Hash, hash-table-p}.

@item integer-or-marker-p
@xref{Predicates on Markers, integer-or-marker-p}.

@item integerp
@xref{Predicates on Numbers, integerp}.

@item keymapp
@xref{Creating Keymaps, keymapp}.

@item keywordp
@xref{Constant Variables}.

@item listp
@xref{List-related Predicates, listp}.

@item markerp
@xref{Predicates on Markers, markerp}.

@item mutexp
@xref{Mutexes, mutexp}.

@item nlistp
@xref{List-related Predicates, nlistp}.

@item number-or-marker-p
@xref{Predicates on Markers, number-or-marker-p}.

@item numberp
@xref{Predicates on Numbers, numberp}.

@item overlayp
@xref{Overlays, overlayp}.

@item processp
@xref{Processes, processp}.

@item recordp
@xref{Record Type, recordp}.

@item sequencep
@xref{Sequence Functions, sequencep}.

@item string-or-null-p
@xref{Predicates for Strings, string-or-null-p}.

@item stringp
@xref{Predicates for Strings, stringp}.

@item subrp
@xref{Function Cells, subrp}.

@item symbolp
@xref{Symbols, symbolp}.

@item syntax-table-p
@xref{Syntax Tables, syntax-table-p}.

@item threadp
@xref{Basic Thread Functions, threadp}.

@item vectorp
@xref{Vectors, vectorp}.

@item wholenump
@xref{Predicates on Numbers, wholenump}.

@item window-configuration-p
@xref{Window Configurations, window-configuration-p}.

@item window-live-p
@xref{Deleting Windows, window-live-p}.

@item windowp
@xref{Basic Windows, windowp}.
@end table

  The most general way to check the type of an object is to call the
function @code{type-of}.  Recall that each object belongs to one and
only one primitive type; @code{type-of} tells you which one (@pxref{Lisp
Data Types}).  But @code{type-of} knows nothing about non-primitive
types.  In most cases, it is more convenient to use type predicates than
@code{type-of}.

@defun type-of object
This function returns a symbol naming the primitive type of
@var{object}.  The value is one of the symbols @code{bool-vector},
@code{buffer}, @code{char-table}, @code{compiled-function},
@code{condition-variable}, @code{cons}, @code{finalizer},
@code{float}, @code{font-entity}, @code{font-object},
@code{font-spec}, @code{frame}, @code{hash-table}, @code{integer},
@code{marker}, @code{mutex}, @code{overlay}, @code{process},
@code{string}, @code{subr}, @code{symbol}, @code{thread},
@code{vector}, @code{window}, or @code{window-configuration}.
However, if @var{object} is a record, the type specified by its first
slot is returned; @ref{Records}.

@example
(type-of 1)
     @result{} integer
@group
(type-of 'nil)
     @result{} symbol
(type-of '())    ; @r{@code{()} is @code{nil}.}
     @result{} symbol
(type-of '(x))
     @result{} cons
(type-of (record 'foo))
     @result{} foo
@end group
@end example
@end defun

@node Equality Predicates
@section Equality Predicates
@cindex equality

  Here we describe functions that test for equality between two
objects.  Other functions test equality of contents between objects of
specific types, e.g., strings.  For these predicates, see the
appropriate chapter describing the data type.

@defun eq object1 object2
This function returns @code{t} if @var{object1} and @var{object2} are
the same object, and @code{nil} otherwise.

If @var{object1} and @var{object2} are integers with the same value,
they are considered to be the same object (i.e., @code{eq} returns
@code{t}).  If @var{object1} and @var{object2} are symbols with the
same name, they are normally the same object---but see @ref{Creating
Symbols} for exceptions.  For other types (e.g., lists, vectors,
strings), two arguments with the same contents or elements are not
necessarily @code{eq} to each other: they are @code{eq} only if they
are the same object, meaning that a change in the contents of one will
be reflected by the same change in the contents of the other.

@example
@group
(eq 'foo 'foo)
     @result{} t
@end group

@group
(eq 456 456)
     @result{} t
@end group

@group
(eq "asdf" "asdf")
     @result{} nil
@end group

@group
(eq "" "")
     @result{} t
;; @r{This exception occurs because Emacs Lisp}
;; @r{makes just one multibyte empty string, to save space.}
@end group

@group
(eq '(1 (2 (3))) '(1 (2 (3))))
     @result{} nil
@end group

@group
(setq foo '(1 (2 (3))))
     @result{} (1 (2 (3)))
(eq foo foo)
     @result{} t
(eq foo '(1 (2 (3))))
     @result{} nil
@end group

@group
(eq [(1 2) 3] [(1 2) 3])
     @result{} nil
@end group

@group
(eq (point-marker) (point-marker))
     @result{} nil
@end group
@end example

@noindent
The @code{make-symbol} function returns an uninterned symbol, distinct
from the symbol that is used if you write the name in a Lisp expression.
Distinct symbols with the same name are not @code{eq}.  @xref{Creating
Symbols}.

@example
@group
(eq (make-symbol "foo") 'foo)
     @result{} nil
@end group
@end example

@noindent
@cindex identical-contents objects, and byte-compiler
@cindex objects with identical contents, and byte-compiler
The Emacs Lisp byte compiler may collapse identical literal objects,
such as literal strings, into references to the same object, with the
effect that the byte-compiled code will compare such objects as
@code{eq}, while the interpreted version of the same code will not.
Therefore, your code should never rely on objects with the same
literal contents being either @code{eq} or not @code{eq}, it should
instead use functions that compare object contents such as
@code{equal}, described below.  Similarly, your code should not modify
literal objects (e.g., put text properties on literal strings), since
doing that might affect other literal objects of the same contents, if
the byte compiler collapses them.
@end defun

@defun equal object1 object2
This function returns @code{t} if @var{object1} and @var{object2} have
equal components, and @code{nil} otherwise.  Whereas @code{eq} tests
if its arguments are the same object, @code{equal} looks inside
nonidentical arguments to see if their elements or contents are the
same.  So, if two objects are @code{eq}, they are @code{equal}, but
the converse is not always true.

@example
@group
(equal 'foo 'foo)
     @result{} t
@end group

@group
(equal 456 456)
     @result{} t
@end group

@group
(equal "asdf" "asdf")
     @result{} t
@end group
@group
(eq "asdf" "asdf")
     @result{} nil
@end group

@group
(equal '(1 (2 (3))) '(1 (2 (3))))
     @result{} t
@end group
@group
(eq '(1 (2 (3))) '(1 (2 (3))))
     @result{} nil
@end group

@group
(equal [(1 2) 3] [(1 2) 3])
     @result{} t
@end group
@group
(eq [(1 2) 3] [(1 2) 3])
     @result{} nil
@end group

@group
(equal (point-marker) (point-marker))
     @result{} t
@end group

@group
(eq (point-marker) (point-marker))
     @result{} nil
@end group
@end example

Comparison of strings is case-sensitive, but does not take account of
text properties---it compares only the characters in the strings.
@xref{Text Properties}.  Use @code{equal-including-properties} to also
compare text properties.  For technical reasons, a unibyte string and
a multibyte string are @code{equal} if and only if they contain the
same sequence of character codes and all these codes are in the range
0 through 127 (@acronym{ASCII}).

@example
@group
(equal "asdf" "ASDF")
     @result{} nil
@end group
@end example

However, two distinct buffers are never considered @code{equal}, even if
their textual contents are the same.
@end defun

  The test for equality is implemented recursively; for example, given
two cons cells @var{x} and @var{y}, @code{(equal @var{x} @var{y})}
returns @code{t} if and only if both the expressions below return
@code{t}:

@example
(equal (car @var{x}) (car @var{y}))
(equal (cdr @var{x}) (cdr @var{y}))
@end example

Because of this recursive method, circular lists may therefore cause
infinite recursion (leading to an error).

@defun equal-including-properties object1 object2
This function behaves like @code{equal} in all cases but also requires
that for two strings to be equal, they have the same text properties.

@example
@group
(equal "asdf" (propertize "asdf" 'asdf t))
     @result{} t
@end group
@group
(equal-including-properties "asdf"
                            (propertize "asdf" 'asdf t))
     @result{} nil
@end group
@end example
@end defun
