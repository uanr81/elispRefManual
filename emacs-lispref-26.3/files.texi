@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2019 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Files
@chapter Файлы

  В этой главе описываются функции и переменные Emacs Lisp для поиска,
создания, просмотра, сохранения и другой работы с файлами и каталогами.
Некоторые другие функции, связанные с файлами, описаны в @ref{Buffers}, а
функции, связанные с резервным копированием и автосохранением, описаны в
@ref{Backups and Auto-Saving}.

  Многие функции обработки файлов принимают один или несколько аргументов,
которые являются именами файлов.  Имя файла - это строка.  Большинство этих
функций расширяют аргументы имени файла с помощью функции
@code{expand-file-name}, так что @file{~} обрабатывается правильно, как и
относительные имена файлов (включая @file{../} и пустую строку).
@xref{File Name Expansion}.

  Кроме того, некоторые @dfn{магические} имена файлов  обрабатываются особым
образом.  Например, когда указано имя удаленного файла, Emacs обращается к
файлу по сети через соответствующий протокол.
@xref{Remote Files,, Remote Files, emacs, The GNU Emacs Manual}.  Эта
обработка выполняется на очень низком уровне, поэтому можно предположить,
что все функции, описанные в этой главе, принимают магические имена файлов в
качестве аргументов имени файла, за исключением случаев, когда это указано.
@xref{Magic File Names}, для подробностей.

  Когда функции файлового ввода-вывода сигнализируют об ошибках Lisp, они
обычно используют условие @code{file-error} (@pxref{Handling Errors}).
Сообщение об ошибке в большинстве случаев получается из операционной системы
в соответствии с локалью @code{system-messages-locale} и декодируется с
использованием системы кодирования @code{locale-coding-system}
(@pxref{Locales}).

@menu
* Visiting Files::          Чтение файлов в буферы Emacs для редактирования.
* Saving Buffers::           Запись измененных буферов обратно в файлы.
* Reading from Files::       Чтение файлов в буферы без посещения.
* Writing to Files::         Запись новых файлов из частей буферов.
* File Locks::               Блокировка и разблокировка файлов для
                                предотвращения одновременного редактирования
                                несколькими людьми.
* Information about Files:: Тестирование наличия, доступности, размера
                                файлов.
* Changing Files::  Переименование файлов, изменение разрешений и так далее.
* Files and Storage::        Surviving power and media failures
* File Names::               Разложение и раскрытие имен файлов.
* Contents of Directories::  Получение списка файлов в каталоге.
* Create/Delete Dirs::       Создание и удаление каталогов.
* Magic File Names::         Специальная обработка определенных имен файлов.
* Format Conversion::        Преобразование в различные форматы файлов и
                                обратно.
@end menu

@node Visiting Files
@section Посещение Файлов
@cindex finding files
@cindex visiting files

  Посещение файла означает чтение файла в буфер.  Как только это будет
сделано, понимается, что буфер является @dfn{посещаемый} файл, и
вызываем файл @dfn{посещаем файл} буфером.

  Файл и буфер - это разные вещи.  Файл - это информация, постоянно
записанная на компьютере (если не удалить её).  С другой стороны, буфер -
это информация внутри Emacs, которая исчезнет в конце сеанса редактирования
(или когда уничтожиться буфер).  Когда буфер обращается к файлу, он содержит
информацию, скопированную из файла.  Копия в буфере - это то, что изменяется
с помощью команд редактирования.  Изменения в буфере не изменяют файл; чтобы
сделать изменения постоянными, потребуется @dfn{сохранить} буфер, что
означает копирование измененного содержимого буфера обратно в файл.

  Несмотря на различие между файлами и буферами, люди часто ссылаются на
файл, имея в виду буфер, и наоборот.  В самом деле, мы говорится,
``Редактируется файл'', а не ``Редактируется буфер, который скоро сохранится
как файл с тем же именем''.  Людям обычно не нужно делать это различие
явным.  Однако, имея дело с компьютерной программой, следует помнить об этом
различии.

@menu
* Visiting Functions::         Обычный интерфейс для посещения.
* Subroutines of Visiting::    Подпрограммы нижнего уровня, которые
                                  используются.
@end menu

@node Visiting Functions
@subsection Функции для Посещения Файлов
@cindex visiting files, functions for
@cindex how to visit files

  В этом разделе описаны функции, обычно используемые для посещения файлов.
По историческим причинам эти функции имеют имена, начинающиеся с
@samp{find-}, а не @samp{visit-}.  @xref{Buffer File Name} для функций и
переменных, которые обращаются к имени посещенного файла буфера или находят
существующий буфер по имени посещенного файла.

  В программе на Lisp, если потребуется просматривать содержимое файла, но
не изменять его, самый быстрый способ - использовать
@code{insert-file-contents} во временном буфере.  Посещение файла не
требуется, которое занимает больше времени.  @xref{Reading from Files}.

@deffn Command find-file filename &optional wildcards
Эта команда выбирает буфер, обращающийся к файлу @var{filename}, используя
существующий буфер, если он есть, и в противном случае создает новый буфер
и считывает файл в него.  Также возвращает этот буфер.

За исключением некоторых технических деталей, тело функции @code{find-file}
в основном эквивалентно:

@smallexample
(switch-to-buffer (find-file-noselect filename nil nil wildcards))
@end smallexample

@noindent
(смотреть @code{switch-to-buffer} в @ref{Switching Buffers}.)

Если @var{wildcards} равен не-@code{nil}, что всегда верно в интерактивном
вызове, тогда @code{find-file} расширяет символы подстановки в
@var{filename} и посещает все соответствующие файлы.

Когда @code{find-file} вызывается в интерактивном режиме, запрашивается
@var{filename} в минибуфере.
@end deffn

@deffn Command find-file-literally filename
Эта команда обращается к @var{filename}, как и @code{find-file}, но не
выполняет никаких преобразований формата (@pxref{Format Conversion}),
преобразований символьного кода (@pxref{Coding Systems}) или преобразования
конца строки (@pxref{Coding System Basics, End of line conversion}).  Буфер,
обращающийся к файлу, делается однобайтовым, и его основным режимом является
режим Fundamental, независимо от имени файла.  Спецификации локальных
переменных файла в файле (@pxref{File Local Variables}) игнорируются,
автоматическая распаковка и добавление новой строки в конце файла из-за
@code{require-final-newline} (@pxref{Saving Buffers, require-final-newline})
также отключены.

Обратить внимание, что если в Emacs уже есть буфер, обращающийся к тому же
файлу не буквально, он не будет посещать тот же файл буквально, а вместо
этого просто переключится на существующий буфер.  Если требуется быть
уверены в прямом доступе к содержимому файла, следует создать временный
буфер, а затем прочитать в него содержимое файла с помощью
@code{insert-file-contents-literally} (@pxref{Reading from Files}).
@end deffn

@defun find-file-noselect filename &optional nowarn rawfile wildcards
Эта функция является основой всех функций обращения к файлам.  Возвращает
буфер, обращающийся к файлу @var{filename}.  Можно сделать буфер текущим или
отобразить его в окне, если нужно, но эта функция не делает этого.

Функция возвращает существующий буфер, если он есть; в противном случае
создает новый буфер и считывает в него файл.  Когда
@code{find-file-noselect} использует существующий буфер, сначала проверяет,
не изменился ли файл с момента последнего посещения или сохранения в этом
буфере.  Если файл был изменен, эта функция спрашивает пользователя, следует
ли перечитать измененный файл.  Если пользователь говорит @samp{yes}, все
изменения, ранее сделанные в буфере, теряются.

Чтение файла включает декодирование содержимого файла
(@pxref{Coding Systems}), включая преобразование конца строки и
преобразование формата (@pxref{Format Conversion}).  Если @var{wildcards}
равен не-@code{nil}, то @code{find-file-noselect} расширяет символы
подстановки в @var{filename} и посещает все соответствующие файлы.

Эта функция отображает предупреждающие или рекомендательные сообщения в
различных особых случаях, если только необязательный аргумент @var{nowarn}
не равен не-@code{nil}.  Например, если нужно создать буфер, а файла с
именем @var{filename} нет, отображается сообщение @samp{(New file)} в
эхо-области и оставляет буфер пустым.

Функция @code{find-file-noselect} обычно вызывает @code{after-find-file}
после чтения файла (@pxref{Subroutines of Visiting}).  Эта функция
устанавливает основной режим буфера, анализирует локальные переменные,
предупреждает пользователя, если существует файл автосохранения более
поздний, чем только что посещенный файл, и завершает выполнение функций в
@code{find-file-hook}.

Если необязательный аргумент @var{rawfile} - не-@code{nil}, то
@code{after-find-file} не вызывается, и @code{find-file-not-found-functions}
не запускаются в случае сбоя.  Более того, значение не-@code{nil}
@var{rawfile} подавляет преобразование системы кодирования и преобразование
формата.

Функция @code{find-file-noselect} обычно возвращает буфер, который посещает
файл @var{filename}.  Но если подстановочные знаки действительно
используются и расширяются, он возвращает список буферов, которые обращаются
к различным файлам.

@example
@group
(find-file-noselect "/etc/fstab")
     @result{} #<buffer fstab>
@end group
@end example
@end defun

@deffn Command find-file-other-window filename &optional wildcards
Эта команда выбирает буфер, обращающийся к файлу @var{filename}, но делает
это в окне, отличном от выбранного окна.  Может использовать другое
существующее окно или разделить окно; смотреть @ref{Switching Buffers}.

Когда эта команда вызывается в интерактивном режиме, она запрашивает
@var{filename}.
@end deffn

@deffn Command find-file-read-only filename &optional wildcards
Эта команда выбирает буфер, обращающийся к файлу @var{filename}, как и
@code{find-file}, но помечает буфер как доступный только для чтения.
@xref{Read Only Buffers}, для связанных функций и переменных.

Когда эта команда вызывается в интерактивном режиме, она запрашивает
@var{filename}.
@end deffn

@defopt find-file-wildcards
Если эта переменная - не-@code{nil}, то различные команды @code{find-file}
проверяют наличие подстановочных знаков и посещают все файлы, которые им
соответствуют (при интерактивном вызове или когда их аргумент
@var{wildcards} - не-@code{nil}).  Если эта опция - @code{nil}, то команды
@code{find-file} игнорируют свой аргумент @var{wildcards} и никогда
специально не обрабатывают подстановочные знаки.
@end defopt

@defopt find-file-hook
Значение этой переменной представляет собой список функций, вызываемых после
посещения файла.  Спецификация локальных переменных файла (если таковая
имеется) будет обработана до запуска перехватчиков.  Буфер, обращающийся к
файлу, является текущим, когда выполняются функции ловушки.

Эта переменная - обычная ловушка.  @xref{Hooks}.
@end defopt

@defvar find-file-not-found-functions
Значение этой переменной представляет собой список функций, которые будут
вызываться, когда @code{find-file} или @code{find-file-noselect} передается
несуществующее имя файла.  @code{find-file-noselect} вызывает эти функции,
как только обнаруживает несуществующий файл.  Вызывает их в порядке списка,
пока один из них не вернет не-@code{nil}.  @code{buffer-file-name} уже
настроен.

Это не обычная ловушка, потому что используются значения функций, а во
многих случаях вызываются только некоторые функции.
@end defvar

@defvar find-file-literally
Эта локальная в буфере переменная, если установлена в значение
не-@code{nil}, заставляет @code{save-buffer} вести себя так, как если бы
буфер буквально посещал свой файл, то есть без каких-либо преобразований.
Команда @code{find-file-literally} устанавливает локальное значение этой
переменной, но другие эквивалентные функции и команды также могут это
делать, например, чтобы избежать автоматического добавления новой строки в
конец файла.  Эта переменная является постоянной локальной, поэтому на нее
не влияют изменения основных режимов.
@end defvar

@node Subroutines of Visiting
@subsection Подпрограммы Посещения

  Функция @code{find-file-noselect} использует две важные подпрограммы,
которые иногда полезны в коде пользователя Lisp: @code{create-file-buffer} и
@code{after-find-file}.  В этом разделе объясняется, как их использовать.

@c FIXME Это не описывает поведение по умолчанию, потому что uniquify
@c включен по умолчанию и рекомендует эту функцию.  Это смущает.
@c uniquify должен быть встроен в функцию.
@defun create-file-buffer filename
Эта функция создает буфер с подходящим именем для посещения @var{filename} и
возвращает его.  В качестве имени используется @var{filename} (без указания
каталога), если это имя свободно; в противном случае он добавляется строка,
например @samp{<2>}, чтобы получить неиспользуемое имя.  Смотреть также
@ref{Creating Buffers}.  Обратить внимание, что библиотека @file{uniquify}
влияет на результат этой функции.
@xref{Uniquify,,, emacs, The GNU Emacs Manual}.

@strong{Пожалуйста, обратить внимание:} @code{create-file-buffer} @emph{не}
связывает новый буфер с файлом и не выбирает буфер.  Также не использует
основной режим по умолчанию.

@example
@group
(create-file-buffer "foo")
     @result{} #<buffer foo>
@end group
@group
(create-file-buffer "foo")
     @result{} #<buffer foo<2>>
@end group
@group
(create-file-buffer "foo")
     @result{} #<buffer foo<3>>
@end group
@end example

Эта функция используется @code{find-file-noselect}.  Использует
@code{generate-new-buffer} (@pxref{Creating Buffers}).
@end defun

@defun after-find-file &optional error warn noauto after-find-file-from-revert-buffer nomodes
Эта функция устанавливает основной режим буфера и анализирует локальные
переменные (@pxref{Auto Major Mode}).  Вызывается @code{find-file-noselect}
и функцией возврата по умолчанию (@pxref{Reverting}).

@cindex new file message
@cindex file open error
Если при чтении файла возникла ошибка, потому что файл не существует, но его
каталог существует, вызывающий должен передать значение не-@code{nil} для
@var{error}.  В этом случае @code{after-find-file} выдает предупреждение:
@samp{(New file)}.  В случае более серьезных ошибок вызывающий обычно не
должен вызывать @code{after-find-file}.

Если @var{warn} - не-@code{nil}, то эта функция выдает предупреждение, если
файл автосохранения существует и является более новым, чем посещенный файл.

Если @var{noauto} равен не-@code{nil}, это означает, что не следует включать
и отключать режим автосохранения.  Режим остается включенным, если он был
включен ранее.

Если @var{after-find-file-from-revert-buffer} - не-@code{nil}, это означает,
что этот вызов был от @code{revert-buffer}. Это не имеет прямого эффекта, но
некоторые функции режима и функции перехвата проверяют значение этой
переменной.

Если @var{nomodes} равен не-@code{nil}, это означает, что не изменять
основной режим буфера, не обрабатывать спецификации локальных переменных в
файле и не запускать @code{find-file-hook}.  Эта функция в некоторых случаях
используется @code{revert-buffer}.

Последнее, что делает @code{after-find-file} - вызывает все функции из
списка @code{find-file-hook}.
@end defun

@node Saving Buffers
@section Сохранение Буферов
@cindex saving buffers

  Когда редактируется файл в Emacs, фактически происходит работа с буфером,
который обращается к этому файлу, то есть содержимое файла копируется в
буфер, а копия - это то, что редактируется.  Изменения в буфере не изменяют
файл, пока не @dfn{сохранить} буфер, что означает копирование содержимого
буфера в файл.  Буферы, которые не обращаются к файлу, все еще могут быть
``сохранены'', в некотором смысле, с использованием функций в ловушке
buffer-local @code{write-contents-functions}.

@deffn Command save-buffer &optional backup-option
Эта функция сохраняет содержимое текущего буфера в своем посещенном файле,
если буфер был изменен с момента последнего посещения или сохранения.  В
противном случае ничего не происходит.

@code{save-buffer} отвечает за создание файлов резервных копий.  Обычно
@var{backup-option} - это @code{nil}, а @code{save-buffer} создает резервную
копию только в том случае, если это первое сохранение с момента обращения к
файлу.  Другие значения @var{backup-option} указывают запрашивать создание
файлов резервных копий в других случаях:

@itemize @bullet
@item
С аргументом 4 или 64, отражающим 1 или 3 @kbd{C-u}, функция
@code{save-buffer} отмечает эту версию файла для резервного копирования при
следующем сохранении буфера.

@item
С аргументом 16 или 64, отражающим 2 или 3 @kbd{C-u}, функция
@code{save-buffer} безусловно создает резервную копию предыдущей версии
файла перед ее сохранением.

@item
С аргументом 0 безоговорочно @emph{не} делает резервную копию любого файла.
@end itemize
@end deffn

@deffn Command save-some-buffers &optional save-silently-p pred
@anchor{Definition of save-some-buffers}
Эта команда сохраняет некоторые модифицированные буферы обращения к файлам.
Обычно спрашивается пользователя о каждом буфере.  Но если
@var{save-silently-p} равен не-@code{nil}, сохраняются все буферы обращения
к файлам, не запрашивая пользователя.

@vindex save-some-buffers-default-predicate
Необязательный аргумент @var{pred} предоставляет предикат, который
контролирует, какие буферы запрашивать (или молча сохранять, если
@var{save-silently-p} равен не-@code{nil}).  Если @var{pred} равно
@code{nil}, это означает, что вместо @var{pred} следует использовать
значение @code{save-some-buffers-default-predicate}.  Если результат
@code{nil}, значит спрашивать только о файловых буферах.  Если это @code{t},
это означает также предложение сохранить некоторые другие нефайловые буферы
- те, которые имеют локальное значение не-@code{nil} для буфера
@code{buffer-offer-save} (@pxref{Killing Buffers}).  Пользователя, который
говорит @samp{yes} для сохранения нефайлового буфера, просят указать имя
файла для использования.  Функция @code{save-buffers-kill-emacs} передает
значение @code{t} для @var{pred}.

Если предикат не является ни @code{t}, ни @code{nil}, то должен быть
функцией без аргументов.  Будет вызываться в каждом буфере, чтобы решить,
предлагать ли сохранить этот буфер.  Если возвращается значение
не-@code{nil} в определенном буфере, означает, что предлагается сохранить
этот буфер.
@end deffn

@deffn Command write-file filename &optional confirm
@anchor{Definition of write-file}
Эта функция записывает текущий буфер в файл @var{filename}, заставляет буфер
посещать этот файл и отмечает, что он не изменен.  Затем переименовывает
буфер на основе @var{filename}, добавляя строку типа @samp{<2>}, если
необходимо, чтобы получить уникальное имя буфера.  Большую часть этой работы
выполняет, вызывая @code{set-visited-file-name} (@pxref{Buffer File Name}) и
@code{save-buffer}.

Если @var{confirm} - не-@code{nil}, это означает, что нужно запрашивать
подтверждение перед перезаписью существующего файла.  В интерактивном режиме
требуется подтверждение, если пользователь не предоставляет префиксный
аргумент.

Если @var{filename} - это имя каталога (@pxref{Directory Names}),
@code{write-file} использует имя посещенного файла в каталоге
@var{filename}.  Если буфер не обращается к файлу, вместо этого используется
имя буфера.
@end deffn

  Сохранение буфера запускает несколько ловушек.  Также выполняется
преобразование формата (@pxref{Format Conversion}).  Обратить внимание, что
эти ловушки, описанные ниже, запускаются только @code{save-buffer}, они не
запускаются другими примитивами и функциями, которые записывают текст буфера
в файлы, и, в частности, автосохранение (@pxref{Auto-Saving}) не запускает
эти перехватчики.

@defvar write-file-functions
Значение этой переменной представляет собой список функций, которые должны
быть вызваны перед записью буфера в посещенный файл.  Если одна из них
возвращает не-@code{nil}, файл считается уже записанным, и остальные функции
не вызываются, а также не выполняется обычный код для записи файла.

Если функция в @code{write-file-functions} возвращает не-@code{nil}, она
отвечает за создание файла резервной копии (если это уместно).  Для этого
выполняется следующий код:

@example
(or buffer-backed-up (backup-buffer))
@end example

Можно сохранить значение режима файла, возвращаемое @code{backup-buffer}, и
использовать его (если не-@code{nil}) для установки битов режима файла,
который пишется.  Это то, что обычно делает @code{save-buffer}.
@xref{Making Backups,, Making Backup Files}.

Функции ловушки в @code{write-file-functions} также отвечают за кодирование
данных (при желании): они должны выбрать подходящую систему кодирования и
преобразование конца строки (@pxref{Lisp and Coding Systems}), выполнить
кодирование (@pxref{Explicit Encoding}) и установить
@code{last-coding-system-used} на систему кодирования, которая
использовалась (@pxref{Encoding and I/O}).

Если устанавливается эта ловушка локально в буфере, предполагается, что она
связана с файлом или способом получения содержимого буфера.  Таким образом,
переменная помечается как постоянная локальная, так что изменение основного
режима не меняет локального значения буфера.  С другой стороны, вызов
@code{set-visited-file-name} сбросит его.  Если это не то, что нужно, можно
вместо этого использовать @code{write-contents-functions}.

Несмотря на то, что это не обычная ловушка, можно использовать
@code{add-hook} и @code{remove-hook} для управления списком перехватчиков.
@xref{Hooks}.
@end defvar

@c Emacs 19 feature
@defvar write-contents-functions
Это работает так же, как @code{write-file-functions}, но предназначено для
ловушек, которые относятся к содержимому буфера, а не к конкретному
посещенному файлу или его местоположению, и может использоваться для
создания произвольных процессов сохранения для буферов, которые вообще не
обращаются к файлам.  Такие перехватчики обычно устанавливаются основными
режимами как привязки этой переменной к локальному буферу.  Эта переменная
автоматически становится локальной в буфере всякий раз, когда она
установлена; переключение в новый основной режим всегда сбрасывает эту
переменную, но вызов @code{set-visited-file-name} - нет.

Если какая-либо из функций в этой ловушке возвращает не-@code{nil}, файл
считается уже записанным, а остальные не вызываются, как и функции в
@code{write-file-functions}.

При использовании этой ловушки для сохранения буферов, которые не обращаются
к файлам (например, буферов специального режима), иметь в виду, что если
функция не сможет правильно сохранить и возвращает значение @code{nil},
@code{save-buffer} продолжит запрашивать у пользователя файл для сохранения
буфера.  Если это нежелательно, рассмотреть возможность отказа функции,
вызвав ошибку.
@end defvar

@defopt before-save-hook
Эта обычная ловушка запускается до того, как буфер будет сохранен в
посещенном файле, независимо от того, выполняется ли это обычным образом или
с помощью одной из описанных выше ловушек.  Например, программа
@file{copyright.el} использует эту ловушку, чтобы убедиться, что в
сохраняемом файле указан текущий год в уведомлении об авторских правах.
@end defopt

@c Emacs 19 feature
@defopt after-save-hook
Эта обычная ловушка запускается после того, как буфер был сохранен в
посещенном им файле.  Одно использование этого перехватчика - в режиме
Fast Lock; он использует этот хук для сохранения информации о выделении в
файле кэша.
@end defopt

@defopt file-precious-flag
Если эта переменная - не-@code{nil}, то @code{save-buffer} защищает от
ошибок ввода-вывода при сохранении, записывая новый файл с временным именем
вместо имени, которое он должен иметь, а затем переименовывает его в
предполагаемое имя после того, как станет ясно, что нет ошибки.  Эта
процедура предотвращает возникновение таких проблем, как нехватка места на
диске, в результате чего файл окажется недействительным.

Как побочный эффект, резервные копии обязательно делаются путем копирования.
@xref{Rename or Copy}.  Но в то же время при сохранении ценного файла всегда
прерываются все жесткие связи между сохраняемым файлом и другими именами
файлов.

Некоторые режимы присваивают этой переменной значение не-@code{nil},
локальное в конкретном буфере.
@end defopt

@defopt require-final-newline
Эта переменная определяет, могут ли быть записаны файлы, котрые @emph{не}
заканчиваются новой строкой.  Если значение переменной - @code{t}, то
@code{save-buffer} незаметно добавляет новую строку в конец буфера всякий
раз, когда это не так.  Если значение равно @code{visit}, Emacs добавляет не
достающую новую строку сразу после посещения файла.  Если значение равно
@code{visit-save}, Emacs добавляет недостающую новую строку как при
посещении, так и при сохранении.  Для любого другого значения не-@code{nil}
@code{save-buffer} спрашивает пользователя, добавлять ли новую строку каждый
раз, когда возникает случай.

Если значение переменной - @code{nil}, то @code{save-buffer} вообще не
добавляет новые строки.  @code{nil} - значение по умолчанию, но несколько
основных режимов устанавливают его на @code{t} в определенных буферах.
@end defopt

Смотреть также функцию @code{set-visited-file-name}
(@pxref{Buffer File Name}).

@node Reading from Files
@section Чтение из Файлов
@cindex reading from files

  Чтобы скопировать содержимое файла в буфер, использвать функцию
@code{insert-file-contents}.  (Не использовать команду @code{insert-file} в
программе на Lisp, поскольку она устанавливает метку.)

@defun insert-file-contents filename &optional visit beg end replace
Эта функция вставляет содержимое файла @var{filename} в текущий буфер после
точки.  Возвращает список абсолютного имени файла и длины вставленных
данных.  Выдается сообщение об ошибке, если @var{filename} не является
именем файла, который можно прочитать.

Функция проверяет содержимое файла на соответствие определенным форматам
файлов и при необходимости преобразует содержимое файла, а также вызывает
функции из списка @code{after-insert-file-functions}.
@xref{Format Conversion}.  Обычно одна из функций в списке
@code{after-insert-file-functions} определяет систему кодирования
(@pxref{Coding Systems}), используемую для декодирования содержимого файла,
включая преобразование конца строки.  Однако, если файл содержит нулевые
байты, он по умолчанию посещается без каких-либо преобразований кода.
@xref{Lisp and Coding Systems, inhibit-null-byte-detection}.

Если @var{visit} равен не-@code{nil}, эта функция дополнительно помечает
буфер как немодифицированный и настраивает различные поля в буфере так,
чтобы он обращался к файлу @var{filename}: это включает имя файла,
посещенного буфером, и время его последнего сохранения.  Функция
используется @code{find-file-noselect}, и, вероятно, не стоит использовать
ее самостоятельно.

Если @var{beg} и @var{end} равны не-@code{nil}, они должны быть числами,
которые представляют собой байтовые смещения, определяющие часть файла для
вставки.  В этом случае @var{visit} должен быть @code{nil}.  Для примера,

@example
(insert-file-contents filename nil 0 500)
@end example

@noindent
вставляет первые 500 символов файла.

Если аргумент @var{replace} равен не-@code{nil}, это означает замену
содержимого буфера (фактически, только доступной части) содержимым файла.
Это лучше, чем просто удалить содержимое буфера и вставить весь файл, потому
что (1) он сохраняет некоторые позиции маркеров и (2) помещает меньше данных
в список отмены.

Можно читать специальный файл (например, устройство FIFO или I/O) с помощью
@code{insert-file-contents}, если @var{replace} и @var{visit} имеют значение
@code{nil}.
@end defun

@defun insert-file-contents-literally filename &optional visit beg end replace
Функция работает как @code{insert-file-contents}, за исключением того, что
не запускает @code{after-insert-file-functions} и не выполняет декодирование
формата, преобразование кода символов, автоматическую распаковку и тому
подобное.
@end defun

Если требуется передать имя файла другому процессу, чтобы другая программа
могла его прочитать, используется функция @code{file-local-copy}; смотреть
@ref{Magic File Names}.

@node Writing to Files
@section Запись в Файлы
@cindex writing to files

  Можно записать содержимое буфера или его части непосредственно в файл на
диске с помощью функций @code{append-to-file} и @code{write-region}.  Не
использовать эти функции для записи в файлы, которые посещаются; это может
вызвать путаницу в механизмах посещения.

@deffn Command append-to-file start end filename
Функция добавляет содержимое области, разделенной @var{start} и @var{end} в
текущем буфере, в конец файла @var{filename}.  Если этот файл не существует,
он создается.  Функция возвращает @code{nil}.

Об ошибке сообщается, если @var{filename} указывает файл, который нельзя
записывать, или несуществующий файл в каталоге, где файлы не могут быть
созданы.

При вызове из Lisp эта функция полностью эквивалентна:

@example
(write-region start end filename t)
@end example
@end deffn

@deffn Command write-region start end filename &optional append visit lockname mustbenew
Функция записывает область, ограниченную @var{start} и @var{end} в текущем
буфере, в файл, указанный @var{filename}.

Если @var{start} равен @code{nil}, то команда записывает все содержимое
буфера (@emph{не} только доступную часть) в файл и игнорирует @var{end}.

@c Emacs 19 feature
Если @var{start} является строкой, то @code{write-region} записывает или
добавляет эту строку, а не текст из буфера.  @var{end} в этом случае
игнорируется.

Если @var{append} равен не-@code{nil}, то указанный текст добавляется к
существующему содержимому файла (если есть).  Если @var{append} является
числом, @code{write-region} ищет это байтовое смещение от начала файла и
записывает данные оттуда.

Если @var{mustbenew} равен не-@code{nil}, то @code{write-region} запрашивает
подтверждение, если @var{filename} называет существующий файл.  Если
@var{mustbenew} - это символ @code{excl}, то @code{write-region} не
запрашивает подтверждения, а вместо этого сигнализирует об ошибке
@code{file-already-exists}, если файл уже существует.  Хотя
@code{write-region} обычно следует по символической ссылке и создает
указанный файл, если символическая ссылка битая, он не следует по
символическим ссылкам, если @var{mustbenew} имеет значение @code{excl}.

Тест для существующего файла, когда @var{mustbenew} равен @code{excl},
использует специальную системную функцию.  По крайней мере, для файлов на
локальном диске исключается возможность, что какая-то другая программа
сможет создать файл с тем же именем раньше, чем это сделает Emacs, без
его ведома.

Если @var{visit} равен @code{t}, то Emacs устанавливает связь между буфером
и файлом: тогда буфер обращается к этому файлу.  Также устанавливается время
последней модификации файла для текущего буфера как @var{filename} время
модификации и отмечает буфер как неизмененный.  Функция используется
@code{save-buffer}, но, вероятно, не стоит использовать ее самостоятельно.

@c Emacs 19 feature
Если @var{visit} - строка, она указывает имя файла для посещения.  Таким
образом, можно записывать данные в один файл (@var{filename}) при записи
буфера при посещении другого файла (@var{visit}).  Аргумент @var{visit}
используется в сообщении эхо-области, а также для блокировки файла;
@var{visit} хранится в @code{buffer-file-name}.  Функция используется для
реализации @code{file-precious-flag}; не использовать её самостоятельно,
если действительно не знать, что делать.

Необязательный аргумент @var{lockname}, если не-@code{nil}, указывает имя
файла для использования в целях блокировки и разблокировки, заменяя
@var{filename} и @var{visit} для этой цели.

Функция @code{write-region} преобразует данные, которые записывает, в
соответствующие форматы файлов, указанные в @code{buffer-file-format}, а
также вызывает функции из списка @code{write-region-annotate-functions}.
@xref{Format Conversion}.

Обычно @code{write-region} отображает сообщение @samp{Wrote @var{filename}}
в эхо-области.  Сообщение запрещается, если @var{visit} не является ни
@code{t}, ни @code{nil}, ни строкой, или если Emacs работает в пакетном
режиме (@pxref{Batch Mode}).  Функция полезна для программ, которые
используют файлы для внутренних целей, файлы, о которых пользователю не
нужно знать.
@end deffn

@defvar write-region-inhibit-fsync
Если значение этой переменной - @code{nil}, @code{write-region} использует
системный вызов @code{fsync} после записи файла.  Хотя это замедляет работу
Emacs, это снижает риск потери данных после сбоя питания.  Если значение
равно @code{t}, Emacs не использует @code{fsync}.  Значение по умолчанию -
@code{nil}, когда Emacs интерактивен, и @code{t}, когда Emacs работает в
пакетном режиме.  @xref{Files and Storage}.
@end defvar

@defmac with-temp-file file body@dots{}
@anchor{Definition of with-temp-file}
Макрос @code{with-temp-file} оценивает формы @var{body} с временным буфером
в качестве текущего буфера; затем, в конце, записывает содержимое буфера
в файл @var{file}.  По завершении уничтожает временный буфер, восстанавливая
буфер, который был текущим до формы @code{with-temp-file}.  Затем возвращает
значение последней формы в @var{body}.

Текущий буфер восстанавливается даже в случае аварийного выхода через
@code{throw} или ошибки (@pxref{Nonlocal Exits}).

Смотреть также @code{with-temp-buffer} в
@ref{Definition of with-temp-buffer,, The Current Buffer}.
@end defmac

@node File Locks
@section Файловые Блокировки
@cindex file locks
@cindex lock file
@cindex .#, lock file names

  Когда два пользователя редактируют один и тот же файл одновременно, они
могут мешать друг другу.  Emacs пытается предотвратить возникновение этой
ситуации, записывая @dfn{блокировку файла}, когда файл изменяется.
Затем Emacs может обнаружить первую попытку изменить буфер, обращения к
файлу, который заблокирован другим заданием Emacs, и спросить пользователя,
что ему делать.  Блокировка файла на самом деле представляет собой файл,
символическую ссылку со специальным именем, хранящуюся в том же каталоге,
что и файл, который редактируется.  Имя создается путем добавления @file{.#}
к имени файла буфера.
Цель символической ссылки будет иметь вид
@code{@var{user}@@@var{host}.@var{pid}:@var{boot}}, где @var{user}
заменяется текущим именем пользователя (из @code{user-login-name}),
@var{host} - на имя хоста, на котором работает Emacs (из
@code{system-name}), @var{pid} - на идентификатор процесса Emacs, а
@var{boot} со временем с момента последней перезагрузки.  @code{:@var{boot}}
не указывается, если время загрузки недоступно.  (В файловых системах,
которые не поддерживают символические ссылки, вместо этого используется
обычный файл с содержимым в форме
@code{@var{user}@@@var{host}.@var{pid}:@var{boot}}.)

  Когда получается доступ к файлам с помощью NFS, существует небольшая
вероятность того, что два пользователя заблокируете один и тот же файл
одновременно.  Если это произойдет, пользователи могут внести изменения
одновременно, но Emacs все равно предупредит пользователя, который
окажется вторым.  Также обнаружение модификации буфера при обращении к
файлу, измененному на диске, выявляет некоторые случаи одновременного
редактирования; смотреть @ref{Modification Time}.

@defun file-locked-p filename
Функция возвращает @code{nil}, если файл @var{filename} не заблокирован.
Возвращается @code{t}, если заблокирован этим процессом Emacs, и возвращает
имя пользователя, заблокировавшего его, если файл заблокирован каким-либо
другим заданием.

@example
@group
(file-locked-p "foo")
     @result{} nil
@end group
@end example
@end defun

@defun lock-buffer &optional filename
Функция блокирует файл @var{filename}, если текущий буфер изменен.  По
умолчанию аргумент @var{filename} соответствует посещенному файлу текущего
буфера.  Ничего не происходит, если текущий буфер не обращается к файлу или
не изменяется, или если опция @code{create-lockfiles} имеет значение
@code{nil}.
@end defun

@defun unlock-buffer
Функция разблокирует посещаемый файл в текущем буфере, если буфер изменен.
Если буфер не изменен, файл не должен быть заблокирован, поэтому функция
ничего не делает.  Также ничего не делает, если текущий буфер не обращается
к файлу или не заблокирован.
@end defun

@defopt create-lockfiles
Если эта переменная - @code{nil}, Emacs не блокирует файлы.
@end defopt

@defun ask-user-about-lock file other-user
Функция вызывается, когда пользователь пытается изменить @var{file}, но он
заблокирован другим пользователем с именем @var{other-user}.  Определение
этой функции по умолчанию просит пользователя сказать, что делать.
Значение, которое возвращает эта функция, определяет, что Emacs будет делать
дальше.:

@itemize @bullet
@item
Значение @code{t} говорит о захвате блокировки файла.  Затем этот
пользователь может редактировать файл, и @var{other-user} теряет блокировку.

@item
Значение @code{nil} указывает игнорировать блокировку и в любом случае
позволить этому пользователю редактировать файл.

@item
@kindex file-locked
Вместо этого эта функция может сигнализировать об ошибке @code{file-locked},
и в этом случае изменение, которое пользователь собирался внести, не
происходит.

Сообщение об этой ошибке выглядит так:

@example
@error{} File is locked: @var{file} @var{other-user}
@end example

@noindent
где @code{file} - это имя файла, а @var{other-user} - имя пользователя,
заблокировавшего файл.
@end itemize

При желании можно заменить функцию @code{ask-user-about-lock} своей версией,
которая принимает решение другим способом.
@end defun

@node Information about Files
@section Информация о Файлах
@cindex file, information about

  В этом разделе описаны функции для получения различных типов информации о
файлах (или каталогах, или символических ссылках), например о том, доступен
ли файл для чтения или записи, а также его размер.  Все эти функции
принимают аргументы, которые являются именами файлов.  Если не указано иное,
эти аргументы должны указывать существующие файлы, иначе будет выдана
ошибка.

@cindex file names, trailing whitespace
@cindex trailing blanks in file names
  Быть осторожным с именами файлов, заканчивающимися пробелами.  В некоторых
файловых системах (особенно в MS-Windows) завершающие пробельные символы в
именах файлов автоматически игнорируются.

@menu
* Testing Accessibility::   Читается ли данный файл? Возможность записи?
* Kinds of Files::          Это каталог? Символическая ссылка?
* Truenames::               Удаление символических ссылок из имени файла.
* File Attributes::         Размеры файлов, время модификации и так далее.
* Extended Attributes::    Расширенные атрибуты файлов для контроля доступа.
* Locating Files::          Как найти файл в стандартных местах.
@end menu

@node Testing Accessibility
@subsection Тестирование Доступности
@cindex accessibility of a file
@cindex file accessibility

  Эти функции проверяют разрешение на доступ к файлу для чтения, записи или
выполнения.  Если явно не указано иное, они переходят по символическим
ссылкам.  @xref{Kinds of Files}.

  В некоторых операционных системах можно указать более сложные наборы прав
доступа с помощью таких механизмов, как Access Control Lists (ACLs).
@xref{Extended Attributes}, чтобы узнать, как запрашивать и устанавливать
эти разрешения.

@defun file-exists-p filename
Функция возвращает @code{t}, если файл с именем @var{filename} существует.
Это не означает, что обязательно можно читать файл, только возможно узнать
его атрибуты.  (В GNU и других системах, подобных POSIX, это верно, если
файл существует и есть разрешение на выполнение в содержащих его каталогах,
независимо от разрешений самого файла.)

Если файл не существует или политики контроля доступа не позволяют найти его
атрибуты, эта функция возвращает @code{nil}.

Каталоги - это файлы, поэтому @code{file-exists-p} может возвращать @code{t}
при задании каталога. Однако, поскольку @code{file-exists-p} следует по
символическим ссылкам, он возвращает @code{t} для имени символической
ссылки, только если целевой файл существует.
@end defun

@defun file-readable-p filename
This function returns @code{t} if a file named @var{filename} exists
and you can read it.  It returns @code{nil} otherwise.
@end defun

@defun file-executable-p filename
Функция возвращает @code{t}, если файл с именем @var{filename} существует и
можно его выполнить.  В противном случае возвращается @code{nil}.  В GNU и
других системах, подобных POSIX, если файл является каталогом, разрешение на
выполнение означает, что можно проверять наличие и атрибуты файлов внутри
каталога и открывать эти файлы, если их режимы позволяют.
@end defun

@defun file-writable-p filename
Функция возвращает @code{t}, если файл @var{filename} может быть записан или
создан, и @code{nil} в противном случае.  Файл доступен для записи, если
файл существует и можно его записать.  Его можно создать, если он не
существует, но указанный каталог существует, и можно писать в этом каталоге.

В приведенном ниже примере @file{foo} недоступен для записи, потому что
родительский каталог не существует, даже если пользователь может создать
такой каталог.

@example
@group
(file-writable-p "~/no-such-dir/foo")
     @result{} nil
@end group
@end example
@end defun

@defun file-accessible-directory-p dirname
Функция возвращает @code{t}, если есть разрешение на открытие существующих
файлов каталога, имя в качестве файла которого - @var{dirname}; в противном
случае (или если такой директории нет) возвращается @code{nil}.  Значение
@var{dirname} может быть либо именем каталога (например, @file{/foo/}), либо
именем файла, который является каталогом (например, @file{/foo}, без
последней косой черты).

Например, из следующего делается вывод, что любая попытка прочитать файл в
@file{/foo/} приведет к ошибке:

@example
(file-accessible-directory-p "/foo")
     @result{} nil
@end example
@end defun

@defun access-file filename string
Функция открывает файл @var{filename} для чтения, затем закрывает его и
возвращает @code{nil}.  Однако, если открыть не удается, сигнализирует об
ошибке, используя @var{string} в качестве текста сообщения об ошибке.
@end defun

@defun file-ownership-preserved-p filename &optional group
Функция возвращает @code{t}, если удаление файла @var{filename} и
последующее его создание сохранит владельца файла неизменным.  Также
возвращает @code{t} для несуществующих файлов.

Если необязательный аргумент @var{group} - не-@code{nil}, эта функция также
проверяет, не изменилась ли группа файла.

Эта функция не переходит по символическим ссылкам.
@end defun

@defun file-modes filename
@cindex mode bits
@cindex file permissions
@cindex permissions, file
@cindex file modes
Функция возвращает @dfn{биты модификации} для @var{filename} - целое число,
суммирующее его права на чтение, запись и выполнение.  Функция следует по
символическим ссылкам.  Если файл не существует, возвращается @code{nil}.

@xref{File permissions,,, coreutils, The @sc{gnu} @code{Coreutils} Manual},
для описания битов модификации.  Например, если младший бит равен 1, файл
может быть выполнен всеми пользователями; если второй младший бит равен 1,
файл доступен для записи всем пользователям; и так далее.  Максимально
возможное значение - 4095 (7777 восьмеричное), что означает, что у всех есть
права на чтение, запись и выполнение, бит @acronym{SUID} установлен как для
других, так и для группы, а также установлен бит закрепления.

@xref{Changing Files} для функции @code{set-file-modes}, которую можно
использовать для установки этих разрешений.

@example
@group
(file-modes "~/junk/diffs")
     @result{} 492               ; @r{Десятичное целое число.}
@end group
@group
(format "%o" 492)
     @result{} "754"             ; @r{Преобразовать в восьмеричное.}
@end group

@group
(set-file-modes "~/junk/diffs" #o666)
     @result{} nil
@end group

@group
$ ls -l diffs
-rw-rw-rw- 1 lewis lewis 3063 Oct 30 16:00 diffs
@end group
@end example

@cindex MS-DOS and file modes
@cindex file modes and MS-DOS
@strong{MS-DOS предупреждение:} В MS-DOS нет такого понятия, как бит режима
исполняемого файла.  Таким образом, @code{file-modes} считает файл
исполняемым, если его имя заканчивается одним из стандартных исполняемых
расширений, например @file{.com}, @file{.bat}, @file{.exe} и некоторыми
другими.  Файлы, начинающиеся со стандартной сигнатуры @samp{#!} стандарта
POSIX, такие как сценарии оболочки и Perl, также считаются исполняемыми.
Каталоги также сообщаются как исполняемые для совместимости с POSIX@.  За
этими соглашениями также следует @code{file-attributes}
(@pxref{File Attributes}).
@end defun

@node Kinds of Files
@subsection Различия Типов Файлов
@cindex file classification
@cindex classification of file types
@cindex symbolic links

  В этом разделе описывается, как различать различные типы файлов, такие как
каталоги, символические ссылки и обычные файлы.

  Символические ссылки обычно используются везде, где они появляются.
Например, для интерпретации имени файла @file{a/b/c} любая из @file{a},
@file{a/b}, и @file{a/b/c} может быть символической ссылкой, по которой
переходят, возможно, рекурсивно, если цели ссылки сами являются
символическими ссылками.  Однако некоторые функции не следуют символическим
ссылкам в конце имени файла (в этом примере @file{a/b/c}).  Такая функция
называется @dfn{не переходящая по символическим ссылкам}.

@defun file-symlink-p filename
@cindex symbolic links
Если файл @var{filename} является символической ссылкой, эта функция не
следует по ней и вместо этого возвращает цель ссылки в виде строки.
(Целевая строка ссылки не обязательно является полным абсолютным именем
целевого файла; определение полного имени файла, на которое указывает
ссылка, нетривиально, смотреть ниже.)

Если файл @var{filename} не является символической ссылкой или не
существует, @code{file-symlink-p} возвращает @code{nil}.

Вот несколько примеров использования этой функции:

@example
@group
(file-symlink-p "not-a-symlink")
     @result{} nil
@end group
@group
(file-symlink-p "sym-link")
     @result{} "not-a-symlink"
@end group
@group
(file-symlink-p "sym-link2")
     @result{} "sym-link"
@end group
@group
(file-symlink-p "/bin")
     @result{} "/pub/bin"
@end group
@end example

Обратить внимание, что в третьем примере функция вернула @file{sym-link}, но
не приступила к его разрешению, хотя этот файл сам по себе является
символической ссылкой.  Это потому, что эта функция не переходит по
символическим ссылкам - процесс перехода по символическим ссылкам не
применяется к последнему компоненту имени файла.

Строка, которую возвращает эта функция, записана в символической ссылке;
может включать или не включать какие-либо ведущие каталоги.  Функция
@emph{не} расширяет цель ссылки для получения полного имени файла и, в
частности, не использует ведущие каталоги аргумента @var{filename}, если
таковые имеются, если цель ссылки не является абсолютным именем файла.  Вот
пример:

@example
@group
(file-symlink-p "/foo/bar/baz")
     @result{} "some-file"
@end group
@end example

@noindent
Здесь, хотя @file{/foo/bar/baz} был задан как полное имя файла, результата
нет, и на самом деле у него вообще нет ведущих каталогов.  А поскольку
@file{some-file} сам по себе может быть символической ссылкой, не можно
просто добавить к нему ведущие каталоги или даже наивно использовать
@code{expand-file-name} (@pxref{File Name Expansion}) для получения его
абсолютного имени файла.

По этой причине эта функция редко бывает полезной, если нужно определить
нечто большее, чем просто тот факт, что файл является или не является
символической ссылкой.  Если действительно нужно имя файла цели ссылки,
используйте @code{file-chase-links} или @code{file-truename}, как описано в
@ref{Truenames}.
@end defun

@defun file-directory-p filename
Функция возвращает @code{t}, если @var{filename} - имя существующего
каталога, в противном случае - @code{nil}.  Функция следует по символическим
ссылкам.

@example
@group
(file-directory-p "~rms")
     @result{} t
@end group
@group
(file-directory-p "~rms/lewis/files.texi")
     @result{} nil
@end group
@group
(file-directory-p "~rms/lewis/no-such-file")
     @result{} nil
@end group
@group
(file-directory-p "$HOME")
     @result{} nil
@end group
@group
(file-directory-p
 (substitute-in-file-name "$HOME"))
     @result{} t
@end group
@end example
@end defun

@defun file-regular-p filename
Функция возвращает @code{t}, если файл @var{filename} существует и является
обычным файлом (не каталогом, именованным каналом, терминалом или другим
устройством I/O).  Функция следует по символическим ссылкам.
@end defun

@node Truenames
@subsection Truenames
@cindex truename (of file)

  @dfn{truename} файла - это имя, которое получаеся, при переходе по
символическим ссылкам на всех уровнях, пока не останется ни одной, а затем
упростив @samp{.}@: и @samp{..}@:, появляющиеся как компоненты имени.  Это
дает своего рода каноническое имя файла.  Файл не всегда имеет уникальное
истинное имя; количество различных истинных имен, которые имеет файл, равно
количеству жестких ссылок на файл.  Однако истинные имена полезны, потому
что они устраняют символические ссылки как причину вариации имени.

@defun file-truename filename
Функция возвращает истинное имя файла @var{filename}.  Если аргумент не
является абсолютным именем файла, эта функция сначала расширяет его до
@code{default-directory}.

Функция не расширяет переменные среды.  Только
@code{substitute-in-file-name} делает это.
@xref{Definition of substitute-in-file-name}.

Если может потребоваться перейти по символическим ссылкам, предшествующим
@samp{..}@:, появляющимся как компонент имени, вызывается
@code{file-truename} без предшествующих прямых или косвенных вызовов
@code{expand-file-name}.  В противном случае компонент имени файла,
непосредственно предшествующий @samp{..}, будет сброшен перед вызовом
@code{file-truename}.  Чтобы исключить необходимость вызова
@code{expand-file-name}, @code{file-truename} обрабатывает @samp{~} так же,
как @code{expand-file-name}.

Если цель символических ссылок имеет синтаксис удаленного имени файла,
@code{file-truename} возвращает его в кавычках.
@xref{File Name Expansion,,Функции, расширяющие имена файлов}.
@end defun

@defun file-chase-links filename &optional limit
Функция следует по символическим ссылкам, начиная с @var{filename}, пока не
найдет имя файла, которое не является именем символической ссылки.  Затем
возвращается это имя файла.  Функция @emph{не} переходит по символическим
ссылкам на уровне родительских каталогов.

Если указать число для @var{limit}, то после прохождения такого количества
ссылок функция просто вернет то, что у нее есть, даже если это все еще
символическая ссылка.
@end defun

  Чтобы проиллюстрировать разницу между @code{file-chase-links} и
@code{file-truename}, предпологается, что @file{/usr/foo} - это
символическая ссылка на каталог @file{/home/foo}, а @file{/home/foo/hello} -
обычный файл (или, по крайней мере, не символическая ссылка) или
несуществующий.  Тогда у нас было бы:

@example
(file-chase-links "/usr/foo/hello")
     ;; @r{Это не соответствует ссылкам в родительских каталогах.}
     @result{} "/usr/foo/hello"
(file-truename "/usr/foo/hello")
     ;; @r{Предполагая, что @file{/home} не является символической ссылкой.}
     @result{} "/home/foo/hello"
@end example

@defun file-equal-p file1 file2
Функция возвращает @code{t}, если файлы @var{file1} и @var{file2} называют
один и тот же файл.   Это похоже на сравнение их истинных имен, за
исключением того, что имена удаленных файлов также обрабатываются
соответствующим образом.  Если @var{file1} или @var{file2} не существует,
возвращаемое значение не определено.
@end defun

@defun file-name-case-insensitive-p filename
Иногда имена файлов или их части необходимо сравнивать как строки, и в этом
случае важно знать, нечувствительна ли файловая система к регистру.  Функция
возвращает @code{t}, если файл @var{filename} находится в файловой системе
без учета регистра.  Всегда возвращается @code{t} для MS-DOS и MS-Windows.
На Cygwin и macOS файловые системы могут или не могут быть нечувствительными
к регистру, и функция пытается определить чувствительность к регистру с
помощью теста времени выполнения.  Если проверка не дает результатов,
функция возвращает @code{t} для Cygwin и @code{nil} для macOS.

В настоящее время эта функция всегда возвращает @code{nil} на платформах,
отличных от MS-DOS, MS-Windows, Cygwin и macOS.  Не обнаруживает
нечувствительность к регистру смонтированных файловых систем, таких как
общие ресурсы Samba или тома Windows, смонтированные на NFS.  На удаленных
хостах для метода @samp{smb} используется @code{t}.  Для всех остальных
методов подключения выполняются тесты во время выполнения.
@end defun

@defun file-in-directory-p file dir
Функция возвращает @code{t}, если @var{file} - это файл в каталоге @var{dir}
или в подкаталоге @var{dir}.  Также возвращает @code{t}, если @var{file} и
@var{dir} находятся в одном каталоге.  Сравнивает истинные имена двух
каталогов.  Если @var{dir} не называет существующий каталог, возвращается
значение @code{nil}.
@end defun

@defun vc-responsible-backend file
Функция определяет ответственный бэкэнд VC данного @var{file}.  Например,
если @file{emacs.c} - это файл, отслеживаемый Git,
@w{@code{(vc-responsible-backend "emacs.c")}} возвращает @samp{Git}.
Обратить внимание, что если @var{file} является символической ссылкой,
@code{vc-responsible-backend} не разрешит ее - сообщается серверная часть
самого файла символической ссылки.  Чтобы получить бэкэнд VC файла, на
который ссылается @var{file}, обёртывается @var{file} функцией разрешения
символьных ссылок, например @code{file-chase-links}:

@smallexample
(vc-responsible-backend (file-chase-links "emacs.c"))
@end smallexample
@end defun

@node File Attributes
@subsection Атрибуты Файла
@cindex file attributes

  В этом разделе описаны функции для получения подробной информации о файле,
включая номера владельца и группы, количество имен, номер inode, размер и
время доступа и модификации.

@defun file-newer-than-file-p filename1 filename2
@cindex file age
@cindex file modification time
Функция возвращает @code{t}, если файл @var{filename1} новее, чем файл
@var{filename2}.  Если @var{filename1} не существует, возвращает @code{nil}.
Если @var{filename1} существует, а @var{filename2} нет, возвращается
@code{t}.

В следующем примере предположим, что файл @file{aug-19} был записан 19-го,
@file{aug-20} записан 20-го, а файл @file{no-file} вообще не существует.

@example
@group
(file-newer-than-file-p "aug-19" "aug-20")
     @result{} nil
@end group
@group
(file-newer-than-file-p "aug-20" "aug-19")
     @result{} t
@end group
@group
(file-newer-than-file-p "aug-19" "no-file")
     @result{} t
@end group
@group
(file-newer-than-file-p "no-file" "aug-19")
     @result{} nil
@end group
@end example
@end defun

@defun file-attributes filename &optional id-format
@anchor{Definition of file-attributes}
Функция возвращает список атрибутов файла @var{filename}.  Если к указанным
атрибутам файла невозможно получить доступ, возвращается @code{nil}.  Эта
функция не переходит по символическим ссылкам.  Необязательный параметр
@var{id-format} указывает предпочтительный формат атрибутов @acronym{UID} и
@acronym{GID} (смотреть ниже) --- допустимые значения - @code{'string} и
@code{'integer}.  Последний вариант используется по умолчанию, но
планируется его изменить, поэтому потребуется указать значение не-@code{nil}
для @var{id-format}, если используется возвращаемый @acronym{UID} или
@acronym{GID}.

На платформах GNU при работе с локальным файлом эта функция является
атомарной: если файловая система одновременно изменяется каким-либо другим
процессом, эта функция возвращает атрибуты файла до или после изменения.  В
противном случае эта функция не является атомарной и может возвращать
@code{nil}, если обнаруживает состояние гонки, или может возвращать мешанину
из предыдущих и текущих атрибутов файла.

Функции доступа предоставляются для доступа к элементам в этом списке.
Аксессоры упомянуты вместе с описанием элементов ниже.

Элементы списка по порядку::

@enumerate 0
@item
@code{t} для каталога, строка для символической ссылки (имя, на которое
ссылается) или @code{nil} для текстового файла (@code{file-attribute-type}).

@c Многословный, чтобы предотвратить переполнение бокса.  --rjc 15mar92
@item
Количество имен файла (@code{file-attribute-link-number}).  Альтернативные
имена, также известные как жесткие ссылки, можно создать с помощью функции
@code{add-name-to-file} (@pxref{Changing Files}).

@item
@acronym{UID} файла, обычно в виде строки (@code{file-attribute-user-id}).
Однако, если не соответствует указанному пользователю, значением является
число.

@item
файл @acronym{GID}, аналогично (@code{file-attribute-group-id}).

@item
время последнего доступа в виде списка из четырех целых чисел
@code{(@var{sec-high} @var{sec-low} @var{microsec} @var{picosec})}
(@code{file-attribute-access-time}).  (Это похоже на значение
@code{current-time}; смотреть @ref{Time of Day}.)  Значение усекается до
разрешения временной метки файловой системы; например, в некоторых файловых
системах на основе FAT записывается только дата последнего доступа, поэтому
на этот раз всегда будет находиться полночь дня последнего доступа.

@cindex modification time of file
@item
Время последней модификации в виде списка из четырех целых чисел (как
указано выше) (@code{file-attribute-modification-time}).  Это последний раз,
когда содержимое файла изменялось.

@item
Время последнего изменения статуса в виде списка из четырех целых чисел (как
указано выше) (@code{file-attribute-status-change-time}).  Это время
последнего изменения битов режима доступа к файлу, его владельца и группы,
а также другой информации, записанной в файловой системе для файла, помимо
содержимого файла.

@item
Размер файла в байтах (@code{file-attribute-size}).  Это число с плавающей
точкой, если размер слишком велик для целого числа Lisp.

@item
Режимы файла в виде строки из десяти букв или тире, как в @samp{ls -l}
(@code{file-attribute-modes}).

@item
An unspecified value, present for backward compatibility.

@item
Номер inode файла (@code{file-attribute-inode-number}).  Если возможно, это
целое число.  Если номер inode слишком велик для представления в виде целого
числа в Emacs Lisp, но деление его на @math{2^{16}} дает представимое целое
число, тогда значение имеет форму @code{(@var{high} . @var{low})}, где
@var{low} содержит младшие 16 бит.  Если номер inode слишком велик даже для
этого, значение имеет вид @code{(@var{high} @var{middle} . @var{low})}, где
@code{high} содержит старшие биты, @var{middle} - средние 24 бита, а
@var{low} - младшие 16 бит.

@item
Номер файловой системы устройства, на котором находится файл
@code{file-attribute-device-number}).  В зависимости от величины значения
это может быть целое число или cons-ячейка, так же, как и номер inode.  Этот
элемент и номер inode файла вместе дают достаточно информации, чтобы
различать любые два файла в системе - никакие два файла не могут иметь
одинаковые значения для обоих этих номеров.
@end enumerate

Например, вот атрибуты файла для @file{files.texi}:

@example
@group
(file-attributes "files.texi" 'string)
     @result{}  (nil 1 "lh" "users"
          (20614 64019 50040 152000)
          (20000 23 0 0)
          (20614 64555 902289 872000)
          122295 "-rw-rw-rw-"
          t (5888 2 . 43978)
          (15479 . 46724))
@end group
@end example

@noindent
и вот как интерпретируется результат:

@table @code
@item nil
не является ни каталогом, ни символической ссылкой.

@item 1
имеет только одно имя (имя @file{files.texi} в текущем каталоге по
умолчанию).

@item "lh"
принадлежит пользователю с именем @samp{lh}.

@item "users"
находится в группе с именем @samp{users}.

@item (20614 64019 50040 152000)
последний раз просматривался 23 октября 2012 г. в 20:12: 03.050040152 UTC.

@item (20000 23 0 0)
последний раз был изменен 15 июля 2001 г. в 08:53:43 UTC.

@item (20614 64555 902289 872000)
Последнее изменение статуса произошло 23 октября 2012 г., в
20:20: 59.902289872 UTC.

@item 122295
имеет длину 122295 байт.  (Однако может не содержать 122295 символов, если
некоторые байты принадлежат многобайтовым последовательностям, а также если
формат конца строки - CR-LF.)

@item "-rw-rw-rw-"
имеет режим доступа для чтения и записи для владельца, группы и остальных.

@item t
просто заполнитель; он не несет информации.

@item (5888 2 . 43978)
имеет номер inode 6473924464520138.

@item (15479 . 46724)
находится на устройстве файловой системы с номером 1014478468.
@end table
@end defun

@defun file-nlinks filename
Функция возвращает количество имен (то есть жестких ссылок) файла
@var{filename}.  Если файл не существует, эта функция возвращает @code{nil}.
Обратить внимание, что символические ссылки не влияют на эту функцию, потому
что они не считаются именами файлов, на которые они ссылаются.  Функция не
переходит по символическим ссылкам.

@example
@group
$ ls -l foo*
-rw-rw-rw- 2 rms rms 4 Aug 19 01:27 foo
-rw-rw-rw- 2 rms rms 4 Aug 19 01:27 foo1
@end group

@group
(file-nlinks "foo")
     @result{} 2
@end group
@group
(file-nlinks "doesnt-exist")
     @result{} nil
@end group
@end example
@end defun

@node Extended Attributes
@subsection Расширенные Aтрибуты Файлов
@cindex extended file attributes

В некоторых операционных системах каждый файл может быть связан с
произвольными @dfn{расширенными атрибутами файла}.  В настоящее время Emacs
поддерживает запросы и установку двух конкретных наборов расширенных
атрибутов файлов: контекстов Access Control Lists (ACLs) и SELinux.  Эти
расширенные атрибуты файлов используются в некоторых системах для введения
более сложных элементов управления доступа к файлам, чем базовые разрешения
в стиле Unix, которые обсуждались в предыдущих разделах.

@cindex access control list
@cindex ACL entries
@cindex SELinux context
  Подробное объяснение ACL и SELinux выходит за рамки этого руководства.
Для требуемых здеся целей каждый файл может быть связан с @dfn{ACL}, который
определяет его свойства в системе управления файлами на основе ACL, и/или
@dfn{SELinux контекст}, который определяет его свойства в системе SELinux.

@defun file-acl filename
Функция возвращает ACL для файла @var{filename}.  Точное представление ACL в
Lisp не определено (и может измениться в будущих версиях Emacs), но это то
же самое, что принимает @code{set-file-acl} в качестве аргумента @var{acl}
(@pxref{Changing Files}).

Базовая реализация ACL зависит от платформы; в GNU/Linux и BSD Emacs
использует интерфейс POSIX ACL, а в MS-Windows Emacs эмулирует интерфейс
POSIX ACL с собственными API-интерфейсами безопасности файлов.

Если Emacs не был скомпилирован с поддержкой ACL, или файл не существует или
недоступен, или Emacs не смог определить записи ACL по какой-либо другой
причине, то возвращается значение @code{nil}.
@end defun

@defun file-selinux-context filename
Функция возвращает контекст SELinux файла @var{filename} в виде списка вида
@code{(@var{user} @var{role} @var{type} @var{range})}.  Элементы списка -
это пользователь контекста, роль, тип и диапазон соответственно в виде строк
Lisp; смотреть документацию SELinux, чтобы узнать, что они на самом деле
означают.  Возвращаемое значение имеет ту же форму, что и
@code{set-file-selinux-context} в качестве аргумента @var{context}
(@pxref{Changing Files}).

Если Emacs не был скомпилирован с поддержкой SELinux, или файл не существует
или недоступен, или если система не поддерживает SELinux, то возвращаемое
значение - @code{(nil nil nil nil)}.
@end defun

@defun file-extended-attributes filename
Функция возвращает список расширенных атрибутов файла @var{filename},
распознаваемых Emacs.  В настоящее время служит удобным способом получения
контекста ACL и SELinux; затем возможно вызвать функцию
@code{set-file-extended-attributes} с возвращенным списком в качестве
второго аргумента, чтобы применить те же атрибуты доступа к файлу к другому
файлу (@pxref{Changing Files}).

Один из элементов - @code{(acl . @var{acl})}, где @var{acl} имеет ту же
форму, что и @code{file-acl}.

Другой элемент - @code{(selinux-context . @var{context})}, где @var{context}
- это контекст SELinux в той же форме, что и @code{file-selinux-context}.
@end defun

@node Locating Files
@subsection Размещение Файлов в Стандартных Местах
@cindex locate file in path
@cindex find file in path

  В этом разделе объясняется, как искать файл в списке каталогов
(@dfn{пути}) или исполняемый файл в стандартном списке каталогов
исполняемых файлов.

  Для поиска пользовательского файла конфигурации @xref{Standard File Names}
для функции @code{locate-user-emacs-file}.

@defun locate-file filename path &optional suffixes predicate
Функция ищет файл с именем @var{filename} в списке каталогов, заданном
@var{path}, пробуя суффиксы в @var{suffixes}.  Если находит такой файл,
возвращается абсолютное имя файла (@pxref{Relative File Names}); в противном
случае возвращается @code{nil}.

Необязательный аргумент @var{suffixes} дает список суффиксов имени файла,
добавляемых к @var{filename} при поиске.  @code{locate-file} пробует каждый
возможный каталог с каждым из этих суффиксов.  Если @var{suffixes} - это
@code{nil} или @code{("")}, суффиксы отсутствуют, и @var{filename}
используется как есть.  Типичные значения @var{suffixes} -
@code{exec-suffixes} (@pxref{Subprocess Creation}), @code{load-suffixes},
@code{load-file-rep-suffixes} и возвращаемое значение функции
@code{get-load-suffixes} (@pxref{Load Suffixes}).

Типичные значения @var{path}: @code{exec-path} (@pxref{Subprocess Creation})
при поиске исполняемых программ или @code{load-path}
(@pxref{Library Search}) при поиске файлов Lisp.  Если @var{filename}
является абсолютным, @var{path} не действует, но суффиксы в @var{suffixes}
все равно пробуются.

Необязательный аргумент @var{predicate}, если не-@code{nil}, указывает
функцию предиката для проверки, подходит ли файл-кандидат.  Предикату
передается имя файла-кандидата в качестве единственного аргумента.  Если
@var{predicate} равен @code{nil} или опущен, @code{locate-file} использует
@code{file-readable-p} в качестве предиката.  @xref{Kinds of Files} для
других полезных предикатов, например, @code{file-executable-p} и
@code{file-directory-p}.

Функция обычно пропускает каталоги, поэтому, если требуется, чтобы находила
каталоги, убедится, что функция @var{predicate} возвращает для них
@code{dir-ok}.  Например:

@example
(locate-file "html" '("/var/www" "/srv") nil
             (lambda (f) (if (file-directory-p f) 'dir-ok)))
@end example


Для совместимости @var{predicate} также может быть одним из символов
@code{executable}, @code{readable}, @code{writable}, @code{exists} или
списком из одного или нескольких из этих символов.
@end defun

@defun executable-find program
Функция ищет исполняемый файл с именем @var{program} и возвращает абсолютное
имя исполняемого файла, включая его расширения имени файла, если они есть.
Если файл не найден, возвращается @code{nil}.  Функции ищут во всех
каталогах в @code{exec-path} и пробуют все расширения имен файлов в
@code{exec-suffixes} (@pxref{Subprocess Creation}).
@end defun

@node Changing Files
@section Изменение Имен Файлов и Атрибутов
@c @cindex renaming files  Duplicates rename-file
@cindex copying files
@cindex deleting files
@cindex linking files
@cindex setting modes of files

  Функции в этом разделе переименовывают, копируют, удаляют, связывают и
устанавливают режимы (разрешения) файлов.  Как правило, сигнализируют об
ошибке @code{file-error}, если не выполняют свою функцию, сообщая
системно-зависимое сообщение об ошибке, которое описывает причину сбоя.
Если они терпят неудачу из-за отсутствия файла, они сигнализируют об ошибке
@code{file-missing}.

  Для повышения производительности операционная система может кэшировать или
изменять псевдонимы, сделанные этими функциями, вместо того, чтобы сразу
записывать их во вторичное хранилище.  @xref{Files and Storage}.

  В функциях, имеющих аргумент @var{newname}, если этот аргумент является
именем каталога, он обрабатывается так, как если бы была добавлена не
относящаяся к каталогу часть имени источника.  Обычно имя каталога
заканчивается на @samp{/} (@pxref{Directory Names}).  Например, если старое
имя - @file{a/b/c}, @var{newname} @file{d/e/f/} обрабатывается так, как если
бы оно было @file{d/e/f/c}.  Эта особая обработка не применяется, если
@var{newname} - это не имя каталога, а имя файла, который является
каталогом; например, @var{newname} @file{d/e/f} остается как есть, даже если
@file{d/e/f} является каталогом.

  В функциях, имеющих аргумент @var{newname}, если файл с именем
@var{newname} уже существует, предпринимаемые действия зависят от значения
аргумента @var{ok-if-already-exists}:

@itemize @bullet
@item
Сообщать об ошибке @code{file-already-exists}, если
@var{ok-if-already-exists} равен @code{nil}.

@item
Запросить подтверждение, если @var{ok-if-already-exists} - это число.

@item
Заменить старый файл без подтверждения, если @var{ok-if-already-exists}
имеет любое другое значение.
@end itemize

@deffn Command add-name-to-file oldname newname &optional ok-if-already-exists
@cindex file with multiple names
@cindex file hard link
Функция дает файлу с именем @var{oldname} дополнительное имя @var{newname}.
Это означает, что @var{newname} становится новой жесткой ссылкой на
@var{oldname}.

Если @var{newname} является символической ссылкой, заменяется ее запись в
каталоге, а не запись в каталоге, на которую она указывает.  Если
@var{oldname} является символической ссылкой, эта функция может переходить
или не переходить по ссылке; не переходит по ссылке на платформах GNU.  Если
@var{oldname} - это каталог, эта функция обычно терпит неудачу, хотя для
суперпользователя на нескольких устаревших платформах, отличных от GNU,
может успешно работать и создать файловую систему, не имеющую древовидной
структуры.

В первой части следующего примера перечислено два файла, @file{foo} и
@file{foo3}.

@example
@group
$ ls -li fo*
81908 -rw-rw-rw- 1 rms rms 29 Aug 18 20:32 foo
84302 -rw-rw-rw- 1 rms rms 24 Aug 18 20:31 foo3
@end group
@end example

Теперь создается жесткая ссылка, вызовом @code{add-name-to-file}, затем
снова выводится список файлов.  Это показывает два имени для одного файла,
@file{foo} и @file{foo2}.

@example
@group
(add-name-to-file "foo" "foo2")
     @result{} nil
@end group

@group
$ ls -li fo*
81908 -rw-rw-rw- 2 rms rms 29 Aug 18 20:32 foo
81908 -rw-rw-rw- 2 rms rms 29 Aug 18 20:32 foo2
84302 -rw-rw-rw- 1 rms rms 24 Aug 18 20:31 foo3
@end group
@end example

Наконец, оценивается следующие:

@example
(add-name-to-file "foo" "foo3" t)
@end example

@noindent
и снова перечислить файлы.  Теперь у одного файла три имени: @file{foo},
@file{foo2} и @file{foo3}.  Старое содержимое @file{foo3} теряется.

@example
@group
(add-name-to-file "foo1" "foo3")
     @result{} nil
@end group

@group
$ ls -li fo*
81908 -rw-rw-rw- 3 rms rms 29 Aug 18 20:32 foo
81908 -rw-rw-rw- 3 rms rms 29 Aug 18 20:32 foo2
81908 -rw-rw-rw- 3 rms rms 29 Aug 18 20:32 foo3
@end group
@end example

Функция не имеет смысла в операционных системах, где несколько имен для
одного файла не разрешены.  Некоторые системы реализуют несколько имен,
вместо этого копируя файл.

Смотреть также @code{file-nlinks} в @ref{File Attributes}.
@end deffn

@deffn Command rename-file filename newname &optional ok-if-already-exists
Команда переименовывает файл @var{filename} в @var{newname}.

Если @var{filename} имеет дополнительные имена, помимо @var{filename},
присваиваются и эти имена.  Фактически, добавление имени @var{newname} с
@code{add-name-to-file} и последующее удаление @var{filename} имеет тот же
эффект, что и переименование, за исключением мгновенных промежуточных
состояний и обработки ошибок, каталогов и символических ссылок.

Эта команда не переходит по символическим ссылкам.  Если @var{filename}
является символической ссылкой, эта команда переименовывает символическую
ссылку, а не файл, на который она указывает.  Если @var{newname} является
символической ссылкой, заменяется ее запись в каталоге, а не запись в
каталоге, на которую она указывает.

Эта команда ничего не делает, если @var{filename} и @var{newname} являются
одной и той же записью каталога, то есть если они ссылаются на один и тот же
родительский каталог и дают одно и то же имя в этом каталоге.  В противном
случае, если @var{filename} и @var{newname} называют один и тот же файл,
эта команда ничего не делает в POSIX-совместимых системах и удаляет
@var{filename} в некоторых системах, отличных от POSIX.

Если @var{newname} существует, тогда это должен быть пустой каталог, если
@var{oldname} - каталог, и не каталог в противном случае.
@end deffn

@deffn Command copy-file oldname newname &optional ok-if-already-exists time preserve-uid-gid preserve-extended-attributes
Команда копирует файл @var{oldname} в @var{newname}.  Выдается сообщение
об ошибке, если @var{oldname} не является обычным файлом.  Если
@var{newname} называет каталог, копируется @var{oldname} в этот каталог,
сохраняя его окончательный компонент имени.
@c FIXME: Смотреть Bug#27986, чтобы узнать, как может измениться предыдущее предложение.

Функция следует по символическим ссылкам, за исключением того, что не
следует по висящей символической ссылке для создания @var{newname}.

Если @var{time} равен не-@code{nil}, то функция дает новому файлу то же
время последнего изменения, что и старому.  (Это работает только в некоторых
операционных системах.)  Если при установке времени возникает ошибка,
@code{copy-file} сигнализирует об ошибке @code{file-date-error}.  В
интерактивном вызове префиксный аргумент указывает значение не-@code{nil}
для @var{time}.

Если аргумент @var{preserve-uid-gid} равен @code{nil}, позволяется
операционной системе определять пользователя и группу, владеющую новым
файлом (обычно это пользователь, запускающий Emacs).  Если
@var{preserve-uid-gid} равен не-@code{nil}, проводится попытка скопировать
пользователя и группу, владеющую файлом.  Это работает только в некоторых
операционных системах и только в том случае, если есть соответствующие
разрешения.

Если необязательный аргумент @var{preserve-permissions} - не-@code{nil}, эта
функция копирует режимы файла (или ``разрешения'') @var{oldname} в
@var{newname}, а также контекст Access Control List и SELinux (если есть).  @xref{Information about Files}.

В противном случае режимы файла @var{newname} остаются неизменными, если это
уже существующий файл, и устанавливаются на режимы @var{oldname},
замаскированные правами доступа к файлу по умолчанию.  (смотреть
@code{set-default-file-modes} ниже), если @var{newname} нужно создать
заново.  Контекст Access Control List или SELinux не копируется ни в одном
случае.
@end deffn

@deffn Command make-symbolic-link target linkname &optional ok-if-already-exists
@pindex ln
@kindex file-already-exists
Команда создает символическую ссылку на @var{target} с именем
@var{linkname}.  Это похоже на команду оболочки @samp{ln -s @var{target}
@var{linkname}}.  Аргумент @var{target} обрабатывается только как строка;
ему не нужно называть существующий файл.  Если @var{ok-if-already-exists} -
целое число, указывающее на интерактивное использование, то ведущий @samp{~}
раскрывается, а ведущий @samp{/:} удаляется из строки @var{target}.

Если @var{target} - относительное имя файла, результирующая символическая
ссылка интерпретируется относительно каталога, содержащего символическую
ссылку.  @xref{Relative File Names}.

Если и @var{target}, и @var{linkname} имеют синтаксис удаленного имени файла
и если оба удаленных идентификатора равны, символическая ссылка указывает на
часть имени локального файла @var{target}.

Эта функция недоступна в системах, которые не поддерживают символические
ссылки.
@end deffn

@cindex trash
@vindex delete-by-moving-to-trash
@deffn Command delete-file filename &optional trash
@pindex rm
Команда удаляет файл @var{filename}.  Если файл имеет несколько имен, он
продолжает существовать под другими именами.  Если @var{filename} является
символической ссылкой, @code{delete-file} удаляет только символическую
ссылку, но не ее цель.

Соответствующий тип ошибки @code{file-error} выдается, если файл не
существует или не удаляется.  (В GNU и других системах, подобных POSIX, файл
можно удалить, если его каталог доступен для записи.)

Если необязательный аргумент @var{trash} - не-@code{nil}, а переменная
@code{delete-by-moving-to-trash} - не-@code{nil}, эта команда перемещает
файл в системную корзину, а не удаляет его.  @xref{Misc File Ops,,Miscellaneous File Operations, emacs, The GNU Emacs Manual}.  При интерактивном вызове
@var{trash} становится @code{t}, если аргумент префикса не указан, и
@code{nil} в противном случае.

Смотреть также @code{delete-directory} в @ref{Create/Delete Dirs}.
@end deffn

@cindex file permissions, setting
@cindex permissions, file
@cindex file modes, setting
@deffn Command set-file-modes filename mode
Функция устанавливает @dfn{файловые режимы} (или @dfn{разрешения})
@var{filename} в @var{mode}.  Эта функция следует по символическим ссылкам.

Если вызывается не интерактивно, @var{mode} должно быть целым числом.
Используются только младшие 12 бит целого числа; в большинстве систем
значимы только младшие 9 бит.  Можно использовать конструкцию Lisp для
восьмеричных чисел, чтобы ввести @var{mode}.  Например,

@example
(set-file-modes #o644)
@end example

@noindent
указывает, что файл должен быть доступен для чтения и записи его владельцe,
для чтения членам группы и для чтения всем остальным пользователям.
@xref{File permissions,,, coreutils, @sc{gnu} @code{Coreutils} Manual}, для
описания спецификаций битов режима.

В интерактивном режиме @var{mode} считывается из минибуфера с помощью
@code{read-file-modes} (смотреть ниже), что позволяет пользователю вводить
либо целое число, либо строку, символически представляющую разрешения.

@xref{File Attributes} для функции @code{file-modes}, которая возвращает
права доступа к файлу.
@end deffn

@defun set-default-file-modes mode
@cindex umask
Функция устанавливает разрешения по умолчанию для новых файлов, созданных
Emacs и его подпроцессами.  Каждый файл, созданный с помощью Emacs,
изначально имеет эти разрешения или их подмножество (@code{write-region} не
будет предоставлять разрешения на выполнение, даже если разрешения для
файлов по умолчанию разрешают выполнение).  В GNU и других системах,
подобных POSIX, разрешения по умолчанию задаются побитовым дополнением
значения @samp{umask}, то есть @:, каждый бит, установленный в аргументе
@var{mode}, будет @emph{перезагружать} в разрешениях по умолчанию, с
которыми Emacs создает файлы.

Аргумент @var{mode} должен быть целым числом, указывающим разрешения,
аналогично @code{set-file-modes} выше.  Имеют значение только самые младшие
9 бит.

Разрешения файла по умолчанию не действуют, когда сохраняется измененная
версия существующего файла; при сохранении файла сохраняются его
существующие разрешения.
@end defun

@defmac with-file-modes mode body@dots{}
Этот макрос оценивает формы @var{body} с разрешениями по умолчанию для новых
файлов, временно установленными в @var{modes} (значение которого такое же,
как для @code{set-file-modes} выше).  По завершении восстанавливаются
исходные права доступа к файлам по умолчанию и возвращается значение
последней формы в @var{body}.

Это полезно, например, для создания личных файлов.
@end defmac

@defun default-file-modes
Функция возвращает права доступа к файлу по умолчанию в виде целого числа.
@end defun

@defun read-file-modes &optional prompt base-file
Функция считывает набор битов режима файла из минибуфера.  Первый
необязательный аргумент @var{prompt} указывает приглашение не по умолчанию.
Второй необязательный аргумент @var{base-file} - это имя файла, на основе
разрешений которого будут базироваться биты режима, возвращаемые этой
функцией, если то, что вводит пользователь, определяет биты режима
относительно разрешений существующего файла.

Если пользовательский ввод представляет собой восьмеричное число, эта
функция возвращает это число.  Если это полная символьная спецификация битов
режима, как в @code{"u=rwx"}, функция преобразует его в эквивалентное
числовое значение с помощью @code{file-modes-symbolic-to-number} и
возвращает результат.  Если спецификация является относительной, как в
@code{"o+g"}, то разрешения, на которых основана спецификация, берутся из
битов режима @var{base-file}.  Если @var{base-file} опущен или @code{nil},
функция использует @code{0} в качестве битов базового режима.  Полные и
относительные спецификации можно объединить, как @code{"u+r,g+rx,o+r,g-w"}.
@xref{File permissions,,, coreutils, The @sc{gnu} @code{Coreutils} Manual},
для описания спецификаций файлового режима.
@end defun

@defun file-modes-symbolic-to-number modes &optional base-modes
Функция преобразует спецификацию символьного режима файла в @var{modes} в
эквивалентное целое число.  Если символическая спецификация основана на
существующем файле, биты режима этого файла берутся из необязательного
аргумента @var{base-modes}; если этот аргумент опущен или @code{nil}, по
умолчанию он равен 0, то есть вообще никаких прав доступа.
@end defun

@defun set-file-times filename &optional time
Функция устанавливает время доступа и модификации @var{filename} в
@var{time}.  Возвращаемое значение - @code{t}, если время успешно
установлено, в противном случае - @code{nil}.  @var{time} по умолчанию
использует текущее время и должно быть значением времени
(@pxref{Time of Day}).
@end defun

@defun set-file-extended-attributes filename attribute-alist
Функция устанавливает атрибуты расширенного файла, распознаваемые Emacs, для
@code{filename}.  Второй аргумент @var{attribute-alist} должен быть списком
той же формы, возвращаемой @code{file-extended-attributes}.  Возвращаемое
значение - @code{t}, если атрибуты установлены успешно, в противном случае -
@code{nil}.  @xref{Extended Attributes}.
@end defun

@defun set-file-selinux-context filename context
Функция устанавливает контекст безопасности SELinux для @var{filename} в
@var{context}.  Аргумент @var{context} должен быть списком
@code{(@var{user} @var{role} @var{type} @var{range})}, где каждый элемент
является строкой.  @xref{Extended Attributes}.

Функция возвращает @code{t}, если ей удается установить контекст SELinux для
@var{filename}.  Возвращает @code{nil}, если контекст не был установлен
(например, если SELinux отключен или Emacs был скомпилирован без поддержки
SELinux).
@end defun

@defun set-file-acl filename acl
Функция устанавливает для списка контроля доступа @var{filename} значение
@var{acl}.  Аргумент @var{acl} должен иметь ту же форму, которую возвращает
функция @code{file-acl}.  @xref{Extended Attributes}.

Функция возвращает @code{t}, если она успешно устанавливает ACL для
@var{filename}, @code{nil}, в противном случае.
@end defun

@node Files and Storage
@section Файлы и Вторичное Хранилище
@cindex secondary storage

После того, как Emacs изменяет файл, есть две причины, по которым изменения
могут не сохраниться после сбоев питания или носителя, и обе связаны с
эффективностью.  Во-первых, операционная система может связать записанные
данные с данными, уже хранящимися в другом месте на вторичном хранилище, до
тех пор, пока один или другой файл не будет позже изменен; это приведет к
потере обоих файлов, если единственная копия на вторичном хранилище будет
потеряна из-за сбоя носителя.  Во-вторых, операционная система может не
сразу записывать данные во вторичное хранилище, что приведет к потере данных
при отключении питания.

@findex write-region
Хотя обоих видов сбоев можно в значительной степени избежать с помощью
правильно настроенной файловой системы, такие системы обычно более дороги
или менее эффективны.  В более типичных системах, чтобы пережить сбой
носителя, можно скопировать файл на другое устройство, а чтобы перенести
сбой питания, можно использовать функцию @code{write-region} с переменной
@code{write-region-inhibit-fsync}, установленной в @code{nil}.
@xref{Writing to Files}.

@node File Names
@section Имена Файла
@cindex file names

  В Emacs, как и везде, файлы обычно называются своими именами.  Имена
файлов в Emacs представлены в виде строк.  Все функции, которые работают с
файлом, ожидают аргумента имени файла.

  Помимо работы с самими файлами, программам Emacs Lisp часто необходимо
работать с именами файлов; то есть разобрать их и использовать часть имени
для построения связанных имен файлов.  В этом разделе описывается, как
управлять именами файлов.

  Функции в этом разделе фактически не обращаются к файлам, поэтому они
могут работать с именами файлов, которые не относятся к существующему файлу
или каталогу.

@findex cygwin-convert-file-name-from-windows
@findex cygwin-convert-file-name-to-windows
@cindex MS-Windows file-name syntax
@cindex converting file names from/to MS-Windows syntax
  В MS-DOS и MS-Windows эти функции (как и функции, которые фактически
работают с файлами) принимают синтаксис имени файла MS-DOS или MS-Windows,
где обратная косая черта разделяет компоненты, а также синтаксис POSIX; но
они всегда возвращают синтаксис POSIX.  Это позволяет программам на Lisp
указывать имена файлов в синтаксисе POSIX и правильно работать во всех
системах без изменений.@footnote{В версиях Emacs для MS-Windows,
скомпилированных для среды Cygwin, можно использовать функции
@code{cygwin-convert-file-name-to-windows} и
@code{cygwin-convert-file-name-from-windows} для преобразования между двумя
синтаксисами имен файлов.}

@menu
* File Name Components::  Директория, часть имени файла, а все остальное.
* Relative File Names::   Некоторые имена файлов относятся к текущему каталогу.
* Directory Names::       Имя каталога как каталога отличается от его имени
                             как файла.
* File Name Expansion::   Преобразование относительных имен файлов в
                             абсолютные.
* Unique File Names::     Генерация имен для временных файлов.
* File Name Completion::  Нахождение дополнений для заданного имени файла.
* Standard File Names::   Если пакет использует фиксированное имя файла, как
                             легко работать с различными операционными
                             системами.
@end menu

@node File Name Components
@subsection Компоненты Имени Файла
@cindex directory part (of file name)
@cindex nondirectory part (of file name)
@cindex version number (in file name)

  Операционная система группирует файлы в каталоги.  Чтобы указать файл,
потребуется указать каталог и имя файла в этом каталоге.  Следовательно,
Emacs считает, что имя файла состоит из двух основных частей: части
@dfn{имя директории} и части @dfn{без директории} (или
@dfn{имя файла в каталоге}).  Любая часть может быть пустой.  Объединение
этих двух частей воспроизводит исходное имя файла.

  В большинстве систем часть каталога - это все, вплоть до последней косой
черты (обратная косая черта также разрешена при вводе в MS-DOS или
MS-Windows); часть без директории - остальное.

  Для некоторых целей часть без директории далее подразделяется на
собственное имя и @dfn{номер версии}.  В большинстве систем только файлы
резервных копий имеют номера версий в своих именах.

@defun file-name-directory filename
Функция возвращает часть каталога @var{filename} как имя каталога
(@pxref{Directory Names}) или @code{nil}, если @var{filename} не включает
часть каталога.

В GNU и других системах, подобных POSIX, строка, возвращаемая этой функцией,
всегда заканчивается косой чертой.  В MS-DOS он также может заканчиваться
двоеточием.

@example
@group
(file-name-directory "lewis/foo")  ; @r{пример GNU}
     @result{} "lewis/"
@end group
@group
(file-name-directory "foo")        ; @r{пример GNU}
     @result{} nil
@end group
@end example
@end defun

@defun file-name-nondirectory filename
Функция возвращает имя @var{filename} без директории.

@example
@group
(file-name-nondirectory "lewis/foo")
     @result{} "foo"
@end group
@group
(file-name-nondirectory "foo")
     @result{} "foo"
@end group
@group
(file-name-nondirectory "lewis/")
     @result{} ""
@end group
@end example
@end defun

@defun file-name-sans-versions filename &optional keep-backup-version
Функция возвращает @var{filename} с отброшенными номерами версий файлов,
номерами версий резервных копий или завершающими тильдами.

Если @var{keep-backup-version} равен не-@code{nil}, то истинные номера
версий файлов, которые понимает файловая система как таковые, исключаются из
возвращаемого значения, но номера версий резервных копий сохраняются.

@example
@group
(file-name-sans-versions "~rms/foo.~1~")
     @result{} "~rms/foo"
@end group
@group
(file-name-sans-versions "~rms/foo~")
     @result{} "~rms/foo"
@end group
@group
(file-name-sans-versions "~rms/foo")
     @result{} "~rms/foo"
@end group
@end example
@end defun

@defun file-name-extension filename &optional period
Функция возвращает окончательное расширение @var{filename}, если оно есть,
после применения @code{file-name-sans-versions} для удаления любой части
версии/резервной копии.  Расширение в имени файла - это часть, которая
следует за последней @samp{.} в компоненте не директории (за вычетом любой
части версии/резервной копии).

Функция возвращает @code{nil} для имен файлов без расширений, таких как
@file{foo}.  Она возвращает @code{""} для нулевых расширений, как в
@file{foo.}.  Если последний компонент имени файла начинается с @samp{.},
этот @samp{.} не считается началом расширения.  Таким образом, расширение
@file{.emacs}'s - это @code{nil}, а не @samp{.emacs}.

Если @var{period} - не-@code{nil}, то возвращаемое значение включает
пропуски, ограничивающие расширение, а если @var{filename} не имеет
расширения, значение - @code{""}.
@end defun

@defun file-name-sans-extension filename
Функция возвращает @var{filename} минус его расширение, если оно есть.
Часть версии/резервной копии, если она присутствует, удаляется только в том
случае, если файл имеет расширение.  Например,

@example
(file-name-sans-extension "foo.lose.c")
     @result{} "foo.lose"
(file-name-sans-extension "big.hack/foo")
     @result{} "big.hack/foo"
(file-name-sans-extension "/my/home/.emacs")
     @result{} "/my/home/.emacs"
(file-name-sans-extension "/my/home/.emacs.el")
     @result{} "/my/home/.emacs"
(file-name-sans-extension "~/foo.el.~3~")
     @result{} "~/foo"
(file-name-sans-extension "~/foo.~3~")
     @result{} "~/foo.~3~"
@end example

Обратить внимание, что @samp{.~3~} в двух последних примерах является
резервной частью, а не расширением.
@end defun

@defun file-name-base &optional filename
Функция представляет собой композицию @code{file-name-sans-extension} и
@code{file-name-nondirectory}.  Например,

@example
(file-name-base "/my/home/foo.c")
    @result{} "foo"
@end example

По умолчанию аргумент @var{filename} равен @code{buffer-file-name}.
@end defun

@node Relative File Names
@subsection Абсолютные и Относительные Имена Файлов
@cindex absolute file name
@cindex relative file name

  Все каталоги в файловой системе образуют дерево, начинающееся с корневого
каталога.  Имя файла может указывать все имена каталогов, начиная с корня
дерева; тогда это называется @dfn{абсолютным} именем файла.  Или может
указываться положение файла в дереве относительно каталога по умолчанию;
тогда это называется @dfn{относительным} именем файла.  В GNU и других
POSIX-подобных системах после расширения любого ведущего @samp{~} абсолютное
имя файла начинается с @samp{/} (@pxref{abbreviate-file-name}), а
относительное - нет.  В MS-DOS и MS-Windows абсолютное имя файла начинается
с косой черты или обратной косой черты либо со спецификации диска
@samp{@var{x}:/}, где @var{x} - это @dfn{имя диска}.

@defun file-name-absolute-p filename
Функция возвращает @code{t}, если @var{filename} является абсолютным именем
файла, или начинается с @samp{~}, в противном случае - @code{nil}.

@example
@group
(file-name-absolute-p "~rms/foo")
     @result{} t
@end group
@group
(file-name-absolute-p "rms/foo")
     @result{} nil
@end group
@group
(file-name-absolute-p "/user/rms/foo")
     @result{} t
@end group
@end example
@end defun

  Учитывая возможное относительное имя файла, можно расширить любой
начальный @samp{~} и преобразовать результат в абсолютное имя с помощью
@code{expand-file-name} (@pxref{File Name Expansion}).  Эта функция
преобразует абсолютные имена файлов в относительные:

@defun file-relative-name filename &optional directory
Функция пытается вернуть относительное имя, эквивалентное @var{filename},
при условии, что результат будет интерпретироваться относительно
@var{directory} (абсолютное имя каталога или имя файла каталога).  Если
@var{directory} не указан или @code{nil}, по умолчанию используется каталог
текущего буфера по умолчанию.

В некоторых операционных системах абсолютное имя файла начинается с имени
устройства.  В таких системах @var{filename} не имеет эквивалента
относительного каталогаа @var{directory}, если начинается с двух разных
имен устройств.  В этом случае @code{file-relative-name} возвращает
@var{filename} в абсолютной форме.

@example
(file-relative-name "/foo/bar" "/foo/")
     @result{} "bar"
(file-relative-name "/foo/bar" "/hack/")
     @result{} "../foo/bar"
@end example
@end defun

@node Directory Names
@subsection Имена Директории
@cindex directory name
@cindex directory file name
@cindex file name of directory

  @dfn{Имя директории} - это строка, которая должна называть каталог, если
так вообще называется какой-либо файл.  Каталог на самом деле является
своего рода файлом, и у него есть имя файла (называемое
@dfn{имя файла директории}, которое связано с именем каталога, но обычно не
идентично (это не совсем то же самое, что обычная терминология POSIX).  Эти
два имени для одного и того же объекта связаны синтаксическим
преобразованием.  В GNU и других системах, подобных POSIX, это просто: чтобы
получить имя каталога, добавьте @samp{/} к имени файла каталога, который еще
не заканчивается на @samp{/}.  В MS-DOS отношения сложнее.

  Разница между именем каталога и именем файла каталога тонкая, но важная.
Когда переменная Emacs или аргумент функции описываются как имя каталога,
имя файла каталога неприемлемо.  Когда @code{file-name-directory} возвращает
строку, это всегда имя каталога.

  Следующие две функции преобразуют имена каталогов в имена файлов
каталогов.  Они не делают ничего особенного с заменами переменных окружения,
таких как @samp{$HOME} и конструкции @samp{~}, @samp{.} и @samp{..}.

@defun file-name-as-directory filename
Функция возвращает строку, представляющую @var{filename} в форме, которую
операционная система будет интерпретировать как имя каталога (имя каталога).
В большинстве систем это означает добавление косой черты к строке (если она
еще не оканчивается на нее).

@example
@group
(file-name-as-directory "~rms/lewis")
     @result{} "~rms/lewis/"
@end group
@end example
@end defun

@defun directory-name-p filename
Функция возвращает не-@code{nil}, если @var{filename} заканчивается символом
разделителя каталогов.  Это косая черта @samp{/} в GNU и других системах,
подобных POSIX; MS-Windows и MS-DOS распознают как косую черту, так и
обратную косую черту @samp{\} как разделители каталогов.
@end defun

@defun directory-file-name dirname
Функция возвращает строку, представляющую @var{dirname} в форме, которую
операционная система будет интерпретировать как имя файла (имя файла
каталога).  В большинстве систем это означает удаление последних
разделителей каталогов из строки, если только строка не состоит полностью из
разделителей каталогов.

@example
@group
(directory-file-name "~lewis/")
     @result{} "~lewis"
@end group
@end example
@end defun

  Учитывая имя каталога, можно объединить его с относительным именем файла,
используя @code{concat}:

@example
(concat @var{dirname} @var{relfile})
@end example

@noindent
Прежде чем делать это, убедиться, что имя файла является относительным.
Если используется абсолютное имя файла, результаты могут быть синтаксически
недопустимыми или относиться к неправильному файлу.

  Если требуется использовать имя файла каталога при создании такой
комбинации, нужно сначала преобразовать его в имя каталога с помощью
@code{file-name-as-directory}:

@example
(concat (file-name-as-directory @var{dirfile}) @var{relfile})
@end example

@noindent
Не пытаться соединить косую черту вручную, как в

@example
;;; @r{Неправильно!}
(concat @var{dirfile} "/" @var{relfile})
@end example

@noindent
потому что это не переносимо.  Всегда использовать
@code{file-name-as-directory}.

  Чтобы избежать проблем, упомянутых выше, или если значение @var{dirname}
может быть @code{nil} (например, из элемента @code{load-path}),
использовать:

@example
(expand-file-name @var{relfile} @var{dirname})
@end example

Однако @code{expand-file-name} расширяет ведущие @samp {~} в @var{relfile},
что может быть не тем, что требуется.  @xref{File Name Expansion}.

  Чтобы преобразовать имя каталога в его аббревиатуру, использовать
  эту функцию:

@cindex file name abbreviations
@cindex abbreviated file names
@vindex directory-abbrev-alist
@defun abbreviate-file-name filename
@anchor{abbreviate-file-name}
Функция возвращает сокращенную форму @var{filename}.  Применяет сокращения,
указанные в @code{directory-abbrev-alist}
(@pxref{File Aliases,,File Aliases, emacs, The GNU Emacs Manual}), затем
заменяет @samp{~} на домашний каталог пользователя, если аргумент называет
файл в домашнем каталоге или одном из его подкаталогов.  Если домашний
каталог является корневым, он не заменяется на @samp{~}, потому что это не
делает результат короче во многих системах.

Можно использовать эту функцию для имен каталогов и для имен файлов, потому
что она распознает сокращения даже как часть имени.
@end defun

@node File Name Expansion
@subsection Функции, Расширяющие Имена Файлов
@cindex expansion of file names

  @dfn{Расширенное} имя файла означает преобразование относительного имени
файла в абсолютное.  Поскольку это делается относительно каталога по
умолчанию, потребуется указать каталог по умолчанию, а также имя файла,
который нужно раскрыть.  Это также включает расширение сокращений, таких как
@file{~/}
@ifnottex
(@pxref{abbreviate-file-name}),
@end ifnottex
и устранение избыточности, такой как @file{./} и @file{@var{name}/../}.

@defun expand-file-name filename &optional directory
Функция преобразует @var{filename} в абсолютное имя файла.  Если задан
аргумент @var{directory}, это начальный каталог по умолчанию, если
@var{filename} является относительным и не начинается с @samp{~}.  (Значение
@var{directory} само должно быть абсолютным именем каталога или именем файла
каталога; оно может начинаться с @samp{~}.)  В противном случае используется
текущее значение буфера @code{default-directory}.  Например:

@example
@group
(expand-file-name "foo")
     @result{} "/xcssun/users/rms/lewis/foo"
@end group
@group
(expand-file-name "../foo")
     @result{} "/xcssun/users/rms/foo"
@end group
@group
(expand-file-name "foo" "/usr/spool/")
     @result{} "/usr/spool/foo"
@end group
@end example

Если часть @var{filename} перед первой косой чертой - @samp{~}, она
расширяется до значения переменной среды @env{HOME} (обычно это ваш домашний
каталог).  Если перед первой косой чертой стоит @samp{~@var{user}} и если
@var{user} - допустимое имя для входа, оно расширяется до домашнего каталога
@var{user}.  Если не требуется это расширение для относительного имени
@var{filename}, которое может начинаться с символа @samp {~}, можно
использовать @code{(concat (file-name-as-directory directory) filename)}
вместо @code{(expand-file-name filename directory)}.

Имена файлов, содержащие @samp{.} или @samp{..}, упрощены до их канонической
формы:

@example
@group
(expand-file-name "bar/../foo")
     @result{} "/xcssun/users/rms/lewis/foo"
@end group
@end example

В некоторых случаях ведущий компонент @samp{..} может оставаться на выходе:

@example
@group
(expand-file-name "../home" "/")
     @result{} "/../home"
@end group
@end example

@noindent
Это сделано для файловых систем, которые имеют концепцию суперкорня над
корневым каталогом @file{/}.  В других файловых системах @file{/../}
интерпретируется точно так же, как @file{/}.

Расширение @file{.} или пустой строки возвращает каталог по умолчанию:

@example
@group
(expand-file-name "." "/usr/spool/")
     @result{} "/usr/spool"
(expand-file-name "" "/usr/spool/")
     @result{} "/usr/spool"
@end group
@end example

Обратить внимание, что @code{expand-file-name} действительно @emph{не}
расширяет переменные среды; только @code{substitute-in-file-name} делает
это:

@example
@group
(expand-file-name "$HOME/foo")
     @result{} "/xcssun/users/rms/lewis/$HOME/foo"
@end group
@end example

Также обратить внимание, что @code{expand-file-name} не переходит по
символическим ссылкам ни на каком уровне.  Это приводит к различию в
способах обработки @samp{..} в @code{file-truename} и
@code{expand-file-name}.  Предполагая, что @samp{/tmp/bar} является
символической ссылкой на каталог @samp{/tmp/foo/bar}, получается:

@example
@group
(file-truename "/tmp/bar/../myfile")
     @result{} "/tmp/foo/myfile"
@end group
@group
(expand-file-name "/tmp/bar/../myfile")
     @result{} "/tmp/myfile"
@end group
@end example

Если может потребоваться перейти по символическим ссылкам, предшествующим
@samp{..}, потребуется убедиться, что вызывается @code{file-truename} без
предшествующих прямых или косвенных вызовов @code{expand-file-name}.
@xref{Truenames}.
@end defun

@defvar default-directory
Значение этой локальной переменной буфера - это каталог по умолчанию для
текущего буфера.  Это должно быть абсолютное имя каталога; оно может
начинаться с @samp{~}.  Эта переменная является локальной для каждого
буфера.

@code{expand-file-name} использует каталог по умолчанию, когда её второй
аргумент - @code{nil}.

Значение всегда представляет собой строку, оканчивающуюся косой чертой.

@example
@group
default-directory
     @result{} "/user/lewis/manual/"
@end group
@end example
@end defvar

@defun substitute-in-file-name filename
@anchor{Definition of substitute-in-file-name}
Функция заменяет ссылки на переменные среды в @var{filename} значениями
переменных среды.  Следуя стандартному синтаксису оболочки Unix, @samp{$} -
это префикс для замены значения переменной среды.  Если вход содержит
@samp{$$}, он конвертируется в @samp{$}; это дает пользователю возможность
цитировать @samp{$}.

Имя переменной окружения - это последовательность буквенно-цифровых символов
(включая подчеркивания), следующих за @samp{$}.  Если символ, следующий за
@samp{$}, является @samp{@{}, тогда имя переменной - это все, вплоть до
соответствия @samp{@}}.

Вызов @code{substitute-in-file-name} на выходе, произведенный
@code{substitute-in-file-name}, обычно дает неверные результаты.  Например,
использование @samp{$$} для цитирования одного @samp{$} не будет работать
должным образом, а @samp{$} в значении переменной окружения может привести к
повторной подстановке.  Следовательно, программы, которые вызывают эту
функцию и помещают результат в то место, где он будет передан в эту функцию,
должны удвоить все символы @samp{$}, чтобы предотвратить последующие
неверные результаты.

@c Многословный, чтобы избежать переполнения hbox.  --rjc 15mar92
Здесь предполагается, что переменная окружения @env{HOME}, которая содержит
домашний каталог пользователя, имеет значение @samp{/xcssun/users/rms}.

@example
@group
(substitute-in-file-name "$HOME/foo")
     @result{} "/xcssun/users/rms/foo"
@end group
@end example

После замены, если @samp{~} или @samp{/} появляется сразу после другого
@samp{/}, функция отбрасывает все, что было до него (вплоть до
непосредственно предшествующего @samp{/}).

@example
@group
(substitute-in-file-name "bar/~/foo")
     @result{} "~/foo"
@end group
@group
(substitute-in-file-name "/usr/local/$HOME/foo")
     @result{} "/xcssun/users/rms/foo"
     ;; @r{@file{/usr/local/} было отброшено.}
@end group
@end example

@end defun

  Иногда расширять имена файлов нежелательно.  В таких случаях имя файла
можно заключить в кавычки, чтобы подавить раскрытие и буквально обработать
имя файла.  Цитирование происходит путем добавления к имени файла префикса
@samp{/:}.

@defmac file-name-quote name
Этот макрос добавляет префикс цитаты @samp{/:} в файл @var{name}.  Для
локального файла @var{name} он ставит перед @var{name} префикс @samp{/:}.
Если @var{name} - это имя удаленного файла, указывается локальная часть
@var{name} (@pxref{Magic File Names}).  Если @var{name} уже является именем
цитированного файла, @var{name} возвращается без изменений.

@example
@group
(substitute-in-file-name (file-name-quote "bar/~/foo"))
     @result{} "/:bar/~/foo"
@end group

@group
(substitute-in-file-name (file-name-quote "/ssh:host:bar/~/foo"))
     @result{} "/ssh:host:/:bar/~/foo"
@end group
@end example

Макрос не может использоваться для подавления обработчиков имен файлов из
волшебных имен файлов (@pxref{Magic File Names}).
@end defmac

@defmac file-name-unquote name
Этот макрос удаляет префикс цитаты @samp{/:} из файла @var{name}, если он
есть.  Если @var{name} - имя удаленного файла, локальная часть @var{name} не
заключена в кавычки.
@end defmac

@defmac file-name-quoted-p name
Этот макрос возвращает не-@code{nil}, если @var{name} заключен в кавычки с
префиксом @samp{/:}.  Если @var{name} - имя удаленного файла, проверяется
локальная часть @var{name}.
@end defmac


@node Unique File Names
@subsection Создание Уникальных Имен Файлов
@cindex unique file names
@cindex temporary files

  Некоторым программам необходимо записывать временные файлы.  Вот обычный
способ создания имени для такого файла:

@example
(make-temp-file @var{name-of-application})
@end example

@noindent
Задача @code{make-temp-file} - предотвратить попытки двух разных
пользователей или двух разных заданий использовать одно и то же имя файла.

@defun make-temp-file prefix &optional dir-flag suffix text
Функция создает временный файл и возвращает его имя.  Emacs создает имя
временного файла, добавляя к @var{prefix} несколько случайных символов,
которые различны в каждом задании Emacs.  Результатом обязательно будет
вновь созданный файл, содержащий @var{text}, если он указан в виде строки, и
пустой в противном случае.  В MS-DOS эта функция может усекать @var{prefix},
чтобы соответствовать ограничениям 8 + 3 имени файла.  Если @var{prefix} -
относительное имя файла, оно заменяется на @code{temporary-file-directory}.

@example
@group
(make-temp-file "foo")
     @result{} "/tmp/foo232J6v"
@end group
@end example

Когда @code{make-temp-file} возвращается, файл был создан и пуст.  На этом
этапе потребуется записать предполагаемое содержимое в файл.

Если @var{dir-flag} равен не-@code{nil}, @code{make-temp-file} создает
пустой каталог вместо пустого файла.  Возвращает имя файла, а не имя
каталога этого каталога.  @xref{Directory Names}.

Если @var{suffix} равен не-@code{nil}, @code{make-temp-file}, он добавляется
в конец имени файла.

Если @var{text} - строка, @code{make-temp-file} вставляет ее в файл.

Чтобы предотвратить конфликты между различными библиотеками, работающими в
одном и том же Emacs, каждая программа на Lisp, использующая
@code{make-temp-file}, должна иметь свой собственный @var{prefix}.  Число,
добавленное в конец @var{prefix}, различает одно и то же приложение,
работающее в разных заданиях Emacs.  Дополнительные добавленные символы
позволяют использовать большое количество различных имен даже в одном
задании Emacs.
@end defun

  Каталог по умолчанию для временных файлов управляется переменной
@code{temporary-file-directory}.  Эта переменная дает пользователю единый
способ указать каталог для всех временных файлов.  Некоторые программы
вместо этого используют @code{small-temporary-file-directory}, если это
не-@code{nil}.  Чтобы использовать это, перед вызовом @code{make-temp-file}
следует расширить префикс до соответствующего каталога.

@defopt temporary-file-directory
@cindex @env{TMPDIR} environment variable
@cindex @env{TMP} environment variable
@cindex @env{TEMP} environment variable
Эта переменная определяет имя каталога для создания временных файлов.  Её
значением должно быть имя каталога (@pxref{Directory Names}), но для
программ Lisp это хорошо, если вместо этого значение предоставляется имя
файла каталога.  Использование значения в качестве второго аргумента
@code{expand-file-name} - хороший способ добиться этого.

Значение по умолчанию определяется разумным образом для вашей операционной
системы; основано на переменных окружения @env{TMPDIR}, @env{TMP} и
@env{TEMP} с откатом к системно-зависимому имени, если ни одна из этих
переменных не определена.

Даже если не используется @code{make-temp-file} для создания временного
файла, все равно потребуется использовать эту переменную, чтобы решить, в
какой каталог поместить файл.  Однако, если ожидается, что файл будет
небольшим, нужно сначала использовать @code{small-temporary-file-directory},
если это не-@code{nil}.
@end defopt

@defopt small-temporary-file-directory
Эта переменная определяет имя каталога для создания определенных временных
файлов, которые, вероятно, будут небольшими.

Если требуется записать временный файл, который, вероятно, будет небольшим,
нужно вычислить каталог следующим образом:

@example
(make-temp-file
  (expand-file-name @var{prefix}
                    (or small-temporary-file-directory
                        temporary-file-directory)))
@end example
@end defopt

@defun make-temp-name base-name
Функция генерирует строку, которая может быть уникальным именем файла.  Имя
начинается с @var{base-name} и к нему добавлено несколько случайных
символов, которые различны в каждом задании Emacs.  Это похоже на
@code{make-temp-file}, за исключением того, что (1) он просто создает имя и
не создает файл, (2) @var{base-name} должно быть абсолютным именем файла,
которое не является магическим, и (3) если возвращаемое имя файла является
магическим, оно может называть существующий файл.  @xref{Magic File Names}.

@strong{Предупреждение:} В большинстве случаев не следует использовать эту
функцию; используется вместо этого @code{make-temp-file}!  Эта функция
восприимчива к состоянию гонки между вызовом @code{make-temp-name} и
созданием файла, что в некоторых случаях может вызвать брешь в безопасности.
@end defun

Иногда необходимо создать временный файл на удаленном хосте или в
смонтированном каталоге.  Следующие две функции поддерживают это.

@defun make-nearby-temp-file prefix &optional dir-flag suffix
Эта функция похожа на @code{make-temp-file}, но создает временный файл,
максимально приближенный к @code{default-directory}.  Если @var{prefix} -
относительное имя файла, а @code{default-directory} - имя удаленного файла
или находится в смонтированных файловых системах, временный файл создается в
каталоге, возвращаемом функцией @code{temporary-file-directory}.  В
противном случае используется функция @code{make-temp-file}.  @var{prefix},
@var{dir-flag} и @var{suffix} имеет то же значение, что и
@code{make-temp-file}.

@example
@group
(let ((default-directory "/ssh:remotehost:"))
  (make-nearby-temp-file "foo"))
     @result{} "/ssh:remotehost:/tmp/foo232J6v"
@end group
@end example
@end defun

@defun temporary-file-directory
Каталог для записи временных файлов через @code{make-nearby-temp-file}.  В
случае удаленного @code{default-directory} это каталог для временных файлов
на этом удаленном хосте.  Если такой каталог не существует или
@code{default-directory} должен находиться в смонтированной файловой системе
(смотреть @code{mounted-file-systems}), функция возвращает
@code{default-directory}.  Для не удаленного и не смонтированного
@code{default-directory} возвращается значение переменной
@code{temporary-file-directory}.
@end defun

Чтобы извлечь локальную часть имени временного файла, использовать
@code{file-local-name} (@pxref{Magic File Names}).

@node File Name Completion
@subsection Завершение Имени Файла
@cindex file name completion subroutines
@cindex completion, file name

  В этом разделе описаны низкоуровневые подпрограммы для завершения имени
файла.  Для функций более высокого уровня смотреть @ref{Reading File Names}.

@defun file-name-all-completions partial-filename directory
Функция возвращает список всех возможных завершений для файла, имя которого
начинается с @var{partial-filename} в каталоге @var{directory}.  Порядок
завершения - это порядок файлов в каталоге, который непредсказуем и не несет
никакой полезной информации.

Аргумент @var{partial-filename} должен быть именем файла, не содержащим
части каталога и косой черты (или обратной косой черты в некоторых
системах).  Каталог по умолчанию текущего буфера добавляется к
@var{directory}, если @var{directory} не является абсолютным.

В следующем примере предположим, что @file{~rms/lewis} является текущим
каталогом по умолчанию и имеет пять файлов, имена которых начинаются с
@samp{f}: @file{foo}, @file{file~}, @file{file.c}, @file{file.c.~1~} и
@file{file.c.~2~}.

@example
@group
(file-name-all-completions "f" "")
     @result{} ("foo" "file~" "file.c.~2~"
                "file.c.~1~" "file.c")
@end group

@group
(file-name-all-completions "fo" "")
     @result{} ("foo")
@end group
@end example
@end defun

@defun file-name-completion filename directory &optional predicate
Функция завершает имя файла @var{filename} в каталоге @var{directory}.  Она
возвращает самый длинный префикс, общий для всех имен файлов в каталоге
@var{directory}, которые начинаются с @var{filename}.  Если @var{predicate}
- не-@code{nil}, то он игнорирует возможные завершения, которые не
удовлетворяют @var{predicate}, после вызова этой функции с одним аргументом,
расширенным абсолютным именем файла.

Если существует только одно совпадение и @var{filename} ему точно
соответствует, функция возвращает @code{t}.  Функция возвращает @code{nil},
если в каталоге @var{directory} нет имени, начинающегося с @var{filename}.

В следующем примере предпологается, что в текущем каталоге по умолчанию есть
пять файлов, имена которых начинаются с @samp{f}: @file{foo},
@file{file~}, @file{file.c}, @file{file.c.~1~} и @file{file.c.~2~}.

@example
@group
(file-name-completion "fi" "")
     @result{} "file"
@end group

@group
(file-name-completion "file.c.~1" "")
     @result{} "file.c.~1~"
@end group

@group
(file-name-completion "file.c.~1~" "")
     @result{} t
@end group

@group
(file-name-completion "file.c.~3" "")
     @result{} nil
@end group
@end example
@end defun

@defopt completion-ignored-extensions
@code{file-name-completion} обычно игнорирует имена файлов, которые
заканчиваются любой строкой в этом списке.  Не игнорируются все возможные
варианты завершения заканчивающиеся одним из этих суффиксов.  Эта переменная
не влияет на @code{file-name-all-completions}.

Типичное значение может выглядеть так:

@example
@group
completion-ignored-extensions
     @result{} (".o" ".elc" "~" ".dvi")
@end group
@end example

Если элемент @code{completion-ignored-extensions} заканчивается косой чертой
@samp{/}, сигнализируется о каталоге.  Элементы, заканчивающиеся @emph{не}
косой чертой, никогда не будут соответствовать каталогу; таким образом,
указанное выше значение не будет отфильтровывать каталог с именем
@file{foo.elc}.
@end defopt

@node Standard File Names
@subsection Стандартные Имена Файлов

  Иногда программе Emacs Lisp необходимо указать стандартное имя файла для
конкретного использования - обычно для хранения данных конфигурации,
заданных текущим пользователем.  Обычно такие файлы должны находиться в
каталоге, заданном параметром @code{user-emacs-directory}, которым по
умолчанию является @file{~/.emacs.d} (@pxref{Init File}).  Например,
определения сокращений по умолчанию хранятся в
@file{~/.emacs.d/abbrev_defs}.  Самый простой способ указать такое имя
файла - использовать функцию @code{locate-user-emacs-file}.

@defun locate-user-emacs-file base-name &optional old-name
Функция возвращает абсолютное имя файла для специфичной для Emacs
конфигурации или файла данных.  Аргумент @file{base-name} должен быть
относительным именем файла.  Возвращаемое значение - абсолютное имя файла в
каталоге, указанном @code{user-emacs-directory}; если этот каталог не
существует, эта функция создает его.

Если необязательный аргумент @var{old-name} - не-@code{nil}, указывается
файл в домашнем каталоге пользователя, @file{~/@var{old-name}}.  Если такой
файл существует, возвращаемое значение - это абсолютное имя этого файла, а
не файла, указанного в @var{base-name}.  Этот аргумент предназначен для
использования пакетами Emacs для обеспечения обратной совместимости.
Например, до введения @code{user-emacs-directory} файл сокращений
располагался в @file{~/.abbrev_defs}.  Вот определение
@code{abbrev-file-name}:

@example
(defcustom abbrev-file-name
  (locate-user-emacs-file "abbrev_defs" ".abbrev_defs")
  "Имя файла по умолчанию, из которого следует читать сокращения."
  @dots{}
  :type 'file)
@end example
@end defun

  Функция нижнего уровня для стандартизации имен файлов, которую
@code{locate-user-emacs-file} использует в качестве подпрограммы, -
@code{convert-standard-filename}.

@defun convert-standard-filename filename
Эта функция возвращает имя файла на основе @var{filename}, что соответствует
соглашениям текущей операционной системы.

В GNU и других системах, подобных POSIX, это просто возвращает
@var{filename}.  В других операционных системах могут применятся системные
соглашения об именах файлов; например, в MS-DOS эта функция выполняет
множество изменений, чтобы обеспечить соблюдение ограничений имени файла
MS-DOS, включая преобразование любых ведущих @samp{.} в @samp{_} и
усечение до трех символов после @samp{.}.

Рекомендуемый способ использования этой функции - указать имя, которое
соответствует соглашениям систем GNU и Unix, и передать его в
@code{convert-standard-filename}.
@end defun

@node Contents of Directories
@section Контекст Директорий
@cindex directory-oriented functions
@cindex file names in directory

  Каталог - это своего рода файл, содержащий другие файлы, введенные под
различными именами.  Каталоги - это особенность файловой системы.

  Emacs может перечислить имена файлов в каталоге в виде списка Lisp или
отобразить имена в буфере с помощью команды оболочки @code{ls}.  В последнем
случае может дополнительно отображать информацию о каждом файле, в
зависимости от параметров, переданных команде @code{ls}.

@defun directory-files directory &optional full-name match-regexp nosort
Функция возвращает список имен файлов в каталоге @var{directory}.  По
умолчанию список находится в алфавитном порядке.

Если @var{full-name} равен не-@code{nil}, функция возвращает абсолютные
имена файлов.  В противном случае возвращает имена относительно указанного
каталога.

Если @var{match-regexp} равен не-@code{nil}, эта функция возвращает только
те имена файлов, которые содержат совпадение с этим регулярным выражением -
другие имена файлов исключаются из списка. В файловых системах без учета
регистра при сопоставлении регулярных выражений регистр не учитывается.

@c Emacs 19 feature
Если @var{nosort} равен не-@code{nil}, @code{directory-files}, список не
сортируется, поэтому получаются имена файлов в произвольном порядке.
Использовать это, если нужна максимально возможная скорость и все равно, в
каком порядке обрабатываются файлы.  Если порядок обработки виден
пользователю, то он, вероятно, будет более доволен, если все-таки имена
отсортируются.

@example
@group
(directory-files "~lewis")
     @result{} ("#foo#" "#foo.el#" "." ".."
         "dired-mods.el" "files.texi"
         "files.texi.~1~")
@end group
@end example

Об ошибке сигнализируется, если @var{directory} не является именем каталога,
который можно прочитать.
@end defun

@defun directory-files-recursively directory regexp &optional include-directories
Вернуть все файлы директории @var{directory}, имена которых совпадают с
@var{regexp}.  Функция рекурсивно ищет в указанной директории
@var{directory} и её подкаталогах файлы, чьи базовые имена (тоесть есть
без ведущих каталогов) совпадают с указанным @var{regexp}, и возвращает
список абсолютных имен файлов соответствующих файлов
(@pxref{Relative File Names, абсолютные имена файла}).  Имена файлов
возвращаются в порядке глубины, что означает, что файлы в некотором
подкаталоге возвращаются раньше файлов в его родительском каталоге.  Кроме
того, соответствующие файлы, найденные в каждом подкаталоге, сортируются в
алфавитном порядке по их базовым именам.  По умолчанию каталоги, имена
которых совпадают с @var{regexp}, исключаются из списка, но если
необязательный аргумент @var{include-directories} равен не-@code{nil}, они
включаются.
@end defun

@defun directory-files-and-attributes directory &optional full-name match-regexp nosort id-format
Это похоже на @code{directory-files} при принятии решения о том, о каких
файлах сообщать и как сообщать их имена.  Однако вместо того, чтобы
возвращать список имен файлов, возвращает для каждого файла список
@code{(@var{filename} @var{attributes})}, где @var{attributes} - это то, что
@code{file-attributes} возвращает для этого файла.  Необязательный аргумент
@var{id-format} имеет то же значение, что и соответствующий аргумент
@code{file-attributes} (@pxref{Definition of file-attributes}).
@end defun

@defun file-expand-wildcards pattern &optional full
Функция расширяет подстановочный знак @var{pattern}, возвращая список имен
файлов, которые ему соответствуют.

Если @var{pattern} записано как абсолютное имя файла, значения также
являются абсолютными.

Если @var{pattern} записано как относительное имя файла, оно
интерпретируется относительно текущего каталога по умолчанию.  Возвращаемые
имена файлов обычно также относятся к текущему каталогу по умолчанию.
Однако, если @var{full} равен не-@code{nil}, они абсолютны.
@end defun

@defun insert-directory file switches &optional wildcard full-directory-p
Функция вставляет (в текущий буфер) список каталогов для каталога
@var{file}, отформатированный как @code{ls} в соответствии с @var{switches}.
Она оставляет точку после вставленного текста.  @var{switches} может быть
строкой параметров или списком строк, представляющих отдельные параметры.

Аргумент @var{file} может быть каталогом или спецификацией файла, включая
подстановочные знаки.  Если @var{wildcard} равен не-@code{nil}, это
означает, что @var{file} следует рассматривать как спецификацию файла с
подстановочными знаками.

Если @var{full-directory-p} - не-@code{nil}, это означает, что в списке
каталогов должно отображаться полное содержимое каталога.  Потребуется
указать @code{t}, когда @var{file} - это каталог, а параметры не содержат
@samp{-d}.  (Параметр @samp{-d} для @code{ls} указывает описать сам каталог
как файл, а не отображать его содержимое.)

В большинстве систем эта функция работает путем запуска программы для вывода
списка каталогов, имя которой находится в переменной
@code{insert-directory-program}.  Если @var{wildcard} равно не-@code{nil},
она также запускает оболочку, указанную @code{shell-file-name}, для
расширения подстановочных знаков.

В системах MS-DOS и MS-Windows обычно отсутствует стандартная программа Unix
@code{ls}, поэтому эта функция имитирует стандартную программу Unix
@code{ls} с кодом Lisp.

Техническая деталь: когда @var{switches} содержит длинную опцию
@samp{--dired}, @code{insert-directory} обрабатывает ее специально, ради
dired.  Однако обычно эквивалентный короткий вариант @samp{-D} просто
передается в @code{insert-directory-program}, как и любой другой параметр.
@end defun

@defvar insert-directory-program
Значение этой переменной - это программа, которую нужно запустить для
создания списка каталогов для функции @code{insert-directory}.  Она
игнорируется в системах, которые генерируют листинг с кодом Lisp.
@end defvar

@node Create/Delete Dirs
@section Создание, Копирование и Удаление Каталогов
@cindex creating, copying and deleting directories
@c Emacs 19 features

  Большинство функций Emacs Lisp для работы с файлами выдают ошибки при
использовании с файлами, которые являются каталогами.  Например, не выйдет
удалить каталог с @code{delete-file}.  Эти специальные функции существуют
для создания и удаления каталогов.

@findex mkdir
@deffn Command make-directory dirname &optional parents
Команда создает каталог с именем @var{dirname}.  Если @var{parents} равен
не-@code{nil}, как это всегда бывает при интерактивном вызове, это означает,
что сначала нужно создать родительские каталоги, если они еще не существуют.

@code{mkdir} это псевдоним для этого.
@end deffn

@deffn Command copy-directory dirname newname &optional keep-time parents copy-contents
Команда копирует каталог с именем @var{dirname} в @var{newname}.  Если
@var{newname} - это имя каталога, @var{dirname} будет скопирован в
подкаталог там.  @xref{Directory Names}.

Всегда устанавливает режимы копируемых файлов, соответствующие
соответствующему исходному файлу.

Третий аргумент @var{keep-time} не-@code{nil} означает сохранение времени
модификации копируемых файлов.  Префикс arg делает @var{keep-time}
не-@code{nil}.

Четвертый аргумент @var{parents} говорит, создавать ли родительские
каталоги, если они не существуют.  В интерактивном режиме это происходит по
умолчанию.

Пятый аргумент @var{copy-contents}, если не-@code{nil}, означает копирование
содержимого @var{dirname} непосредственно в @var{newname}, если последнее
является именем каталога, вместо копирования @var{dirname} в него как
подкаталог.
@end deffn

@cindex trash
@vindex delete-by-moving-to-trash
@deffn Command delete-directory dirname &optional recursive trash
Команда удаляет каталог с именем @var{dirname}.  Функция @code{delete-file}
не работает для файлов, которые являются каталогами; потребуется
использовать для них @code{delete-directory}.  Если @var{recursive} равен
@code{nil}, а каталог содержит какие-либо файлы, @code{delete-directory}
сигнализирует об ошибке.  Если рекурсивным является не-@code{nil}, ошибки не
возникает просто потому, что каталог или его файлы удаляются каким-то другим
процессом до того, как @code{delete-directory} попадает в них.

@code{delete-directory} следует только по символическим ссылкам на уровне
родительских каталогов.

Если необязательный аргумент @var{trash} - не-@code{nil}, а переменная
@code{delete-by-moving-to-trash} - не-@code{nil}, эта команда перемещает
файл в системную корзину, а не удаляет его.
@xref{Misc File Ops,,Miscellaneous File Operations, emacs, The GNU Emacs Manual}.  При интерактивном вызове @var{trash} становится @code{t}, если
аргумент префикса не задан, и @code{nil} в противном случае.
@end deffn

@node Magic File Names
@section Создание Определенных ``Магических'' Имен Файлов 
@cindex magic file names

  Можно реализовать специальную обработку для определенных имен файлов.  Это
называется преобразованием этих имен в @dfn{магические}.  Основное
использование этой функции - реализация доступа к удаленным файлам.
(@pxref{Remote Files,,Удалённые Файлы, emacs, GNU Emacs Руководство}).

  Чтобы определить вид магического имени файла, потребуется предоставить
регулярное выражение для определения класса имен (всех тех, которые
соответствуют регулярному выражению), а также обработчик, который реализует
все примитивные файловые операции Emacs для имен файлов, которые совпадают.

@cindex file handler
@vindex file-name-handler-alist
  Переменная @code{file-name-handler-alist} содержит список обработчиков
вместе с регулярными выражениями, которые определяют, когда применять каждый
обработчик.  Каждый элемент имеет такую форму:

@example
(@var{regexp} . @var{handler})
@end example

@noindent
Все примитивы Emacs для доступа к файлам и преобразования имени файла
проверяют данное имя файла на соответствие @code{file-name-handler-alist}.
Если имя файла совпадает с @var{regexp}, примитивы обрабатывают этот файл,
вызывая @var{handler}.

  Первый аргумент, передаваемый @var{handler}, - это имя примитива в виде
символа; остальные аргументы - это аргументы, переданные этому примитиву.
(Первым из этих аргументов чаще всего является само имя файла.)  Например,
если сделать это:

@example
(file-exists-p @var{filename})
@end example

@noindent
а @var{filename} имеет обработчик @var{handler}, тогда @var{handler}
вызывается так:

@example
(funcall @var{handler} 'file-exists-p @var{filename})
@end example

  Когда функция принимает два или более аргумента, которые должны быть
именами файлов, она проверяет каждое из этих имен на предмет наличия
обработчика.  Например, если сделать это:

@example
(expand-file-name @var{filename} @var{dirname})
@end example

@noindent
затем она проверяет обработчик для @var{filename}, а затем для обработчика
@var{dirname}.  В любом случае @var{handler} вызывается так:

@example
(funcall @var{handler} 'expand-file-name @var{filename} @var{dirname})
@end example

@noindent
Затем @var{handler} должен решить, обрабатывать @var{filename} или
@var{dirname}.

  Если указанное имя файла соответствует более чем одному обработчику,
приоритет получает тот, чье совпадение начинается последним в имени файла.
Это правило выбрано таким образом, чтобы сначала обрабатывались обработчики
таких заданий, как распаковка, а не обработчики заданий, таких как удаленный
доступ к файлам.

  Вот операции, которые должен обрабатывать обработчик магического имени
файла:

@ifnottex
@noindent
@code{access-file}, @code{add-name-to-file},
@code{byte-compiler-base-file-name},@*
@code{copy-directory}, @code{copy-file},
@code{delete-directory}, @code{delete-file},
@code{diff-latest-backup-file},
@code{directory-file-name},
@code{directory-files},
@code{directory-files-and-attributes},
@code{dired-compress-file}, @code{dired-uncache},@*
@code{expand-file-name},
@code{file-accessible-directory-p},
@code{file-acl},
@code{file-attributes},
@code{file-directory-p},
@code{file-equal-p},
@code{file-executable-p}, @code{file-exists-p},
@code{file-in-directory-p},
@code{file-local-copy},
@code{file-modes}, @code{file-name-all-completions},
@code{file-name-as-directory},
@code{file-name-case-insensitive-p},
@code{file-name-completion},
@code{file-name-directory},
@code{file-name-nondirectory},
@code{file-name-sans-versions}, @code{file-newer-than-file-p},
@code{file-notify-add-watch}, @code{file-notify-rm-watch},
@code{file-notify-valid-p},
@code{file-ownership-preserved-p},
@code{file-readable-p}, @code{file-regular-p},
@code{file-remote-p}, @code{file-selinux-context},
@code{file-symlink-p}, @code{file-truename}, @code{file-writable-p},
@code{find-backup-file-name},@*
@code{get-file-buffer},
@code{insert-directory},
@code{insert-file-contents},@*
@code{load},
@code{make-auto-save-file-name},
@code{make-directory},
@code{make-directory-internal},
@code{make-nearby-temp-file},
@code{make-symbolic-link},@*
@code{process-file},
@code{rename-file}, @code{set-file-acl}, @code{set-file-modes},
@code{set-file-selinux-context}, @code{set-file-times},
@code{set-visited-file-modtime}, @code{shell-command},
@code{start-file-process},
@code{substitute-in-file-name},@*
@code{temporary-file-directory},
@code{unhandled-file-name-directory},
@code{vc-registered},
@code{verify-visited-file-modtime},@*
@code{write-region}.
@end ifnottex
@iftex
@noindent
@flushleft
@code{access-file}, @code{add-name-to-file},
@code{byte-com@discretionary{}{}{}piler-base-file-name},
@code{copy-directory}, @code{copy-file},
@code{delete-directory}, @code{delete-file},
@code{diff-latest-backup-file},
@code{directory-file-name},
@code{directory-files},
@code{directory-files-and-at@discretionary{}{}{}tributes},
@code{dired-compress-file}, @code{dired-uncache},
@code{expand-file-name},
@code{file-accessible-direc@discretionary{}{}{}tory-p},
@code{file-acl},
@code{file-attributes},
@code{file-direc@discretionary{}{}{}tory-p},
@code{file-equal-p},
@code{file-executable-p}, @code{file-exists-p},
@code{file-in-directory-p},
@code{file-local-copy},
@code{file-modes}, @code{file-name-all-completions},
@code{file-name-as-directory},
@code{file-name-case-insensitive-p},
@code{file-name-completion},
@code{file-name-directory},
@code{file-name-nondirec@discretionary{}{}{}tory},
@code{file-name-sans-versions}, @code{file-newer-than-file-p},
@code{file-notify-add-watch}, @code{file-notify-rm-watch},
@code{file-notify-valid-p},
@code{file-ownership-pre@discretionary{}{}{}served-p},
@code{file-readable-p}, @code{file-regular-p},
@code{file-remote-p}, @code{file-selinux-context},
@code{file-symlink-p}, @code{file-truename}, @code{file-writable-p},
@code{find-backup-file-name},
@code{get-file-buffer},
@code{insert-directory},
@code{insert-file-contents},
@code{load},
@code{make-auto-save-file-name},
@code{make-direc@discretionary{}{}{}tory},
@code{make-direc@discretionary{}{}{}tory-internal},
@code{make-symbolic-link},
@code{process-file},
@code{rename-file}, @code{set-file-acl}, @code{set-file-modes},
@code{set-file-selinux-context}, @code{set-file-times},
@code{set-visited-file-modtime}, @code{shell-command},
@code{start-file-process},
@code{substitute-in-file-name},
@code{unhandled-file-name-directory},
@code{vc-regis@discretionary{}{}{}tered},
@code{verify-visited-file-modtime},
@code{write-region}.
@end flushleft
@end iftex

  Обработчики для @code{insert-file-contents} обычно должны сбрасывать
модифицированный флаг буфера с помощью @code{(set-buffer-modified-p nil)},
если аргумент @var{visit} - не-@code{nil}.  Это также имеет эффект
разблокировки буфера, если он заблокирован.

  Функция-обработчик должна обрабатывать все перечисленные выше операции и,
возможно, другие, которые будут добавлены в будущем.  Ей не нужно
реализовывать все эти операции самостоятельно - когда ей нечего делать для
определенной операции, она может повторно вызвать примитив, чтобы обработать
операцию обычным способом.  Всегда должна повторно вызывать примитив для
операции, которую не распознает.  Вот один из способов сделать это:

@smallexample
(defun my-file-handler (operation &rest args)
  ;; @r{Сначала проверяется конкретная операция,}
  ;; @r{для которой у есть специальная обработка.}
  (cond ((eq operation 'insert-file-contents) @dots{})
        ((eq operation 'write-region) @dots{})
        @dots{}
        ;; @r{Выполняется любая операцию, о которой не известно.}
        (t (let ((inhibit-file-name-handlers
                  (cons 'my-file-handler
                        (and (eq inhibit-file-name-operation operation)
                             inhibit-file-name-handlers)))
                 (inhibit-file-name-operation operation))
             (apply operation args)))))
@end smallexample

  Когда функция-обработчик решает вызвать обычный примитив Emacs для данной
операции, ей необходимо предотвратить повторный вызов этого же обработчика
примитивом, что приведет к бесконечной рекурсии.  В приведенном выше примере
показано, как это сделать с переменными @code{inhibit-file-name-handlers} и
@code{inhibit-file-name-operation}.  Быть осторожным, используя их точно
так, как показано выше; детали имеют решающее значение для правильного
поведения в случае нескольких обработчиков и для операций с двумя именами
файлов, каждый из которых может иметь обработчики.

@kindex safe-magic @r{(property)}
  Обработчики, которые на самом деле не делают ничего особенного для
фактического доступа к файлу - например, те, которые реализуют завершение
имен хостов для имен удаленных файлов - должны иметь свойство не-@code{nil}
@code{safe-magic}.  Например, Emacs обычно защищает имена каталогов, которые
он находит в @code{PATH}, от превращения в магические, если они выглядят как
магические имена файлов, с помощью префикса @samp{/:}.  Но если обработчик,
который будет использоваться для них, имеет свойство не-@code{nil}
@code{safe-magic}, @samp{/:} не добавляется.

@kindex operations @r{(property)}
  Обработчик имени файла может иметь свойство @code{operations}, чтобы
объявлять, какие операции обрабатывает нетривиальным способом.  Если это
свойство имеет значение не-@code{nil}, это должен быть список операций;
тогда только эти операции вызовут обработчик.  Это позволяет избежать
неэффективности, но его основная цель - для функций-обработчиков с
автозагрузкой, так что они не будут загружаться, кроме случаев, когда у них
есть реальная работа.

  Просто перенести все операции на обычные примитивы не получится.
Например, если обработчик имени файла применяется к @code{file-exists-p}, он
должен обрабатывать сам @code{load}, потому что обычный код @code{load} в
этом случае не будет работать должным образом.  Однако, если обработчик
использует свойство @code{operations}, чтобы сказать, что он не обрабатывает
@code{file-exists-p}, ему нет необходимости обрабатывать @code{load}
нетривиально.

@defvar inhibit-file-name-handlers
Эта переменная содержит список обработчиков, использование которых в
настоящее время запрещено для определенной операции.
@end defvar

@defvar inhibit-file-name-operation
Операция, для которой в настоящее время запрещены определенные обработчики.
@end defvar

@defun find-file-name-handler file operation
Функция возвращает функцию-обработчик для файла с именем @var{file} или
@code{nil}, если его нет.  Аргумент @var{operation} должен быть операцией,
выполняемой с файлом - значением, которое передаётся обработчику в качестве
первого аргумента при его вызове.  Если @var{operation} равно
@code{inhibit-file-name-operation}, или если не найден в свойстве
@code{operations} обработчика, эта функция возвращает @code{nil}.
@end defun

@defun file-local-copy filename
Функция копирует файл @var{filename} в обычный немагический файл на
локальной машине, если он еще не находится на локальной машине.  Магические
имена файлов должны обрабатывать операцию @code{file-local-copy}, если они
относятся к файлам на других машинах.  Магическое имя файла, которое
используется для других целей, кроме удаленного доступа к файлу, не должно
обрабатывать @code{file-local-copy}; тогда эта функция будет рассматривать
файл как локальный.

Если @var{filename} является локальным, магическим или нет, эта функция
ничего не делает и возвращает @code{nil}.  В противном случае она возвращает
имя файла локальной копии.
@end defun

@defun file-remote-p filename &optional identification connected
Функция проверяет, является ли @var{filename} удаленным файлом.  Если
@var{filename} является локальным (не удаленным), возвращаемое значение -
@code{nil}.  Если @var{filename} действительно удаленный, возвращаемое
значение - строка, которая идентифицирует удаленную систему.

Эта строка идентификатора может включать имя хоста и имя пользователя, а так
же символы, обозначающие метод, используемый для доступа к удаленной
системе.  Например, строка удаленного идентификатора для имени файла
@code{/sudo::/some/file} is @code{/sudo:root@@localhost:}.

Если @code{file-remote-p} возвращает один и тот же идентификатор для двух
разных имен файлов, это означает, что они хранятся в одной файловой системе
и могут быть доступны локально по отношению друг к другу.  Это означает,
например, что можно запустить удаленный процесс, обращающийся к обоим файлам
одновременно.  Разработчики обработчиков файлов должны убедиться, что этот
принцип работает.

@var{identification} указывает, какая часть идентификатора должна быть
возвращена в виде строки. @var{identification} может быть символом
@code{method}, @code{user} или @code{host}; любое другое значение
обрабатывается как @code{nil} и означает возврат полной строки
идентификатора.  В приведенном выше примере строка идентификатора удаленного
@code{user} будет иметь вид @code{root}.

Если @var{connected} равен не-@code{nil}, функция возвращает @code{nil},
даже если @var{filename} удалённый, если Emacs не имеет сетевого подключения
к своему хосту.  Это полезно, когда требуется избежать задержки установления
соединений, когда они не существуют.
@end defun

@defun unhandled-file-name-directory filename
Функция возвращает имя каталога, который не является магическим.  Для
немагического @var{filename} она возвращает соответствующее имя каталога
(@pxref{Directory Names}).  Для магического @var{filename} она вызывает
обработчик имени файла, который решает, какое значение вернуть.  Если
@var{filename} недоступен из локального процесса, то обработчик имени файла
должен указать это, вернув @code{nil}.

Это полезно для запуска подпроцесса; у каждого подпроцесса должен быть
немагический каталог, который будет его текущим каталогом, и эта функция -
хороший способ его создать.
@end defun

@cindex local part of remote file name
@defun file-local-name filename
Функция возвращает @dfn{местную часть} для @var{filename}. Это часть имени
файла, которая идентифицирует его на удаленном хосте, и обычно получается
путем удаления из имени удаленного файла частей, которые определяют
удаленный хост и метод доступа к нему.  Например:

@smallexample
(file-local-name "/ssh:@var{user}@@@var{host}:/foo/bar")
     @result{} "/foo/bar"
@end smallexample

Для удаленного @var{filename} эта функция возвращает имя файла, которое
может использоваться непосредственно как аргумент удаленного процесса
(@pxref{Asynchronous Processes} и @pxref{Synchronous Processes}) и как
программа для запуска на удаленном хосте.  Если @var{filename} является
локальным, эта функция возвращает его без изменений.
@end defun

@defopt remote-file-name-inhibit-cache
Атрибуты удаленных файлов можно кэшировать для повышения производительности.
Если они изменяются вне контроля Emacs, кешированные значения становятся
недействительными и должны быть перечитаны.

Если для этой переменной установлено значение @code{nil}, кешированные
значения никогда не истекают.  Использовать этот параметр с осторожностью,
только если есть уверенность, что ничто, кроме Emacs, никогда не изменяет
удаленные файлы.  Если установлено значение @code{t}, кешированные значения
никогда не используются.  Это самое безопасное значение, но оно может
привести к снижению производительности.

Компромисс - установить положительное число.  Это означает, что кешированные
значения используются в течение этого количества секунд с момента
кэширования.  Если удаленный файл проверяется регулярно, может быть хорошей
идеей разрешить привязку этой переменной к значению, меньшему, чем период
времени между последовательными проверками.  Например:

@example
(defun display-time-file-nonempty-p (file)
  (let ((remote-file-name-inhibit-cache
         (- display-time-interval 5)))
    (and (file-exists-p file)
         (< 0 (nth 7 (file-attributes
                       (file-chase-links file)))))))
@end example
@end defopt

@node Format Conversion
@section Преобразование Формата Файла

@cindex file format conversion
@cindex encoding file formats
@cindex decoding file formats
@cindex text properties in files
@cindex saving text properties
  Emacs выполняет несколько шагов для преобразования данных в буфере (текст,
свойства текста и, возможно, другая информация) в представление, подходящее
для сохранения в файл, и обратно.  В этом разделе описаны основные функции,
которые выполняют это @dfn{преобразование формата}, а именно
@code{insert-file-contents} для чтения файла в буфер и @code{write-region}
для записи буфера в файл.

@menu
* Overview: Format Conversion Overview.     @code{insert-file-contents} и @code{write-region}.
* Round-Trip: Format Conversion Round-Trip. Использование @code{format-alist}.
* Piecemeal: Format Conversion Piecemeal.   Указание непарного преобразования.
@end menu

@node Format Conversion Overview
@subsection Обзор
@noindent
The function @code{insert-file-contents}:

@itemize
@item изначально вставляет байты из файла в буфер;
@item декодирует байты в символы по мере необходимости;
@item обрабатывает форматы, определенные записями в @code{format-alist}; и
@item вызывает функции в @code{after-insert-file-functions}.
@end itemize

@noindent
Функция @code{write-region}:

@itemize
@item изначально вызывает функции в @code{write-region-annotate-functions};
@item обрабатывает форматы, определенные записями в @code{format-alist};
@item кодирует символы в байты по мере необходимости; и
@item изменяет файл с байтами.
@end itemize

  Это показывает симметрию операций нижнего уровня; чтение и письмо
обрабатывают вещи в противоположном порядке.  Остальная часть этого раздела
описывает две возможности, окружающие три упомянутые выше переменные, а
также некоторые связанные функции.  @ref{Coding Systems}, для получения
подробной информации о кодировке и декодировании символов.

@node Format Conversion Round-Trip
@subsection Спецификация Туда и Обратно

  Наиболее общее из двух средств управляется переменной @code{format-alist},
списком спецификаций @dfn{формата файла}, которые описывают текстовые
представления, используемые в файлах для данных в буфере Emacs.  Описания
для чтения и записи парные, поэтому называют эту спецификацию
``туда-обратно'' (@pxref{Format Conversion Piecemeal}, для непарной
спецификации).

@defvar format-alist
Этот список содержит одно определение формата для каждого определенного
формата файла.  Каждое определение формата представляет собой список этой
формы:

@example
(@var{name} @var{doc-string} @var{regexp} @var{from-fn} @var{to-fn} @var{modify} @var{mode-fn} @var{preserve})
@end example
@end defvar

@cindex format definition
@noindent
Вот что означают элементы в определении формата:

@table @var
@item name
Название этого формата.

@item doc-string
Строка документации для формата.

@item regexp
Регулярное выражение, которое используется для распознавания файлов,
представленных в этом формате.  Если @code{nil}, формат никогда не
применяется автоматически.

@item from-fn
Команда или функция оболочки для декодирования данных в этом формате (для
преобразования данных файла в обычное представление данных Emacs).

Команда оболочки представлена u200bu200bв виде строки; Emacs запускает
команду как фильтр для выполнения преобразования.

Если @var{from-fn} - функция, она вызывается с двумя аргументами,
@var{begin} и @var{end}, которые определяют часть буфера, которую она должна
преобразовать.  Должна преобразовать текст, отредактировав его на месте.
Поскольку это может изменить длину текста, @var{from-fn} должна возвращать
измененную конечную позицию.

Одна из обязанностей @var{from-fn} - убедиться, что начало файла больше не
совпадает с @var{regexp}.  В противном случае, скорее всего, повторный
вызов.  Кроме того, @var{from-fn} не должна включать буферы или файлы,
отличные от декодируемого, иначе внутренний буфер, используемый для
форматирования, может быть перезаписан.

@item to-fn
Команда или функция оболочки для кодирования данных в этом формате - то есть
для преобразования обычного представления данных Emacs в этот формат.

Если @var{to-fn} - строка, это команда оболочки; Emacs запускает команду как
фильтр для выполнения преобразования.

Если @var{to-fn} - функция, она вызывается с тремя аргументами: @var{begin}
и @var{end}, которые указывают часть буфера, которую должна преобразовать, и
@var{buffer}, что указывает, какой буфер.  Есть два способа сделать
преобразование:

@itemize @bullet
@item
Редактируя буфер на месте.  В этом случае @var{to-fn} должна возвращать
конечную позицию диапазона измененного текста.

@item
Вернув список аннотаций.  Это список элементов в форме
@code{(@var{position} . @var{string})}, где @var{position} - целое число,
определяющее относительную позицию в записываемом тексте, а @var{string} -
добавляемая туда аннотация.  Список должен быть отсортирован в порядке
позиции, когда @var{to-fn} возвращает его.

Когда @code{write-region} фактически записывает текст из буфера в файл,
смешивает указанные аннотации в соответствующих позициях.  Все это
происходит без модификации буфера.
@end itemize

@var{to-fn} не должно включать буферы или файлы, отличные от кодируемого, в
противном случае внутренний буфер, используемый для форматирования, может
быть перезаписан.

@item modify
Флаг, @code{t}, если функция кодирования изменяет буфер, и @code{nil}, если
работает, возвращая список аннотаций.

@item mode-fn
Функция второстепенного режима, вызываемая после посещения файла,
преобразованного из этого формата.  Функция вызывается с одним аргументом,
целым числом 1; который сообщает функции второстепенного режима, чтобы
включить режим.

@item preserve
Флаг @code{t}, если @code{format-write-file} не должен удалять этот формат
из @code{buffer-file-format}.
@end table

Функция @code{insert-file-contents} автоматически распознает форматы файлов
при чтении указанного файла.  Проверяет текст начала файла на соответствие
регулярным выражениям определений формата и, если обнаруживает совпадение,
вызывает функцию декодирования для этого формата.  Затем снова проверяет все
известные форматы.  Продолжает проверять их до тех пор, пока ни один из них
не подходит.

При посещении файла с помощью @code{find-file-noselect} или команд, которые
это используют, аналогичным образом выполняется преобразование (потому что
вызывается @code{insert-file-contents}); также вызывается функция режима для
каждого декодируемого формата.  Хранится список имен форматов в локальной
переменной буфера @code{buffer-file-format}.

@defvar buffer-file-format
Переменная определяет формат посещенного файла.  Точнее, это список имён
файловых форматов, которые были декодированы в процессе обращения к файлу
текущего буфера.  Всегда является локальным для всех буферов.
@end defvar

Когда @code{write-region} записывает данные в файл, сначала вызываются
функции кодирования для форматов, перечисленных в @code{buffer-file-format},
в порядке появления в списке.

@deffn Command format-write-file file format &optional confirm
Команда записывает текущее содержимое буфера в файл @var{file} в формате,
основанном на @var{format}, который представляет собой список имен форматов.
Создается фактический формат, начиная с @var{format}, а затем добавляются
любые элементы из значения @code{buffer-file-format} с флагом не-@code{nil}
@var{preserve} (смотреть выше), если они еще не присутствуют в @var{format}.
Затем обновляется @code{buffer-file-format} с этим форматом, делая его по
умолчанию для будущих сохранений.  За исключением аргумента @var{format},
эта команда похожа на @code{write-file}.  В частности, @var{confirm} имеет
то же значение и интерактивную обработку, что и соответствующий аргумент
@code{write-file}.  @xref{Definition of write-file}.
@end deffn

@deffn Command format-find-file file format
Команда находит файл @var{file}, конвертируя его в формат @var{format}.
Также делает @var{format} значением по умолчанию, если буфер будет сохранен
позже.

Аргумент @var{format} - это список имен форматов.  Если @var{format} равен
@code{nil}, преобразование не происходит.  В интерактивном режиме ввод
просто @key{RET} вместо @var{format} указывает @code{nil}.
@end deffn

@deffn Command format-insert-file file format &optional beg end
Команда вставляет содержимое файла @var{file}, конвертируя его в формат
@var{format}.  Если @var{beg} и @var{end} - не-@code{nil}, они указывают,
какую часть файла читать, как в @code{insert-file-contents}
(@pxref{Reading from Files}).

Возвращаемое значение похоже на то, что возвращает
@code{insert-file-contents}: список абсолютного имени файла и длины
вставленных данных (после преобразования).

Аргумент @var{format} - это список имен форматов.  Если @var{format} равен
@code{nil}, преобразование не происходит.  В интерактивном режиме ввод
просто @key{RET} вместо @var{format} указывает @code{nil}.
@end deffn

@defvar buffer-auto-save-file-format
Переменная определяет формат, используемый для автоматического сохранения.
Её значение представляет собой список имен форматов, как и значение
@code{buffer-file-format}; однако используется вместо
@code{buffer-file-format} для записи файлов с автосохранением.  Если
значение равно @code{t}, по умолчанию при автосохранении используется тот же
формат, что и при обычном сохранении в том же буфере.  Эта переменная всегда
является локальной для всех буферов.
@end defvar

@node Format Conversion Piecemeal
@subsection Спецификация по Частям

  В отличие от спецификации двустороннего обмена, описанной в предыдущем
подразделе (@pxref{Format Conversion Round-Trip}), можно использовать
переменные @code{after-insert-file-functions} и
@code{write-region-annotate-functions} для отдельного управления
соответствующими преобразованиями чтения и записи.

  Преобразование начинается с одного представления и дает другое
представление.  Когда нужно выполнить только одно преобразование, не
возникает конфликта, с чего начать.  Однако, когда задействовано несколько
преобразований, может возникнуть конфликт, когда два преобразования должны
начинаться с одних и тех же данных.

  Эту ситуацию лучше всего понять в контексте преобразования свойств текста
во время @code{write-region}.  Например, символ в позиции 42 в буфере - это
@samp{X} с текстовым свойством @code{foo}.  Если преобразование для
@code{foo} выполняется путем вставки в буфер, скажем, @samp{FOO:}, то это
изменяет символ в позиции 42 с @samp{X} на @samp{F}.  Следующее
преобразование сразу начнется с неверными данными.

  Чтобы избежать конфликта, кооперативные преобразования не изменяют буфер,
а вместо этого определяют @dfn{аннотации}, список элементов формы
@code{(@var{position} . @var{string})}, отсортированных в порядке увеличения
@var{position}.

  Если существует более одного преобразования, @code{write-region}
деструктивно объединяет их аннотации в один отсортированный список.  Позже,
когда текст из буфера фактически записывается в файл, смешиваются указанные
аннотации в соответствующих позициях.  Все это происходит без модификации
буфера.

@c ??? Как насчет преобразований "преобладающих", подобных тем, 
@c ??? которые разрешены для 'write-region-annotate-functions', ниже? --ttn

  Напротив, при чтении аннотации, смешанные с текстом, обрабатываются
немедленно.  @code{insert-file-contents} устанавливает точку в начало
некоторого текста, который нужно преобразовать, а затем вызывает функции
преобразования с длиной этого текста.  Эти функции всегда должны
возвращаться с точкой в начале вставленного текста.  Этот подход имеет смысл
для чтения, поскольку аннотации, удаленные первым преобразователем, не могут
быть ошибочно обработаны последующим преобразователем.  Каждая функция
преобразования должна сканировать аннотации, которые она распознает, удалить
аннотацию, изменить текст буфера (например, для установки свойства текста) и
вернуть обновленную длину текста в том виде, в каком она была после этих
изменений.  Значение, возвращаемое одной функцией, становится аргументом для
следующей функции.

@defvar write-region-annotate-functions
Список функций для вызова @code{write-region}.  Каждая функция в списке
вызывается с двумя аргументами: началом и концом записываемой области.  Эти
функции не должны изменять содержимое буфера.  Вместо этого они должны
возвращать аннотации.

В особом случае функция может возвращаться с другим потоком буфера.  Emacs
понимает, что текущий буфер содержит измененный текст для вывода.  Поэтому
изменяет аргументы @var{start} и @var{end} вызова @code{write-region},
присваивая им значения @code{point-min} и @code{point-max} в новом буфере
соответственно.  Также отбрасывает все предыдущие аннотации, потому что они
должны были обрабатываться этой функцией.
@end defvar

@defvar write-region-post-annotation-function
Значение этой переменной, если не-@code{nil}, должно быть функцией.  Эта
функция вызывается без аргументов после завершения @code{write-region}.

Если какая-либо функция в @code{write-region-annotate-functions}
возвращается с другим текущим буфером, Emacs вызывает
@code{write-region-post-annotation-function} более одного раза.  Emacs
вызывает её с последним буфером, который был текущим, и снова с буфером до
этого, и так далее обратно к исходному буферу.

Таким образом, функция в @code{write-region-annotate-functions} может
создать буфер, присвоить этой переменной локальное значение
@code{kill-buffer} в этом буфере, настроить буфер с измененным текстом и
сделать буфер текущим.  Буфер будет уничтожен после завершения
@code{write-region}.
@end defvar

@defvar after-insert-file-functions
Каждая функция в этом списке вызывается @code{insert-file-contents} с одним
аргументом, количеством вставленных символов и точкой в начале вставленного
текста.  Каждая функция должна оставлять точку без изменений и возвращать
новое количество символов, описывающих вставленный текст, измененный
функцией.
@c ??? В строке документации упоминается обработчик из
@c 'file-name-handler-alist' "перехват" 'insert-file-contents'. Hmmm.  --ttn
@end defvar

  Предлагается пользователям писать программы на Lisp для хранения и
извлечения текстовых свойств в файлах, используя эти ловушки, и, таким
образом, экспериментировать с различными форматами данных и находить
подходящие.  В конце концов, есть надежде, что пользователи создадут хорошие
общие расширения, которые можно установить в Emacs.

  Предлагаем не пытаться обрабатывать произвольные объекты Lisp как имена
или значения текстовых свойств --- потому что программу такого общего
назначения, вероятно, сложно написать и она медленная.  Вместо этого
выберается набор возможных типов данных, которые являются достаточно гибкими
и не слишком сложными для кодирования.
