@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-2019 Free Software Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Variables
@chapter Переменные
@cindex variable

  @dfn{Переменная} это имя, используемое в программе, чтобы остаивать
  значение.  В Lisp, каждая переменная представлена ​​символом Lisp
  (@pxref{Symbols}).  Имя переменной - просто имя символа, а значение
  переменной сохраняется в компоненте символа ячейки
  значения@footnote{Чтобы быть точным, в соответствии с правилом
  @dfn{динамического связывания} по умолчанию, в компоненте символа ячейки
  значения всегда установленно текущее значение переменной, но это не так,
  в соответствии с правилом @dfn{лексического связывания}.
  @xref{Variable Scoping}, для деталей.}.  @xref{Symbol Components}.  В Emacs
  Lisp, использование символа в качестве переменной не зависит от
  использования его в качестве имени функции.

 Как уже отмечалось ранее в данном руководстве, программа Lisp представлена
 в основном объектами Lisp, и лишь во вторую очередь как текст.  Текстовая
 форма программы Lisp задается для чтения синтаксиса объектов Lisp, которые
 составляют программу.  Следовательно, текстовая форма переменной в программе
 Lisp записывается с использованием синтаксиса для чтения символа,
 представляющего переменную.

@menu
* Global Variables::            Переменные, значения которых существуют постоянно, везде.
* Constant Variables::          Переменные, значения которых никогда не меняются.
* Local Variables::             Переменные, значения которых существуют временно.
* Void Variables::              Символы, которые не имеют значения.
* Defining Variables::          Определение указывает использование символа в качестве переменной.
* Tips for Defining::           Вещи, о которых требуется думать, когда определяется переменная.
* Accessing Variables::         Проверка значений переменных, имена которых известны только во время выполнения.
* Setting Variables::           Сохранение новых значений в переменных.
* Watching Variables::          Выполнение функции, когда переменная изменяется.
* Variable Scoping::            Как Lisp выбирает среди локальных и глобальных связок.
* Buffer-Local Variables::      Значения переменных действующих только в одном буфере.
* File Local Variables::        Обработка списков локальных переменных файла.
* Directory Local Variables::   Локальные переменные, общие для всех файлов в каталоге.
* Connection Local Variables::  Локальные переменные, общие для удаленных подключений.
* Variable Aliases::            Переменные, которые являются псевдонимами для других переменных.
* Variables with Restricted Values::  Непостоянные переменные, принимающих значения определённого объекта Lisp.
* Generalized Variables::       Расширение концепции переменных.
@end menu

@node Global Variables
@section Глобальные Переменные
@cindex global variable

  Самый простой способ использовать переменную - использовать её
  @dfn{глобально}.  Это означает, что переменная имеет только одно значение
  (по крайней мере на данный момент) по всей системе Lisp.  Значение остается
  в силе до тех пор, пока не задать новое.  Когда новое значение заменяет
  старое, никаких следов старого значения в переменной не остаётся.

  Необходимо указать значение для символа. Используется @code{setq}.
  Например,

@example
(setq x '(a b))
@end example

@noindent
присваивает переменной @code{x} значение @code{(a b)}.  Обратите внимание,
что @code{setq} это специальная форма (@pxref{Special Forms}); она не
оценивает свой первый аргумент, имя переменной, но оценивает второй аргумент,
новое значение.

  После того, как переменная имеет значение, можно обратиться к нему,
  используя сам символ как выражение.  Таким образом,

@example
@group
x @result{} (a b)
@end group
@end example

@noindent
предполлагается, что уже оценена форма @code{setq},  показанная выше.

  Если определить ту же переменную снова, новое значение замещает старое:

@example
@group
x
     @result{} (a b)
@end group
@group
(setq x 4)
     @result{} 4
@end group
@group
x
     @result{} 4
@end group
@end example

@node Constant Variables
@section Переменные, Которые не Меняются
@cindex @code{setting-constant} error
@cindex keyword symbol
@cindex variable with constant value
@cindex constant variables
@cindex symbol that evaluates to itself
@cindex symbol with constant value

  В Emacs Lisp, определенные символы, как правило, оценивают сами себя.  К
  ним относятся @code{nil} и @code{t}, а также любой символ, имя которого
  начинается с @samp{:} (они называются @dfn{keywords}).  Эти символы не
  могут быть переопределены, и нельзя изменить их значения.  Любая попытка
  определить или связать символы @code{nil} или @code{t}, приводит к сигналу
  ошибки @code{setting-constant}.  То же самое верно и для ключевого слова
  (символ, имя которого начинается с @samp{:}), если он интернирован в
  стандартном obarray, за исключением того, что определение такого символа
  само по себе не является ошибкой.  (ВопросVariables117)

@example
@group
nil @equiv{} 'nil
     @result{} nil
@end group
@group
(setq nil 500)
@error{} Попытка определить символ константу: nil
@end group
@end example

@defun keywordp object
Функция возвращает @code{t} если @var{object} символ, имя которого начинается
с @samp{:}, интернированных в стандартном obarray и возвращается @code{nil}
другом случае.
@end defun

Такие константы существенно отличаются от констант, определенных с помощью
специальной формы @code{defconst} (@pxref{Defining Variables}).  Форма
@code{defconst} - средство выделить переменную для программиста, который
может изменить значение переменной, Emacs не вызывает ошибку, если значение
на самом деле будет изменено.

@cindex read-only variables
Небольшое количество дополнительных символов сделаны доступными только для
чтения по различным практическим причинам.  К ним относятся
@code{enable-multibyte-characters}, @code{most-positive-fixnum},
@code{most-negative-fixnum}, и несколько других.  Любая попытка установить
или связать их также сигнализирует об ошибке @code{setting-constant}.

@node Local Variables
@section Локальные Переменные
@cindex binding local variables
@cindex local variables
@cindex local binding
@cindex global binding

  Глобальные переменные имеют значения, которые сохраняются до тех пор, пока
  не будут явно заменены новыми значениями.  Иногда требуется присвоить
  переменной @dfn{локальное значение}---ия, который вступают в силу только в
  пределах определенной части программы Lisp.  Когда переменная имеет
  локальное значение, это определяется как @dfn{локальная привязка} к этому
  значению пременной, и что это @dfn{локальная переменная}.

  Например, когда происходит вызов функции, ее аргументы переменные получают
  локальные значения, которые представляют фактические аргументы, переданные
  в вызов функции; эти локальные привязки вступают в силу в теле функции.
  Возьмем другой пример, специальная форма @code{let} явно устанавливает
  локальные привязки для конкретных переменных, которые вступают в силу
  только в теле самой формы @code{let}.

  Также определение @dfn{глобальная привязка}, подразумевает (концептуально)
  глобальное хранение значения.

@cindex shadowing of variables
  Установка локальной привязки не изменяет предыдущее значение переменной
  (или отсутствие такового).  Рассматривается так, что предыдущее значение
  @dfn{затенено}.  Могут быть затенены как глобальные так и локальные
  значения переменных.  Если действует локальная привязка, с помощью
  @code{setq} присваивается значение в локальной привязке.  Когда эта
  локальная привязка перестаёт действовать, ранее затененное значение
  (или отсутствие таковго) снова вступает в силу.

@cindex current binding
  Переменная может одновременно иметь более одной локальной привязки
  (например, если есть вложенные формы @code{let}, которые связывают
  переменные).  @dfn{Текущая привязка} на самом деле это локальное
  связывание.  @code{setq} определяется значение, возвращаемое посредством
  оценки символа переменной в условиях связывания.

  В большинстве случаев текущая привязка рассматривается как самое внутреннее
  локальное связывание или глобальное связывание, если отсутствует локальное
  связывание.  Более точно, правило называется @dfn{областью видимости}
  и определяет, где в программе локальное связывание вступает в силу.
  Правило области видимости (действует по умолчанию) в Emacs Lisp называется
  @dfn{динамическое связывание}, которое гласит, что текущая привязка
  переменной значения в любой заданной точке выполнения программы является
  самой последней такой созданной привязкой к этой переменной, которая все
  еще существуетвует.  Более подробную информацию о динамической области
  видимости, и альтернативное правило области видимости под названием
  @dfn{лексическое связывание}, @xref{Variable Scoping}.

  Специальные формы @code{let} и @code{let*} существуют для создания
  локальных привязок:

@defspec let (bindings@dots{}) forms@dots{}
Особая форма устанавливает локальные привязки для определенного набора
переменных, как определенно с помощью формы @var{bindings}, а затем оценивает
все @var{forms} в текстовом порядке.  Возвращаемое значение является
значением последней формы в @var{forms}.  Местные привязок созданые с помощью
формы @code{let} будет действовать только в пределах её тела @var{forms}.

Каждая из форм @var{bindings} является либо отдельным символом @w{(i) a}, и
в этом случае символу локально устанавливается значение в @code{nil}; или
список @w{(ii) a} вида @code{(@var{symbol} @var{value-form})}, в этом случае
символ @var{symbol} локально связывается с результатом оценки формы
@var{value-form}.  Если @var{value-form} опущена, используется @code{nil}.

Все формы @var{value-form}ы в @var{bindings} оцениваются в порядке их
появления и @emph{до} связывания с предназначенным для них символом.  Вот
пример этого: @code{z} связан со старым значением @code{y}, которое 2, а не
новое значение @code{y}, которое 1.

@example
@group
(setq y 2)
     @result{} 2
@end group

@group
(let ((y 1)
      (z y))
  (list y z))
     @result{} (1 2)
@end group
@end example

С другой стороны, порядок оценки @emph{bindings} не определен: в следующем
примере, либо 1 или 2 может быть в результате напечатано.

@example
(let ((x 1)
      (x 2))
  (print x))
@end example

Поэтому требуется избегать связывания переменной более одного раза в одной
форме @code{let}.
@end defspec

@defspec let* (bindings@dots{}) forms@dots{}
Специальная форма подобна @code{let}, но связывается каждая переменная сразу
после вычисления её локального значения, перед вычислением локального
значения следующих переменных.  Таким образом, выражение в @var{bindings}
может относиться к предыдущим символам, связанным в этой @code{let*} форме.
Сравните следующий пример с примером @code{let} выше.

@example
@group
(setq y 2)
     @result{} 2
@end group

@group
(let* ((y 1)
       (z y))    ; @r{Действует только что установленное значение @code{y}.}
  (list y z))
     @result{} (1 1)
@end group
@end example
@end defspec

  Вот полный список других средств, которые создают локальные привязки:

@itemize @bullet
@item
Вызов функций (@pxref{Functions}).

@item
Вызов макросов (@pxref{Macros}).

@item
@code{condition-case} (@pxref{Errors}).
@end itemize

  Переменные могут также иметь локальную привязку к буфферу
  (@pxref{Buffer-Local Variables}); некоторые переменные имеют локальную
  привязку к терминалу (@pxref{Multiple Terminals}).  Эти виды привязок
  работают как обычные локальные привязки, но они локализуются в зависимости
  от контекста где находится Emacs.

@defopt max-specpdl-size
@anchor{Definition of max-specpdl-size}
@cindex variable limit error
@cindex evaluation error
@cindex infinite recursion
Переменная определяет допустимый предел на общее количество локальных
привязок и очисток @code{unwind-protect} переменных (смотреть
@ref{Cleanups,,Cleaning Up from Nonlocal Exits}), которые разрешены, прежде
чем Emacs сигнализирует об ошибке (с данными @code{"Глубина связывания
переменной превышает заданное значение max-specpdl-size"}).

Это ограничение, с соответствующей ошибкой при превышении, это один из
способов Lisp избежать зацикливания на нечетко определенной функции.
@code{max-lisp-eval-depth} обеспечивает еще ограничение на глубину
вложенности.  @xref{Definition of max-lisp-eval-depth,, Eval}.

Значение по умолчанию 1300.  При вход в отладчик, Lisp увеличивает значение,
если остаётся мало места для выполнения отладчиком действий.
@end defopt

@node Void Variables
@section Недействительная Переменная
@cindex @code{void-variable} error
@cindex void variable

  Понимается, что переменная недействительна, если компонента символа ячейка
  значения не имеет значения (@pxref{Symbol Components}).

  В соответствии правилу динамического связывания, действующему по умолчанию
  (@pxref{Variable Scoping}), Emacs Lisp хранит текущее значение переменной
  (локальное или глобальное) значением компоненты символа ячейки значения.
  Обратите внимание, что неприсвоенное значение этой ячейки значения
  @emph{не} такое, как установленое в @code{nil}.  Символ @code{nil}
  является объектом Lisp и может быть значением переменной, так же, как
  может быть любой другой объект.  Если переменная недействительна, попытка
  её оценить сигнализирует ошибку @code{void-variable}, вместо того, чтобы
  вернуть её значение.

  Согласно дополнительному правилу лексической области видимости, значение
  ячейки компоненты символа содержит только глобальное значение переменной---
  значение вне любого лексического связывания конструкции.  Когда переменная
  лексически связана, локальное значение определяется лексической средой;
  следовательно, переменные могут иметь локальные значения, даже если
  ячейкам значений компоненты их символов значения неприсвоенны.

@defun makunbound symbol
Функция очищает значение ячейки значения символа @var{symbol}, что делает
переменную пустой.  Возвращается @var{symbol}.

Если @var{symbol} имеет локальное динамическое связывание, @code{makunbound}
аннулирует текущую привязку, и эта пустота длится только до тех пор, пока
действует локальное связывание.  После этого, ранее затененное локальное или
глобальное связывание выходит на первый план и переменная больше не будет
считаться недействительной, если восстановленная привязка существует.

Ниже приведены некоторые примеры (предполагая, что действует динамическое
связывание):

@smallexample
@group
(setq x 1)               ; @r{Помещается значение глобальной привязки.}
     @result{} 1
(let ((x 2))             ; @r{Её локальное связывание.}
  (makunbound 'x)        ; @r{Очистка локального связывания.}
  x)
@error{} Значение символа как переменный является недействительным: x
@end group
@group
x                        ; @r{Глобальное связывание осталось неизменным.}
     @result{} 1

(let ((x 2))             ; @r{Локально её связать.}
  (let ((x 3))           ; @r{И снова связать.}
    (makunbound 'x)      ; @r{Очистка самой внутренней локальной привязки.}
    x))                  ; @r{И прверка: что здесь пусто.}
@error{} Значение символа как переменный является недействительным: x
@end group

@group
(let ((x 2))
  (let ((x 3))
    (makunbound 'x))     ; @r{Очистка внутреннего @code{let} связывания.}
  x)                     ; @r{Теперь оценка внешнего @code{let} связывания.}
     @result{} 2
@end group
@end smallexample
@end defun

@defun boundp variable
Функция возвращает @code{t} если @var{variable} (символ) действительная
переменная и @code{nil}, в обратном случае.

Ниже приведены некоторые примеры (предполагается, что действует динамическое
связывание):

@smallexample
@group
(boundp 'abracadabra)          ; @r{Прверка недействительной переменной.}
     @result{} nil
@end group
@group
(let ((abracadabra 5))         ; @r{Локальная её привязка.}
  (boundp 'abracadabra))
     @result{} t
@end group
@group
(boundp 'abracadabra)          ; @r{Глобально переменная недействительна.}
     @result{} nil
@end group
@group
(setq abracadabra 5)           ; @r{Глобальная привязка.}
     @result{} 5
@end group
@group
(boundp 'abracadabra)
     @result{} t
@end group
@end smallexample
@end defun

@node Defining Variables
@section Определение Глобальных Переменных
@cindex variable definition

  @dfn{Определение переменной} представляет собой конструкцию, которая
  объявляет о намерении использовать символ в качестве глобальной переменной.
  Используются специальные формы @code{defvar} или @code{defconst}, которые
  описаны ниже.

  Определение переменной служит трем целям.  Во-первых, информирует людей,
  которые читают код, что символ @emph{предназначается} для использования
  определенным образом (в качестве переменной).  Во-вторых, информирует
  систему Lisp этого, при необходимости подавая начальное значение и строку
  документации.  В-третьих, предоставляет информацию инструментам
  программирования, таким как @command{etags}, что позволяет найти, где
  была определена переменная.

  Разница между @code{defconst} и @code{defvar} в основном заключена в
  намерениях, служащих для информирования читалей о том, должно ли значение
  когда-либо изменится.  Emacs Lisp фактически не мешает изменять значение
  переменной, определенной с использованием @code{defconst}.  Одно заметное
  различие между этими двумя формами является то, что @code{defconst}
  безоговорочно инициализирует переменную, тогда как @code{defvar}
  инициализирует его только тогда, когда она изначально недействительная.

  Чтобы определить настраиваемую переменную, вы должны использовать
  @code{defcustom} (который вызывает @code{defvar} в качестве подпрограммы).
  @xref{Variable Definitions}.

@defspec defvar symbol [value [doc-string]]
Специальная форма определяет @var{symbol} в качестве переменной.  Обратите
внимание, что @var{symbol} не оценивается; символ, который определяется
должен быть записан в явном виде @code{defvar}.  Переменная помечается как
@dfn{специальная}, а это означает, что должна всегда быть динамически
связаной.  (@pxref{Variable Scoping}).

Если @var{value} указано, и @var{symbol} является недействительным (то есть,
не имеет динамически связанного значения; @pxref{Void Variables}), то
@var{value} оценивается и устанавливается в результате значением компоненты
символа @var{symbol} ячейки значения.  Но если @var{symbol} действительный,
@var{value} не вычисляется, и значение @var{symbol}ов остаётся неизменным.
Если @var{value} опущен, то значение @var{symbol} не изменяется в любом
случае.

Обратите внимание, что определение значения, даже @code{nil}, помечает
переменную в качестве специальной навсегда.  В то время как, если @var{value}
опущено, то переменная помечается специальным локально (т.е. @: в пределах
текущей лексической области видимости, или файла, если находится на верхнем
уровне).  Это может быть полезным для подавления предупреждений байт
компиляции, see @ref{Compiler Errors}.  (ВопросVariables459)

Если @var{symbol} имеет локальную привязку к буферу в текущем буфере,
@code{defvar} устанавливает значение по умолчанию, которое является
буферо-независимое, а не связано с текущим буфером.  Значение устанавливается
по умолчанию, если значение по умолчанию было недействительным.
@xref{Buffer-Local Variables}. (ВопросVariables465)

Если @var{symbol} уже лексически связан (например, если форма @code{defvar}
используется в теле формы @code{let} с включенным лексическим связыванием),
@code{defvar} устанавливает динамическое значение.  Лексическое связывание
остается в силе до его выхода из конструкции связывания.
@xref{Variable Scoping}.

@cindex @code{eval-defun}, and @code{defvar} forms
Когда вы оцениваете форму @code{defvar} верхнего уровня с @kbd{C-M-x} в Emacs
Lisp режиме (@code{eval-defun}), специальная функция @code{eval-defun}
договаривается установить переменную, безусловно, не проверяя, является ли
недействительным его значение.  (ВопросVariables477)

Если указан @var{doc-string} аргумент, он указует строку документации для
переменной (хранится в свойстве @code{variable-documentation} символа).
@xref{Documentation}.

Вот несколько примеров. Эта форма определяет @code{foo}, но не
инициализирует её:

@example
@group
(defvar foo)
     @result{} foo
@end group
@end example

Этот пример инициализирует символ @code{bar} значением @code{23}, и
устанавливает ему строку документации:

@example
@group
(defvar bar 23
  "Нормальное состояние bar.")
     @result{} bar
@end group
@end example

@code{defvar} форма возвращает @var{symbol}, используется на верхнем уровне в
файле, где его значение не имеет значения.

Для более сложного примера использования @code{defvar} без значения,
смотреть @ref{Local defvar example}.
@end defspec

@cindex constant variables
@defspec defconst symbol value [doc-string]
Эта специальная форма определяет @var{symbol} и инициализирует его значеним.
Это информирует человека, читающего код, о том, что @var{symbol} имеет
стандартное глобальное значение, установленное здесь, которые не должно быть
изменены пользователем или другими программами.  Обратите внимание, что
@var{symbol} не оценивается; символ, который должен быть определен явно
печатается в @code{defconst}.  (ВопросVariables518)

@code{defconst} форма, как @code{defvar}, отмечает переменную как
@dfn{специальную}, а это означает, что она всегда должна быть динамически
связанной (@pxref{Variable Scoping}).  Кроме того, отмечается переменная как
рискованная (@pxref{File Local Variables}).

@code{defconst} всегда оценивает @var{value}, и в результате устанавливает значение @var{symbol}.  Если @var{symbol} имеет локальное связывание с буфером
в текущем буфере, @code{defconst} устанавливает значение по умолчанию, а не
буфер локального значения. (Но вы не должны делать буфер локальной привязки
для символа, который определяется с @code{defconst}.) (ВопросVariables528)

Примером использования @code{defconst} является определение Emacs
@code{float-pi}---математической константы @math{pi}, которая не должна быть
изменена кем-либо (не смотря на попытки законодательного органа штата
Индиана).  Однако, как показывает вторая форма, @code{defconst} носит только
рекомендательный характер.

@example
@group
(defconst float-pi 3.141592653589793 "Значение Pi.")
     @result{} float-pi
@end group
@group
(setq float-pi 3)
     @result{} float-pi
@end group
@group
float-pi
     @result{} 3
@end group
@end example
@end defspec

  @strong{Предупреждение:} Если вы используете специальную форму
  @code{defconst} или @code{defvar}, когда переменная имеет локальное
  связывание (сделанную с @code{let} или аргументом функции), это
  устанавливает локальное, а не глобальное связывание.  Это не то, что обычно
  требуется.  Чтобы избежать этого, используйте эти специальные формы на
  верхнем уровне в файле, где обычно не нет локальной привязки, и обязательно
  загрузите файл, прежде чем сделать локальное связывание переменной.

@node Tips for Defining
@section Советы для Надёжного Определения Переменных

  При определении переменной, значением которой является функция или список
  функций, используется имя, которое заканчивается на @samp{-function} или
  @samp{-functions}, соответственно.

  Есть несколько других соглашений именования переменных; вот полный список:

@table @samp
@item @dots{}-hook
Переменная - это обычная ловушка (@pxref{Hooks}).

@item @dots{}-function
Значение является функцией.

@item @dots{}-functions
Значение представляет собой список функций.

@item @dots{}-form
Значение представляет собой форму (выражение).

@item @dots{}-forms
Значение представляет собой список форм (выражения).

@item @dots{}-predicate
Значение предикат---функция одного аргумента, которая возвращает
не-@code{nil} в случае успеха и @code{nil} в другом случае.

@item @dots{}-flag
Значение может принимать значение @code{nil} или нет.  Поскольку такие
переменные часто в конечном итоге приобретают другие значения с течением
времени, эта соглашение настоятельно не рекомендуется. (ВопросVariables592)

@item @dots{}-program
Значение имени программы.

@item @dots{}-command
Значение целая команда оболочки.

@item @dots{}-switches
Значение определяет параметры для команды.

@item @var{prefix}--@dots{}
Переменная предназначена для внутреннего использования и определяется в файле
@file{@var{prefix}.el}.  (Emacs, код, внесенный до 2018 года может следовать
другим соглашениям, которые постепенно сокращаются.)

@item @dots{}-internal
Переменная предназначена для внутреннего использования и определяется в коде
C. (Emacs, код, внесенный до 2018 года может следовать другим соглашениям,
которые постепенно сокращаются.)
@end table

  При определении переменной, всегда учитывается, следует ли пометить её как
  безопасный или опасной; смотреть @ref{File Local Variables}.

  При определении и инициализации переменной, которая содержит сложное
  значение (например, раскладку клавиатуры с привязкой в ней), то лучше
  поместить всё вычисление в @code{defvar}, как здесь:

@example
(defvar my-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map "\C-c\C-a" 'my-command)
    @dots{}
    map)
  @var{docstring})
@end example

@noindent
Этот метод имеет ряд преимуществ.  Во-первых, если пользователь завершает
работу при загрузке файла, переменная предстаёт либо инициализирована
правильно, либо вовсе не инициализирована, а не частично.  Если она ещё
не инициализирована, перезагрузка файла инициализирует её должным образом.
Во-вторых, перезагрузка файл не изменит уже проинициализированную переменную;
что важно, если пользователь запустил ловушки, чтобы изменить часть
содержимого (например, для повторной привязки ключей).  В-третьих, оценка
формы @code{defvar} с @kbd{C-M-x} полностью переинициализирует карту.
(ВопросVariables639)

  Помещение такого колличества кода в @code{defvar} имеет один недостаток:
  помещается строка документации далеко от строки, имени переменной.  Вот
  безопасный способ избежать этого:

@example
(defvar my-mode-map nil
  @var{docstring})
(unless my-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map "\C-c\C-a" 'my-command)
    @dots{}
    (setq my-mode-map map)))
@end example

@noindent
Здесь используются все преимущества помещения инициализации внутри
@code{defvar}, за исключением того, что требуется ввести @kbd{C-M-x} дважды,
один раз на каждой форме, если вы хотите повторно инициализировать
переменную.

@node Accessing Variables
@section Доступ к Значениям Переменных

  Обычный способ ссылки на переменную, записать символ с этим именем.
  @xref{Symbol Forms}.

  Иногда, вы можете ссылаться на переменную, которая определяется только во
  время выполнения.  В этом случае вы не можете указать имя переменной в
  тексте программы.  Вы можете использовать функцию @code{symbol-value} для
  извлечения значения.

@defun symbol-value symbol
Функция возвращает значение, хранящееся в компоненте яцейки значения символа
@var{symbol}.  Здесь хранится текущее значение переменной (динамическое).
Если переменная не имеет локального связывания, это просто её глобальное
значение.  Если переменная является недействительной, сигнализируется ошибка
@code{void-variable}.

Если переменная связана лексически, значение получаемое @code{symbol-value}
не обязательно совпадёт с лексическим значением переменной, которое
определяется лексической средой, а не компонентой ячейки значения символа.
@xref{Variable Scoping}.

@example
@group
(setq abracadabra 5)
     @result{} 5
@end group
@group
(setq foo 9)
     @result{} 9
@end group

@group
;; @r{Здесь символ @code{abracadabra}}
;;   @r{это символ, значение которого проверяется.}
(let ((abracadabra 'foo))
  (symbol-value 'abracadabra))
     @result{} foo
@end group

@group
;; @r{Здесь значение @code{abracadabra},}
;;   @r{устанавливается в @code{foo},}
;;   @r{символ, значение которого проверяется.}
(let ((abracadabra 'foo))
  (symbol-value abracadabra))
     @result{} 9
@end group

@group
(symbol-value 'abracadabra)
     @result{} 5
@end group
@end example
@end defun

@node Setting Variables
@section Установка Значений Переменным

  Обычный способ изменить значение переменной, воспользоватся специальной
  формой @code{setq}.  Когда нужно вычислить переменную во время
  выполнения, используется форма @code{set}.

@defspec setq [symbol form]@dots{}
Особая форма является наиболее распространенным способом изменения значения
переменной.  Каждый @var{symbol} получает новое значение, которое является
результатом оценки соответствующей ему формы @var{form}. Меняется текущее
связывание символа.

@code{setq} не оценивает @var{symbol}; он устанавливает символ, который
напечат.  Уведомляется, что этот аргумент @dfn{цитируется автоматически}.
@samp{q} в @code{setq} означает ``квота (цитата)''.

Значение формы @code{setq} является значение последней оценённой формы
@var{form}.

@example
@group
(setq x (1+ 2))
     @result{} 3
@end group
x                   ; @r{@code{x} теперь имеет глобальное значение.}
     @result{} 3
@group
(let ((x 5))
  (setq x 6)        ; @r{Локальное связывание @code{x}.}
  x)
     @result{} 6
@end group
x                   ; @r{Глобальное значение не изменяется.}
     @result{} 3
@end example

Обратите внимание, что оценивается первая форма @var{form} - устанавливается
первый @var{symbol}, оценивается вторая форма @var{form} - устанавливается
второй @var{symbol}, и так далее:

@example
@group
(setq x 10          ; @r{Обратите внимание, что значение @code{x} устанавливается}
      y (1+ x))     ;   @r{до того как вычисляется значение @code{y}.}
     @result{} 11
@end group
@end example
@end defspec

@defun set symbol value
Функция помещает компоненте символа @var{symbol} в ячейку значения значение
@var{value}.  Так как это функция, а не специальная форма, выражение
написанное для @var{symbol} оценивается, который требуется установить.
Возвращаемое значение @var{value}.

Когда действует правило динамического связывания переменной (по умолчанию),
@code{set} имеет тот же эффект, как и @code{setq}, за исключением того факта,
что @code{set} вычисляет свой аргумент @var{symbol}, тогда как @code{setq}
нет.  Но когда переменная лексически связана, @code{set} влияет на её
@emph{динамическое} значение, в то время как @code{setq} влияет на её текущее
(лексическое) значение.  @xref{Variable Scoping}.  (ВопросVariables779)

@example
@group
(set one 1)
@error{} Значение символа как переменный является недействительным: one
@end group
@group
(set 'one 1)
     @result{} 1
@end group
@group
(set 'two 'one)
     @result{} one
@end group
@group
(set two 2)         ; @r{@code{two} принимает значение символа @code{one}.}
     @result{} 2
@end group
@group
one                 ; @r{@code{one}, который был установлен.}
     @result{} 2
(let ((one 1))      ; @r{@code{one} локальное связываие.}
  (set 'one 3)      ;   @r{устанавливает не глобальное значение.}
  one)
     @result{} 3
@end group
@group
one
     @result{} 2
@end group
@end example

Если @var{symbol} на самом деле не символ, сигнализируется ошибка
@code{wrong-type-argument}  (Неправильный тип аргумента).

@example
(set '(x y) 'z)
@error{} Wrong type argument: symbolp, (x y)
@end example
@end defun

@node Watching Variables
@section Запуск Функции при Изменении Переменной
@cindex variable watchpoints
@cindex watchpoints for Lisp variables

Иногда полезно принимать какое-либо действие, когда переменная изменяет свое
значение.  Объект точки наблюдения предоставляет средства для этого.
Некоторое возможные варианты использования этой функции включает
синхронизацию отображения с параметрами переменной, и вызов отладчика
для отслеживания неожиданных изменений переменной
(@pxref{Variable Debugging}).  (ВопросVariables831)

Следующие функции могут быть использованы для управления функциями наблюдения
для переменной и запросов к ней.

@defun add-variable-watcher symbol watch-function
Функция организует для функции @var{watch-function} вызов всякий раз, когда
@var{symbol} модифицируется.  Изменения с помощью псевдонимов
(@pxref{Variable Aliases}) будут иметь тот же эффект.

@var{watch-function} будет вызываться с 4-мью аргументами:
(@var{symbol} @var{newval} @var{operation} @var{where}).

@var{symbol} - переменная которая изменяется.
@var{newval} - присваимое значение.
@var{operation} - символ, представляющий вид изменения, одно из следующего:
`set', `let', `unlet', `makunbound', и `defvaralias'.
@var{where} - представляет собой буфер, если меняется локальное значение
переменной буфера и @code{nil} в другом случае.
@end defun

@defun remove-variable-watch symbol watch-function
Функция удаляет функцию @var{watch-function} из списка наблюдателей за
@var{symbol}-ами.
@end defun

@defun get-variable-watchers symbol
Функция возвращает список активных функций наблюдателей за @var{symbol}.
@end defun

@subsection Limitations

Есть несколько способов, которыми переменная может быть изменена (или, по
крайней мере, выглядеть изменённой) не заметно для наблюдающих функций.

Так как наблюдение прикрепленно к символам, модификация объектов
содержащихся в переменных (например, с помощью функции
@pxref{Modifying Lists} модификация списков) не отслеживается этим
механизмом.

Кроме того, C код может изменять значения переменных напрямую,
минуя механизм наблюдения.

Незначительное ограничение этой функции, опять же, из-за того, что всё
внимание уделяется символу как переменной динамического диапазона.  Это
не создает особые трудности, поскольку изменения переменных в лексической
области можно легко обнаружить путем проверки кода (в отличие от
динамического связывания переменных, которые могут быть изменены с помощью
любого кода относящегося к ним, @pxref{Variable Scoping}).
(ВопросVariables879)


@node Variable Scoping
@section Правила Области Действия для Привязки Переменной
@cindex scoping rule

  При создании локальной привязки для переменной, связывание действует в
  ограниченной части программы (@pxref{Local Variables}).  Этот раздел
  описывает именно то, что это значит.

@cindex scope
@cindex extent
  Каждое локальное связывание имеет определенную @dfn{кучу} и
  @dfn{сокучность}.  @dfn{Кача} относится к тому @emph{где} в текстовом
  исходном коде, связывание может быть доступно.  @dfn{Сокучность}
  относится к тому @emph{когда} при выполнении программы существует
  связывание.

@cindex dynamic binding
@cindex dynamic scope
@cindex dynamic extent
  По умолчанию локальные привязки, создаваемые Emacs, являются
  @dfn{динамической привязкой}.  Такое связывание имеет
  @dfn{динамическую кучу}, а это означает, что любая часть программы может
  потенциально получить доступ к связыванию переменной.  Также имеется
  @dfn{динамическая протяжённость}, а это означает, что связывание
  длится в то время пока связывающая конструкция (например, тело формы
  @code{let}) выполняется.

@cindex lexical binding
@cindex lexical scope
@cindex indefinite extent
  Emacs может дополнительно создавать @dfn{лексическое связывание}.
  Лексическое связывание имеет @dfn{лексическую кучу}, а это означает, что
  любая ссылка на переменную должна быть расположена в текстуальных пределах
  связывающей конструкции@footnote{За некоторыми исключениями; например,
  лексические связывания можно также получить в отладчике Lisp.}.  Также
  имеется @dfn{неопределённая протяжённость}, а это означает, что при
  некоторых обстоятельствах, связка может существовать даже после завершения
  выполнения связывающей конструкции, с помощью специальных объектов,
  называемых @dfn{замыканием}.

  Следующие подразделы описывают динамическое связывание и лексические
  связывание более подробно, а также то, как включить лексическое связывание
  в программах Emacs Lisp.

@menu
* Dynamic Binding::   Cвязывания локальных переменных в Emacs (по умолчанию).
* Dynamic Binding Tips::    Как избежать проблем с обязательным динамическим
                            связыванием.
* Lexical Binding::         Другой тип локального связывания переменной.
* Using Lexical Binding::   Как включить лексическое связывание.
@end menu

@node Dynamic Binding
@subsection Динамическое Связывание

  По умолчанию Emacs осуществляет динамическое связывание для локальных
  переменных.  Когда переменная динамически связана, его текущее связывание в
  любом момент выполнение программы Lisp -  просто последняя динамическая
  локальная привязка для, или глобальное связывание, если нет такой локальной
  привязки.

  Динамические привязки имеют динамическую кучу и сокучность, как показано
  в следующем примере:

@example
@group
(defvar x -99)  ; @r{@code{x} получает начальное значение @minus{}99.}

(defun getx ()
  x)            ; @r{@code{x} используется свободно в этой функции.}

(let ((x 1))    ; @r{@code{x} динамически связан.}
  (getx))
     @result{} 1

;; @r{После того, как оценена форма @code{let}, @code{x} возвращается к}
;; @r{своему предыдущему значению, которое устанавливается в @minus{}99.}

(getx)
     @result{} -99
@end group
@end example

@noindent
Функция @code{getx} относится к @code{x}.  Это ссылка @dfn{свободна}, в том
смысле, что нет назначений для @code{x} в этой @code{defun} конструкции.
Когда вызывается функция @code{getx} внутри формы, в которой @code{let}
связывает (динамически) @code{x}, извлекается локальное значение
(то есть, 1). Но когда вызывается @code{getx} вне формы @code{let}, получает
глобальное значение @code{x} (то есть, @minus{}99).

  Вот еще один пример, который иллюстрирует установление динамического
  связывание переменной с помощью @code{setq}:

@example
@group
(defvar x -99)      ; @r{@code{x} получает начальное значение @minus{}99.}

(defun addx ()
  (setq x (1+ x)))  ; @r{Добавление к @code{x} 1 и установление нового}
                    ; @r{значения @code{x}.} 

(let ((x 1))
  (addx)
  (addx))
     @result{} 3           ; @r{Два вызова @code{addx} добавят к @code{x}}
                           ; @r{1 дважды.}

;; @r{После того, как оценена форма @code{let}, @code{x} возвращается к}
;; @r{своему предыдущему значению, которое @minus{}99.}

(addx)
     @result{} -98
@end group
@end example

  Динамическое связывание осуществляется в Emacs Lisp простым способом.
  Каждый символ имеет компоненту - ячейку значения, которая определяет его
  текущее динамическое значение (или его отсутствие).
  @xref{Symbol Components}.  Когда символа касается локальное динамическое
  связывание, Emacs записывает содержимое компоненты ячейки значения
  (или его отсутствие) в стек и сохраняет уже новое локальное значение в
  компоненте ячейки значения.  Когда связывающая конструкция заканчивает
  своё влияние (выполнение), Emacs выталкивает старое значение из стека и
  помещает его обратно компоненте символа в ячейку значения.

@node Dynamic Binding Tips
@subsection Правильное Использование Динамического Связывания

  Динамическое связывание является мощным средством, поскольку позволяет
  программам ссылаться на переменные, которые не определены в пределах своей
  локальной текстовой области.  Однако, если используеть это без ограничений,
  это может сделать программы трудными для понимания.  Есть два чистых
  способов использовать эту технику:

@itemize @bullet
@item
Если переменная не имеет глобального определения, используйте её в качестве
локальной переменной только в пределах связывающей конструкции, такой, как
тело формы @code{let}, где переменная была связана.  Если следовать этому
соглашению в течение всей программы, то значение переменной не будет влиять,
и не будут затронуто, любым использованием одного и того же символа
переменной в другом месте в программе.

@item
В противном случае, определите переменную используя @code{defvar},
@code{defconst} (@pxref{Defining Variables}), или @code{defcustom}
(@pxref{Variable Definitions}).  Как правило, это определение должно быть на
высшем уровне в файле Emacs Lisp.  Насколько это возможно, переменная должна
включать в себя строку документации, которая объясняет смысл и назначение
переменной.  Вы должны также выбрать имя переменной, чтобы избежать
конфликтов имен (@pxref{Coding Conventions}).

Затем вы можете связать переменную в любом месте программы, зная достоверно,
какой будет эффект.  Везде, где встречается переменная, будет легко вернуться
к её определению, например, с помощью команды @kbd{C-h v} (при условии, что
определение переменной было загружено в Emacs).
@xref{Name Help,,, emacs, The GNU Emacs Manual}.

Например, обычно используют локальные привязки для настраиваемых переменных,
таких как @code{case-fold-search}:

@example
@group
(defun search-for-abc ()
  "Поиск строки \"abc\", игнорируя регистр букв."
  (let ((case-fold-search t))
    (re-search-forward "abc")))
@end group
@end example
@end itemize

@node Lexical Binding
@subsection Лексическе Связывание

  Лексический связывание был введен в Emacs, в качестве дополнительной
  функции, в версии 24.1.  Ожидается, что его важность возрастает со
  временем.  Лексическое связывание открывает намного больше возможностей для
  оптимизации, так что программы, использующих его, скорее всего, работать
  юудут быстрее в будущих версиях Emacs.  Лексическое связывание также
  является более совместимо с параллелизмом, который был добавлен к Emacs в
  версии 26.1.

  Лексически-связанная переменная имеет @dfn{лексическую кучу}, а это
  означает, что любая ссылка на переменную должна быть расположена в
  текстуальных пределах конструкции связывания. Вот пример
@iftex
(смотрите следующий подраздел о том, как на самом деле включить
лексическое связывание):
@end iftex
@ifnottex
(@pxref{Using Lexical Binding}, о том, как на самом деле включить
лексическое связывание):
@end ifnottex

@example
@group
(let ((x 1))    ; @r{@code{x} лексически связан.}
  (+ x 3))
     @result{} 4

(defun getx ()
  x)            ; @r{@code{x} используется свободно в этой функции.}

(let ((x 1))    ; @r{@code{x} лексически связан.}
  (getx))
@error{} Значение символа как переменный является недействительным: x
@end group
@end example

@noindent
Здесь переменная @code{x} не имеет глобального значения.  Когда эта
переменная лексически связывается в форме @code{let}, она может быть
использован в текстовых пределах этой @code{let} формы.  Но эта переменная
@emph{not} может быть использована в функции @code{getx}, вызываемой из формы
@code{let}, так как определение функции @code{getx} происходит вне этой самой
@code{let} формы.

@cindex lexical environment
  Вот как работает лексическая привязка.  Каждая связывающая конструкция
  определяет @dfn{лексическую среду}, определяя переменным, которые связаны
  внутри этой конструкции и их локальные значения.  Когда оценщику Lisp
  требуется текущее значение переменной, ищется вначале это значение в
  в лексической среде и если значение переменной не указано там, то ищется
  значение в компоненте символа ячейки значения, в которой хранится
  динамически связываемое значение.

  (Внутренне, лексическая среда реализована посредствам ассоциативного
  списка, с парами символ-значение, причём последний элемент этого списка,
  является символом @code{t}, а не cons-ячейкой.  Такой ассоциативный список
  может быть передан в качестве второго аргумента функции @code{eval}, чтобы
  указать лексическую среду, в которой оценивается форма @xref{Eval}.
  Большинство программ Emacs Lisp, не должны взаимодействовать
  непосредственно с лексической средой таким образом;... только
  специализированные программы, такие как отладчики).

@cindex closures, example of using
  Лексическое связывание не имеет сокучности.  Даже после завршения
  выполнения привязки, его лексическая среда может быть ``удержана в поле''
  в Lisp объекте под названием @dfn{замыкание}.  Замыкание создается при
  определении именованной или анонимной функции с включённым лексическим
  связыванием.  @xref{Closures}, для деталей.

  Когда замыкание вызывается как функция, любые ссылки на лексически
  связанные в пределах её определения переменные, используют нераспределенную
  лексическую среду. Вот пример:

@example
(defvar my-ticker nil)   ; @r{Будет использоваться эта динамически связанная}
                         ; @r{переменная для хранения замыкания.}

(let ((x 0))             ; @r{@code{x} лексически связана.}
  (setq my-ticker (lambda ()
                    (setq x (1+ x)))))
    @result{} (closure ((x . 0) t) ()
          (setq x (1+ x)))

(funcall my-ticker)
    @result{} 1

(funcall my-ticker)
    @result{} 2

(funcall my-ticker)
    @result{} 3

x        ; @r{Обратите внимание, что @code{x} не имеет глобального значения.}
@error{} Значение символа как переменной является недействительным: x
@end example

@noindent
@code{let} привязка определяет лексическую среду, в которой переменная
@code{x} локально устанавливается в 0.  В этой конструкции связывания,
определяется лямбда-выражение, которое приращивает начальному значение
@code{x} единицу и возвращает измененное значение.  Это лямбда-выражение
автоматически включается в замыкание, в котором лексическая среда существует
даже после того, как покинута  @code{let} конструкция связывания.  Каждый
раз, когда оценивается замыкание, увеличивается @code{x}, используя
связывание @code{x} в этой лексической среде.

  Следует отметить, что в отличие от динамически связанных переменных,
  которые привязаны к самому объекту символа, отношения между лексически
  связанными переменными и символами присутствуют только в интерпретаторе
  (или компиляторе).  Таким образом, функция, которые принимают символьный
  аргумент (как @code{symbol-value}, @code{boundp}, и @code{set}) может
  только получить или модифицировать динамически связанную переменную (то
  есть содержимое компоненты своего символа ячейки значения).

@node Using Lexical Binding
@subsection Использование Лексического Связывания

  При загрузке файла Emacs Lisp или оценки буфера Lisp, лексическая связь
  включена, если локальная переменная буфера @code{lexical-binding}
  установлена в не-@code{nil}:

@defvar lexical-binding
Если эта локальная переменная буфера учтановлена в не-@code{nil}, Emacs Lisp
оценивает файлы и буферы по правилам лексического связывания вместо
динамического.  (Тем не менее, специальные переменные все еще динамически
связаны; см. Ниже).  Если установлена в @code{nil}, используется динамическое
связывание для всех локальных переменных.  Эта переменная обычно
устанавливается для всего файла Emacs Lisp, как локальная переменная файла.
(@pxref{File Local Variables}).  Обратить внимание, что в отличие от других
таких переменных, она одна должен быть находится в первой строке файла.
@end defvar

@noindent
При оценке кода Emacs Lisp непосредственно с помощью вызова @code{eval},
правило лексического связывания действует, если аргумент @var{lexical}
функции @code{eval} установлен в не-@code{nil}.  @xref{Eval}.

@cindex special variables
  Даже когда лексическая связь действует, некоторые переменные продолжают
  связываться динамически.  Они называются @dfn{специальные переменные}.
  Каждая переменная, которая была определена с использованием @code{defvar},
  @code{defcustom} или @code{defconst} принадлежат к типу специальных
  переменных (@pxref{Defining Variables}).  Все остальные переменные могут
  подвергаться лексическому связыванию.

@anchor{Local defvar example}
Используя @code{defvar} без значения, то можно динамически связать переменную
только в одном файле, или только в одной части файла, при этом использовать
её лексическую привязку в другом месте. Например:

@example
@group
(let (_)
  (defvar x)      ; @r{Let-привязка @code{x} динамическая внутри конструкции}
  (let ((x -99))  ; @r{Это динамичное связывание @code{x}.}
    (defun get-dynamic-x ()
      x)))

(let ((x 'lexical)) ; @r{Это лексическое связывание @code{x}.}
  (defun get-lexical-x ()
    x))

(let (_)
  (defvar x)
  (let ((x 'dynamic))
    (list (get-lexical-x)
          (get-dynamic-x))))
    @result{} (lexical dynamic)
@end group
@end example

@defun special-variable-p symbol
Эта функция возвращает не-@code{nil}, если @var{symbol} содержит специальную
переменную (то есть, значение переменной определенной с использованием
@code{defvar}, @code{defcustom}, или @code{defconst}).  В противном случае,
возвращаемое значение @code{nil}.
@end defun

  Использование специальной переменной в качестве формального аргумента в
  функции не рекомендуется.  Это приводит к возникновению неопределенного
  поведения при включённом правиле лексического связывания (это может
  использовать как лексическое связывание, так и динамическое связывание в
  с неопределённым приоритетом).

  Использование в программе Emacs Lisp лексического связывания легко
  реализуется.  Во-первых, устанавливается значение локальной переменной
  файла @code{lexical-binding} в @code{t} в строке заголовка исходного файла
  Emacs Lisp (@pxref{File Local Variables}).  Во-вторых, проверяется каждая
  переменная в программе, которая должна быть динамически связана, так что
  бы случайно не связать её лексически.

@cindex free variable
@cindex unused lexical variable
  Простой способ выяснить, каким переменным необходимо определение переменной
  - это байт-компиляции исходного файла.  @xref{Byte Compilation}.  Если
  неспециальная переменная используется вне формы @code{let}, байт-компилятор
  будет предупреждать о назначении или ссылки свободной переменной.  Если
  неспециальная переменная связана, но не используется в форме @code{let},
  байт-компилятор будет предупреждать о неиспользованной лексически связанной
  переменной.  Байт-компилятор также выдаст предупреждение, если использовать
  специальную переменную в качестве аргумента функции.

  (Чтобы отключить предупреждения байт-компилятора о неиспользуемых
  переменных, просто нужно использовать имя переменной, которое начинается с
  символа подчеркивания.  Байт-компилятор интерпретирует это как признак
  того, что это будет использоваться неизвестная переменная.)

@node Buffer-Local Variables
@section Локальные Переменные Буфера
@cindex variable, buffer-local
@cindex buffer-local variables

  Глобальные и локальные привязки переменных встречаются в большинстве
  языков программирования в той или иной форме.  Emacs, однако, также
  поддерживает дополнительные, необычные виды связываения переменных, такие
  как @dfn{локальные буферные} привязки, которые применяются только в одном
  буфере.  Имея различные значения для переменной в различных буферах
  является важным методом настройки.  (Переменные могут также иметь привязки,
  которые являются локальными для каждого терминала.
  @xref{Multiple Terminals}.)

@menu
* Intro to Buffer-Local::       Введение и соглашения.
* Creating Buffer-Local::       Создание и уничтожение локальной привязки буфера.
* Default Value::               Значения по умолчанию для буферов не имеющих
                                собственных локальных значений буфера.
@end menu

@node Intro to Buffer-Local
@subsection Введение в Локальные Переменные Буфера

  Локальная переменная буфера имеет локальное связывание с конкретным
  буфером.  Связывание действует, когда этот буфер текущий; в противном
  случае, связывание не действует.  Если вы установите переменную во время
  её локального связывания к буферу, по сути, новое значение заменит значение
  только для этой связки, и другие её связывания не затронутся.  Это
  означает, что изменение видно только в буфере, где вы его сделали.

  Обычная привязка переменной, которая не связывается с каким-либо
  конкретным буфером, называется @dfn{привязкой по умолчанию}.  В
  большинстве случаев это глобальное связывание.

  Переменная может иметь локальную привязку для конкретного буфера,
  действующую только в этом конкретном буфере.  Связывание по умолчанию
  является общим для всех буферов, и вступает в силу, если текущий буфер не
  имеет своего собственного связывания для переменной.  (Это относиться ко
  всем вновь созданным буферам.)  Если вы установите переменную в буфере,
  которая не имеет локального связывания буфера, это устанавливает
  обязательное связывание по умолчанию, так что новое значение видно во всех
  буферах, в которых действует для переменной локальное связование буфера по
  умолчанию.

  Наиболее распространено использование локальной привязки буфера в основных
  режимах для изменения переменных, которые контролируют поведение команд.
  Например, режим С и режим Lisp оба устанавливают переменную
  @code{paragraph-start}, чтобы указать, что только пустые строки служат
  разделением параграфов.  Они делают это посредствам локальной переменной
  буфера, которая содержит признак использования режима С или Lisp,
  устанавливая ей определённое новое значение для каждого из режимов.
  @xref{Major Modes}.

  Обычный способ создать локальное связывание буфера использовать
  @code{make-local-variable}, как правило используемое командами основного
  режима.  Это связывание влияет только на текущий буфер и все другие буферы
  (включая те, которые еще будут созданы), которые будут разделять это
  значение, как значение по умолчанию, если не будут явно определять свои
  собственные локальные привязки буфера для переменной.

@cindex automatically buffer-local
  Более мощная операция, помечается переменная как
  @dfn{автоматическая локальная буфера} использовать средство
  @code{make-variable-buffer-local}.  Можно представить это, как определение
  локальной переменной для всех буферов, но даже тех, которые будут созданы.
  Точнее, эффект состоит в том, что устанавливается автоматическая переменная
  делая эту переменную локальной для текущего буфера, если это ещё не так.
  Все буфера обычно используют значение переменной из привязки по умолчанию,
  но установка переменной таким образом, создаёт локальную привязку для
  текущего буфера.  Новое значение сохраняется в локальном связывания буфера,
  оставляя нетронутым привязку по умолчанию.  Это означает, что значение по
  умолчанию не может быть изменено используя @code{setq} в любом из буферов;
  единственный способ изменить это, использовать @code{setq-default}.

  @strong{Предупреждение:} Когда переменная имеет локальную привязку буфера в
  одном или нескольких буферах, @code{let} добавляет своё связывание, пока
  конструкция в действии.  Например, если текущий буфер имеет локальное
  значение переменной буфера, @code{let} временно добавляет ещё одну привязку
  затеняя это значение.  Если нет локальной привязки переменной буфера,
  @code{let} производит дополнительную привязку, затеняя значение по
  умолчанию.  Если внутри конструкции @code{let} происходит переход в другой
  буфер, делая его текущим, в котором существуют другие привязки, по сути,
  теряется связывание @code{let}.  И если выход из @code{let} происходит при
  использовании другого буфера в качестве текущего, отмена связывания не
  происходит (хотя это будет происходить должным образом). Ниже приведен
  пример для иллюстрации:

@example
@group
(setq foo 'g)
(set-buffer "a")
(make-local-variable 'foo)
@end group
(setq foo 'a)
(let ((foo 'temp))
  ;; foo @result{} 'temp  ; @r{Выполняется связывание в буфере @samp{a} в конструкции @samp{let}}
  (set-buffer "b")
  ;; foo @result{} 'g     ; @r{Получается глобальное значение, так как foo не имеет значение локальной привязки в буфере @samp{b}}
  @var{body}@dots{})
@group
foo @result{} 'g        ; @r{после выхода восстановлено локальное значение
буфера @samp{a},}
                 ; @r{но мы не видим, этого изменений в буфере @samp{b}}
@end group
@group
(set-buffer "a") ; @r{Проверка того, что локальное значение восстановлено}
foo @result{} 'a
@end group
@end example

@noindent
Обратите внимание, что ссылки на @code{foo} в @var{body} доступны локальному
связыванию буфера @samp{b}.  (ВопросVariables1377)

  Когда определяются локальные переменные файла, они становятся локальными
  переменными буфера при посещении этого файла.
  @xref{File Variables,,, emacs, The GNU Emacs Manual}.

  Локальную переменную буфера, нельзя сделать локальной переменной терминала
  (@pxref{Multiple Terminals}).

@node Creating Buffer-Local
@subsection Создание и Удаление Локального Связывания Буфера

@deffn Command make-local-variable variable
Функция создает локальное связывание буфера в текущем буфере для
@var{variable} (символа).  Другие буферы не затрагиваются.  Возвращаемое
значение @var{variable}.

Локальное связывание буфера связывает значение @var{variable} с прежним
значением @var{variable}.  Если @var{variable} была недействительной
переменной, она остаётся также недействительной.

@example
@group
;; @r{В буфере @samp{b1}:}
(setq foo 5)                ; @r{Влияет на все буферы.}
     @result{} 5
@end group
@group
(make-local-variable 'foo)  ; @r{Сейчас это локальная привязка @samp{b1}.}
     @result{} foo
@end group
@group
foo                         ; @r{Значение @samp{foo}}
     @result{} 5                   ;   @r{подхватывается.}
@end group
@group
(setq foo 6)                ; @r{Изменение значения}
     @result{} 6                   ;   @r{@samp{b1}.}
@end group
@group
foo
     @result{} 6
@end group

@group
;; @r{В буфере @samp{b2}, значение не изменилось.}
(with-current-buffer "b2"
  foo)
     @result{} 5
@end group
@end example

Создание связывания локальной переменной буфера @code{let}-свзыванием этой
переменной не работает надежно, если буфер, в котором это происходит,
является текущим, пока конструкция @code{let} имеет силу.  Это происходит
потому, что @code{let} не делает различия между различными видами связывания;
просто создаёт связывание переменной.

Ошибочно, делать доступную только для чтения константу, локальной переменной
буфера.  @xref{Constant Variables}.

Если переменная является локальной переменной терминала
(@pxref{Multiple Terminals}), эта функция сигнализирует об ошибке.  Эти
переменные также не могут иметь локальные привязки буфера.

@strong{Предупреждение:} @code{make-local-variable} не используется для
переменных ловушек.  Переменная ловушка автоматически становится локальной
переменной буфера по необходимости, когда используется аогумент @var{local}
для @code{add-hook} или @code{remove-hook}.
@end deffn

@defmac setq-local variable value
Макрос создает локальное связывание переменной буфера в текущем буфере для
переменной @var{variable}, и связывает её с локальное значением буфера
@var{value}.  Это эквивалентно вызову @code{make-local-variable} с
последующим @code{setq}.  @var{variable} печатается символом без кавычек.
@end defmac

@deffn Command make-variable-buffer-local variable
Функция отмечает переменную @var{variable} (символ) как автоматическую
локальную буфера, так что любая последующая попытка установить эту
переменную, делает её локальной для текущего буфера.  В отличие от
@code{make-local-variable}, с которой её часто путают, это не может быть
отменено, и влияет на поведение переменной во всех буферах
(ВопросVariables1460).

Особенностью этой функции является то, что связывание переменной (с
@code{let} или другими связующими конструкциями) не создает локального
связывания  буфера для неё.  Только определение переменной (используя
@code{set} или @code{setq}), в то время как переменная не имеет
никагого @code{let}-подобного связывания в текущем буфере во время
связывания.

Если переменная @var{variable} не имеет значения по умолчанию, то вызов этой
команды присваивает значение по умолчанию @code{nil}.  Если @var{variable}
уже имеет значение по умолчанию, это значение остается неизменным.
Впоследствии вызов @code{makunbound} к переменной @var{variable} приведет к
унчтожению локальной привязки значения к буферу и оставит значение по
умолчанию без изменений.  (ВопросVariables1475)

Возвращаемое значение @var{variable}.

Это ошибка, чтобы сделать константу или переменную, доступную только для
чтения, локальной переменной буфера(ВопросVariables1480).  @xref{Constant Variables}.

@strong{Предупреждение:} Не нужно использовать
@code{make-variable-buffer-local} для установления опциональных переменных
пользователя, просто потому, что пользователь @emph{может} захотеть, чтобы
настроить их по-разному в различных буферах.  Пользователь может создать
любую локальную переменную, когда захочет.  Лучше оставить выбор за ним.

Следует использовать @code{make-variable-buffer-local} когда важно, что
никакие два буфера никогда не будут разделять одну и ту же привязку.
Например, когда переменная используется для внутренних целей в Lisp
программе, которая зависит от наличия отдельных значений в отдельных буферах,
решить это с помощью @code{make-variable-buffer-local} может быть лучшим
решением.
@end deffn

@defmac defvar-local variable value &optional docstring
Макрос определяет @var{variable} в качестве переменной с начальным значением
@var{value} и строкой документации @var{docstring}, и помечает её как
автоматическую локальную переменную буфера.  Это эквивалентно вызову
@code{defvar} с последующим @code{make-variable-buffer-local}.  Аргумент
@var{variable} должен быть символом без кавычек.
@end defmac

@defun local-variable-p variable &optional buffer
Возвращает @code{t}, если @var{variable} является локальной переменной буфера
@var{buffer} (по умолчанию текущий буфер); в противном случае, @code{nil}.
@end defun

@defun local-variable-if-set-p variable &optional buffer
Возвращает @code{t}, если @var{variable} является либо имеющая локальную
привязку или является автоматической переменной буфера @var{buffer}.  В
противном случае возвращается @code{nil}.  Если параметр @var{buffer} опущен
или @code{nil}, по умолчанию устанавливается текущий буфер.
@end defun

@defun buffer-local-value variable buffer
Функция возвращает значение локального связывания переменной буфера
@var{variable} (символ) в буфере @var{buffer}.  Если @var{variable} не имеет
локального связывания буфера в буфере @var{buffer}, возвращается значение по
умолчанию (@pxref{Default Value}) переменной @var{variable} вместо этого.
@end defun

@defun buffer-local-variables &optional buffer
Функция возвращает список, описывающий локальные переменные буфера
@var{buffer}.  (Если @var{buffer} опущен, используется текущий буфер.).
Как правило, каждый элемент списка имеет вид
@w{@code{(@var{sym} . @var{val})}}, где @var{sym} является локальной
переменной (символ) буфера и @var{val} является её локальным значением
буфера.  Но когда локальное связывание переменной буфера @var{buffer}
является недействительным, её элемент списка это просто @var{sym} без
значения.

@example
@group
(make-local-variable 'foobar)
(makunbound 'foobar)
(make-local-variable 'bind-me)
(setq bind-me 69)
@end group
(setq lcl (buffer-local-variables))
    ;; @r{Во-первых, встроенные локальные переменные во всех буферах:}
@result{} ((mark-active . nil)
    (buffer-undo-list . nil)
    (mode-name . "Fundamental")
    @dots{}
@group
    ;; @r{Далее, не встроенные локальные переменные буфера.}
    ;; @r{Это одна недействительная локальная переменная буфера:}
    foobar
    ;; @r{Это другая действительная локальная переменная буфера:}
    (bind-me . 69))
@end group
@end example

Обратите внимание, что сохранение новых значений в @sc{cdr}ов этих
cons-ячеек этого списка @emph{не} изменяет значения локальных переменных
буфера.
@end defun

@deffn Command kill-local-variable variable
Функция удаляет локальное связывание (если таковое имеется) для переменной
@var{variable} (символ) в текущем буфере.  В результате связывание переменной
@var{variable} по умолчанию становится видимым в этом буфере.  Это обычно
приводит к изменению значения переменной @var{variable}, так как значение по
умолчанию, как правило, отличается от только что удалённого локального
значения переменной буфера.

Если удаляется локальное связывание переменной буфера, которая автоматически
устанавливается локальной переменной буфера, это устанавливает переменной
значение по умолчанию, видимое в текущем буфере.  Тем не менее, если снова
установить значение этой переменной, это вновь создаст локальное связывание
переменной буфера.

@code{kill-local-variable} returns @var{variable}.

Функция является командой, потому что иногда бывает полезно как удалять, так
и создавать в интерактивном режиме локальное связывание переменных буфера.
@end deffn

@cindex local variables, killed by major mode
@defun kill-all-local-variables
Функция устраняет все локальные привязки переменных текущего буфера, не
включая связывание для переменных, отмеченных как постоянные и локальные
функции ловушек, у которых свойство @code{permanent-local-hook} установленно
в не-@code{nil} (@pxref{Setting Hooks}).  В результате, в буфере будут
доступны значения по умолчанию большинства переменных.

Функцией также сбрасывается определенная другая информация, относящуюся к
буферу: устанавливается локальная раскладка клавиатуры в @code{nil},
синтаксис таблица устанавливается в @code{(standard-syntax-table)}, таблица
регистра устанавливается в @code{(standard-case-table)} и таблица Abbrev
устанавливается в @code{fundamental-mode-abbrev-table}.

Самое первое, что эта функция делает запускает обычную ловушку
@code{change-major-mode-hook} (смотри ниже).

Каждая команда основного режима начинается с вызова этой функции, которая
имеет эффект переключения на основной режим и стирание большинства эффектов
предыдущего основного режима.  Для того, чтобы гарантировать, что это делает
свою работу, переменные, которые устанавливают основные режимы не должны быть
отмечены как постоянные.

@code{kill-all-local-variables} возвращает @code{nil}.
@end defun

@defvar change-major-mode-hook
Функция @code{kill-all-local-variables} запускает эту обычную ловушку, до
выполнения любых действий.  Это дает возможность основному режиму устроить
всё необходимое, когда пользователь переходит на другой основной режим.  Это
также полезно для удаления специфичных дополнительных режимов буфера, если
пользователь изменяет основной режим.

Для достижения наилучших результатов, переменную делают локальной переменной
буфера, так что она исчезнет после того, как сделает свою работу и не будет
мешать в последующем основном режиме.  @xref{Hooks}.
@end defvar

@cindex permanent local variable
@dfn{Постоянной} локальной переменной буфера переменная становится, если
переменная (символ) имеет свойство @code{permanent-local}, установленное в
не-@code{nil}.  На такие переменные и их привязки не влияют функции
@code{kill-all-local-variables}, таким образом, не удаляются их связывание
при изменении основных режимов.  Постоянные локальные переменные подходят для
данных, относящихся к тому, откуда файл был получен или куда его сохранить,
а не для тех, которые участвуют при редактировании содержимого.

@node Default Value
@subsection Значение Локальной Переменной Буфера по Умолчанию
@cindex default value

  Глобальное значение локальной привязки переменной буфера также называют
  значением @dfn{по умолчанию}, потому что это значение действует, когда ни
  текущий буфер, ни выбранный фрейм не имеет своего собственного связывания
  для переменной.

  Функции @code{default-value} и @code{setq-default} используют для доступа и
  изменения значения переменной по умолчанию, независимо от того, имеет ли
  текущий буфер локальное связывания переменной.  Например, можно
  использовать @code{setq-default} для изменения настройки по умолчанию
  @code{paragraph-start} для большинства буферов; и это сработает даже тогда,
  когда буфер находится в C или Lisp режиме, который имеет локальное значение
  буфера для этой переменной.

@c Emacs 19 feature
  Специальные формы @code{defvar} и @code{defconst} также устанавливают
  значение по умолчанию (если они вообще устанавливают переменную), а не
  какое-либо локальное значение буфера.

@defun default-value symbol
Функция возвращает значение по умолчанию символа(-ов) @var{symbol}.  Это
значение, которое рассматривается в буферах и фреймах, которые не имеют своих
собственных значений для этой переменной.  Если @var{symbol} не локальная
переменная буфера, это эквивалентно @code{symbol-value}
(@pxref{Accessing Variables}).
@end defun

@c Emacs 19 feature
@defun default-boundp symbol
Функция @code{default-boundp} определяет, является ли значение по умолчанию
@var{symbol} недействительным.  Если @code{(default-boundp 'foo)} возвращает
@code{nil}, то @code{(default-value 'foo)} выдаст ошибку.

@code{default-boundp} соотносится с @code{default-value}, как @code{boundp}
соотносится с @code{symbol-value}.
@end defun

@defspec setq-default [symbol form]@dots{}
Эта специальная форма присваивает каждому символу @var{symbol} новое
значение по умолчанию, которое является результатом вычисления
соответствующей ему формы @var{form}.  Символ @var{symbol} не оценивается,
но оценивается форма @var{form}.  Возвращаемое значение формы
@code{setq-default} является значением последней оценённой формы @var{form}.

Если @var{symbol} не является локальной привязкой буфера для текущего буфера,
и не отмечен как автоматическая локальная переменная буфера,
@code{setq-default} имеет тот же эффект, как и @code{setq}.  Если
@var{symbol} является локальной переменной буфера для текущего буфера, то это
изменяет значение, которое другие буфера будут использовать по умолчанию
(до тех пор, пока не определят своё локальное связывание буфера для этой
переменной), но не значение, которое использует текущий буфер.

@example
@group
;; @r{Для буфера @samp{foo}:}
(make-local-variable 'buffer-local)
     @result{} buffer-local
@end group
@group
(setq buffer-local 'value-in-foo)
     @result{} value-in-foo
@end group
@group
(setq-default buffer-local 'new-default)
     @result{} new-default
@end group
@group
buffer-local
     @result{} value-in-foo
@end group
@group
(default-value 'buffer-local)
     @result{} new-default
@end group

@group
;; @r{В (новом) буфере @samp{bar}:}
buffer-local
     @result{} new-default
@end group
@group
(default-value 'buffer-local)
     @result{} new-default
@end group
@group
(setq buffer-local 'another-default)
     @result{} another-default
@end group
@group
(default-value 'buffer-local)
     @result{} another-default
@end group

@group
;; @r{Обратно в буфере @samp{foo}:}
buffer-local
     @result{} value-in-foo
(default-value 'buffer-local)
     @result{} another-default
@end group
@end example
@end defspec

@defun set-default symbol value
Функция подобна @code{setq-default}, за исключением того, что оценивает
аргумент @var{symbol}.

@example
@group
(set-default (car '(a b c)) 23)
     @result{} 23
@end group
@group
(default-value 'a)
     @result{} 23
@end group
@end example
@end defun

  Переменная может быть связана к значению (@pxref{Local Variables}).  Это
  делает затенение его глобального связывания новым связыванием;
  @code{default-value} будет возвращать значение из этого связывания, а не
  значение из глобального связывания, и @code{set-default} не сможет
  установить значение глобального связывания (вместо этого измениться
  значение @code{let-связывания}).  Следующие две функции позволяют ссылаться
  на глобальное значение, даже если оно затенено @code{let-связыванием}.

@cindex top-level default value
@defun default-toplevel-value symbol
Функция возвращает @dfn{top-level (верхний-уровень)} значение по умолчанию
@var{symbol}, которое является его значением вне любого
@code{let-связывания}.
@end defun

@example
@group
(defvar variable 'global-value)
    @result{} variable
@end group
@group
(let ((variable 'let-binding))
  (default-value 'variable))
    @result{} let-binding
@end group
@group
(let ((variable 'let-binding))
  (default-toplevel-value 'variable))
    @result{} global-value
@end group
@end example

@defun set-default-toplevel-value symbol value
Эта функция устанавливает привязке верхнего уровня символу @var{symbol}
значение по умолчанию @var{value}.  Это очень удобно, когда требуется
установить глобальное значение @var{symbol} независимо от того, в каком
контексте находиться символ @var{symbol} в отрабатываемом коде.
@end defun


@node File Local Variables
@section Локальные Переменные Файла
@cindex file local variables

  Файл может задавать значения локальных переменных; Emacs использует их для
  создания локального связывания буфера этих переменных в буфере, при
  посещении этого файла.  @xref{File Variables, ,
  Локальные Переменные Файла, emacs, GNU Emacs Руководство}, для базовой
  информации относительно локальных переменных файла.  В этом разделе
  описаны функции и переменные, которые влияют на обработку локальных
  переменных файла.

  Если локальная переменная файла указывает произвольную функцию или
  выражение Lisp, которое будет вызываться позже, посещая файл, Emacs может
  это использовать.  Emacs устанавливает только те локальные переменные
  файла, которые известны как безопасные.  Другие локальные переменные файла
  устанавливаются только если пользователь даёт согласие.

  Для дополнительной безопасности, @code{read-circle} временно
  устанавливается в @code{nil}, когда Emacs считывает локальные переменные
  файла (@pxref{Input Functions}).  Это запрещает читателю Lisp
  оценивать циклические и общие структуры Lisp (@pxref{Circular Objects}).

@defopt enable-local-variables
Эта переменная определяет, как будут обрабатываться локальные переменные
файла.  Возможные значения:

@table @asis
@item @code{t} (the default)
Запросить один раз о установке любых небезопасных переменных.(ВопросVariables1818)
@item @code{:safe}
Установите только безопасные переменные без запроса.
@item @code{:all}
Установите все переменные без запроса.
@item @code{nil}
Не устанавливать какие-либо переменные.
@item anything else
Запрос (один раз) обо всех переменных.
@end table
@end defopt

@defvar inhibit-local-variables-regexps
Список регулярных выражений.  Если файл имеет имя, соответствующее
регулярному выражению в одном из элементов этого списка, то в нём не будет
проводится сканирование на предмет наличия каких-либо локальных переменных
буфера.  Для примеров того, почему это может понадобиться использовать,
@pxref{Auto Major Mode}.
@end defvar

@defun hack-local-variables &optional handle-mode
Функция анализирует и связывает или оценивает в случае необходимости, любые
локальные переменные, указанные в содержимом текущего буфера.  Переменная
@code{enable-local-variables} имеет значимость здесь.  Однако, эта функция
не ищет локальных переменных в строке @samp{mode:} @w{@samp{-*-}}.
@code{set-auto-mode} делает это, а также принимает во внимание
@code{enable-local-variables} (@pxref{Auto Major Mode}).

Функция по очереди применяет каждую локальную переменную ассоциативного
списка, хранящегося в @code{file-local-variables-alist}.  Производит вызов
@code{before-hack-local-variables-hook} до и @code{hack-local-variables-hook}
после определения переменных, соответственно.  Вызов ловушки происходит если
список установлен в не-@code{nil}; всегда вызывается другая ловушка.
Функция игнорирует @samp{mode} элемент, если задан тот же основной режим, как
и у текущего буфера.  (ВопросVariables1852)

Если необязательный аргумент @var{handle-mode} установлен в @code{t}, то всё
что делает эта функция - возвращает единственный символ, определяющий
основной режим, если @w{@samp{-*-}} строка или список локальных переменных
определены и @code{nil} в другом случае.  Не установливает режимы или любые
локальные переменные файла.  Если @var{handle-mode} имеет какое-либо
значение, отличное от @code{nil} или @code{t}, любые настройки @samp{mode} в
строке @w{@samp{-*-}} и в списке локальных переменных игнорируются, а
остальные параметры будут применены.  Если @var{handle-mode} является
@code{nil}, все локальные переменные файла устанавливаются.
(ВопросVariables1862)
@end defun

@defvar file-local-variables-alist
Локальная переменная буфера, содержит ассоциативный список параметров
локальных переменных файла.  Каждый элемент ALIST имеет вид
@w{@code{(@var{var} . @var{value})}}, где @var{var} является символом
локальной переменной и @var{value} является его значением.  Когда Emacs
посещает файл, он сначала собирает все локальные переменные файла в этот
список, а затем вызывает для каждого его элемента функцию
@code{hack-local-variables}.
@end defvar

@defvar before-hack-local-variables-hook
Emacs вызывает эту ловушку непосредственно перед помещением локальной
переменной файла в список ловушки @code{file-local-variables-alist}.
@end defvar

@defvar hack-local-variables-hook
Emacs вызывает эту ловушку сразу же после того, как заканчивает помещение
локальных переменный файла в список ловушки
@code{file-local-variables-alist}.
@end defvar

@cindex safe local variable
  Указать безопасные значения для переменной можно воспользовавшись свойством
  @code{safe-local-variable}.  Свойство должно представлять значением функцию
  одного аргумента; любое не-@code{nil} возвращаемое значение функции
  является безопасным.  Многие часто встречающиеся локальные переменные файла
  имеют установленное свойство @code{safe-local-variable}; включая
  @code{fill-column}, @code{fill-prefix}, и @code{indent-tabs-mode}.  Для
  установки признака безопасности локальных переменных файла, предоставляющих
  только булевские значения, используются @code{booleanp} в качестве
  значения свойства.

  Если вы хотите, чтобы определить свойства @code{safe-local-variable} для
  переменных, определенных в исходном коде C, добавьте имена и свойства этих
  переменных в список в разделе ``Безопасные локальные переменные'' файла
  @file{files.el}.

@cindex autoload cookie, and safe values of variable
  При определении параметра пользователя с помощью @code{defcustom}, можно
  установить его свойство @code{safe-local-variable}, добавив аргументы
  @code{:safe @var{function}} к @code{defcustom}
  (@pxref{Variable Definitions}).  Тем не менее, безопасность предиката,
  определенная с помощью @code{:safe} будет известена только загрузки пакета,
  который содержит @code{defcustom}, что часто слишком поздно.  В качестве
  альтернативы, можно использовать файлы cookie автозагрузки
  (@pxref{Autoload}), чтобы назначить опции предикат безопасности, например:

@lisp
;;;###autoload (put '@var{var} 'safe-local-variable '@var{pred})
@end lisp

@noindent
Определения безопасного значения, указанные в @code{autoload} копируются в
файл автозагрузки программ пакета (@file{loaddefs.el} для большинства пакетов
в комплекте с Emacs), и известны Emacs с начала сессии.

@defopt safe-local-variable-values
Переменная обеспечивает ещё способ отметить некоторые значения переменных,
как безопасные.  Это список cons-ячеек @code{(@var{var} . @var{val})}, где
@var{var} является имя переменной и @var{val} является значением, которое
является безопасным для этой переменной.

Когда Emacs запрашивает пользователя о принятии набора спецификаций локальных
переменных файлов, пользователь может выбрать, чтобы пометить их как
безопасные.  Это добавляет эти пары переменная/значение в
@code{safe-local-variable-values}, и сохраняет в пользовательском файле.
(ВопросVariables1932)
@end defopt

@defun safe-local-variable-p sym val
Функция возвращает не-@code{nil}, если безопасно, установить @var{sym}
в значение @var{val}, исходя из вышеуказанных критериев.
@end defun

@c @cindex risky local variable   Дубликаты risky-local-variable
  Некоторые переменные считаются @dfn{рискованными}.  Если переменная
  считается рискованной, она никогда не вводится автоматически в
  @code{safe-local-variable-values}; Emacs всегда запрашивает перед
  установкой рискованной переменной, если  только пользователь
  непосредственно позволяет установку значения настройкой
  @code{safe-local-variable-values}.

  Любая переменная, с именем которой не связано свойство
  @code{risky-local-variable} установленное в не-@code{nil} - считается
  рискованной.  При определении преременной - параметра пользователя с
  помощью @code{defcustom}, можно установить свойство
  @code{risky-local-variable}, добавив аргументы @code{:risky @var{value}} к
  @code{defcustom} (@pxref{Variable Definitions}).  Кроме того, любая
  переменная, имя которой заканчивается любым из постфиксов @samp{-command},
  @samp{-frame-alist}, @samp{-function}, @samp{-functions}, @samp{-hook},
  @samp{-hooks}, @samp{-form}, @samp{-forms}, @samp{-map}, @samp{-map-alist},
  @samp{-mode-alist}, @samp{-program}, или @samp{-predicate} автоматически
  считается рискованной.  Переменные @samp{font-lock-keywords},
  @samp{font-lock-keywords} с последующей цифрой, и
  @samp{font-lock-syntactic-keywords} также считаются рискованными.

@defun risky-local-variable-p sym
Эта функция возвращает не-@code{nil} если @var{sym} является рискованной
переменной, исходя из указанных выше критериев.
@end defun

@defvar ignored-local-variables
Эта переменная содержит список переменных, которым не должны быть заданы
локальные файловые значения.  Любое значение, указанное для одной из этих
переменных полностью игнорируются.
@end defvar

  Форма @samp{Eval:} ``переменная'' также потенциальная лазейка, поэтому
  Emacs обычно запрашивает подтверждение перед её оценкой.

@defopt enable-local-eval
Переменная управляет обработкой @samp{Eval:} в строке @samp{-*-} или списка
локальных переменных посещаемого файла.  Установленное значение в @code{t}
обрабатывать переменные безоговорочно; @code{nil} означает игнорирование их;
Еще что-нибудь - значит спросить у пользователя, что делать для каждого
файла. Значение по умолчанию @code{maybe}.
@end defopt

@defopt safe-local-eval-forms
Переменная содержит список выражений, которые являются безопасными для оценки
при их обнаружении в @samp{Eval:} ``переменная'' в списке локальных
переменных файла.
@end defopt

  Если выражение является вызовом функции, а функция имеет свойство
  @code{safe-local-eval-function}, значение этого свойства определяет,
  является ли это выражение безопасным для оценки.  Значением свойства может
  быть предикат вызова, проверяющий выражение или список таких предикатов
  (безопасно, если любой предикат завершается успешно), или @code{t} (всегда
  безопасно при условии, что аргументы постоянны).

  Свойства текста также являются потенциальными лазейками, так как их
  значения могут включать в себя функции для вызова.  Поэтому Emacs
  отбрасывает все свойства текста из строковых значений, заданных для
  локальных переменных файла.

@node Directory Local Variables
@section Локальные Переменные Каталога
@cindex directory local variables

  Можно указать значения локальным переменным каталога, общие для всех файлов
  в этой директории; Emacs использует это для создания локальной привязки
  переменным буфера, посещающего любой из файлов в этом каталоге.  Это
  полезно, когда файлы в каталоге принадлежат некоторому @dfn{проекту} и,
  следовательно, используют одни и те же локальные переменные.

  Есть два различных метода определить локальные переменные каталога:
  поместить их в специальный файл, или путём определения @dfn{класса проекта}
  для этого каталога.

@defvr Constant dir-locals-file
Константа - имя файла, в котором Emacs ожидает найти локальные переменные
каталога.  Имя файла @file{.dir-locals.el}@footnote{Версия MS-DOS из Emacs
использует @file{_dir-locals.el} вместо этого, из-за ограничения файловых
систем DOS.}.  Файл с таким именем в директории вынуждает Emacs, применить
свои настройки для любого файла в этом каталоге или любом из его подкаталогов
(необязательно, можно исключить подкаталоги, смотрите ниже). Если подкаталог
имеет свой собственный файл @file{.dir-locals.el}, Emacs использует настройку
из самого внутреннего найденного такого файла, начиная с каталога файла и
перемещением вверх по дереву каталогов.  Эта константа также используется для
получения имени второго такого файла-расширения @file{.dir-locals-2.el}. Если
этот второй расширяющий файл присутствует, то загружается он загружается в
дополнение к @file{.dir-locals.el}.  Это полезно, когда @file{.dir-locals.el}
находится под контролем версий в общем хранилище и не может быть использован
для личных настроек.  Файл определяет локальные переменные, как специально
отформатированный список; см @ref{Directory Variables, , Per-directory Local Variables, emacs, The GNU Emacs Manual}, для более подробной информации.
@end defvr

@defun hack-dir-local-variables
Функция считывает файл @code{.dir-locals.el} и сохраняют локальные переменные
каталога в @code{file-local-variables-alist} локального буфера, при посещениилюбого файла в директории, без применения их.  Она также сохраняет локальные
настройки каталога в @code{dir-locals-class-alist}, где определяет
специальный класс для каталога, в котором был найден @file{.dir-locals.el}
файл.  Эта функция работает, вызывая @code{dir-locals-set-class-variables} и
@code{dir-locals-set-directory-class}, как описано ниже.
@end defun

@defun hack-dir-local-variables-non-file-buffer
Функция ищет локальные переменные каталога, и немедленно применяет их в
текущем буфере.  Предназначена для вызова в командах режима для нефайловых
буферов, таких как Dired буфер, чтобы реализовать влияние настройки локальных
переменных каталога.  Для нефайловых буферов, Emacs ищет локальные переменные
каталога в @code{default-directory} родительских каталогах.
@end defun

@defun dir-locals-set-class-variables class variables
Функция определяет набор переменных с именем класса @var{class}, который
является символом.  Позже можно назначить класс одному или нескольким
каталогам, и Emacs будет применять эти переменные для всех файлов в этих
каталогах.  Список в @var{variables} может быть одной из двух форм:
@code{(@var{major-mode} . @var{alist})} или
@code{(@var{directory} . @var{list})}.  Первая форма, если буфер включает
режим, который является производным от режима @var{major-mode} и все
переменных в соответствующем @var{alist} применяется; @var{alist} должен
иметь вид @code{(@var{name} . @var{value})}.  Особое значение для режима
@var{major-mode} установленное в @code{nil} означает, что параметры применимы
к любому режиму.  В @var{alist}, вы можете использовать специальные имена
@var{name}: @code{subdirs}.  Если соответствующее значение установлено в
@code{nil}, то ассоциативный список применяется только к файлам в
соответствующем каталоге, исключая файлы в подкаталогах.

Со второй формой используются переменные @var{variables}, указанные начальной
подстрокой @var{directory} имени директории файла, список @var{list}
применяется рекурсивно, следуя вышеуказанным правилам; @var{list} должен быть
одной из двух форм, принимаемых этой функцией к переменным @var{variables}.
(ВопросVariables2071)
@end defun

@defun dir-locals-set-directory-class directory class &optional mtime
Функция присваивает класс @var{class} всем файлам в  директории
@code{directory} и его подкаталогах.  После этого все настройки, заданные для
переменной @var{class} будет применяться к любому посещаемому файлу в
директории @var{directory} и его подкаталогах.  @var{class} уже должен быть
определён с помощью @code{dir-locals-set-class-variables}.

Emacs использует эту функцию неявно, когда загружает переменные файла
каталога из файла @code{.dir-locals.el}.  В этом случае необязательный
аргумент @var{mtime} содержит время изменения файла (значение которого
возвращается @code{file-attributes}).  Emacs использует это время, чтобы
проверить актуальность сохраненных локальных переменных.  Если назначается
класс напрямую, а не через файл, этот аргумент должен быть @code{nil}.
@end defun

@defvar dir-locals-class-alist
Ассоциативный список содеожит символы класса и настройки соответствующих
переменными.  Обновляется с помощью  @code{dir-locals-set-class-variables}.
@end defvar

@defvar dir-locals-directory-cache
Список содержит имена каталогов, присвоенные им имена классов, и время
модификации локальных переменных файла, связанного каталога (если он есть).
Функция @code{dir-locals-set-directory-class} обновляет этот список.
@end defvar

@defvar enable-dir-local-variables
Если преременная установлена в @code{nil}, локальные переменные файла
игнорируются.  Переменная может быть полезна для режимов, в которых требуется
игнорировать локальные переменные файла в то же сохраняя локальные переменные
файла (@pxref{File Local Variables}).
@end defvar

@node Connection Local Variables
@section Локальные Переменные Соединения
@cindex connection local variables

  Локальные переменные соединения обеспечивают общий механизм для различных
  настроек переменных в буферах с удаленным подключением.  Связывание и
  установка этих переменных зависит от удаленного соединения, которое
  выделено для посещения буфером.

@defun connection-local-set-profile-variables profile variables
Функция определяет набор переменных для использования при подключении
профиля @var{profile}, который представлен символом.  Позже можно назначить
такой профиль подключения к одному или нескольким удаленным соединениям, и
Emacs будет применять эти настройки переменных для всех процесов буферов этих
соединений.  Список переменных в @var{variables} является ассоциативным
списком вида @code{(@var{name}@tie{}.@tie{}@var{value})}. Например:

@example
@group
(connection-local-set-profile-variables
  'remote-bash
  '((shell-file-name . "/bin/bash")
    (shell-command-switch . "-c")
    (shell-interactive-switch . "-i")
    (shell-login-switch . "-l")))
@end group

@group
(connection-local-set-profile-variables
  'remote-ksh
  '((shell-file-name . "/bin/ksh")
    (shell-command-switch . "-c")
    (shell-interactive-switch . "-i")
    (shell-login-switch . "-l")))
@end group

@group
(connection-local-set-profile-variables
  'remote-null-device
  '((null-device . "/dev/null")))
@end group
@end example
@end defun

@defvar connection-local-profile-alist
Ассоциативный список содержит символ профиля соединения и соответствующие
параметры переменных.  Обновляется с помощью
@code{connection-local-set-profile-variables}.
@end defvar

@defun connection-local-set-profiles criteria &rest profiles
Функция назначает профили @var{profiles}, которые являются символами, для
всех удаленных подключений, определенных критерием @var{criteria}.
Критерий @var{criteria} является списком свойств идентифицирующим соединения
и приложения использующие это соединение.  Свойства могут иметь имена
@code{:application}, @code{:protocol}, @code{:user} и @code{:machine}.
Значением свойства с именем @code{:application} является символом, все
остальные значения свойств являются строками.  Указание свойств не являются
обязательным; если критерий @var{criteria} установлен в @code{nil}, он всегда
применяется. Пример:

@example
@group
(connection-local-set-profiles
  '(:application 'tramp :protocol "ssh" :machine "localhost")
  'remote-bash 'remote-null-device)
@end group

@group
(connection-local-set-profiles
  '(:application 'tramp :protocol "sudo"
    :user "root" :machine "localhost")
  'remote-ksh 'remote-null-device)
@end group
@end example

  Если критерий @var{criteria} установлен в @code{nil}, критерий применяется
  для всех удаленных подключений. Таким образом, в приведенный выше пример
  был бы эквивалентен

@example
@group
(connection-local-set-profiles
  '(:application 'tramp :protocol "ssh" :machine "localhost")
  'remote-bash)
@end group

@group
(connection-local-set-profiles
  '(:application 'tramp :protocol "sudo"
    :user "root" :machine "localhost")
  'remote-ksh)
@end group

@group
(connection-local-set-profiles
  nil 'remote-null-device)
@end group
@end example

  Любой профиль подключения @var{profiles} должен был зараннее определен
  @code{connection-local-set-profile-variables}.
@end defun

@defvar connection-local-criteria-alist
Ассоциативный список содержит критерии подключения и назначенные им имена
профилей.  Функция @code{connection-local-set-profiles} обновляет этот
список.
@end defvar

@defun hack-connection-local-variables criteria
Функция собирает применимые локальные переменные подключения, связанные с
критерием @var{criteria} в @code{connection-local-variables-alist}, без их
применения. Пример:

@example
@group
(hack-connection-local-variables
  '(:application 'tramp :protocol "ssh" :machine "localhost"))
@end group

@group
connection-local-variables-alist
     @result{} ((null-device . "/dev/null")
        (shell-login-switch . "-l")
        (shell-interactive-switch . "-i")
        (shell-command-switch . "-c")
        (shell-file-name . "/bin/bash"))
@end group
@end example
@end defun

@defun hack-connection-local-variables-apply criteria
Функция ищет локальные переменные соединения согласно критерию
@var{criteria} и немедленно применяет их в текущем буфере.
@end defun

@defmac with-connection-local-profiles profiles &rest body
Применяются все локальные переменные соединения, которые указаны в профиле
соединения @var{profiles}.

После этого, выполняется тело @var{body}, и локальные переменные соединения
развязываются. Пример: (ВопросVariables2249)

@example
@group
(connection-local-set-profile-variables
  'remote-perl
  '((perl-command-name . "/usr/local/bin/perl")
    (perl-command-switch . "-e %s")))
@end group

@group
(with-connection-local-profiles '(remote-perl)
  do something useful)
@end group
@end example
@end defmac

@defvar enable-connection-local-variables
Если переменная установлена в @code{nil}, локальные переменные соединения
игнорируются.  Эта переменная должна временно изменяется только в специальных
режимах.
@end defvar

@node Variable Aliases
@section Псевдонимы Переменных
@cindex variable aliases
@cindex alias, for variables

  Иногда полезно сделать две переменные синонимы, так чтобы обе переменные
  всегда имели одинаковое значение, и изменение значения одной переменной
  также меняло и значение другой.  Всякий раз, когда меняется имя переменной
  ---либо потому, что её прежднее имя не было выбрано удачно, или потому, что
  её значение частично изменилось---это может быть полезно, чтобы сохранить
  прежднее имя как @emph{псевдоним} нового для совместимости.  Можно сделать
  это с использованием @code{defvaralias}.

@defun defvaralias new-alias base-variable &optional docstring
Функция определяет символ @var{new-alias} в качестве псевдонима базовой
преремнной символа @var{base-variable}.  Это означает, что получение значения
@var{new-alias} возвращает значение @var{base-variable}, и изменение значения
@var{new-alias} изменяет значение @var{base-variable}.  Два псевдонима с
одним и тем же именем всегда одинакого оцениваются и имеют общие привязки.

Если @var{docstring} аргумент установлен в не-@code{nil}, это указывает на
документацию для @var{new-alias}; в противном случае, получается та же
документация, которой распологает @var{base-variable}, если таковая имеется,
если переменная @var{base-variable} сама не является псевдонимом, в случае
если это псевдоним, @var{new-alias} получает документацию переменной в конце
цепочки псевдонимов.  Эта функция возвращает @var{base-variable}.
@end defun

  Переменные псевдонимы удобны для замены прежднего имени переменной
  переменной с новым именем.  @code{make-obsolete-variable} заявляет, что
  старое название является устаревшим и, следовательно, может быть удалено
  в последующем будущем.

@defun make-obsolete-variable obsolete-name current-name when &optional access-type
Функция делает предупреждение байт компилятору, что переменная
@var{obsolete-name} является устаревшей.  Если @var{current-name} это символ,
указывающий новое имя переменной; то предупреждающее сообщение печатает
использовать имя @var{current-name} вместо имени @var{obsolete-name}.  Если
@var{current-name} является строкой, то это представляет из себя сообщение и
нет замены для переменной.   Аргумент @var{when} предоставляет строку,
описывающую, когда переменная впервые была сделана устаревшей (обычно строка
номера версии).

Необязательный аргумент @var{access-type}, если установлен в не-@code{nil},
указывает тип доступа, при котором будут вызываться предупреждения
устаревания; это может быть либо @code{get} или @code{set}.
@end defun

  Можно создат две переменные синонимы и объявить, в то же время, одну
  устаревшей, воспользовавшись макросом
  @code{define-obsolete-variable-alias}.

@defmac define-obsolete-variable-alias obsolete-name current-name &optional when docstring
Макрос отмечает переменную @var{obsolete-name} как устаревшую, а также
делает её псевдоним переменной @var{current-name}.  Это эквивалентно
следующему:

@example
(defvaralias @var{obsolete-name} @var{current-name} @var{docstring})
(make-obsolete-variable @var{obsolete-name} @var{current-name} @var{when})
@end example
@end defmac

@defun indirect-variable variable
Функция возвращает значение переменной @var{variable} в конце цепочки
её псевдонимов.  Если переменная @var{variable} не является символом, или
если переменная @var{variable} не определена как псевдоним, функция
возвращает переменную @var{variable}.

Функция сообщает об ошибке @code{cyclic-variable-indirection}, если есть
зацикливание в цепочке символов псевдонимов.
@end defun

@example
(defvaralias 'foo 'bar)
(indirect-variable 'foo)
     @result{} bar
(indirect-variable 'bar)
     @result{} bar
(setq bar 2)
bar
     @result{} 2
@group
foo
     @result{} 2
@end group
(setq foo 0)
bar
     @result{} 0
foo
     @result{} 0
@end example

@node Variables with Restricted Values
@section Переменные с Ограниченными Значениями
@cindex lisp variables defined in C, restrictions

  Обычным переменным Lisp может быть назначено любое значение, которое
  является допустимым объектом Lisp.  Однако некоторые переменные Lisp не
  определены в Lisp, а определены в C@.  Большинство из этих переменных
  определены в коде C помощью @code{DEFVAR_LISP}.  Как переменные,
  определенные в Lisp, они могут принимать любые значения.  Однако некоторые
  переменные определяются с помощью @code{DEFVAR_INT} или @code{DEFVAR_BOOL}.
  @xref{Defining Lisp variables in C,, Writing Emacs Primitives}, в
  частности, при описании функций типа @code{syms_of_@var{filename}}, для
  краткого осуществления в C.

  Переменные типа @code{DEFVAR_BOOL} могут принимать только значений
  @code{nil} или @code{t}.  Попытка присвоить им любой другой тип значения
  установит их в @code{t}:

@example
(let ((display-hourglass 5))
  display-hourglass)
     @result{} t
@end example

@defvar byte-boolean-vars
Переменная содержит список всех переменных типа @code{DEFVAR_BOOL}.
@end defvar

  Переменные типа @code{DEFVAR_INT} могут принимать только целые значения.
  Попытка присвоить им любое другое значение приведет к ошибке:

@example
(setq undo-limit 1000.0)
@error{} Wrong type argument (Неправильный тип аргумента): integerp, 1000.0
@end example

@node Generalized Variables
@section Обобщенные Переменные

@cindex generalized variable
@cindex place form
@dfn{Обобщённая переменная} или @dfn{место формы} является одним из многих
мест в памяти Lisp, где значения могут быть сохранены с помощью
(@pxref{Setting Generalized Variables})  макроса @code{setf}.  Простейшее
форма размещения - это обычная переменная Lisp.  Но @sc{car}ы и @sc{cdr}ы
списков, элементы массивов, свойства символов и многие другие места, также
места, где хранит значения Lisp.

Обобщенные переменные аналогичны lvalues ​​в языке C, где форма
@samp{x = a[i]} получает элемент из массива и @samp{a[i] = x} помещает
элемент в массив, используя ту же нотацию.  Подобно тому, как некоторые
формы, такие как @code{a[i]} могут быть lvalues ​​в C, существует множество
форм, которые могут быть обобщенными переменными в Lisp.

@menu
* Setting Generalized Variables::   Макрос @code{setf}.
* Adding Generalized Variables::    Определение новых форм @code{setf}.
@end menu

@node Setting Generalized Variables
@subsection Макрос @code{setf}

Макрос @code{setf} является самым основным способом работать с обобщенными
переменными.  Форма @code{setf} аналогична @code{setq}, за исключением того,
что принимает произвольные формы мест хранения в левой стороне, а не только
символы.  Например, @code{(setf (car a) b)} устанавливает голову @code{car}
@code{a} в значение @code{b}, делая ту же операцию, @code{(setcar a b)}, но
без необходимости использовать две отдельные функции для настройки и доступа
к этому типу места.

@defmac setf [place form]@dots{}
Макрос оценивает форму @var{form} и сохраняет её значение в форму
@var{place}, которая должна быть допустимой обобщённой формой переменной.
Если есть несколько пар форм @var{place} и @var{form}, присваивание
выполняется последовательно так же, как при использовании @code{setq}.
@code{setf} возвращает значение последней оценённой формы @var{form}.
@end defmac

Следующие формы Lisp являются формами Emacs, которые будут работать в
качестве обобщенных переменных, и поэтому могут появиться в аргументе
@var{place} формы @code{setf}:

@itemize
@item
Символ.  Другими словами, @code{(setf x y)} в точности эквивалентен
@code{(setq x y)} и @code{setq}, строго говоря,  является излишним, учитывая,
что @code{setf} существует.  Большинство программистов по-прежнему
предпочитают @code{setq} для установки простых переменных из стилистических и
исторических причин.  Макрос @code{(setf x y)} фактически расширяется до
@code{(setq x y)}, так что использование его не снижает производительность
скомпилированного кода.

@item
Вызов любой из следующих стандартных функций Lisp:

@smallexample
aref      cddr      symbol-function
car       elt       symbol-plist
caar      get       symbol-value
cadr      gethash
cdr       nth
cdar      nthcdr
@end smallexample

@item
Вызов любой из следующих стандартных функций Emacs:

@smallexample
alist-get                     process-get
frame-parameter               process-sentinel
terminal-parameter            window-buffer
keymap-parent                 window-display-table
match-data                    window-dedicated-p
overlay-get                   window-hscroll
overlay-start                 window-parameter
overlay-end                   window-point
process-buffer                window-start
process-filter                default-value
@end smallexample
@end itemize

@noindent
@code{setf} сигнализирует об ошибке, если не знает как обращаться с формой
места @var{place}.

@c И для cl-lib's cl-getf.
Обратите внимание, что для формы @code{nthcdr}, список аргументов функции
сами должны быть действительными формами @var{place}.  Например,
@code{(setf (nthcdr 0 foo) 7)} установит @code{foo} в 7.
@c Использование @code{nthcdr} как формы @var{place} является расширением
@c стандарта Common Lisp.

@c ИСПРАВИТЬ МЕНЯ: Я не думаю, что это особенно хороший способ сделать это,
@c но эти макросы были введены, прежде чем ввели обобщенные переменные.
Макросы @code{push} (@pxref{List Variables}) и @code{pop}
(@pxref{List Elements}) могут манипулировать обобщенными переменными, а не
только списками.  Макрос @code{(pop @var{place})} удаляет и возвращает первый
элемент списка, хранящегося в месте формы @var{place}.  Это аналогично
@code{(prog1 (car @var{place}) (setf @var{place} (cdr @var{place})))}, за
исключением того, что берёт на себя, одноразовую оценку всех субформ.
Макрос @code{(push @var{x} @var{place})} вставляет @var{x} в передней части
списка, сохраненного в месте @var{place}.  Она аналогично
@code{(setf @var{place} (cons @var{x} @var{place}))}, за исключением оценки
подчинённых форм.  Обратите внимание, что @code{push} и @code{pop} используя
@code{nthcdr} к месту, может это использовать для вставки или удаления в
любом месте списка.

Библиотека @file{cl-lib} определяет различные расширения для обобщенных
переменных, включая дополнительные места для @code{setf}.
@xref{Generalized Variables,,, cl, Common Lisp Extensions}.


@node Adding Generalized Variables
@subsection Определение Новых Форм @code{setf}

В этом разделе описывается, как определить новые формы, с которыми сможет
работать @code{setf}.

@defmac gv-define-simple-setter name setter &optional fix-return
Макрос позволяет легко определить методы @code{setf} для простых случаев.
@var{name} это имя функции, макроса или специальной формы.  Можно
использовать этот макрос, когда @var{name} имеет непосредственно
соответствующую @var{setter} функцию, которая обновляет её, например,
@code{(gv-define-simple-setter car setcar)}. (ВопросVariables2528)

Этот макрос переводит вызов формы

@example
(setf (@var{name} @var{args}@dots{}) @var{value})
@end example

к вызову формы
@example
(@var{setter} @var{args}@dots{} @var{value})
@end example

@noindent
Такой вызов @code{setf} задокументирован для возврата значения @var{value}.
Это не проблема при использовании, например с, @code{car} и @code{setcar},
поскольку @code{setcar} возвращает значение, которое установил.  Если функция
@var{setter} не возвращает значение @var{value}, используется установленное в
не-@code{nil} значение для аргумента @var{fix-return}
@code{gv-define-simple-setter}.  Это расширяется в нечто эквивалентное
(ВопросVariables2548)
@example
(let ((temp @var{value}))
  (@var{setter} @var{args}@dots{} temp)
  temp)
@end example
чтобы гарантировать, что возвращается правильный результат.
@end defmac


@defmac gv-define-setter name arglist &rest body
Макрос позволяет выполнить более сложные @code{setf} расширения, чем
предыдущая форма.  Возможно, потребуется использовать эту форму, например,
если не существует простой способ вызова установленной функции, или если есть
такой, но требующий дополнительных аргументы для форм размещения.

Этот макрос расширяет форму вида
@code{(setf (@var{name} @var{args}@dots{}) @var{value})} сначала посредствам
@code{setf} связывая формы аргументов @var{args}@dots{} с их значениями
@var{value} согласно списка @var{arglist}, а затем выполняя тело формы
@var{body}.  Тело @var{body} должно возвращать форму Lisp, которая выполняет
задание, и, наконец, возвращает значение, которое было установлено.  Пример
использования этого макроса:

@example
(gv-define-setter caar (val x) `(setcar (car ,x) ,val))
@end example
@end defmac

@findex gv-define-expander
@findex gv-letplace
@c Поправте меня?  Не уверен, что и как много, чтобы сказать о них.
@c See cl.texi для примера использования gv-letplace.
Для большего контроля над расширениями смотреть макрос
@code{gv-define-expander}.  Макрос @code{gv-letplace} может быть полезным
при определении макросов, которые выполняются аналогично @code{setf};
например, макрос Common Lisp @code{incf}.  Обратитесь к исходному файлу
@file{gv.el} для получения более подробной информации.

@cindex CL note---no @code{setf} functions
@quotation
@b{Common Lisp Замечание:} Common Lisp имеет другой способ определить
поведение функций @code{setf}, а именно @code{setf} функций, чьи имена
перечислены списком @code{(setf @var{name})}, а не символами.  Например,
@code{(defun (setf foo) @dots{})} определяет функцию, которая используется,
когда @code{setf} применяется к @code{foo}.  Emacs не поддерживает этого.
Это ошибка времени компиляции использование @code{setf} в форме, которая еще
не имела соответствующего определённого расширения.  В Common Lisp, это не
ошибка, так как функция @code{(setf @var{func})} может быть определена
позднее.
@end quotation
