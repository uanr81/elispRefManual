@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-2019 Free Software Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Variables
@chapter Переменные
@cindex variable

  @dfn{Переменная} это имя, используемое в программе, чтобы остаивать
  значение.  В Lisp, каждая переменная представлена ​​символом Lisp
  (@pxref{Symbols}).  Имя переменной - просто имя символа, а значение
  переменной сохраняется в компоненте символа ячейки
  значения@footnote{Чтобы быть точным, в соответствии с правилом
  @dfn{динамического связывания} по умолчанию, в компоненте символа ячейки
  значения всегда установленно текущее значение переменной, но это не так,
  в соответствии с правилом @dfn{лексического связывания}.
  @xref{Variable Scoping}, для деталей.}.  @xref{Symbol Components}.  В Emacs
  Lisp, использование символа в качестве переменной не зависит от
  использования его в качестве имени функции.

 Как уже отмечалось ранее в данном руководстве, программа Lisp представлена
 в основном объектами Lisp, и лишь во вторую очередь как текст.  Текстовая
 форма программы Lisp задается для чтения синтаксиса объектов Lisp, которые
 составляют программу.  Следовательно, текстовая форма переменной в программе
 Lisp записывается с использованием синтаксиса для чтения символа,
 представляющего переменную.

@menu
* Global Variables::            Переменные, значения которых существуют постоянно, везде.
* Constant Variables::          Переменные, значения которых никогда не меняются.
* Local Variables::             Переменные, значения которых существуют временно.
* Void Variables::              Символы, которые не имеют значения.
* Defining Variables::          Определение указывает использование символа в качестве переменной.
* Tips for Defining::           Вещи, о которых требуется думать, когда определяется переменная.
* Accessing Variables::         Проверка значений переменных, имена которых известны только во время выполнения.
* Setting Variables::           Сохранение новых значений в переменных.
* Watching Variables::          Выполнение функции, когда переменная изменяется.
* Variable Scoping::            Как Lisp выбирает среди локальных и глобальных связок.
* Buffer-Local Variables::      Значения переменных действующих только в одном буфере.
* File Local Variables::        Обработка списков локальных переменных файла.
* Directory Local Variables::   Локальные переменные, общие для всех файлов в каталоге.
* Connection Local Variables::  Локальные переменные, общие для удаленных подключений.
* Variable Aliases::            Переменные, которые являются псевдонимами для других переменных.
* Variables with Restricted Values::  Непостоянные переменные, принимающих значения определённого объекта Lisp.
* Generalized Variables::       Расширение концепции переменных.
@end menu

@node Global Variables
@section Глобальные Переменные
@cindex global variable

  Самый простой способ использовать переменную - использовать её
  @dfn{глобально}.  Это означает, что переменная имеет только одно значение
  (по крайней мере на данный момент) по всей системе Lisp.  Значение остается
  в силе до тех пор, пока не задать новое.  Когда новое значение заменяет
  старое, никаких следов старого значения в переменной не остаётся.

  Необходимо указать значение для символа. Используется @code{setq}.
  Например,

@example
(setq x '(a b))
@end example

@noindent
присваивает переменной @code{x} значение @code{(a b)}.  Обратите внимание,
что @code{setq} это специальная форма (@pxref{Special Forms}); она не
оценивает свой первый аргумент, имя переменной, но оценивает второй аргумент,
новое значение.

  После того, как переменная имеет значение, можно обратиться к нему,
  используя сам символ как выражение.  Таким образом,

@example
@group
x @result{} (a b)
@end group
@end example

@noindent
предполлагается, что уже оценена форма @code{setq},  показанная выше.

  Если определить ту же переменную снова, новое значение замещает старое:

@example
@group
x
     @result{} (a b)
@end group
@group
(setq x 4)
     @result{} 4
@end group
@group
x
     @result{} 4
@end group
@end example

@node Constant Variables
@section Переменные, Которые не Меняются
@cindex @code{setting-constant} error
@cindex keyword symbol
@cindex variable with constant value
@cindex constant variables
@cindex symbol that evaluates to itself
@cindex symbol with constant value

  В Emacs Lisp, определенные символы, как правило, оценивают сами себя.  К
  ним относятся @code{nil} и @code{t}, а также любой символ, имя которого
  начинается с @samp{:} (они называются @dfn{keywords}).  Эти символы не
  могут быть переопределены, и нельзя изменить их значения.  Любая попытка
  определить или связать символы @code{nil} или @code{t}, приводит к сигналу
  ошибки @code{setting-constant}.  То же самое верно и для ключевого слова
  (символ, имя которого начинается с @samp{:}), если он интернирован в
  стандартном obarray, за исключением того, что определение такого символа
  само по себе не является ошибкой.  (ВопросVariables117)

@example
@group
nil @equiv{} 'nil
     @result{} nil
@end group
@group
(setq nil 500)
@error{} Попытка определить символ константу: nil
@end group
@end example

@defun keywordp object
Функция возвращает @code{t} если @var{object} символ, имя которого начинается
с @samp{:}, интернированных в стандартном obarray и возвращается @code{nil}
другом случае.
@end defun

Такие константы существенно отличаются от констант, определенных с помощью
специальной формы @code{defconst} (@pxref{Defining Variables}).  Форма
@code{defconst} - средство выделить переменную для программиста, который
может изменить значение переменной, Emacs не вызывает ошибку, если значение
на самом деле будет изменено.

@cindex read-only variables
Небольшое количество дополнительных символов сделаны доступными только для
чтения по различным практическим причинам.  К ним относятся
@code{enable-multibyte-characters}, @code{most-positive-fixnum},
@code{most-negative-fixnum}, и несколько других.  Любая попытка установить
или связать их также сигнализирует об ошибке @code{setting-constant}.

@node Local Variables
@section Локальные Переменные
@cindex binding local variables
@cindex local variables
@cindex local binding
@cindex global binding

  Глобальные переменные имеют значения, которые сохраняются до тех пор, пока
  не будут явно заменены новыми значениями.  Иногда требуется присвоить
  переменной @dfn{локальное значение}---ия, который вступают в силу только в
  пределах определенной части программы Lisp.  Когда переменная имеет
  локальное значение, это определяется как @dfn{локальная привязка} к этому
  значению пременной, и что это @dfn{локальная переменная}.

  Например, когда происходит вызов функции, ее аргументы переменные получают
  локальные значения, которые представляют фактические аргументы, переданные
  в вызов функции; эти локальные привязки вступают в силу в теле функции.
  Возьмем другой пример, специальная форма @code{let} явно устанавливает
  локальные привязки для конкретных переменных, которые вступают в силу
  только в теле самой формы @code{let}.

  Также определение @dfn{глобальная привязка}, подразумевает (концептуально)
  глобальное хранение значения.

@cindex shadowing of variables
  Установка локальной привязки не изменяет предыдущее значение переменной
  (или отсутствие такового).  Рассматривается так, что предыдущее значение
  @dfn{затенено}.  Могут быть затенены как глобальные так и локальные
  значения переменных.  Если действует локальная привязка, с помощью
  @code{setq} присваивается значение в локальной привязке.  Когда эта
  локальная привязка перестаёт действовать, ранее затененное значение
  (или отсутствие таковго) снова вступает в силу.

@cindex current binding
  Переменная может одновременно иметь более одной локальной привязки
  (например, если есть вложенные формы @code{let}, которые связывают
  переменные).  @dfn{Текущая привязка} на самом деле это локальное
  связывание.  @code{setq} определяется значение, возвращаемое посредством
  оценки символа переменной в условиях связывания.

  В большинстве случаев текущая привязка рассматривается как самое внутреннее
  локальное связывание или глобальное связывание, если отсутствует локальное
  связывание.  Более точно, правило называется @dfn{областью видимости}
  и определяет, где в программе локальное связывание вступает в силу.
  Правило области видимости (действует по умолчанию) в Emacs Lisp называется
  @dfn{динамическое связывание}, которое гласит, что текущая привязка
  переменной значения в любой заданной точке выполнения программы является
  самой последней такой созданной привязкой к этой переменной, которая все
  еще существуетвует.  Более подробную информацию о динамической области
  видимости, и альтернативное правило области видимости под названием
  @dfn{лексическое связывание}, @xref{Variable Scoping}.

  Специальные формы @code{let} и @code{let*} существуют для создания
  локальных привязок:

@defspec let (bindings@dots{}) forms@dots{}
Особая форма устанавливает локальные привязки для определенного набора
переменных, как определенно с помощью формы @var{bindings}, а затем оценивает
все @var{forms} в текстовом порядке.  Возвращаемое значение является
значением последней формы в @var{forms}.  Местные привязок созданые с помощью
формы @code{let} будет действовать только в пределах её тела @var{forms}.

Каждая из форм @var{bindings} является либо отдельным символом @w{(i) a}, и
в этом случае символу локально устанавливается значение в @code{nil}; или
список @w{(ii) a} вида @code{(@var{symbol} @var{value-form})}, в этом случае
символ @var{symbol} локально связывается с результатом оценки формы
@var{value-form}.  Если @var{value-form} опущена, используется @code{nil}.

Все формы @var{value-form}ы в @var{bindings} оцениваются в порядке их
появления и @emph{до} связывания с предназначенным для них символом.  Вот
пример этого: @code{z} связан со старым значением @code{y}, которое 2, а не
новое значение @code{y}, которое 1.

@example
@group
(setq y 2)
     @result{} 2
@end group

@group
(let ((y 1)
      (z y))
  (list y z))
     @result{} (1 2)
@end group
@end example

С другой стороны, порядок оценки @emph{bindings} не определен: в следующем
примере, либо 1 или 2 может быть в результате напечатано.

@example
(let ((x 1)
      (x 2))
  (print x))
@end example

Поэтому требуется избегать связывания переменной более одного раза в одной
форме @code{let}.
@end defspec

@defspec let* (bindings@dots{}) forms@dots{}
Специальная форма подобна @code{let}, но связывается каждая переменная сразу
после вычисления её локального значения, перед вычислением локального
значения следующих переменных.  Таким образом, выражение в @var{bindings}
может относиться к предыдущим символам, связанным в этой @code{let*} форме.
Сравните следующий пример с примером @code{let} выше.

@example
@group
(setq y 2)
     @result{} 2
@end group

@group
(let* ((y 1)
       (z y))    ; @r{Действует только что установленное значение @code{y}.}
  (list y z))
     @result{} (1 1)
@end group
@end example
@end defspec

  Вот полный список других средств, которые создают локальные привязки:

@itemize @bullet
@item
Вызов функций (@pxref{Functions}).

@item
Вызов макросов (@pxref{Macros}).

@item
@code{condition-case} (@pxref{Errors}).
@end itemize

  Переменные могут также иметь локальную привязку к буфферу
  (@pxref{Buffer-Local Variables}); некоторые переменные имеют локальную
  привязку к терминалу (@pxref{Multiple Terminals}).  Эти виды привязок
  работают как обычные локальные привязки, но они локализуются в зависимости
  от контекста где находится Emacs.

@defopt max-specpdl-size
@anchor{Definition of max-specpdl-size}
@cindex variable limit error
@cindex evaluation error
@cindex infinite recursion
Переменная определяет допустимый предел на общее количество локальных
привязок и очисток @code{unwind-protect} переменных (смотреть
@ref{Cleanups,,Cleaning Up from Nonlocal Exits}), которые разрешены, прежде
чем Emacs сигнализирует об ошибке (с данными @code{"Глубина связывания
переменной превышает заданное значение max-specpdl-size"}).

Это ограничение, с соответствующей ошибкой при превышении, это один из
способов Lisp избежать зацикливания на нечетко определенной функции.
@code{max-lisp-eval-depth} обеспечивает еще ограничение на глубину
вложенности.  @xref{Definition of max-lisp-eval-depth,, Eval}.

Значение по умолчанию 1300.  При вход в отладчик, Lisp увеличивает значение,
если остаётся мало места для выполнения отладчиком действий.
@end defopt

@node Void Variables
@section Недействительная Переменная
@cindex @code{void-variable} error
@cindex void variable

  Понимается, что переменная недействительна, если компонента символа ячейка
  значения не имеет значения (@pxref{Symbol Components}).

  В соответствии правилу динамического связывания, действующему по умолчанию
  (@pxref{Variable Scoping}), Emacs Lisp хранит текущее значение переменной
  (локальное или глобальное) значением компоненты символа ячейки значения.
  Обратите внимание, что неприсвоенное значение этой ячейки значения
  @emph{не} такое, как установленое в @code{nil}.  Символ @code{nil}
  является объектом Lisp и может быть значением переменной, так же, как
  может быть любой другой объект.  Если переменная недействительна, попытка
  её оценить сигнализирует ошибку @code{void-variable}, вместо того, чтобы
  вернуть её значение.

  Согласно дополнительному правилу лексической области видимости, значение
  ячейки компоненты символа содержит только глобальное значение переменной---
  значение вне любого лексического связывания конструкции.  Когда переменная
  лексически связана, локальное значение определяется лексической средой;
  следовательно, переменные могут иметь локальные значения, даже если
  ячейкам значений компоненты их символов значения неприсвоенны.

@defun makunbound symbol
Функция очищает значение ячейки значения символа @var{symbol}, что делает
переменную пустой.  Возвращается @var{symbol}.

Если @var{symbol} имеет локальное динамическое связывание, @code{makunbound}
аннулирует текущую привязку, и эта пустота длится только до тех пор, пока
действует локальное связывание.  После этого, ранее затененное локальное или
глобальное связывание выходит на первый план и переменная больше не будет
считаться недействительной, если восстановленная привязка существует.

Ниже приведены некоторые примеры (предполагая, что действует динамическое
связывание):

@smallexample
@group
(setq x 1)               ; @r{Помещается значение глобальной привязки.}
     @result{} 1
(let ((x 2))             ; @r{Её локальное связывание.}
  (makunbound 'x)        ; @r{Очистка локального связывания.}
  x)
@error{} Значение символа как переменный является недействительным: x
@end group
@group
x                        ; @r{Глобальное связывание осталось неизменным.}
     @result{} 1

(let ((x 2))             ; @r{Локально её связать.}
  (let ((x 3))           ; @r{И снова связать.}
    (makunbound 'x)      ; @r{Очистка самой внутренней локальной привязки.}
    x))                  ; @r{И прверка: что здесь пусто.}
@error{} Значение символа как переменный является недействительным: x
@end group

@group
(let ((x 2))
  (let ((x 3))
    (makunbound 'x))     ; @r{Очистка внутреннего @code{let} связывания.}
  x)                     ; @r{Теперь оценка внешнего @code{let} связывания.}
     @result{} 2
@end group
@end smallexample
@end defun

@defun boundp variable
Функция возвращает @code{t} если @var{variable} (символ) действительная
переменная и @code{nil}, в обратном случае.

Ниже приведены некоторые примеры (предполагается, что действует динамическое
связывание):

@smallexample
@group
(boundp 'abracadabra)          ; @r{Прверка недействительной переменной.}
     @result{} nil
@end group
@group
(let ((abracadabra 5))         ; @r{Локальная её привязка.}
  (boundp 'abracadabra))
     @result{} t
@end group
@group
(boundp 'abracadabra)          ; @r{Глобально переменная недействительна.}
     @result{} nil
@end group
@group
(setq abracadabra 5)           ; @r{Глобальная привязка.}
     @result{} 5
@end group
@group
(boundp 'abracadabra)
     @result{} t
@end group
@end smallexample
@end defun

@node Defining Variables
@section Определение Глобальных Переменных
@cindex variable definition

  @dfn{Определение переменной} представляет собой конструкцию, которая
  объявляет о намерении использовать символ в качестве глобальной переменной.
  Используются специальные формы @code{defvar} или @code{defconst}, которые
  описаны ниже.

  Определение переменной служит трем целям.  Во-первых, информирует людей,
  которые читают код, что символ @emph{предназначается} для использования
  определенным образом (в качестве переменной).  Во-вторых, информирует
  систему Lisp этого, при необходимости подавая начальное значение и строку
  документации.  В-третьих, предоставляет информацию инструментам
  программирования, таким как @command{etags}, что позволяет найти, где
  была определена переменная.

  Разница между @code{defconst} и @code{defvar} в основном заключена в
  намерениях, служащих для информирования читалей о том, должно ли значение
  когда-либо изменится.  Emacs Lisp фактически не мешает изменять значение
  переменной, определенной с использованием @code{defconst}.  Одно заметное
  различие между этими двумя формами является то, что @code{defconst}
  безоговорочно инициализирует переменную, тогда как @code{defvar}
  инициализирует его только тогда, когда она изначально недействительная.

  Чтобы определить настраиваемую переменную, вы должны использовать
  @code{defcustom} (который вызывает @code{defvar} в качестве подпрограммы).
  @xref{Variable Definitions}.

@defspec defvar symbol [value [doc-string]]
Специальная форма определяет @var{symbol} в качестве переменной.  Обратите
внимание, что @var{symbol} не оценивается; символ, который определяется
должен быть записан в явном виде @code{defvar}.  Переменная помечается как
@dfn{специальная}, а это означает, что должна всегда быть динамически
связаной.  (@pxref{Variable Scoping}).

Если @var{value} указано, и @var{symbol} является недействительным (то есть,
не имеет динамически связанного значения; @pxref{Void Variables}), то
@var{value} оценивается и устанавливается в результате значением компоненты
символа @var{symbol} ячейки значения.  Но если @var{symbol} действительный,
@var{value} не вычисляется, и значение @var{symbol}ов остаётся неизменным.
Если @var{value} опущен, то значение @var{symbol} не изменяется в любом
случае.

Обратите внимание, что определение значения, даже @code{nil}, помечает
переменную в качестве специальной навсегда.  В то время как, если @var{value}
опущено, то переменная помечается специальным локально (т.е. @: в пределах
текущей лексической области видимости, или файла, если находится на верхнем
уровне).  Это может быть полезным для подавления предупреждений байт
компиляции, see @ref{Compiler Errors}.  (ВопросVariables459)

Если @var{symbol} имеет локальную привязку к буферу в текущем буфере,
@code{defvar} устанавливает значение по умолчанию, которое является
буферо-независимое, а не связано с текущим буфером.  Значение устанавливается
по умолчанию, если значение по умолчанию было недействительным.
@xref{Buffer-Local Variables}. (ВопросVariables465)

Если @var{symbol} уже лексически связан (например, если форма @code{defvar}
используется в теле формы @code{let} с включенным лексическим связыванием),
@code{defvar} устанавливает динамическое значение.  Лексическое связывание
остается в силе до его выхода из конструкции связывания.
@xref{Variable Scoping}.

@cindex @code{eval-defun}, and @code{defvar} forms
Когда вы оцениваете форму @code{defvar} верхнего уровня с @kbd{C-M-x} в Emacs
Lisp режиме (@code{eval-defun}), специальная функция @code{eval-defun}
договаривается установить переменную, безусловно, не проверяя, является ли
недействительным его значение.  (ВопросVariables477)

Если указан @var{doc-string} аргумент, он указует строку документации для
переменной (хранится в свойстве @code{variable-documentation} символа).
@xref{Documentation}.

Вот несколько примеров. Эта форма определяет @code{foo}, но не
инициализирует её:

@example
@group
(defvar foo)
     @result{} foo
@end group
@end example

Этот пример инициализирует символ @code{bar} значением @code{23}, и
устанавливает ему строку документации:

@example
@group
(defvar bar 23
  "Нормальное состояние bar.")
     @result{} bar
@end group
@end example

@code{defvar} форма возвращает @var{symbol}, используется на верхнем уровне в
файле, где его значение не имеет значения.

Для более сложного примера использования @code{defvar} без значения,
смотреть @ref{Local defvar example}.
@end defspec

@cindex constant variables
@defspec defconst symbol value [doc-string]
Эта специальная форма определяет @var{symbol} и инициализирует его значеним.
Это информирует человека, читающего код, о том, что @var{symbol} имеет
стандартное глобальное значение, установленное здесь, которые не должно быть
изменены пользователем или другими программами.  Обратите внимание, что
@var{symbol} не оценивается; символ, который должен быть определен явно
печатается в @code{defconst}.  (ВопросVariables518)

@code{defconst} форма, как @code{defvar}, отмечает переменную как
@dfn{специальную}, а это означает, что она всегда должна быть динамически
связанной (@pxref{Variable Scoping}).  Кроме того, отмечается переменная как
рискованная (@pxref{File Local Variables}).

@code{defconst} всегда оценивает @var{value}, и в результате устанавливает значение @var{symbol}.  Если @var{symbol} имеет локальное связывание с буфером
в текущем буфере, @code{defconst} устанавливает значение по умолчанию, а не
буфер локального значения. (Но вы не должны делать буфер локальной привязки
для символа, который определяется с @code{defconst}.) (ВопросVariables528)

Примером использования @code{defconst} является определение Emacs
@code{float-pi}---математической константы @math{pi}, которая не должна быть
изменена кем-либо (не смотря на попытки законодательного органа штата
Индиана).  Однако, как показывает вторая форма, @code{defconst} носит только
рекомендательный характер.

@example
@group
(defconst float-pi 3.141592653589793 "Значение Pi.")
     @result{} float-pi
@end group
@group
(setq float-pi 3)
     @result{} float-pi
@end group
@group
float-pi
     @result{} 3
@end group
@end example
@end defspec

  @strong{Предупреждение:} Если вы используете специальную форму
  @code{defconst} или @code{defvar}, когда переменная имеет локальное
  связывание (сделанную с @code{let} или аргументом функции), это
  устанавливает локальное, а не глобальное связывание.  Это не то, что обычно
  требуется.  Чтобы избежать этого, используйте эти специальные формы на
  верхнем уровне в файле, где обычно не нет локальной привязки, и обязательно
  загрузите файл, прежде чем сделать локальное связывание переменной.

@node Tips for Defining
@section Советы для Надёжного Определения Переменных

  При определении переменной, значением которой является функция или список
  функций, используется имя, которое заканчивается на @samp{-function} или
  @samp{-functions}, соответственно.

  Есть несколько других соглашений именования переменных; вот полный список:

@table @samp
@item @dots{}-hook
Переменная - это обычная ловушка (@pxref{Hooks}).

@item @dots{}-function
Значение является функцией.

@item @dots{}-functions
Значение представляет собой список функций.

@item @dots{}-form
Значение представляет собой форму (выражение).

@item @dots{}-forms
Значение представляет собой список форм (выражения).

@item @dots{}-predicate
Значение предикат---функция одного аргумента, которая возвращает
не-@code{nil} в случае успеха и @code{nil} в другом случае.

@item @dots{}-flag
Значение может принимать значение @code{nil} или нет.  Поскольку такие
переменные часто в конечном итоге приобретают другие значения с течением
времени, эта соглашение настоятельно не рекомендуется. (ВопросVariables592)

@item @dots{}-program
Значение имени программы.

@item @dots{}-command
Значение целая команда оболочки.

@item @dots{}-switches
Значение определяет параметры для команды.

@item @var{prefix}--@dots{}
Переменная предназначена для внутреннего использования и определяется в файле
@file{@var{prefix}.el}.  (Emacs, код, внесенный до 2018 года может следовать
другим соглашениям, которые постепенно сокращаются.)

@item @dots{}-internal
Переменная предназначена для внутреннего использования и определяется в коде
C. (Emacs, код, внесенный до 2018 года может следовать другим соглашениям,
которые постепенно сокращаются.)
@end table

  При определении переменной, всегда учитывается, следует ли пометить её как
  безопасный или опасной; смотреть @ref{File Local Variables}.

  При определении и инициализации переменной, которая содержит сложное
  значение (например, раскладку клавиатуры с привязкой в ней), то лучше
  поместить всё вычисление в @code{defvar}, как здесь:

@example
(defvar my-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map "\C-c\C-a" 'my-command)
    @dots{}
    map)
  @var{docstring})
@end example

@noindent
Этот метод имеет ряд преимуществ.  Во-первых, если пользователь завершает
работу при загрузке файла, переменная предстаёт либо инициализирована
правильно, либо вовсе не инициализирована, а не частично.  Если она ещё
не инициализирована, перезагрузка файла инициализирует её должным образом.
Во-вторых, перезагрузка файл не изменит уже проинициализированную переменную;
что важно, если пользователь запустил ловушки, чтобы изменить часть
содержимого (например, для повторной привязки ключей).  В-третьих, оценка
формы @code{defvar} с @kbd{C-M-x} полностью переинициализирует карту.
(ВопросVariables639)

  Помещение такого колличества кода в @code{defvar} имеет один недостаток:
  помещается строка документации далеко от строки, имени переменной.  Вот
  безопасный способ избежать этого:

@example
(defvar my-mode-map nil
  @var{docstring})
(unless my-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map "\C-c\C-a" 'my-command)
    @dots{}
    (setq my-mode-map map)))
@end example

@noindent
Здесь используются все преимущества помещения инициализации внутри
@code{defvar}, за исключением того, что требуется ввести @kbd{C-M-x} дважды,
один раз на каждой форме, если вы хотите повторно инициализировать
переменную.

@node Accessing Variables
@section Доступ к Значениям Переменных

  Обычный способ ссылки на переменную, записать символ с этим именем.
  @xref{Symbol Forms}.

  Иногда, вы можете ссылаться на переменную, которая определяется только во
  время выполнения.  В этом случае вы не можете указать имя переменной в
  тексте программы.  Вы можете использовать функцию @code{symbol-value} для
  извлечения значения.

@defun symbol-value symbol
Функция возвращает значение, хранящееся в компоненте яцейки значения символа
@var{symbol}.  Здесь хранится текущее значение переменной (динамическое).
Если переменная не имеет локального связывания, это просто её глобальное
значение.  Если переменная является недействительной, сигнализируется ошибка
@code{void-variable}.

Если переменная связана лексически, значение получаемое @code{symbol-value}
не обязательно совпадёт с лексическим значением переменной, которое
определяется лексической средой, а не компонентой ячейки значения символа.
@xref{Variable Scoping}.

@example
@group
(setq abracadabra 5)
     @result{} 5
@end group
@group
(setq foo 9)
     @result{} 9
@end group

@group
;; @r{Здесь символ @code{abracadabra}}
;;   @r{это символ, значение которого проверяется.}
(let ((abracadabra 'foo))
  (symbol-value 'abracadabra))
     @result{} foo
@end group

@group
;; @r{Здесь значение @code{abracadabra},}
;;   @r{устанавливается в @code{foo},}
;;   @r{символ, значение которого проверяется.}
(let ((abracadabra 'foo))
  (symbol-value abracadabra))
     @result{} 9
@end group

@group
(symbol-value 'abracadabra)
     @result{} 5
@end group
@end example
@end defun

@node Setting Variables
@section Установка Значений Переменным

  Обычный способ изменить значение переменной, воспользоватся специальной
  формой @code{setq}.  Когда нужно вычислить переменную во время
  выполнения, используется форма @code{set}.

@defspec setq [symbol form]@dots{}
Особая форма является наиболее распространенным способом изменения значения
переменной.  Каждый @var{symbol} получает новое значение, которое является
результатом оценки соответствующей ему формы @var{form}. Меняется текущее
связывание символа.

@code{setq} не оценивает @var{symbol}; он устанавливает символ, который
напечат.  Уведомляется, что этот аргумент @dfn{цитируется автоматически}.
@samp{q} в @code{setq} означает ``квота (цитата)''.

Значение формы @code{setq} является значение последней оценённой формы
@var{form}.

@example
@group
(setq x (1+ 2))
     @result{} 3
@end group
x                   ; @r{@code{x} теперь имеет глобальное значение.}
     @result{} 3
@group
(let ((x 5))
  (setq x 6)        ; @r{Локальное связывание @code{x}.}
  x)
     @result{} 6
@end group
x                   ; @r{Глобальное значение не изменяется.}
     @result{} 3
@end example

Обратите внимание, что оценивается первая форма @var{form} - устанавливается
первый @var{symbol}, оценивается вторая форма @var{form} - устанавливается
второй @var{symbol}, и так далее:

@example
@group
(setq x 10          ; @r{Обратите внимание, что значение @code{x} устанавливается}
      y (1+ x))     ;   @r{до того как вычисляется значение @code{y}.}
     @result{} 11
@end group
@end example
@end defspec

@defun set symbol value
Функция помещает компоненте символа @var{symbol} в ячейку значения значение
@var{value}.  Так как это функция, а не специальная форма, выражение
написанное для @var{symbol} оценивается, который требуется установить.
Возвращаемое значение @var{value}.

Когда действует правило динамического связывания переменной (по умолчанию),
@code{set} имеет тот же эффект, как и @code{setq}, за исключением того факта,
что @code{set} вычисляет свой аргумент @var{symbol}, тогда как @code{setq}
нет.  Но когда переменная лексически связана, @code{set} влияет на её
@emph{динамическое} значение, в то время как @code{setq} влияет на её текущее
(лексическое) значение.  @xref{Variable Scoping}.  (ВопросVariables779)

@example
@group
(set one 1)
@error{} Значение символа как переменный является недействительным: one
@end group
@group
(set 'one 1)
     @result{} 1
@end group
@group
(set 'two 'one)
     @result{} one
@end group
@group
(set two 2)         ; @r{@code{two} принимает значение символа @code{one}.}
     @result{} 2
@end group
@group
one                 ; @r{@code{one}, который был установлен.}
     @result{} 2
(let ((one 1))      ; @r{@code{one} локальное связываие.}
  (set 'one 3)      ;   @r{устанавливает не глобальное значение.}
  one)
     @result{} 3
@end group
@group
one
     @result{} 2
@end group
@end example

Если @var{symbol} на самом деле не символ, сигнализируется ошибка
@code{wrong-type-argument}  (Неправильный тип аргумента).

@example
(set '(x y) 'z)
@error{} Wrong type argument: symbolp, (x y)
@end example
@end defun

@node Watching Variables
@section Запуск Функции при Изменении Переменной
@cindex variable watchpoints
@cindex watchpoints for Lisp variables

Иногда полезно принимать какое-либо действие, когда переменная изменяет свое
значение.  Объект точки наблюдения предоставляет средства для этого.
Некоторое возможные варианты использования этой функции включает
синхронизацию отображения с параметрами переменной, и вызов отладчика
для отслеживания неожиданных изменений переменной
(@pxref{Variable Debugging}).  (ВопросVariables831)

Следующие функции могут быть использованы для управления функциями наблюдения
для переменной и запросов к ней.

@defun add-variable-watcher symbol watch-function
Функция организует для функции @var{watch-function} вызов всякий раз, когда
@var{symbol} модифицируется.  Изменения с помощью псевдонимов
(@pxref{Variable Aliases}) будут иметь тот же эффект.

@var{watch-function} будет вызываться с 4-мью аргументами:
(@var{symbol} @var{newval} @var{operation} @var{where}).

@var{symbol} - переменная которая изменяется.
@var{newval} - присваимое значение.
@var{operation} - символ, представляющий вид изменения, одно из следующего:
`set', `let', `unlet', `makunbound', и `defvaralias'.
@var{where} - представляет собой буфер, если меняется локальное значение
переменной буфера и @code{nil} в другом случае.
@end defun

@defun remove-variable-watch symbol watch-function
Функция удаляет функцию @var{watch-function} из списка наблюдателей за
@var{symbol}-ами.
@end defun

@defun get-variable-watchers symbol
Функция возвращает список активных функций наблюдателей за @var{symbol}.
@end defun

@subsection Limitations

Есть несколько способов, которыми переменная может быть изменена (или, по
крайней мере, выглядеть изменённой) не заметно для наблюдающих функций.

Так как наблюдение прикрепленно к символам, модификация объектов
содержащихся в переменных (например, с помощью функции
@pxref{Modifying Lists} модификация списков) не отслеживается этим
механизмом.

Кроме того, C код может изменять значения переменных напрямую,
минуя механизм наблюдения.

Незначительное ограничение этой функции, опять же, из-за того, что всё
внимание уделяется символу как переменной динамического диапазона.  Это
не создает особые трудности, поскольку изменения переменных в лексической
области можно легко обнаружить путем проверки кода (в отличие от
динамического связывания переменных, которые могут быть изменены с помощью
любого кода относящегося к ним, @pxref{Variable Scoping}).
(ВопросVariables879)


@node Variable Scoping
@section Правила Области Действия для Привязки Переменной
@cindex scoping rule

  При создании локальной привязки для переменной, связывание действует в
  ограниченной части программы (@pxref{Local Variables}).  Этот раздел
  описывает именно то, что это значит.

@cindex scope
@cindex extent
  Каждое локальное связывание имеет определенную @dfn{кучу} и
  @dfn{сокучность}.  @dfn{Кача} относится к тому @emph{где} в текстовом
  исходном коде, связывание может быть доступно.  @dfn{Сокучность}
  относится к тому @emph{когда} при выполнении программы существует
  связывание.

@cindex dynamic binding
@cindex dynamic scope
@cindex dynamic extent
  По умолчанию локальные привязки, создаваемые Emacs, являются
  @dfn{динамической привязкой}.  Такое связывание имеет
  @dfn{динамическую кучу}, а это означает, что любая часть программы может
  потенциально получить доступ к связыванию переменной.  Также имеется
  @dfn{динамическая протяжённость}, а это означает, что связывание
  длится в то время пока связывающая конструкция (например, тело формы
  @code{let}) выполняется.

@cindex lexical binding
@cindex lexical scope
@cindex indefinite extent
  Emacs может дополнительно создавать @dfn{лексическое связывание}.
  Лексическое связывание имеет @dfn{лексическую кучу}, а это означает, что
  любая ссылка на переменную должна быть расположена в текстуальных пределах
  связывающей конструкции@footnote{За некоторыми исключениями; например,
  лексические связывания можно также получить в отладчике Lisp.}.  Также
  имеется @dfn{неопределённая протяжённость}, а это означает, что при
  некоторых обстоятельствах, связка может существовать даже после завершения
  выполнения связывающей конструкции, с помощью специальных объектов,
  называемых @dfn{замыканием}.

  Следующие подразделы описывают динамическое связывание и лексические
  связывание более подробно, а также то, как включить лексическое связывание
  в программах Emacs Lisp.

@menu
* Dynamic Binding::   Cвязывания локальных переменных в Emacs (по умолчанию).
* Dynamic Binding Tips::    Как избежать проблем с обязательным динамическим
                            связыванием.
* Lexical Binding::         Другой тип локального связывания переменной.
* Using Lexical Binding::   Как включить лексическое связывание.
@end menu

@node Dynamic Binding
@subsection Динамическое Связывание

  По умолчанию Emacs осуществляет динамическое связывание для локальных
  переменных.  Когда переменная динамически связана, его текущее связывание в
  любом момент выполнение программы Lisp -  просто последняя динамическая
  локальная привязка для, или глобальное связывание, если нет такой локальной
  привязки.

  Динамические привязки имеют динамическую кучу и сокучность, как показано
  в следующем примере:

@example
@group
(defvar x -99)  ; @r{@code{x} получает начальное значение @minus{}99.}

(defun getx ()
  x)            ; @r{@code{x} используется свободно в этой функции.}

(let ((x 1))    ; @r{@code{x} динамически связан.}
  (getx))
     @result{} 1

;; @r{После того, как оценена форма @code{let}, @code{x} возвращается к}
;; @r{своему предыдущему значению, которое устанавливается в @minus{}99.}

(getx)
     @result{} -99
@end group
@end example

@noindent
Функция @code{getx} относится к @code{x}.  Это ссылка @dfn{свободна}, в том
смысле, что нет назначений для @code{x} в этой @code{defun} конструкции.
Когда вызывается функция @code{getx} внутри формы, в которой @code{let}
связывает (динамически) @code{x}, извлекается локальное значение
(то есть, 1). Но когда вызывается @code{getx} вне формы @code{let}, получает
глобальное значение @code{x} (то есть, @minus{}99).

  Вот еще один пример, который иллюстрирует установление динамического
  связывание переменной с помощью @code{setq}:

@example
@group
(defvar x -99)      ; @r{@code{x} получает начальное значение @minus{}99.}

(defun addx ()
  (setq x (1+ x)))  ; @r{Добавление к @code{x} 1 и установление нового}
                    ; @r{значения @code{x}.} 

(let ((x 1))
  (addx)
  (addx))
     @result{} 3           ; @r{Два вызова @code{addx} добавят к @code{x}}
                           ; @r{1 дважды.}

;; @r{После того, как оценена форма @code{let}, @code{x} возвращается к}
;; @r{своему предыдущему значению, которое @minus{}99.}

(addx)
     @result{} -98
@end group
@end example

  Динамическое связывание осуществляется в Emacs Lisp простым способом.
  Каждый символ имеет компоненту - ячейку значения, которая определяет его
  текущее динамическое значение (или его отсутствие).
  @xref{Symbol Components}.  Когда символа касается локальное динамическое
  связывание, Emacs записывает содержимое компоненты ячейки значения
  (или его отсутствие) в стек и сохраняет уже новое локальное значение в
  компоненте ячейки значения.  Когда связывающая конструкция заканчивает
  своё влияние (выполнение), Emacs выталкивает старое значение из стека и
  помещает его обратно компоненте символа в ячейку значения.

@node Dynamic Binding Tips
@subsection Правильное Использование Динамического Связывания

  Динамическое связывание является мощным средством, поскольку позволяет
  программам ссылаться на переменные, которые не определены в пределах своей
  локальной текстовой области.  Однако, если используеть это без ограничений,
  это может сделать программы трудными для понимания.  Есть два чистых
  способов использовать эту технику:

@itemize @bullet
@item
Если переменная не имеет глобального определения, используйте её в качестве
локальной переменной только в пределах связывающей конструкции, такой, как
тело формы @code{let}, где переменная была связана.  Если следовать этому
соглашению в течение всей программы, то значение переменной не будет влиять,
и не будут затронуто, любым использованием одного и того же символа
переменной в другом месте в программе.

@item
В противном случае, определите переменную используя @code{defvar},
@code{defconst} (@pxref{Defining Variables}), или @code{defcustom}
(@pxref{Variable Definitions}).  Как правило, это определение должно быть на
высшем уровне в файле Emacs Lisp.  Насколько это возможно, переменная должна
включать в себя строку документации, которая объясняет смысл и назначение
переменной.  Вы должны также выбрать имя переменной, чтобы избежать
конфликтов имен (@pxref{Coding Conventions}).

Затем вы можете связать переменную в любом месте программы, зная достоверно,
какой будет эффект.  Везде, где встречается переменная, будет легко вернуться
к её определению, например, с помощью команды @kbd{C-h v} (при условии, что
определение переменной было загружено в Emacs).
@xref{Name Help,,, emacs, The GNU Emacs Manual}.

Например, обычно используют локальные привязки для настраиваемых переменных,
таких как @code{case-fold-search}:

@example
@group
(defun search-for-abc ()
  "Поиск строки \"abc\", игнорируя регистр букв."
  (let ((case-fold-search t))
    (re-search-forward "abc")))
@end group
@end example
@end itemize

@node Lexical Binding
@subsection Лексическе Связывание

  Лексический связывание был введен в Emacs, в качестве дополнительной
  функции, в версии 24.1.  Ожидается, что его важность возрастает со
  временем.  Лексическое связывание открывает намного больше возможностей для
  оптимизации, так что программы, использующих его, скорее всего, работать
  юудут быстрее в будущих версиях Emacs.  Лексическое связывание также
  является более совместимо с параллелизмом, который был добавлен к Emacs в
  версии 26.1.

  Лексически-связанная переменная имеет @dfn{лексическую кучу}, а это
  означает, что любая ссылка на переменную должна быть расположена в
  текстуальных пределах конструкции связывания. Вот пример
@iftex
(смотрите следующий подраздел о том, как на самом деле включить
лексическое связывание):
@end iftex
@ifnottex
(@pxref{Using Lexical Binding}, о том, как на самом деле включить
лексическое связывание):
@end ifnottex

@example
@group
(let ((x 1))    ; @r{@code{x} лексически связан.}
  (+ x 3))
     @result{} 4

(defun getx ()
  x)            ; @r{@code{x} используется свободно в этой функции.}

(let ((x 1))    ; @r{@code{x} лексически связан.}
  (getx))
@error{} Значение символа как переменный является недействительным: x
@end group
@end example

@noindent
Здесь переменная @code{x} не имеет глобального значения.  Когда эта
переменная лексически связывается в форме @code{let}, она может быть
использован в текстовых пределах этой @code{let} формы.  Но эта переменная
@emph{not} может быть использована в функции @code{getx}, вызываемой из формы
@code{let}, так как определение функции @code{getx} происходит вне этой самой
@code{let} формы.

@cindex lexical environment
  Вот как работает лексическая привязка.  Каждая связывающая конструкция
  определяет @dfn{лексическую среду}, определяя переменным, которые связаны
  внутри этой конструкции и их локальные значения.  Когда оценщику Lisp
  требуется текущее значение переменной, ищется вначале это значение в
  в лексической среде и если значение переменной не указано там, то ищется
  значение в компоненте символа ячейки значения, в которой хранится
  динамически связываемое значение.

  (Внутренне, лексическая среда реализована посредствам ассоциативного
  списка, с парами символ-значение, причём последний элемент этого списка,
  является символом @code{t}, а не cons-ячейкой.  Такой ассоциативный список
  может быть передан в качестве второго аргумента функции @code{eval}, чтобы
  указать лексическую среду, в которой оценивается форма @xref{Eval}.
  Большинство программ Emacs Lisp, не должны взаимодействовать
  непосредственно с лексической средой таким образом;... только
  специализированные программы, такие как отладчики).

@cindex closures, example of using
  Лексическое связывание не имеет сокучности.  Даже после завршения
  выполнения привязки, его лексическая среда может быть ``удержана в поле''
  в Lisp объекте под названием @dfn{замыкание}.  Замыкание создается при
  определении именованной или анонимной функции с включённым лексическим
  связыванием.  @xref{Closures}, для деталей.

  Когда замыкание вызывается как функция, любые ссылки на лексически
  связанные в пределах её определения переменные, используют нераспределенную
  лексическую среду. Вот пример:

@example
(defvar my-ticker nil)   ; @r{Будет использоваться эта динамически связанная}
                         ; @r{переменная для хранения замыкания.}

(let ((x 0))             ; @r{@code{x} лексически связана.}
  (setq my-ticker (lambda ()
                    (setq x (1+ x)))))
    @result{} (closure ((x . 0) t) ()
          (setq x (1+ x)))

(funcall my-ticker)
    @result{} 1

(funcall my-ticker)
    @result{} 2

(funcall my-ticker)
    @result{} 3

x        ; @r{Обратите внимание, что @code{x} не имеет глобального значения.}
@error{} Значение символа как переменной является недействительным: x
@end example

@noindent
@code{let} привязка определяет лексическую среду, в которой переменная
@code{x} локально устанавливается в 0.  В этой конструкции связывания,
определяется лямбда-выражение, которое приращивает начальному значение
@code{x} единицу и возвращает измененное значение.  Это лямбда-выражение
автоматически включается в замыкание, в котором лексическая среда существует
даже после того, как покинута  @code{let} конструкция связывания.  Каждый
раз, когда оценивается замыкание, увеличивается @code{x}, используя
связывание @code{x} в этой лексической среде.

  Следует отметить, что в отличие от динамически связанных переменных,
  которые привязаны к самому объекту символа, отношения между лексически
  связанными переменными и символами присутствуют только в интерпретаторе
  (или компиляторе).  Таким образом, функция, которые принимают символьный
  аргумент (как @code{symbol-value}, @code{boundp}, и @code{set}) может
  только получить или модифицировать динамически связанную переменную (то
  есть содержимое компоненты своего символа ячейки значения).

@node Using Lexical Binding
@subsection Использование Лексического Связывания

  При загрузке файла Emacs Lisp или оценки буфера Lisp, лексическая связь
  включена, если локальная переменная буфера @code{lexical-binding}
  установлена в не-@code{nil}:

@defvar lexical-binding
Если эта локальная переменная буфера учтановлена в не-@code{nil}, Emacs Lisp
оценивает файлы и буферы по правилам лексического связывания вместо
динамического.  (Тем не менее, специальные переменные все еще динамически
связаны; см. Ниже).  Если установлена в @code{nil}, используется динамическое
связывание для всех локальных переменных.  Эта переменная обычно
устанавливается для всего файла Emacs Lisp, как локальная переменная файла.
(@pxref{File Local Variables}).  Обратить внимание, что в отличие от других
таких переменных, она одна должен быть находится в первой строке файла.
@end defvar

@noindent
При оценке кода Emacs Lisp непосредственно с помощью вызова @code{eval},
правило лексического связывания действует, если аргумент @var{lexical}
функции @code{eval} установлен в не-@code{nil}.  @xref{Eval}.

@cindex special variables
  Даже когда лексическая связь действует, некоторые переменные продолжают
  связываться динамически.  Они называются @dfn{специальные переменные}.
  Каждая переменная, которая была определена с использованием @code{defvar},
  @code{defcustom} или @code{defconst} принадлежат к типу специальных
  переменных (@pxref{Defining Variables}).  Все остальные переменные могут
  подвергаться лексическому связыванию.

@anchor{Local defvar example}
Используя @code{defvar} без значения, то можно динамически связать переменную
только в одном файле, или только в одной части файла, при этом использовать
её лексическую привязку в другом месте. Например:

@example
@group
(let (_)
  (defvar x)      ; @r{Let-привязка @code{x} динамическая внутри конструкции}
  (let ((x -99))  ; @r{Это динамичное связывание @code{x}.}
    (defun get-dynamic-x ()
      x)))

(let ((x 'lexical)) ; @r{Это лексическое связывание @code{x}.}
  (defun get-lexical-x ()
    x))

(let (_)
  (defvar x)
  (let ((x 'dynamic))
    (list (get-lexical-x)
          (get-dynamic-x))))
    @result{} (lexical dynamic)
@end group
@end example

@defun special-variable-p symbol
Эта функция возвращает не-@code{nil}, если @var{symbol} содержит специальную
переменную (то есть, значение переменной определенной с использованием
@code{defvar}, @code{defcustom}, или @code{defconst}).  В противном случае,
возвращаемое значение @code{nil}.
@end defun

  Использование специальной переменной в качестве формального аргумента в
  функции не рекомендуется.  Это приводит к возникновению неопределенного
  поведения при включённом правиле лексического связывания (это может
  использовать как лексическое связывание, так и динамическое связывание в
  с неопределённым приоритетом).

  Использование в программе Emacs Lisp лексического связывания легко
  реализуется.  Во-первых, устанавливается значение локальной переменной
  файла @code{lexical-binding} в @code{t} в строке заголовка исходного файла
  Emacs Lisp (@pxref{File Local Variables}).  Во-вторых, проверяется каждая
  переменная в программе, которая должна быть динамически связана, так что
  бы случайно не связать её лексически.

@cindex free variable
@cindex unused lexical variable
  Простой способ выяснить, каким переменным необходимо определение переменной
  - это байт-компиляции исходного файла.  @xref{Byte Compilation}.  Если
  неспециальная переменная используется вне формы @code{let}, байт-компилятор
  будет предупреждать о назначении или ссылки свободной переменной.  Если
  неспециальная переменная связана, но не используется в форме @code{let},
  байт-компилятор будет предупреждать о неиспользованной лексически связанной
  переменной.  Байт-компилятор также выдаст предупреждение, если использовать
  специальную переменную в качестве аргумента функции.

  (Чтобы отключить предупреждения байт-компилятора о неиспользуемых
  переменных, просто нужно использовать имя переменной, которое начинается с
  символа подчеркивания.  Байт-компилятор интерпретирует это как признак
  того, что это будет использоваться неизвестная переменная.)

@node Buffer-Local Variables
@section Локальные Переменные Буфера
@cindex variable, buffer-local
@cindex buffer-local variables

  Глобальные и локальные привязки переменных встречаются в большинстве
  языков программирования в той или иной форме.  Emacs, однако, также
  поддерживает дополнительные, необычные виды связываения переменных, такие
  как @dfn{локальные буферные} привязки, которые применяются только в одном
  буфере.  Имея различные значения для переменной в различных буферах
  является важным методом настройки.  (Переменные могут также иметь привязки,
  которые являются локальными для каждого терминала.
  @xref{Multiple Terminals}.)

@menu
* Intro to Buffer-Local::       Введение и соглашения.
* Creating Buffer-Local::       Создание и уничтожение локальной привязки буфера.
* Default Value::               Значения по умолчанию для буферов не имеющих
                                собственных локальных значений буфера.
@end menu

@node Intro to Buffer-Local
@subsection Введение в Локальные Переменные Буфера

  Локальная переменная буфера имеет локальное связывание с конкретным
  буфером.  Связывание действует, когда этот буфер текущий; в противном
  случае, связывание не действует.  Если вы установите переменную во время
  её локального связывания к буферу, по сути, новое значение заменит значение
  только для этой связки, и другие её связывания не затронутся.  Это
  означает, что изменение видно только в буфере, где вы его сделали.

  Обычная привязка переменной, которая не связывается с каким-либо
  конкретным буфером, называется @dfn{привязкой по умолчанию}.  В
  большинстве случаев это глобальное связывание.

  Переменная может иметь локальную привязку для конкретного буфера,
  действующую только в этом конкретном буфере.  Связывание по умолчанию
  является общим для всех буферов, и вступает в силу, если текущий буфер не
  имеет своего собственного связывания для переменной.  (Это относиться ко
  всем вновь созданным буферам.)  Если вы установите переменную в буфере,
  которая не имеет локального связывания буфера, это устанавливает
  обязательное связывание по умолчанию, так что новое значение видно во всех
  буферах, в которых действует для переменной локальное связование буфера по
  умолчанию.

  Наиболее распространено использование локальной привязки буфера в основных
  режимах для изменения переменных, которые контролируют поведение команд.
  Например, режим С и режим Lisp оба устанавливают переменную
  @code{paragraph-start}, чтобы указать, что только пустые строки служат
  разделением параграфов.  Они делают это посредствам локальной переменной
  буфера, которая содержит признак использования режима С или Lisp,
  устанавливая ей определённое новое значение для каждого из режимов.
  @xref{Major Modes}.

  Обычный способ создать локальное связывание буфера использовать
  @code{make-local-variable}, как правило используемое командами основного
  режима.  Это связывание влияет только на текущий буфер и все другие буферы
  (включая те, которые еще будут созданы), которые будут разделять это
  значение, как значение по умолчанию, если не будут явно определять свои
  собственные локальные привязки буфера для переменной.

@cindex automatically buffer-local
  Более мощная операция, помечается переменная как
  @dfn{автоматическая локальная буфера} использовать средство
  @code{make-variable-buffer-local}.  Можно представить это, как определение
  локальной переменной для всех буферов, но даже тех, которые будут созданы.
  Точнее, эффект состоит в том, что устанавливается автоматическая переменная
  делая эту переменную локальной для текущего буфера, если это ещё не так.
  Все буфера обычно используют значение переменной из привязки по умолчанию,
  но установка переменной таким образом, создаёт локальную привязку для
  текущего буфера.  Новое значение сохраняется в локальном связывания буфера,
  оставляя нетронутым привязку по умолчанию.  Это означает, что значение по
  умолчанию не может быть изменено используя @code{setq} в любом из буферов;
  единственный способ изменить это, использовать @code{setq-default}.

  @strong{Предупреждение:} Когда переменная имеет локальную привязку буфера в
  одном или нескольких буферах, @code{let} добавляет своё связывание, пока
  конструкция в действии.  Например, если текущий буфер имеет локальное
  значение переменной буфера, @code{let} временно добавляет ещё одну привязку
  затеняя это значение.  Если нет локальной привязки переменной буфера,
  @code{let} производит дополнительную привязку, затеняя значение по
  умолчанию.  Если внутри конструкции @code{let} происходит переход в другой
  буфер, делая его текущим, в котором существуют другие привязки, по сути,
  теряется связывание @code{let}.  И если выход из @code{let} происходит при
  использовании другого буфера в качестве текущего, отмена связывания не
  происходит (хотя это будет происходить должным образом). Ниже приведен
  пример для иллюстрации:

@example
@group
(setq foo 'g)
(set-buffer "a")
(make-local-variable 'foo)
@end group
(setq foo 'a)
(let ((foo 'temp))
  ;; foo @result{} 'temp  ; @r{Выполняется связывание в буфере @samp{a} в конструкции @samp{let}}
  (set-buffer "b")
  ;; foo @result{} 'g     ; @r{Получается глобальное значение, так как foo не имеет значение локальной привязки в буфере @samp{b}}
  @var{body}@dots{})
@group
foo @result{} 'g        ; @r{после выхода восстановлено локальное значение
буфера @samp{a},}
                 ; @r{но мы не видим, этого изменений в буфере @samp{b}}
@end group
@group
(set-buffer "a") ; @r{Проверка того, что локальное значение восстановлено}
foo @result{} 'a
@end group
@end example

@noindent
Обратите внимание, что ссылки на @code{foo} в @var{body} доступны локальному
связыванию буфера @samp{b}.  (ВопросVariables1377)

  Когда определяются локальные переменные файла, они становятся локальными
  переменными буфера при посещении этого файла.
  @xref{File Variables,,, emacs, The GNU Emacs Manual}.

  Локальную переменную буфера, нельзя сделать локальной переменной терминала
  (@pxref{Multiple Terminals}).

@node Creating Buffer-Local
@subsection Создание и Удаление Локального Связывания Буфера

@deffn Command make-local-variable variable
Функция создает локальное связывание буфера в текущем буфере для
@var{variable} (символа).  Другие буферы не затрагиваются.  Возвращаемое
значение @var{variable}.

Локальное связывание буфера связывает значение @var{variable} с прежним
значением @var{variable}.  Если @var{variable} была недействительной
переменной, она остаётся также недействительной.

@example
@group
;; @r{В буфере @samp{b1}:}
(setq foo 5)                ; @r{Влияет на все буферы.}
     @result{} 5
@end group
@group
(make-local-variable 'foo)  ; @r{Сейчас это локальная привязка @samp{b1}.}
     @result{} foo
@end group
@group
foo                         ; @r{Значение @samp{foo}}
     @result{} 5                   ;   @r{подхватывается.}
@end group
@group
(setq foo 6)                ; @r{Изменение значения}
     @result{} 6                   ;   @r{@samp{b1}.}
@end group
@group
foo
     @result{} 6
@end group

@group
;; @r{В буфере @samp{b2}, значение не изменилось.}
(with-current-buffer "b2"
  foo)
     @result{} 5
@end group
@end example

Создание связывания локальной переменной буфера @code{let}-свзыванием этой
переменной не работает надежно, если буфер, в котором это происходит,
является текущим, пока конструкция @code{let} имеет силу.  Это происходит
потому, что @code{let} не делает различия между различными видами связывания;
просто создаёт связывание переменной.

Ошибочно, делать доступную только для чтения константу, локальной переменной
буфера.  @xref{Constant Variables}.

Если переменная является локальной переменной терминала
(@pxref{Multiple Terminals}), эта функция сигнализирует об ошибке.  Эти
переменные также не могут иметь локальные привязки буфера.

@strong{Предупреждение:} @code{make-local-variable} не используется для
переменных ловушек.  Переменная ловушка автоматически становится локальной
переменной буфера по необходимости, когда используется аогумент @var{local}
для @code{add-hook} или @code{remove-hook}.
@end deffn

@defmac setq-local variable value
Макрос создает локальное связывание переменной буфера в текущем буфере для
переменной @var{variable}, и связывает её с локальное значением буфера
@var{value}.  Это эквивалентно вызову @code{make-local-variable} с
последующим @code{setq}.  @var{variable} печатается символом без кавычек.
@end defmac

@deffn Command make-variable-buffer-local variable
Функция отмечает переменную @var{variable} (символ) как автоматическую
локальную буфера, так что любая последующая попытка установить эту
переменную, делает её локальной для текущего буфера.  В отличие от
@code{make-local-variable}, с которой её часто путают, это не может быть
отменено, и влияет на поведение переменной во всех буферах
(ВопросVariables1460).

Особенностью этой функции является то, что связывание переменной (с
@code{let} или другими связующими конструкциями) не создает локального
связывания  буфера для неё.  Только определение переменной (используя
@code{set} или @code{setq}), в то время как переменная не имеет
никагого @code{let}-подобного связывания в текущем буфере во время
связывания.

Если переменная @var{variable} не имеет значения по умолчанию, то вызов этой
команды присваивает значение по умолчанию @code{nil}.  Если @var{variable}
уже имеет значение по умолчанию, это значение остается неизменным.
Впоследствии вызов @code{makunbound} к переменной @var{variable} приведет к
унчтожению локальной привязки значения к буферу и оставит значение по
умолчанию без изменений.  (ВопросVariables1475)

Возвращаемое значение @var{variable}.

Это ошибка, чтобы сделать константу или переменную, доступную только для
чтения, локальной переменной буфера(ВопросVariables1480).  @xref{Constant Variables}.

@strong{Предупреждение:} Не нужно использовать
@code{make-variable-buffer-local} для установления опциональных переменных
пользователя, просто потому, что пользователь @emph{может} захотеть, чтобы
настроить их по-разному в различных буферах.  Пользователь может создать
любую локальную переменную, когда захочет.  Лучше оставить выбор за ним.

Следует использовать @code{make-variable-buffer-local} когда важно, что
никакие два буфера никогда не будут разделять одну и ту же привязку.
Например, когда переменная используется для внутренних целей в Lisp
программе, которая зависит от наличия отдельных значений в отдельных буферах,
решить это с помощью @code{make-variable-buffer-local} может быть лучшим
решением.
@end deffn

@defmac defvar-local variable value &optional docstring
Макрос определяет @var{variable} в качестве переменной с начальным значением
@var{value} и строкой документации @var{docstring}, и помечает её как
автоматическую локальную переменную буфера.  Это эквивалентно вызову
@code{defvar} с последующим @code{make-variable-buffer-local}.  Аргумент
@var{variable} должен быть символом без кавычек.
@end defmac

@defun local-variable-p variable &optional buffer
Возвращает @code{t}, если @var{variable} является локальной переменной буфера
@var{buffer} (по умолчанию текущий буфер); в противном случае, @code{nil}.
@end defun

@defun local-variable-if-set-p variable &optional buffer
Возвращает @code{t}, если @var{variable} является либо имеющая локальную
привязку или является автоматической переменной буфера @var{buffer}.  В
противном случае возвращается @code{nil}.  Если параметр @var{buffer} опущен
или @code{nil}, по умолчанию устанавливается текущий буфер.
@end defun

@defun buffer-local-value variable buffer
Функция возвращает значение локального связывания переменной буфера
@var{variable} (символ) в буфере @var{buffer}.  Если @var{variable} не имеет
локального связывания буфера в буфере @var{buffer}, возвращается значение по
умолчанию (@pxref{Default Value}) переменной @var{variable} вместо этого.
@end defun

@defun buffer-local-variables &optional buffer
Функция возвращает список, описывающий локальные переменные буфера
@var{buffer}.  (Если @var{buffer} опущен, используется текущий буфер.).
Как правило, каждый элемент списка имеет вид
@w{@code{(@var{sym} . @var{val})}}, где @var{sym} является локальной
переменной (символ) буфера и @var{val} является её локальным значением
буфера.  Но когда локальное связывание переменной буфера @var{buffer}
является недействительным, её элемент списка это просто @var{sym} без
значения.

@example
@group
(make-local-variable 'foobar)
(makunbound 'foobar)
(make-local-variable 'bind-me)
(setq bind-me 69)
@end group
(setq lcl (buffer-local-variables))
    ;; @r{Во-первых, встроенные локальные переменные во всех буферах:}
@result{} ((mark-active . nil)
    (buffer-undo-list . nil)
    (mode-name . "Fundamental")
    @dots{}
@group
    ;; @r{Далее, не встроенные локальные переменные буфера.}
    ;; @r{Это одна недействительная локальная переменная буфера:}
    foobar
    ;; @r{Это другая действительная локальная переменная буфера:}
    (bind-me . 69))
@end group
@end example

Обратите внимание, что сохранение новых значений в @sc{cdr}ов этих
cons-ячеек этого списка @emph{не} изменяет значения локальных переменных
буфера.
@end defun

@deffn Command kill-local-variable variable
Функция удаляет локальное связывание (если таковое имеется) для переменной
@var{variable} (символ) в текущем буфере.  В результате связывание переменной
@var{variable} по умолчанию становится видимым в этом буфере.  Это обычно
приводит к изменению значения переменной @var{variable}, так как значение по
умолчанию, как правило, отличается от только что удалённого локального
значения переменной буфера.

Если удаляется локальное связывание переменной буфера, которая автоматически
устанавливается локальной переменной буфера, это устанавливает переменной
значение по умолчанию, видимое в текущем буфере.  Тем не менее, если снова
установить значение этой переменной, это вновь создаст локальное связывание
переменной буфера.

@code{kill-local-variable} returns @var{variable}.

Функция является командой, потому что иногда бывает полезно как удалять, так
и создавать в интерактивном режиме локальное связывание переменных буфера.
@end deffn

@cindex local variables, killed by major mode
@defun kill-all-local-variables
Функция устраняет все локальные привязки переменных текущего буфера, не
включая связывание для переменных, отмеченных как постоянные и локальные
функции ловушек, у которых свойство @code{permanent-local-hook} установленно
в не-@code{nil} (@pxref{Setting Hooks}).  В результате, в буфере будут
доступны значения по умолчанию большинства переменных.

Функцией также сбрасывается определенная другая информация, относящуюся к
буферу: устанавливается локальная раскладка клавиатуры в @code{nil},
синтаксис таблица устанавливается в @code{(standard-syntax-table)}, таблица
регистра устанавливается в @code{(standard-case-table)} и таблица Abbrev
устанавливается в @code{fundamental-mode-abbrev-table}.

Самое первое, что эта функция делает запускает обычную ловушку
@code{change-major-mode-hook} (смотри ниже).

Каждая команда основного режима начинается с вызова этой функции, которая
имеет эффект переключения на основной режим и стирание большинства эффектов
предыдущего основного режима.  Для того, чтобы гарантировать, что это делает
свою работу, переменные, которые устанавливают основные режимы не должны быть
отмечены как постоянные.

@code{kill-all-local-variables} возвращает @code{nil}.
@end defun

@defvar change-major-mode-hook
Функция @code{kill-all-local-variables} запускает эту обычную ловушку, до
выполнения любых действий.  Это дает возможность основному режиму устроить
всё необходимое, когда пользователь переходит на другой основной режим.  Это
также полезно для удаления специфичных дополнительных режимов буфера, если
пользователь изменяет основной режим.

Для достижения наилучших результатов, переменную делают локальной переменной
буфера, так что она исчезнет после того, как сделает свою работу и не будет
мешать в последующем основном режиме.  @xref{Hooks}.
@end defvar

@cindex permanent local variable
@dfn{Постоянной} локальной переменной буфера переменная становится, если
переменная (символ) имеет свойство @code{permanent-local}, установленное в
не-@code{nil}.  На такие переменные и их привязки не влияют функции
@code{kill-all-local-variables}, таким образом, не удаляются их связывание
при изменении основных режимов.  Постоянные локальные переменные подходят для
данных, относящихся к тому, откуда файл был получен или куда его сохранить,
а не для тех, которые участвуют при редактировании содержимого.

@node Default Value
@subsection Значение Локальной Переменной Буфера по Умолчанию
@cindex default value

  Глобальное значение локальной привязки переменной буфера также называют
  значением @dfn{по умолчанию}, потому что это значение действует, когда ни
  текущий буфер, ни выбранный фрейм не имеет своего собственного связывания
  для переменной.

  Функции @code{default-value} и @code{setq-default} используют для доступа и
  изменения значения переменной по умолчанию, независимо от того, имеет ли
  текущий буфер локальное связывания переменной.  Например, можно
  использовать @code{setq-default} для изменения настройки по умолчанию
  @code{paragraph-start} для большинства буферов; и это сработает даже тогда,
  когда буфер находится в C или Lisp режиме, который имеет локальное значение
  буфера для этой переменной.

@c Emacs 19 feature
  Специальные формы @code{defvar} и @code{defconst} также устанавливают
  значение по умолчанию (если они вообще устанавливают переменную), а не
  какое-либо локальное значение буфера.

@defun default-value symbol
Функция возвращает значение по умолчанию символа(-ов) @var{symbol}.  Это
значение, которое рассматривается в буферах и фреймах, которые не имеют своих
собственных значений для этой переменной.  Если @var{symbol} не локальная
переменная буфера, это эквивалентно @code{symbol-value}
(@pxref{Accessing Variables}).
@end defun

@c Emacs 19 feature
@defun default-boundp symbol
Функция @code{default-boundp} определяет, является ли значение по умолчанию
@var{symbol} недействительным.  Если @code{(default-boundp 'foo)} возвращает
@code{nil}, то @code{(default-value 'foo)} выдаст ошибку.

@code{default-boundp} соотносится с @code{default-value}, как @code{boundp}
соотносится с @code{symbol-value}.
@end defun

@defspec setq-default [symbol form]@dots{}
Эта специальная форма присваивает каждому символу @var{symbol} новое
значение по умолчанию, которое является результатом вычисления
соответствующей ему формы @var{form}.  Символ @var{symbol} не оценивается,
но оценивается форма @var{form}.  Возвращаемое значение формы
@code{setq-default} является значением последней оценённой формы @var{form}.

Если @var{symbol} не является локальной привязкой буфера для текущего буфера,
и не отмечен как автоматическая локальная переменная буфера,
@code{setq-default} имеет тот же эффект, как и @code{setq}.  Если
@var{symbol} является локальной переменной буфера для текущего буфера, то это
изменяет значение, которое другие буфера будут использовать по умолчанию
(до тех пор, пока не определят своё локальное связывание буфера для этой
переменной), но не значение, которое использует текущий буфер.

@example
@group
;; @r{Для буфера @samp{foo}:}
(make-local-variable 'buffer-local)
     @result{} buffer-local
@end group
@group
(setq buffer-local 'value-in-foo)
     @result{} value-in-foo
@end group
@group
(setq-default buffer-local 'new-default)
     @result{} new-default
@end group
@group
buffer-local
     @result{} value-in-foo
@end group
@group
(default-value 'buffer-local)
     @result{} new-default
@end group

@group
;; @r{В (новом) буфере @samp{bar}:}
buffer-local
     @result{} new-default
@end group
@group
(default-value 'buffer-local)
     @result{} new-default
@end group
@group
(setq buffer-local 'another-default)
     @result{} another-default
@end group
@group
(default-value 'buffer-local)
     @result{} another-default
@end group

@group
;; @r{Обратно в буфере @samp{foo}:}
buffer-local
     @result{} value-in-foo
(default-value 'buffer-local)
     @result{} another-default
@end group
@end example
@end defspec

@defun set-default symbol value
Функция подобна @code{setq-default}, за исключением того, что оценивает
аргумент @var{symbol}.

@example
@group
(set-default (car '(a b c)) 23)
     @result{} 23
@end group
@group
(default-value 'a)
     @result{} 23
@end group
@end example
@end defun

  Переменная может быть связана к значению (@pxref{Local Variables}).  Это
  делает затенение его глобального связывания новым связыванием;
  @code{default-value} будет возвращать значение из этого связывания, а не
  значение из глобального связывания, и @code{set-default} не сможет
  установить значение глобального связывания (вместо этого измениться
  значение @code{let-связывания}).  Следующие две функции позволяют ссылаться
  на глобальное значение, даже если оно затенено @code{let-связыванием}.

@cindex top-level default value
@defun default-toplevel-value symbol
Функция возвращает @dfn{top-level (верхний-уровень)} значение по умолчанию
@var{symbol}, которое является его значением вне любого
@code{let-связывания}.
@end defun

@example
@group
(defvar variable 'global-value)
    @result{} variable
@end group
@group
(let ((variable 'let-binding))
  (default-value 'variable))
    @result{} let-binding
@end group
@group
(let ((variable 'let-binding))
  (default-toplevel-value 'variable))
    @result{} global-value
@end group
@end example

@defun set-default-toplevel-value symbol value
Эта функция устанавливает привязке верхнего уровня символу @var{symbol}
значение по умолчанию @var{value}.  Это очень удобно, когда требуется
установить глобальное значение @var{symbol} независимо от того, в каком
контексте находиться символ @var{symbol} в отрабатываемом коде.
@end defun


@node File Local Variables
@section Локальные Переменные Файла
@cindex file local variables

  Файл может задавать значения локальных переменных; Emacs использует их для
  создания локального связывания буфера этих переменных в буфере, при
  посещающении этого файла.  @xref{File Variables, ,
  Local Variables in Files, emacs, The GNU Emacs Manual}, для базовой
  информации относительно локальных переменных файла.  В этом разделе
  описаны функции и переменные, которые влияют на обработку локальных
  переменных файла.

  Если локальная переменная файла указывает произвольную функцию или
  выражение Lisp, которое будет вызываться позже, посещая файл, Emacs может
  это использовать.  Emacs устанавливает только те локальные переменные
  файла, которые известны как безопасные.  Другие локальные переменные файла
  устанавливаются только если пользователь даёт согласие.

  Для дополнительной безопасности, @code{read-circle} временно
  устанавливается в @code{nil} когда Emacs считывает локальные переменные
  файла (@pxref{Input Functions}).  Это предотвращает читатель Lisp
  оценивать циклические и общие структуры Lisp (@pxref{Circular Objects}).

@defopt enable-local-variables
Эта переменная определяет, как будут обрабатываться локальные переменные
файла.  Возможные значения:

@table @asis
@item @code{t} (the default)
Запросить один раз о установке любых небезопасных переменных.(ВопросVariables1818)
@item @code{:safe}
Установите только безопасные переменные без запроса.
@item @code{:all}
Установите все переменные без запроса.
@item @code{nil}
Не устанавливать какие-либо переменные.
@item anything else
Запрос (один раз) обо всех переменных.
@end table
@end defopt

@defvar inhibit-local-variables-regexps
Список регулярных выражений.  Если файл имеет имя, соответствующее
регулярному выражению в одном из элементов этого списка, то в нём не будет
проводится сканирование на предмет наличия каких-либо локальных переменных
буфера.  Для примеров того, почему это может понадобиться использовать,
@pxref{Auto Major Mode}.
@end defvar

@defun hack-local-variables &optional handle-mode
Функция анализирует и связывает или оценивает в случае необходимости, любые
локальные переменные, указанные в содержимом текущего буфера.  Переменная
@code{enable-local-variables} имеет свой эффект здесь.  Однако, эта функция
не ищет локальную переменную в строке @samp{mode:} @w{@samp{-*-}}.
@code{set-auto-mode} делает это, а также принимая во внимание
@code{enable-local-variables} (@pxref{Auto Major Mode}).

This function works by walking the alist stored in
@code{file-local-variables-alist} and applying each local variable in
turn.  It calls @code{before-hack-local-variables-hook} and
@code{hack-local-variables-hook} before and after applying the
variables, respectively.  It only calls the before-hook if the alist
is non-@code{nil}; it always calls the other hook.  This
function ignores a @samp{mode} element if it specifies the same major
mode as the buffer already has.

If the optional argument @var{handle-mode} is @code{t}, then all this
function does is return a symbol specifying the major mode, if the
@w{@samp{-*-}} line or the local variables list specifies one, and
@code{nil} otherwise.  It does not set the mode or any other
file-local variable.  If @var{handle-mode} has any value other than
@code{nil} or @code{t}, any settings of @samp{mode} in the
@w{@samp{-*-}} line or the local variables list are ignored, and the
other settings are applied.  If @var{handle-mode} is @code{nil}, all
the file local variables are set.
@end defun

@defvar file-local-variables-alist
This buffer-local variable holds the alist of file-local variable
settings.  Each element of the alist is of the form
@w{@code{(@var{var} . @var{value})}}, where @var{var} is a symbol of
the local variable and @var{value} is its value.  When Emacs visits a
file, it first collects all the file-local variables into this alist,
and then the @code{hack-local-variables} function applies them one by
one.
@end defvar

@defvar before-hack-local-variables-hook
Emacs calls this hook immediately before applying file-local variables
stored in @code{file-local-variables-alist}.
@end defvar

@defvar hack-local-variables-hook
Emacs calls this hook immediately after it finishes applying
file-local variables stored in @code{file-local-variables-alist}.
@end defvar

@cindex safe local variable
  You can specify safe values for a variable with a
@code{safe-local-variable} property.  The property has to be a
function of one argument; any value is safe if the function returns
non-@code{nil} given that value.  Many commonly-encountered file
variables have @code{safe-local-variable} properties; these include
@code{fill-column}, @code{fill-prefix}, and @code{indent-tabs-mode}.
For boolean-valued variables that are safe, use @code{booleanp} as the
property value.

  If you want to define @code{safe-local-variable} properties for
variables defined in C source code, add the names and the properties
of those variables to the list in the ``Safe local variables'' section
of @file{files.el}.

@cindex autoload cookie, and safe values of variable
  When defining a user option using @code{defcustom}, you can set its
@code{safe-local-variable} property by adding the arguments
@code{:safe @var{function}} to @code{defcustom} (@pxref{Variable
Definitions}).  However, a safety predicate defined using @code{:safe}
will only be known once the package that contains the @code{defcustom}
is loaded, which is often too late.  As an alternative, you can use
the autoload cookie (@pxref{Autoload}) to assign the option its safety
predicate, like this:

@lisp
;;;###autoload (put '@var{var} 'safe-local-variable '@var{pred})
@end lisp

@noindent
The safe value definitions specified with @code{autoload} are copied
into the package's autoloads file (@file{loaddefs.el} for most
packages bundled with Emacs), and are known to Emacs since the
beginning of a session.

@defopt safe-local-variable-values
This variable provides another way to mark some variable values as
safe.  It is a list of cons cells @code{(@var{var} . @var{val})},
where @var{var} is a variable name and @var{val} is a value which is
safe for that variable.

When Emacs asks the user whether or not to obey a set of file-local
variable specifications, the user can choose to mark them as safe.
Doing so adds those variable/value pairs to
@code{safe-local-variable-values}, and saves it to the user's custom
file.
@end defopt

@defun safe-local-variable-p sym val
This function returns non-@code{nil} if it is safe to give @var{sym}
the value @var{val}, based on the above criteria.
@end defun

@c @cindex risky local variable   Duplicates risky-local-variable
  Some variables are considered @dfn{risky}.  If a variable is risky,
it is never entered automatically into
@code{safe-local-variable-values}; Emacs always queries before setting
a risky variable, unless the user explicitly allows a value by
customizing @code{safe-local-variable-values} directly.

  Any variable whose name has a non-@code{nil}
@code{risky-local-variable} property is considered risky.  When you
define a user option using @code{defcustom}, you can set its
@code{risky-local-variable} property by adding the arguments
@code{:risky @var{value}} to @code{defcustom} (@pxref{Variable
Definitions}).  In addition, any variable whose name ends in any of
@samp{-command}, @samp{-frame-alist}, @samp{-function},
@samp{-functions}, @samp{-hook}, @samp{-hooks}, @samp{-form},
@samp{-forms}, @samp{-map}, @samp{-map-alist}, @samp{-mode-alist},
@samp{-program}, or @samp{-predicate} is automatically considered
risky.  The variables @samp{font-lock-keywords},
@samp{font-lock-keywords} followed by a digit, and
@samp{font-lock-syntactic-keywords} are also considered risky.

@defun risky-local-variable-p sym
This function returns non-@code{nil} if @var{sym} is a risky variable,
based on the above criteria.
@end defun

@defvar ignored-local-variables
This variable holds a list of variables that should not be given local
values by files.  Any value specified for one of these variables is
completely ignored.
@end defvar

  The @samp{Eval:} ``variable'' is also a potential loophole, so Emacs
normally asks for confirmation before handling it.

@defopt enable-local-eval
This variable controls processing of @samp{Eval:} in @samp{-*-} lines
or local variables
lists in files being visited.  A value of @code{t} means process them
unconditionally; @code{nil} means ignore them; anything else means ask
the user what to do for each file.  The default value is @code{maybe}.
@end defopt

@defopt safe-local-eval-forms
This variable holds a list of expressions that are safe to
evaluate when found in the @samp{Eval:} ``variable'' in a file
local variables list.
@end defopt

  If the expression is a function call and the function has a
@code{safe-local-eval-function} property, the property value
determines whether the expression is safe to evaluate.  The property
value can be a predicate to call to test the expression, a list of
such predicates (it's safe if any predicate succeeds), or @code{t}
(always safe provided the arguments are constant).

  Text properties are also potential loopholes, since their values
could include functions to call.  So Emacs discards all text
properties from string values specified for file-local variables.

@node Directory Local Variables
@section Directory Local Variables
@cindex directory local variables

  A directory can specify local variable values common to all files in
that directory; Emacs uses these to create buffer-local bindings for
those variables in buffers visiting any file in that directory.  This
is useful when the files in the directory belong to some @dfn{project}
and therefore share the same local variables.

  There are two different methods for specifying directory local
variables: by putting them in a special file, or by defining a
@dfn{project class} for that directory.

@defvr Constant dir-locals-file
This constant is the name of the file where Emacs expects to find the
directory-local variables.  The name of the file is
@file{.dir-locals.el}@footnote{
The MS-DOS version of Emacs uses @file{_dir-locals.el} instead, due to
limitations of the DOS filesystems.
}.  A file by that name in a directory causes Emacs to apply its
settings to any file in that directory or any of its subdirectories
(optionally, you can exclude subdirectories; see below).
If some of the subdirectories have their own @file{.dir-locals.el}
files, Emacs uses the settings from the deepest file it finds starting
from the file's directory and moving up the directory tree.  This
constant is also used to derive the name of a second dir-locals file
@file{.dir-locals-2.el}.  If this second dir-locals file is present,
then that is loaded instead of @file{.dir-locals.el}.  This is useful
when @file{.dir-locals.el} is under version control in a shared
repository and cannot be used for personal customizations.  The file
specifies local variables as a specially formatted list; see
@ref{Directory Variables, , Per-directory Local Variables, emacs, The
GNU Emacs Manual}, for more details.
@end defvr

@defun hack-dir-local-variables
This function reads the @code{.dir-locals.el} file and stores the
directory-local variables in @code{file-local-variables-alist} that is
local to the buffer visiting any file in the directory, without
applying them.  It also stores the directory-local settings in
@code{dir-locals-class-alist}, where it defines a special class for
the directory in which @file{.dir-locals.el} file was found.  This
function works by calling @code{dir-locals-set-class-variables} and
@code{dir-locals-set-directory-class}, described below.
@end defun

@defun hack-dir-local-variables-non-file-buffer
This function looks for directory-local variables, and immediately
applies them in the current buffer.  It is intended to be called in
the mode commands for non-file buffers, such as Dired buffers, to let
them obey directory-local variable settings.  For non-file buffers,
Emacs looks for directory-local variables in @code{default-directory}
and its parent directories.
@end defun

@defun dir-locals-set-class-variables class variables
This function defines a set of variable settings for the named
@var{class}, which is a symbol.  You can later assign the class to one
or more directories, and Emacs will apply those variable settings to
all files in those directories.  The list in @var{variables} can be of
one of the two forms: @code{(@var{major-mode} . @var{alist})} or
@code{(@var{directory} . @var{list})}.  With the first form, if the
file's buffer turns on a mode that is derived from @var{major-mode},
then all the variables in the associated @var{alist} are applied;
@var{alist} should be of the form @code{(@var{name} . @var{value})}.
A special value @code{nil} for @var{major-mode} means the settings are
applicable to any mode.  In @var{alist}, you can use a special
@var{name}: @code{subdirs}.  If the associated value is
@code{nil}, the alist is only applied to files in the relevant
directory, not to those in any subdirectories.

With the second form of @var{variables}, if @var{directory} is the
initial substring of the file's directory, then @var{list} is applied
recursively by following the above rules; @var{list} should be of one
of the two forms accepted by this function in @var{variables}.
@end defun

@defun dir-locals-set-directory-class directory class &optional mtime
This function assigns @var{class} to all the files in @code{directory}
and its subdirectories.  Thereafter, all the variable settings
specified for @var{class} will be applied to any visited file in
@var{directory} and its children.  @var{class} must have been already
defined by @code{dir-locals-set-class-variables}.

Emacs uses this function internally when it loads directory variables
from a @code{.dir-locals.el} file.  In that case, the optional
argument @var{mtime} holds the file modification time (as returned by
@code{file-attributes}).  Emacs uses this time to check stored
local variables are still valid.  If you are assigning a class
directly, not via a file, this argument should be @code{nil}.
@end defun

@defvar dir-locals-class-alist
This alist holds the class symbols and the associated variable
settings.  It is updated by @code{dir-locals-set-class-variables}.
@end defvar

@defvar dir-locals-directory-cache
This alist holds directory names, their assigned class names, and
modification times of the associated directory local variables file
(if there is one).  The function @code{dir-locals-set-directory-class}
updates this list.
@end defvar

@defvar enable-dir-local-variables
If @code{nil}, directory-local variables are ignored.  This variable
may be useful for modes that want to ignore directory-locals while
still respecting file-local variables (@pxref{File Local Variables}).
@end defvar

@node Connection Local Variables
@section Connection Local Variables
@cindex connection local variables

  Connection-local variables provide a general mechanism for different
variable settings in buffers with a remote connection.  They are bound
and set depending on the remote connection a buffer is dedicated to.

@defun connection-local-set-profile-variables profile variables
This function defines a set of variable settings for the connection
@var{profile}, which is a symbol.  You can later assign the connection
profile to one or more remote connections, and Emacs will apply those
variable settings to all process buffers for those connections.  The
list in @var{variables} is an alist of the form
@code{(@var{name}@tie{}.@tie{}@var{value})}.  Example:

@example
@group
(connection-local-set-profile-variables
  'remote-bash
  '((shell-file-name . "/bin/bash")
    (shell-command-switch . "-c")
    (shell-interactive-switch . "-i")
    (shell-login-switch . "-l")))
@end group

@group
(connection-local-set-profile-variables
  'remote-ksh
  '((shell-file-name . "/bin/ksh")
    (shell-command-switch . "-c")
    (shell-interactive-switch . "-i")
    (shell-login-switch . "-l")))
@end group

@group
(connection-local-set-profile-variables
  'remote-null-device
  '((null-device . "/dev/null")))
@end group
@end example
@end defun

@defvar connection-local-profile-alist
This alist holds the connection profile symbols and the associated
variable settings.  It is updated by
@code{connection-local-set-profile-variables}.
@end defvar

@defun connection-local-set-profiles criteria &rest profiles
This function assigns @var{profiles}, which are symbols, to all remote
connections identified by @var{criteria}.  @var{criteria} is a plist
identifying a connection and the application using this connection.
Property names might be @code{:application}, @code{:protocol},
@code{:user} and @code{:machine}.  The property value of
@code{:application} is a symbol, all other property values are
strings.  All properties are optional; if @var{criteria} is @code{nil}, it
always applies.  Example:

@example
@group
(connection-local-set-profiles
  '(:application 'tramp :protocol "ssh" :machine "localhost")
  'remote-bash 'remote-null-device)
@end group

@group
(connection-local-set-profiles
  '(:application 'tramp :protocol "sudo"
    :user "root" :machine "localhost")
  'remote-ksh 'remote-null-device)
@end group
@end example

  If @var{criteria} is @code{nil}, it applies for all remote connections.
Therefore, the example above would be equivalent to

@example
@group
(connection-local-set-profiles
  '(:application 'tramp :protocol "ssh" :machine "localhost")
  'remote-bash)
@end group

@group
(connection-local-set-profiles
  '(:application 'tramp :protocol "sudo"
    :user "root" :machine "localhost")
  'remote-ksh)
@end group

@group
(connection-local-set-profiles
  nil 'remote-null-device)
@end group
@end example

  Any connection profile of @var{profiles} must have been already
defined by @code{connection-local-set-profile-variables}.
@end defun

@defvar connection-local-criteria-alist
This alist contains connection criteria and their assigned profile
names.  The function @code{connection-local-set-profiles} updates this
list.
@end defvar

@defun hack-connection-local-variables criteria
This function collects applicable connection-local variables
associated with @var{criteria} in
@code{connection-local-variables-alist}, without applying them.
Example:

@example
@group
(hack-connection-local-variables
  '(:application 'tramp :protocol "ssh" :machine "localhost"))
@end group

@group
connection-local-variables-alist
     @result{} ((null-device . "/dev/null")
        (shell-login-switch . "-l")
        (shell-interactive-switch . "-i")
        (shell-command-switch . "-c")
        (shell-file-name . "/bin/bash"))
@end group
@end example
@end defun

@defun hack-connection-local-variables-apply criteria
This function looks for connection-local variables according to
@var{criteria}, and immediately applies them in the current buffer.
@end defun

@defmac with-connection-local-profiles profiles &rest body
All connection-local variables, which are specified by a connection
profile in @var{profiles}, are applied.

After that, @var{body} is executed, and the connection-local variables
are unwound.  Example:

@example
@group
(connection-local-set-profile-variables
  'remote-perl
  '((perl-command-name . "/usr/local/bin/perl")
    (perl-command-switch . "-e %s")))
@end group

@group
(with-connection-local-profiles '(remote-perl)
  do something useful)
@end group
@end example
@end defmac

@defvar enable-connection-local-variables
If @code{nil}, connection-local variables are ignored.  This variable
shall be changed temporarily only in special modes.
@end defvar

@node Variable Aliases
@section Variable Aliases
@cindex variable aliases
@cindex alias, for variables

  It is sometimes useful to make two variables synonyms, so that both
variables always have the same value, and changing either one also
changes the other.  Whenever you change the name of a
variable---either because you realize its old name was not well
chosen, or because its meaning has partly changed---it can be useful
to keep the old name as an @emph{alias} of the new one for
compatibility.  You can do this with @code{defvaralias}.

@defun defvaralias new-alias base-variable &optional docstring
This function defines the symbol @var{new-alias} as a variable alias
for symbol @var{base-variable}. This means that retrieving the value
of @var{new-alias} returns the value of @var{base-variable}, and
changing the value of @var{new-alias} changes the value of
@var{base-variable}.  The two aliased variable names always share the
same value and the same bindings.

If the @var{docstring} argument is non-@code{nil}, it specifies the
documentation for @var{new-alias}; otherwise, the alias gets the same
documentation as @var{base-variable} has, if any, unless
@var{base-variable} is itself an alias, in which case @var{new-alias} gets
the documentation of the variable at the end of the chain of aliases.

This function returns @var{base-variable}.
@end defun

  Variable aliases are convenient for replacing an old name for a
variable with a new name.  @code{make-obsolete-variable} declares that
the old name is obsolete and therefore that it may be removed at some
stage in the future.

@defun make-obsolete-variable obsolete-name current-name when &optional access-type
This function makes the byte compiler warn that the variable
@var{obsolete-name} is obsolete.  If @var{current-name} is a symbol,
it is the variable's new name; then the warning message says to use
@var{current-name} instead of @var{obsolete-name}.  If
@var{current-name} is a string, this is the message and there is no
replacement variable.  @var{when} should be a string indicating when
the variable was first made obsolete (usually a version number
string).

The optional argument @var{access-type}, if non-@code{nil}, should
specify the kind of access that will trigger obsolescence warnings; it
can be either @code{get} or @code{set}.
@end defun

  You can make two variables synonyms and declare one obsolete at the
same time using the macro @code{define-obsolete-variable-alias}.

@defmac define-obsolete-variable-alias obsolete-name current-name &optional when docstring
This macro marks the variable @var{obsolete-name} as obsolete and also
makes it an alias for the variable @var{current-name}.  It is
equivalent to the following:

@example
(defvaralias @var{obsolete-name} @var{current-name} @var{docstring})
(make-obsolete-variable @var{obsolete-name} @var{current-name} @var{when})
@end example
@end defmac

@defun indirect-variable variable
This function returns the variable at the end of the chain of aliases
of @var{variable}.  If @var{variable} is not a symbol, or if @var{variable} is
not defined as an alias, the function returns @var{variable}.

This function signals a @code{cyclic-variable-indirection} error if
there is a loop in the chain of symbols.
@end defun

@example
(defvaralias 'foo 'bar)
(indirect-variable 'foo)
     @result{} bar
(indirect-variable 'bar)
     @result{} bar
(setq bar 2)
bar
     @result{} 2
@group
foo
     @result{} 2
@end group
(setq foo 0)
bar
     @result{} 0
foo
     @result{} 0
@end example

@node Variables with Restricted Values
@section Variables with Restricted Values
@cindex lisp variables defined in C, restrictions

  Ordinary Lisp variables can be assigned any value that is a valid
Lisp object.  However, certain Lisp variables are not defined in Lisp,
but in C@.  Most of these variables are defined in the C code using
@code{DEFVAR_LISP}.  Like variables defined in Lisp, these can take on
any value.  However, some variables are defined using
@code{DEFVAR_INT} or @code{DEFVAR_BOOL}.  @xref{Defining Lisp
variables in C,, Writing Emacs Primitives}, in particular the
description of functions of the type @code{syms_of_@var{filename}},
for a brief discussion of the C implementation.

  Variables of type @code{DEFVAR_BOOL} can only take on the values
@code{nil} or @code{t}.  Attempting to assign them any other value
will set them to @code{t}:

@example
(let ((display-hourglass 5))
  display-hourglass)
     @result{} t
@end example

@defvar byte-boolean-vars
This variable holds a list of all variables of type @code{DEFVAR_BOOL}.
@end defvar

  Variables of type @code{DEFVAR_INT} can take on only integer values.
Attempting to assign them any other value will result in an error:

@example
(setq undo-limit 1000.0)
@error{} Wrong type argument: integerp, 1000.0
@end example

@node Generalized Variables
@section Generalized Variables

@cindex generalized variable
@cindex place form
A @dfn{generalized variable} or @dfn{place form} is one of the many
places in Lisp memory where values can be stored using the @code{setf}
macro (@pxref{Setting Generalized Variables}).  The simplest place
form is a regular Lisp variable.  But the @sc{car}s and @sc{cdr}s of
lists, elements of arrays, properties of symbols, and many other
locations are also places where Lisp values get stored.

Generalized variables are analogous to lvalues in the C
language, where @samp{x = a[i]} gets an element from an array
and @samp{a[i] = x} stores an element using the same notation.
Just as certain forms like @code{a[i]} can be lvalues in C, there
is a set of forms that can be generalized variables in Lisp.

@menu
* Setting Generalized Variables::   The @code{setf} macro.
* Adding Generalized Variables::    Defining new @code{setf} forms.
@end menu

@node Setting Generalized Variables
@subsection The @code{setf} Macro

The @code{setf} macro is the most basic way to operate on generalized
variables.  The @code{setf} form is like @code{setq}, except that it
accepts arbitrary place forms on the left side rather than just
symbols.  For example, @code{(setf (car a) b)} sets the car of
@code{a} to @code{b}, doing the same operation as @code{(setcar a b)},
but without you having to use two separate functions for setting and
accessing this type of place.

@defmac setf [place form]@dots{}
This macro evaluates @var{form} and stores it in @var{place}, which
must be a valid generalized variable form.  If there are several
@var{place} and @var{form} pairs, the assignments are done sequentially
just as with @code{setq}.  @code{setf} returns the value of the last
@var{form}.
@end defmac

The following Lisp forms are the forms in Emacs that will work as
generalized variables, and so may appear in the @var{place} argument
of @code{setf}:

@itemize
@item
A symbol.  In other words, @code{(setf x y)} is exactly equivalent to
@code{(setq x y)}, and @code{setq} itself is strictly speaking
redundant given that @code{setf} exists.  Most programmers will
continue to prefer @code{setq} for setting simple variables, though,
for stylistic and historical reasons.  The macro @code{(setf x y)}
actually expands to @code{(setq x y)}, so there is no performance
penalty for using it in compiled code.

@item
A call to any of the following standard Lisp functions:

@smallexample
aref      cddr      symbol-function
car       elt       symbol-plist
caar      get       symbol-value
cadr      gethash
cdr       nth
cdar      nthcdr
@end smallexample

@item
A call to any of the following Emacs-specific functions:

@smallexample
alist-get                     process-get
frame-parameter               process-sentinel
terminal-parameter            window-buffer
keymap-parent                 window-display-table
match-data                    window-dedicated-p
overlay-get                   window-hscroll
overlay-start                 window-parameter
overlay-end                   window-point
process-buffer                window-start
process-filter                default-value
@end smallexample
@end itemize

@noindent
@code{setf} signals an error if you pass a @var{place} form that it
does not know how to handle.

@c And for cl-lib's cl-getf.
Note that for @code{nthcdr}, the list argument of the function must
itself be a valid @var{place} form.  For example, @code{(setf (nthcdr
0 foo) 7)} will set @code{foo} itself to 7.
@c The use of @code{nthcdr} as a @var{place} form is an extension
@c to standard Common Lisp.

@c FIXME I don't think is a particularly good way to do it,
@c but these macros are introduced before generalized variables are.
The macros @code{push} (@pxref{List Variables}) and @code{pop}
(@pxref{List Elements}) can manipulate generalized variables,
not just lists.  @code{(pop @var{place})} removes and returns the first
element of the list stored in @var{place}.  It is analogous to
@code{(prog1 (car @var{place}) (setf @var{place} (cdr @var{place})))},
except that it takes care to evaluate all subforms only once.
@code{(push @var{x} @var{place})} inserts @var{x} at the front of
the list stored in @var{place}.  It is analogous to @code{(setf
@var{place} (cons @var{x} @var{place}))}, except for evaluation of the
subforms.  Note that @code{push} and @code{pop} on an @code{nthcdr}
place can be used to insert or delete at any position in a list.

The @file{cl-lib} library defines various extensions for generalized
variables, including additional @code{setf} places.
@xref{Generalized Variables,,, cl, Common Lisp Extensions}.


@node Adding Generalized Variables
@subsection Defining new @code{setf} forms

This section describes how to define new forms that @code{setf} can
operate on.

@defmac gv-define-simple-setter name setter &optional fix-return
This macro enables you to easily define @code{setf} methods for simple
cases.  @var{name} is the name of a function, macro, or special form.
You can use this macro whenever @var{name} has a directly
corresponding @var{setter} function that updates it, e.g.,
@code{(gv-define-simple-setter car setcar)}.

This macro translates a call of the form

@example
(setf (@var{name} @var{args}@dots{}) @var{value})
@end example

into
@example
(@var{setter} @var{args}@dots{} @var{value})
@end example

@noindent
Such a @code{setf} call is documented to return @var{value}.  This is
no problem with, e.g., @code{car} and @code{setcar}, because
@code{setcar} returns the value that it set.  If your @var{setter}
function does not return @var{value}, use a non-@code{nil} value for
the @var{fix-return} argument of @code{gv-define-simple-setter}.  This
expands into something equivalent to
@example
(let ((temp @var{value}))
  (@var{setter} @var{args}@dots{} temp)
  temp)
@end example
so ensuring that it returns the correct result.
@end defmac


@defmac gv-define-setter name arglist &rest body
This macro allows for more complex @code{setf} expansions than the
previous form.  You may need to use this form, for example, if there
is no simple setter function to call, or if there is one but it
requires different arguments to the place form.

This macro expands the form
@code{(setf (@var{name} @var{args}@dots{}) @var{value})} by
first binding the @code{setf} argument forms
@code{(@var{value} @var{args}@dots{})} according to @var{arglist},
and then executing @var{body}.  @var{body} should return a Lisp
form that does the assignment, and finally returns the value that was
set.  An example of using this macro is:

@example
(gv-define-setter caar (val x) `(setcar (car ,x) ,val))
@end example
@end defmac

@findex gv-define-expander
@findex gv-letplace
@c FIXME?  Not sure what or how much to say about these.
@c See cl.texi for an example of using gv-letplace.
For more control over the expansion, see the macro @code{gv-define-expander}.
The macro @code{gv-letplace} can be useful in defining macros that
perform similarly to @code{setf}; for example, the @code{incf} macro
of Common Lisp.  Consult the source file @file{gv.el} for more details.

@cindex CL note---no @code{setf} functions
@quotation
@b{Common Lisp note:} Common Lisp defines another way to specify the
@code{setf} behavior of a function, namely @code{setf} functions,
whose names are lists @code{(setf @var{name})} rather than symbols.
For example, @code{(defun (setf foo) @dots{})} defines the function
that is used when @code{setf} is applied to @code{foo}.  Emacs does
not support this.  It is a compile-time error to use @code{setf} on a
form that has not already had an appropriate expansion defined.  In
Common Lisp, this is not an error since the function @code{(setf
@var{func})} might be defined later.
@end quotation
