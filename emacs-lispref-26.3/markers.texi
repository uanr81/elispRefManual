@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2019 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Markers
@chapter Маркеры
@cindex markers

  @dfn{Маркер} - это объект Lisp, используемый для указания позиции в буфере
относительно окружающего текста.  Маркер автоматически изменяет свое
смещение от начала буфера всякий раз, когда текст вставляется или удаляется,
так что он остается с двумя символами по обе стороны от него.

@menu
* Overview of Markers::      Компоненты маркера и способ его перемещения.
* Predicates on Markers::    Проверка того, является ли объект маркером.
* Creating Markers::         Изготовление пустых маркеров или маркеров в
                                определенных местах.
* Information from Markers:: Нахождение маркера буфера или позиции символа.
* Marker Insertion Types::   Маркер может перемещаться двумя способами,
                                когда вставляется туда, куда он указывает.
* Moving Markers::           Перемещение маркера в новый буфер или позицию.
* The Mark::                 Как наносится отметка маркером.
* The Region::               Как получить доступ к региону.
@end menu

@node Overview of Markers
@section Обзор Маркеров

  Маркер определяет буфер и позицию в этом буфере.  Маркер может
использоваться для представления позиции в функциях, которые требуют его,
так же как можно использовать целое число.  В этом случае маркер буфера
обычно игнорируется.  Конечно, используемый таким образом маркер обычно
указывает на позицию в буфере, над которой работает функция, но это
полностью ответственность программиста.  @xref{Positions}, полное описание
позиций.

  Маркер имеет три атрибута: положение маркера, буфер маркера и тип вставки.
Позиция маркера - это целое число, которое эквивалентно (в данный момент)
маркеру как позиции в этом буфере.  Но значение положения маркера может
меняться в течение срока службы маркера, и часто это происходит.  Вставка и
удаление текста в буфере перемещают маркер.  Идея состоит в том, что маркер,
расположенный между двумя символами, остается между этими двумя символами,
несмотря на вставку и удаление в другом месте буфера.  Перемещение изменяет
целочисленный эквивалент маркера.

@cindex marker relocation
  При удалении текста вокруг позиции маркера маркер остается между символами
непосредственно перед и после удаленного текста.  Вставка текста в позицию
маркера обычно оставляет маркер либо перед новым текстом, либо после него, в
зависимости от @dfn{insertion type} (@pxref{Marker Insertion Types}) маркера
--- если только вставка не выполняется с помощью
@code{insert-before-markers} (@pxref{Insertion}).

@cindex marker garbage collection
  Вставка и удаление в буфере должны проверять все маркеры и при
необходимости перемещать их.  Это замедляет обработку в буфере с большим
количеством маркеров.  По этой причине рекомендуется нигде не устанавливать
маркер, если нет уверенности, что он больше не нужен.  Маркеры, к которым
больше нельзя получить доступ, в конечном итоге удаляются
(@pxref{Garbage Collection}).

@cindex markers as numbers
  Поскольку над положением маркера обычно выполняются арифметические
операции, большинство этих операций (включая @code{+} и @code{-}) принимают
маркеры в качестве аргументов.  В таких случаях маркер обозначает его
текущее положение.

Вот примеры создания маркеров, установки маркеров и перемещения точки к
маркерам:

@example
@group
;; @r{Сделать новый маркер, который изначально никуда не указывает:}
(setq m1 (make-marker))
     @result{} #<marker in no buffer>
@end group

@group
;; @r{Установить @code{m1}, чтобы указывало между 99-м и 100-м символами}
;;   @r{в текущем буфере:}
(set-marker m1 100)
     @result{} #<marker at 100 in markers.texi>
@end group

@group
;; @r{Теперь вставить один символ в начало буфера:}
(goto-char (point-min))
     @result{} 1
(insert "Q")
     @result{} nil
@end group

@group
;; @r{@code{m1} обновляется соответствующим образом.}
m1
     @result{} #<marker at 101 in markers.texi>
@end group

@group
;; @r{Два маркера, указывающие на одну и ту же позицию,}
;;   @r{не являются @code{eq}, а являются @code{equal}.}
(setq m2 (copy-marker m1))
     @result{} #<marker at 101 in markers.texi>
(eq m1 m2)
     @result{} nil
(equal m1 m2)
     @result{} t
@end group

@group
;; @r{Когда закончиться использоваться маркер, он не указывает никуда.}
(set-marker m1 nil)
     @result{} #<marker in no buffer>
@end group
@end example

@node Predicates on Markers
@section Предикаты по Маркерам
@cindex predicates for markers
@cindex markers, predicates for

  Можно протестировать объект, чтобы узнать, является ли он маркером, целым
числом или маркером.  Последний тест полезен в связи с арифметическими
функциями, которые работают как с маркерами, так и с целыми числами.

@defun markerp object
Функция возвращает @code{t}, если @var{object} является маркером, и
@code{nil} в противном случае.  Обратить внимание, что целые числа не
являются маркерами, хотя многие функции принимают либо маркер, либо целое
число.
@end defun

@defun integer-or-marker-p object
Функция возвращает @code{t}, если @var{object} является целым числом или
маркером, в противном случае - @code{nil}.
@end defun

@defun number-or-marker-p object
Функция возвращает @code{t}, если @var{object} является числом (целым или
с плавающей точкой) или маркером, в противном случае - @code{nil}.
@end defun

@node Creating Markers
@section Функции, Создающие Маркеры
@cindex creating markers
@cindex marker creation

  Когда создается новый маркер, можно сделать так, чтобы он никуда не
указывал, или указывал на текущее положение точки, или на начало или конец
доступной части буфера, или на то же место, что и другой заданный маркер.

Все следующие четыре функции возвращают маркеры с типом вставки @code{nil}.
@xref{Marker Insertion Types}.

@defun make-marker
Функция возвращает вновь созданный маркер, который никуда не указывает.

@example
@group
(make-marker)
     @result{} #<marker in no buffer>
@end group
@end example
@end defun

@defun point-marker
Функция возвращает новый маркер, указывающий на текущее положение точки в
текущем буфере.  @xref{Point}.  Для примера, смотреть
@code{copy-marker}, ниже.
@end defun

@defun point-min-marker
Функция возвращает новый маркер, указывающий на начало доступной части
буфера.  Это будет начало буфера, если не действует сужение.
@xref{Narrowing}.
@end defun

@defun point-max-marker
Функция возвращает новый маркер, указывающий на конец доступной части
буфера.  Это будет конец буфера, если не действует сужение.
@xref{Narrowing}.

Вот примеры этой функции и @code{point-min-marker}, показанные в буфере,
содержащем версию исходного файла для текста этой главы.

@example
@group
(point-min-marker)
     @result{} #<marker at 1 in markers.texi>
(point-max-marker)
     @result{} #<marker at 24080 in markers.texi>
@end group

@group
(narrow-to-region 100 200)
     @result{} nil
@end group
@group
(point-min-marker)
     @result{} #<marker at 100 in markers.texi>
@end group
@group
(point-max-marker)
     @result{} #<marker at 200 in markers.texi>
@end group
@end example
@end defun

@defun copy-marker &optional marker-or-integer insertion-type
Если в качестве аргумента передан маркер, @code{copy-marker} возвращает
новый маркер, указывающий на то же место и тот же буфер, что и
@var{marker-or-integer}.  Если передано целое число в качестве аргумента,
@code{copy-marker} возвращает новый маркер, указывающий на позицию
@var{marker-or-integer} в текущем буфере.

Тип вставки нового маркера определяется аргументом @var{insertion-type}.
@xref{Marker Insertion Types}.

@c Это поведение документировалось до тех пор, пока 2013/08.
@ignore
Если передан целочисленный аргумент меньше 1, @code{copy-marker} возвращает
новый маркер, указывающий на начало текущего буфера.  Если передан
целочисленный аргумент, превышающий длину буфера, @code{copy-marker}
возвращает новый маркер, указывающий на конец буфера.
@end ignore

@example
@group
(copy-marker 0)
     @result{} #<marker at 1 in markers.texi>
@end group

@group
(copy-marker 90000)
     @result{} #<marker at 24080 in markers.texi>
@end group
@end example

Об ошибке сообщается, если @var{marker} не является ни маркером, ни целым
числом.
@end defun

  Два разных маркера считаются @code{equal} (хотя и не @code{eq})
относительно друг друга, если они имеют одинаковую позицию и буфер, или
если они оба никуда не указывают.

@example
@group
(setq p (point-marker))
     @result{} #<marker at 2139 in markers.texi>
@end group

@group
(setq q (copy-marker p))
     @result{} #<marker at 2139 in markers.texi>
@end group

@group
(eq p q)
     @result{} nil
@end group

@group
(equal p q)
     @result{} t
@end group
@end example

@node Information from Markers
@section Информация с Маркеров
@cindex marker information

  В этом разделе описаны функции для доступа к компонентам объекта-маркера.

@defun marker-position marker
Функция возвращает позицию, на которую указывает @var{marker}, или
@code{nil}, если никуда не указывает.
@end defun

@defun marker-buffer marker
Функция возвращает буфер, на который указывает @var{marker}, или @code{nil},
если никуда не указывает.

@c FIXME: Аргумент 'buffer' для 'set-marker' уже по умолчанию равен
@c текущему буферу, зачем здесь явно использовать '(current-buffer)'?
@example
@group
(setq m (make-marker))
     @result{} #<marker in no buffer>
@end group
@group
(marker-position m)
     @result{} nil
@end group
@group
(marker-buffer m)
     @result{} nil
@end group

@group
(set-marker m 3770 (current-buffer))
     @result{} #<marker at 3770 in markers.texi>
@end group
@group
(marker-buffer m)
     @result{} #<buffer markers.texi>
@end group
@group
(marker-position m)
     @result{} 3770
@end group
@end example
@end defun

@node Marker Insertion Types
@section Типы Вставки Маркеров

@cindex insertion type of a marker
  Когда вставляется текст непосредственно в то место, где указывает маркер,
есть два возможных способа переместить этот маркер: может указывать перед
вставленным текстом или указывать после него.  Можно указать, что должен
делать данный маркер, установив его @dfn{тип вставки}.  Обратить внимание,
что использование @code{insert-before-markers} игнорирует типы вставки
маркеров, всегда перемещая маркер так, чтобы он указывал после вставленного
текста.

@defun set-marker-insertion-type marker type
Функция устанавливает тип вставки маркера @var{marker} в @var{type}.  Если
@var{type} равен @code{t}, @var{marker} будет продвигаться, когда текст
будет вставлен в его позицию.  Если @var{type} равен @code{nil},
@var{marker} не продвигается, когда туда вставляется текст.
@end defun

@defun marker-insertion-type marker
Функция сообщает о текущем типе вставки @var{marker}.
@end defun

Все функции, которые создают маркеры, не принимая аргумент, указывающий тип
вставки, создают их с типом вставки @code{nil} (@pxref{Creating Markers}).
Также метка по умолчанию имеет тип вставки @code{nil}.

@node Moving Markers
@section Перемещение Позиций Маркеров
@cindex moving markers
@cindex marker, how to move position

  В этом разделе описывается, как изменить положение существующего маркера.
Когда это сделано, убедиться, что известно, используется ли маркер вне
программы, и если да, то какие эффекты произойдут в результате его
перемещения - иначе в других частях Emacs могут возникнуть проблемы.

@defun set-marker marker position &optional buffer
Функция перемещает @var{marker} в @var{position} в @var{buffer}.  Если
@var{buffer} не указан, по умолчанию используется текущий буфер.

@c Это поведение документировалось до тех пор, пока 2013/08.
@ignore
Если @var{position} меньше 1, @code{set-marker} перемещает @var{marker} в
начало буфера.  Если @var{position} больше размера буфера (@pxref{Point}),
 @code{set-marker} перемещает маркер в конец буфера.
@end ignore
Если @var{position} - это @code{nil} или маркер, который никуда не
указывает, тогда @var{marker} устанавливается в никуда.

Возвращаемое значение - @var{marker}.

@example
@group
(setq m (point-marker))
     @result{} #<marker at 4714 in markers.texi>
@end group
@group
(set-marker m 55)
     @result{} #<marker at 55 in markers.texi>
@end group
@group
(setq b (get-buffer "foo"))
     @result{} #<buffer foo>
@end group
@group
(set-marker m 0 b)
     @result{} #<marker at 1 in foo>
@end group
@end example
@end defun

@defun move-marker marker position &optional buffer
Это другое название @code{set-marker}.
@end defun

@node The Mark
@section Отметка
@cindex mark, the
@c @cindex the mark?

  У каждого буфера есть специальный маркер, который обозначается
@dfn{отметка}.  Когда буфер создается заново, этот маркер существует, но
нигде не указывает; это означает, что метки еще нет в этом буфере.
Последующие команды могут ставить отметку.

  Метка указывает позицию для ограничения диапазона текста для многих
команд, таких как @code{kill-region} и @code{indent-rigidly}.  Эти команды
обычно воздействуют на текст между точкой и меткой, который называется
@dfn{регион}.  Если пишется команда, которая работает с регионом, не
исследуется метка напрямую; вместо этого используется @code{interactive} со
спецификацией @samp{r}.  Это обеспечивает значения точки и метки в качестве
аргументов команды в интерактивном вызове, но позволяет другим программам на
Lisp явно указывать аргументы.  @xref{Interactive Codes}.

  Некоторые команды устанавливают метку как побочный эффект.  Команды должны
делать это только в том случае, если это может быть использовано
пользователем, и никогда для их собственных внутренних целей.  Например,
команда @code{replace-regexp} устанавливает метку на значение точки перед
выполнением любых замен, потому что это позволяет пользователю удобно
вернуться туда после завершения замены.

  Как только метка существует в буфере, она обычно никогда не перестает
существовать.  Однако может стать @dfn{неактивной}, если включен режим
Transient Mark.  Локальная в буфере переменная @code{mark-active}, если
не-@code{nil}, означает, что метка активна.  Команда может вызвать функцию
@code{deactivate-mark}, чтобы деактивировать метку напрямую, или она может
запросить деактивацию метки при возврате в цикл команд редактора, установив
для переменной @code{deactivate-mark} значение не-@code{nil}.

  Если включен режим временной метки, определенные команды редактирования,
которые обычно применяются к тексту рядом с точкой, вместо этого применяются
к области, когда метка активна.  Это основная мотивация для использования
режима Transient Mark.  (Во-вторых, это позволяет выделить область, когда
метка активна.  @xref{Display}.)

@cindex mark ring
  В дополнение к метке каждый буфер имеет @dfn{кольцо маркеров}, которое
представляет собой список маркеров, содержащих предыдущие значения метки.
Когда команды редактирования изменяют метку, они обычно должны сохранять
старое значение метки в кольце меток.  Переменная @code{mark-ring-max}
определяет максимальное количество записей в кольце отметок; как только
список становится таким длинным, добавление нового элемента удаляет
последний элемент.

  Существует также отдельный глобальный список меток, но он используется
только в нескольких конкретных командах пользовательского уровня и не имеет
отношения к программированию на Lisp.  Поэтому не описывается здесь.

@defun mark &optional force
@cindex current buffer mark
Функция возвращает текущую позицию метки буфера в виде целого числа или
@code{nil}, если в этом буфере никогда не устанавливалась метка.

Если включен режим Transient Mark, а @code{mark-even-if-inactive} -
@code{nil}, @code{mark} сигнализирует об ошибке, если метка неактивна.
Однако, если @var{force} равен не-@code{nil}, то @code{mark} игнорирует
неактивность метки и все равно возвращает позицию метки (или @code{nil}).
@end defun

@defun mark-marker
Функция возвращает маркер, представляющий метку текущего буфера.  Это не
копия, это внутренний маркер.  Следовательно, изменение положения этого
маркера напрямую повлияет на метку буфера.  Не делать этого, если не
требуется добиться желаемого эффекта.

@example
@group
(setq m (mark-marker))
     @result{} #<marker at 3420 in markers.texi>
@end group
@group
(set-marker m 100)
     @result{} #<marker at 100 in markers.texi>
@end group
@group
(mark-marker)
     @result{} #<marker at 100 in markers.texi>
@end group
@end example

Как и любой маркер, этот маркер можно установить так, чтобы он указывал на
любой буфер, который нравится.  Если сделать так, чтобы он указывал на любой
буфер, кроме того, на котором он является меткой, это даст совершенно
последовательные, но довольно странные результаты.  Рекомендуется не делать
этого!
@end defun

@defun set-mark position
Функция устанавливает метку в @var{position} и активирует метку.  Старое
значение метки - @emph{не} толкается в кольцо меток.

@strong{Пожалуйста, обратить внимание:} Использовать эту функцию только в
том случае, если требуется, чтобы пользователь увидел, что метка
переместилась, и нужно, чтобы предыдущее положение метки было потеряно.
Обычно, когда ставится новая отметка, старая должна помещаться в
@code{mark-ring}.  По этой причине в большинстве приложений следует
использовать @code{push-mark} и @code{pop-mark}, а не @code{set-mark}.

Начинающие программисты на Emacs Lisp часто пытаются использовать метку в
неправильных целях.  Отметка сохраняет местоположение для удобства
пользователя.  Команда редактирования не должна изменять метку, если
изменение метки не является частью функциональных возможностей команды на
уровне пользователя.  (И в этом случае этот эффект должен быть
задокументирован.)  Чтобы запомнить место для внутреннего использования в
программе на Lisp, это сохраняется в переменной Lisp.  Например:

@example
@group
(let ((beg (point)))
  (forward-line 1)
  (delete-region beg (point))).
@end group
@end example
@end defun

@defun push-mark &optional position nomsg activate
Функция устанавливает текущую метку буфера в @var{position} и помещает копию
предыдущей метки в @code{mark-ring}.  Если @var{position} равно @code{nil},
то используется значение точки.
@c Не кажется актуальным.  @code{push-mark} возвращает @code{nil}.

Функция @code{push-mark} обычно @emph{не} активирует отметку.  Для этого
указать @code{t} в качестве аргумента @var{activate}.

Сообщение @samp{Mark set} отображается, если @var{nomsg} не не-@code{nil}.
@end defun

@defun pop-mark
Функция извлекает верхний элемент @code{mark-ring} и делает эту метку
фактической меткой буфера.  Это не перемещает точку в буфере и ничего не
делает, если @code{mark-ring} пуст.  Деактивируется отметка.
@c
@c Кажется даже менее актуальным.
@c Возвращаемое значение не имеет смысла.
@end defun

@defopt transient-mark-mode
Переменная, если не-@code{nil}, включает режим Transient Mark.  В режиме
Transient Mark каждый примитив, изменяющий буфер, устанавливает
@code{deactivate-mark}.  Как следствие, большинство команд, изменяющих
буфер, также деактивируют метку.

Когда включен режим Transient Mark и активна метка, многие команды, которые
обычно применяются к тексту рядом с точкой, вместо этого применяются к
области.  Такие команды должны использовать функцию @code{use-region-p},
чтобы проверить, должны ли они работать с регионом.  @xref{The Region}.

Программы Lisp могут устанавливать для @code{transient-mark-mode} значения
не-@code{nil}, не-@code{t}, чтобы временно включить режим Transient Mark.
Если значение равно @code{lambda}, режим Transient Mark автоматически
отключается после любого действия, такого как изменение буфера, которое
обычно деактивирует метку.  Если значение равно
@w{@code{(only . @var{oldval})}}, тогда @code{transient-mark-mode}
устанавливается в значение @var{oldval} после любой последующей команды,
которая перемещает точку и не переводится с помощью сдвига
(@pxref{Key Sequence Input, shift-translation}), или после любого другого
действия, которое обычно деактивирует метку.
@end defopt

@defopt mark-even-if-inactive
Если это не-@code{nil}, программы Lisp и пользователь Emacs могут
использовать метку, даже когда она неактивна.  Эта опция влияет на поведение
режима Transient Mark.  Когда опция - не-@code{nil}, деактивация метки
отключает выделение области, но команды, использующие метку, ведут себя так,
как если бы метка все еще была активной.
@end defopt

@defvar deactivate-mark
Если команда редактора устанавливает эту переменную в не-@code{nil}, то цикл
команд редактора деактивирует метку после возврата команды (если включен
режим Transient Mark).  Все примитивы, изменяющие буфер, устанавливают
@code{deactivate-mark}, чтобы деактивировать отметку, когда команда
завершена.  Установка этой переменной делает ее локальным для буфера.

Чтобы написать код Lisp, который изменяет буфер, не вызывая деактивации
метки в конце команды, привяжите @code{deactivate-mark} к @code{nil} вокруг
кода, который выполняет модификацию. Например:

@example
(let (deactivate-mark)
  (insert " "))
@end example
@end defvar

@defun deactivate-mark &optional force
Если включен режим Transient Mark или @var{force} имеет значение
не-@code{nil}, функция деактивирует метку и запускает обычный обработчик
@code{deactivate-mark-hook}.  В противном случае ничего не происходит.
@end defun

@defvar mark-active
Отметка активности, если эта переменная - не-@code{nil}.  Эта переменная
всегда локальна в каждом буфере.  Используется значение этой переменной,
чтобы решить, должна ли команда, которая обычно работает с текстом рядом с
точкой, работать с регионом.  Для этого (@pxref{The Region}) используется
функция @code{use-region-p}.
@end defvar

@defvar activate-mark-hook
@defvarx deactivate-mark-hook
Эти обычные перехватчики запускаются, соответственно, когда метка становится
активной и когда она становится неактивной.  Ловушка
@code{activate-mark-hook} также запускается в конце цикла команд, если метка
активна и возможно, что область изменилась.
@ignore
Это кусок command_loop_1, запускать если не деактивировать отметку:
  if (current_buffer != prev_buffer || MODIFF != prev_modiff)
    {
      Lisp_Object hook = intern ("activate-mark-hook");
      Frun_hooks (1, &hook);
    }
@end ignore
@end defvar

@defun handle-shift-selection
Функция реализует поведение выбора сдвига для команд перемещения точки.
@xref{Shift Selection,,, emacs, The GNU Emacs Manual}.  Вызывается
автоматически командным циклом Emacs всякий раз, когда вызывается команда с
символом @samp{^} в ее спецификации @code{interactive}, до того, как сама
команда будет выполнена (@pxref{Interactive Codes, ^}).

Если @code{shift-select-mode} - не-@code{nil} и текущая команда была вызвана
с помощью сдвига трансляции (@pxref{Key Sequence Input, shift-translation}),
эта функция устанавливает метку и временно активирует регион, если регион
уже не был временно активирован таким образом.  В противном случае, если
область была активирована временно, она деактивирует метку и восстанавливает
для переменной @code{transient-mark-mode} ее предыдущее значение.
@end defun

@defvar mark-ring
Значение этой локальной переменной буфера представляет собой список
сохраненных прежних меток текущего буфера, начиная с самых последних.

@example
@group
mark-ring
@result{} (#<marker at 11050 in markers.texi>
    #<marker at 10832 in markers.texi>
    @dots{})
@end group
@end example
@end defvar

@defopt mark-ring-max
Значение этой переменной - максимальный размер @code{mark-ring}.  Если на
@code{mark-ring} помещается больше меток, чем указано в переменной,
@code{push-mark} отбрасывает старую метку при добавлении новой.
@end defopt

@c Существует также global-mark-ring-max, но в этой главе
@c явно не говорится о глобальной метке.

@cindex @code{delete-selection}, symbol property
@findex delete-selection-helper
@findex delete-selection-pre-hook
Когда включен режим удаления выделения
(@pxref{Using Region, Delete Selection, , emacs, The GNU Emacs Manual}),
команды, работающие с активной областью (также известной как @: ``отбор''),
ведут себя немного иначе.  Это работает путем добавления функции
@code{delete-selection-pre-hook} в файл @code{pre-command-hook}
(@pxref{Command Overview}).  Эта функция вызывает
@code{delete-selection-helper}, чтобы удалить выделение, соответствующее
команде.  Если требуется адаптировать команду к режиму «Удалить выделение»,
поместить свойство @code{delete-selection} в символ функции
(@pxref{Symbol Plists}); команды, у которых нет этого свойства в своем
символе, не удаляют выделение.  Это свойство может иметь одно из нескольких
значений для адаптации поведения к тому, что должна делать команда;
подробности смотреть в строках документации @code{delete-selection-pre-hook}
и @code{delete-selection-helper}.

@node The Region
@section Регион
@c Запись индекса должна быть просто "region", чтобы сделать ее первым
@c попаданием, когда пользователь набирает "i region RET", потому что в
@c противном случае читатель Info представит совпадения подстрок в
@c алфавитном порядке, поместит эту подстроку ближе к концу, а что-то
@c совершенно не связанное с первым.
@cindex region

  Текст между точкой и меткой известен как @dfn{регион или область}.
Различные функции работают с текстом, разделенным точкой и меткой, но здесь
описаны только те функции, которые относятся к самой области.

Следующие две функции сигнализируют об ошибке, если метка никуда не
указывает.  Если включен режим Transient Mark, а
@code{mark-even-if-inactive} - @code{nil}, они также сигнализируют об
ошибке, если метка неактивна.

@defun region-beginning
Функция возвращает позицию начала области (как целое число).  Это положение
точки или метки, в зависимости от того, что меньше.
@end defun

@defun region-end
Функция возвращает позицию конца области (как целое число).  Это положение
точки или метки, в зависимости от того, что больше.
@end defun

@c FIXME: Упомяните об этом в tips.texi?
  Вместо использования @code{region-beginning} и @code{region-end} команда,
предназначенная для работы с областью, обычно должна использовать
@code{interactive} со спецификацией @samp{r}, чтобы найти начало и конец
области.  Это позволяет другим программам на Lisp явно указывать границы как
аргументы.  @xref{Interactive Codes}.

@defun use-region-p
Функция возвращает @code{t}, если включен режим Transient Mark, метка
активна и в буфере есть допустимая область.  Эта функция предназначена для
использования командами, которые работают с областью, а не с текстом рядом с
точкой, когда метка активна.

@cindex empty region
@vindex use-empty-active-region
Регион считается допустимым, если имеет ненулевой размер или если
пользовательская опция @code{use-empty-active-region} имеет значение
не-@code{nil} (по умолчанию это @code{nil}).  Функция @code{region-active-p}
аналогична функции @code{use-region-p}, но считает допустимыми все области.
В большинстве случаев не следует использовать @code{region-active-p},
поскольку, если область пуста, часто более целесообразно работать с точкой.
@end defun
