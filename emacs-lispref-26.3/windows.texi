@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2019 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Windows
@chapter Окна

В этой главе описаны функции и переменные, относящиеся к окнам Emacs.
@xref{Frames}, о том, как окнам назначается область экрана, доступная для
использования Emacs.  @xref{Display}, чтобы узнать, как текст отображается
в окнах.

@menu
* Basic Windows::           Основная информация об использовании окон.
* Windows and Frames::      Связь окон с фреймом, на котором они появляются.
* Window Sizes::            Доступ к размеру окна.
* Resizing Windows::        Изменение размеров окон.
* Preserving Window Sizes:: Сохранение размеров окон.
* Splitting Windows::       Создание нового окна.
* Deleting Windows::        Удаление окна из рамы.
* Recombining Windows::     Сохранение макета фрейма при разделении
                               и удалении окон.
* Selecting Windows::      Выбранное окно - это то, в которое редактируется.
* Cyclic Window Ordering::  Перемещение по существующим окнам.
* Buffers and Windows::     В каждом окне отображается содержимое буфера.
* Switching Buffers::       Функции более высокого уровня для
                               переключения на буфер.
* Displaying Buffers::      Отображение буфера в подходящем окне.
* Window History::         Каждое окно запоминает отображаемые в нем буферы.
* Dedicated Windows::       Как избежать отображения другого буфера
                               в определенном окне.
* Quitting Windows::        Как восстановить состояние до отображения
                               буфера.
* Side Windows::            Специальные окна по бокам рамки.
* Atomic Windows::          Сохранение частей макета окна.
* Window Point::            Каждое окно имеет собственное расположение
                               точки.
* Window Start and End::    Позиции буфера, указывающие, какой текст
                               отображается на экране в окне.
* Textual Scrolling::       Перемещение текста вверх и вниз по окну.
* Vertical Scrolling::      Перемещение содержимого вверх и вниз по окну.
* Horizontal Scrolling::    Перемещение содержимого в окне горизонтально.
* Coordinates and Windows:: Преобразование координат в окна.
* Mouse Window Auto-selection:: Автоматическое выделение окон мышкой.
* Window Configurations::   Сохранение и восстановление состояния экрана.
* Window Parameters::       Связывание дополнительной информации с окнами.
* Window Hooks::            Ловушки для прокрутки, изменения размера окна,
                               повторного отображения после определенной
                               точки или изменения конфигурации окна.
@end menu


@node Basic Windows
@section Основные Концепции Окон Emacs
@cindex window

@dfn{Окно} - это область экрана, которая используется для отображения буфера
(@pxref{Buffers}).  В Emacs Lisp окна представлены особым типом объекта
Lisp.

@cindex multiple windows
  Окна сгруппированы в рамки (@pxref{Frames}).  Каждый фрейм содержит как
минимум одно окно; пользователь может разделить его на несколько
неперекрывающихся окон для одновременного просмотра нескольких буферов.
Программы Lisp могут использовать несколько окон для различных целей.  В
Rmail, например, можно просматривать сводку заголовков сообщений в одном
окне и содержимое выбранного сообщения в другом окне.

@cindex terminal screen
@cindex screen of terminal
  Emacs использует слово ``окно'' в другом значении, чем в графических
средах рабочего стола и оконных системах, таких как X Window System.  Когда
Emacs запущен в X, каждое из его графических X-окон является фреймом Emacs
(содержащим одно или несколько окон Emacs).  Когда Emacs запускается на
текстовом терминале, фрейм заполняет весь экран терминала.

@cindex tiled windows
  В отличие от окон X, окна Emacs имеют формат @dfn{выложенный плиткой}; они
никогда не перекрываются в пределах области фрейма.  Когда окно создается,
удаляется или изменяется его размер, оконное пространство берется из
соседних окон или передается им, так что общая площадь фрейма остается
неизменной.

@defun windowp object
Функция возвращает @code{t}, если @var{object} является окном (независимо от
того, отображает оно буфер или нет).  В противном случае возвращается
@code{nil}.
@end defun

@cindex live windows
@dfn{Активное окно} - это то, которое фактически отображает буфер в фрейме.

@defun window-live-p object
Функция возвращает @code{t}, если @var{object} является активным окном, и
@code{nil} в противном случае. Активное окно - это окно, в котором
отображается буфер.
@end defun

@cindex internal windows
Окна в каждом фрейме организованы в @dfn{дереве окон}.
@xref{Windows and Frames}.  Листовые узлы каждого дерева окон являются
активными окнами - фактически отображающими буферы.  Внутренние узлы дерева
окон - @dfn{внутренние окна}, которые не являются активными.

@cindex valid windows
   @dfn{Действительное окно} - это активное или внутреннее.  Действительное
окно может быть @dfn{удаленным}, то есть удалено из его кадра
(@pxref{Deleting Windows}), тогда оно больше не является действительным, но
объект Lisp, представляющий его, может по-прежнему ссылаться на другие
объекты Lisp.  Удаленное окно можно снова сделать действительным,
восстановив сохраненную конфигурацию окна (@pxref{Window Configurations}).

   Можно отличить действительные окна от удаленных с помощью
@code{window-valid-p}.

@defun window-valid-p object
Функция возвращает @code{t}, если @var{object} - активное окно, или
внутреннее окно в дереве окон.  В противном случае возвращается @code{nil},
в том числе для случая, когда @var{object} - удаленное окно.
@end defun

@cindex selected window
@cindex window selected within a frame
  В каждом кадре в любое время ровно одно окно Emacs обозначается как
@dfn{выбраное в кадре}.  Для выбранного фрейма это окно называется
@dfn{выбранное окно} - то, в котором происходит большая часть
редактирования, и в котором отображается курсор для выбранных окон
(@pxref{Cursor Parameters}).  Клавиатурный ввод, который вставляет или
удаляет текст, также обычно направляется в это окно.  Буфер выбранного окна
обычно также является текущим буфером, за исключением случая, когда
используется @code{set-buffer} (@pxref{Current Buffer}).  Что касается
невыбранных фреймов, окно, выбранное в фрейме, становится выбранным окном,
если фрейм когда-либо был выбран.  @xref{Selecting Windows}.

@defun selected-window
Функция возвращает выбранное окно (которое всегда является активным окном).
@end defun

@anchor{Window Group}Иногда несколько окон вместе и совместно отображают
буфер, например, под управлением режима следования
(@pxref{Follow Mode,,, emacs}), где окна вместе отображают большую часть
буфера, чем одно окно могло бы в одиночку.  Часто бывает полезно
рассматривать такую @dfn{оконную группу} как единый объект.  Некоторые
функции, такие как @code{window-group-start} (@pxref{Window Start and End}),
позволяют сделать это, задавая в качестве аргумента одно из окон в качестве
замены для всей группы.

@defun selected-window-group
@vindex selected-window-group-function
Когда выбранное окно является членом группы окон, эта функция возвращает
список окон в группе, упорядоченный так, чтобы первое окно в списке
отображало самую раннюю часть буфера, и так далее.  В противном случае
функция возвращает список, содержащий только выбранное окно.

Выбранное окно считается частью группы, если локальная переменная буфера
@code{selected-window-group-function} указывает на функцию.  В этом случае
@code{selected-window-group} вызывает её без аргументов и возвращает
результат (который должен быть списком окон в группе).
@end defun

@node Windows and Frames
@section Окна и Фреймы

Каждое окно принадлежит ровно одному фрейму (@pxref{Frames}).

@defun window-frame &optional window
Функция возвращает фрейм, которому принадлежит окно @var{window}.  Если
@var{window} равен @code{nil}, по умолчанию используется выбранное окно.
@end defun

@defun window-list &optional frame minibuffer window
Функция возвращает список активных окон, принадлежащих фрейму @var{frame}.
Если @var{frame} опущен или @code{nil}, по умолчанию используется выбранный
фрейм.

Необязательный аргумент @var{minibuffer} указывает, нужно ли включать окно
минибуфера в возвращаемый список.  Если @var{minibuffer} равен @code{t},
включается окно минибуфера.  Если @var{minibuffer} равен @code{nil} или не
указан, окно минибуфера включается, только если оно активно.  Если
@var{minibuffer} не является ни @code{nil}, ни @code{t}, окно минибуфера
никогда не включается.

Необязательный аргумент @var{window}, если не-@code{nil}, должен быть
активным окном в указанном фрейме; тогда @var{window} будет первым элементом
в возвращаемом списке.  Если @var{window} опущено или @code{nil}, окно,
выбранное в фрейме, является первым элементом.
@end defun

@cindex window tree
@cindex root window
  Окна в том же фрейме организованы в @dfn{оконное дерево}, конечными узлами
которого являются активные окна.  Внутренние узлы оконного дерева не
используются; они существуют с целью организации отношений между активными
окнами.  Корневой узел дерева окон называется @dfn{оконным корнем}.  Это
может быть либо активное окно (если в фрейме только одно окно), либо
внутреннее окно.

  Окно минибуфера (@pxref{Minibuffer Windows}), которое находится не только
в своем фрейме, не имеет родительского окна, поэтому, строго говоря, оно не
является частью дерева окон своего фрейма.  Тем не менее, это одноуровневое
окно корневого окна фрейма, и, таким образом, к нему можно получить доступ
через @code{window-next-sibling}.  Кроме того, функция @code{window-tree},
описанная в конце этого раздела, перечисляет окно минибуфера вместе с
фактическим деревом окон.

@defun frame-root-window &optional frame-or-window
Функция возвращает корневое окно для @var{frame-or-window}.  Аргумент
@var{frame-or-window} должен быть окном или фреймом; если опущен или
@code{nil}, по умолчанию используется выбранный фрейм.  Если
@var{frame-or-window} - это окно, возвращаемое значение - это корневое окно
фрейма этого окна.
@end defun

@cindex parent window
@cindex child window
@cindex sibling window
  Когда окно разделено, появляются два активных окна там, где раньше было
одно.  Одно из них представлено тем же объектом окна Lisp, что и исходное
окно, а другое - вновь созданное объектом окна Lisp.  Оба этих активных
окна становятся листовыми узлами дерева окон, как @dfn{дочерние окна} одного
внутреннего окна.  При необходимости Emacs автоматически создает это
внутреннее окно, которое также называется @dfn{родительское окно}, и
присваивает ему соответствующую позицию в дереве окон.  Набор окон с одним и
тем же родителем называется @dfn{потомками}.

@cindex parent window
@defun window-parent &optional window
Функция возвращает родительское окно @var{window}.  Если @var{window} не
указано или @code{nil}, по умолчанию используется выбранное окно.
Возвращаемое значение - @code{nil}, если @var{window} не имеет родителя
(то есть это окно минибуфера или корневое окно его фрейма).
@end defun

  Каждое внутреннее окно всегда имеет как минимум два дочерних окна.  Если
это число падает до единицы в результате удаления окна, Emacs автоматически
удаляет внутреннее окно, и его единственное оставшееся дочернее окно
занимает свое место в дереве окон.

  Каждое дочернее окно может быть либо активным окном, либо внутренним окном
(которое, в свою очередь, будет иметь свои собственные дочерние окна).
Следовательно, каждое внутреннее окно можно представить себе как занимающее
определенный прямоугольный @dfn{область экрана} - объединение областей,
занятых окнами реального времени, которые в конечном итоге происходят от
него.

@cindex window combination
@cindex vertical combination
@cindex horizontal combination
  Для каждого внутреннего окна области экрана непосредственных дочерних
элементов располагаются либо вертикально, либо горизонтально (но не
одновременно).  Если дочерние окна расположены одно над другим, говорится,
что они образуют @dfn{вертикальное сочетание}; если расположены бок о бок,
говорится, что они образуют @dfn{горизонтальное сочетание}.  Рассмотрим
следующий пример:

@smallexample
@group
     ______________________________________
    | ______  ____________________________ |
    ||      || __________________________ ||
    ||      |||                          |||
    ||      |||                          |||
    ||      |||                          |||
    ||      |||____________W4____________|||
    ||      || __________________________ ||
    ||      |||                          |||
    ||      |||                          |||
    ||      |||____________W5____________|||
    ||__W2__||_____________W3_____________ |
    |__________________W1__________________|

@end group
@end smallexample

@noindent
Корневым окном этого фрейма является внутреннее окно @var{W1}.  Его дочерние
окна образуют горизонтальную комбинацию, состоящую из активных окон
изображения @var{W2} и внутреннего окна @var{W3}.  Дочерние окна @var{W3}
образуют вертикальную комбинацию, состоящую из активных окон @var{W4} и
@var{W5}.  Следовательно, активные окна в этом дереве окон - @var{W2},
@var{W4}, и @var{W5}.

  Следующие функции могут использоваться для получения дочернего окна
внутреннего окна и одноуровневых элементов дочернего окна.

@defun window-top-child &optional window
Функция возвращает самое верхнее дочернее окно @var{window}, если
@var{window} - внутреннее окно, дочерние элементы которого образуют
вертикальную комбинацию.  Для любого другого типа окна возвращаемое
значение - @code{nil}.
@end defun

@defun window-left-child &optional window
Функция возвращает самое левое дочернее окно @var{window}, если @var{window}
- внутреннее окно, дочерние элементы которого образуют горизонтальную
комбинацию.  Для любого другого типа окна возвращаемое значение -
@code{nil}.
@end defun

@defun window-child window
Функция возвращает первое дочернее окно внутреннего окна @var{window} ---
самое верхнее дочернее окно для вертикальной комбинации или самое левое
дочернее окно для горизонтальной комбинации.  Если @var{window} является
активным окном, возвращаемое значение - @code{nil}.
@end defun

@defun window-combined-p &optional window horizontal
Функция возвращает значение не-@code{nil} тогда и только тогда, когда
@var{window} является частью вертикальной комбинации.  Если @var{window}
опущено или @code{nil}, по умолчанию используется выбранное окно.

Если необязательный аргумент @var{horizontal} - не-@code{nil}, это означает
возвращение не-@code{nil} тогда и только тогда, когда @var{window} является
частью горизонтальной комбинации.
@end defun

@defun window-next-sibling &optional window
Функция возвращает следующего брата окна @var{window}.  Если опущено или
@code{nil}, @var{window} по умолчанию используется в выбранном окне.
Возвращаемое значение - @code{nil}, если @var{window} - последний дочерний
элемент своего родителя.
@end defun

@defun window-prev-sibling &optional window
Функция возвращает предыдущего брата окна @var{window}.  Если опущено, или
@code{nil}, @var{window} по умолчанию используется в выбранном окне.
Возвращаемое значение - @code{nil}, если @var{window} является первым
потомком своего родителя.
@end defun

Функции @code{window-next-sibling} и @code{window-prev-sibling} не следует
путать с функциями @code{next-window} и @code{previous-window}, которые
возвращают следующее и предыдущее окно, соответственно, в циклическом
порядке окон (@pxref{Cyclic Window Ordering}).

  Следующие функции могут быть полезны для нахождения окна внутри его
фрейма.

@defun frame-first-window &optional frame-or-window
Функция возвращает окно реального времени в верхнем левом углу кадра,
заданного @var{frame-or-window}.  Аргумент @var{frame-or-window} должен
обозначать окно или активный фрейм и по умолчанию использовать выбранный
фрейм.  Если @var{frame-or-window} указывает окно, эта функция возвращает
первое окно во фрейме этого окна.  При условии, что кадр из нашего
канонического примера выбран @code{(frame-first-window)}, возвращает
@var{W2}.
@end defun

@defun window-at-side-p &optional window side
Функция возвращает @code{t}, если @var{window} находится в @var{side}
содержащего его фоейма.  Аргумент @var{window} должен быть действительным
окном и по умолчанию выбранным.  Аргумент @var{side} может быть любой из
символов @code{left}, @code{top}, @code{right} или @code{bottom}.  Значение
по умолчанию @code{nil} обрабатывается как @code{bottom}.

Обратить внимание, что эта функция игнорирует окно минибуфера
(@pxref{Minibuffer Windows}).  Следовательно, если @var{side} равно
@code{bottom}, может возвращаться @code{t} также, когда окно минибуфера
появляется прямо под @var{window}.
@end defun

@cindex window in direction
@defun window-in-direction direction &optional window ignore sign wrap mini
Функция возвращает ближайшее окно реального времени в направлении
@var{direction}, если смотреть с позиции @code{window-point} в окне
@var{window}.  Аргумент @var{direction} должен быть одним из @code{above},
@code{below}, @code{left} или @code{right}.  Необязательный аргумент
@var{window} должен обозначать активное окно и по умолчанию использовать
выбранное.

Функция не возвращает окно, если параметр @code{no-other-window} которого
равен не-@code{nil} (@pxref{Window Parameters}).  Если параметр
@code{no-other-window} ближайшего окна равен не-@code{nil}, эта функция
пытается найти другое окно в указанном направлении, параметр
@code{no-other-window} которого равен @code{nil}.  Если необязательный
аргумент @var{ignore} - не-@code{nil}, окно может быть возвращено, даже если
его параметр @code{no-other-window} - не-@code{nil}.

Если необязательный аргумент @var{sign} - отрицательное число, это означает
использование правого или нижнего края @var{window} в качестве ссылочной
позиции вместо @code{window-point}.  Если @var{sign} является положительным
числом, то это значит использовать левый или верхний край @var{window} в
качестве опорной позиции.

Если необязательный аргумент @var{wrap} - не-@code{nil}, это означает, что
@var{direction} нужно обернуть вокруг границ фрейма.  Например, если
@var{window} находится вверху фрейма, а @var{direction} - @code{above}, то
функция обычно возвращает окно минибуфера фрейма, если оно активно, и
окно внизу фрейма в противном случае.

Если необязательный аргумент @var{mini} - @code{nil}, это означает, что окно
минибуфера должно возвращаться тогда и только тогда, когда оно активно в
данный момент.  Если @var{mini} равен не-@code{nil}, эта функция может
вернуть окно минибуфера, даже если оно не активно. Однако, если @var{wrap}
равен не-@code{nil}, всегда действует так, как если бы @var{mini} было
установлено в @code{nil}.

Если подходящего окна не найдено, функция возвращает @code{nil}.

Не использовать эту функцию для проверки наличия окна @emph{не} в
@var{direction}.  Вызов @code{window-at-side-p}, описанный выше, - гораздо
более эффективный способ сделать это.
@end defun

The following function allows the entire window tree of a frame to be
retrieved:

@defun window-tree &optional frame
Функция возвращает список, представляющий дерево окон для фрейми
@var{frame}.  Если @var{frame} опущен или @code{nil}, по умолчанию
используется выбранный фрейм.

Возвращаемое значение - это список вида @code{(@var{root} @var{mini})}, где
@var{root} представляет дерево окон корневого окна фрейма, а @var{mini} -
окно минибуфера фрейма.

Если корневое окно активно, @var{root} - это само окно.  В противном случае
@var{root} - список @code{(@var{dir} @var{edges} @var{w1} @var{w2} ...)},
где @var{dir} - это @code{nil} для горизонтальной комбинации, а @code{t} -
для вертикальной комбинации, @var{edges} дает размер и положение комбинации,
а остальные элементы являются дочерними окнами.  Каждое дочернее окно может
снова быть объектом окна (для активного окна) или списком с тем же форматом,
что и выше (для внутреннего окна).  Элемент @var{edges} - это список
@code{(@var{left} @var{top} @var{right} @var{bottom})}, аналогичный
значению, возвращаемому @code{window-edges}
(@pxref{Coordinates and Windows}).
@end defun


@node Window Sizes
@section Размеры Окон
@cindex window size
@cindex size of window

  На следующей схеме показана структура активного окна:

@smallexample
@group
        ____________________________________________
       |______________ Header Line ______________|RD| ^
     ^ |LS|LM|LF|                       |RF|RM|RS|  | |
     | |  |  |  |                       |  |  |  |  | |
Window |  |  |  |       Text Area       |  |  |  |  | Window
Body | |  |  |  |     (Window Body)     |  |  |  |  | Total
Height |  |  |  |                       |  |  |  |  | Height
     | |  |  |  |<- Window Body Width ->|  |  |  |  | |
     v |__|__|__|_______________________|__|__|__|  | |
       |_________ Horizontal Scroll Bar _________|  | |
       |_______________ Mode Line _______________|__| |
       |_____________ Bottom Divider _______________| v
        <---------- Window Total Width ------------>

@end group
@end smallexample

@cindex window body
@cindex text area of a window
@cindex body of a window
  В центре окна находится @dfn{text area} или @dfn{body}, где отображается
текст буфера.  Текстовая область может быть окружена рядом дополнительных
областей.  Слева и справа, от самого внутреннего до самого внешнего, это
левая и правая полосы, обозначенные LF и RF (@pxref{Fringes}); левое и
правое поля, обозначенные LM и RM на схеме (@pxref{Display Margins});
левая или правая вертикальная полоса прокрутки, только одна из которых
присутствует в любой момент, обозначается LS и RS (@pxref{Scroll Bars}); и
правый разделитель, обозначенный RD (@pxref{Window Dividers}).  Вверху окна
находится строка заголовка (@pxref{Header Lines}).  Внизу окна расположены
горизонтальная полоса прокрутки (@pxref{Scroll Bars}); строка режима
(@pxref{Mode Line Format}); и нижний делитель (@pxref{Window Dividers}).

  Emacs предоставляет разные функции для определения высоты и ширины окна.
Возвращаемое значение многих из этих функций может быть указано либо в
пикселях, либо в единицах строк и столбцов.  На графическом дисплее
последний фактически соответствует высоте и ширине символа по умолчанию,
заданного шрифтом по умолчанию фрейма, возвращаемым @code{frame-char-height}
и @code{frame-char-width} (@pxref{Frame Font}).  Таким образом, если окно
отображает текст с другим шрифтом или размером, сообщаемая высота строки и
ширина столбца для этого окна могут отличаться от фактического количества
текстовых строк или столбцов, отображаемых в нем.

@cindex window height
@cindex height of a window
@cindex total height of a window
  @dfn{total height} окна - это количество строк, составляющих тело окна,
строку заголовка, горизонтальную полосу прокрутки, строку режима и нижний
разделитель (если есть).

@defun window-total-height &optional window round
Функция возвращает общую высоту в строках окна @var{window}.  Если
@var{window} опущен или @code{nil}, по умолчанию используется выбранное
окно.  Если @var{window} - внутреннее окно, возвращаемое значение - это
общая высота, занимаемая его дочерними окнами.

  Если высота в пикселях окна не является целым числом, кратным высоте
символа его фрейма по умолчанию, количество строк, занимаемых окном,
округляется внутри.  Это делается таким образом, что, если окно является
родительским окном, сумма общих высот всех его дочерних окон внутренне равна
общей высоте их родительского окна.  Это означает, что хотя два окна имеют
одинаковую высоту в пикселях, их внутренняя общая высота может отличаться на
одну строку.  Это также означает, что если окно объединено по вертикали и
имеет следующего брата, самая верхняя строка этого брата может быть
вычислена как сумма самой верхней строки этого окна и общей высоты
(@pxref{Coordinates and Windows})

  Если необязательный аргумент @var{round} равен @code{ceiling}, эта функция
возвращает наименьшее целое число, превышающее высоту пикселя @var{window},
деленное на высоту символа его фрейма; если это @code{floor}, возвращается
наибольшее целое число, меньшее указанного значения; с любым другим
@var{round} возвращается внутреннее значение общей высоты @var{windows}.
@end defun

@cindex window width
@cindex width of a window
@cindex total width of a window
@dfn{total width} окна - это количество строк, составляющих тело окна, его
поля, полосы, полосы прокрутки и правый разделитель (если есть).

@defun window-total-width &optional window round
Функция возвращает общую ширину окна @var{window} в столбцах.  Если
@var{window} опущен или @code{nil}, по умолчанию используется выбранное
окно.  Если @var{window} является внутренним, возвращаемое значение - это
общая ширина, занимаемая его дочерними окнами.

  Если ширина окна в пикселях не является целым числом кратным ширине его
фрейма, количество строк, занимаемых окном, внутри округляется.  Это
делается так, что, если окно является родительским окном, сумма общей ширины
всех его дочерних элементов внутри равна общей ширине их родительского окна.
Это означает, что хотя два окна имеют одинаковую ширину в пикселях, их
внутренняя общая ширина может отличаться на один столбец.  Это также
означает, что если это окно объединено по горизонтали и имеет следующего
брата, крайний левый столбец этого родственного элемента может быть
вычислен как сумма самого левого столбца этого окна и общей ширины
(@pxref{Coordinates and Windows}).  Необязательный аргумент @var{round}
ведет себя так же, как и для @code{window-total-height}.
@end defun

@defun window-total-size &optional window horizontal round
Функция возвращает либо общую высоту в строках, либо общую ширину в столбцах
окна @var{window}.  Если @var{horizontal} опущен или @code{nil}, это
эквивалентно вызову @code{window-total-height} для @var{window}; в противном
случае это эквивалентно вызову @code{window-total-width} для @var{window}.
Необязательный аргумент @var{round} действует так же, как и для
@code{window-total-height}.
@end defun

Следующие две функции могут использоваться для возврата общего размера окна
в пикселях.

@cindex window pixel height
@cindex pixel height of a window
@cindex total pixel height of a window

@defun window-pixel-height &optional window
Функция возвращает общую высоту окна @var{window} в пикселях.  @var{window}
должен быть допустимым окном и по умолчанию выбран выбранным.

Возвращаемое значение включает режим и строку заголовка, горизонтальную
полосу прокрутки и нижний разделитель, если таковой имеется.  Если
@var{window} является внутренним окном, его высота в пикселях - это высота в
пикселях областей экрана, охватываемых его дочерними элементами.
@end defun

@defun window-pixel-height-before-size-change &optional Lisp_Object &optional window
Функция возвращает высоту окна @var{window} в пикселях на момент последнего
запуска @code{window-size-change-functions} на фрейме @var{window}
(@pxref{Window Hooks}).
@end defun

@cindex window pixel width
@cindex pixel width of a window
@cindex total pixel width of a window

@defun window-pixel-width &optional window
Функция возвращает ширину окна @var{window} в пикселях.  @var{window} должен
быть допустимым окном и по умолчанию выбран выбранным.

Возвращаемое значение включает границы и поля @var{window}, а также любые
вертикальные разделители или полосы прокрутки, принадлежащие @var{window}.
Если @var{window} является внутренним окном, его ширина в пикселях - это
ширина областей экрана, охватываемых его дочерними элементами.
@end defun

@defun window-pixel-width-before-size-change &optional Lisp_Object &optional window
Функция возвращает ширину окна @var{window} в пикселях на момент последнего
запуска @code{window-size-change-functions} на фрейме @var{window}
(@pxref{Window Hooks}).
@end defun

@cindex full-width window
@cindex full-height window
  Следующие функции могут использоваться, чтобы определить, есть ли в данном
окне какие-либо смежные окна.

@defun window-full-height-p &optional window
Функция возвращает не-@code{nil}, если @var{window} не имеет другого окна
выше или ниже в своем фрейме.  Точнее, это означает, что общая высота
@var{window} равна общей высоте корневого окна в этом фрейме.  Окно
минибуфера в этом отношении не учитывается.  Если @var{window} опущено или
@code{nil}, по умолчанию используется выбранное окно.
@end defun

@defun window-full-width-p &optional window
Функция возвращает не-@code{nil}, если @var{window} не имеет другого окна
слева или справа в его фрейме, то есть его общая ширина равна ширине
корневого окна в этом фрейме.  Если @var{window} опущен или @code{nil}, по
умолчанию используется выбранное окно.
@end defun

@cindex window body height
@cindex body height of a window
@dfn{body height} окна - это высота его текстовой области, которая не
включает режим или строку заголовка, горизонтальную полосу прокрутки или
нижний разделитель.

@defun window-body-height &optional window pixelwise
Функция возвращает высоту в строках тела окна @var{window}.  Если
@var{window} опущен или @code{nil}, по умолчанию используется выбранное
окно; в противном случае это должно быть активное окно.

Если необязательный аргумент @var{pixelwise} - не-@code{nil}, функция
возвращает высоту тела @var{window} в пикселях.

Если @var{pixelwise} равен @code{nil}, возвращаемое значение при
необходимости округляется до ближайшего целого числа.  Это означает, что
если строка в нижней части текстовой области видна только частично, эта
строка не учитывается.  Это также означает, что высота тела окна никогда не
может превышать его общую высоту, возвращаемую @code{window-total-height}.
@end defun

@cindex window body width
@cindex body width of a window
@dfn{body width} окна - это ширина его текстовой области, которая не
включает полосу прокрутки, края, поля или правый разделитель.  Обратить
внимание, что при удалении одной или обеих полос (путем установки их ширины
на ноль) механизм отображения резервирует две символьные ячейки, по одной с
каждой стороны окна, для отображения глифов продолжения и усечения, что
оставляет на 2 столбца меньше для отображения текста.  (Функция
@code{window-max-chars-per-line}, описанная ниже, учитывает эту
особенность.)

@defun window-body-width &optional window pixelwise
Функция возвращает ширину в столбцах тела окна @var{window}.  Если
@var{window} опущен или @code{nil}, по умолчанию используется выбранное
окно; в противном случае это должно быть живое окно.

Если необязательный аргумент @var{pixelwise} - не-@code{nil}, функция
возвращает ширину тела @var{window} в пикселях.

Если @var{pixelwise} равен @code{nil}, возвращаемое значение при
необходимости округляется до ближайшего целого числа.  Это означает, что
если столбец справа от текстовой области виден только частично, этот столбец
не учитывается.  Это также означает, что ширина тела окна никогда не может
превышать его общую ширину, возвращаемую @code{window-total-width}.
@end defun

@cindex window body size
@cindex body size of a window
@defun window-body-size &optional window horizontal pixelwise
Функция возвращает высоту или ширину тела @var{window}.  Если
@var{horizontal} опущен или @code{nil}, это эквивалентно вызову
@code{window-body-height} для @var{window}; в противном случае это
эквивалентно вызову @code{window-body-width}.  В любом случае необязательный
аргумент @var{pixelwise} передается вызываемой функции.
@end defun

Для совместимости с предыдущими версиями Emacs @code{window-height} - это
псевдоним для @code{window-total-height}, а @code{window-width} - это
псевдоним для @code{window-body-width}.  Эти псевдонимы считаются
устаревшими и будут удалены в будущем.

   Высота в пикселях режима окна и строки заголовка может быть получена с
помощью функций, приведенных ниже.  Их возвращаемое значение обычно является
точным, если окно не отображалось раньше: в этом случае возвращаемое
значение основывается на оценке шрифта, используемого для рамки окна.

@defun window-mode-line-height &optional window
Функция возвращает высоту в пикселях строки режима @var{window}.
@var{window} должно быть активным окном и по умолчанию быть выбранным.  Если
@var{window} не имеет строки режима, возвращаемое значение равно нулю.
@end defun

@defun window-header-line-height &optional window
Функция возвращает высоту в пикселях строки заголовка @var{window}.
@var{window} должно быть активным окном и по умолчанию быть выбранным.  Если
@var{window} не имеет строки заголовка, возвращаемое значение равно нулю.
@end defun

Функции для получения высоты и/или ширины разделителей окон
(@pxref{Window Dividers}), полос (@pxref{Fringes}), полос прокрутки
(@pxref{Scroll Bars}) и полей отображения (@pxref{Display Margins}) описаны
в соответствующих разделах.

Если программа Lisp должна принимать решения по компоновке, пригодится
следующая функция:

@defun window-max-chars-per-line &optional window face
Функция возвращает количество символов, отображаемых в границах
@var{face} в указанном окне @var{window} (которое должно быть активным
окном).  Если @var{face} было переназначено (@pxref{Face Remapping}),
информация возвращается для переназначенного вида отображения.  Если опущено
или @code{nil}, @var{face} по умолчанию принимает вид отображения по
умолчанию, а @var{window} по умолчанию используется для выбранного окна.

В отличие от @code{window-body-width}, эта функция учитывает фактический
размер шрифта @var{face} вместо того, чтобы работать в единицах канонической
ширины символа границ @var{window} (@pxref{Frame Font}).  Также учитывается
пространство, используемое глифом продолжения, если @var{window} не имеет
одной или обеих сторон.
@end defun

@cindex fixed-size window
@vindex window-min-height
@vindex window-min-width
  Команды, которые изменяют размер окон (@pxref{Resizing Windows}) или
разделяют их на (@pxref{Splitting Windows}), подчиняются переменным
@code{window-min-height} и @code{window-min-width}, которые определяют
минимально допустимую высоту и ширину окна.  Они также подчиняются
переменной @code{window-size-fixed}, с помощью которой окно может быть
@dfn{фиксированного} размера (@pxref{Preserving Window Sizes}).

@defopt window-min-height
Этот параметр определяет минимальную общую высоту в строках любого окна.
Его значение должно включать по крайней мере одну текстовую строку, а также
строку режима и заголовка, горизонтальную полосу прокрутки и нижний
разделитель, если таковой имеется.
@end defopt

@defopt window-min-width
Этот параметр определяет минимальную общую ширину в столбцах любого окна.
Его значение должно включать два текстовых столбца, а также поля, полосы,
полосу прокрутки и правый разделитель, если таковой имеется.
@end defopt

Следующая функция сообщает, насколько маленьким может стать конкретное окно
с учетом размеров его областей и значений @code{window-min-height},
@code{window-min-width} и @code{window-size-fixed}
(@pxref{Preserving Window Sizes}).

@defun window-min-size &optional window horizontal ignore pixelwise
Функция возвращает минимальный размер @var{window}.  @var{window} должено
быть допустимым окном и по умолчанию быть выбранным.  Необязательный
аргумент @var{horizontal} не-@code{nil} означает возврат минимального
количества столбцов @var{window}; в противном случае возврать минимального
количества строк @var{window}.

Возвращаемое значение гарантирует, что все компоненты @var{window} остаются
полностью видимыми, если размер @var{window} действительно был установлен
для этого.  @var{horizontal} в @code{nil} включает строку режима и
заголовка, горизонтальную полосу прокрутки и нижний разделитель, если он
есть.  @var{horizontal} в не-@code{nil} включает поля и полосы, вертикальную
полосу прокрутки и правый разделитель, если он есть.

Необязательный аргумент @var{ignore}, если не-@code{nil}, означает
игнорирование ограничений, налагаемых окнами фиксированного размера,
параметрами @code{window-min-height} или @code{window-min-width}.  Если
@var{ignore} равно @code{safe}, активные окна могут стать меньше строк
@code{window-safe-min-height} и столбцов @code{window-safe-min-width}.  Если
@var{ignore} является окном, игнорируются ограничения только для этого окна.
Любое другое значение от не-@code{nil} означает игнорирование всех
вышеперечисленных ограничений для всех окон.

Необязательный аргумент @var{pixelwise} не-@code{nil} означает возврат
минимального размера @var{window} в пикселях.
@end defun


@node Resizing Windows
@section Изменение Размера Окон
@cindex window resizing
@cindex resize window
@cindex changing window size
@cindex window size, changing

  В этом разделе описаны функции для изменения размера окна без изменения
размера его рамки.  Поскольку активные окна не перекрываются, эти функции
имеют смысл только для фреймов, содержащих два или более окон: изменение
размера окна также изменяет размер соседнего окна.  Если во фрейме только
одно окно, его размер нельзя изменить, кроме как путем изменения размера
фрейма (@pxref{Frame Size}).

  Если не указано иное, эти функции также принимают внутренние окна в
качестве аргументов.  Изменение размера внутреннего окна приводит к тому,
что его дочерние окна изменяются, чтобы соответствовать тому же
пространству.

@defun window-resizable window delta &optional horizontal ignore pixelwise
Функция возвращает @var{delta}, если размер @var{window} может быть изменен
по вертикали строками @var{delta}.  Если необязательный аргумент
@var{horizontal} - не-@code{nil}, вместо этого возвращается @var{delta},
если @var{window} можно изменять по горизонтали с помощью столбцов
@var{delta}.  Фактически это не меняет размер окна.

Если @var{window} равен @code{nil}, по умолчанию используется выбранное
окно.

Положительное значение @var{delta} означает проверку возможности увеличения
окна на это количество строк или столбцов; отрицательное значение
@var{delta} означает проверку, можно ли уменьшить окно на такое количество
строк или столбцов.  Если @var{delta} не равно нулю, возвращаемое значение 0
означает, что размер окна изменить нельзя.

Обычно переменные @code{window-min-height} и @code{window-min-width}
определяют наименьший допустимый размер окна (@pxref{Window Sizes}).
Однако, если необязательный аргумент @var{ignore} - не-@code{nil}, эта
функция игнорирует @code{window-min-height} и @code{window-min-width}, а
также @code{window-size-fixed}.  Вместо этого считается, что окно
минимальной высоты состоит из заголовка и строки режима, горизонтальной
полосы прокрутки и нижнего разделителя (если есть), а также текстовой
области высотой в одну строку; и окно минимальной ширины, состоящее из
полос, полей, полосы прокрутки и правого разделителя (если есть), а также
текстовой области шириной в два столбца.

Если необязательный аргумент @var{pixelwise} - не-@code{nil}, @var{delta}
интерпретируется как пиксели.
@end defun

@defun window-resize window delta &optional horizontal ignore pixelwise
Функция изменяет размер @var{window} с шагом @var{delta}.  Если
@var{horizontal} равен @code{nil}, изменяется высота на строки @var{delta};
в противном случае ширина изменяется на @var{delta} столбцов.  Положительное
значение @var{delta} означает увеличение окна, а отрицательное значение
@var{delta} означает его уменьшение.

Если @var{window} равно @code{nil}, по умолчанию используется выбранное
окно.  Если размер окна не может быть изменен в соответствии с требованиями,
выдается сигнал об ошибке.

Необязательный аргумент @var{ignore} имеет то же значение, что и для функции
@code{window-resizable} выше.

Если необязательный аргумент @var{pixelwise} - не-@code{nil}, @var{delta}
будет интерпретироваться как пиксели.

Выбор того, какие края окна изменяются этой функцией, зависит от значений
параметра @code{window-combination-resize} и пределов комбинации
задействованных окон; в некоторых случаях это может изменить оба края.
@xref{Recombining Windows}.  Чтобы изменить размер, перемещая только нижний
или правый край окна, используется функция
@code{adjust-window-trailing-edge}.
@end defun

@c Команды Увеличить окно, Увеличить окно по горизонтали, сжать окно и
@c сжать окно по горизонтали задокументированы в руководстве по Emacs.
@c Это не рекомендуется вызывать из Lisp.

@defun adjust-window-trailing-edge window delta &optional horizontal pixelwise
Функция перемещает нижний край @var{window} на строки @var{delta}.  Если
необязательный аргумент @var{horizontal} - не-@code{nil}, вместо этого
перемещается правый край на столбцы @var{delta}.  Если @var{window} равен
@code{nil}, по умолчанию используется выбранное окно.

Если необязательный аргумент @var{pixelwise} - не-@code{nil}, @var{delta}
интерпретируется как пиксели.

Положительное значение @var{delta} перемещает край вниз или вправо;
отрицательное @var{delta} перемещает его вверх или влево.  Если край не
может быть перемещен так далеко, как указано @var{delta}, эта функция
перемещает его как можно дальше, но не сигнализирует об ошибке.

Функция пытается изменить размер окон, прилегающих к перемещаемому краю.
Если это невозможно по какой-либо причине (например, если это соседнее окно
имеет фиксированный размер), может изменить размер других окон.
@end defun

@cindex pixelwise, resizing windows
@defopt window-resize-pixelwise
Если значение этой опции - не-@code{nil}, Emacs изменяет размеры окон в
пикселях.  В настоящее время это влияет на такие функции, как
@code{split-window} (@pxref{Splitting Windows}), @code{maximize-window},
@code{minimize-window}, @code{fit-window-to-buffer},
@code{fit-frame-to-buffer} и
@code{shrink-window-if-larger-than-buffer} (все перечисленны ниже).

Обратить внимание, что когда размер кадра в пикселях не кратен размеру его
символа, по крайней мере одно окно может быть изменено в пикселях, даже
если эта опция - @code{nil}.  Значение по умолчанию - @code{nil}.
@end defopt

  Следующие команды изменяют размер окон более конкретными способами.  При
интерактивном вызове они действуют в выбранном окне.

@deffn Command fit-window-to-buffer &optional window max-height min-height max-width min-width preserve-size
Команда регулирует высоту или ширину @var{window}, чтобы соответствовать
тексту в нем.  Возвращает не-@code{nil}, если можно было изменить размер
@var{window}, и в противном случае @code{nil}.  Если @var{window} опущено
или @code{nil}, по умолчанию используется выбранное окно.  В противном
случае это должно быть активное окно.

Если @var{window} является частью вертикальной комбинации, эта функция
регулирует высоту @var{window}.  Новая высота рассчитывается исходя из
фактической высоты доступной части буфера.  Необязательный аргумент
@var{max-height}, если не-@code{nil}, указывает максимальную общую высоту,
которую эта функция может дать @var{window}.  Необязательный аргумент
@var{min-height}, если не-@code{nil}, указывает минимальную общую высоту,
которую можно дать, которая переопределяет переменную
@code{window-min-height}.  И @var{max-height}, и @var{min-height} указаны в
строках и включают режим, строку заголовка и нижний разделитель, если
таковой имеется.

Если @var{window} является частью горизонтальной комбинации и значение
параметра @code{fit-window-to-buffer-horizontally} (смотреть ниже) равно
не-@code{nil}, функция регулирует ширину @var{window}.  Новая ширина
@var{window} рассчитывается из максимальной длины строк буфера, следующих за
текущей начальной позицией @var{window}.  Необязательный аргумент
@var{max-width} указывает максимальную ширину и по умолчанию равен ширине
рамки @var{window}.  Необязательный аргумент @var{min-width} указывает
минимальную ширину, по умолчанию - @code{window-min-width}.  Оба
@var{max-width} и @var{min-width} указаны в столбцах и включают обрамление,
поля и полосы прокрутки, если таковые имеются.

Необязательный аргумент @var{preserve-size}, если не-@code{nil}, установит
параметр для сохранения размера @var{window} во время будущих операций
изменения размера (@pxref{Preserving Window Sizes}).

Если опция @code{fit-frame-to-buffer} (смотреть ниже) - не-@code{nil}, эта
функция попытается изменить размер рамки @var{window}, чтобы соответствовала
его содержимому, вызывая @code{fit-frame-to-buffer} (смотреть ниже).
@end deffn

@defopt fit-window-to-buffer-horizontally
Если не-@code{nil}, @code{fit-window-to-buffer}, может изменять размер
окон по горизонтали.  Если @code{nil} (по умолчанию),
@code{fit-window-to-buffer} никогда не изменит размер окон по горизонтали.
Если @code{only}, может изменять размер окон только по горизонтали.  Любое
другое значение означает, что @code{fit-window-to-buffer} может изменять
размер окон в обоих измерениях.
@end defopt

@defopt fit-frame-to-buffer
Если опция установлена в не-@code{nil}, @code{fit-window-to-buffer}, может
поместить фрейм в свой буфер.  Фрейм подходит тогда и только тогда, когда
его корневое окно является активным окном и эта опция - не-@code{nil}.  Еслиэто @code{horizontally}, рамки подходят только по горизонтали.  Если это
@code{vertically}, рамки подходят только по вертикали.  Любое другое
значение не-@code{nil} означает, что размер фреймов можно изменять в обоих
измерениях.
@end defopt

Если у есть фрейм, который отображает только одно окно, можно поместить этот
фрейм в его буфер, используя команду @code{fit-frame-to-buffer}.

@deffn Command fit-frame-to-buffer &optional frame max-height min-height max-width min-width only
Команда регулирует размер @var{frame} для точного отображения содержимого
буфера.  @var{frame} может быть любым активным фреймом и по умолчанию
быть выбранным.  Подгонка производится только при активном корневом окне
@var{frame}.  Аргументы @var{max-height}, @var{min-height}, @var{max-width}
и @var{min-width} задают границы нового общего размера корневого окна
@var{frame}.  @var{min-height} и @var{min-width} по умолчанию принимает
значения @code{window-min-height} и @code{window-min-width} соответственно.

Если необязательный аргумент @var{only} - @code{vertically}, функция может
изменять размер кадра только по вертикали.  Если @var{only} равен
@code{horizontally}, можно изменять размер кадра только по горизонтали.
@end deffn

Поведение @code{fit-frame-to-buffer} можно контролировать с помощью двух
опций, перечисленных ниже.

@defopt fit-frame-to-buffer-margins
Опцию можно использовать для указания полей вокруг фреймов, которые будут
соответствовать @code{fit-frame-to-buffer}.  Такие поля могут быть полезны,
чтобы избежать, например, того, что рамка с измененным размером перекрывает
панель задач или части ее родительской рамки.

Определяет количество пикселей, которые должны быть оставлены свободными
слева, сверху, справа и снизу кадра соответственно.  По умолчанию для
каждого указывается @code{nil}, что означает отсутствие полей.  Указанное
здесь значение может быть переопределено для конкретного кадра параметром
@code{fit-frame-to-buffer-margins} этого кадра, если присутствует.
@end defopt

@defopt fit-frame-to-buffer-sizes
Опция определяет границы размера для @code{fit-frame-to-buffer}.  Определяет
общие максимальные и минимальные строки, а также максимальные и минимальные
столбцы корневого окна любого кадра, которое должно уместиться в его буфере.
Если любое из этих значений - не-@code{nil}, оно отменяет соответствующий
аргумент @code{fit-frame-to-buffer}.
@end defopt

@deffn Command shrink-window-if-larger-than-buffer &optional window
Команда пытается уменьшить высоту @var{window} насколько это возможно, при
этом показывая полный буфер, но не меньше, чем строк в
@code{window-min-height}.  Возвращаемое значение - не-@code{nil}, если
размер окна был изменен, и @code{nil} в противном случае.  Если @var{window}
опущено или @code{nil}, по умолчанию используется выбранное окно.  В
противном случае это должно быть активное окно.

Команда ничего не делает, если окно уже слишком короткое, чтобы отобразить
весь его буфер, или если какой-либо буфер прокручивается за пределы экрана,
или если окно является единственным активным окном в своем фрейме.

Команда вызывает @code{fit-window-to-buffer} (смотреть выше) для выполнения
своей работы.
@end deffn


@cindex balancing window sizes
@deffn Command balance-windows &optional window-or-frame
Функция уравновешивает окна таким образом, чтобы оставлять больше места для
окон во всю ширину и/или во всю высоту.  Если @var{window-or-frame}
указывает фрейм, уравновешивает все окна в этом фрейме.  Если
@var{window-or-frame} указывает окно, балансирует только это окно и его
братьев и сестер (@pxref{Windows and Frames}).
@end deffn

@deffn Command balance-windows-area
Функция пытается предоставить всем окнам в выбранном фрейме примерно
одинаковую долю площади экрана.  Окна во всю ширину или в высоту не занимают
больше места, чем другие окна.
@end deffn

@cindex maximizing windows
@deffn Command maximize-window &optional window
Функция пытается сделать @var{window} как можно больше в обоих измерениях
без изменения размера его рамки или удаления других окон.  Если @var{window}
опущено или @code{nil}, по умолчанию используется выбранное окно.
@end deffn

@cindex minimizing windows
@deffn Command minimize-window &optional window
Функция пытается сделать @var{window} как можно меньше в обоих измерениях,
не удаляя его и не изменяя размер его рамки.  Если @var{window} опущено или
@code{nil}, по умолчанию используется выбранное окно.
@end deffn


@node Preserving Window Sizes
@section Сохранение Размеров Окон
@cindex preserving window sizes

Размер окна можно изменить явно, используя одну из функций из предыдущего
раздела, или неявно, например, при изменении размера соседнего окна, при
разделении или удалении окна (@pxref{Splitting Windows},
@pxref{Deleting Windows}) или при изменении размера рамки окна
(@pxref{Frame Size}).

  Можно избежать неявного изменения размера конкретного окна, если в том же
фрейме есть одно или несколько других окон с изменяемым размером.  Для этого
следует посоветовать Emacs увеличить размер этого окна.  Для этого есть два
основных способа.

@defvar window-size-fixed
Если эта локальная переменная буфера - не-@code{nil}, размер любого окна,
отображающего буфер, обычно не может быть изменен.  Удаление окна или
изменение размера фрейма может по-прежнему изменять размер окна, если нет
выбора.

Если значение равно @code{height}, то фиксируется только высота окна; если
значение @code{width}, то фиксируется только ширина окна.  Любое другое
значение не-@code{nil} фиксирует как ширину, так и высоту.

Если эта переменная - @code{nil}, это не обязательно означает, что любое
окно, показывающее буфер, может быть изменено в желаемом направлении.  Чтобы
определить это, используйте функцию @code{window-resizable}.
@xref{Resizing Windows}.
@end defvar

Часто @code{window-size-fixed} слишком агрессивенj, потому что также
запрещает любые попытки явно изменить размер или разделить затронутое окно.
Это может произойти даже после неявного изменения размера окна, например,
при удалении соседнего окна или изменении размера рамки окна.  Следующая
функция изо всех сил пытается никогда не запрещать явное изменение размера
такого окна:

@defun window-preserve-size &optional window horizontal preserve
Функция (отменяет-) отмечает - высоту окна @var{window}, которая
сохраняется для будущих операций изменения размера.  @var{window} должно
быть активным окном и по умолчанию выбрано.  Если необязательный аргумент
@var{horizontal} - не-@code{nil}, (отменяет-) отмечает ширину @var{window}
как сохраненную.

Если необязательный аргумент @var{preserve} - @code{t}, это означает
сохранение текущей высоты/ширины тела @var{window}.  Высота/ширина
@var{window} изменится только в том случае, если у Emacs нет лучшего выбора.
Изменение размера окна, высота/ширина которого сохраняется этой функцией,
никогда не вызывает ошибки.

Если @var{preserve} равен @code{nil}, это означает прекращение сохранения
высоты/ширины @var{window}, снятие любых ограничений, наложенных предыдущим
вызовом этой функции для @var{window}.  Вызов @code{enlarge-window},
@code{shrink-window} или @code{fit-window-to-buffer} с аргументом
@var{window} также может удалить соответствующее ограничение.
@end defun

@code{window-preserve-size} в настоящее время вызывается следующими
функциями:

@table @code
@item fit-window-to-buffer
Если необязательный аргумент @var{preserve-size} этой функции
(@pxref{Resizing Windows}) равен не-@code{nil}, размер, установленный этой
функцией, сохраняется.

@item display-buffer
Если аргумент @var{alist} этой функции (@pxref{Choosing Window}) содержит
запись @code{preserve-size}, размер окна, созданного этой функцией,
сохраняется.
@end table

  @code{window-preserve-size} устанавливает параметр окна
(@pxref{Window Parameters}) с именем @code{window-preserved-size}, который
используется функциями изменения размера окна.  Этот параметр не
препятствует изменению размера окна, когда в окне отображается другой буфер,
отличный от того, который был при вызове @code{window-preserve-size}, или
если его размер с тех пор изменился.

Следующая функция может использоваться, чтобы проверить, сохраняется ли
высота конкретного окна:

@defun window-preserved-size &optional window horizontal
Функция возвращает сохраненную высоту окна @var{window} в пикселях.
@var{window} должно быть активным окном и по умолчанию быть выбранным.  Если
необязательный аргумент @var{horizontal} - не-@code{nil}, возвращается
сохраненная ширина @var{window}.  Возвращается @code{nil}, если размер
@var{window} не сохраняется.
@end defun


@node Splitting Windows
@section Разделение Окон
@cindex splitting windows
@cindex window splitting

В этом разделе описаны функции для создания нового окна с помощью
@dfn{расделение} существующего.  Обратить внимание, что некоторые окна
являются особенными в том смысле, что эти функции могут не разделить их, как
описано здесь.  Примерами таких окон являются боковые окна
(@pxref{Side Windows}) и атомарные окна (@pxref{Atomic Windows}).

@defun split-window &optional window size side pixelwise
Функция создает новое активное окно рядом с окном @var{window}.  Если
@var{window} опущено или @code{nil}, по умолчанию используется выбранное
окно.  Это окно разделяется и уменьшается в размере.  Место занимает новое
окно, которое возвращается.

Необязательный второй аргумент @var{size} определяет размеры @var{window}
и/или нового окна.  Если не указан или @code{nil}, обоим окнам присваивается
одинаковый размер; если есть нечетная строка, она размещается в новом окне.
Если @var{size} - положительное число, @var{window} даются строки @var{size}
(или столбцы, в зависимости от значения @var{side}).  Если @var{size} -
отрицательное число, в новом окне будет отображаться @minus{}@var{size}
строк (или столбцов).

Если @var{size} равен @code{nil}, эта функция подчиняется переменным
@code{window-min-height} и @code{window-min-width} (@pxref{Window Sizes}).
Таким образом, сигнализируется об ошибке, если разбиение приведет к
уменьшению окна меньше, чем указано в этих переменных.  Однако значение
не-@code{nil} для @var{size} приводит к тому, что эти переменные
игнорируются; в этом случае наименьшим допустимым окном считается такое, в
котором есть место для текстовой области высотой в одну строку и/или шириной
в два столбца.

Следовательно, если указано @var{size}, вызывающий должен проверить,
достаточно ли велики исходящие окна, чтобы охватить все области, такие как
строка режима или полоса прокрутки.  Функцию @code{window-min-size}
(@pxref{Window Sizes}) можно использовать для определения минимальных
требований @var{window} в этом отношении.  Поскольку новое окно обычно
наследует такие области, как строка режима или полоса прокрутки от
@var{window}, эта функция также является хорошим предположением для
минимального размера нового окна.  Вызывающий должен указать меньший размер
только в том случае, если он соответственно удаляет унаследованную область
перед следующим повторным отображением.

Необязательный третий аргумент @var{side} определяет положение нового окна
относительно @var{window}.  Если это @code{nil} или @code{below}, новое окно
помещается под @var{window}.  Если это @code{above}, новое окно размещается
над @var{window}.  В обоих случаях @var{size} указывает общую высоту окна в
строках.

Если @var{side} равен @code{t} или @code{right}, новое окно помещается
справа от @var{window}.  Если @var{side} - @code{left}, новое окно
помещается слева от @var{window}.  В обоих случаях @var{size} указывает
общую ширину окна в столбцах.

Необязательный четвертый аргумент @var{pixelwise}, если не-@code{nil},
означает интерпретацию @var{size} в единицах пикселей, а не в строках и
столбцах.

Если @var{window} является активным окном, новое окно наследует от него
различные свойства, включая поля и полосы прокрутки.  Если @var{window}
является внутренним окном, новое окно наследует свойства окна, выбранного
во фрейме @var{window}.

Поведение этой функции может быть изменено параметрами окна @var{window},
если переменная @code{ignore-window-parameters} имеет значение @code{nil}.
Если значение параметра окна @code{split-window} - @code{t}, эта функция
игнорирует все остальные параметры окна.  В противном случае, если значение
параметра окна @code{split-window} является функцией, эта функция вызывается
с аргументами @var{window}, @var{size} и @var{side} вместо обычного действия
@code{split-window}.  В другом случае эта функция подчиняется параметру окна
@code{window-atom} или @code{window-side}, если таковой имеется.
@xref{Window Parameters}.
@end defun

  В качестве примера, вот последовательность вызовов @code{split-window},
которая дает конфигурацию окна, обсуждаемую в @ref{Windows and Frames}.
Этот пример демонстрирует разделение активного окна, а также разделение
внутреннего окна.  Нчиноется с фрейма, содержащего одно окно (активное
корневое окно), которое обозначается @var{W4}.  Вызов
@code{(split-window W4)} дает такую конфигурацию окна:

@smallexample
@group
     ______________________________________
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||_________________W4_________________||
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||_________________W5_________________||
    |__________________W3__________________|

@end group
@end smallexample

@noindent
Вызовом @code{split-window} создаётся новое активное окно, обозначенное
@var{W5}.  Также создаётся новое внутреннее окно, обозначенное @var{W3},
которое становится корневым окном и родительским окном для @var{W4} и
@var{W5}.

  Затем вызывается @code{(split-window W3 nil 'left)}, с передачей в
качестве аргумента внутреннее окно @var{W3}.  Результат:

@smallexample
@group
     ______________________________________
    | ______  ____________________________ |
    ||      || __________________________ ||
    ||      |||                          |||
    ||      |||                          |||
    ||      |||                          |||
    ||      |||____________W4____________|||
    ||      || __________________________ ||
    ||      |||                          |||
    ||      |||                          |||
    ||      |||____________W5____________|||
    ||__W2__||_____________W3_____________ |
    |__________________W1__________________|
@end group
@end smallexample

@noindent
Новое активное окно @var{W2} создается слева от внутреннего окна @var{W3}.
Создается новое внутреннее окно @var{W1}, которое становится новым корневым
окном.

   Для интерактивного использования Emacs предоставляет две команды, которые
всегда разделяют выбранное окно.  Они внутри вызывают @code{split-window}.

@deffn Command split-window-right &optional size
Функция разделяет выбранное окно на два бок о бок окна, помещая выбранное
окно слева.  Если @var{size} положительно, левое окно получает столбцы
@var{size}; если @var{size} отрицательно, правое окно получает столбцы
@minus{}@var{size}.
@end deffn

@deffn Command split-window-below &optional size
Функция разделяет выбранное окно на два окна, одно над другим, оставляя
верхнее окно выбранным.  Если @var{size} положительно, верхнее окно получает
строки @var{size}; если @var{size} отрицательно, нижнее окно получает строки
@minus{}@var{size}.
@end deffn

@defopt split-window-keep-point
Если значение этой переменной - не-@code{nil} (по умолчанию),
@code{split-window-below} ведет себя, как описано выше.

Если @code{nil}, @code{split-window-below} регулирует точку в каждом из двух
окон, чтобы минимизировать повторное отображение.  (Это полезно на
медленных терминалах.)  Выбирается любое окно, содержащее строку экрана, на
которой ранее находилась точка.  Обратить внимание, что это влияет только на
@code{split-window-below}, но не на функцию @code{split-window} нижнего
уровня.
@end defopt


@node Deleting Windows
@section Удаление Окон
@cindex deleting windows

  @dfn{Удаление} окна удаляет его из дерева окон фрейма.  Если окно является
активным окном, оно исчезает с экрана.  Если окно является внутренним, его
дочерние окна также удаляются.

  Даже после того, как окно удалено, оно продолжает существовать как объект
Lisp до тех пор, пока на него не исчезнут ссылки.  Удаление окна можно
отменить, восстановив сохраненную конфигурацию окна
(@pxref{Window Configurations}).

@deffn Command delete-window &optional window
Функция удаляет @var{window} с дисплея и возвращает @code{nil}.  Если
@var{window} опущено или @code{nil}, по умолчанию используется выбранное
окно.

Если при удалении окна больше не останется окон в дереве окон (например,
если это единственное активное окно фрейма) или все оставшиеся окна в фрейме
@var{window} являются боковыми окнами (@pxref{Side Windows}), выдается
сигнал об ошибке.  Если @var{window} является частью атомарного окна
(@pxref{Atomic Windows}), эта функция вместо этого пытается удалить корень
этого атомарного окна.

По умолчанию, пространство, занимаемое @var{window}, отводится одному из
соседних соседних окон, если таковые имеются.  Однако, если переменная
@code{window-combination-resize} равна не-@code{nil}, пространство
пропорционально распределяется между любыми оставшимися окнами в той же
комбинации окон.  @xref{Recombining Windows}.

Поведение этой функции может быть изменено параметрами окна @var{window},
если переменная @code{ignore-window-parameters} имеет значение @code{nil}.
Если значение параметра окна @code{delete-window} - @code{t}, эта функция
игнорирует все остальные параметры окна.  В противном случае, если значение
параметра окна @code{delete-window} является функцией, эта функция
вызывается с аргументом @var{window} вместо обычного действия
@code{delete-window}.  @xref{Window Parameters}.
@end deffn

@deffn Command delete-other-windows &optional window
Функция заставляет @var{window} заполнять его фрейм, удаляя при
необходимости другие окна.  Если @var{window} не указан или @code{nil}, по
умолчанию используется выбранное окно.  Об ошибке сигнализируется, если
@var{window} является боковым окном (@pxref{Side Windows}).  Если
@var{window} является частью атомарного окна (@pxref{Atomic Windows}), эта
функция пытается заставить корень этого атомарного окна заполнить его фрейм.
Возвращаемое значение - @code{nil}.

Поведение этой функции может быть изменено параметрами окна @var{window},
если переменная @code{ignore-window-parameters} имеет значение @code{nil}.
Если значение параметра окна @code{delete-other-windows} - @code{t}, эта
функция игнорирует все остальные параметры окна.  В противном случае, если
значение параметра окна @code{delete-other-windows} является функцией, эта
функция вызывается с аргументом @var{window} вместо обычного действия
@code{delete-other-windows}.  @xref{Window Parameters}.

Кроме того, если @code{ignore-window-parameters} равно @code{nil}, эта
функция не удаляет ни одного окна, параметр @code{no-delete-other-windows}
которого равен не-@code{nil}.
@end deffn

@deffn Command delete-windows-on &optional buffer-or-name frame
Функция удаляет все окна, отображающие @var{buffer-or-name}, путем вызова
@code{delete-window} для этих окон.  @var{buffer-or-name} должно быть
буфером или именем буфера; если опущено или @code{nil}, по умолчанию
используется текущий буфер.  Если нет окон, показывающих указанный буфер,
эта функция ничего не делает.  Если указанный буфер является минибуфером,
выдается сигнал об ошибке.

Если есть выделенное окно, показывающее буфер, и это окно является
единственным в своем фрейме, эта функция также удаляет этот фрейм, если это
не единственный фрейм на терминале.

Необязательный аргумент @var{frame} указывает, с какими фреймами работать:

@itemize @bullet
@item @code{nil}
означает работать на всех фреймах.
@item @code{t}
означает работать с выбранным фреймом.
@item @code{visible}
означает работать со всеми видимыми фреймами.
@item @code{0}
означает работу со всеми видимыми или иконизированными фреймами.
@item A frame
означает работать с этим фреймом.
@end itemize

Обратить внимание, что этот аргумент не имеет того же значения, что и в
других функциях, сканирующих все активные окна
(@pxref{Cyclic Window Ordering}).  В частности, значения @code{t} и
@code{nil} здесь противоположны тому, что представляют собой в других таких
функциях.
@end deffn


@node Recombining Windows
@section Перекомпоновка Окон
@cindex recombining windows
@cindex windows, recombining

При удалении последнего брата окна @var{W}, его родительское окно также
удаляется, а @var{W} заменяет его в дереве окон.  Это означает, что @var{W}
должно быть повторно скомбинировано с его родителями и сестрами, чтобы
сформировать новую комбинацию окон (@pxref{Windows and Frames}).  В
некоторых случаях удаление активного окна может даже повлечь за собой
удаление двух внутренних окон.

@smallexample
@group
     ______________________________________
    | ______  ____________________________ |
    ||      || __________________________ ||
    ||      ||| ___________  ___________ |||
    ||      ||||           ||           ||||
    ||      ||||____W6_____||_____W7____||||
    ||      |||____________W4____________|||
    ||      || __________________________ ||
    ||      |||                          |||
    ||      |||                          |||
    ||      |||____________W5____________|||
    ||__W2__||_____________W3_____________ |
    |__________________W1__________________|

@end group
@end smallexample

@noindent
Удаление @var{W5} в этой конфигурации обычно приводит к удалению @var{W3} и
@var{W4}.  Остальные активные окна @var{W2}, @var{W6} и @var{W7}
рекомбинируются для образования новой горизонтальной комбинации с
родительским @var{W1}.

   Однако иногда имеет смысл не удалять родительское окно, например
@var{W4}.  В частности, не следует удалять родительское окно, если оно
использовалось для сохранения комбинации, встроенной в комбинацию того же
типа.  Такие вложения имеют смысл гарантиии, что когда разбивается окно и
впоследствии удаляете новое окно, Emacs восстанавливает макет связанного
фрейма, который существовал до разделения.

   Рассматривается сценарий, начинающийся с двух активных окон @var{W2} и
@var{W3} и их родительского @var{W1}.

@smallexample
@group
     ______________________________________
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||_________________W2_________________||
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||_________________W3_________________||
    |__________________W1__________________|

@end group
@end smallexample

@noindent
Разделите @var{W2}, чтобы сделать новое окно @var{W4} следующим образом.

@smallexample
@group
     ______________________________________
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||_________________W2_________________||
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||_________________W4_________________||
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||_________________W3_________________||
    |__________________W1__________________|

@end group
@end smallexample

@noindent
Теперь, увеличивая окно по вертикали, Emacs пытается получить
соответствующее пространство от своего младшего брата, при условии, что
такое окно существует.  В сценарии увеличение @var{W4} будет занимать место
у @var{W3}.

@smallexample
@group
     ______________________________________
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||_________________W2_________________||
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||_________________W4_________________||
    | ____________________________________ |
    ||_________________W3_________________||
    |__________________W1__________________|

@end group
@end smallexample

@noindent
Удаление @var{W4} теперь предоставит @var{W2} все пространство, включая
пространство, ранее украденное из @var{W3}.

@smallexample
@group
     ______________________________________
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||_________________W2_________________||
    | ____________________________________ |
    ||_________________W3_________________||
    |__________________W1__________________|

@end group
@end smallexample

@noindent
Это может показаться нелогичным, в частности, если @var{W4} использовалось
для временного отображения буфера (@pxref{Temporary Displays}), и требуется
продолжить работу с исходным макетом.

Поведение можно исправить, создав новое родительское окно при разделении
@var{W2}.  Описанная ниже переменная позволяет это сделать.

@defopt window-combination-limit
Переменная определяет, должно ли разделение окна создавать новое
родительское окно.  Признаны следующие значения:

@table @code
@item nil
Означает, что новому активному окну разрешено совместно использовать
существующее родительское окно, если оно существует, при условии, что
разделение происходит в том же направлении, что и существующая комбинация
окон (в противном случае в любом случае создается новое внутреннее окно).

@item window-size
Означает, что @code{display-buffer} создает новое родительское окно, когда
разделяет окно, и ему передается запись @code{window-height} или
@code{window-width} в аргументе @var{alist}
(@pxref{Buffer Display Action Functions}).  В противном случае разделение
окна ведет себя как для значения @code{nil}.

@item temp-buffer-resize
В этом случае @code{with-temp-buffer-window} создается новое родительское
окно, когда разбивается окно, и @code{temp-buffer-resize-mode} включен
(@pxref{Temporary Displays}).  В противном случае разбиение окна ведёт себя
как для @code{nil}.

@item temp-buffer
В этом случае @code{with-temp-buffer-window} всегда создает новое
родительское окно, когда разделяет существующее окно
(@pxref{Temporary Displays}).  В противном случае разделение окна ведёт себя
как для @code{nil}.

@item display-buffer
Это означает, что когда @code{display-buffer} (@pxref{Choosing Window})
разбивает окно, всегда создается новое родительское окно.  В противном
случае разбиение окна ведет себя как для @code{nil}.

@item t
Это означает, что при разделении окна всегда создается новое родительское
окно.  Таким образом, если значение этой переменной всегда @code{t}, то
всегда каждое дерево окон является двоичным деревом (деревом, в котором
каждое окно, кроме корневого, имеет ровно одного брата).
@end table

По умолчанию @code{window-size}.  Остальные значения зарезервированы для
использования в будущем.

Если в результате установки этой переменной @code{split-window} создается
новое родительское окно, также вызывается
@code{set-window-combination-limit} (смотреть ниже) во вновь созданном
внутреннем окне.  Это влияет на то, как дерево окон перестраивается при
удалении дочерних окон (смотреть ниже).
@end defopt

  Если @code{window-combination-limit} установлено в @code{t}, разделение
@var{W2} в начальной конфигурации этого сценария привело бы к следующему:

@smallexample
@group
     ______________________________________
    | ____________________________________ |
    || __________________________________ ||
    |||                                  |||
    |||________________W2________________|||
    || __________________________________ ||
    |||                                  |||
    |||________________W4________________|||
    ||_________________W5_________________||
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||_________________W3_________________||
    |__________________W1__________________|

@end group
@end smallexample

@noindent
Создано новое внутреннее окно @var{W5}; его дочерними элементами являются
@var{W2} и новое окно активного изображения @var{W4}.  Теперь @var{W2} -
единственный родственник @var{W4}, поэтому при увеличении @var{W4} будет
пытаться уменьшиться @var{W2}, не затрагивая @var{W3}.  Обратить внимание,
что @var{W5} представляет собой вертикальную комбинацию двух окон,
встроенных в вертикальную комбинацию @var{W1}.

@cindex window combination limit
@defun set-window-combination-limit window limit
Функция устанавливает @dfn{предел комбинации} окна @var{window} в
@var{limit}.  Это значение можно получить с помощью функции
@code{window-combination-limit}.  Смотреть ниже такие эффекты; обратить
внимание, что это имеет значение только для внутренних окон.  Функция
@code{split-window} автоматически вызывает эту функцию, передавая ей
@code{t} как @var{limit}, при условии, что при ее вызове значение переменной
@code{window-combination-limit} установлено в @code{t}.
@end defun

@defun window-combination-limit window
Функция возвращает предел комбинации для @var{window}.

Предел комбинации имеет значение только для внутреннего окна.  Если это
@code{nil}, то Emacs может автоматически удалить @var{window} в ответ на
удаление окна, чтобы сгруппировать дочерние окна @var{window} с его
родственными окнами формируя новую комбинацию окон.  Если предел
комбинирования - @code{t}, дочерние окна @var{window} никогда автоматически
не объединяются с его братьями и сестрами.

Если в конфигурации, показанной в начале этого раздела, предел комбинации
@var{W4} (родительское окно @var{W6} и @var{W7}) устанавливается в @code{t},
удаление @var{W5} не приведет к неявному удалению @var{W4}.
@end defun

В качестве альтернативы, проблем, описанных выше, можно избежать, всегда
изменяя размер всех окон в одной и той же комбинации, когда одно из окон
разделяется или удаляется.  Это также позволяет разбивать окна, которые в
противном случае были бы слишком малы для такой операции.

@defopt window-combination-resize
Если эта переменная установлена в @code{nil}, @code{split-window}, то можно
разделить окно (обозначается @var{window}), только если область экрана
@var{window} достаточно велика, чтобы вместить как само окно, так и новое
окно.

Если эта переменная - @code{t}, @code{split-window} пытается изменить размер
всех окон, которые являются частью той же комбинации, что и @var{window},
чтобы приспособиться к новому окну.  В частности, это может позволить
@code{split-window} успешно работать, даже если @var{window} является окном
фиксированного размера или слишком маленьким для обычного разделения.  Более
того, последующее изменение размера или удаление @var{window} может изменить
размер всех других окон в его комбинации.

По умолчанию @code{nil}.  Остальные значения зарезервированы для
использования в будущем.  Конкретная операция разделения может игнорировать
значение этой переменной, если на нее влияет значение не-@code{nil}
@code{window-combination-limit}.
@end defopt

  Чтобы проиллюстрировать эффект @code{window-combination-resize},
рассмотривается следующий макет фрейма.

@smallexample
@group
     ______________________________________
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||_________________W2_________________||
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||_________________W3_________________||
    |__________________W1__________________|

@end group
@end smallexample

@noindent
Если @code{window-combination-resize} равен @code{nil}, разделение окна
@var{W3} оставляет размер @var{W2} неизменным:

@smallexample
@group
     ______________________________________
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||_________________W2_________________||
    | ____________________________________ |
    ||                                    ||
    ||_________________W3_________________||
    | ____________________________________ |
    ||                                    ||
    ||_________________W4_________________||
    |__________________W1__________________|

@end group
@end smallexample

@noindent
Если @code{window-combination-resize} равен @code{t}, при разделении
@var{W3} все три активных окна будут иметь примерно одинаковую высоту:

@smallexample
@group
     ______________________________________
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||_________________W2_________________||
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||_________________W3_________________||
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||_________________W4_________________||
    |__________________W1__________________|

@end group
@end smallexample

@noindent
Удаление любого из активных окон @var{W2}, @var{W3} или @var{W4}
распределяет его пространство пропорционально между двумя оставшимися
активными окнами.


@node Selecting Windows
@section Выбор Окон
@cindex selecting a window

@defun select-window window &optional norecord
Функция делает @var{window} выбранным окном, а окно выбранным в его фрейме
(@pxref{Basic Windows}) и выбирает этот фрейм.  Это также делает буфер
@var{window} (@pxref{Buffers and Windows}) текущим и устанавливает значение
этого буфера @code{point} равным значению @code{window-point}
(@pxref{Window Point}) в @var{window}.  @var{window} должно быть активным
окном.  Возвращаемое значение - @var{window}.

По умолчанию эта функция также перемещает буфер @var{window} в начало списка
буферов (@pxref{Buffer List}) и делает @var{window} самым последним
выбранным окном.  Если необязательный аргумент @var{norecord} -
не-@code{nil}, эти дополнительные действия не выполняются.

Кроме того, эта функция по умолчанию также сообщает механизму отображения
обновить отображение @var{window}, когда его фрейм будет повторно отображен
в следующий раз.  Если @var{norecord} равен не-@code{nil}, такие обновления
обычно не выполняются.  Если, однако, @var{norecord} равно специальному
символу @code{mark-for-redisplay}, дополнительные действия, упомянутые выше,
опускаются, но @var{window}, тем не менее, обновляется.

Обратить внимание, что иногда выбора окна недостаточно, чтобы отобразить его
или сделать его фрейм самым верхним фреймом на дисплее: также может
потребоваться поднять фрейм или убедиться, что фокус ввода направлен на этот
фрейм.
@xref{Input Focus}.
@end defun

@cindex select window hook
@cindex running a hook when a window gets selected
По историческим причинам Emacs не запускает отдельную ловушку всякий раз,
когда выбирается окно.  Приложения и внутренние процедуры часто временно
выбирают окно, чтобы выполнить с ним несколько действий.  Делают это либо
для упрощения кодирования - потому что многие функции по умолчанию работают
с выбранным окном, когда не указан аргумент @var{window} - либо потому, что
некоторые функции не принимают (и до сих пор не принимают) окно в качестве
аргумента и всегда работают с выбранным окном.  Запуск ловушки каждый раз,
когда окно выбирается на короткое время и еще раз, когда восстанавливается
ранее выбранное окно, бесполезно.

  Однако, когда аргумент @var{norecord} - @code{nil}, @code{select-window}
обновляет список буферов и, таким образом, косвенно запускает обычный
обработчик @code{buffer-list-update-hook} (@pxref{Buffer List}).
Следовательно, этот перехватчик обеспечивает разумный способ запуска функции
всякий раз, когда окно выбирается больше ``нормы''.

  Поскольку @code{buffer-list-update-hook} также запускается функциями, не
имеющими отношения к управлению окнами, обычно имеет смысл сохранить
где-нибудь значение выбранного окна и сравнить его со значением
@code{selected-window} при запуске этого перехватчика.  Кроме того, чтобы
избежать ложных срабатываний при использовании
@code{buffer-list-update-hook}, рекомендуется, чтобы каждый вызов
@code{select-window}, предназначенный для выбора окна, только временно
передавал аргумент не-@code{nil} @var{norecord}.  По возможности в таких
случаях следует использовать макрос @code{with-selected-window} (смотреть
ниже).

@cindex most recently selected windows
  Последовательность вызовов @code{select-window} с аргументом не-@code{nil}
@var{norecord} определяет порядок окон по времени их выбора.  Функцию
@code{get-lru-window} можно использовать для извлечения последнего
выбранного окна реального времени (@pxref{Cyclic Window Ordering}).

@defmac save-selected-window forms@dots{}
Макрос записывает выбранный фрейм, а также выбранное окно каждого фрейма,
последовательно выполняет @var{forms}, затем восстанавливает ранее выбранный
фрейм и окна.  Также сохраняет и восстанавливает текущий буфер. Возвращает
значение последней формы в @var{forms}.

Макрос ничего не сохраняет и не восстанавливает о размерах, расположении или
содержимом окон; поэтому, если @var{forms} их изменит, изменение
сохраняется.  Если ранее выбранное окно какого-либо фрейма больше не
работает во время выхода из @var{forms}, выбранное окно этого фрейма
остается в покое.  Если ранее выбранное окно больше не является активным, то
любое окно, выбранное в конце @var{forms}, остается выбранным.  Текущий
буфер восстанавливается тогда и только тогда, когда он все еще активен при
выходе из @var{forms}.

Макрос не изменяет ни порядок недавно выбранных окон, ни список буферов.
@end defmac

@defmac with-selected-window window forms@dots{}
Макрос выбирает @var{window}, последовательно выполняет @var{forms}, затем
восстанавливает ранее выбранное окно и текущий буфер.  Порядок недавно
выбранных окон и список буферов остаются неизменными, если намеренно не
измените их в @var{forms}; например, вызовом @code{select-window} с
аргументом @var{norecord} @code{nil}.  Следовательно, макрос является
предпочтительным способом временно работать с @var{window} как с выбранным
окном без ненужного запуска @code{buffer-list-update-hook}.
@end defmac

@defun frame-selected-window &optional frame
Функция возвращает окно на @var{frame}, которое выбрано в этом фрейме.
@var{frame} должен быть активным фреймом; если опущено или @code{nil}, по
умолчанию используется выбранный фрейм.
@end defun

@defun set-frame-selected-window frame window &optional norecord
Функция делает @var{window} окном, выбранным в фрейме @var{frame}.
@var{frame} должен быть активным фреймом; если @code{nil}, по умолчанию
используется выбранный фрейм.  @var{window} должно быть активным окном; если
@code{nil}, по умолчанию используется выбранное окно.

Если @var{frame} - это выбранный фрейм, это делает @var{window} выбранным
окном.

Если необязательный аргумент @var{norecord} - не-@code{nil}, эта функция не
изменяет ни список последних выбранных окон, ни список буферов.
@end defun

@cindex window use time
@cindex use time of window
@cindex window order by time of last use
@defun window-use-time &optional window
Функция возвращает время использования окна @var{window}.  @var{window}
должно быть активным окном и по умолчанию быть выбранным.

@dfn{Использованное время} окна на самом деле не является значением времени,
а целым числом, которое монотонно увеличивается с каждым вызовом
@code{select-window} с аргументом @code{nil} @var{norecord}.  Окно с
наименьшим временем использования обычно называется окном с наименьшим
временем использования, а окно с наибольшим временем использования
называется самым широко использованным окном
(@pxref{Cyclic Window Ordering}).
@end defun


@node Cyclic Window Ordering
@section Циклическое Упорядочение Окон
@cindex cyclic ordering of windows
@cindex ordering of windows, cyclic
@cindex window ordering, cyclic

  Когда используется команда @w{@kbd{C-x o}} (@code{other-window}) для
выбора другого окна, происходить перемещение пр активным окнам в
определенном порядке.  Для любой данной конфигурации окон этот порядок
никогда не меняется.  Порядок называется
@dfn{циклическое упорядочение окон}.

  Порядок определяется обходом в глубину дерева окон каждого фрейма,
извлекая активные окна, которые являются конечными узлами дерева
(@pxref{Windows and Frames}).  Если минибуфер активен, окно минибуфера также
включается.  Порядок циклический, поэтому за последним окном в
последовательности следует первое.

@defun next-window &optional window minibuf all-frames
@cindex minibuffer window, and @code{next-window}
Функция возвращает активное окно, следующее за @var{window} в циклическом
порядке окон.  @var{window} должно быть активным окном; если опущено или
@code{nil}, по умолчанию используется выбранное окно.

Необязательный аргумент @var{minibuf} указывает, должны ли окна минибуфера
быть включены в циклический порядок.  Обычно, когда @var{minibuf} равен
@code{nil}, окно минибуфера включается только в том случае, если оно в
настоящее время активно; это соответствует поведению @w{@kbd{C-x o}}.
(Обратить внимание, что окно минибуфера активно, пока используется его
минибуфер, смотреть @ref{Minibuffers}).

Если @var{minibuf} равен @code{t}, циклическое упорядочение включает все
окна минибуфера.  Если @var{minibuf} не является ни @code{t}, ни @code{nil},
окна минибуфера не включаются, даже если они активны.

Необязательный аргумент @var{all-frames} указывает, какие фреймы следует
учитывать:

@itemize @bullet
@item @code{nil}
значит считать окна на фрейме @var{window}.  Если рассматривается окно
минибуфера (как указано аргументом @var{minibuf}), то учитываются и фреймы,
совместно использующие окно минибуфера.

@item @code{t}
означает учитывать окна на всех существующих фреймах.

@item @code{visible}
означает учитывать окна на всех видимых фреймах.

@item 0
означает учитывать окна на всех видимых или иконизированных фреймах.

@item A frame
означает рассматривать окна в этом конкретном фрейме.

@item Anything else
значит считать окна на фрейме @var{window}, и никакие другие.
@end itemize

Если рассматривается более одного фрейма, циклический порядок получается
добавлением порядка для этих фреймов в том же порядке, что и список всех
активных фреймов (@pxref{Finding All Frames}).
@end defun

@defun previous-window &optional window minibuf all-frames
Функция возвращает активное окно, предшествующее @var{window} в циклическом
порядке окон.  Остальные аргументы обрабатываются как в @code{next-window}.
@end defun

@deffn Command other-window count &optional all-frames
Функция выбирает активное окно, размещает каждых @var{count} окон от
выбранного окна в циклическом порядке окон.  Если @var{count} -
положительное число, окна @var{count} пропускаются вперед; если @var{count}
отрицательно, окна @minus{}@var{count} пропускаются назад; если @var{count}
равно нулю, это просто повторно выбирает выбранное окно.  При интерактивном
вызове @var{count} является аргументом числового префикса.

Необязательный аргумент @var{all-frames} имеет то же значение, что и в
@code{next-window}, как аргумент @code{nil} @var{minibuf} для
@code{next-window}.

Функция не выбирает окно, которое имеет параметр окна не-@code{nil}
@code{no-other-window} (@pxref{Window Parameters}), при условии, что
@code{ignore-window-parameters} имеет значение @code{nil}.

Если параметр @code{other-window} выбранного окна является функцией, а
@code{ignore-window-parameters} - @code{nil}, функция будет вызываться с
аргументами @var{count} и @var{all-frames} вместо нормальной работы этой
функции.
@end deffn

@defun walk-windows fun &optional minibuf all-frames
Функция вызывает функцию @var{fun} один раз для каждого активного окна с
окном в качестве аргумента.

Это следует за циклическим порядком окон.  Необязательные аргументы
@var{minibuf} и @var{all-frames} определяют набор включаемых окон; они имеют
те же аргументы, что и в @code{next-window}.  Если @var{all-frames} задает
фрейм, первое пройденное окно будет первым окном в этом фрейме (возвращенным
@code{frame-first-window}), не обязательно выбранным окном.

Если @var{fun} изменяет конфигурацию окна, разделяя или удаляя окна, это не
меняет набор пройденных окон, который определяется перед вызовом @var{fun} в
первый раз.
@end defun

@defun one-window-p &optional no-mini all-frames
Функция возвращает @code{t}, если выбранное окно является единственным
активным окном, и @code{nil} в противном случае.

Если окно минибуфера активно, оно обычно считается (так что эта функция
возвращает @code{nil}).  Однако, если необязательный аргумент @var{no-mini}
равен не-@code{nil}, окно минибуфера игнорируется, даже если оно активно.
Необязательный аргумент @var{all-frames} имеет то же значение, что и
@code{next-window}.
@end defun

@cindex finding windows
  Следующие функции возвращают окно, которое удовлетворяет некоторому
критерию, не выбирая его:

@cindex least recently used window
@defun get-lru-window &optional all-frames dedicated not-selected
Функция возвращает активное окно, которое эвристически использовалось меньше
всего в последнее время.  Необязательный аргумент @var{all-frames} имеет то
же значение, что и в @code{next-window}.

Если есть какие-либо окна во всю ширину, учитываются только эти окна.  Окно
минибуфера никогда не является кандидатом.  Выделенное окно
(@pxref{Dedicated Windows}) никогда не является кандидатом, если
необязательный аргумент @var{dedicated} не равен не-@code{nil}.  Выбранное
окно никогда не возвращается, если только оно не является единственным
кандидатом.  Однако, если необязательный аргумент @var{not-selected} -
не-@code{nil}, функция в этом случае возвращает @code{nil}.
@end defun

@cindex most recently used window
@defun get-mru-window &optional all-frames dedicated not-selected
Функция похожа на @code{get-lru-window}, но вместо этого возвращает
последнее использованное окно.  Значение аргументов такое же, как описано
для @code{get-lru-window}.
@end defun

@cindex largest window
@defun get-largest-window &optional all-frames dedicated not-selected
Функция возвращает окно с наибольшей площадью (высота умноженная на ширину).
Необязательный аргумент @var{all-frames} указывает окна для поиска и имеет
то же значение, что и в @code{next-window}.

Окно минибуфера никогда не является кандидатом.  Выделенное окно
(@pxref{Dedicated Windows}) никогда не является кандидатом, если
необязательный аргумент @var{dedicated} не равен не-@code{nil}.  Выбранное
окно не является кандидатом, если необязательный аргумент @var{not-selected}
- не-@code{nil}.  Если необязательный аргумент @var{not-selected} равен
не-@code{nil} и выбранное окно является единственным кандидатом, функция
возвращает @code{nil}.

Если есть два окна-кандидата одинакового размера, функция предпочитает то,
которое идет первым в циклическом порядке окон, начиная с выбранного окна.
@end defun

@cindex window that satisfies a predicate
@cindex conditional selection of windows
@defun get-window-with-predicate predicate &optional minibuf all-frames default
Функция вызывает функцию @var{predicate} для каждого из окон в циклическом
порядке окон по очереди, передавая ей окно в качестве аргумента.  Если
предикат возвращает не-@code{nil} для любого окна, функция останавливается
и возвращает это окно.  Если такое окно не найдено, возвращается значение
@var{default} (по умолчанию - @code{nil}).

Необязательные аргументы @var{minibuf} и @var{all-frames} указывают окна для
поиска и имеют то же значение, что и в @code{next-window}.
@end defun


@node Buffers and Windows
@section Буферы и Окна
@cindex examining windows
@cindex windows, controlling precisely
@cindex buffers, controlled in windows

  В этом разделе описаны низкоуровневые функции для проверки и настройки
содержимого окон.  @xref{Switching Buffers}, для высокоуровневых функций
отображения определенного буфера в окне.

@defun window-buffer &optional window
Функция возвращает буфер, отображаемый @var{window}.  Если @var{window}
опущен или @code{nil}, по умолчанию используется выбранное окно.  Если
@var{window} - внутреннее окно, функция возвращает @code{nil}.
@end defun

@defun set-window-buffer window buffer-or-name &optional keep-margins
Функция заставляет @var{window} отображать @var{buffer-or-name}.
@var{window} должно быть активным окном; если @code{nil}, по умолчанию
используется выбранное окно.  @var{buffer-or-name} должен быть буфером или
именем существующего буфера.  Функция не меняет, какое окно выбрано, и не
меняет напрямую, какой буфер является текущим (@pxref{Current Buffer}).
Возвращаемое значение - @code{nil}.

Если @var{window} - это @dfn{строго предназначеное} для буфера, а
@var{buffer-or-name} не указывает этот буфер, функция сигнализирует об
ошибке.  @xref{Dedicated Windows}.

По умолчанию функция сбрасывает положение @var{window}, поля отображения,
ширину границ и настройки полосы прокрутки на основе локальных переменных в
указанном буфере.  Однако, если необязательный аргумент @var{keep-margins} -
не-@code{nil}, оставляются только параметры отображения полей, полос и
полосы прокрутки @var{window}.

При написании приложения обычно требуется использовать @code{display-buffer}
(@pxref{Choosing Window}) или функции более высокого уровня, описанные в
@ref{Switching Buffers}, вместо прямого вызова @code{set-window-buffer}.

Запускает @code{window-scroll-functions}, а затем
@code{window-configuration-change-hook}.  @xref{Window Hooks}.
@end defun

@defvar buffer-display-count
Локальная для буфера переменная записывает, сколько раз буфер отображался в
окне.  Увеличивается каждый раз, когда @code{set-window-buffer} вызывается
для буфера.
@end defvar

@defvar buffer-display-time
Локальная для буфера переменная записывает время, когда буфер последний раз
отображался в окне.  Значение @code{nil}, если буфер никогда не отображался.
Обновляется каждый раз, когда @code{set-window-buffer} вызывается для
буфера, со значением, возвращаемым @code{current-time}.
(@pxref{Time of Day}).
@end defvar

@defun get-buffer-window &optional buffer-or-name all-frames
Функция возвращает первое окно, отображающее @var{buffer-or-name} в
циклическом порядке окон, начиная с выбранного окна
(@pxref{Cyclic Window Ordering}).  Если такого окна нет, возвращаемое
значение - @code{nil}.

@var{buffer-or-name} должен быть буфером или именем буфера; если опущено или
@code{nil}, по умолчанию используется текущий буфер.  Необязательный
аргумент @var{all-frames} указывает, какие окна следует учитывать:

@itemize @bullet
@item
@code{t} означает учитывать окна на всех существующих фреймах.
@item
@code{visible} означает считать окна на всех видимых фреймах.
@item
0 означает, что окна учитываются во всех видимых или иконизированных
фреймах.
@item
frame означает рассматривать окна только в этом фрейме.
@item
Любое другое значение означает, что окна будут учитываться в
выбранном фрейме.
@end itemize

Обратить внимание, что эти значения немного отличаются от значений аргумента
@var{all-frames} для @code{next-window} (@pxref{Cyclic Window Ordering}).
Функция может быть изменена в будущей версии Emacs, чтобы устранить это
несоответствие.
@end defun

@defun get-buffer-window-list &optional buffer-or-name minibuf all-frames
Функция возвращает список всех окон, в которых в данный момент отображается
@var{buffer-or-name}.  @var{buffer-or-name} должен быть буфером или именем
существующего буфера.  Если опущено или @code{nil}, по умолчанию
используется текущий буфер.  Если в текущем выбранном окне отображается
@var{buffer-or-name}, оно будет первым в списке, возвращаемом этой функцией.

Аргументы @var{minibuf} и @var{all-frames} имеют то же значение, что и в
функции @code{next-window} (@pxref{Cyclic Window Ordering}).  Обратить
внимание, что аргумент @var{all-frames} ведет себя точно так же, как
аргумент @code{get-buffer-window}.
@end defun

@deffn Command replace-buffer-in-windows &optional buffer-or-name
Команда заменяет @var{buffer-or-name} каким-либо другим буфером во всех
окнах, отображающих его.  @var{buffer-or-name} должен быть буфером или
именем существующего буфера; если опущено или @code{nil}, по умолчанию
используется текущий буфер.

Буфер замены в каждом окне выбирается через @code{switch-to-prev-buffer}
(@pxref{Window History}).  Любое выделенное окно, отображающее
@var{buffer-or-name}, по возможности удаляется (@pxref{Dedicated Windows}).
Если такое окно является единственным окном в своем фрейме и на том же
терминале есть другие фреймы, фрейм также удаляется.  Если выделенное окно
является единственным окном в единственном фрейме на своем терминале, буфер
все равно заменяется.
@end deffn


@node Switching Buffers
@section Переключение на Буфер в Окне
@cindex switching to a buffer

В этом разделе описаны высокоуровневые функции для переключения на указанный
буфер в некотором окне.  В общем, ``переключение на буфер'' означает (1)
показать буфер в некотором окне, (2) сделать это окно выбранным окном (а его
фрейм - выбранным фреймом) и (3) сделать буфер текущим буфером.

  @emph{Не} использовать эти функции, чтобы временно сделать буфер текущим
только для того, чтобы программа на Lisp могла получить к нему доступ или
изменить.  У них есть побочные эффекты, такие как изменение истории окон
(@pxref{Window History}), что удивит пользователя, если использовать его
таким образом.  Если требуется сделать буфер текущим, чтобы изменить его в
Lisp, использовать @code{with-current-buffer}, @code{save-current-buffer}
или @code{set-buffer}.  @xref{Current Buffer}.

@deffn Command switch-to-buffer buffer-or-name &optional norecord force-same-window
Команда пытается отобразить @var{buffer-or-name} в выбранном окне и сделать
его текущим буфером.  Часто используется интерактивно (как привязка
@kbd{C-x b}), а также в программах Lisp.  Возвращаемое значение - это буфер,
на который был переключен.

Если @var{buffer-or-name} установлено @code{nil}, по умолчанию используется
буфер, возвращаемый @code{other-buffer} (@pxref{Buffer List}).  Если
@var{buffer-or-name} - строка, которая не является именем какого-либо
существующего буфера, функция создает новый буфер с этим именем; основной
режим нового буфера определяется переменной @code{major-mode}
(@pxref{Major Modes}).

Обычно указанный буфер помещается в начало списка буферов - как глобального
списка буферов, так и списка буферов выбранного фрейма
(@pxref{Buffer List}).  Однако этого не происходит, если необязательный
аргумент @var{norecord} установлен в не-@code{nil}.

Иногда выбранное окно может не подходить для отображения буфера.  Это
происходит, если выбранное окно является окном минибуфера, или если
выбранное окно строго предназначено для своего буфера
(@pxref{Dedicated Windows}).  В таких случаях команда обычно пытается
отобразить буфер в другом окне, вызывая @code{pop-to-buffer} (смотреть
ниже).

Если необязательный аргумент @var{force-same-window} - не-@code{nil} и
выбранное окно не подходит для отображения буфера, функция всегда
сигнализирует об ошибке при неинтерактивном вызове.  При интерактивном
использовании, если выбранное окно является окном минибуфера, функция вместо
этого попытается использовать какое-нибудь другое окно.  Если выбранное окно
строго предназначено для своего буфера, для продолжения можно использовать
опцию @code{switch-to-buffer-in-dedicated-window}, описанную далее.
@end deffn

@defopt switch-to-buffer-in-dedicated-window
Опция, если не-@code{nil}, позволяет @code{switch-to-buffer} продолжить
работу при интерактивном вызове, а выбранное окно строго предназначено для
своего буфера.

Соблюдаются следующие ценности:

@table @code
@item nil
Запрещает при неинтерактивном использовании переключение и сигнализирует об
ошибке. 

@item prompt
Запрашивает пользователя, разрешить ли переключение.

@item pop
Для продолжения вызывает @code{pop-to-buffer}.

@item t
Помечает выбранное окно как незанятое и продолжается.
@end table

Эта опция не влияет на неинтерактивные вызовы @code{switch-to-buffer}.
@end defopt

По умолчанию @code{switch-to-buffer} пытается сохранить @code{window-point}.
Это поведение можно настроить с помощью следующей опции.

@defopt switch-to-buffer-preserve-window-point
Если переменная - @code{nil}, @code{switch-to-buffer}, отображается буфер,
указанный @var{buffer-or-name}, в позиции этого буфера @code{point}.  Если
переменная - @code{already-displayed}, проводится попытка отобразить буфер в
его предыдущей позиции в выбранном окне, при условии, что буфер в настоящее
время отображается в каком-либо другом окне в любом видимом или
иконизированном кадре.  Если переменная - @code{t}, @code{switch-to-buffer},
безоговорочно пытается отобразить буфер в его предыдущей позиции в
выбранном окне.

Переменная игнорируется, если буфер уже отображается в выбранном окне или
никогда не появлялся в нем раньше, или если @code{switch-to-buffer} вызывает
@code{pop-to-buffer} для отображения буфера.
@end defopt

Следующие две команды аналогичны @code{switch-to-buffer}, за исключением
описанных функций.

@deffn Command switch-to-buffer-other-window buffer-or-name &optional norecord
Функция отображает буфер, указанный @var{buffer-or-name}, в каком-то окне,
отличном от выбранного.  Используется внутренняя функция
@code{pop-to-buffer} (смотреть ниже).

Если в выбранном окне уже отображается указанный буфер, продолжает
отображаться, но, тем не менее, обнаруживается другое окно, которое также
отображает его.

Аргументы @var{buffer-or-name} и @var{norecord} имеют то же значение, что и
аргументы @code{switch-to-buffer}.
@end deffn

@deffn Command switch-to-buffer-other-frame buffer-or-name &optional norecord
Функция отображает буфер, указанный @var{buffer-or-name}, в новом фрейме.
Используется внутренняя функция @code{pop-to-buffer} (смотреть ниже).

Если указанный буфер уже отображается в другом окне, в любом фрейме на
текущем терминале, происходит переключенин на это окно вместо создания
нового фрейма.  Однако выбранное окно никогда не используется для этого.

Аргументы @var{buffer-or-name} и @var{norecord} имеют то же значение, что и
аргументы @code{switch-to-buffer}.
@end deffn

Вышеупомянутые команды используют функцию @code{pop-to-buffer}, которая
гибко отображает буфер в каком-либо окне и выбирает это окно для
редактирования.  В свою очередь @code{pop-to-buffer} использует
@code{display-buffer} для отображения буфера.  Следовательно, все
переменные, влияющие на @code{display-buffer}, также будут влиять на него.
@xref{Choosing Window}, для документации @code{display-buffer}.

@deffn Command pop-to-buffer buffer-or-name &optional action norecord
Функция делает @var{buffer-or-name} текущим буфером и отображает его в
каком-то окне, желательно не в текущем выбранном окне.  Затем выбирается
отображаемое окно.  Если это окно находится в другом графическом фрейме,
этот фрейм получает фокус ввода, если возможно (@pxref{Input Focus}).

Если @var{buffer-or-name} равно @code{nil}, по умолчанию используется буфер,
возвращаемый @code{other-buffer} (@pxref{Buffer List}).  Если
@var{buffer-or-name} - строка, которая не является именем какого-либо
существующего буфера, функция создает новый буфер с этим именем; основной
режим нового буфера определяется переменной @code{major-mode}
(@pxref{Major Modes}).  В любом случае буфер становится текущим и
возвращается, даже если не найдено подходящего окна для его отображения.

Если @var{action} равен не-@code{nil}, это должно быть действие отображения,
которое нужно передать в @code{display-buffer} (@pxref{Choosing Window}).
В качестве альтернативы, не-@code{nil}, значение, не входящее в список,
означает переход в окно, отличное от выбранного, даже если буфер уже
отображается в выбранном окне.

Как и @code{switch-to-buffer}, эта функция обновляет список буферов, если
@var{norecord} отлично от не-@code{nil}.
@end deffn


@node Displaying Buffers
@section Отображение Буфера в Подходящем Окне
@cindex buffer display
@cindex displaying a buffer

В этом разделе описаны функции нижнего уровня, которые Emacs использует для
поиска или создания окна для отображения указанного буфера.  Общая рабочая
лошадка этих функций - @code{display-buffer}, которая в конечном итоге
обрабатывает все входящие запросы на отображение буфера
(@pxref{Choosing Window}).

   @code{display-buffer} делегирует задачу поиска подходящего окна так
называемым функциям действия (@pxref{Buffer Display Action Functions}).
Во-первых, @code{display-buffer} составляет так называемый список действий -
специальный список ассоциаций, функции действия которых могут использовать
для точной настройки своего поведения.  Затем передается этот список каждой
функции действия, которую вызывает (@pxref{Buffer Display Action Alists}).

   Поведение @code{display-buffer} легко настраивается.  Чтобы понять, как
настройки используются на практике, можно изучить примеры, иллюстрирующие
порядок приоритета, который @code{display-buffer} использует для вызова
функций действий (@pxref{Precedence of Action Functions}).  Чтобы избежать
конфликтов между программами на Lisp, вызывающими @code{display-buffer}, и
пользовательскими настройками поведения, может иметь смысл следовать ряду
рекомендаций, которые набросаны в заключительной части этого раздела
(@pxref{The Zen of Buffer Display}).

@menu
* Choosing Window::         Как выбрать окно для отображения буфера.
* Buffer Display Action Functions:: Функции поддержки для отображения буфера.
* Buffer Display Action Alists:: Списки для тонкой настройки отображения буфера.
* Choosing Window Options:: Дополнительные параметры, влияющие на отображение буферов.
* Precedence of Action Functions:: Примеры, объясняющие приоритет функций действий.
* The Zen of Buffer Display:: Как избежать потери буферов между окнами.
@end menu


@node Choosing Window
@subsection Выбор Окна для Отображения Буфера

Команда @code{display-buffer} гибко выбирает окно для отображения и
отображает указанный буфер в этом окне.  Её можно вызвать интерактивно,
через привязку клавиш @kbd{C-x 4 C-o}.  Также используется в качестве
подпрограммы многими функциями и командами, включая @code{switch-to-buffer}
и @code{pop-to-buffer} (@pxref{Switching Buffers}).

@cindex buffer display display action
@cindex display action
  Команда выполняет несколько сложных шагов, чтобы найти окно для
отображения.  Эти шаги описываются с помощью @dfn{display actions}, что
имеет форму @code{(@var{functions} . @var{alist})}.  Здесь @var{functions} -
это либо отдельная функция, либо список функций, называемых
``функциями действия'' (@pxref{Buffer Display Action Functions}); и
@var{alist} - это список ассоциаций, называемый ``списком действий''
(@pxref{Buffer Display Action Alists}).  @xref{The Zen of Buffer Display},
для примеров действий отображения.

  Функция действия принимает два аргумента: отображаемый буфер и список
действий.  Пытается отобразить буфер в каком-то окне, выбирая или создавая
окно в соответствии со своими критериями.  В случае успеха возвращается
окно, в противном случае возвращается @code{nil}.

  @code{display-buffer} работает, комбинируя действия отображения из
нескольких источников и вызывая функции действий по очереди, пока одна из
них не сможет отобразить буфер и не вернет значение не-@code{nil}.

@deffn Command display-buffer buffer-or-name &optional action frame
Команда заставляет @var{buffer-or-name} появляться в каком-либо окне, не
выбирая окно и не делая буфер текущим.  Аргумент @var{buffer-or-name} должен
быть буфером или именем существующего буфера.  Возвращаемое значение - это
окно, выбранное для отображения буфера, или @code{nil}, если подходящего
окна не найдено.

Необязательный аргумент @var{action}, если не-@code{nil}, обычно должен быть
действием отображения (описано выше).  @code{display-buffer} создает список
функций действий и список действий, объединяя действия отображения из
следующих источников (в порядке их приоритета, от высшего к низшему):

@itemize
@item
Переменная @code{display-buffer-overriding-action}.

@item
Пользовательская опция @code{display-buffer-alist}.

@item
Аргумент @var{action}.

@item
Пользовательская опция @code{display-buffer-base-action}.

@item
Константа @code{display-buffer-fallback-action}.
@end itemize

@noindent
На практике это означает, что @code{display-buffer} формирует список всех
функций действий, определенных этими действиями отображения.  Первый элемент
этого списка - первая функция действия, заданная
@code{display-buffer-overriding-action}, если таковая имеется.  Его
последний элемент - @code{display-buffer-pop-up-frame} --- последняя функция
действия, указанная в @code{display-buffer-fallback-action}.  Дубликаты не
удаляются из этого списка - следовательно, одна и та же функция действия
может вызываться несколько раз за один вызов @code{display-buffer}.

@code{display-buffer} по очереди вызывает функции действий, указанные в этом
списке, передавая буфер в качестве первого аргумента и объединенный список
действий в качестве второго аргумента, пока одна из функций не вернет
не-@code{nil}.  @xref{Precedence of Action Functions}, например, как
отображать действия, указанные из разных источников, обрабатываются
@code{display-buffer}.

Обратить внимание, что вторым аргументом всегда является список записей
списка @emph{всех} действий , заданный указанными выше источниками.
Следовательно, первый элемент этого списка - первая запись списка действий,
заданная @code{display-buffer-overriding-action}, если таковая имеется.  Его
последний элемент - это последняя запись в списке
@code{display-buffer-base-action}, если таковая имеется (список действий
@code{display-buffer-fallback-action} пуст).

Также обратить внимание, что объединенный список действий может содержать
повторяющиеся записи и записи для одного и того же ключа с разными
значениями.  Как правило, функции действий всегда используют первую
ассоциацию найденного ими ключа.  Следовательно, ассоциация, которую
использует функция действия, не обязательно является ассоциацией,
предоставляемой действием отображения, которое задает эту функцию действия.

Аргумент @var{action} также может иметь значение не-@code{nil}, не входящее  в список.  Это имеет особое значение, буфер должен отображаться в окне,
отличном от выбранного, даже если выбранное окно уже отображает его.  При
интерактивном вызове с аргументом префикса @var{action} будет @code{t}.
Программы Lisp всегда должны предоставлять значение списка.

Необязательный аргумент @var{frame}, если не-@code{nil}, указывает, какие
фреймы проверять при принятии решения о том, отображается ли уже буфер.  Это
эквивалентно добавлению элемента @w{@code{(reusable-frames. @var{frame})}} в
список действий @var{action} (@pxref{Buffer Display Action Alists}).
Аргумент @var{frame} предоставляется из соображений совместимости, программы
Lisp не должны его использовать.
@end deffn

@defvar display-buffer-overriding-action
Значением этой переменной должно быть действие отображения, которое
обрабатывается @code{display-buffer} с наивысшим приоритетом.  Значение по
умолчанию - пустое действие отображения, то есть @w{@code{(nil . nil)}}.
@end defvar

@defopt display-buffer-alist
Значение этой опции - список условий отображения для отображения действий.
Каждое условие может быть либо регулярным выражением, соответствующим имени
буфера, либо функцией, которая принимает два аргумента: имя буфера и
аргумент @var{action}, переданный в @code{display-buffer}.  Если либо имя
буфера, переданное в @code{display-buffer}, совпадает с регулярным
выражением в этом списке, либо функция, заданная условием, возвращает
не-@code{nil}, то @code{display-buffer} использует соответствующее действие
display для отображения буфера.
@end defopt

@defopt display-buffer-base-action
Значением этого параметра должно быть действие отображения.  Этот параметр
можно использовать для определения стандартного действия отображения для
вызовов @code{display-buffer}.
@end defopt

@defvr Constant display-buffer-fallback-action
Это действие отображения задает резервное поведение для
@code{display-buffer}, если не заданы другие действия отображения.
@end defvr


@node Buffer Display Action Functions
@subsection Функции Действий для Отображения Буфера
@cindex buffer display action function
@cindex action function, for buffer display

@dfn{Функция действия} - это функция, вызываемая @code{display-buffer} для
выбора окна для отображения буфера.  Функции действий принимают два
аргумента: @var{buffer}, отображаемый буфер, и @var{alist}, список действий
(@pxref{Buffer Display Action Alists}).  Должны возвращать окно,
отображающее @var{buffer} в случае успеха и @code{nil} в случае неудачи.

   В Emacs определены следующие основные функции действий.

@defun display-buffer-same-window buffer alist
Функция пытается отобразить @var{buffer} в выбранном окне.  Это не удается,
если выбранное окно является окном минибуфера или выделено для другого
буфера (@pxref{Dedicated Windows}).  Это также не удается, если @var{alist}
имеет запись не-@code{nil} @code{inhibit-same-window}.
@end defun

@defun display-buffer-reuse-window buffer alist
Функция пытается отобразить @var{buffer}, находя окно, в котором он уже
отображается.

Если @var{alist} имеет запись не-@code{nil} @code{inhibit-same-window},
выбранное окно не может быть использовано повторно.  Набор фреймов для
поиска окна, в котором уже отображается @var{buffer}, можно указать с
помощью записи @code{reusable-frames} action alist.  Если @var{alist} не
содержит записи @code{reusable-frames}, функция ищет только выбранный фрейм.

Если функция выбирает окно в другом фрейме, делает этот фрейм видимым и,
если @var{alist} не содержит запись @code{inhibit-switch-frame}, при
необходимости поднимает этот фрейм.
@end defun

@defun display-buffer-reuse-mode-window buffer alist
Функция пытается отобразить @var{buffer}, находя окно, отображающее буфер в
заданном режиме.

Если @var{alist} содержит запись @code{mode}, его значение определяет
основной режим (символ) или список основных режимов.  Если @var{alist} не
содержит записи @code{mode}, вместо этого используется текущий основной
режим @var{buffer}.  Окно является кандидатом, если оно отображает буфер,
режим которого является производным от одного из указанных таким образом
режимов.

Поведение также контролируется записями @var{alist} для
@code{inhibit-same-window}, @code{reusable-frames} и
@code{inhibit-switch-frame}, как это делает
@code{display-buffer-reuse-window}.
@end defun

@defun display-buffer-pop-up-window buffer alist
Функция пытается отобразить @var{buffer} путем разделения самого большого
или наименее использованного окна (обычно расположенного в выбранном
фрейме).  Фактически выполняется разделение, вызывая функцию, указанную в
@code{split-window-preferred-function} (@pxref{Choosing Window Options}).

Размер нового окна можно настроить, добавив записи @code{window-height} и
@code{window-width} в @var{alist}.  Если @var{alist} содержит запись
@code{preserve-size}, Emacs также попытается сохранить размер нового окна
во время будущих операций изменения размера
(@pxref{Preserving Window Sizes}).

Функция не работает, если ни одно окно не может быть разделено.  Чаще всего
это происходит из-за того, что ни одно окно не является достаточно большим,
чтобы позволить разделение.  В этом отношении может помочь установка более
низких значений @code{split-height-threshold} или
@code{split-width-threshold}.  Разделение также не выполняется, если
выбранный фрейм имеет параметр фрейма @code{unsplittable},
@pxref{Buffer Parameters}.
@end defun

@defun display-buffer-in-previous-window buffer alist
Функция пытается отобразить @var{buffer} в окне, в котором он отображался
ранее.

Если @var{alist} содержит запись не-@code{nil} @code{inhibit-same-window},
выбранное окно нельзя использовать.  Выделенное окно можно использовать,
только если оно уже показывает @var{buffer}.  Если @var{alist} содержит
запись @code{previous-window}, окно, указанное этой записью, можно
использовать, даже если оно никогда раньше не отображало @var{buffer}.

Если @var{alist} содержит запись @code{reusable-frames}
(@pxref{Buffer Display Action Alists}), его значение определяет, в каких
фреймах искать подходящее окно.  Если @var{alist} не содержит записи
@code{reusable-frames}, функция ищет только выбранный фрейм, если
@code{display-buffer-reuse-frames} и @code{pop-up-frames} оба являются
@code{nil}; ищутся все фреймы на текущем терминале, если любая из этих
переменных имеет значение не-@code{nil}.

Если более одного окна квалифицируется как пригодное для использования в
соответствии с этими правилами, эта функция делает выбор в следующем порядке
предпочтения:

@itemize @bullet
@item
Окно, указанное любой записью @code{previous-window} @var{alist}, при
условии, что это не выбранное окно.

@item
Окно, которое раньше показывало @var{buffer}, при условии, что это не
выбранное окно.

@item
Выбранное окно, если оно либо указано записью @code{previous-window}
@var{alist}, либо ранее показывало @var{buffer}.
@end itemize
@end defun

@defun display-buffer-use-some-window buffer alist
Функция пытается отобразить @var{buffer}, выбирая существующее окно и
отображая буфер в этом окне.  Может произойти сбой, если все окна
предназначены для других буферов.  (@pxref{Dedicated Windows}).
@end defun

@defun display-buffer-below-selected buffer alist
Функция пытается отобразить @var{buffer} в окне под выбранным окном.  Если
под выбранным есть окно, и в этом окне уже отображается @var{buffer}, оно
повторно использует это окно.

Если такого окна нет, функция пытается создать новое окно, разделив
выбранное, и отображает там @var{buffer}.  Также попытается отрегулировать
размер этого окна при условии, что @var{alist} содержит подходящую запись
@code{window-height} или @code{window-width}, смотреть выше.

Если разделение выбранного окна не удается, а под выбранным есть не
выделенное окно, показывающее какой-либо другой буфер, функция пытается
использовать это окно для отображения @var{buffer}.
@end defun

@defun display-buffer-at-bottom buffer alist
Эта функция пытается отобразить @var{buffer} в окне внизу выбранного фрейма.

Это либо пытается разделить окно в нижней части фрейма, либо в корневом окне
фрейма, либо повторно использовать существующее окно в нижней части
выбранного фрейма.
@end defun

@defun display-buffer-pop-up-frame buffer alist
Функция создает новый фрейм и отображает буфер в окне этого фрейма.
Фактически он выполняет создание фрейма, вызывая функцию, указанную в
@code{pop-up-frame-function} (@pxref{Choosing Window Options}).  Если
@var{alist} содержит запись @code{pop-up-frame-parameters}, соответствующее
значение добавляется к параметрам вновь созданного фрейма.
@end defun

@defun display-buffer-in-child-frame buffer alist
Функция пытается отобразить @var{buffer} в дочернем фрейме
(@pxref{Child Frames}) выбранного фрейма, либо повторно используя
существующий дочерний фрейм, либо создавая новый.  Если @var{alist} имеет
запись не-@code{nil} @code{child-frame-parameters}, соответствующее значение
представляет собой список параметров фрейма для получения нового фрейма.
Параметр @code{parent-frame}, указывающий выбранный фрейм, предоставляется
по умолчанию.  Если дочерний фрейм должен стать потомком другого фрейма,
соответствующая запись должна быть добавлена в @var{alist}.

Внешний вид дочерних фреймов во многом зависит от параметров,
предоставленных через @var{alist}.  Рекомендуется использовать как минимум
отношения, чтобы указать размер (@pxref{Size Parameters}) и положение
(@pxref{Position Parameters}) дочернего кадра, а также добавить параметр
@code{keep-ratio} (@pxref{Frame Interaction Parameters}), чтобы убедиться,
что дочерний фрейм остается видимым.  Для других параметров, которые следует
учитывать смотреть @ref{Child Frames}.
@end defun

@defun display-buffer-use-some-frame buffer alist
Функция пытается отобразить @var{buffer}, находя фрейм, который
соответствует предикату (по умолчанию любой фрейм, кроме выбранного фрейма).

Если функция выбирает окно в другом фрейме, она делает этот фрейм видимым и,
если @var{alist} не содержит запись @code{inhibit-switch-frame}, при
необходимости поднимает этот фрейм.

Если @var{alist} имеет запись не-@code{nil} @code{frame-predicate}, ее
значением является функция, принимающая один аргумент (фрейм), возвращающая
не-@code{nil}, если фрейм является кандидатом; эта функция заменяет
предикат по умолчанию.

Если @var{alist} имеет запись не-@code{nil} @code{inhibit-same-window},
выбранное окно не используется; таким образом, если в выбранном фрейме есть
одно окно, оно не используется.
@end defun

@defun display-buffer-no-window buffer alist
Если @var{alist} имеет запись не-@code{nil} @code{allow-no-window}, то
функция не отображает @var{buffer} и возвращает символ @code{fail}.  Это
составляет единственное исключение из соглашения, согласно которому функция
действия возвращает либо @code{nil}, либо окно, показывающее @var{buffer}.
Если @var{alist} не имеет такой записи @code{allow-no-window}, функция
возвращает @code{nil}.

Если функция возвращает @code{fail}, @code{display-buffer} пропустит
выполнение любых дальнейших действий по отображению и немедленно вернет
@code{nil}.  Если эта функция возвращает @code{nil}, @code{display-buffer}
продолжит выполнение следующего действия по отображению, если таковое
имеется.

Предполагается, что когда вызывающий @code{display-buffer} указывает запись
не-@code{nil} @code{allow-no-window}, также может обрабатывать возвращаемое
значение @code{nil}.
@end defun

Две другие функции действий описаны в соответствующих разделах ---
@code{display-buffer-in-side-window}
(@pxref{Displaying Buffers in Side Windows}) и
@code{display-buffer-in-atom-window} (@pxref{Atomic Windows}).


@node Buffer Display Action Alists
@subsection Списки Действий для Отображения Буфера
@cindex buffer display action alist
@cindex action alist for buffer display

@dfn{Список действий} - это список ассоциаций, отображающий предопределенные
символы, распознаваемые функциями действий, на значения, которые эти функции
должны интерпретировать соответствующим образом.  В каждом вызове
@code{display-buffer} создает новый, возможно, пустой список действий и
передает весь этот список любой вызываемой им функции действия.

   По замыслу, функции действий могут свободно интерпретировать записи
списка действий.  Фактически, некоторые записи, такие как
@code{allow-no-window} или @code{previous-window}, имеют значение только для
одной или нескольких функций действий и игнорируются остальными.  Другие
записи, такие как @code{inhibit-same-window} или @code{window-parameters},
должны соблюдаться большинством функций действий, включая те, которые
предоставляются прикладными программами и внешними пакетами.

   В предыдущем подразделе подробно описано, как отдельные функции действий
интерпретируют записи списка действий, которые им важны.  Здесь даётся
справочный список всех известных записей списков действий в соответствии с
их символами, вместе с их значениями и функциями действий
(@pxref{Buffer Display Action Functions}), которые их распознают.  В этом
списке термины ``буфер'' будут относиться к буферу, который должен
отображать @code{display-buffer}, а ``значение'' - к значению записи.

@table @code
@vindex inhibit-same-window@r{, запись списка действий отображения буфера}
@item inhibit-same-window
Если значение равно не-@code{nil}, это сигнализирует, что выбранное окно не
должно использоваться для отображения буфера.  Все функции действий, которые
(повторно) используют существующее окно, должны учитывать эту запись.

@vindex previous-window@r{, запись списка действий отображения буфера}
@item previous-window
Значение должно указывать окно, которое могло ранее отображать буфер.
@code{display-buffer-in-previous-window} отдаст предпочтение такому окну,
если оно все еще активно и не предназначено для другого буфера.

@vindex mode@r{, запись списка действий отображения буфера}
@item mode
Значение - это либо основной режим, либо список основных режимов.
@code{display-buffer-reuse-mode-window} может повторно использовать окно
всякий раз, когда значение, указанное в этой записи, совпадает с основным
режимом буфера этого окна.  Другие функции действий игнорируют такие записи.

@vindex frame-predicate@r{, запись списка действий отображения буфера}
@item frame-predicate
Значение должно быть функцией, принимающей один аргумент (фрейм), которая
должна возвращать не-@code{nil}, если этот фрейм является кандидатом для
отображения буфера.  Эта запись используется
@code{display-buffer-use-some-frame}.

@vindex reusable-frames@r{, запись списка действий отображения буфера}
@item reusable-frames
Значение указывает набор фреймов для поиска окна, которое можно использовать
повторно, поскольку в нем уже отображается буфер.  Это можно установить
следующим образом:

@itemize @bullet
@item
@code{nil} означает, что рассматривать только окна в выбранном фрейме.
(Фактически, последний использованный фрейм, который не является фреймом
только для минибуфера.)
@item
@code{t} означает считать окна на всех фреймах.
@item
@code{visible} означает считать окна на всех видимых фреймах.
@item
0 означает учитывать окна на всех видимых или иконизированных фреймах.
@item
Фрейм означает рассматривать окна только в этом фрейме.
@end itemize

Обратить внимание, что значение @code{nil} немного отличается от значения
аргумента @var{all-frames} для @code{next-window}
(@pxref{Cyclic Window Ordering}).

Основным клиентом этого является @code{display-buffer-reuse-window}, но все
другие функции действий, которые пытаются повторно использовать окно, также
затрагиваются.  @code{display-buffer-in-previous-window} обращается к нему
при поиске окна, которое ранее отображало буфер в другом кадре.

@vindex inhibit-switch-frame@r{, запись списка действий отображения буфера}
@item inhibit-switch-frame
Значение не-@code{nil} предотвращает поднятие или выделение другого фрейма,
если там отображается окно, выбранное @code{display-buffer}.  В первую
очередь это влияет на @code{display-buffer-use-some-frame} и
@code{display-buffer-reuse-window}.  @code{display-buffer-pop-up-frame}
также должно быть затронуто, но нет гарантии, что оконный менеджер будет
соответствовать.

@vindex window-parameters@r{, a buffer display action alist entry}
@item window-parameters
Значение указывает список параметров окна, чтобы получить выбранное окно.
Все функции действий, которые выбирают окно, должны обрабатывать эту запись.

@vindex window-height@r{, a buffer display action alist entry}
@item window-height
Значение указывает, нужно ли и как регулировать высоту выбранного окна, и
может быть одно из следующих:

@itemize @bullet
@item
@code{nil} означает оставить высоту выбранного окна без изменений.

@item
Целое число определяет желаемую общую высоту выбранного окна в строках.

@item
Число с плавающей запятой указывает долю желаемой общей высоты выбранного
окна по отношению к общей высоте корневого окна его фрейма.

@item
Если значение определяет функцию, эта функция вызывается с одним аргументом
- выбранным окном.  Функция предназначена для регулировки высоты окна; его
возвращаемое значение игнорируется.  Подходящие функции:
@code{shrink-window-if-larger-than-buffer} и @code{fit-window-to-buffer},
смотреть @ref{Resizing Windows}.
@end itemize

По соглашению, высота выбранного окна регулируется только в том случае, если
окно является частью вертикальной комбинации (@pxref{Windows and Frames}),
чтобы избежать изменения высоты других, не связанных между собой окон.
Кроме того, эта запись должна обрабатываться только при определенных
условиях, которые указаны прямо под этим списком.

@vindex window-width@r{, a buffer display action alist entry}
@item window-width
Запись похожа на запись @code{window-height}, описанная ранее, но вместо
этого используется для настройки ширины выбранного окна.  Значение может
быть одним из следующих:

@itemize @bullet
@item
@code{nil} означает оставить только ширину выбранного окна.

@item
Целое число определяет желаемую общую ширину выбранного окна в столбцах.

@item
Число с плавающей запятой указывает долю желаемой общей ширины выбранного
окна по отношению к общей ширине корневого окна фрейма.

@item
Если значение определяет функцию, эта функция вызывается с одним аргументом
- выбранным окном.  Функция предназначена для регулировки ширины окна; его
возвращаемое значение игнорируется.
@end itemize

По соглашению, ширина выбранного окна регулируется только в том случае, если
окно является частью горизонтальной комбинации (@pxref{Windows and Frames}),
чтобы избежать изменения ширины других, не связанных между собой окон.
Кроме того, эта запись должна обрабатываться только при определенных
условиях, которые указаны прямо под этим списком.

@vindex preserve-size@r{, запись списка действий отображения буфера}
@item preserve-size
Если не-@code{nil}, такая запись говорит Emacs сохранить размер окна,
выбранного (@pxref{Preserving Window Sizes}).  Значение должно быть либо
@w{@code{(t . nil)}}, чтобы сохранить ширину окна, либо
@w{@code{(nil . t)}}, чтобы сохранить его высоту, либо @w{@code{(t . t)}},
чтобы сохранить его ширину и высоту.  Эта запись должна обрабатываться
только при определенных условиях, которые указаны сразу после этого списка.

@vindex pop-up-frame-parameters@r{, a buffer display action alist entry}
@item pop-up-frame-parameters
Значение определяет список параметров фрейма для создания нового фрейма,
если он создан.  @code{display-buffer-pop-up-frame} - его единственный
адресат.

@vindex parent-frame@r{, запись списка действий отображения буфера}
@item parent-frame
Значение указывает родительский фрейм, который будет использоваться при
отображении буфера в дочернем фрейме.  Эта запись используется только
@code{display-buffer-in-child-frame}.

@vindex child-frame-parameters@r{, запись списка действий отображения буфера}
@item child-frame-parameters
Значение определяет список параметров фрейма, которые будут использоваться
при отображении буфера в дочернем фрейме.  Эта запись используется только
@code{display-buffer-in-child-frame}.

@vindex side@r{, запись списка действий отображения буфера}
@item side
Значение обозначает сторону фрейма или окна, где должно быть создано новое
окно, отображающее буфер.  Эта запись используется
@code{display-buffer-in-side-window} для указания стороны фрейма, где должно
быть размещено новое боковое окно
(@pxref{Displaying Buffers in Side Windows}).  Также используется
@code{display-buffer-in-atom-window} для указания стороны существующего
окна, где должно располагаться новое окно (@pxref{Atomic Windows}).

@vindex slot@r{, запись списка действий отображения буфера}
@item slot
Если не-@code{nil}, значение указывает слот бокового окна, которое должно
отображать буфер.  Эта запись используется только
@code{display-buffer-in-side-window}.

@vindex window@r{, запись списка действий отображения буфера}
@item window
Значение определяет окно, которое каким-то образом связано с окном,
выбранным @code{display-buffer}.  Эта запись в настоящее время используется
@code{display-buffer-in-atom-window} для указания окна, на чьей стороне
должно быть создано новое окно.

@vindex allow-no-window@r{, запись списка действий отображения буфера}
@item allow-no-window
Если значение равно не-@code{nil}, @code{display-buffer} не обязательно
должен отображать буфер, и вызывающая сторона готова принять это.  Эта
запись не предназначена для пользовательских настроек, поскольку нет
гарантии, что произвольный вызывающий @code{display-buffer} сможет
обработать случай, когда ни одно окно не будет отображать буфер.
@code{display-buffer-no-window} - единственная функция действия, которая
заботится об этой записи.
@end table

По соглашению, записи @code{window-height}, @code{window-width} и
@code{preserve-size} применяются после того, как буфер выбранного окна был
установлен, и тогда и только тогда, когда это окно никогда раньше не
показывало другой буфер.  Точнее, последнее означает, что окно должно быть
либо создано текущим вызовом @code{display-buffer}, либо окно было создано
ранее @code{display-buffer} для отображения буфера и никогда не
использовалось для отображения другого буфера, пока оно не было повторно
использовано текущим вызовом @code{display-buffer}.


@node Choosing Window Options
@subsection Дополнительные Параметры для Отображения Буферов

Поведение действий отображения буфера (@pxref{Choosing Window}) может быть
дополнительно изменено следующими пользовательскими опциями.

@defopt pop-up-windows
Если значение этой переменной - не-@code{nil}, @code{display-buffer} может
разделить существующее окно, чтобы создать новое окно для отображения.  Это
значение по умолчанию.

Эта переменная предоставляется только для обратной совместимости.
Подчиняется @code{display-buffer} через специальный механизм в
@code{display-buffer-fallback-action}, который вызывает функцию действия
@code{display-buffer-pop-up-window}
(@pxref{Buffer Display Action Functions}), когда значение этой опции равно
не-@code{nil}.  Самостоятельно @code{display-buffer-pop-up-window} не
обращается, пользователь может указать непосредственно в
@code{display-buffer-alist} и так далее.
@end defopt

@defopt split-window-preferred-function
Эта переменная определяет функцию разделения окна, чтобы создать новое окно
для отображения буфера.  Используется функцией действия
@code{display-buffer-pop-up-window} для фактического разделения окна.

Значение должно быть функцией, которая принимает один аргумент, окно, и
возвращает либо новое окно (которое будет использоваться для отображения
желаемого буфера), либо @code{nil} (что означает сбой разделения).  Значение
по умолчанию - @code{split-window-sensibly}, которое задокументировано
далее.
@end defopt

@defun split-window-sensibly &optional window
Функция пытается разделить @var{window} и вернуть вновь созданное окно.
Если @var{window} нельзя разделить, возвращается @code{nil}.  Если
@var{window} опущен или @code{nil}, по умолчанию используется выбранное
окно.

Функция подчиняется обычным правилам, которые определяют, когда окно может
быть разделено (@pxref{Splitting Windows}).  Сначала проводится попытка
разделить, помещая новое окно ниже, с учетом ограничения, наложенного
@code{split-height-threshold} (смотреть ниже), в дополнение к любым другим
ограничениям.  Если это не удается, следует попытка разделить, помещая новое
окно справа, в зависимости от @code{split-width-threshold} (смотреть ниже).
Если это тоже не удается, и окно является единственным окном во фрейме, эта
функция снова пытается разделить и разместить новое окно ниже, игнорируя
@code{split-height-threshold}.  Если и это не удается, функция прекращает
работу и возвращает @code{nil}.
@end defun

@defopt split-height-threshold
Переменная определяет, разрешено ли @code{split-window-sensibly} разделить
окно, разместив новое окно ниже.  Если указано целое число, это означает
разделение только в том случае, если в исходном окне есть такое количество
строк.  Если @code{nil}, значит, не разделять таким образом.
@end defopt

@defopt split-width-threshold
Переменная определяет, разрешено ли @code{split-window-sensibly} разбивать
окно, помещая новое окно вправо.  Если значение является целым числом, это
означает разделение только в том случае, если исходное окно имеет как
минимум такое же количество столбцов.  Если значение равно @code{nil}, это
означает, что таким образом не разбивать.
@end defopt

@defopt even-window-sizes
Эта переменная, если не-@code{nil}, заставляет @code{display-buffer}
выравнивать размеры окна всякий раз, когда он повторно использует
существующее окно, и это окно находится рядом с выбранным.

Если значение - @code{width-only}, размеры выравниваются только в том
случае, если повторно используемое окно находится слева или справа от
выбранного, а выбранное окно шире, чем повторно используемое.  Если значение
- @code{height-only}, размеры выравниваются только в том случае, если
повторно используемое окно находится выше или ниже выбранного окна, а
выбранное окно выше повторно используемого.  Любое другое значение 
не-@code{nil} означает выравнивание размеров в любом из этих случаев при
условии, что выбранное окно больше повторно используемого в смысле их
комбинации.
@end defopt

@defopt pop-up-frames
Если значение этой переменной - не-@code{nil}, это означает, что
@code{display-buffer} может отображать буферы, создавая новые фреймы.  По
умолчанию - @code{nil}.

Значение не-@code{nil} также означает, что когда @code{display-buffer} ищет
окно, уже отображающее @var{buffer-or-name}, может искать любой видимый или
иконизированный фрейм, а не только выбранный фрейм.

Переменная предоставляется в основном для обратной совместимости.  Ей
подчиняется @code{display-buffer} через специальный механизм в
@code{display-buffer-fallback-action}, который вызывает функцию действия
@code{display-buffer-pop-up-frame}
(@pxref{Buffer Display Action Functions}), если значение равно
не-@code{nil}.  (Это делается перед попыткой разбить окно.)  Сам
@code{display-buffer-pop-up-frame} не обращается к этой переменной, которую
пользователь может указать непосредственно в @code{display-buffer-alist} и
так далее.
@end defopt

@defopt pop-up-frame-function
Переменная определяет функцию для создания нового фрейма, чтобы создать
новое окно для отображения буфера.  Используется функцией действия
@code{display-buffer-pop-up-frame}.

Значение должно быть функцией, которая не принимает аргументов и возвращает
фрейм, или @code{nil}, если фрейм не может быть создан.  Значение по
умолчанию - функция, которая создает фрейм, используя параметры, указанные в
@code{pop-up-frame-alist} (смотреть ниже.).
@end defopt

@defopt pop-up-frame-alist
Переменная содержит список параметров фрейма (@pxref{Frame Parameters}),
который используется функцией, заданной @code{pop-up-frame-function}, для
создания нового фрейма.  По умолчанию - @code{nil}.

Опция предусмотрена только для обратной совместимости.  Обратить внимание,
что когда @code{display-buffer-pop-up-frame} вызывает функцию, указанную в
@code{pop-up-frame-function}, добавляется значение всех записей списка
действий @code{pop-up-frame-parameters} к @code{pop-up-frame-alist}, так что
значения, указанные в записи списка действий, эффективно переопределяют
любые соответствующие значения @code{pop-up-frame-alist}.

Следовательно, пользователи должны настроить запись
@code{pop-up-frame-parameters} action alist в @code{display-buffer-alist}
вместо настройки @code{pop-up-frame-alist}.  Только это гарантирует, что
значение параметра, указанного пользователем, переопределяет значение этого
параметра, указанное вызывающим объектом @code{display-buffer}.
@end defopt

   При разработке @code{display-buffer} было приложено много усилий для
обеспечения совместимости с кодом, который использует более старые
параметры, такие как @code{pop-up-windows}, @code{pop-up-frames},
@code{pop-up-frame-alist}, @code{same-window-buffer-names} и
@code{same-window-regexps}.  Lisp Программы и пользователи должны
воздерживаться от использования этих параметров.  Выше уже предостерегалось
от настройки @code{pop-up-frame-alist}.  Здесь описывается, как
преобразовать оставшиеся параметры для использования вместо них действий
отображения.

@table @code
@item pop-up-windows
@vindex pop-up-windows@r{, замена}
По умолчанию переменная установлена в @code{t}.  Вместо того, чтобы
настраивать её в @code{nil} и, таким образом, указывать
@code{display-buffer}, чего не следует делать, гораздо лучше перечислить в
@code{display-buffer-base-action} функции действий, которые должны
попробоваться вместо этого, например:

@example
@group
(customize-set-variable
 'display-buffer-base-action
 '((display-buffer-reuse-window display-buffer-same-window
    display-buffer-in-previous-window
    display-buffer-use-some-window)))
@end group
@end example

@item pop-up-frames
@vindex pop-up-frames@r{, замена}
Вместо того, чтобы настраивать эту переменную в @code{t}, настраивается
@code{display-buffer-base-action}, например, следующим образом:

@example
@group
(customize-set-variable
 'display-buffer-base-action
 '((display-buffer-reuse-window display-buffer-pop-up-frame)
   (reusable-frames . 0)))
@end group
@end example

@item same-window-buffer-names
@itemx same-window-regexps
@vindex same-window-buffer-names@r{, замена}
@vindex same-window-regexps@r{, замена}
Вместо добавления имени буфера или регулярного выражения к одному из этих
параметров используется запись @code{display-buffer-alist} для этого буфера,
определяющая функцию действия @code{display-buffer-same-window}.

@example
@group
(customize-set-variable
 'display-buffer-alist
 (cons '("\\*foo\\*" (display-buffer-same-window))
        display-buffer-alist))
@end group
@end example
@end table


@node Precedence of Action Functions
@subsection Приоритет Функций Действий
@cindex precedence of buffer display action functions
@cindex execution order of buffer display action functions
@cindex buffer display action functions, precedence

Из предыдущих подразделов известно, что @code{display-buffer} должно быть
снабжено рядом действий отображения (@pxref{Choosing Window}) для
отображения буфера.  В полностью ненастроенном Emacs эти действия задаются
@code{display-buffer-fallback-action} в следующем порядке приоритета:
повторно использовать окно, выскакивается новое окно в том же фрейме,
использовать окно, ранее показывающее буфер, использовать какое-то окно и
выбрасывать новый фрейм.  (Обратить внимание, что остальные действия,
названные @code{display-buffer-fallback-action}, недействительны в
ненастроенном Emacs).

Рассматривается следующая форма:

@example
(display-buffer (get-buffer-create "*foo*"))
@end example

@noindent
При оценке этой формы в буфере @file{*scratch*} ненастроенного сеанса Emacs
обычно не удается повторно использовать окно, в котором уже отображается
@file{*foo*}, но появляется новое окно.  Повторная оценка той же формы
теперь не вызовет никаких видимых изменений - @code{display-buffer} повторно
использовал окно, уже показывающее @file{*foo*}, потому что это действие
было применимо и имело наивысший приоритет среди всех применимых действий.

   Выбросить новое окно не удастся, если в выбранном фрейме недостаточно
места.  В ненастроенном Emacs это обычно не работает, когда во фрейме уже
есть два окна.  Например, если еперь набрать @w{@kbd{C-x 1}}, а затем
@w{@kbd{C-x 2}} и еще раз оценить форму, @file{*foo*} должен появиться в
нижнем окне --- @code{display-buffer} только что ``немного'' использованное
окно.  Если бы перед вводом @w{@kbd{C-x 2}} набрать @w{@kbd{C-x o}},
@file{*foo*}, отображался бы в верхнем окне, потому что ``немного'' использованное окно обозначает окно ``наименее недавно использованное'', а выбранное
окно использовалось меньше всего в том и только том случае, если оно
находится в том же фрейме.

   Предположим, не набрано @w{@kbd{C-x o}} и @file{*foo*}, это показано в
нижнем окне.  Вводится @w{@kbd{C-x o}}, чтобы попасть туда, затем
@w{@kbd{C-x left}} и снова оценивается форма.  Должно отображать
@file{*foo*} в том же нижнем окне, потому что это окно уже показывало
@file{*foo*} ранее и поэтому было выбрано вместо какого-либо другого окна.

  До сих пор наблюдалось только поведение по умолчанию в ненастроенном
сеансе Emacs.  Чтобы увидеть, как это поведение можно настроить,
рассматривается параметр @code{display-buffer-base-action}.  Он обеспечивает
очень грубую настройку, которая концептуально влияет на отображение @emph{любого} буфера.  Можно использовать для дополнения действий, предоставляемых
@code{display-buffer-fallback-action}, путем их переупорядочивания или
добавления действий, которых там нет, но которые больше соответствуют
практике редактирования пользователя.  Однако его также можно использовать
для более глубокого изменения поведения по умолчанию.

   Рассмотрим пользователя, который, как правило, предпочитает отображать
буферы на другом фрейме.  Такой пользователь может предоставить следующую
настройку:

@example
@group
(customize-set-variable
 'display-buffer-base-action
 '((display-buffer-reuse-window display-buffer-pop-up-frame)
   (reusable-frames . 0)))
@end group
@end example

@noindent
Параметр указывает @code{display-buffer} сначала попытаться найти окно,
показывающее буфер в видимом или иконизированном фрейме, и, если такого
фрейма не существует, отобразит новый фрейм.  Можно наблюдать это поведение
в графической системе, набрав @w{@kbd{C-x 1}} в окне, показывающем
@file{*scratch*}, и оценив каноническую форму @code{display-buffer}.  Обычно
создает (и дает фокус) новый фрейм, в корневом окне которого отображается
@file{*foo*}.  Преобразовать этот фрейм в иконку и снова оценить
каноническую форму: @code{display-buffer} будет повторно использовать окно в
новом фрейме (обычно поднимая фрейм и уделяя ему фокус).

   Только в случае сбоя создания нового фрейма @code{display-buffer}
применит действия, предоставленные @code{display-buffer-fallback-action},
что означает повторную попытку повторного использования окна, появление
нового окна и так далее.  Тривиальный способ сделать невозможным создание
фрейма можно с помощью следующей формы:

@example
@group
(let ((pop-up-frame-function 'ignore))
  (display-buffer (get-buffer-create "*foo*")))
@end group
@end example

@noindent
Забыть об этой форме сразу после того, как видно, что она не может создать
новый фрейм и вместо этого использовать резервное действие.

   Обратить внимание, что @code{display-buffer-reuse-window} кажется
излишним при настройке @code{display-buffer-base-action}, потому что уже
является частью @code{display-buffer-fallback-action} и в любом случае это
следует попробовать.  Однако не получится, потому что из-за приоритета
@code{display-buffer-base-action} над @code{display-buffer-fallback-action},
в то время @code{display-buffer-pop-up-frame} уже выиграл гонку.  На самом
деле:

@example
@group
(customize-set-variable
 'display-buffer-base-action
 '(display-buffer-pop-up-frame (reusable-frames . 0)))
@end group
@end example

@noindent
приведет к тому, что @code{display-buffer} @emph{всегда} вызовет появление
нового фрейма, что, вероятно, не то, что хочет наш пользователь.

   До сих пор только показано, как @emph{пользователи} могут настроить
поведение @code{display-buffer} по умолчанию.  Теперь смотреть, как
@emph{Приложения} могут изменить курс @code{display-buffer}.  Канонический
способ сделать это - использовать аргумент @var{action} для
@code{display-buffer} или вызывающую его функцию, например,
@code{pop-to-buffer} (@pxref{Switching Buffers}).

   Предположить, приложение хочет отображать @file{*foo*} предпочтительно
под выбранным окном (чтобы сразу привлечь внимание пользователя к новому
окну) или, если это не удается, в окне внизу фрейма.  Можно сделать это с
помощью такого вызова:

@example
@group
(display-buffer
 (get-buffer-create "*foo*")
 '((display-buffer-below-selected display-buffer-at-bottom)))
@end group
@end example

@noindent
Чтобы увидеть, как работает эта новая измененная форма, удалить любой фрейм,
показывающий @file{*foo*}, ввести @w{@kbd{C-x 1}}, а затем @w{@kbd{C-x 2}} в
окне, показывающем @file{*scratch*}, и затем оценить эту форму.
@code{display-buffer} должен разделить верхнее окно и отобразить
@file{*foo*} в новом окне.  В качестве альтернативы, если бы после
@w{@kbd{C-x 2}} набрать @w{@kbd{C-x o}}, @code{display-buffer}, вместо этого
бы разбило окно внизу.

   Предположим теперь, что перед оценкой новой формы сделано выбранное окно
как можно меньшим, например, оценив форму @code{(fit-window-to-buffer)} в
этом окне.  В этом случае @code{display-buffer} не смог бы разделить
выбранное окно и вместо этого разделил бы корневое окно фрейма, эффективно
отображая @file{*foo*} внизу фрейма.

   В любом случае при оценке новой формы во второй раз следует повторно
использовать окно, уже показывающее @file{*foo*}, поскольку обе функции,
предоставленные аргументом @var{action}, сначала пытаются повторно
использовать такое окно.

   Устанавив аргумент @var{action}, приложение фактически отменяет любую
настройку @code{display-buffer-base-action}.  Теперь пользователь может либо
принять выбор приложения, либо повторить двойную настройку параметра
@code{display-buffer-alist} следующим образом:

@example
@group
(customize-set-variable
 'display-buffer-alist
 '(("\\*foo\\*"
    (display-buffer-reuse-window display-buffer-pop-up-frame))))
@end group
@end example

@noindent
Попытка сделать это с новой, измененной формой выше в конфигурации, в
которой нигде не отображается @file{*foo*}, отобразит @file{*foo*} в
отдельном фрейме, полностью игнорируя аргумент @var{action} для
@code{display-buffer}.

   Обратить внимание, что не позаботились указать запись списка действий
@code{reusable-frames} в спецификации @code{display-buffer-alist}.
@code{display-buffer} всегда берет первый найденный - в этом случае тот,
который указан в @code{display-buffer-base-action}.  Если бы требовалось
использовать другую спецификацию, например, чтобы исключить иконизированные
фреймы, показывающие @file{*foo*}, из списка многоразовых, нам пришлось бы
указать это отдельно, однако:

@example
@group
(customize-set-variable
 'display-buffer-alist
 '(("\\*foo\\*"
    (display-buffer-reuse-window display-buffer-pop-up-frame)
    (reusable-frames . visible))))
@end group
@end example

@noindent
Если попробовать это сделать, заметиться, что повторные попытки отобразить
@file{*foo*} позволят повторно использовать фрейм только в том случае, если
этот фрейм виден.

   Приведенный выше пример позволяет сделать вывод, что пользователи
настраивают @code{display-buffer-alist} с единственной целью - отменить
аргумент @var{action}, выбранный приложениями.  Такой вывод был бы неверным.
@code{display-buffer-alist} - это стандартный параметр, позволяющий
пользователям направлять ход отображения определенных буферов
предпочтительным образом независимо от того, управляется ли отображение
аргументом @var{action}.

   Однако можно сделать разумный вывод, что настройка
@code{display-buffer-alist} отличается от настройки
@code{display-buffer-base-action} в двух основных аспектах: она сильнее,
потому что переопределяет аргумент @var{action} для @code{display-buffer} и
позволяет явно указать затронутые буферы.  Фактически, настройка
@file{*foo*} никак не влияет на отображение других буферов.  Например,

@example
(display-buffer (get-buffer-create "*bar*"))
@end example

@noindent
продолжает регулироваться только настройками
@code{display-buffer-base-action} и @code{display-buffer-fallback-action}.

   Можно бы остановиться на наших примерах здесь, но у программ на Lisp все
еще есть козырь в рукаве, который они могут использовать для отмены любой
настройки @code{display-buffer-alist}.  Это переменная
@code{display-buffer-overriding-action}, которую они могут привязать к
вызовам @code{display-buffer} следующим образом:

@example
@group
(let ((display-buffer-overriding-action
       '((display-buffer-same-window))))
  (display-buffer
   (get-buffer-create "*foo*")
   '((display-buffer-below-selected display-buffer-at-bottom))))
@end group
@end example

@noindent
Оценка этой формы обычно отображает @file{*foo*} в выбранном окне независимо
от аргумента @var{action} и любых пользовательских настроек.  (Обычно
приложение не заботится о предоставлении аргумента @var{action}.  Здесь
просто служит для иллюстрации того факта, что он переопределяется.)

Было бы показательно взглянуть на список функций действий, которые
@code{display-buffer} пытались отобразить @file{*foo*} с настройками,
которые здесь предоставлены.  Список (включая комментарии, объясняющие, кто
добавил этот и последующие элементы)::

@example
@group
(display-buffer-same-window  ;; `display-buffer-overriding-action'
 display-buffer-reuse-window ;; `display-buffer-alist'
 display-buffer-pop-up-frame
 display-buffer-below-selected ;; ACTION argument
 display-buffer-at-bottom
 display-buffer-reuse-window ;; `display-buffer-base-action'
 display-buffer-pop-up-frame
 display-buffer--maybe-same-window ;; `display-buffer-fallback-action'
 display-buffer-reuse-window
 display-buffer--maybe-pop-up-frame-or-window
 display-buffer-in-previous-window
 display-buffer-use-some-window
 display-buffer-pop-up-frame)
@end group
@end example

@noindent
Обратить внимание, что среди перечисленных здесь внутренних функций
@code{display-buffer--maybe-same-window} фактически игнорируется, в то время
как @code{display-buffer--maybe-pop-up-frame-or-window} фактически выполняет
@code{display-buffer-pop-up-window}.

Список действий, переданный при каждом вызове функции,:

@example
@group
((reusable-frames . visible)
 (reusable-frames . 0))
@end group
@end example

@noindent
что показывает, что использована вторая спецификация
@code{display-buffer-alist} выше, которая переопределила спецификацию,
предоставленную @code{display-buffer-base-action}.  Предположив, что
пользователь написал это как

@example
@group
(customize-set-variable
 'display-buffer-alist
 '(("\\*foo\\*"
    (display-buffer-reuse-window display-buffer-pop-up-frame)
    (inhibit-same-window . t)
    (reusable-frames . visible))))
@end group
@end example

@noindent
В этом случае запись @code{inhibit-same-window} alist успешно аннулирует
спецификацию @code{display-buffer-same-window} из
@code{display-buffer-overriding-action} и @code{display-buffer}, будет
отображаться @file{*foo*} в другом фрейме.  Чтобы сделать
@code{display-buffer-overriding-action} более надежным в этом отношении,
приложение должно также указать соответствующую запись
@code{inhibit-same-window}, например, следующим образом:

@example
@group
(let ((display-buffer-overriding-action
       '(display-buffer-same-window (inhibit-same-window . nil))))
  (display-buffer (get-buffer-create "*foo*")))
@end group
@end example

@noindent
Этот последний пример показывает, что, хотя порядок приоритета функций
действий фиксирован, как описано в @ref{Choosing Window}, запись списка
действий, заданная действием отображения с более низким рангом в этом
порядке, может влиять на выполнение действия отображения с более высоким
рейтингом.


@node The Zen of Buffer Display
@subsection The Zen of Buffer Display
@cindex guidelines for buffer display
@cindex writing buffer display actions
@cindex buffer display conventions

В наиболее упрощенной форме фрейм всегда включает в себя одно окно, которое
можно использовать для отображения буфера.  Как следствие, всегда последний
вызов @code{display-buffer} успешно помещает туда свой буфер.

   Поскольку работа с таким фреймом не очень практична, Emacs по умолчанию
допускает более сложные макеты фреймов, управляемые значениями по умолчанию
для размера фрейма и опциями @code{split-height-threshold} и
@code{split-width-threshold}.  Отображение буфера, еще не показанного в
фрейме, затем либо разделяет одно окно на этот фрейм, либо (повторно)
использует одно из двух окон.

   От поведения по умолчанию отказываются, как только пользователь
настраивает один из этих пороговых значений или вручную изменяет макет
фрейма.  От поведения по умолчанию также отказываются при вызове
@code{display-buffer} с аргументом не-@code{nil} @var{action} или когда
пользователь настраивает один из параметров, упомянутых в предыдущих
подразделах.  Освоение @code{display-buffer} скоро может стать неприятным
занятием из-за множества применимых действий отображения и результирующих
макетов фреймов.

   Однако воздержание от использования функций отображения буфера и
использование метафоры разделения и удаления окон также не является хорошей
идеей.  Функции отображения буфера дают программам и пользователям на Lisp
основу для согласования их различных потребностей; сопоставимой структуры
для разделения и удаления окон не существует.  Функции отображения буфера
также позволяют хотя бы частично восстановить макет фрейма при удалении из
него буфера позже (@pxref{Quitting Windows}).

   Ниже даны ряд рекомендаций, чтобы избавиться от разочарования,
упомянутого выше, и, таким образом, избежать буквально потери буферов между
окнами фрейма.

@table @asis
@item Написать действия с дисплеем без напряга
Написание действий отображения может быть проблемой, потому что нужно
объединить функции действий и списки действий в один огромный список.
(Исторические причины не позволили @code{display-buffer} поддержать
отдельные аргументы в их пользу.)  Может быть полезно запомнить некоторые
основные формы, подобные перечисленным ниже:

@example
'(nil (inhibit-same-window . t))
@end example

@noindent
определяет только запись списка действий и не функцию действия.  Его
единственная цель - запретить функции @code{display-buffer-same-window},
указанной в другом месте, отображать буфер в том же окне, смотреть также
последний пример в предыдущем подразделе.

@example
'(display-buffer-below-selected)
@end example

@noindent
с другой стороны, определяет одну функцию действия и пустой список действий.
Чтобы объединить эффекты двух вышеупомянутых спецификаций, нужно написать
форму

@example
'(display-buffer-below-selected (inhibit-same-window . t))
@end example

@noindent
чтобы добавить еще одну функцию действия, нужно написать

@example
@group
'((display-buffer-below-selected display-buffer-at-bottom)
  (inhibit-same-window . t))
@end group
@end example

@noindent
и чтобы добавить еще одну запись в список, нужно написать

@example
@group
'((display-buffer-below-selected display-buffer-at-bottom)
  (inhibit-same-window . t)
  (window-height . fit-window-to-buffer))
@end group
@end example

@noindent
Эту последнюю форму можно использовать как аргумент @var{action} для
@code{display-buffer} следующим образом:

@example
@group
(display-buffer
 (get-buffer-create "*foo*")
 '((display-buffer-below-selected display-buffer-at-bottom)
   (inhibit-same-window . t)
   (window-height . fit-window-to-buffer)))
@end group
@end example

@noindent
При настройке @code{display-buffer-alist} будет использоваться следующим
образом:

@example
@group
(customize-set-variable
 'display-buffer-alist
 '(("\\*foo\\*"
    (display-buffer-below-selected display-buffer-at-bottom)
    (inhibit-same-window . t)
    (window-height . fit-window-to-buffer))))
@end group
@end example

@noindent
Чтобы добавить настройку для второго буфера, нужно написать:

@example
@group
(customize-set-variable
 'display-buffer-alist
 '(("\\*foo\\*"
    (display-buffer-below-selected display-buffer-at-bottom)
    (inhibit-same-window . t)
    (window-height . fit-window-to-buffer))
   ("\\*bar\\*"
    (display-buffer-reuse-window display-buffer-pop-up-frame)
    (reusable-frames . visible))))
@end group
@end example

@item Относиться друг к другу с уважением
@code{display-buffer-alist} и @code{display-buffer-base-action} - это
пользовательские параметры --- программы Lisp никогда не должны
устанавливать или повторно связывать их.
@code{display-buffer-overriding-action}, с другой стороны, зарезервирован
для приложений - которые редко используют эту опцию, а если они используют
ее, то с особой осторожностью.

   Более старые реализации @code{display-buffer} часто заставляли
пользователей и приложения драться из-за настроек пользовательских
параметров, таких как @code{pop-up-frames} и @code{pop-up-windows}
(@pxref{Choosing Window Options}).  Это было одной из основных причин
переделки @code{display-buffer} - чтобы обеспечить четкую структуру,
определяющую, что пользователям и приложениям должно быть разрешено делать.

   Программы Lisp должны быть подготовлены к тому, что пользовательские
настройки могут привести к неожиданному отображению буферов.  Они никогда не
должны предполагать в своем последующем поведении, что буфер был показан
именно так, как они просили в аргументе @var{action} для
@code{display-buffer}.

   Пользователи не должны устанавливать слишком много и слишком жестких
ограничений на отображение произвольных буферов.  В противном случае они
рискуют потерять характеристики показа буфера для определенной цели.
Предположим, что программа на Lisp была написана для параллельного сравнения
различных версий буфера в двух окнах.  Если настройка
@code{display-buffer-alist} предписывает, что любой такой буфер всегда
должен отображаться в выбранном окне или под ним, программе будет сложно
настроить желаемую конфигурацию окна через @code{display-buffer}.

   Чтобы указать предпочтение для отображения произвольного буфера,
пользователи должны настроить @code{display-buffer-base-action}.  Пример
того, как это будут делать пользователи, предпочитающие работать с
несколькими фреймами, был приведен в предыдущем подразделе.
@code{display-buffer-alist} следует зарезервировать для отображения
определенных буферов определенным образом.

@item Рассмотреть возможность повторного использования окна, в котором уже отображается буфер
Как правило, для пользователей и программистов на Lisp всегда полезно быть
готовым к тому случаю, когда в окне уже отображается рассматриваемый буфер,
и повторно использовать это окно.  В предыдущем подразделе показано, что
невыполнение этого требования может привести к тому, что
@code{display-buffer} будет постоянно отображать новый буфер, хотя буфер,
показывающий, что буфер уже существует.  Только в некоторых случаях может
быть нежелательно повторно использовать окно, например, когда в этом окне
должна отображаться другая часть буфера.

   Следовательно, @code{display-buffer-reuse-window} - это одна функция
действия, которую следует использовать как можно чаще, как в аргументах
@var{action}, так и в настройках.  Запись @code{inhibit-same-window} в
аргументе @var{action} обычно касается наиболее распространенного случая,
когда следует избегать повторного использования окна, показывающего буфер, -
когда рассматриваемое окно является выбранным.

@item Привлечь внимание к выбранному окну
Это простая задача для людей, работающих с несколькими фреймами - фрейм,
показывающий буфер, автоматически поднимется и получит фокус, если запись
@code{inhibit-switch-frame} не запрещает это.  Для пользователей одного
фрейма эта задача может быть значительно сложнее.  В частности,
@code{display-buffer-pop-up-window} и @code{display-buffer-use-some-window}
в этом отношении могут стать навязчивыми.  Они разделяют или используют
кажущееся произвольным (часто самое большое или недавно использовавшееся)
окно, отвлекая внимание пользователя.

Поэтому некоторые программы Lisp пытаются выбрать окно внизу кадра,
например, чтобы отобразить буфер рядом с окном минибуфера, где пользователь
должен ответить на вопрос, связанный с новым окном.  Для действий, не
связанных с вводом, может быть предпочтительнее
@code{display-buffer-below-selected}, потому что выбранное окно обычно уже
привлекает внимание пользователя.

@item Обработка последующих вызовов @code{display-buffer}
@code{display-buffer} не слишком хорошо подходит для последовательного
отображения нескольких буферов и обеспечения упорядоченного отображения всех
этих буферов в итоговой конфигурации окна.  Опять же, стандартные функции
действий @code{display-buffer-pop-up-window} и
@code{display-buffer-use-some-window} не очень подходят для этой цели из-за
их несколько хаотичного характера в более сложных конфигурациях.

   Чтобы создать конфигурацию окна, отображающую несколько буферов (или
разные представления одного и того же буфера) в одном и том же цикле
отображения, программистам на Lisp неизбежно придется писать свои
собственные функции действий.  Несколько уловок, перечисленных ниже, могут
помочь в этом отношении.

@itemize @bullet
@item
Создание атомарных окон (@pxref{Atomic Windows}) позволяет избежать
разрушения существующей композиции окна при открытии нового окна.  Вместо
этого новое окно появится за пределами композиции.

@item
Временное выделение окон для их буферов (@pxref{Dedicated Windows})
позволяет избежать использования окна для отображения другого буфера.
Вместо этого будет использоваться неспециализированное окно.

@item
Вызов @code{window-preserve-size} (@pxref{Preserving Window Sizes})
попытается сохранить размер окна аргументов неизменным при открытии нового
окна.  Однако потребуется убедиться, что вместо этого можно уменьшить другое
окно в той же комбинации.

@item
Боковые окна (@pxref{Side Windows}) могут использоваться для отображения
определенных буферов всегда в окне в одной и той же позиции фрейма.  Это
позволяет группировать буферы, которые не конкурируют за одновременное
отображение в фрейме, и отображать любой такой буфер в одном окне без
нарушения отображения других буферов.

@item
Дочерние фреймы (@pxref{Child Frames}) могут использоваться для отображения
буфера в пределах экранного состояния выбранного фрейма без нарушения
конфигурации окна этого фрейма и без накладных расходов, связанных с
полнофункциональными фреймами, как это вызвано
@code{display-buffer-pop-up-frame}.
@end itemize
@end table


@node Window History
@section История Окон
@cindex window history

Каждое окно запоминает в списке буферы, которые оно отображало ранее, и
порядок, в котором эти буферы были удалены из него.  Эту историю использует,
например, @code{replace-buffer-in-windows} (@pxref{Buffers and Windows}), 
при выходе из окна (@pxref{Quitting Windows}).  Список автоматически
поддерживается Emacs, но можно использовать следующие функции, чтобы явно
проверить или изменить его:

@defun window-prev-buffers &optional window
Функция возвращает список, в котором указано предыдущее содержимое
@var{window}.  Необязательный аргумент @var{window} должен быть активным
окном и по умолчанию выбран выбранным.

Каждый элемент списка имеет форму @code{(@var{buffer} @var{window-start}
@var{window-pos})}, где @var{buffer} - это буфер, ранее показанный в окне,
@var{window-start} - это начальная позиция окна,
(@pxref{Window Start and End}), когда этот буфер был показан в последний
раз, а @var{window-pos} - это позиция точки (@pxref{Window Point}), когда
этот буфер последний раз отображался в @var{window}.

Список упорядочен так, что более ранние элементы соответствуют недавно
показанным буферам, а первый элемент обычно соответствует буферу, который
был удален из окна последним.
@end defun

@defun set-window-prev-buffers window prev-buffers
Функция устанавливает предыдущие буферы @var{window} в значение
@var{prev-buffers}.  Аргумент @var{window} должен быть активным окном и по
умолчанию быть выбранным.  Аргумент @var{prev-buffers} должен быть списком
той же формы, что и возвращаемый @code{window-prev-buffers}.
@end defun

Кроме того, каждое окно поддерживает список @dfn{next buffers}, который
представляет собой список буферов, повторно отображаемый
@code{switch-to-prev-buffer} (смотреть ниже).  Этот список в основном
используется @code{switch-to-prev-buffer} и @code{switch-to-next-buffer} для
выбора буферов для переключения.

@defun window-next-buffers &optional window
Функция возвращает список буферов, недавно повторно показанных в
@var{window} через @code{switch-to-prev-buffer}.  Аргумент @var{window}
должен обозначать активное окно или @code{nil} (то есть выбранное окно).
@end defun

@defun set-window-next-buffers window next-buffers
Функция устанавливает следующий список буферов @var{window} в
@var{next-buffers}.  Аргумент @var{window} должен быть активным окном или
@code{nil} (то есть выбранным окном).  Аргумент @var{next-buffers} должен
быть списком буферов.
@end defun

Следующие команды могут использоваться для циклического просмотра
глобального списка буферов, таких как @code{bury-buffer} и
@code{unbury-buffer}.  Однако они циклически меняются в соответствии со
списком истории указанного окна, а не глобальным списком буферов.  Кроме
того, восстанавливают зависящие от окна положения начала и точки окна и
могут отображать буфер, даже если он уже отображается в другом окне.  В
частности, команда @code{switch-to-prev-buffer} используется
@code{replace-buffer-in-windows}, @code{bury-buffer} и @code{quit-window}
для поиска буфера замены для окна.

@deffn Command switch-to-prev-buffer &optional window bury-or-kill
Команда отображает предыдущий буфер в @var{window}.  Аргумент @var{window}
должен быть активным окном или @code{nil} (то есть выбранным окном).  Если
необязательный аргумент @var{bury-or-kill} - не-@code{nil}, это означает,
что буфер, показанный в настоящее время в @var{window}, вот-вот будет
оставлен или уничтожен и, следовательно, не должен переключаться на него
при будущих вызовах этой команды.

Предыдущий буфер обычно является буфером, показанным перед буфером,
показанным в настоящее время в @var{window}.  Однако буфер, который был
оставлен или уничтожен, или уже был показан последним вызовом
@code{switch-to-prev-buffer}, не квалифицируется как предыдущий буфер.

Если повторные вызовы этой команды уже показали все буферы, ранее показанные
в @var{window}, дальнейшие вызовы покажут буферы из списка буферов фрейма
@var{window} появляются на (@pxref{Buffer List}), пытаясь пропустить буферы,
которые уже показаны в другом окне этого фрейма.
@end deffn

@deffn Command switch-to-next-buffer &optional window
Команда переключает на следующий буфер в @var{window}, таким образом отменяя
действие последней команды @code{switch-to-prev-buffer} в @var{window}.
Аргумент @var{window} должен быть активным окном и по умолчанию быть
выбранным.

Если нет недавнего вызова @code{switch-to-prev-buffer}, который можно
отменить, эта функция пытается показать буфер из списка буферов фрейма,
в котором @var{window} появляется в (@pxref{Buffer List}).
@end deffn

По умолчанию @code{switch-to-prev-buffer} и @code{switch-to-next-buffer}
может переключиться на буфер, который уже отображается в другом окне в том
же фрейме.  Следующая опция может использоваться, чтобы переопределить это
поведение.

@defopt switch-to-visible-buffer
Если эта переменная - не-@code{nil}, @code{switch-to-prev-buffer} и
@code{switch-to-next-buffer}, можно переключиться на буфер, который уже
виден в том же фрейме, при условии, что буфер ранее был показан в
соответствующем окне.  Если это @code{nil}, @code{switch-to-prev-buffer} и
@code{switch-to-next-buffer} всегда старается избегать переключения на
буфер, который уже виден в другом окне в том же фрейме. По умолчанию -
@code{t}.
@end defopt


@node Dedicated Windows
@section Выделения Окон
@cindex dedicated window

Можно указать функциям для отображения буфера не использовать определенные
окна, пометив эти окна как @dfn{выделенные} для их буферов.
@code{display-buffer} (@pxref{Choosing Window}) никогда не использует
выделенное окно для отображения в нем другого буфера.  @code{get-lru-window}
и @code{get-largest-window} (@pxref{Cyclic Window Ordering}) не
рассматривает выделенные окна в качестве кандидатов, если их аргумент
@var{dedicated} - не-@code{nil}.  Поведение @code{set-window-buffer}
(@pxref{Buffers and Windows}) по отношению к выделенным окнам немного
отличается, смотреть ниже.

   Функции, предназначенные для удаления буфера из окна или окна из фрейма,
могут вести себя особым образом, когда окно, над которым они работают,
выделено.  Различаются три основных случая, а именно, когда (1) окно - не
единственное окно в своем фрейме, (2) окно является единственным окном в
своём фрейме, но на том же терминале слева есть другие фреймы, и (3) окно -
единственное окно в единственном фрейме на том же терминале.

   В частности, @code{delete-windows-on} (@pxref{Deleting Windows})
обрабатывает case (2), удаляя связанный фрейм, и case (3), показывая другой
буфер в единственном окне этого фрейма.  Функция
@code{replace-buffer-in-windows} (@pxref{Buffers and Windows}), которая
вызывается при уничтожении буфера, удаляет окно в случае (1) и ведет себя
как @code{delete-windows-on} в противном случае.
@c FIXME: Заменяет-буфер-в-окнах _удалено_ окно в случае (1)?

   Когда @code{bury-buffer} (@pxref{Buffer List}) работает с выбранным окном
(которое показывает буфер, который должен быть скрыт), обрабатывает case
(2), вызывая @code{frame-auto-hide-function} (@pxref{Quitting Windows}) для
работы с выбранным фреймом.  Остальные два случая обрабатываются как с
@code{replace-buffer-in-windows}.

@defun window-dedicated-p &optional window
Функция возвращает не-@code{nil}, если @var{window} выделен для своего
буфера, и @code{nil} в противном случае.  Точнее, возвращаемое значение -
это значение, присвоенное последним вызовом @code{set-window-dedicated-p}
для @var{window} или @code{nil}, если эта функция никогда не вызывалась с
@var{window} в качестве аргумента.  По умолчанию для @var{window} выбрано
окно.
@end defun

@defun set-window-dedicated-p window flag
Функция отмечает @var{window} как выделенный для своего буфера, если
@var{flag} имеет значение не-@code{nil}, и как не выделенный в противном
случае.

В особом случае, если @var{flag} равен @code{t}, @var{window} становится
@dfn{строго} выделенным для своего буфера.  @code{set-window-buffer}
сигнализирует об ошибке, когда окно, с которым оно работает, строго выделено
для своего буфера и еще не отображает буфер, который требуется отобразить.
Другие функции не обрабатывают @code{t} иначе, чем любое значение
не-@code{nil}.
@end defun


@node Quitting Windows
@section Выход из Окон

Если требуется избавиться от окна, используемого для отображения буфера,
можно вызвать @code{delete-window} или @code{delete-windows-on}
(@pxref{Deleting Windows}), чтобы удалить это окно из его фрейма.  Если
буфер отображается в отдельном фрейме, можно вместо этого вызвать
@code{delete-frame} (@pxref{Deleting Frames}).  Если, с другой стороны, окно
было повторно использовано для отображения буфера, можно предпочесть
показать буфер, ранее показанный в этом окне, вызвав функцию
@code{switch-to-prev-buffer} (@pxref{Window History}).  Наконец, можно
захотеть либо похоронить (@pxref{Buffer List}), либо убить
(@pxref{Killing Buffers}) окно буфера.

   Следующая команда использует информацию о том, как изначально было
получено окно для отображения буфера, таким образом пытаясь автоматизировать
вышеуказанные решения для вас.

@deffn Command quit-window &optional kill window
Команда закрывает @var{window} и закапывает его буфер.  Аргумент
@var{window} должен быть активным окном и по умолчанию выть выбранным.  С
аргументом префикса @var{kill} не-@code{nil} уничтожается буфер, а не
хоронится.  Вызывается функция @code{quit-restore-window}, описанная ниже,
для работы с окном и его буфером.
@end deffn

@defun quit-restore-window &optional window bury-or-kill
Функция обрабатывает @var{window} и его буфер после выхода.  Необязательный
аргумент @var{window} должен быть активным окном и по умолчанию быть
выбранным.  Поведение функции определяется четырьмя элементами списка,
заданного параметром @var{window} @code{quit-restore}
(@pxref{Window Parameters}).

Первый элемент параметра @code{quit-restore} - это один из символов
@code{window}, означающий, что окно было специально создано
@code{display-buffer}; @code{frame}, создан отдельный фрейм; @code{same},
окно всегда отображало только этот буфер; или @code{other}, раньше окно
показывало другой буфер.  @code{frame} и @code{window} влияет на то, как
окно закрывается, а @code{same} и @code{other} влияет на повторное
отображение буферов, ранее показанных в @var{window}.

Второй элемент параметра - это либо один из символов @code{window} или
@code{frame}, либо список, элементами которого являются буфер, показанный в
@var{window} ранее, положение начала окна и точки  этого буфера, а также
высота @var{window} в это время.  Если этот буфер все еще активен при выходе
из @var{window}, то эта функция может повторно использовать @var{window} для
его отображения.

Третий элемент - это окно, выбранное во время создания параметра.  Если эта
функция удаляет @var{window}, она впоследствии пытается повторно выбрать
окно, названное этим элементом.

Четвертый элемент - это буфер, отображение которого вызвало создание этого
параметра.  Функция может удалить @var{window} тогда и только тогда, когда
она все еще показывает этот буфер.

Функция попытается удалить @var{window} тогда и только тогда, когда (1)
первый элемент ее параметра @code{quit-restore} равен @code{window} или
@code{frame}, (2) в окне нет истории ранее отображаемых буферов и (3)
четвертый элемент параметра @code{quit-restore} указывает буфер,
отображаемый в настоящее время в формате @var{window}.  Если @var{window}
является частью атомарного окна (@pxref{Atomic Windows}), вместо этого
попытается удалить корень этого атомарного окна.  В любом случае пытается
избежать сообщения об ошибке, когда невозможно удалить @var{window}.

Если @var{window} должно быть удалено и это единственное окно в его фрейме, и на терминале этого фрейма есть другие фреймы, значение необязательного
аргумента @var{bury-or-kill} определяет, как продолжить работу с окном.
Если @var{bury-or-kill} равно @code{kill}, фрейм удаляется безоговорочно.  В
противном случае судьба фрейма определяется вызовом
@code{frame-auto-hide-function} (смотреть ниже) с этим фреймом в качестве
единственного аргумента.

Если третий элемент параметра @code{quit-restore} - это список буферов,
начало окна (@pxref{Window Start and End}) и точка (@pxref{Window Point}), и
этот буфер все еще активен, буфер будет отображаться, а начало и точка
установлены соответственно.  Если дополнительно был временно изменен размер
буфера @var{window}, эта функция также попытается восстановить исходную
высоту @var{window}.

В противном случае, если @var{window} ранее использовался для отображения
других буферов (@pxref{Window History}), будет отображаться самый последний
буфер в этой истории.  В любом случае, если @var{window} не удален, его
параметр @code{quit-restore} сбрасывается на @code{nil}.

Необязательный аргумент @var{bury-or-kill} указывает, как работать с
буфером @var{window}.  Обрабатываются следующие значения:

@table @code
@item nil
Это означает, что не нужно иметь дело с буфером каким-либо конкретным
образом.  Как следствие, если @var{window} не удален, вызов
@code{switch-to-prev-buffer} обычно снова отображает буфер.

@item append
Это означает, что если @var{window} не удалено, его буфер перемещается в
конец списка предыдущих буферов @var{window}, поэтому вероятность
переключения на него при следующем вызове @code{switch-to-prev-buffer}
снижается.  Кроме того, перемещается буфер в конец списка буферов фрейма.

@item bury
Это означает, что если @var{window} не удалено, его буфер удаляется из
списка @var{window} предыдущих буферов.  Кроме того, перемещается буфер в
конец списка буферов фрейма.  Это значение обеспечивает самое надежное
средство, чтобы @code{switch-to-prev-buffer} не переключился на этот буфер
снова, не уничтожая буфер.

@item kill
Это означает уничтожение буфера @var{window}.
@end table

Обычно процедуры отображения, запускаемые @code{display-buffer}, правильно
устанавливают параметр окна @code{quit-restore}.  Также можно установить его
вручную, используя следующий код для отображения @var{buffer} в
@var{window}:

@example
@group
(display-buffer-record-window type window buffer)

(set-window-buffer window buffer)

(set-window-prev-buffers window nil)
@end group
@end example

Установка истории окон на @code{nil} гарантирует, что будущий вызов
@code{quit-window} может полностью удалить окно.

@end defun

Следующая опция определяет, как поступать с фреймом, содержащим только одно
окно, которое должно быть либо закрыто, либо буфер которого должен быть
похоронен.

@defopt frame-auto-hide-function
Функция, указанная в этой опции, вызывается для автоматического скрытия
фреймов.  Эта функция вызывается с одним аргументом - фреймом.

Указанная здесь функция вызывается @code{bury-buffer} (@pxref{Buffer List}),
когда выбранное окно выделено и показывает буфер, который нужно скрыть.
Также вызывается @code{quit-restore-window} (смотреть выше), когда фрейм
окна, из которого нужно выйти, был специально создан для отображения буфера
этого окна, и буфер не уничтожается.

По умолчанию вызывается @code{iconify-frame} (@pxref{Visibility of Frames}).
В качестве альтернативы можно указать @code{delete-frame}
(@pxref{Deleting Frames}), чтобы удалить фрейм его отображения,
@code{make-frame-invisible}, чтобы сделать фрейм невидимым, @code{ignore},
чтобы оставить фрейм без изменений, или любую другую функцию, которая может
принимать фрейм в качестве единственного аргумента.

Обратить внимание, что функция, указанная в этой опции, вызывается только в
том случае, если указанный фрейм содержит только одно активное окно и есть
хотя бы один другой фрейм на том же терминале.

Для конкретного фрейма указанное здесь значение может быть переопределено
параметром фрейма @code{auto-hide-function}
(@pxref{Frame Interaction Parameters}) этого кадра.
@end defopt


@node Side Windows
@section Боковые Окна
@cindex side windows
@cindex main window
@cindex main window of a frame

Боковые окна - это специальные окна, расположенные с любой из четырех сторон
корневого окна фрейма (@pxref{Windows and Frames}).  На практике это
означает, что область корневого окна фрейма подразделяется на главное окно и
ряд боковых окон, окружающих это главное окно.  Главное окно представляет
собой окно реального времени ``normal'' или определяет область, содержащую
все обычные окна.

   В наиболее простой форме использования боковые окна позволяют всегда
отображать определенные буферы в одной и той же области фрейма.
Следовательно, их можно рассматривать как обобщение концепции
@code{display-buffer-at-bottom} (@pxref{Buffer Display Action Functions}) на
остальные стороны фрейма.  Однако с соответствующими настройками боковые
окна могут также использоваться для предоставления макетов фреймов,
аналогичных тем, которые встречаются в так называемых интегрированных средах
разработки.  (IDEs).

@menu
* Displaying Buffers in Side Windows:: Функция действия для отображения
                                          буферов в боковых окнах.
* Side Window Options and Functions:: Дальнейший тюнинг боковых окон.
* Frame Layouts with Side Windows:: Настройка макетов рамок с боковыми
                                       окнами.
@end menu


@node Displaying Buffers in Side Windows
@subsection Отображение Буферов в Боковых Окнах

Следующая функция действия для @code{display-buffer}
(@pxref{Buffer Display Action Functions}) создает или повторно использует
боковое окно для отображения указанного буфера.

@defun display-buffer-in-side-window buffer alist
Функция отображает @var{buffer} в боковом окне выбранного фрейма.
Возвращает окно, используемое для отображения @var{buffer}, @code{nil},
если такое окно не может быть найдено или создано.

@var{alist} - это список ассоциаций символов и значений, как для
@code{display-buffer}.  Следующие символы в @var{alist} являются
специальными для этой функции:

@table @code
@item side
Обозначает сторону рамки, на которой должно быть расположено окно.
Допустимые значения: @code{left}, @code{top}, @code{right} и @code{bottom}.
Если не указано иное, окно располагается в нижней части фрейма.

@item slot
Обозначает слот на указанной стороне, где нужно разместить окно.  Нулевое
значение означает, что окно предпочтительно расположить посередине указанной
стороны.  Отрицательное значение означает использование слота,
предшествующего (то есть выше или слева) среднего слота.  Положительное
значение означает использование слота, следующего (то есть ниже или справа)
от среднего слота.  Следовательно, все окна на определенной стороне
упорядочены по их значению @code{slot}.  Если не указано, окно располагается
посередине указанной стороны.
@end table

Если указан один и тот же слот на одной стороне для двух или более разных
буферов, буфер, отображаемый последним, будет показан в соответствующем
окне.  Следовательно, слоты могут использоваться для совместного
использования одного и того же бокового окна между буферами.

Функция устанавливает параметры @code{window-side} и @code{window-slot}
(@pxref{Window Parameters}) и делает их постоянными.  Никакие другие
параметры окна не устанавливаются, если они не были явно указаны через
запись @code{window-parameters} в @var{alist}.
@end defun

По умолчанию боковые окна нельзя разделить через @code{split-window}
(@pxref{Splitting Windows}).  Кроме того, боковое окно не используется
повторно или не разделяется никаким действием отображения буфера
(@pxref{Buffer Display Action Functions}), если оно явно не указано как цель
этого действия.  Также обратить внимание, что @code{delete-other-windows} не
может сделать боковое окно единственным окном в своей рамке
(@pxref{Deleting Windows}).

   После настройки боковые окна также изменяют поведение команд
@code{switch-to-prev-buffer} и @code{switch-to-next-buffer}
(@pxref{Window History}).  В частности, эти команды будут воздерживаться от
отображения в боковом окне буферов, которые ранее не отображались в этом
окне.  Они также будут воздерживаться от того, чтобы в обычном небоковом
окне отображался буфер, который уже был отображен в боковом окне.  Заметное
исключение из последнего правила возникает, когда приложение после
отображения буфера сбрасывает локальные переменные этого буфера.


@node Side Window Options and Functions
@subsection Параметры и Функции Бокового Окна

Следующие параметры обеспечивают дополнительный контроль над размещением
боковых окон.

@defopt window-sides-vertical
Если не-@code{nil}, боковые окна слева и справа от рамки занимают всю высоту
рамки.  В противном случае боковые окна вверху и внизу рамкп занимают всю
ширину рамки.
@end defopt

@defopt window-sides-slots
Параметр определяет максимальное количество боковых окон с каждой стороны
рамки.  Значение представляет собой список из четырех элементов,
определяющих количество слотов боковых окон (в этом порядке) слева, вверху,
справа и внизу каждого кадра.  Если элемент является числом, это означает
отображение не более этого количества окон на соответствующей стороне.  Если
элементом является @code{nil}, это означает, что количество слотов на этой
стороне не ограничено.

Если любое из указанных значений равно нулю, на соответствующей стороне не
может быть создано ни одного окна.  @code{display-buffer-in-side-window} не
будет сигнализировать об ошибке в этом случае, но вернет @code{nil}.  Если
указанное значение просто запрещает создание дополнительного бокового окна,
наиболее подходящее окно на этой стороне используется повторно, и его
параметр @code{window-slot} может быть соответственно изменен.
@end defopt

@defopt window-sides-reversed
Параметр указывает, должны ли верхние/нижние боковые окна отображаться в
обратном порядке.  Когда @code{nil}, боковые окна сверху и снизу фрейма
всегда рисуются слева направо с увеличением значений слота.  Когда @code{t},
порядок рисования меняется на противоположный, и боковые окна сверху и снизу
фрейма рисуются справа налево с увеличением значений слота.

Когда установлено @code{bidi}, порядок рисования меняется на обратный тогда
и только тогда, когда значение @code{bidi-paragraph-direction}
(@pxref{Bidirectional Display}) установлено в @code{right-to-left} в буфере,
отображаемом в окне, которое было выбрано последним в области главного окна
этого фрейма.  Иногда это окно бывает трудно найти, поэтому используются
эвристики, чтобы избежать непреднамеренного изменения порядка рисования при
выборе другого окна.

Расположение боковых окон слева или справа от рамки не зависит от значения
этой переменной.
@end defopt

Когда у фрейма есть боковые окна, следующая функция возвращает главное окно
этого фрейма.

@defun window-main-window &optional frame
Функция возвращает главное окно указанного @var{frame}.  Необязательный
аргумент @var{frame} должен быть активным фреймом и по умолчанию быть
выбранным.

Если @var{frame} не имеет боковых окон, возвращается корневое окно
@var{frame}.  В противном случае возвращается либо внутреннее небоковое
окно, так что все другие небоковые окна на @var{frame} спускаются от него,
либо одиночное активное небоковое окно @var{frame}.  Обратить внимание, что
главное окно фрейма нельзя удалить с помощью @code{delete-window}.
@end defun

Следующая команда удобна для переключения внешнего вида всех боковых окон
на указанной рамке.

@deffn Command window-toggle-side-windows &optional frame
Команда переключает боковые окна на указанном @var{frame}.  Необязательный
аргумент @var{frame} должен быть активным фреймом и по умолчанию быть
выбранным.

Если у @var{frame} есть хотя бы одно боковое окно, эта команда сохраняет
состояние корневого окна @var{frame} в параметре @var{frame}
@code{window-state} и впоследствии удаляет все боковые окна на
@var{frame}.

Если @var{frame} не имеет боковых окон, но имеет параметр
@code{window-state}, эта команда использует значение этого параметра для
восстановления боковых окон на @var{frame}, оставляя только главное окно
@var{frame}.

Об ошибке сигнализируется, если @var{frame} не имеет боковых окон и для него
не найдено сохраненное состояние.
@end deffn


@node Frame Layouts with Side Windows
@subsection Макеты Рамок с Боковыми Окнами

Боковые окна можно использовать для создания более сложных макетов фреймов,
подобных тем, которые предоставляются интегрированными средами разработки
(IDE).  В таких макетах область главного окна - это место, где обычно
выполняются операции редактирования.  Боковые окна не предназначены для
редактирования в обычном понимании.  Скорее, они должны отображать
информацию, дополняющую текущую операцию редактирования, такую как списки
файлов, тегов или буферов, справочную информацию, результаты поиска или
grep или вывод оболочки.

   Макет такой рамки может выглядеть следующим образом:

@smallexample
@group
     ___________________________________
    |          *Buffer List*            |
    |___________________________________|
    |     |                       |     |
    |  *  |                       |  *  |
    |  d  |                       |  T  |
    |  i  |                       |  a  |
    |  r  |   Main Window Area    |  g  |
    |  e  |                       |  s  |
    |  d  |                       |  *  |
    |  *  |                       |     |
    |_____|_______________________|_____|
    | *help*/*grep*/  |  *shell*/       |
    | *Completions*   |  *compilation*  |
    |_________________|_________________|
    |             Echo Area             |
    |___________________________________|


@end group
@end smallexample

В следующем примере показано, как параметры окна (@pxref{Window Parameters})
могут использоваться с @code{display-buffer-in-side-window}
(@pxref{Displaying Buffers in Side Windows}) для настройки кода для создания
макета фрейма, показанного выше.

@example
@group
(defvar parameters
  '(window-parameters . ((no-other-window . t)
                         (no-delete-other-windows . t))))

(setq fit-window-to-buffer-horizontally t)
(setq window-resize-pixelwise t)

(setq
 display-buffer-alist
 `(("\\*Buffer List\\*" display-buffer-in-side-window
    (side . top) (slot . 0) (window-height . fit-window-to-buffer)
    (preserve-size . (nil . t)) ,parameters)
   ("\\*Tags List\\*" display-buffer-in-side-window
    (side . right) (slot . 0) (window-width . fit-window-to-buffer)
    (preserve-size . (t . nil)) ,parameters)
   ("\\*\\(?:help\\|grep\\|Completions\\)\\*"
    display-buffer-in-side-window
    (side . bottom) (slot . -1) (preserve-size . (nil . t))
    ,parameters)
   ("\\*\\(?:shell\\|compilation\\)\\*" display-buffer-in-side-window
    (side . bottom) (slot . 1) (preserve-size . (nil . t))
    ,parameters)))
@end group
@end example

Это определяет записи @code{display-buffer-alist} (@pxref{Choosing Window})
для буферов с фиксированными именами.  В частности, просит показать
@file{*Buffer List*} с регулируемой высотой вверху рамки и
@file{*Tags List*} с регулируемой шириной справа от рамки.  Также требует,
чтобы буферы @file{*help*}, @file{*grep*} и @file{*Completions*} совместно
использовали окно в нижней левой части фрейма, а буферы @file{*shell*} и
@file{*compilation*} отображались в окне в правой нижней части фрейма.

   Обратить внимание, что опция @code{fit-window-to-buffer-horizontally}
должна иметь значение не-@code{nil}, чтобы разрешить горизонтальную
настройку окон.  Также добавляются записи, которые просят сохранить высоту
боковых окон вверху и внизу рамки и ширину боковых окон слева или справа от
рамки.  Чтобы гарантировать, что боковые окна сохраняют свои соответствующие
размеры при максимальном увеличении фрейма, переменной
@code{window-resize-pixelwise} устанавливается значение не-@code{nil}.
@xref{Resizing Windows}.

   Последняя форма также гарантирует, что ни одно из созданных боковых окон
не доступно через @w{@kbd{C-x o}}, установив параметр @code{no-other-window}
для каждого из этих окон.  Кроме того, следится за тем, чтобы боковые окна
не удалялись через @w{@kbd{C-x 1}}, устанавливая параметр
@code{no-delete-other-windows} для каждого из этих окон.

   Поскольку у буферов @code{dired} нет фиксированных имен, используется
специальная функция @code{dired-default-directory-on-left}, чтобы отображать
минимальный буфер каталога в левой части кадра.

@example
@group
(defun dired-default-directory-on-left ()
  "Отобразить `default-directory' в боковом окне слева, скрывая детали."
  (interactive)
  (let ((buffer (dired-noselect default-directory)))
    (with-current-buffer buffer (dired-hide-details-mode t))
    (display-buffer-in-side-window
     buffer `((side . left) (slot . 0)
              (window-width . fit-window-to-buffer)
              (preserve-size . (t . nil)) ,parameters))))
@end group
@end example

Оценив предыдущие формы и набрав в любом порядке,
@w{@kbd{M-x list-buffers}}, @kbd{C-h f}, @kbd{M-x shell},
@w{@kbd{M-x list-tags}}, и @kbd{M-x dired-default-directory-on-left} теперь
должен воспроизвестись макет фрейма, показанный выше.


@node Atomic Windows
@section Атомарные Окна
@cindex atomic windows

Атомарные окна - это прямоугольные композиции как минимум из двух активных
окон.  Они обладают следующими отличительными характеристиками:


@itemize @bullet
@item
Функция @code{split-window} (@pxref{Splitting Windows}), когда применяется к
составной части атомарного окна, будет пытаться создать новое окно вне
атомарного окна.

@item
Функция @code{delete-window} (@pxref{Deleting Windows}), применяемая к
компоненту атомарного окна, вместо этого попытается удалить все атомарное
окно.

@item
Функция @code{delete-other-windows} (@pxref{Deleting Windows}), когда
применяется к компоненту атомарного окна, будет пытаться заставить атомарное
окно заполнить его фрейм или главное окно (@pxref{Side Windows}).
@end itemize

Это означает, что основные группы функций, которые изменяют структуру окна,
обрабатывают атомарное окно как активное, таким образом сохраняя внутреннюю
структуру атомарного окна.

   Атомарные окна полезны для создания и сохранения макетов окон, которые
имеют смысл только тогда, когда все задействованные буферы отображаются
одновременно определенным образом, например, при отображении различий между
версиями файлов или одного и того же текста на разных языках или разметках.
Их также можно использовать для постоянного отображения информации,
относящейся к определенному окну, в полосах по бокам этого окна.

@cindex root window of atomic window
   Атомарные окна реализуются с помощью зарезервированного параметра окна
@code{window-atom} (@pxref{Window Parameters}) и внутреннего окна
(@pxref{Basic Windows}), называемого корневым окном атомарного окна.  Все
окна, которые являются частью одного атомарного окна, имеют это корневое
окно в качестве своего общего предка, и им устанавливается параметр
@code{window-atom} в не-@code{nil}.

  Следующая функция возвращает корень атомарного окна, частью которого
является указанное окно:

@defun window-atom-root &optional window
Функция возвращает корень атомарного окна, частью которого является
@var{window}.  Указанный @var{window} должно быть допустимым окном и по
умолчанию быть выбранным.  Возвращается @code{nil}, если @var{window} не
является частью атомарного окна.
@end defun

Самый простой подход к созданию нового атомарного окна - это взять
существующее внутреннее окно и применить следующую функцию:

@defun window-make-atom window
Функция конвертирует @var{window} в атомарное окно.  Указаное @var{window}
должно быть внутренним окном.  Все, что делает эта функция, - устанавливает
для параметра @code{window-atom} каждого потомка @var{window} значение
@code{t}.
@end defun

Чтобы создать новое атомарное окно из существующего активного окна или
добавить новое окно к существующему атомарному окну, можно использовать
следующую функцию действия отображения буфера
(@pxref{Buffer Display Action Functions}):

@defun display-buffer-in-atom-window buffer alist
Функция пытается отобразить @var{buffer} в новом окне, которое будет
объединено с существующим окном, чтобы сформировать атомарное окно.  Если
существующее окно уже является частью атомарного окна, оно добавляет новое
окно к этому атомарному окну.

Указанный @var{alist} - это список ассоциаций символов и значений.
Следующие символы имеют особое значение:

@table @code
@item window
Значение такого элемента определяет существующее окно, с которым должно быть
объединено новое окно.  Если указывает внутреннее окно, все дочерние
элементы этого окна также становятся частью атомарного окна.  Если никакое
окно не указано, новое окно становится родным по отношению к выбранному
окну.  Параметр @code{window-atom} существующего окна устанавливается в
@code{main} при условии, что окно активно и его параметр @code{window-atom}
еще не установлен.

@item side
Значение такого элемента обозначает сторону существующего окна, где должно
быть расположено новое окно.  Допустимые значения: @code{below},
@code{right}, @code{above} и @code{left}.  По умолчанию @code{below}.
Параметр @code{window-atom} нового окна устанавливается в это значение.
@end table

Возвращаемое значение - новое окно, @code{nil}, когда создание этого окна
не удалось.
@end defun

Обратить внимание, что значение параметра @code{window-atom} на самом деле
не имеет значения, если оно равно не-@code{nil}.  Значения, присвоенные
@code{display-buffer-in-atom-window}, позволяют легко получить исходное и
новое окно после применения этой функции.  Также обратить внимание, что
параметр @code{window-atom} - единственный параметр окна, назначаемый
@code{display-buffer-in-atom-window}.  Дополнительные параметры должны быть
установлены приложением явно через запись @code{window-parameters} в
@var{alist}.

   Атомарные окна автоматически перестают существовать, когда одна из их
составляющих удаляется.  Чтобы растворить атомарное окно вручную,
сбрасывается параметр @code{window-atom} его составляющих - корень
атомарного окна и всех его потомков.

   Следующий фрагмент кода, применяемый к однооконному фрейму, сначала
разделяет выбранное окно и делает выбранное и новое окно составляющими
атомарного окна с их родителем в качестве корня.  Затем отображается буфер
@file{*Messages*} в новом окне внизу фрейма и делает это новое окно частью
только что созданного атомарного окна.

@example
@group
(let ((window (split-window-right)))
  (window-make-atom (window-parent window))
  (display-buffer-in-atom-window
   (get-buffer-create "*Messages*")
   `((window . ,(window-parent window)) (window-height . 5))))
@end group
@end example

В этот момент ввод @w{@kbd{C-x 2}} в любом окне этого фрейма создает новое
окно в нижней части фрейма.  Если вместо этого набирается @w{@kbd{C-x 3}},
справа от фрейма появится новое окно.  В любом случае, если вводится сейчас
@w{@kbd{C-x 1}} в любом окне атомарного окна, будет удалено только новое
окно.  Ввод @w{@kbd{C-x 0}} в любом окне атомарного окна заставит это новое
окно заполнить фрейм.


@node Window Point
@section Окна и Точка
@cindex window position
@cindex window point
@cindex position in window
@cindex point in window

  Каждое окно имеет собственное значение точки (@pxref{Point}), независимо
от значения точки в других окнах, отображающих тот же буфер.  Это делает
полезным иметь несколько окон, показывающих один буфер.

@itemize @bullet
@item
Точка окна устанавливается при первом создании окна; она инициализируется из
точки буфера или из точки другого окна, открытого в буфере, если такое окно
существует.

@item
Выбор окна устанавливает значение точки в его буфере из значения точки в
окне.  И наоборот, отмена выбора окна устанавливает значение точки окна,
отличное от значения в буфере.  Таким образом, когда переключаться между
окнами, отображающими данный буфер, значение точки для выбранного окна
действует в буфере, в то время как значения точек для других окон
сохраняются в этих окнах.

@item
Пока в выбранном окне отображается текущий буфер, точка окна и точка буфера
всегда перемещаются вместе; они остаются равными.
@end itemize

@cindex cursor
   Emacs отображает курсор по умолчанию в виде прямоугольного блока в каждом
окне в позиции точки этого окна.  Когда пользователь переключается на другой
буфер в окне, Emacs перемещает курсор этого окна туда, где находится точка в
этом буфере.  Если точное положение точки скрыто за некоторым отображаемым
элементом, таким как отображаемая строка или изображение, Emacs отображает
курсор непосредственно перед или после этого отображаемого элемента.

@defun window-point &optional window
Функция возвращает текущую позицию точки в @var{window}.  Для невыбранного
окна это значение будет иметь (в буфере этого окна), если бы это окно было
выбрано.  По умолчанию для @var{window} выбрано окно.

Когда @var{window} является выбранным окном, возвращаемое значение является
значением точки в буфере этого окна.  Строго говоря, было бы правильнее
возвращать значение точки верхнего уровня вне любых форм
@code{save-excursion}.  Но такую ценность трудно найти.
@end defun

@defun set-window-point window position
Функция позиционирует точку в @var{window} на позицию @var{position} в
буфере @var{window}.  Возвращается @var{position}.

Если выбрано @var{window}, это просто делает @code{goto-char} в буфере
@var{window}.
@end defun

@defvar window-point-insertion-type
Переменная определяет тип вставки маркера (@pxref{Marker Insertion Types})
для @code{window-point}.  По умолчанию используется @code{nil}, поэтому
@code{window-point} останется за вставленным там текстом.
@end defvar

@node Window Start and End
@section Позиции Начала и Конца Окна
@cindex window start position
@cindex display-start position

  В каждом окне есть маркер, используемый для отслеживания позиции буфера,
который указывает, где в буфере должно начинаться отображение.  Эта позиция
называется положением окна @dfn{display-start} (или просто @dfn{start}).
Символ после этой позиции - это тот, который появляется в верхнем левом углу
окна.  Обычно, но не обязательно, в начале текстовой строки.

  После переключения окон или буферов и в некоторых других случаях, если
начало окна находится в середине строки, Emacs корректирует начало окна на
начало строки.  Это предотвращает выход некоторых операций за пределы начала
окна в бессмысленной точке внутри строки.  Эта функция может помешать
тестированию некоторого кода Lisp, выполняя его с помощью команд режима
Lisp, потому что они запускают эту перенастройку.  Чтобы протестировать
такой код, поместить его в команду и привязать команду к ключу.

@defun window-start &optional window
@cindex window top line
Функция возвращает позицию начала отображения окна @var{window}.  Если
@var{window} равен @code{nil}, используется выбранное окно.

Когда создается окно или отображаете в нем другой буфер, позиция
display-start устанавливается в положение display-start, которое недавно
использовалось для того же буфера, или на @code{point-min}, если в буфере
его нет.

Redisplay обновляет позицию начала окна (если не указана она явно с момента
предыдущего повторного отображения) --- чтобы убедиться, что точка
появляется на экране.  Ничего, кроме повторного отображения, автоматически
не изменяет положение начала окна; если перемещать точку, не ожидается, что
позиция начала окна изменится в ответ до следующего повторного отображения.
@end defun

@defun window-group-start &optional window
@vindex window-group-start-function
Функция похожа на @code{window-start}, за исключением того, что когда
@var{window} является частью группы окон (@pxref{Window Group}),
@code{window-group-start} возвращает начальную позицию всей группы.  Это
условие выполняется, когда в качестве локальной переменной буфера
@code{window-group-start-function} задана функция.  В этом случае
@code{window-group-start} вызывает функцию с единственным аргументом
@var{window}, а затем возвращает ее результат.
@end defun

@cindex window end position
@cindex last visible position in a window
@defun window-end &optional window update
Функция возвращает позицию, в которой отображение ее буфера заканчивается на
@var{window}.  По умолчанию для @var{window} выбрано окно.

Простое изменение текста в буфере или перемещения точки не обновляет
значение, возвращаемое @code{window-end}.  Значение обновляется только
тогда, когда Emacs повторно отображается и повторное отображение завершается
без вытеснения.

Если последнее повторное отображение @var{window} было прервано и не
завершилось, Emacs не знает позицию конца отображения в этом окне.  В этом
случае эта функция возвращает @code{nil}.

Если @var{update} равен не-@code{nil}, @code{window-end}, всегда возвращает
актуальное значение, в котором заканчивается отображение, на основе текущего
значения @code{window-start}.  Если ранее сохраненное значение этой позиции
все еще действует, @code{window-end} возвращает это значение; в противном
случае вычисляется правильное значение, просматривая текст буфера.

Даже если @var{update} равен не-@code{nil}, @code{window-end}, не пытается
прокрутить дисплей, если точка переместилась за пределы экрана, как это было
бы при реальном повторном отображении.  Это не меняет значение
@code{window-start}.  Фактически, сообщается, где закончится отображаемый
текст, если прокрутка не требуется.  Обратить внимание, что возвращаемая
позиция может быть видна только частично.
@end defun

@vindex window-group-end-function
@defun window-group-end &optional window update
Функция похожа на @code{window-end}, за исключением того, что когда
@var{window} является частью группы окон, (@pxref{Window Group}),
@code{window-group-end} возвращает конечную позицию всей группы.  Это
условие выполняется, когда локальная переменная буфера
@code{window-group-end-function} установлена в функцию.  В этом случае
@code{window-group-end} вызывает функцию с двумя аргументами @var{window} и
@var{update}, а затем возвращает ее результат.  Аргумент @var{update} имеет
то же значение, что и аргумент @code{window-end}.
@end defun

@defun set-window-start window position &optional noforce
Функция устанавливает позицию начала отображения @var{window} в
@var{position} в буфере @var{window}.  Возвращается @var{position}.

Процедуры отображения настаивают на том, чтобы положение точки было видимым
при отображении буфера.  Обычно они выбирают начальную позицию отображения в
соответствии со своей внутренней логикой (и при необходимости прокручивают
окно), чтобы сделать точку видимой.  Однако, если указать начальную позицию
с помощью этой функции, используя @code{nil} для @var{noforce}, это будет
означает, что требуется, чтобы отображение начиналось с @var{position}, даже
если это приведет к удалению местоположения точки с экрана.  Если это
действительно перемещает точку за пределы экрана, процедуры отображения
пытаются переместить точку к левому краю средней линии в окне.

Например, если точка @w{это 1} и установлено начало окна @w{в 37}, начало
следующей строки, точка будет выше верхней части окна.  Процедуры
отображения автоматически переместят точку, если она все еще равна 1 при
повторном отображении. Вот пример:

@example
@group
;; @r{Вот как выглядит @samp{foo} до выполнения }
;;   @r{ выражения @code{set-window-start}.}
@end group

@group
---------- Buffer: foo ----------
@point{}This is the contents of buffer foo.
2
3
4
5
6
---------- Buffer: foo ----------
@end group

@group
(set-window-start
 (selected-window)
 (save-excursion
   (goto-char 1)
   (forward-line 1)
   (point)))
@result{} 37
@end group

@group
;; @r{Вот как выглядит @samp{foo} после выполнения }
;;   @r{ выражения @code{set-window-start}.}
---------- Buffer: foo ----------
2
3
@point{}4
5
6
---------- Buffer: foo ----------
@end group
@end example

Если попытка сделать точку видимой (то есть в полностью видимой строке
экрана) не удалась, процедуры отображения проигнорируют запрошенную позицию
начала окна и все равно вычисят новую.  Таким образом, для получения
надежных результатов программы Lisp, вызывающие эту функцию, всегда должны
перемещать точку внутрь окна, отображение которого начинается с
@var{position}.

Если @var{noforce} равен не-@code{nil}, а @var{position} поместит точку за
пределы экрана при следующем повторном отображении, то перерисовка вычисляет
новую позицию начала окна, которая хорошо работает с точкой, и поэтому
@var{position} не используется.
@end defun

@vindex set-window-group-start-function
@defun set-window-group-start window position &optional noforce
Функция похожа на @code{set-window-start}, за исключением того, что когда
@var{window} является частью группы окон (@pxref{Window Group}),
@code{set-window-group-start} устанавливает начальную позицию всей группы.
Это условие выполняется, когда локальная переменная буфера
@code{set-window-group-start-function} установлена в функцию.  В этом случае
@code{set-window-group-start} вызывает функцию с тремя аргументами
@var{window}, @var{position}, и @var{noforce}, а затем возвращает ее
результат.  Аргументы @var{position} и @var{noforce} в этой функции имеют
то же значение, что и в @code{set-window-start}.
@end defun

@defun pos-visible-in-window-p &optional position window partially
Функция возвращает не-@code{nil}, если @var{position} находится в пределах
диапазона текста, который в настоящее время отображается на экране в
@var{window}.  Возвращается @code{nil}, если @var{position} прокручивается
вертикально вне поля зрения.  Частично закрытые места не считаются видимыми,
если @var{partially} не не-@code{nil}.  Аргумент @var{position} по умолчанию
равен текущей позиции точки в @var{window}; @var{window} по умолчанию
используется в выбранном окне.  Если @var{position} имеет значение @code{t},
это означает, что нужно проверить либо первую видимую позицию последней
строки экрана в @var{window}, либо позицию конца буфера, в зависимости от
того, что наступит раньше.

Функция учитывает только вертикальную прокрутку.  Если @var{position}
находится вне поля зрения только потому, что @var{window} был прокручен по
горизонтали, @code{pos-visible-in-window-p} все равно возвращает
не-@code{nil}.  @xref{Horizontal Scrolling}.

Если @var{position} виден, @code{pos-visible-in-window-p} возвращается
@code{t}, если @var{partially} - @code{nil}; если @var{partially} равен
не-@code{nil}, а символ, следующий за @var{position}, полностью виден,
возвращается список вида @code{(@var{x} @var{y})}, где @var{x} и @var{y} -
координаты пикселя относительно левого верхнего угла окна; в противном
случае возвращается расширенный список в форме
@code{(@var{x} @var{y} @var{rtop} @var{rbot} @var{rowh} @var{vpos})}, где
@var{rtop} и @var{rbot} указывает количество пикселей вне окна вверху и
внизу строки в @var{position}, @var{rowh} указывает видимую высоту этой
строки, а @var{vpos} указывает вертикальное положение (ноль- на основе
номера строки) этой строки.

Вот пример:

@example
@group
;; @r{Если точка сейчас находится за пределами экрана, перецентрировать её сейчас.}
(or (pos-visible-in-window-p
     (point) (selected-window))
    (recenter 0))
@end group
@end example
@end defun

@vindex pos-visible-in-window-group-p-function
@defun pos-visible-in-window-group-p &optional position window partially
Функция похожа на @code{pos-visible-in-window-p}, за исключением того, что
когда @var{window} является частью группы окон (@pxref{Window Group}),
@code{pos-visible-in-window-group-p} проверяет видимость @var{pos} во всей
группе, а не только в одном @var{window}.  Это условие выполняется, когда
локальная переменная буфера @code{pos-visible-in-window-group-p-function}
установлена как функция.  В этом случае @code{pos-visible-in-window-group-p}
вызывает функцию с тремя аргументами @var{position}, @var{window}, и
@var{partially}, а затем возвращает ее результат.  Аргументы @var{position}
и @var{partially} имеют то же значение, что и в
@code{pos-visible-in-window-p}.
@end defun

@defun window-line-height &optional line window
Функция возвращает высоту текстовой строки @var{line} в @var{window}.  Если
@var{line} является одним из @code{header-line} или @code{mode-line},
@code{window-line-height}, возвращает информацию о соответствующей строке
окна.  В противном случае @var{line} - это номер текстовой строки,
начинающийся с 0.  Отрицательное число отсчитывается от конца окна.  По
умолчанию для @var{line} это текущая строка в @var{window}; по умолчанию для
@var{window} выбрано окно.

Если дисплей устарел, @code{window-line-height} возвращается @code{nil}.  В
этом случае @code{pos-visible-in-window-p} можно использовать для получения
связанной информации.

Если нет строки, соответствующей указанию @var{line},
@code{window-line-height}, возвращает @code{nil}.  В противном случае
возвращается список
@code{(@var{height} @var{vpos} @var{ypos} @var{offbot})}, где @var{height} -
высота в пикселях видимой части строки, @var{vpos} и @var{ypos} -
вертикальное положение в строках и пикселях строки относительно верха первой
текстовой строки, а @var{offbot} - число пикселей вне окна внизу текстовой
строки.  Если есть пиксели вне окна в верхней части (первой) текстовой
строки, @var{ypos} имеет отрицательное значение.
@end defun

@node Textual Scrolling
@section Текстовая Прокрутка
@cindex textual scrolling
@cindex scrolling textually

  @dfn{Текстовая прокрутка} означает перемещение текста вверх или вниз в
окне.  Работает путем изменения начальной точки отображения окна.  Также
может изменить значение @code{window-point}, чтобы сохранить точку на экране
(@pxref{Window Point}).

  Основные функции текстовой прокрутки - это @code{scroll-up} (прокрутка
вперед) и @code{scroll-down} (прокрутка назад).  В этих именах функций
``up'' и ``down'' относится к направлению движения текста буфера
относительно окна.  Представить, что текст написан на длинном рулоне бумаги
и что команды прокрутки перемещают бумагу вверх и вниз.  Таким образом, если
смотреть на середину буфера и многократно вызывать @code{scroll-down}, в
конечном итоге увидится начало буфера.

  К сожалению, это иногда вызывает путаницу, потому что некоторые люди
склонны мыслить в терминах противоположного соглашения: они воображают, что
окно перемещается по тексту, который остается на месте, так что команды
``down'' переносят в конец буфера.  Это соглашение согласуется с тем фактом,
что такая команда привязана к ключу с именем @key{PageDown} на современных
клавиатурах.
@ignore
Мы не перешли на это соглашение, так как это может нарушить существующий код
Emacs Lisp.
@end ignore

  Функции текстовой прокрутки (кроме @code{scroll-other-window}) дают
непредсказуемые результаты, если текущий буфер не тот, который отображается
в выбранном окне.  @xref{Current Buffer}.

  Если окно содержит строку выше, чем высота окна (например, при наличии
большого изображения), функции прокрутки будут регулировать положение
вертикальной прокрутки окна для прокрутки частично видимой строки.
Вызывающие Lisp могут отключить эту функцию, привязав переменную
@code{auto-window-vscroll} к @code{nil} (@pxref{Vertical Scrolling}).

@deffn Command scroll-up &optional count
Aункция выполняет прокрутку вперед на @var {count} строк в выбранном окне.

Если @var{count} отрицательно, вместо этого выполняется прокрутка назад.
Если @var{count} равно @code{nil} (или опущено), прокручиваемое расстояние
на @code{next-screen-context-lines} строк меньше высоты текстовой области
окна.

Если выбранное окно не может быть прокручено дальше, эта функция
сигнализирует об ошибке.  В противном случае возвращается @code{nil}.
@end deffn

@deffn Command scroll-down &optional count
Функция выполняет прокрутку назад по строкам @var{count} в выбранном окне.

Если @var{count} отрицательно, вместо этого выполняется прокрутка вперед.  В
остальном ведет себя так же, как @code{scroll-up}.
@end deffn

@deffn Command scroll-up-command &optional count
Ведет себя как @code{scroll-up}, за исключением того, что если выбранное
окно не может быть прокручено дальше, а значение переменной
@code{scroll-error-top-bottom} равно @code{t}, вместо этого оно пытается
переместиться в конец буфера.  Если точка уже есть, сигнализируется об
ошибке.
@end deffn

@deffn Command scroll-down-command &optional count
Ведет себя как @code{scroll-down}, за исключением того, что если выбранное
окно не может быть прокручено дальше, а значение переменной
@code{scroll-error-top-bottom} равно @code{t}, вместо этого проводится
попытка переместиться в начало буфера.  Если точка уже есть, сигнализируется
об ошибке.
@end deffn

@deffn Command scroll-other-window &optional count
Функция прокручивает текст в другом окне вверх @var{count} строк.
Отрицательные значения @var{count} или @code{nil} обрабатываются так же, как
и @code{scroll-up}.

Можно указать, какой буфер прокручивать, установив в переменной
@code{other-window-scroll-buffer} значение буфера.  Если этот буфер еще не
отображается, @code{scroll-other-window} отображает его в каком-то окне.

Когда выбранное окно является минибуфером, следующим окном обычно является
крайнее левое окно непосредственно над ним.  Можно указать другое окно для
прокрутки, когда минибуфер выбран, установив переменную
@code{minibuffer-scroll-window}.  Эта переменная не действует, когда выбрано
любое другое окно.  Когда не-@code{nil} и выбран минибуфер, он имеет
приоритет над @code{other-window-scroll-buffer}.
@xref{Definition of minibuffer-scroll-window}.

Когда минибуфер активен, это следующее окно, если выбрано окно в правом
нижнем углу.  В этом случае @code{scroll-other-window} пытается прокрутить
минибуфер.  Если минибуфер содержит только одну строку, прокручивать его
некуда, поэтому строка снова появляется после того, как в эхо-области на
мгновение отображается сообщение @samp{End of buffer}.
@end deffn

@defvar other-window-scroll-buffer
Если эта переменная - не-@code{nil}, она сообщает
@code{scroll-other-window}, какое окно буфера нужно прокручивать.
@end defvar

@defopt scroll-margin
Параметр определяет размер поля прокрутки - минимальное количество строк
между точкой и верхней или нижней частью окна.  Всякий раз, когда точка
попадает в такое количество строк вверху или внизу окна, перерисовка
автоматически прокручивает текст (если возможно), чтобы переместить точку
за пределы поля ближе к центру окна.
@end defopt

@defopt maximum-scroll-margin
Переменная ограничивает эффективное значение @code{scroll-margin} долей
текущей высоты строки окна.  Например, если в текущем окне 20 строк и
@code{maximum-scroll-margin} равно 0,1, то поля прокрутки никогда не будут
больше 2 строк, независимо от того, насколько велик @code{scroll-margin}.

Само @code{maximum-scroll-margin} имеет максимальное значение 0.5, что
позволяет устанавливать большие поля, чтобы курсор оставался в средней
строке окна (или двух средних строках, если в окне четное количество строк).
Если установлено большее значение (или любое значение, отличное от числа с
плавающей запятой между 0.0 и 0.5), то вместо него будет использоваться
значение по умолчанию 0.25.
@end defopt

@defopt scroll-conservatively
Переменная контролирует, как прокрутка выполняется автоматически, когда
точка перемещается за пределы экрана (или в поле прокрутки).  Если значение
является положительным целым числом @var{n}, то при повторном отображении
текст прокручивается до строк @var{n} в любом направлении, если это вернет
точку в надлежащий вид.  Такое поведение называется
@dfn{консервативная прокрутка}.  В противном случае прокрутка происходит
обычным образом под управлением других переменных, например
@code{scroll-up-aggressively} и @code{scroll-down-aggressively}.

Значение по умолчанию - ноль, что означает, что консервативной прокрутки
никогда не будет.
@end defopt

@defopt scroll-down-aggressively
The value of this variable should be either @code{nil} or a fraction
@var{f} between 0 and 1.  If it is a fraction, that specifies where on
the screen to put point when scrolling down.  More precisely, when a
window scrolls down because point is above the window start, the new
start position is chosen to put point @var{f} part of the window
height from the top.  The larger @var{f}, the more aggressive the
scrolling.

A value of @code{nil} is equivalent to .5, since its effect is to center
point.  This variable automatically becomes buffer-local when set in any
fashion.
@end defopt

@defopt scroll-up-aggressively
Likewise, for scrolling up.  The value, @var{f}, specifies how far
point should be placed from the bottom of the window; thus, as with
@code{scroll-down-aggressively}, a larger value scrolls more
aggressively.
@end defopt

@defopt scroll-step
This variable is an older variant of @code{scroll-conservatively}.
The difference is that if its value is @var{n}, that permits scrolling
only by precisely @var{n} lines, not a smaller number.  This feature
does not work with @code{scroll-margin}.  The default value is zero.
@end defopt

@cindex @code{scroll-command} property
@defopt scroll-preserve-screen-position
If this option is @code{t}, whenever a scrolling command moves point
off-window, Emacs tries to adjust point to keep the cursor at its old
vertical position in the window, rather than the window edge.

If the value is не-@code{nil} and not @code{t}, Emacs adjusts point
to keep the cursor at the same vertical position, even if the
scrolling command didn't move point off-window.

This option affects all scroll commands that have a не-@code{nil}
@code{scroll-command} symbol property.
@end defopt

@defopt next-screen-context-lines
The value of this variable is the number of lines of continuity to
retain when scrolling by full screens.  For example, @code{scroll-up}
with an argument of @code{nil} scrolls so that this many lines at the
bottom of the window appear instead at the top.  The default value is
@code{2}.
@end defopt

@defopt scroll-error-top-bottom
If this option is @code{nil} (the default), @code{scroll-up-command}
and @code{scroll-down-command} simply signal an error when no more
scrolling is possible.

If the value is @code{t}, these commands instead move point to the
beginning or end of the buffer (depending on scrolling direction);
only if point is already on that position do they signal an error.
@end defopt

@deffn Command recenter &optional count
@cindex centering point
This function scrolls the text in the selected window so that point is
displayed at a specified vertical position within the window.  It does
not move point with respect to the text.

If @var{count} is a non-negative number, that puts the line containing
point @var{count} lines down from the top of the window.  If
@var{count} is a negative number, then it counts upward from the
bottom of the window, so that @minus{}1 stands for the last usable
line in the window.

If @var{count} is @code{nil} (or a не-@code{nil} list),
@code{recenter} puts the line containing point in the middle of the
window.  If @var{count} is @code{nil}, this function may redraw the
frame, according to the value of @code{recenter-redisplay}.

When @code{recenter} is called interactively, @var{count} is the raw
prefix argument.  Thus, typing @kbd{C-u} as the prefix sets the
@var{count} to a не-@code{nil} list, while typing @kbd{C-u 4} sets
@var{count} to 4, which positions the current line four lines from the
top.

With an argument of zero, @code{recenter} positions the current line at
the top of the window.  The command @code{recenter-top-bottom} offers
a more convenient way to achieve this.
@end deffn

@vindex recenter-window-group-function
@defun recenter-window-group &optional count
This function is like @code{recenter}, except that when the selected
window is part of a group of windows (@pxref{Window Group}),
@code{recenter-window-group} scrolls the entire group.  This condition
holds when the buffer local variable
@code{recenter-window-group-function} is set to a function.  In this
case, @code{recenter-window-group} calls the function with the
argument @var{count}, then returns its result.  The argument
@var{count} has the same meaning as in @code{recenter}, but with
respect to the entire window group.
@end defun

@defopt recenter-redisplay
If this variable is не-@code{nil}, calling @code{recenter} with a
@code{nil} argument redraws the frame.  The default value is
@code{tty}, which means only redraw the frame if it is a tty frame.
@end defopt

@deffn Command recenter-top-bottom &optional count
This command, which is the default binding for @kbd{C-l}, acts like
@code{recenter}, except if called with no argument.  In that case,
successive calls place point according to the cycling order defined
by the variable @code{recenter-positions}.
@end deffn

@defopt recenter-positions
This variable controls how @code{recenter-top-bottom} behaves when
called with no argument.  The default value is @code{(middle top
bottom)}, which means that successive calls of
@code{recenter-top-bottom} with no argument cycle between placing
point at the middle, top, and bottom of the window.
@end defopt


@node Vertical Scrolling
@section Vertical Fractional Scrolling
@cindex vertical fractional scrolling
@cindex vertical scroll position

   @dfn{Vertical fractional scrolling} means shifting text in a window
up or down by a specified multiple or fraction of a line.  Emacs uses
it, for example, on images and screen lines which are taller than the
window.  Each window has a @dfn{vertical scroll position}, which is a
number, never less than zero.  It specifies how far to raise the
contents of the window when displaying them.  Raising the window
contents generally makes all or part of some lines disappear off the
top, and all or part of some other lines appear at the bottom.  The
usual value is zero.

   The vertical scroll position is measured in units of the normal line
height, which is the height of the default font.  Thus, if the value is
.5, that means the window contents will be scrolled up half the normal
line height.  If it is 3.3, that means the window contents are scrolled
up somewhat over three times the normal line height.

   What fraction of a line the vertical scrolling covers, or how many
lines, depends on what the lines contain.  A value of .5 could scroll a
line whose height is very short off the screen, while a value of 3.3
could scroll just part of the way through a tall line or an image.

@defun window-vscroll &optional window pixels-p
This function returns the current vertical scroll position of
@var{window}.  The default for @var{window} is the selected window.
If @var{pixels-p} is не-@code{nil}, the return value is measured in
pixels, rather than in units of the normal line height.

@example
@group
(window-vscroll)
     @result{} 0
@end group
@end example
@end defun

@defun set-window-vscroll window lines &optional pixels-p
This function sets @var{window}'s vertical scroll position to
@var{lines}.  If @var{window} is @code{nil}, the selected window is
used.  The argument @var{lines} should be zero or positive; if not, it
is taken as zero.


The actual vertical scroll position must always correspond
to an integral number of pixels, so the value you specify
is rounded accordingly.

The return value is the result of this rounding.

@example
@group
(set-window-vscroll (selected-window) 1.2)
     @result{} 1.13
@end group
@end example

If @var{pixels-p} is не-@code{nil}, @var{lines} specifies a number of
pixels.  In this case, the return value is @var{lines}.
@end defun

@defvar auto-window-vscroll
If this variable is не-@code{nil}, the @code{line-move},
@code{scroll-up}, and @code{scroll-down} functions will automatically
modify the vertical scroll position to scroll through display rows
that are taller than the height of the window, for example in the
presence of large images.
@end defvar

@node Horizontal Scrolling
@section Horizontal Scrolling
@cindex horizontal scrolling

  @dfn{Horizontal scrolling} means shifting the image in the window left
or right by a specified multiple of the normal character width.  Each
window has a @dfn{horizontal scroll position}, which is a number, never
less than zero.  It specifies how far to shift the contents left.
Shifting the window contents left generally makes all or part of some
characters disappear off the left, and all or part of some other
characters appear at the right.  The usual value is zero.

  The horizontal scroll position is measured in units of the normal
character width, which is the width of space in the default font.  Thus,
if the value is 5, that means the window contents are scrolled left by 5
times the normal character width.  How many characters actually
disappear off to the left depends on their width, and could vary from
line to line.

  Because we read from side to side in the inner loop, and from top
to bottom in the outer loop, the effect of horizontal scrolling is
not like that of textual or vertical scrolling.  Textual scrolling
involves selection of a portion of text to display, and vertical
scrolling moves the window contents contiguously; but horizontal
scrolling causes part of @emph{each line} to go off screen.

  Usually, no horizontal scrolling is in effect; then the leftmost
column is at the left edge of the window.  In this state, scrolling to
the right is meaningless, since there is no data to the left of the edge
to be revealed by it; so this is not allowed.  Scrolling to the left is
allowed; it scrolls the first columns of text off the edge of the window
and can reveal additional columns on the right that were truncated
before.  Once a window has a nonzero amount of leftward horizontal
scrolling, you can scroll it back to the right, but only so far as to
reduce the net horizontal scroll to zero.  There is no limit to how far
left you can scroll, but eventually all the text will disappear off the
left edge.

@vindex auto-hscroll-mode
  If @code{auto-hscroll-mode} is set, redisplay automatically alters
the horizontal scrolling of a window as necessary to ensure that point
is always visible.  However, you can still set the horizontal
scrolling value explicitly.  The value you specify serves as a lower
bound for automatic scrolling, i.e., automatic scrolling will not
scroll a window to a column less than the specified one.

  The default value of @code{auto-hscroll-mode} is @code{t}; setting
it to @code{current-line} activates a variant of automatic horizontal
scrolling whereby only the line showing the cursor is horizontally
scrolled to make point visible, the rest of the window is left either
unscrolled, or at the minimum scroll amount set by @code{scroll-left}
and @code{scroll-right}, see below.

@deffn Command scroll-left &optional count set-minimum
This function scrolls the selected window @var{count} columns to the
left (or to the right if @var{count} is negative).  The default
for @var{count} is the window width, minus 2.

The return value is the total amount of leftward horizontal scrolling in
effect after the change---just like the value returned by
@code{window-hscroll} (below).

Note that text in paragraphs whose base direction is right-to-left
(@pxref{Bidirectional Display}) moves in the opposite direction: e.g.,
it moves to the right when @code{scroll-left} is invoked with a
positive value of @var{count}.

Once you scroll a window as far right as it can go, back to its normal
position where the total leftward scrolling is zero, attempts to scroll
any farther right have no effect.

If @var{set-minimum} is не-@code{nil}, the new scroll amount becomes
the lower bound for automatic scrolling; that is, automatic scrolling
will not scroll a window to a column less than the value returned by
this function.  Interactive calls pass не-@code{nil} for
@var{set-minimum}.
@end deffn

@deffn Command scroll-right &optional count set-minimum
This function scrolls the selected window @var{count} columns to the
right (or to the left if @var{count} is negative).  The default
for @var{count} is the window width, minus 2.  Aside from the direction
of scrolling, this works just like @code{scroll-left}.
@end deffn

@defun window-hscroll &optional window
This function returns the total leftward horizontal scrolling of
@var{window}---the number of columns by which the text in @var{window}
is scrolled left past the left margin.  (In right-to-left paragraphs,
the value is the total amount of the rightward scrolling instead.)
The default for @var{window} is the selected window.

The return value is never negative.  It is zero when no horizontal
scrolling has been done in @var{window} (which is usually the case).


@example
@group
(window-hscroll)
     @result{} 0
@end group
@group
(scroll-left 5)
     @result{} 5
@end group
@group
(window-hscroll)
     @result{} 5
@end group
@end example
@end defun

@defun set-window-hscroll window columns
This function sets horizontal scrolling of @var{window}.  The value of
@var{columns} specifies the amount of scrolling, in terms of columns
from the left margin (right margin in right-to-left paragraphs).  The
argument @var{columns} should be zero or positive; if not, it is taken
as zero.  Fractional values of @var{columns} are not supported at
present.

Note that @code{set-window-hscroll} may appear not to work if you test
it by evaluating a call with @kbd{M-:} in a simple way.  What happens
is that the function sets the horizontal scroll value and returns, but
then redisplay adjusts the horizontal scrolling to make point visible,
and this overrides what the function did.  You can observe the
function's effect if you call it while point is sufficiently far from
the left margin that it will remain visible.

The value returned is @var{columns}.

@example
@group
(set-window-hscroll (selected-window) 10)
     @result{} 10
@end group
@end example
@end defun

   Here is how you can determine whether a given position @var{position}
is off the screen due to horizontal scrolling:

@c FIXME: Maybe hscroll-on-screen-p is a better name?
@example
@group
(defun hscroll-on-screen (window position)
  (save-excursion
    (goto-char position)
    (and
     (>= (- (current-column) (window-hscroll window)) 0)
     (< (- (current-column) (window-hscroll window))
        (window-width window)))))
@end group
@end example


@node Coordinates and Windows
@section Coordinates and Windows
@cindex frame-relative coordinate
@cindex coordinate, relative to frame
@cindex window position

This section describes functions that report positions of and within a
window.  Most of these functions report positions relative to an origin
at the native position of the window's frame (@pxref{Frame Geometry}).
Some functions report positions relative to the origin of the display of
the window's frame.  In any case, the origin has the coordinates (0, 0)
and X and Y coordinates increase rightward and downward respectively.

  For the following functions, X and Y coordinates are reported in
integer character units, i.e., numbers of lines and columns
respectively.  On a graphical display, each ``line'' and ``column''
corresponds to the height and width of the default character specified by
the frame's default font (@pxref{Frame Font}).

@defun window-edges &optional window body absolute pixelwise
This function returns a list of the edge coordinates of @var{window}.
If @var{window} is omitted or @code{nil}, it defaults to the selected
window.

The return value has the form @code{(@var{left} @var{top} @var{right}
@var{bottom})}.  These list elements are, respectively, the X
coordinate of the leftmost column occupied by the window, the Y
coordinate of the topmost row, the X coordinate one column to the
right of the rightmost column, and the Y coordinate one row down from
the bottommost row.

Note that these are the actual outer edges of the window, including any
header line, mode line, scroll bar, fringes, window divider and display
margins.  On a text terminal, if the window has a neighbor on its right,
its right edge includes the separator line between the window and its
neighbor.

If the optional argument @var{body} is @code{nil}, this means to
return the edges corresponding to the total size of @var{window}.
@var{body} не-@code{nil} means to return the edges of @var{window}'s
body (aka text area).  If @var{body} is не-@code{nil}, @var{window}
must specify a live window.

If the optional argument @var{absolute} is @code{nil}, this means to
return edges relative to the native position of @var{window}'s frame.
@var{absolute} не-@code{nil} means to return coordinates relative to
the origin (0, 0) of @var{window}'s display.  On non-graphical systems
this argument has no effect.

If the optional argument @var{pixelwise} is @code{nil}, this means to
return the coordinates in terms of the default character width and
height of @var{window}'s frame (@pxref{Frame Font}), rounded if
necessary.  @var{pixelwise} не-@code{nil} means to return the
coordinates in pixels.  Note that the pixel specified by @var{right} and
@var{bottom} is immediately outside of these edges.  If @var{absolute}
is не-@code{nil}, @var{pixelwise} is implicitly не-@code{nil} too.
@end defun

@defun window-body-edges &optional window
This function returns the edges of @var{window}'s body (@pxref{Window
Sizes}).  Calling @code{(window-body-edges window)} is equivalent to
calling @code{(window-edges window t)}, see above.
@end defun

@comment The following two functions are confusing and hardly used.
@ignore
@defun window-left-column &optional window
This function returns the leftmost column of @var{window}.  This value
equals the @var{left} entry in the list returned by @code{(window-edges
window)} minus the number of columns occupied by the internal border of
@var{window}'s frame.
@end defun

@defun window-top-line &optional window
This function returns the topmost row of @var{window}.  This value is
equal to the @var{top} entry in the list returned by @code{(window-edges
window)} minus the number of lines occupied by the internal border of
@var{window}'s frame.
@end defun
@end ignore

  The following functions can be used to relate a set of
frame-relative coordinates to a window:

@defun window-at x y &optional frame
This function returns the live window at the coordinates @var{x} and
@var{y} given in default character sizes (@pxref{Frame Font}) relative
to the native position of @var{frame} (@pxref{Frame Geometry}).

If there is no window at that position, the return value is @code{nil}.
If @var{frame} is omitted or @code{nil}, it defaults to the selected
frame.
@end defun

@defun coordinates-in-window-p coordinates window
This function checks whether a window @var{window} occupies the frame
relative coordinates @var{coordinates}, and if so, which part of the
window that is.  @var{window} should be a live window.

@var{coordinates} should be a cons cell of the form @code{(@var{x}
. @var{y})}, where @var{x} and @var{y} are given in default character
sizes (@pxref{Frame Font}) relative to the native position of
@var{window}'s frame (@pxref{Frame Geometry}).

If there is no window at the specified position, the return value is
@code{nil} .  Otherwise, the return value is one of the following:

@table @code
@item (@var{relx} . @var{rely})
The coordinates are inside @var{window}.  The numbers @var{relx} and
@var{rely} are the equivalent window-relative coordinates for the
specified position, counting from 0 at the top left corner of the
window.

@item mode-line
The coordinates are in the mode line of @var{window}.

@item header-line
The coordinates are in the header line of @var{window}.

@item right-divider
The coordinates are in the divider separating @var{window} from a
window on the right.

@item bottom-divider
The coordinates are in the divider separating @var{window} from a
window beneath.

@item vertical-line
The coordinates are in the vertical line between @var{window} and its
neighbor to the right.  This value occurs only if the window doesn't
have a scroll bar; positions in a scroll bar are considered outside the
window for these purposes.

@item left-fringe
@itemx right-fringe
The coordinates are in the left or right fringe of the window.

@item left-margin
@itemx right-margin
The coordinates are in the left or right margin of the window.

@item nil
The coordinates are not in any part of @var{window}.
@end table

The function @code{coordinates-in-window-p} does not require a frame as
argument because it always uses the frame that @var{window} is on.
@end defun

  The following functions return window positions in pixels, rather
than character units.  Though mostly useful on graphical displays,
they can also be called on text terminals, where the screen area of
each text character is taken to be one pixel.

@defun window-pixel-edges &optional window
This function returns a list of pixel coordinates for the edges of
@var{window}.  Calling @code{(window-pixel-edges window)} is equivalent
to calling @code{(window-edges window nil nil t)}, see above.
@end defun

@comment The following two functions are confusing and hardly used.
@ignore
@defun window-pixel-left &optional window
This function returns the left pixel edge of window @var{window}.  This
value equals the @var{left} entry in the list returned by
@code{(window-pixel-edges window)} minus the number of pixels occupied
by the internal border of @var{window}'s frame.  @var{window} must be a
valid window and defaults to the selected one.
@end defun

@defun window-pixel-top &optional window
This function returns the top pixel edge of window @var{window}.  This
value is equal to the @var{top} entry in the list returned by
@code{(window-pixel-edges window)} minus the number of pixels occupied
by the internal border of @var{window}'s frame.  @var{window} must be a
valid window and defaults to the selected one.
@end defun
@end ignore

@defun window-body-pixel-edges &optional window
This function returns the pixel edges of @var{window}'s body.  Calling
@code{(window-body-pixel-edges window)} is equivalent to calling
@code{(window-edges window t nil t)}, see above.
@end defun

  The following functions return window positions in pixels, relative to
the origin of the display screen rather than that of the frame:

@defun window-absolute-pixel-edges &optional window
This function returns the pixel coordinates of @var{window} relative to
an origin at (0, 0) of the display of @var{window}'s frame.  Calling
@code{(window-absolute-pixel-edges)} is equivalent to calling
@code{(window-edges window nil t t)}, see above.
@end defun

@defun window-absolute-body-pixel-edges &optional window
This function returns the pixel coordinates of @var{window}'s body
relative to an origin at (0, 0) of the display of @var{window}'s frame.
Calling @code{(window-absolute-body-pixel-edges window)} is equivalent
to calling @code{(window-edges window t t t)}, see above.

Combined with @code{set-mouse-absolute-pixel-position}, this function
can be used to move the mouse pointer to an arbitrary buffer position
visible in some window:

@example
@group
(let ((edges (window-absolute-body-pixel-edges))
      (position (pos-visible-in-window-p nil nil t)))
  (set-mouse-absolute-pixel-position
   (+ (nth 0 edges) (nth 0 position))
   (+ (nth 1 edges) (nth 1 position))))
@end group
@end example

On a graphical terminal this form ``warps'' the mouse cursor to the
upper left corner of the glyph at the selected window's point.  A
position calculated this way can be also used to show a tooltip window
there.
@end defun

The following function returns the screen coordinates of a buffer
position visible in a window:

@defun window-absolute-pixel-position &optional position window
If the buffer position @var{position} is visible in window @var{window},
this function returns the display coordinates of the upper/left corner
of the glyph at @var{position}.  The return value is a cons of the X-
and Y-coordinates of that corner, relative to an origin at (0, 0) of
@var{window}'s display.  It returns @code{nil} if @var{position} is not
visible in @var{window}.

@var{window} must be a live window and defaults to the selected
window.  @var{position} defaults to the value of @code{window-point}
of @var{window}.

This means that in order to move the mouse pointer to the position of
point in the selected window, it's sufficient to write:

@example
@group
(let ((position (window-absolute-pixel-position)))
  (set-mouse-absolute-pixel-position
   (car position) (cdr position)))
@end group
@end example
@end defun

The following function returns the largest rectangle that can be
inscribed in a window without covering text displayed in that window.

@defun window-largest-empty-rectangle &optional window count min-width min-height positions left
This function calculates the dimensions of the largest empty rectangle
that can be inscribed in the specified @var{window}'s text area.
@var{window} must be a live window and defaults to the selected one.

The return value is a triple of the width and the start and end
y-coordinates of the largest rectangle that can be inscribed into the
empty space (space not displaying any text) of the text area of
@var{window}.  No x-coordinates are returned by this function---any such
rectangle is assumed to end at the right edge of @var{window}'s text
area.  If no empty space can be found, the return value is @code{nil}.

The optional argument @var{count}, if не-@code{nil}, specifies a
maximum number of rectangles to return.  This means that the return
value is a list of triples specifying rectangles with the largest
rectangle first.  @var{count} can be also a cons cell whose car
specifies the number of rectangles to return and whose @sc{cdr}, if
не-@code{nil}, states that all rectangles returned must be disjoint.

The optional arguments @var{min-width} and @var{min-height}, if
не-@code{nil}, specify the minimum width and height of any rectangle
returned.

The optional argument @var{positions}, if не-@code{nil}, is a cons cell
whose @sc{car} specifies the uppermost and whose @sc{cdr} specifies the
lowermost pixel position that must be covered by any rectangle returned.
These positions measure from the start of the text area of @var{window}.

The optional argument @var{left}, if не-@code{nil}, means to return
values suitable for buffers displaying right to left text.  In that
case, any rectangle returned is assumed to start at the left edge of
@var{window}'s text area.

Note that this function has to retrieve the dimensions of each line of
@var{window}'s glyph matrix via @code{window-lines-pixel-dimensions}
(@pxref{Size of Displayed Text}).  Hence, this function may also return
@code{nil} when the current glyph matrix of @var{window} is not
up-to-date.
@end defun


@node Mouse Window Auto-selection
@section Mouse Window Auto-selection
@cindex window auto-selection
@cindex auto-selection of window
The following option allows to automatically select the window under the
mouse pointer.  This accomplishes a policy similar to that of window
managers that give focus to a frame (and thus trigger its subsequent
selection) whenever the mouse pointer enters its window-system window
(@pxref{Input Focus}).

@defopt mouse-autoselect-window
If this variable is не-@code{nil}, Emacs will try to automatically
select the window under the mouse pointer.  The following values are
meaningful:

@table @asis
@item A positive number
This specifies a delay in seconds after which auto-selection triggers.
The window under the mouse pointer is selected after the mouse has
remained in it for the entire duration of the delay.

@item A negative number
A negative number has a similar effect as a positive number, but selects
the window under the mouse pointer only after the mouse pointer has
remained in it for the entire duration of the absolute value of that
number and in addition has stopped moving.

@item Other value
Any other не-@code{nil} value means to select a window instantaneously
as soon as the mouse pointer enters it.
@end table

In either case, the mouse pointer must enter the text area of a window in
order to trigger its selection.  Dragging the scroll bar slider or the
mode line of a window conceptually should not cause its auto-selection.

Mouse auto-selection selects the minibuffer window only if it is active,
and never deselects the active minibuffer window.
@end defopt

Mouse auto-selection can be used to emulate a focus follows mouse policy
for child frames (@pxref{Child Frames}) which usually are not tracked by
the window manager.  This requires to set the value of
@code{focus-follows-mouse} (@pxref{Input Focus}) to a не-@code{nil}
value.  If the value of @code{focus-follows-mouse} is @code{auto-raise},
entering a child frame with the mouse will raise it automatically above
all other child frames of that frame's parent frame.


@node Window Configurations
@section Window Configurations
@cindex window configurations
@cindex saving window information

A @dfn{window configuration} records the entire layout of one
frame---all windows, their sizes, which buffers they contain, how those
buffers are scrolled, and their value of point; also their
fringes, margins, and scroll bar settings.  It also includes the value
of @code{minibuffer-scroll-window}.  As a special exception, the window
configuration does not record the value of point in the selected window
for the current buffer.

  You can bring back an entire frame layout by restoring a previously
saved window configuration.  If you want to record the layout of all
frames instead of just one, use a frame configuration instead of a
window configuration.  @xref{Frame Configurations}.

@defun current-window-configuration &optional frame
This function returns a new object representing @var{frame}'s current
window configuration.  The default for @var{frame} is the selected
frame.  The variable @code{window-persistent-parameters} specifies
which window parameters (if any) are saved by this function.
@xref{Window Parameters}.
@end defun

@defun set-window-configuration configuration
This function restores the configuration of windows and buffers as
specified by @var{configuration}, for the frame that @var{configuration}
was created for.

The argument @var{configuration} must be a value that was previously
returned by @code{current-window-configuration}.  The configuration is
restored in the frame from which @var{configuration} was made, whether
that frame is selected or not.  In some rare cases this may trigger
execution of the @code{window-size-change-functions} (@pxref{Window
Hooks}) even if the size of windows did not change at all.  The
@code{window-configuration-change-hook} functions will be called if and
only if at least one window was added to or deleted from the frame.

If the frame from which @var{configuration} was saved is dead, all this
function does is restore the three variables @code{window-min-height},
@code{window-min-width} and @code{minibuffer-scroll-window}.  In this
case, the function returns @code{nil}.  Otherwise, it returns @code{t}.

Here is a way of using this function to get the same effect
as @code{save-window-excursion}:

@example
@group
(let ((config (current-window-configuration)))
  (unwind-protect
      (progn (split-window-below nil)
             @dots{})
    (set-window-configuration config)))
@end group
@end example
@end defun

@defmac save-window-excursion forms@dots{}
This macro records the window configuration of the selected frame,
executes @var{forms} in sequence, then restores the earlier window
configuration.  The return value is the value of the final form in
@var{forms}.

Most Lisp code should not use this macro; @code{save-selected-window}
is typically sufficient.  In particular, this macro cannot reliably
prevent the code in @var{forms} from opening new windows, because new
windows might be opened in other frames (@pxref{Choosing Window}), and
@code{save-window-excursion} only saves and restores the window
configuration on the current frame.

Do not use this macro in @code{window-size-change-functions}; exiting
the macro triggers execution of @code{window-size-change-functions},
leading to an endless loop.
@end defmac

@defun window-configuration-p object
This function returns @code{t} if @var{object} is a window configuration.
@end defun

@defun compare-window-configurations config1 config2
This function compares two window configurations as regards the
structure of windows, but ignores the values of point and the
saved scrolling positions---it can return @code{t} even if those
aspects differ.

The function @code{equal} can also compare two window configurations; it
regards configurations as unequal if they differ in any respect, even a
saved point.
@end defun

@defun window-configuration-frame config
This function returns the frame for which the window configuration
@var{config} was made.
@end defun

  Other primitives to look inside of window configurations would make
sense, but are not implemented because we did not need them.  See the
file @file{winner.el} for some more operations on windows
configurations.

  The objects returned by @code{current-window-configuration} die
together with the Emacs process.  In order to store a window
configuration on disk and read it back in another Emacs session, you
can use the functions described next.  These functions are also useful
to clone the state of a frame into an arbitrary live window
(@code{set-window-configuration} effectively clones the windows of a
frame into the root window of that very frame only).

@cindex window state
@defun window-state-get &optional window writable
This function returns the state of @var{window} as a Lisp object.  The
argument @var{window} must be a valid window and defaults to the root
window of the selected frame.

If the optional argument @var{writable} is не-@code{nil}, this means to
not use markers for sampling positions like @code{window-point} or
@code{window-start}.  This argument should be не-@code{nil} when the
state will be written to disk and read back in another session.

Together, the argument @var{writable} and the variable
@code{window-persistent-parameters} specify which window parameters are
saved by this function.  @xref{Window Parameters}.
@end defun

The value returned by @code{window-state-get} can be used in the same
session to make a clone of a window in another window.  It can be also
written to disk and read back in another session.  In either case, use
the following function to restore the state of the window.

@defun window-state-put state &optional window ignore
This function puts the window state @var{state} into @var{window}.
The argument @var{state} should be the state of a window returned by
an earlier invocation of @code{window-state-get}, see above.  The
optional argument @var{window} can be either a live window or an
internal window (@pxref{Windows and Frames}) and defaults to the
selected one.  If @var{window} is not live, it is replaced by a live
window before putting @var{state} into it.

If the optional argument @var{ignore} is не-@code{nil}, it means to ignore
minimum window sizes and fixed-size restrictions.  If @var{ignore}
is @code{safe}, this means windows can get as small as one line
and/or two columns.
@end defun

The functions @code{window-state-get} and @code{window-state-put} also
allow to exchange the contents of two live windows.  The following
function does precisely that:

@deffn Command window-swap-states &optional window-1 window-2 size
This command swaps the states of the two live windows @var{window-1} and
@var{window-2}.  @var{window-1} must specify a live window and defaults
to the selected one.  @var{window-2} must specify a live window and
defaults to the window following @var{window-1} in the cyclic ordering
of windows, excluding minibuffer windows and including live windows on
all visible frames.

Optional argument @var{size} не-@code{nil} means to try swapping the
sizes of @var{window-1} and @var{window-2} as well.  A value of
@code{height} means to swap heights only, a value of @code{width}
means to swap widths only, while @code{t} means to swap both widths
and heights, if possible.  Frames are not resized by this function.
@end deffn


@node Window Parameters
@section Window Parameters
@cindex window parameters

This section describes the window parameters that can be used to
associate additional information with windows.

@defun window-parameter window parameter
This function returns @var{window}'s value for @var{parameter}.  The
default for @var{window} is the selected window.  If @var{window} has no
setting for @var{parameter}, this function returns @code{nil}.
@end defun

@defun window-parameters &optional window
This function returns all parameters of @var{window} and their values.
The default for @var{window} is the selected window.  The return value
is either @code{nil}, or an association list whose elements have the form
@code{(@var{parameter} . @var{value})}.
@end defun

@defun set-window-parameter window parameter value
This function sets @var{window}'s value of @var{parameter} to
@var{value} and returns @var{value}.  The default for @var{window}
is the selected window.
@end defun

By default, the functions that save and restore window configurations or the
states of windows (@pxref{Window Configurations}) do not care about
window parameters.  This means that when you change the value of a
parameter within the body of a @code{save-window-excursion}, the
previous value is not restored when that macro exits.  It also means
that when you restore via @code{window-state-put} a window state saved
earlier by @code{window-state-get}, all cloned windows have their
parameters reset to @code{nil}.  The following variable allows you to
override the standard behavior:

@cindex persistent window parameters
@defvar window-persistent-parameters
This variable is an alist specifying which parameters get saved by
@code{current-window-configuration} and @code{window-state-get}, and
subsequently restored by @code{set-window-configuration} and
@code{window-state-put}.  @xref{Window Configurations}.

The @sc{car} of each entry of this alist is a symbol specifying the
parameter.  The @sc{cdr} should be one of the following:

@table @asis
@item @code{nil}
This value means the parameter is saved neither by
@code{window-state-get} nor by @code{current-window-configuration}.

@item @code{t}
This value specifies that the parameter is saved by
@code{current-window-configuration} and (provided its @var{writable}
argument is @code{nil}) by @code{window-state-get}.

@item @code{writable}
This means that the parameter is saved unconditionally by both
@code{current-window-configuration} and @code{window-state-get}.  This
value should not be used for parameters whose values do not have a read
syntax.  Otherwise, invoking @code{window-state-put} in another session
may fail with an @code{invalid-read-syntax} error.
@end table
@end defvar

Some functions (notably @code{delete-window},
@code{delete-other-windows} and @code{split-window}), may behave
specially when the window specified by their @var{window} argument has
a parameter whose name is equal to the function's name.  You can
override such special behavior by binding the following variable to a
не-@code{nil} value:

@defvar ignore-window-parameters
If this variable is не-@code{nil}, some standard functions do not
process window parameters.  The functions currently affected by this are
@code{split-window}, @code{delete-window}, @code{delete-other-windows},
and @code{other-window}.

An application can bind this variable to a не-@code{nil} value around
calls to these functions.  If it does so, the application is fully
responsible for correctly assigning the parameters of all involved
windows when exiting that function.
@end defvar

The following parameters are currently used by the window management
code:

@table @code
@item delete-window
@vindex delete-window@r{, a window parameter}
This parameter affects the execution of @code{delete-window}
(@pxref{Deleting Windows}).

@item delete-other-windows
@vindex delete-other-windows@r{, a window parameter}
This parameter affects the execution of @code{delete-other-windows}
(@pxref{Deleting Windows}).

@item no-delete-other-windows
@vindex no-delete-other-windows@r{, a window parameter}
This parameter marks the window as not deletable by
@code{delete-other-windows} (@pxref{Deleting Windows}).

@item split-window
@vindex split-window@r{, a window parameter}
This parameter affects the execution of @code{split-window}
(@pxref{Splitting Windows}).

@item other-window
@vindex other-window@r{, a window parameter}
This parameter affects the execution of @code{other-window}
(@pxref{Cyclic Window Ordering}).

@item no-other-window
@vindex no-other-window@r{, a window parameter}
This parameter marks the window as not selectable by @code{other-window}
(@pxref{Cyclic Window Ordering}).

@item clone-of
@vindex clone-of@r{, a window parameter}
This parameter specifies the window that this one has been cloned
from.  It is installed by @code{window-state-get} (@pxref{Window
Configurations}).

@item window-preserved-size
@vindex window-preserved-size@r{, a window parameter}
This parameter specifies a buffer, a direction where @code{nil} means
vertical and @code{t} horizontal, and a size in pixels.  If this window
displays the specified buffer and its size in the indicated direction
equals the size specified by this parameter, then Emacs will try to
preserve the size of this window in the indicated direction.  This
parameter is installed and updated by the function
@code{window-preserve-size} (@pxref{Preserving Window Sizes}).

@item quit-restore
@vindex quit-restore@r{, a window parameter}
This parameter is installed by the buffer display functions
(@pxref{Choosing Window}) and consulted by @code{quit-restore-window}
(@pxref{Quitting Windows}).  It is a list of four elements, see the
description of @code{quit-restore-window} in @ref{Quitting Windows}
for details.

@item window-side
@itemx window-slot
@vindex window-side@r{, a window parameter}
@vindex window-slot@r{, a window parameter}
These parameters are used internally for implementing side windows
(@pxref{Side Windows}).

@item window-atom
@vindex window-atom@r{, a window parameter}
This parameter is used internally for implementing atomic windows, see
@ref{Atomic Windows}.

@item mode-line-format
@vindex mode-line-format@r{, a window parameter}
This parameter replaces the value of the buffer-local variable
@code{mode-line-format} (@pxref{Mode Line Basics}) of this window's
buffer whenever this window is displayed.  The symbol @code{none} means
to suppress display of a mode line for this window.  Display and
contents of the mode line on other windows showing this buffer are not
affected.

@item header-line-format
@vindex header-line-format@r{, a window parameter}
This parameter replaces the value of the buffer-local variable
@code{header-line-format} (@pxref{Mode Line Basics}) of this window's
buffer whenever this window is displayed.  The symbol @code{none} means
to suppress display of a header line for this window.  Display and
contents of the header line on other windows showing this buffer are not
affected.

@item min-margins
@vindex min-margins@r{, a window parameter}
The value of this parameter is a cons cell whose @sc{car} and
@sc{cdr}, if не-@code{nil}, specify the minimum values (in columns)
for the left and right margin of this window (@pxref{Display Margins}.
When present, Emacs will use these values instead of the actual margin
widths for determining whether a window can be split or shrunk
horizontally.

Emacs never auto-adjusts the margins of any window after splitting or
resizing it.  It is the sole responsibility of any application setting
this parameter to adjust the margins of this window as well as those of
any new window that inherits this window's margins due to a split.
Both @code{window-configuration-change-hook} and
@code{window-size-change-functions} (@pxref{Window Hooks}) should be
employed for this purpose.

This parameter was introduced in Emacs version 25.1 to support
applications that use large margins to center buffer text within a
window and should be used, with due care, exclusively by those
applications.  It might be replaced by an improved solution in future
versions of Emacs.
@end table

@node Window Hooks
@section Hooks for Window Scrolling and Changes
@cindex hooks for window operations

This section describes how a Lisp program can take action whenever a
window displays a different part of its buffer or a different buffer.
There are three actions that can change this: scrolling the window,
switching buffers in the window, and changing the size of the window.
The first two actions run @code{window-scroll-functions}; the last runs
@code{window-size-change-functions}.

@defvar window-scroll-functions
This variable holds a list of functions that Emacs should call before
redisplaying a window with scrolling.  Displaying a different buffer in
the window also runs these functions.

This variable is not a normal hook, because each function is called with
two arguments: the window, and its new display-start position.  At the
time of the call, the display-start position of the window argument is
already set to its new value, and the buffer to be displayed in the
window is already set as the current buffer.

These functions must take care when using @code{window-end}
(@pxref{Window Start and End}); if you need an up-to-date value, you
must use the @var{update} argument to ensure you get it.

@strong{Warning:} don't use this feature to alter the way the window
is scrolled.  It's not designed for that, and such use probably won't
work.
@end defvar

@defun run-window-scroll-functions &optional window
This function calls @code{window-scroll-functions} for the specified
@var{window}, which defaults to the selected window.
@end defun

@defvar window-size-change-functions
This variable holds a list of functions to be called if the size of any
window changes for any reason.  The functions are called once per
redisplay, and once for each frame on which size changes have occurred.

Each function receives the frame as its sole argument.  To find out
whether a specific window has changed size, compare the return values of
@code{window-pixel-width-before-size-change} and
@code{window-pixel-width} respectively
@code{window-pixel-height-before-size-change} and
@code{window-pixel-height} for that window (@pxref{Window Sizes}).

These function are usually only called when at least one window was
added or has changed size since the last time this hook was run for
the associated frame.  In some rare cases this hook also runs when a
window that was added intermittently has been deleted afterwards.  In
these cases none of the windows on the frame will appear to have
changed its size.
@end defvar

@defvar window-configuration-change-hook
A normal hook that is run every time the window configuration of a
frame changes.  Window configuration changes include splitting and
deleting windows, and the display of a different buffer in a window.

The hook can be also used for tracking changes of window sizes.  It
is, however, not run when the size of a frame changes or automatic
resizing of a minibuffer window (@pxref{Minibuffer Windows}) changes
the size of another window.  As a rule, adding a function to
@code{window-size-change-functions}, see above, is the recommended way
for reliably tracking size changes of any window.

The buffer-local value of this hook is run once for each window on the
affected frame, with the relevant window selected and its buffer
current.  The global value of this hook is run once for the modified
frame, with that frame selected.
@end defvar

@defun run-window-configuration-change-hook &optional frame
This function runs @code{window-configuration-change-hook} for the
specified @var{frame}, which defaults to the selected frame.
@end defun

  In addition, you can use @code{jit-lock-register} to register a Font
Lock fontification function, which will be called whenever parts of a
buffer are (re)fontified because a window was scrolled or its size
changed.  @xref{Other Font Lock Variables}.
