@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2019 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Windows
@chapter Окна

В этой главе описаны функции и переменные, относящиеся к окнам Emacs.
@xref{Frames}, о том, как окнам назначается область экрана, доступная для
использования Emacs.  @xref{Display}, чтобы узнать, как текст отображается
в окнах.

@menu
* Basic Windows::           Основная информация об использовании окон.
* Windows and Frames::      Связь окон с фреймом, на котором они появляются.
* Window Sizes::            Доступ к размеру окна.
* Resizing Windows::        Изменение размеров окон.
* Preserving Window Sizes:: Сохранение размеров окон.
* Splitting Windows::       Создание нового окна.
* Deleting Windows::        Удаление окна из рамы.
* Recombining Windows::     Сохранение макета фрейма при разделении
                               и удалении окон.
* Selecting Windows::      Выбранное окно - это то, в которое редактируется.
* Cyclic Window Ordering::  Перемещение по существующим окнам.
* Buffers and Windows::     В каждом окне отображается содержимое буфера.
* Switching Buffers::       Функции более высокого уровня для
                               переключения на буфер.
* Displaying Buffers::      Отображение буфера в подходящем окне.
* Window History::         Каждое окно запоминает отображаемые в нем буферы.
* Dedicated Windows::       Как избежать отображения другого буфера
                               в определенном окне.
* Quitting Windows::        Как восстановить состояние до отображения
                               буфера.
* Side Windows::            Специальные окна по бокам рамки.
* Atomic Windows::          Сохранение частей макета окна.
* Window Point::            Каждое окно имеет собственное расположение
                               точки.
* Window Start and End::    Позиции буфера, указывающие, какой текст
                               отображается на экране в окне.
* Textual Scrolling::       Перемещение текста вверх и вниз по окну.
* Vertical Scrolling::      Перемещение содержимого вверх и вниз по окну.
* Horizontal Scrolling::    Перемещение содержимого в окне горизонтально.
* Coordinates and Windows:: Преобразование координат в окна.
* Mouse Window Auto-selection:: Автоматическое выделение окон мышкой.
* Window Configurations::   Сохранение и восстановление состояния экрана.
* Window Parameters::       Связывание дополнительной информации с окнами.
* Window Hooks::            Ловушки для прокрутки, изменения размера окна,
                               повторного отображения после определенной
                               точки или изменения конфигурации окна.
@end menu


@node Basic Windows
@section Основные Концепции Окон Emacs
@cindex window

@dfn{Окно} - это область экрана, которая используется для отображения буфера
(@pxref{Buffers}).  В Emacs Lisp окна представлены особым типом объекта
Lisp.

@cindex multiple windows
  Окна сгруппированы в рамки (@pxref{Frames}).  Каждый фрейм содержит как
минимум одно окно; пользователь может разделить его на несколько
неперекрывающихся окон для одновременного просмотра нескольких буферов.
Программы Lisp могут использовать несколько окон для различных целей.  В
Rmail, например, можно просматривать сводку заголовков сообщений в одном
окне и содержимое выбранного сообщения в другом окне.

@cindex terminal screen
@cindex screen of terminal
  Emacs использует слово ``окно'' в другом значении, чем в графических
средах рабочего стола и оконных системах, таких как X Window System.  Когда
Emacs запущен в X, каждое из его графических X-окон является фреймом Emacs
(содержащим одно или несколько окон Emacs).  Когда Emacs запускается на
текстовом терминале, фрейм заполняет весь экран терминала.

@cindex tiled windows
  В отличие от окон X, окна Emacs имеют формат @dfn{выложенный плиткой}; они
никогда не перекрываются в пределах области фрейма.  Когда окно создается,
удаляется или изменяется его размер, оконное пространство берется из
соседних окон или передается им, так что общая площадь фрейма остается
неизменной.

@defun windowp object
Функция возвращает @code{t}, если @var{object} является окном (независимо от
того, отображает оно буфер или нет).  В противном случае возвращается
@code{nil}.
@end defun

@cindex live windows
@dfn{Активное окно} - это то, которое фактически отображает буфер в фрейме.

@defun window-live-p object
Функция возвращает @code{t}, если @var{object} является активным окном, и
@code{nil} в противном случае. Активное окно - это окно, в котором
отображается буфер.
@end defun

@cindex internal windows
Окна в каждом фрейме организованы в @dfn{дереве окон}.
@xref{Windows and Frames}.  Листовые узлы каждого дерева окон являются
активными окнами - фактически отображающими буферы.  Внутренние узлы дерева
окон - @dfn{внутренние окна}, которые не являются активными.

@cindex valid windows
   @dfn{Действительное окно} - это активное или внутреннее.  Действительное
окно может быть @dfn{удаленным}, то есть удалено из его кадра
(@pxref{Deleting Windows}), тогда оно больше не является действительным, но
объект Lisp, представляющий его, может по-прежнему ссылаться на другие
объекты Lisp.  Удаленное окно можно снова сделать действительным,
восстановив сохраненную конфигурацию окна (@pxref{Window Configurations}).

   Можно отличить действительные окна от удаленных с помощью
@code{window-valid-p}.

@defun window-valid-p object
Функция возвращает @code{t}, если @var{object} - активное окно, или
внутреннее окно в дереве окон.  В противном случае возвращается @code{nil},
в том числе для случая, когда @var{object} - удаленное окно.
@end defun

@cindex selected window
@cindex window selected within a frame
  В каждом кадре в любое время ровно одно окно Emacs обозначается как
@dfn{выбраное в кадре}.  Для выбранного фрейма это окно называется
@dfn{выбранное окно} - то, в котором происходит большая часть
редактирования, и в котором отображается курсор для выбранных окон
(@pxref{Cursor Parameters}).  Клавиатурный ввод, который вставляет или
удаляет текст, также обычно направляется в это окно.  Буфер выбранного окна
обычно также является текущим буфером, за исключением случая, когда
используется @code{set-buffer} (@pxref{Current Buffer}).  Что касается
невыбранных фреймов, окно, выбранное в фрейме, становится выбранным окном,
если фрейм когда-либо был выбран.  @xref{Selecting Windows}.

@defun selected-window
Функция возвращает выбранное окно (которое всегда является активным окном).
@end defun

@anchor{Window Group}Иногда несколько окон вместе и совместно отображают
буфер, например, под управлением режима следования
(@pxref{Follow Mode,,, emacs}), где окна вместе отображают большую часть
буфера, чем одно окно могло бы в одиночку.  Часто бывает полезно
рассматривать такую @dfn{оконную группу} как единый объект.  Некоторые
функции, такие как @code{window-group-start} (@pxref{Window Start and End}),
позволяют сделать это, задавая в качестве аргумента одно из окон в качестве
замены для всей группы.

@defun selected-window-group
@vindex selected-window-group-function
Когда выбранное окно является членом группы окон, эта функция возвращает
список окон в группе, упорядоченный так, чтобы первое окно в списке
отображало самую раннюю часть буфера, и так далее.  В противном случае
функция возвращает список, содержащий только выбранное окно.

Выбранное окно считается частью группы, если локальная переменная буфера
@code{selected-window-group-function} указывает на функцию.  В этом случае
@code{selected-window-group} вызывает её без аргументов и возвращает
результат (который должен быть списком окон в группе).
@end defun

@node Windows and Frames
@section Окна и Фреймы

Каждое окно принадлежит ровно одному фрейму (@pxref{Frames}).

@defun window-frame &optional window
Функция возвращает фрейм, которому принадлежит окно @var{window}.  Если
@var{window} равен @code{nil}, по умолчанию используется выбранное окно.
@end defun

@defun window-list &optional frame minibuffer window
Функция возвращает список активных окон, принадлежащих фрейму @var{frame}.
Если @var{frame} опущен или @code{nil}, по умолчанию используется выбранный
фрейм.

Необязательный аргумент @var{minibuffer} указывает, нужно ли включать окно
минибуфера в возвращаемый список.  Если @var{minibuffer} равен @code{t},
включается окно минибуфера.  Если @var{minibuffer} равен @code{nil} или не
указан, окно минибуфера включается, только если оно активно.  Если
@var{minibuffer} не является ни @code{nil}, ни @code{t}, окно минибуфера
никогда не включается.

Необязательный аргумент @var{window}, если не-@code{nil}, должен быть
активным окном в указанном фрейме; тогда @var{window} будет первым элементом
в возвращаемом списке.  Если @var{window} опущено или @code{nil}, окно,
выбранное в фрейме, является первым элементом.
@end defun

@cindex window tree
@cindex root window
  Окна в том же фрейме организованы в @dfn{оконное дерево}, конечными узлами
которого являются активные окна.  Внутренние узлы оконного дерева не
используются; они существуют с целью организации отношений между активными
окнами.  Корневой узел дерева окон называется @dfn{оконным корнем}.  Это
может быть либо активное окно (если в фрейме только одно окно), либо
внутреннее окно.

  Окно минибуфера (@pxref{Minibuffer Windows}), которое находится не только
в своем фрейме, не имеет родительского окна, поэтому, строго говоря, оно не
является частью дерева окон своего фрейма.  Тем не менее, это одноуровневое
окно корневого окна фрейма, и, таким образом, к нему можно получить доступ
через @code{window-next-sibling}.  Кроме того, функция @code{window-tree},
описанная в конце этого раздела, перечисляет окно минибуфера вместе с
фактическим деревом окон.

@defun frame-root-window &optional frame-or-window
Функция возвращает корневое окно для @var{frame-or-window}.  Аргумент
@var{frame-or-window} должен быть окном или фреймом; если опущен или
@code{nil}, по умолчанию используется выбранный фрейм.  Если
@var{frame-or-window} - это окно, возвращаемое значение - это корневое окно
фрейма этого окна.
@end defun

@cindex parent window
@cindex child window
@cindex sibling window
  Когда окно разделено, появляются два активных окна там, где раньше было
одно.  Одно из них представлено тем же объектом окна Lisp, что и исходное
окно, а другое - вновь созданное объектом окна Lisp.  Оба этих активных
окна становятся листовыми узлами дерева окон, как @dfn{дочерние окна} одного
внутреннего окна.  При необходимости Emacs автоматически создает это
внутреннее окно, которое также называется @dfn{родительское окно}, и
присваивает ему соответствующую позицию в дереве окон.  Набор окон с одним и
тем же родителем называется @dfn{потомками}.

@cindex parent window
@defun window-parent &optional window
Функция возвращает родительское окно @var{window}.  Если @var{window} не
указано или @code{nil}, по умолчанию используется выбранное окно.
Возвращаемое значение - @code{nil}, если @var{window} не имеет родителя
(то есть это окно минибуфера или корневое окно его фрейма).
@end defun

  Каждое внутреннее окно всегда имеет как минимум два дочерних окна.  Если
это число падает до единицы в результате удаления окна, Emacs автоматически
удаляет внутреннее окно, и его единственное оставшееся дочернее окно
занимает свое место в дереве окон.

  Каждое дочернее окно может быть либо активным окном, либо внутренним окном
(которое, в свою очередь, будет иметь свои собственные дочерние окна).
Следовательно, каждое внутреннее окно можно представить себе как занимающее
определенный прямоугольный @dfn{область экрана} - объединение областей,
занятых окнами реального времени, которые в конечном итоге происходят от
него.

@cindex window combination
@cindex vertical combination
@cindex horizontal combination
  Для каждого внутреннего окна области экрана непосредственных дочерних
элементов располагаются либо вертикально, либо горизонтально (но не
одновременно).  Если дочерние окна расположены одно над другим, говорится,
что они образуют @dfn{вертикальное сочетание}; если расположены бок о бок,
говорится, что они образуют @dfn{горизонтальное сочетание}.  Рассмотрим
следующий пример:

@smallexample
@group
     ______________________________________
    | ______  ____________________________ |
    ||      || __________________________ ||
    ||      |||                          |||
    ||      |||                          |||
    ||      |||                          |||
    ||      |||____________W4____________|||
    ||      || __________________________ ||
    ||      |||                          |||
    ||      |||                          |||
    ||      |||____________W5____________|||
    ||__W2__||_____________W3_____________ |
    |__________________W1__________________|

@end group
@end smallexample

@noindent
Корневым окном этого фрейма является внутреннее окно @var{W1}.  Его дочерние
окна образуют горизонтальную комбинацию, состоящую из активных окон
изображения @var{W2} и внутреннего окна @var{W3}.  Дочерние окна @var{W3}
образуют вертикальную комбинацию, состоящую из активных окон @var{W4} и
@var{W5}.  Следовательно, активные окна в этом дереве окон - @var{W2},
@var{W4}, и @var{W5}.

  Следующие функции могут использоваться для получения дочернего окна
внутреннего окна и одноуровневых элементов дочернего окна.

@defun window-top-child &optional window
Функция возвращает самое верхнее дочернее окно @var{window}, если
@var{window} - внутреннее окно, дочерние элементы которого образуют
вертикальную комбинацию.  Для любого другого типа окна возвращаемое
значение - @code{nil}.
@end defun

@defun window-left-child &optional window
Функция возвращает самое левое дочернее окно @var{window}, если @var{window}
- внутреннее окно, дочерние элементы которого образуют горизонтальную
комбинацию.  Для любого другого типа окна возвращаемое значение -
@code{nil}.
@end defun

@defun window-child window
Функция возвращает первое дочернее окно внутреннего окна @var{window} ---
самое верхнее дочернее окно для вертикальной комбинации или самое левое
дочернее окно для горизонтальной комбинации.  Если @var{window} является
активным окном, возвращаемое значение - @code{nil}.
@end defun

@defun window-combined-p &optional window horizontal
Функция возвращает значение не-@code{nil} тогда и только тогда, когда
@var{window} является частью вертикальной комбинации.  Если @var{window}
опущено или @code{nil}, по умолчанию используется выбранное окно.

Если необязательный аргумент @var{horizontal} - не-@code{nil}, это означает
возвращение не-@code{nil} тогда и только тогда, когда @var{window} является
частью горизонтальной комбинации.
@end defun

@defun window-next-sibling &optional window
Функция возвращает следующего брата окна @var{window}.  Если опущено или
@code{nil}, @var{window} по умолчанию используется в выбранном окне.
Возвращаемое значение - @code{nil}, если @var{window} - последний дочерний
элемент своего родителя.
@end defun

@defun window-prev-sibling &optional window
Функция возвращает предыдущего брата окна @var{window}.  Если опущено, или
@code{nil}, @var{window} по умолчанию используется в выбранном окне.
Возвращаемое значение - @code{nil}, если @var{window} является первым
потомком своего родителя.
@end defun

Функции @code{window-next-sibling} и @code{window-prev-sibling} не следует
путать с функциями @code{next-window} и @code{previous-window}, которые
возвращают следующее и предыдущее окно, соответственно, в циклическом
порядке окон (@pxref{Cyclic Window Ordering}).

  Следующие функции могут быть полезны для нахождения окна внутри его
фрейма.

@defun frame-first-window &optional frame-or-window
Функция возвращает окно реального времени в верхнем левом углу кадра,
заданного @var{frame-or-window}.  Аргумент @var{frame-or-window} должен
обозначать окно или активный фрейм и по умолчанию использовать выбранный
фрейм.  Если @var{frame-or-window} указывает окно, эта функция возвращает
первое окно во фрейме этого окна.  При условии, что кадр из нашего
канонического примера выбран @code{(frame-first-window)}, возвращает
@var{W2}.
@end defun

@defun window-at-side-p &optional window side
Функция возвращает @code{t}, если @var{window} находится в @var{side}
содержащего его фоейма.  Аргумент @var{window} должен быть действительным
окном и по умолчанию выбранным.  Аргумент @var{side} может быть любой из
символов @code{left}, @code{top}, @code{right} или @code{bottom}.  Значение
по умолчанию @code{nil} обрабатывается как @code{bottom}.

Обратить внимание, что эта функция игнорирует окно минибуфера
(@pxref{Minibuffer Windows}).  Следовательно, если @var{side} равно
@code{bottom}, может возвращаться @code{t} также, когда окно минибуфера
появляется прямо под @var{window}.
@end defun

@cindex window in direction
@defun window-in-direction direction &optional window ignore sign wrap mini
Функция возвращает ближайшее окно реального времени в направлении
@var{direction}, если смотреть с позиции @code{window-point} в окне
@var{window}.  Аргумент @var{direction} должен быть одним из @code{above},
@code{below}, @code{left} или @code{right}.  Необязательный аргумент
@var{window} должен обозначать активное окно и по умолчанию использовать
выбранное.

Функция не возвращает окно, если параметр @code{no-other-window} которого
равен не-@code{nil} (@pxref{Window Parameters}).  Если параметр
@code{no-other-window} ближайшего окна равен не-@code{nil}, эта функция
пытается найти другое окно в указанном направлении, параметр
@code{no-other-window} которого равен @code{nil}.  Если необязательный
аргумент @var{ignore} - не-@code{nil}, окно может быть возвращено, даже если
его параметр @code{no-other-window} - не-@code{nil}.

Если необязательный аргумент @var{sign} - отрицательное число, это означает
использование правого или нижнего края @var{window} в качестве ссылочной
позиции вместо @code{window-point}.  Если @var{sign} является положительным
числом, то это значит использовать левый или верхний край @var{window} в
качестве опорной позиции.

Если необязательный аргумент @var{wrap} - не-@code{nil}, это означает, что
@var{direction} нужно обернуть вокруг границ фрейма.  Например, если
@var{window} находится вверху фрейма, а @var{direction} - @code{above}, то
функция обычно возвращает окно минибуфера фрейма, если оно активно, и
окно внизу фрейма в противном случае.

Если необязательный аргумент @var{mini} - @code{nil}, это означает, что окно
минибуфера должно возвращаться тогда и только тогда, когда оно активно в
данный момент.  Если @var{mini} равен не-@code{nil}, эта функция может
вернуть окно минибуфера, даже если оно не активно. Однако, если @var{wrap}
равен не-@code{nil}, всегда действует так, как если бы @var{mini} было
установлено в @code{nil}.

Если подходящего окна не найдено, функция возвращает @code{nil}.

Не использовать эту функцию для проверки наличия окна @emph{не} в
@var{direction}.  Вызов @code{window-at-side-p}, описанный выше, - гораздо
более эффективный способ сделать это.
@end defun

The following function allows the entire window tree of a frame to be
retrieved:

@defun window-tree &optional frame
Функция возвращает список, представляющий дерево окон для фрейми
@var{frame}.  Если @var{frame} опущен или @code{nil}, по умолчанию
используется выбранный фрейм.

Возвращаемое значение - это список вида @code{(@var{root} @var{mini})}, где
@var{root} представляет дерево окон корневого окна фрейма, а @var{mini} -
окно минибуфера фрейма.

Если корневое окно активно, @var{root} - это само окно.  В противном случае
@var{root} - список @code{(@var{dir} @var{edges} @var{w1} @var{w2} ...)},
где @var{dir} - это @code{nil} для горизонтальной комбинации, а @code{t} -
для вертикальной комбинации, @var{edges} дает размер и положение комбинации,
а остальные элементы являются дочерними окнами.  Каждое дочернее окно может
снова быть объектом окна (для активного окна) или списком с тем же форматом,
что и выше (для внутреннего окна).  Элемент @var{edges} - это список
@code{(@var{left} @var{top} @var{right} @var{bottom})}, аналогичный
значению, возвращаемому @code{window-edges}
(@pxref{Coordinates and Windows}).
@end defun


@node Window Sizes
@section Размеры Окон
@cindex window size
@cindex size of window

  На следующей схеме показана структура активного окна:

@smallexample
@group
        ____________________________________________
       |______________ Header Line ______________|RD| ^
     ^ |LS|LM|LF|                       |RF|RM|RS|  | |
     | |  |  |  |                       |  |  |  |  | |
Window |  |  |  |       Text Area       |  |  |  |  | Window
Body | |  |  |  |     (Window Body)     |  |  |  |  | Total
Height |  |  |  |                       |  |  |  |  | Height
     | |  |  |  |<- Window Body Width ->|  |  |  |  | |
     v |__|__|__|_______________________|__|__|__|  | |
       |_________ Horizontal Scroll Bar _________|  | |
       |_______________ Mode Line _______________|__| |
       |_____________ Bottom Divider _______________| v
        <---------- Window Total Width ------------>

@end group
@end smallexample

@cindex window body
@cindex text area of a window
@cindex body of a window
  В центре окна находится @dfn{text area} или @dfn{body}, где отображается
текст буфера.  Текстовая область может быть окружена рядом дополнительных
областей.  Слева и справа, от самого внутреннего до самого внешнего, это
левая и правая полосы, обозначенные LF и RF (@pxref{Fringes}); левое и
правое поля, обозначенные LM и RM на схеме (@pxref{Display Margins});
левая или правая вертикальная полоса прокрутки, только одна из которых
присутствует в любой момент, обозначается LS и RS (@pxref{Scroll Bars}); и
правый разделитель, обозначенный RD (@pxref{Window Dividers}).  Вверху окна
находится строка заголовка (@pxref{Header Lines}).  Внизу окна расположены
горизонтальная полоса прокрутки (@pxref{Scroll Bars}); строка режима
(@pxref{Mode Line Format}); и нижний делитель (@pxref{Window Dividers}).

  Emacs предоставляет разные функции для определения высоты и ширины окна.
Возвращаемое значение многих из этих функций может быть указано либо в
пикселях, либо в единицах строк и столбцов.  На графическом дисплее
последний фактически соответствует высоте и ширине символа по умолчанию,
заданного шрифтом по умолчанию фрейма, возвращаемым @code{frame-char-height}
и @code{frame-char-width} (@pxref{Frame Font}).  Таким образом, если окно
отображает текст с другим шрифтом или размером, сообщаемая высота строки и
ширина столбца для этого окна могут отличаться от фактического количества
текстовых строк или столбцов, отображаемых в нем.

@cindex window height
@cindex height of a window
@cindex total height of a window
  @dfn{total height} окна - это количество строк, составляющих тело окна,
строку заголовка, горизонтальную полосу прокрутки, строку режима и нижний
разделитель (если есть).

@defun window-total-height &optional window round
Функция возвращает общую высоту в строках окна @var{window}.  Если
@var{window} опущен или @code{nil}, по умолчанию используется выбранное
окно.  Если @var{window} - внутреннее окно, возвращаемое значение - это
общая высота, занимаемая его дочерними окнами.

  Если высота в пикселях окна не является целым числом, кратным высоте
символа его фрейма по умолчанию, количество строк, занимаемых окном,
округляется внутри.  Это делается таким образом, что, если окно является
родительским окном, сумма общих высот всех его дочерних окон внутренне равна
общей высоте их родительского окна.  Это означает, что хотя два окна имеют
одинаковую высоту в пикселях, их внутренняя общая высота может отличаться на
одну строку.  Это также означает, что если окно объединено по вертикали и
имеет следующего брата, самая верхняя строка этого брата может быть
вычислена как сумма самой верхней строки этого окна и общей высоты
(@pxref{Coordinates and Windows})

  Если необязательный аргумент @var{round} равен @code{ceiling}, эта функция
возвращает наименьшее целое число, превышающее высоту пикселя @var{window},
деленное на высоту символа его фрейма; если это @code{floor}, возвращается
наибольшее целое число, меньшее указанного значения; с любым другим
@var{round} возвращается внутреннее значение общей высоты @var{windows}.
@end defun

@cindex window width
@cindex width of a window
@cindex total width of a window
@dfn{total width} окна - это количество строк, составляющих тело окна, его
поля, полосы, полосы прокрутки и правый разделитель (если есть).

@defun window-total-width &optional window round
Функция возвращает общую ширину окна @var{window} в столбцах.  Если
@var{window} опущен или @code{nil}, по умолчанию используется выбранное
окно.  Если @var{window} является внутренним, возвращаемое значение - это
общая ширина, занимаемая его дочерними окнами.

  Если ширина окна в пикселях не является целым числом кратным ширине его
фрейма, количество строк, занимаемых окном, внутри округляется.  Это
делается так, что, если окно является родительским окном, сумма общей ширины
всех его дочерних элементов внутри равна общей ширине их родительского окна.
Это означает, что хотя два окна имеют одинаковую ширину в пикселях, их
внутренняя общая ширина может отличаться на один столбец.  Это также
означает, что если это окно объединено по горизонтали и имеет следующего
брата, крайний левый столбец этого родственного элемента может быть
вычислен как сумма самого левого столбца этого окна и общей ширины
(@pxref{Coordinates and Windows}).  Необязательный аргумент @var{round}
ведет себя так же, как и для @code{window-total-height}.
@end defun

@defun window-total-size &optional window horizontal round
Функция возвращает либо общую высоту в строках, либо общую ширину в столбцах
окна @var{window}.  Если @var{horizontal} опущен или @code{nil}, это
эквивалентно вызову @code{window-total-height} для @var{window}; в противном
случае это эквивалентно вызову @code{window-total-width} для @var{window}.
Необязательный аргумент @var{round} действует так же, как и для
@code{window-total-height}.
@end defun

Следующие две функции могут использоваться для возврата общего размера окна
в пикселях.

@cindex window pixel height
@cindex pixel height of a window
@cindex total pixel height of a window

@defun window-pixel-height &optional window
Функция возвращает общую высоту окна @var{window} в пикселях.  @var{window}
должен быть допустимым окном и по умолчанию выбран выбранным.

Возвращаемое значение включает режим и строку заголовка, горизонтальную
полосу прокрутки и нижний разделитель, если таковой имеется.  Если
@var{window} является внутренним окном, его высота в пикселях - это высота в
пикселях областей экрана, охватываемых его дочерними элементами.
@end defun

@defun window-pixel-height-before-size-change &optional Lisp_Object &optional window
Функция возвращает высоту окна @var{window} в пикселях на момент последнего
запуска @code{window-size-change-functions} на фрейме @var{window}
(@pxref{Window Hooks}).
@end defun

@cindex window pixel width
@cindex pixel width of a window
@cindex total pixel width of a window

@defun window-pixel-width &optional window
Функция возвращает ширину окна @var{window} в пикселях.  @var{window} должен
быть допустимым окном и по умолчанию выбран выбранным.

Возвращаемое значение включает границы и поля @var{window}, а также любые
вертикальные разделители или полосы прокрутки, принадлежащие @var{window}.
Если @var{window} является внутренним окном, его ширина в пикселях - это
ширина областей экрана, охватываемых его дочерними элементами.
@end defun

@defun window-pixel-width-before-size-change &optional Lisp_Object &optional window
Функция возвращает ширину окна @var{window} в пикселях на момент последнего
запуска @code{window-size-change-functions} на фрейме @var{window}
(@pxref{Window Hooks}).
@end defun

@cindex full-width window
@cindex full-height window
  Следующие функции могут использоваться, чтобы определить, есть ли в данном
окне какие-либо смежные окна.

@defun window-full-height-p &optional window
Функция возвращает не-@code{nil}, если @var{window} не имеет другого окна
выше или ниже в своем фрейме.  Точнее, это означает, что общая высота
@var{window} равна общей высоте корневого окна в этом фрейме.  Окно
минибуфера в этом отношении не учитывается.  Если @var{window} опущено или
@code{nil}, по умолчанию используется выбранное окно.
@end defun

@defun window-full-width-p &optional window
Функция возвращает не-@code{nil}, если @var{window} не имеет другого окна
слева или справа в его фрейме, то есть его общая ширина равна ширине
корневого окна в этом фрейме.  Если @var{window} опущен или @code{nil}, по
умолчанию используется выбранное окно.
@end defun

@cindex window body height
@cindex body height of a window
@dfn{body height} окна - это высота его текстовой области, которая не
включает режим или строку заголовка, горизонтальную полосу прокрутки или
нижний разделитель.

@defun window-body-height &optional window pixelwise
Функция возвращает высоту в строках тела окна @var{window}.  Если
@var{window} опущен или @code{nil}, по умолчанию используется выбранное
окно; в противном случае это должно быть активное окно.

Если необязательный аргумент @var{pixelwise} - не-@code{nil}, функция
возвращает высоту тела @var{window} в пикселях.

Если @var{pixelwise} равен @code{nil}, возвращаемое значение при
необходимости округляется до ближайшего целого числа.  Это означает, что
если строка в нижней части текстовой области видна только частично, эта
строка не учитывается.  Это также означает, что высота тела окна никогда не
может превышать его общую высоту, возвращаемую @code{window-total-height}.
@end defun

@cindex window body width
@cindex body width of a window
@dfn{body width} окна - это ширина его текстовой области, которая не
включает полосу прокрутки, края, поля или правый разделитель.  Обратить
внимание, что при удалении одной или обеих полос (путем установки их ширины
на ноль) механизм отображения резервирует две символьные ячейки, по одной с
каждой стороны окна, для отображения глифов продолжения и усечения, что
оставляет на 2 столбца меньше для отображения текста.  (Функция
@code{window-max-chars-per-line}, описанная ниже, учитывает эту
особенность.)

@defun window-body-width &optional window pixelwise
Функция возвращает ширину в столбцах тела окна @var{window}.  Если
@var{window} опущен или @code{nil}, по умолчанию используется выбранное
окно; в противном случае это должно быть живое окно.

Если необязательный аргумент @var{pixelwise} - не-@code{nil}, функция
возвращает ширину тела @var{window} в пикселях.

Если @var{pixelwise} равен @code{nil}, возвращаемое значение при
необходимости округляется до ближайшего целого числа.  Это означает, что
если столбец справа от текстовой области виден только частично, этот столбец
не учитывается.  Это также означает, что ширина тела окна никогда не может
превышать его общую ширину, возвращаемую @code{window-total-width}.
@end defun

@cindex window body size
@cindex body size of a window
@defun window-body-size &optional window horizontal pixelwise
Функция возвращает высоту или ширину тела @var{window}.  Если
@var{horizontal} опущен или @code{nil}, это эквивалентно вызову
@code{window-body-height} для @var{window}; в противном случае это
эквивалентно вызову @code{window-body-width}.  В любом случае необязательный
аргумент @var{pixelwise} передается вызываемой функции.
@end defun

Для совместимости с предыдущими версиями Emacs @code{window-height} - это
псевдоним для @code{window-total-height}, а @code{window-width} - это
псевдоним для @code{window-body-width}.  Эти псевдонимы считаются
устаревшими и будут удалены в будущем.

   Высота в пикселях режима окна и строки заголовка может быть получена с
помощью функций, приведенных ниже.  Их возвращаемое значение обычно является
точным, если окно не отображалось раньше: в этом случае возвращаемое
значение основывается на оценке шрифта, используемого для рамки окна.

@defun window-mode-line-height &optional window
Функция возвращает высоту в пикселях строки режима @var{window}.
@var{window} должно быть активным окном и по умолчанию быть выбранным.  Если
@var{window} не имеет строки режима, возвращаемое значение равно нулю.
@end defun

@defun window-header-line-height &optional window
Функция возвращает высоту в пикселях строки заголовка @var{window}.
@var{window} должно быть активным окном и по умолчанию быть выбранным.  Если
@var{window} не имеет строки заголовка, возвращаемое значение равно нулю.
@end defun

Функции для получения высоты и/или ширины разделителей окон
(@pxref{Window Dividers}), полос (@pxref{Fringes}), полос прокрутки
(@pxref{Scroll Bars}) и полей отображения (@pxref{Display Margins}) описаны
в соответствующих разделах.

Если программа Lisp должна принимать решения по компоновке, пригодится
следующая функция:

@defun window-max-chars-per-line &optional window face
Функция возвращает количество символов, отображаемых в границах
@var{face} в указанном окне @var{window} (которое должно быть активным
окном).  Если @var{face} было переназначено (@pxref{Face Remapping}),
информация возвращается для переназначенного вида отображения.  Если опущено
или @code{nil}, @var{face} по умолчанию принимает вид отображения по
умолчанию, а @var{window} по умолчанию используется для выбранного окна.

В отличие от @code{window-body-width}, эта функция учитывает фактический
размер шрифта @var{face} вместо того, чтобы работать в единицах канонической
ширины символа границ @var{window} (@pxref{Frame Font}).  Также учитывается
пространство, используемое глифом продолжения, если @var{window} не имеет
одной или обеих сторон.
@end defun

@cindex fixed-size window
@vindex window-min-height
@vindex window-min-width
  Команды, которые изменяют размер окон (@pxref{Resizing Windows}) или
разделяют их на (@pxref{Splitting Windows}), подчиняются переменным
@code{window-min-height} и @code{window-min-width}, которые определяют
минимально допустимую высоту и ширину окна.  Они также подчиняются
переменной @code{window-size-fixed}, с помощью которой окно может быть
@dfn{фиксированного} размера (@pxref{Preserving Window Sizes}).

@defopt window-min-height
Этот параметр определяет минимальную общую высоту в строках любого окна.
Его значение должно включать по крайней мере одну текстовую строку, а также
строку режима и заголовка, горизонтальную полосу прокрутки и нижний
разделитель, если таковой имеется.
@end defopt

@defopt window-min-width
Этот параметр определяет минимальную общую ширину в столбцах любого окна.
Его значение должно включать два текстовых столбца, а также поля, полосы,
полосу прокрутки и правый разделитель, если таковой имеется.
@end defopt

Следующая функция сообщает, насколько маленьким может стать конкретное окно
с учетом размеров его областей и значений @code{window-min-height},
@code{window-min-width} и @code{window-size-fixed}
(@pxref{Preserving Window Sizes}).

@defun window-min-size &optional window horizontal ignore pixelwise
Функция возвращает минимальный размер @var{window}.  @var{window} должено
быть допустимым окном и по умолчанию быть выбранным.  Необязательный
аргумент @var{horizontal} не-@code{nil} означает возврат минимального
количества столбцов @var{window}; в противном случае возврать минимального
количества строк @var{window}.

Возвращаемое значение гарантирует, что все компоненты @var{window} остаются
полностью видимыми, если размер @var{window} действительно был установлен
для этого.  @var{horizontal} в @code{nil} включает строку режима и
заголовка, горизонтальную полосу прокрутки и нижний разделитель, если он
есть.  @var{horizontal} в не-@code{nil} включает поля и полосы, вертикальную
полосу прокрутки и правый разделитель, если он есть.

Необязательный аргумент @var{ignore}, если не-@code{nil}, означает
игнорирование ограничений, налагаемых окнами фиксированного размера,
параметрами @code{window-min-height} или @code{window-min-width}.  Если
@var{ignore} равно @code{safe}, активные окна могут стать меньше строк
@code{window-safe-min-height} и столбцов @code{window-safe-min-width}.  Если
@var{ignore} является окном, игнорируются ограничения только для этого окна.
Любое другое значение от не-@code{nil} означает игнорирование всех
вышеперечисленных ограничений для всех окон.

Необязательный аргумент @var{pixelwise} не-@code{nil} означает возврат
минимального размера @var{window} в пикселях.
@end defun


@node Resizing Windows
@section Изменение Размера Окон
@cindex window resizing
@cindex resize window
@cindex changing window size
@cindex window size, changing

  В этом разделе описаны функции для изменения размера окна без изменения
размера его рамки.  Поскольку активные окна не перекрываются, эти функции
имеют смысл только для фреймов, содержащих два или более окон: изменение
размера окна также изменяет размер соседнего окна.  Если во фрейме только
одно окно, его размер нельзя изменить, кроме как путем изменения размера
фрейма (@pxref{Frame Size}).

  Если не указано иное, эти функции также принимают внутренние окна в
качестве аргументов.  Изменение размера внутреннего окна приводит к тому,
что его дочерние окна изменяются, чтобы соответствовать тому же
пространству.

@defun window-resizable window delta &optional horizontal ignore pixelwise
Функция возвращает @var{delta}, если размер @var{window} может быть изменен
по вертикали строками @var{delta}.  Если необязательный аргумент
@var{horizontal} - не-@code{nil}, вместо этого возвращается @var{delta},
если @var{window} можно изменять по горизонтали с помощью столбцов
@var{delta}.  Фактически это не меняет размер окна.

Если @var{window} равен @code{nil}, по умолчанию используется выбранное
окно.

Положительное значение @var{delta} означает проверку возможности увеличения
окна на это количество строк или столбцов; отрицательное значение
@var{delta} означает проверку, можно ли уменьшить окно на такое количество
строк или столбцов.  Если @var{delta} не равно нулю, возвращаемое значение 0
означает, что размер окна изменить нельзя.

Обычно переменные @code{window-min-height} и @code{window-min-width}
определяют наименьший допустимый размер окна (@pxref{Window Sizes}).
Однако, если необязательный аргумент @var{ignore} - не-@code{nil}, эта
функция игнорирует @code{window-min-height} и @code{window-min-width}, а
также @code{window-size-fixed}.  Вместо этого считается, что окно
минимальной высоты состоит из заголовка и строки режима, горизонтальной
полосы прокрутки и нижнего разделителя (если есть), а также текстовой
области высотой в одну строку; и окно минимальной ширины, состоящее из
полос, полей, полосы прокрутки и правого разделителя (если есть), а также
текстовой области шириной в два столбца.

Если необязательный аргумент @var{pixelwise} - не-@code{nil}, @var{delta}
интерпретируется как пиксели.
@end defun

@defun window-resize window delta &optional horizontal ignore pixelwise
Функция изменяет размер @var{window} с шагом @var{delta}.  Если
@var{horizontal} равен @code{nil}, изменяется высота на строки @var{delta};
в противном случае ширина изменяется на @var{delta} столбцов.  Положительное
значение @var{delta} означает увеличение окна, а отрицательное значение
@var{delta} означает его уменьшение.

Если @var{window} равно @code{nil}, по умолчанию используется выбранное
окно.  Если размер окна не может быть изменен в соответствии с требованиями,
выдается сигнал об ошибке.

Необязательный аргумент @var{ignore} имеет то же значение, что и для функции
@code{window-resizable} выше.

Если необязательный аргумент @var{pixelwise} - не-@code{nil}, @var{delta}
будет интерпретироваться как пиксели.

Выбор того, какие края окна изменяются этой функцией, зависит от значений
параметра @code{window-combination-resize} и пределов комбинации
задействованных окон; в некоторых случаях это может изменить оба края.
@xref{Recombining Windows}.  Чтобы изменить размер, перемещая только нижний
или правый край окна, используется функция
@code{adjust-window-trailing-edge}.
@end defun

@c Команды Увеличить окно, Увеличить окно по горизонтали, сжать окно и
@c сжать окно по горизонтали задокументированы в руководстве по Emacs.
@c Это не рекомендуется вызывать из Lisp.

@defun adjust-window-trailing-edge window delta &optional horizontal pixelwise
Функция перемещает нижний край @var{window} на строки @var{delta}.  Если
необязательный аргумент @var{horizontal} - не-@code{nil}, вместо этого
перемещается правый край на столбцы @var{delta}.  Если @var{window} равен
@code{nil}, по умолчанию используется выбранное окно.

Если необязательный аргумент @var{pixelwise} - не-@code{nil}, @var{delta}
интерпретируется как пиксели.

Положительное значение @var{delta} перемещает край вниз или вправо;
отрицательное @var{delta} перемещает его вверх или влево.  Если край не
может быть перемещен так далеко, как указано @var{delta}, эта функция
перемещает его как можно дальше, но не сигнализирует об ошибке.

Функция пытается изменить размер окон, прилегающих к перемещаемому краю.
Если это невозможно по какой-либо причине (например, если это соседнее окно
имеет фиксированный размер), может изменить размер других окон.
@end defun

@cindex pixelwise, resizing windows
@defopt window-resize-pixelwise
Если значение этой опции - не-@code{nil}, Emacs изменяет размеры окон в
пикселях.  В настоящее время это влияет на такие функции, как
@code{split-window} (@pxref{Splitting Windows}), @code{maximize-window},
@code{minimize-window}, @code{fit-window-to-buffer},
@code{fit-frame-to-buffer} и
@code{shrink-window-if-larger-than-buffer} (все перечисленны ниже).

Обратить внимание, что когда размер кадра в пикселях не кратен размеру его
символа, по крайней мере одно окно может быть изменено в пикселях, даже
если эта опция - @code{nil}.  Значение по умолчанию - @code{nil}.
@end defopt

  Следующие команды изменяют размер окон более конкретными способами.  При
интерактивном вызове они действуют в выбранном окне.

@deffn Command fit-window-to-buffer &optional window max-height min-height max-width min-width preserve-size
Команда регулирует высоту или ширину @var{window}, чтобы соответствовать
тексту в нем.  Возвращает не-@code{nil}, если можно было изменить размер
@var{window}, и в противном случае @code{nil}.  Если @var{window} опущено
или @code{nil}, по умолчанию используется выбранное окно.  В противном
случае это должно быть активное окно.

Если @var{window} является частью вертикальной комбинации, эта функция
регулирует высоту @var{window}.  Новая высота рассчитывается исходя из
фактической высоты доступной части буфера.  Необязательный аргумент
@var{max-height}, если не-@code{nil}, указывает максимальную общую высоту,
которую эта функция может дать @var{window}.  Необязательный аргумент
@var{min-height}, если не-@code{nil}, указывает минимальную общую высоту,
которую можно дать, которая переопределяет переменную
@code{window-min-height}.  И @var{max-height}, и @var{min-height} указаны в
строках и включают режим, строку заголовка и нижний разделитель, если
таковой имеется.

Если @var{window} является частью горизонтальной комбинации и значение
параметра @code{fit-window-to-buffer-horizontally} (смотреть ниже) равно
не-@code{nil}, функция регулирует ширину @var{window}.  Новая ширина
@var{window} рассчитывается из максимальной длины строк буфера, следующих за
текущей начальной позицией @var{window}.  Необязательный аргумент
@var{max-width} указывает максимальную ширину и по умолчанию равен ширине
рамки @var{window}.  Необязательный аргумент @var{min-width} указывает
минимальную ширину, по умолчанию - @code{window-min-width}.  Оба
@var{max-width} и @var{min-width} указаны в столбцах и включают обрамление,
поля и полосы прокрутки, если таковые имеются.

Необязательный аргумент @var{preserve-size}, если не-@code{nil}, установит
параметр для сохранения размера @var{window} во время будущих операций
изменения размера (@pxref{Preserving Window Sizes}).

Если опция @code{fit-frame-to-buffer} (смотреть ниже) - не-@code{nil}, эта
функция попытается изменить размер рамки @var{window}, чтобы соответствовала
его содержимому, вызывая @code{fit-frame-to-buffer} (смотреть ниже).
@end deffn

@defopt fit-window-to-buffer-horizontally
Если не-@code{nil}, @code{fit-window-to-buffer}, может изменять размер
окон по горизонтали.  Если @code{nil} (по умолчанию),
@code{fit-window-to-buffer} никогда не изменит размер окон по горизонтали.
Если @code{only}, может изменять размер окон только по горизонтали.  Любое
другое значение означает, что @code{fit-window-to-buffer} может изменять
размер окон в обоих измерениях.
@end defopt

@defopt fit-frame-to-buffer
Если опция установлена в не-@code{nil}, @code{fit-window-to-buffer}, может
поместить фрейм в свой буфер.  Фрейм подходит тогда и только тогда, когда
его корневое окно является активным окном и эта опция - не-@code{nil}.  Еслиэто @code{horizontally}, рамки подходят только по горизонтали.  Если это
@code{vertically}, рамки подходят только по вертикали.  Любое другое
значение не-@code{nil} означает, что размер фреймов можно изменять в обоих
измерениях.
@end defopt

Если у есть фрейм, который отображает только одно окно, можно поместить этот
фрейм в его буфер, используя команду @code{fit-frame-to-buffer}.

@deffn Command fit-frame-to-buffer &optional frame max-height min-height max-width min-width only
Команда регулирует размер @var{frame} для точного отображения содержимого
буфера.  @var{frame} может быть любым активным фреймом и по умолчанию
быть выбранным.  Подгонка производится только при активном корневом окне
@var{frame}.  Аргументы @var{max-height}, @var{min-height}, @var{max-width}
и @var{min-width} задают границы нового общего размера корневого окна
@var{frame}.  @var{min-height} и @var{min-width} по умолчанию принимает
значения @code{window-min-height} и @code{window-min-width} соответственно.

Если необязательный аргумент @var{only} - @code{vertically}, функция может
изменять размер кадра только по вертикали.  Если @var{only} равен
@code{horizontally}, можно изменять размер кадра только по горизонтали.
@end deffn

Поведение @code{fit-frame-to-buffer} можно контролировать с помощью двух
опций, перечисленных ниже.

@defopt fit-frame-to-buffer-margins
Опцию можно использовать для указания полей вокруг фреймов, которые будут
соответствовать @code{fit-frame-to-buffer}.  Такие поля могут быть полезны,
чтобы избежать, например, того, что рамка с измененным размером перекрывает
панель задач или части ее родительской рамки.

Определяет количество пикселей, которые должны быть оставлены свободными
слева, сверху, справа и снизу кадра соответственно.  По умолчанию для
каждого указывается @code{nil}, что означает отсутствие полей.  Указанное
здесь значение может быть переопределено для конкретного кадра параметром
@code{fit-frame-to-buffer-margins} этого кадра, если присутствует.
@end defopt

@defopt fit-frame-to-buffer-sizes
Опция определяет границы размера для @code{fit-frame-to-buffer}.  Определяет
общие максимальные и минимальные строки, а также максимальные и минимальные
столбцы корневого окна любого кадра, которое должно уместиться в его буфере.
Если любое из этих значений - не-@code{nil}, оно отменяет соответствующий
аргумент @code{fit-frame-to-buffer}.
@end defopt

@deffn Command shrink-window-if-larger-than-buffer &optional window
Команда пытается уменьшить высоту @var{window} насколько это возможно, при
этом показывая полный буфер, но не меньше, чем строк в
@code{window-min-height}.  Возвращаемое значение - не-@code{nil}, если
размер окна был изменен, и @code{nil} в противном случае.  Если @var{window}
опущено или @code{nil}, по умолчанию используется выбранное окно.  В
противном случае это должно быть активное окно.

Команда ничего не делает, если окно уже слишком короткое, чтобы отобразить
весь его буфер, или если какой-либо буфер прокручивается за пределы экрана,
или если окно является единственным активным окном в своем фрейме.

Команда вызывает @code{fit-window-to-buffer} (смотреть выше) для выполнения
своей работы.
@end deffn


@cindex balancing window sizes
@deffn Command balance-windows &optional window-or-frame
Функция уравновешивает окна таким образом, чтобы оставлять больше места для
окон во всю ширину и/или во всю высоту.  Если @var{window-or-frame}
указывает фрейм, уравновешивает все окна в этом фрейме.  Если
@var{window-or-frame} указывает окно, балансирует только это окно и его
братьев и сестер (@pxref{Windows and Frames}).
@end deffn

@deffn Command balance-windows-area
Функция пытается предоставить всем окнам в выбранном фрейме примерно
одинаковую долю площади экрана.  Окна во всю ширину или в высоту не занимают
больше места, чем другие окна.
@end deffn

@cindex maximizing windows
@deffn Command maximize-window &optional window
Функция пытается сделать @var{window} как можно больше в обоих измерениях
без изменения размера его рамки или удаления других окон.  Если @var{window}
опущено или @code{nil}, по умолчанию используется выбранное окно.
@end deffn

@cindex minimizing windows
@deffn Command minimize-window &optional window
Функция пытается сделать @var{window} как можно меньше в обоих измерениях,
не удаляя его и не изменяя размер его рамки.  Если @var{window} опущено или
@code{nil}, по умолчанию используется выбранное окно.
@end deffn


@node Preserving Window Sizes
@section Сохранение Размеров Окон
@cindex preserving window sizes

Размер окна можно изменить явно, используя одну из функций из предыдущего
раздела, или неявно, например, при изменении размера соседнего окна, при
разделении или удалении окна (@pxref{Splitting Windows},
@pxref{Deleting Windows}) или при изменении размера рамки окна
(@pxref{Frame Size}).

  Можно избежать неявного изменения размера конкретного окна, если в том же
фрейме есть одно или несколько других окон с изменяемым размером.  Для этого
следует посоветовать Emacs увеличить размер этого окна.  Для этого есть два
основных способа.

@defvar window-size-fixed
Если эта локальная переменная буфера - не-@code{nil}, размер любого окна,
отображающего буфер, обычно не может быть изменен.  Удаление окна или
изменение размера фрейма может по-прежнему изменять размер окна, если нет
выбора.

Если значение равно @code{height}, то фиксируется только высота окна; если
значение @code{width}, то фиксируется только ширина окна.  Любое другое
значение не-@code{nil} фиксирует как ширину, так и высоту.

Если эта переменная - @code{nil}, это не обязательно означает, что любое
окно, показывающее буфер, может быть изменено в желаемом направлении.  Чтобы
определить это, используйте функцию @code{window-resizable}.
@xref{Resizing Windows}.
@end defvar

Часто @code{window-size-fixed} слишком агрессивенj, потому что также
запрещает любые попытки явно изменить размер или разделить затронутое окно.
Это может произойти даже после неявного изменения размера окна, например,
при удалении соседнего окна или изменении размера рамки окна.  Следующая
функция изо всех сил пытается никогда не запрещать явное изменение размера
такого окна:

@defun window-preserve-size &optional window horizontal preserve
Функция (отменяет-) отмечает - высоту окна @var{window}, которая
сохраняется для будущих операций изменения размера.  @var{window} должно
быть активным окном и по умолчанию выбрано.  Если необязательный аргумент
@var{horizontal} - не-@code{nil}, (отменяет-) отмечает ширину @var{window}
как сохраненную.

Если необязательный аргумент @var{preserve} - @code{t}, это означает
сохранение текущей высоты/ширины тела @var{window}.  Высота/ширина
@var{window} изменится только в том случае, если у Emacs нет лучшего выбора.
Изменение размера окна, высота/ширина которого сохраняется этой функцией,
никогда не вызывает ошибки.

Если @var{preserve} равен @code{nil}, это означает прекращение сохранения
высоты/ширины @var{window}, снятие любых ограничений, наложенных предыдущим
вызовом этой функции для @var{window}.  Вызов @code{enlarge-window},
@code{shrink-window} или @code{fit-window-to-buffer} с аргументом
@var{window} также может удалить соответствующее ограничение.
@end defun

@code{window-preserve-size} в настоящее время вызывается следующими
функциями:

@table @code
@item fit-window-to-buffer
Если необязательный аргумент @var{preserve-size} этой функции
(@pxref{Resizing Windows}) равен не-@code{nil}, размер, установленный этой
функцией, сохраняется.

@item display-buffer
Если аргумент @var{alist} этой функции (@pxref{Choosing Window}) содержит
запись @code{preserve-size}, размер окна, созданного этой функцией,
сохраняется.
@end table

  @code{window-preserve-size} устанавливает параметр окна
(@pxref{Window Parameters}) с именем @code{window-preserved-size}, который
используется функциями изменения размера окна.  Этот параметр не
препятствует изменению размера окна, когда в окне отображается другой буфер,
отличный от того, который был при вызове @code{window-preserve-size}, или
если его размер с тех пор изменился.

Следующая функция может использоваться, чтобы проверить, сохраняется ли
высота конкретного окна:

@defun window-preserved-size &optional window horizontal
Функция возвращает сохраненную высоту окна @var{window} в пикселях.
@var{window} должно быть активным окном и по умолчанию быть выбранным.  Если
необязательный аргумент @var{horizontal} - не-@code{nil}, возвращается
сохраненная ширина @var{window}.  Возвращается @code{nil}, если размер
@var{window} не сохраняется.
@end defun


@node Splitting Windows
@section Разделение Окон
@cindex splitting windows
@cindex window splitting

В этом разделе описаны функции для создания нового окна с помощью
@dfn{расделение} существующего.  Обратить внимание, что некоторые окна
являются особенными в том смысле, что эти функции могут не разделить их, как
описано здесь.  Примерами таких окон являются боковые окна
(@pxref{Side Windows}) и атомарные окна (@pxref{Atomic Windows}).

@defun split-window &optional window size side pixelwise
Функция создает новое активное окно рядом с окном @var{window}.  Если
@var{window} опущено или @code{nil}, по умолчанию используется выбранное
окно.  Это окно разделяется и уменьшается в размере.  Место занимает новое
окно, которое возвращается.

Необязательный второй аргумент @var{size} определяет размеры @var{window}
и/или нового окна.  Если не указан или @code{nil}, обоим окнам присваивается
одинаковый размер; если есть нечетная строка, она размещается в новом окне.
Если @var{size} - положительное число, @var{window} даются строки @var{size}
(или столбцы, в зависимости от значения @var{side}).  Если @var{size} -
отрицательное число, в новом окне будет отображаться @minus{}@var{size}
строк (или столбцов).

Если @var{size} равен @code{nil}, эта функция подчиняется переменным
@code{window-min-height} и @code{window-min-width} (@pxref{Window Sizes}).
Таким образом, сигнализируется об ошибке, если разбиение приведет к
уменьшению окна меньше, чем указано в этих переменных.  Однако значение
не-@code{nil} для @var{size} приводит к тому, что эти переменные
игнорируются; в этом случае наименьшим допустимым окном считается такое, в
котором есть место для текстовой области высотой в одну строку и/или шириной
в два столбца.

Следовательно, если указано @var{size}, вызывающий должен проверить,
достаточно ли велики исходящие окна, чтобы охватить все области, такие как
строка режима или полоса прокрутки.  Функцию @code{window-min-size}
(@pxref{Window Sizes}) можно использовать для определения минимальных
требований @var{window} в этом отношении.  Поскольку новое окно обычно
наследует такие области, как строка режима или полоса прокрутки от
@var{window}, эта функция также является хорошим предположением для
минимального размера нового окна.  Вызывающий должен указать меньший размер
только в том случае, если он соответственно удаляет унаследованную область
перед следующим повторным отображением.

Необязательный третий аргумент @var{side} определяет положение нового окна
относительно @var{window}.  Если это @code{nil} или @code{below}, новое окно
помещается под @var{window}.  Если это @code{above}, новое окно размещается
над @var{window}.  В обоих случаях @var{size} указывает общую высоту окна в
строках.

Если @var{side} равен @code{t} или @code{right}, новое окно помещается
справа от @var{window}.  Если @var{side} - @code{left}, новое окно
помещается слева от @var{window}.  В обоих случаях @var{size} указывает
общую ширину окна в столбцах.

Необязательный четвертый аргумент @var{pixelwise}, если не-@code{nil},
означает интерпретацию @var{size} в единицах пикселей, а не в строках и
столбцах.

Если @var{window} является активным окном, новое окно наследует от него
различные свойства, включая поля и полосы прокрутки.  Если @var{window}
является внутренним окном, новое окно наследует свойства окна, выбранного
во фрейме @var{window}.

Поведение этой функции может быть изменено параметрами окна @var{window},
если переменная @code{ignore-window-parameters} имеет значение @code{nil}.
Если значение параметра окна @code{split-window} - @code{t}, эта функция
игнорирует все остальные параметры окна.  В противном случае, если значение
параметра окна @code{split-window} является функцией, эта функция вызывается
с аргументами @var{window}, @var{size} и @var{side} вместо обычного действия
@code{split-window}.  В другом случае эта функция подчиняется параметру окна
@code{window-atom} или @code{window-side}, если таковой имеется.
@xref{Window Parameters}.
@end defun

  В качестве примера, вот последовательность вызовов @code{split-window},
которая дает конфигурацию окна, обсуждаемую в @ref{Windows and Frames}.
Этот пример демонстрирует разделение активного окна, а также разделение
внутреннего окна.  Нчиноется с фрейма, содержащего одно окно (активное
корневое окно), которое обозначается @var{W4}.  Вызов
@code{(split-window W4)} дает такую конфигурацию окна:

@smallexample
@group
     ______________________________________
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||_________________W4_________________||
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||_________________W5_________________||
    |__________________W3__________________|

@end group
@end smallexample

@noindent
Вызовом @code{split-window} создаётся новое активное окно, обозначенное
@var{W5}.  Также создаётся новое внутреннее окно, обозначенное @var{W3},
которое становится корневым окном и родительским окном для @var{W4} и
@var{W5}.

  Затем вызывается @code{(split-window W3 nil 'left)}, с передачей в
качестве аргумента внутреннее окно @var{W3}.  Результат:

@smallexample
@group
     ______________________________________
    | ______  ____________________________ |
    ||      || __________________________ ||
    ||      |||                          |||
    ||      |||                          |||
    ||      |||                          |||
    ||      |||____________W4____________|||
    ||      || __________________________ ||
    ||      |||                          |||
    ||      |||                          |||
    ||      |||____________W5____________|||
    ||__W2__||_____________W3_____________ |
    |__________________W1__________________|
@end group
@end smallexample

@noindent
Новое активное окно @var{W2} создается слева от внутреннего окна @var{W3}.
Создается новое внутреннее окно @var{W1}, которое становится новым корневым
окном.

   Для интерактивного использования Emacs предоставляет две команды, которые
всегда разделяют выбранное окно.  Они внутри вызывают @code{split-window}.

@deffn Command split-window-right &optional size
Функция разделяет выбранное окно на два бок о бок окна, помещая выбранное
окно слева.  Если @var{size} положительно, левое окно получает столбцы
@var{size}; если @var{size} отрицательно, правое окно получает столбцы
@minus{}@var{size}.
@end deffn

@deffn Command split-window-below &optional size
Функция разделяет выбранное окно на два окна, одно над другим, оставляя
верхнее окно выбранным.  Если @var{size} положительно, верхнее окно получает
строки @var{size}; если @var{size} отрицательно, нижнее окно получает строки
@minus{}@var{size}.
@end deffn

@defopt split-window-keep-point
Если значение этой переменной - не-@code{nil} (по умолчанию),
@code{split-window-below} ведет себя, как описано выше.

Если @code{nil}, @code{split-window-below} регулирует точку в каждом из двух
окон, чтобы минимизировать повторное отображение.  (Это полезно на
медленных терминалах.)  Выбирается любое окно, содержащее строку экрана, на
которой ранее находилась точка.  Обратить внимание, что это влияет только на
@code{split-window-below}, но не на функцию @code{split-window} нижнего
уровня.
@end defopt


@node Deleting Windows
@section Удаление Окон
@cindex deleting windows

  @dfn{Удаление} окна удаляет его из дерева окон фрейма.  Если окно является
активным окном, оно исчезает с экрана.  Если окно является внутренним, его
дочерние окна также удаляются.

  Даже после того, как окно удалено, оно продолжает существовать как объект
Lisp до тех пор, пока на него не исчезнут ссылки.  Удаление окна можно
отменить, восстановив сохраненную конфигурацию окна
(@pxref{Window Configurations}).

@deffn Command delete-window &optional window
Функция удаляет @var{window} с дисплея и возвращает @code{nil}.  Если
@var{window} опущено или @code{nil}, по умолчанию используется выбранное
окно.

Если при удалении окна больше не останется окон в дереве окон (например,
если это единственное активное окно фрейма) или все оставшиеся окна в фрейме
@var{window} являются боковыми окнами (@pxref{Side Windows}), выдается
сигнал об ошибке.  Если @var{window} является частью атомарного окна
(@pxref{Atomic Windows}), эта функция вместо этого пытается удалить корень
этого атомарного окна.

По умолчанию, пространство, занимаемое @var{window}, отводится одному из
соседних соседних окон, если таковые имеются.  Однако, если переменная
@code{window-combination-resize} равна не-@code{nil}, пространство
пропорционально распределяется между любыми оставшимися окнами в той же
комбинации окон.  @xref{Recombining Windows}.

Поведение этой функции может быть изменено параметрами окна @var{window},
если переменная @code{ignore-window-parameters} имеет значение @code{nil}.
Если значение параметра окна @code{delete-window} - @code{t}, эта функция
игнорирует все остальные параметры окна.  В противном случае, если значение
параметра окна @code{delete-window} является функцией, эта функция
вызывается с аргументом @var{window} вместо обычного действия
@code{delete-window}.  @xref{Window Parameters}.
@end deffn

@deffn Command delete-other-windows &optional window
Функция заставляет @var{window} заполнять его фрейм, удаляя при
необходимости другие окна.  Если @var{window} не указан или @code{nil}, по
умолчанию используется выбранное окно.  Об ошибке сигнализируется, если
@var{window} является боковым окном (@pxref{Side Windows}).  Если
@var{window} является частью атомарного окна (@pxref{Atomic Windows}), эта
функция пытается заставить корень этого атомарного окна заполнить его фрейм.
Возвращаемое значение - @code{nil}.

Поведение этой функции может быть изменено параметрами окна @var{window},
если переменная @code{ignore-window-parameters} имеет значение @code{nil}.
Если значение параметра окна @code{delete-other-windows} - @code{t}, эта
функция игнорирует все остальные параметры окна.  В противном случае, если
значение параметра окна @code{delete-other-windows} является функцией, эта
функция вызывается с аргументом @var{window} вместо обычного действия
@code{delete-other-windows}.  @xref{Window Parameters}.

Кроме того, если @code{ignore-window-parameters} равно @code{nil}, эта
функция не удаляет ни одного окна, параметр @code{no-delete-other-windows}
которого равен не-@code{nil}.
@end deffn

@deffn Command delete-windows-on &optional buffer-or-name frame
Функция удаляет все окна, отображающие @var{buffer-or-name}, путем вызова
@code{delete-window} для этих окон.  @var{buffer-or-name} должно быть
буфером или именем буфера; если опущено или @code{nil}, по умолчанию
используется текущий буфер.  Если нет окон, показывающих указанный буфер,
эта функция ничего не делает.  Если указанный буфер является минибуфером,
выдается сигнал об ошибке.

Если есть выделенное окно, показывающее буфер, и это окно является
единственным в своем фрейме, эта функция также удаляет этот фрейм, если это
не единственный фрейм на терминале.

Необязательный аргумент @var{frame} указывает, с какими фреймами работать:

@itemize @bullet
@item @code{nil}
означает работать на всех фреймах.
@item @code{t}
означает работать с выбранным фреймом.
@item @code{visible}
означает работать со всеми видимыми фреймами.
@item @code{0}
означает работу со всеми видимыми или иконизированными фреймами.
@item A frame
означает работать с этим фреймом.
@end itemize

Обратить внимание, что этот аргумент не имеет того же значения, что и в
других функциях, сканирующих все активные окна
(@pxref{Cyclic Window Ordering}).  В частности, значения @code{t} и
@code{nil} здесь противоположны тому, что представляют собой в других таких
функциях.
@end deffn


@node Recombining Windows
@section Перекомпоновка Окон
@cindex recombining windows
@cindex windows, recombining

При удалении последнего брата окна @var{W}, его родительское окно также
удаляется, а @var{W} заменяет его в дереве окон.  Это означает, что @var{W}
должно быть повторно скомбинировано с его родителями и сестрами, чтобы
сформировать новую комбинацию окон (@pxref{Windows and Frames}).  В
некоторых случаях удаление активного окна может даже повлечь за собой
удаление двух внутренних окон.

@smallexample
@group
     ______________________________________
    | ______  ____________________________ |
    ||      || __________________________ ||
    ||      ||| ___________  ___________ |||
    ||      ||||           ||           ||||
    ||      ||||____W6_____||_____W7____||||
    ||      |||____________W4____________|||
    ||      || __________________________ ||
    ||      |||                          |||
    ||      |||                          |||
    ||      |||____________W5____________|||
    ||__W2__||_____________W3_____________ |
    |__________________W1__________________|

@end group
@end smallexample

@noindent
Удаление @var{W5} в этой конфигурации обычно приводит к удалению @var{W3} и
@var{W4}.  Остальные активные окна @var{W2}, @var{W6} и @var{W7}
рекомбинируются для образования новой горизонтальной комбинации с
родительским @var{W1}.

   Однако иногда имеет смысл не удалять родительское окно, например
@var{W4}.  В частности, не следует удалять родительское окно, если оно
использовалось для сохранения комбинации, встроенной в комбинацию того же
типа.  Такие вложения имеют смысл гарантиии, что когда разбивается окно и
впоследствии удаляете новое окно, Emacs восстанавливает макет связанного
фрейма, который существовал до разделения.

   Рассматривается сценарий, начинающийся с двух активных окон @var{W2} и
@var{W3} и их родительского @var{W1}.

@smallexample
@group
     ______________________________________
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||_________________W2_________________||
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||_________________W3_________________||
    |__________________W1__________________|

@end group
@end smallexample

@noindent
Разделите @var{W2}, чтобы сделать новое окно @var{W4} следующим образом.

@smallexample
@group
     ______________________________________
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||_________________W2_________________||
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||_________________W4_________________||
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||_________________W3_________________||
    |__________________W1__________________|

@end group
@end smallexample

@noindent
Теперь, увеличивая окно по вертикали, Emacs пытается получить
соответствующее пространство от своего младшего брата, при условии, что
такое окно существует.  В сценарии увеличение @var{W4} будет занимать место
у @var{W3}.

@smallexample
@group
     ______________________________________
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||_________________W2_________________||
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||_________________W4_________________||
    | ____________________________________ |
    ||_________________W3_________________||
    |__________________W1__________________|

@end group
@end smallexample

@noindent
Удаление @var{W4} теперь предоставит @var{W2} все пространство, включая
пространство, ранее украденное из @var{W3}.

@smallexample
@group
     ______________________________________
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||_________________W2_________________||
    | ____________________________________ |
    ||_________________W3_________________||
    |__________________W1__________________|

@end group
@end smallexample

@noindent
Это может показаться нелогичным, в частности, если @var{W4} использовалось
для временного отображения буфера (@pxref{Temporary Displays}), и требуется
продолжить работу с исходным макетом.

Поведение можно исправить, создав новое родительское окно при разделении
@var{W2}.  Описанная ниже переменная позволяет это сделать.

@defopt window-combination-limit
Переменная определяет, должно ли разделение окна создавать новое
родительское окно.  Признаны следующие значения:

@table @code
@item nil
Означает, что новому активному окну разрешено совместно использовать
существующее родительское окно, если оно существует, при условии, что
разделение происходит в том же направлении, что и существующая комбинация
окон (в противном случае в любом случае создается новое внутреннее окно).

@item window-size
Означает, что @code{display-buffer} создает новое родительское окно, когда
разделяет окно, и ему передается запись @code{window-height} или
@code{window-width} в аргументе @var{alist}
(@pxref{Buffer Display Action Functions}).  В противном случае разделение
окна ведет себя как для значения @code{nil}.

@item temp-buffer-resize
В этом случае @code{with-temp-buffer-window} создается новое родительское
окно, когда разбивается окно, и @code{temp-buffer-resize-mode} включен
(@pxref{Temporary Displays}).  В противном случае разбиение окна ведёт себя
как для @code{nil}.

@item temp-buffer
В этом случае @code{with-temp-buffer-window} всегда создает новое
родительское окно, когда разделяет существующее окно
(@pxref{Temporary Displays}).  В противном случае разделение окна ведёт себя
как для @code{nil}.

@item display-buffer
Это означает, что когда @code{display-buffer} (@pxref{Choosing Window})
разбивает окно, всегда создается новое родительское окно.  В противном
случае разбиение окна ведет себя как для @code{nil}.

@item t
Это означает, что при разделении окна всегда создается новое родительское
окно.  Таким образом, если значение этой переменной всегда @code{t}, то
всегда каждое дерево окон является двоичным деревом (деревом, в котором
каждое окно, кроме корневого, имеет ровно одного брата).
@end table

По умолчанию @code{window-size}.  Остальные значения зарезервированы для
использования в будущем.

Если в результате установки этой переменной @code{split-window} создается
новое родительское окно, также вызывается
@code{set-window-combination-limit} (смотреть ниже) во вновь созданном
внутреннем окне.  Это влияет на то, как дерево окон перестраивается при
удалении дочерних окон (смотреть ниже).
@end defopt

  Если @code{window-combination-limit} установлено в @code{t}, разделение
@var{W2} в начальной конфигурации этого сценария привело бы к следующему:

@smallexample
@group
     ______________________________________
    | ____________________________________ |
    || __________________________________ ||
    |||                                  |||
    |||________________W2________________|||
    || __________________________________ ||
    |||                                  |||
    |||________________W4________________|||
    ||_________________W5_________________||
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||_________________W3_________________||
    |__________________W1__________________|

@end group
@end smallexample

@noindent
Создано новое внутреннее окно @var{W5}; его дочерними элементами являются
@var{W2} и новое окно активного изображения @var{W4}.  Теперь @var{W2} -
единственный родственник @var{W4}, поэтому при увеличении @var{W4} будет
пытаться уменьшиться @var{W2}, не затрагивая @var{W3}.  Обратить внимание,
что @var{W5} представляет собой вертикальную комбинацию двух окон,
встроенных в вертикальную комбинацию @var{W1}.

@cindex window combination limit
@defun set-window-combination-limit window limit
Функция устанавливает @dfn{предел комбинации} окна @var{window} в
@var{limit}.  Это значение можно получить с помощью функции
@code{window-combination-limit}.  Смотреть ниже такие эффекты; обратить
внимание, что это имеет значение только для внутренних окон.  Функция
@code{split-window} автоматически вызывает эту функцию, передавая ей
@code{t} как @var{limit}, при условии, что при ее вызове значение переменной
@code{window-combination-limit} установлено в @code{t}.
@end defun

@defun window-combination-limit window
Функция возвращает предел комбинации для @var{window}.

Предел комбинации имеет значение только для внутреннего окна.  Если это
@code{nil}, то Emacs может автоматически удалить @var{window} в ответ на
удаление окна, чтобы сгруппировать дочерние окна @var{window} с его
родственными окнами формируя новую комбинацию окон.  Если предел
комбинирования - @code{t}, дочерние окна @var{window} никогда автоматически
не объединяются с его братьями и сестрами.

Если в конфигурации, показанной в начале этого раздела, предел комбинации
@var{W4} (родительское окно @var{W6} и @var{W7}) устанавливается в @code{t},
удаление @var{W5} не приведет к неявному удалению @var{W4}.
@end defun

В качестве альтернативы, проблем, описанных выше, можно избежать, всегда
изменяя размер всех окон в одной и той же комбинации, когда одно из окон
разделяется или удаляется.  Это также позволяет разбивать окна, которые в
противном случае были бы слишком малы для такой операции.

@defopt window-combination-resize
Если эта переменная установлена в @code{nil}, @code{split-window}, то можно
разделить окно (обозначается @var{window}), только если область экрана
@var{window} достаточно велика, чтобы вместить как само окно, так и новое
окно.

Если эта переменная - @code{t}, @code{split-window} пытается изменить размер
всех окон, которые являются частью той же комбинации, что и @var{window},
чтобы приспособиться к новому окну.  В частности, это может позволить
@code{split-window} успешно работать, даже если @var{window} является окном
фиксированного размера или слишком маленьким для обычного разделения.  Более
того, последующее изменение размера или удаление @var{window} может изменить
размер всех других окон в его комбинации.

По умолчанию @code{nil}.  Остальные значения зарезервированы для
использования в будущем.  Конкретная операция разделения может игнорировать
значение этой переменной, если на нее влияет значение не-@code{nil}
@code{window-combination-limit}.
@end defopt

  Чтобы проиллюстрировать эффект @code{window-combination-resize},
рассмотривается следующий макет фрейма.

@smallexample
@group
     ______________________________________
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||_________________W2_________________||
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||_________________W3_________________||
    |__________________W1__________________|

@end group
@end smallexample

@noindent
Если @code{window-combination-resize} равен @code{nil}, разделение окна
@var{W3} оставляет размер @var{W2} неизменным:

@smallexample
@group
     ______________________________________
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||_________________W2_________________||
    | ____________________________________ |
    ||                                    ||
    ||_________________W3_________________||
    | ____________________________________ |
    ||                                    ||
    ||_________________W4_________________||
    |__________________W1__________________|

@end group
@end smallexample

@noindent
Если @code{window-combination-resize} равен @code{t}, при разделении
@var{W3} все три активных окна будут иметь примерно одинаковую высоту:

@smallexample
@group
     ______________________________________
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||_________________W2_________________||
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||_________________W3_________________||
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||_________________W4_________________||
    |__________________W1__________________|

@end group
@end smallexample

@noindent
Удаление любого из активных окон @var{W2}, @var{W3} или @var{W4}
распределяет его пространство пропорционально между двумя оставшимися
активными окнами.


@node Selecting Windows
@section Выбор Окон
@cindex selecting a window

@defun select-window window &optional norecord
Функция делает @var{window} выбранным окном, а окно выбранным в его фрейме
(@pxref{Basic Windows}) и выбирает этот фрейм.  Это также делает буфер
@var{window} (@pxref{Buffers and Windows}) текущим и устанавливает значение
этого буфера @code{point} равным значению @code{window-point}
(@pxref{Window Point}) в @var{window}.  @var{window} должно быть активным
окном.  Возвращаемое значение - @var{window}.

По умолчанию эта функция также перемещает буфер @var{window} в начало списка
буферов (@pxref{Buffer List}) и делает @var{window} самым последним
выбранным окном.  Если необязательный аргумент @var{norecord} -
не-@code{nil}, эти дополнительные действия не выполняются.

Кроме того, эта функция по умолчанию также сообщает механизму отображения
обновить отображение @var{window}, когда его фрейм будет повторно отображен
в следующий раз.  Если @var{norecord} равен не-@code{nil}, такие обновления
обычно не выполняются.  Если, однако, @var{norecord} равно специальному
символу @code{mark-for-redisplay}, дополнительные действия, упомянутые выше,
опускаются, но @var{window}, тем не менее, обновляется.

Обратить внимание, что иногда выбора окна недостаточно, чтобы отобразить его
или сделать его фрейм самым верхним фреймом на дисплее: также может
потребоваться поднять фрейм или убедиться, что фокус ввода направлен на этот
фрейм.
@xref{Input Focus}.
@end defun

@cindex select window hook
@cindex running a hook when a window gets selected
По историческим причинам Emacs не запускает отдельную ловушку всякий раз,
когда выбирается окно.  Приложения и внутренние процедуры часто временно
выбирают окно, чтобы выполнить с ним несколько действий.  Делают это либо
для упрощения кодирования - потому что многие функции по умолчанию работают
с выбранным окном, когда не указан аргумент @var{window} - либо потому, что
некоторые функции не принимают (и до сих пор не принимают) окно в качестве
аргумента и всегда работают с выбранным окном.  Запуск ловушки каждый раз,
когда окно выбирается на короткое время и еще раз, когда восстанавливается
ранее выбранное окно, бесполезно.

  Однако, когда аргумент @var{norecord} - @code{nil}, @code{select-window}
обновляет список буферов и, таким образом, косвенно запускает обычный
обработчик @code{buffer-list-update-hook} (@pxref{Buffer List}).
Следовательно, этот перехватчик обеспечивает разумный способ запуска функции
всякий раз, когда окно выбирается больше ``нормы''.

  Поскольку @code{buffer-list-update-hook} также запускается функциями, не
имеющими отношения к управлению окнами, обычно имеет смысл сохранить
где-нибудь значение выбранного окна и сравнить его со значением
@code{selected-window} при запуске этого перехватчика.  Кроме того, чтобы
избежать ложных срабатываний при использовании
@code{buffer-list-update-hook}, рекомендуется, чтобы каждый вызов
@code{select-window}, предназначенный для выбора окна, только временно
передавал аргумент не-@code{nil} @var{norecord}.  По возможности в таких
случаях следует использовать макрос @code{with-selected-window} (смотреть
ниже).

@cindex most recently selected windows
  Последовательность вызовов @code{select-window} с аргументом не-@code{nil}
@var{norecord} определяет порядок окон по времени их выбора.  Функцию
@code{get-lru-window} можно использовать для извлечения последнего
выбранного окна реального времени (@pxref{Cyclic Window Ordering}).

@defmac save-selected-window forms@dots{}
Макрос записывает выбранный фрейм, а также выбранное окно каждого фрейма,
последовательно выполняет @var{forms}, затем восстанавливает ранее выбранный
фрейм и окна.  Также сохраняет и восстанавливает текущий буфер. Возвращает
значение последней формы в @var{forms}.

Макрос ничего не сохраняет и не восстанавливает о размерах, расположении или
содержимом окон; поэтому, если @var{forms} их изменит, изменение
сохраняется.  Если ранее выбранное окно какого-либо фрейма больше не
работает во время выхода из @var{forms}, выбранное окно этого фрейма
остается в покое.  Если ранее выбранное окно больше не является активным, то
любое окно, выбранное в конце @var{forms}, остается выбранным.  Текущий
буфер восстанавливается тогда и только тогда, когда он все еще активен при
выходе из @var{forms}.

Макрос не изменяет ни порядок недавно выбранных окон, ни список буферов.
@end defmac

@defmac with-selected-window window forms@dots{}
Макрос выбирает @var{window}, последовательно выполняет @var{forms}, затем
восстанавливает ранее выбранное окно и текущий буфер.  Порядок недавно
выбранных окон и список буферов остаются неизменными, если намеренно не
измените их в @var{forms}; например, вызовом @code{select-window} с
аргументом @var{norecord} @code{nil}.  Следовательно, макрос является
предпочтительным способом временно работать с @var{window} как с выбранным
окном без ненужного запуска @code{buffer-list-update-hook}.
@end defmac

@defun frame-selected-window &optional frame
Функция возвращает окно на @var{frame}, которое выбрано в этом фрейме.
@var{frame} должен быть активным фреймом; если опущено или @code{nil}, по
умолчанию используется выбранный фрейм.
@end defun

@defun set-frame-selected-window frame window &optional norecord
Функция делает @var{window} окном, выбранным в фрейме @var{frame}.
@var{frame} должен быть активным фреймом; если @code{nil}, по умолчанию
используется выбранный фрейм.  @var{window} должно быть активным окном; если
@code{nil}, по умолчанию используется выбранное окно.

Если @var{frame} - это выбранный фрейм, это делает @var{window} выбранным
окном.

Если необязательный аргумент @var{norecord} - не-@code{nil}, эта функция не
изменяет ни список последних выбранных окон, ни список буферов.
@end defun

@cindex window use time
@cindex use time of window
@cindex window order by time of last use
@defun window-use-time &optional window
Функция возвращает время использования окна @var{window}.  @var{window}
должно быть активным окном и по умолчанию быть выбранным.

@dfn{Использованное время} окна на самом деле не является значением времени,
а целым числом, которое монотонно увеличивается с каждым вызовом
@code{select-window} с аргументом @code{nil} @var{norecord}.  Окно с
наименьшим временем использования обычно называется окном с наименьшим
временем использования, а окно с наибольшим временем использования
называется самым широко использованным окном
(@pxref{Cyclic Window Ordering}).
@end defun


@node Cyclic Window Ordering
@section Циклическое Упорядочение Окон
@cindex cyclic ordering of windows
@cindex ordering of windows, cyclic
@cindex window ordering, cyclic

  Когда используется команда @w{@kbd{C-x o}} (@code{other-window}) для
выбора другого окна, происходить перемещение пр активным окнам в
определенном порядке.  Для любой данной конфигурации окон этот порядок
никогда не меняется.  Порядок называется
@dfn{циклическое упорядочение окон}.

  Порядок определяется обходом в глубину дерева окон каждого фрейма,
извлекая активные окна, которые являются конечными узлами дерева
(@pxref{Windows and Frames}).  Если минибуфер активен, окно минибуфера также
включается.  Порядок циклический, поэтому за последним окном в
последовательности следует первое.

@defun next-window &optional window minibuf all-frames
@cindex minibuffer window, and @code{next-window}
Функция возвращает активное окно, следующее за @var{window} в циклическом
порядке окон.  @var{window} должно быть активным окном; если опущено или
@code{nil}, по умолчанию используется выбранное окно.

Необязательный аргумент @var{minibuf} указывает, должны ли окна минибуфера
быть включены в циклический порядок.  Обычно, когда @var{minibuf} равен
@code{nil}, окно минибуфера включается только в том случае, если оно в
настоящее время активно; это соответствует поведению @w{@kbd{C-x o}}.
(Обратить внимание, что окно минибуфера активно, пока используется его
минибуфер, смотреть @ref{Minibuffers}).

Если @var{minibuf} равен @code{t}, циклическое упорядочение включает все
окна минибуфера.  Если @var{minibuf} не является ни @code{t}, ни @code{nil},
окна минибуфера не включаются, даже если они активны.

Необязательный аргумент @var{all-frames} указывает, какие фреймы следует
учитывать:

@itemize @bullet
@item @code{nil}
значит считать окна на фрейме @var{window}.  Если рассматривается окно
минибуфера (как указано аргументом @var{minibuf}), то учитываются и фреймы,
совместно использующие окно минибуфера.

@item @code{t}
означает учитывать окна на всех существующих фреймах.

@item @code{visible}
означает учитывать окна на всех видимых фреймах.

@item 0
означает учитывать окна на всех видимых или иконизированных фреймах.

@item A frame
означает рассматривать окна в этом конкретном фрейме.

@item Anything else
значит считать окна на фрейме @var{window}, и никакие другие.
@end itemize

Если рассматривается более одного фрейма, циклический порядок получается
добавлением порядка для этих фреймов в том же порядке, что и список всех
активных фреймов (@pxref{Finding All Frames}).
@end defun

@defun previous-window &optional window minibuf all-frames
Функция возвращает активное окно, предшествующее @var{window} в циклическом
порядке окон.  Остальные аргументы обрабатываются как в @code{next-window}.
@end defun

@deffn Command other-window count &optional all-frames
Функция выбирает активное окно, размещает каждых @var{count} окон от
выбранного окна в циклическом порядке окон.  Если @var{count} -
положительное число, окна @var{count} пропускаются вперед; если @var{count}
отрицательно, окна @minus{}@var{count} пропускаются назад; если @var{count}
равно нулю, это просто повторно выбирает выбранное окно.  При интерактивном
вызове @var{count} является аргументом числового префикса.

Необязательный аргумент @var{all-frames} имеет то же значение, что и в
@code{next-window}, как аргумент @code{nil} @var{minibuf} для
@code{next-window}.

Функция не выбирает окно, которое имеет параметр окна не-@code{nil}
@code{no-other-window} (@pxref{Window Parameters}), при условии, что
@code{ignore-window-parameters} имеет значение @code{nil}.

Если параметр @code{other-window} выбранного окна является функцией, а
@code{ignore-window-parameters} - @code{nil}, функция будет вызываться с
аргументами @var{count} и @var{all-frames} вместо нормальной работы этой
функции.
@end deffn

@defun walk-windows fun &optional minibuf all-frames
Функция вызывает функцию @var{fun} один раз для каждого активного окна с
окном в качестве аргумента.

Это следует за циклическим порядком окон.  Необязательные аргументы
@var{minibuf} и @var{all-frames} определяют набор включаемых окон; они имеют
те же аргументы, что и в @code{next-window}.  Если @var{all-frames} задает
фрейм, первое пройденное окно будет первым окном в этом фрейме (возвращенным
@code{frame-first-window}), не обязательно выбранным окном.

Если @var{fun} изменяет конфигурацию окна, разделяя или удаляя окна, это не
меняет набор пройденных окон, который определяется перед вызовом @var{fun} в
первый раз.
@end defun

@defun one-window-p &optional no-mini all-frames
Функция возвращает @code{t}, если выбранное окно является единственным
активным окном, и @code{nil} в противном случае.

Если окно минибуфера активно, оно обычно считается (так что эта функция
возвращает @code{nil}).  Однако, если необязательный аргумент @var{no-mini}
равен не-@code{nil}, окно минибуфера игнорируется, даже если оно активно.
Необязательный аргумент @var{all-frames} имеет то же значение, что и
@code{next-window}.
@end defun

@cindex finding windows
  Следующие функции возвращают окно, которое удовлетворяет некоторому
критерию, не выбирая его:

@cindex least recently used window
@defun get-lru-window &optional all-frames dedicated not-selected
Функция возвращает активное окно, которое эвристически использовалось меньше
всего в последнее время.  Необязательный аргумент @var{all-frames} имеет то
же значение, что и в @code{next-window}.

Если есть какие-либо окна во всю ширину, учитываются только эти окна.  Окно
минибуфера никогда не является кандидатом.  Выделенное окно
(@pxref{Dedicated Windows}) никогда не является кандидатом, если
необязательный аргумент @var{dedicated} не равен не-@code{nil}.  Выбранное
окно никогда не возвращается, если только оно не является единственным
кандидатом.  Однако, если необязательный аргумент @var{not-selected} -
не-@code{nil}, функция в этом случае возвращает @code{nil}.
@end defun

@cindex most recently used window
@defun get-mru-window &optional all-frames dedicated not-selected
Функция похожа на @code{get-lru-window}, но вместо этого возвращает
последнее использованное окно.  Значение аргументов такое же, как описано
для @code{get-lru-window}.
@end defun

@cindex largest window
@defun get-largest-window &optional all-frames dedicated not-selected
Функция возвращает окно с наибольшей площадью (высота умноженная на ширину).
Необязательный аргумент @var{all-frames} указывает окна для поиска и имеет
то же значение, что и в @code{next-window}.

Окно минибуфера никогда не является кандидатом.  Выделенное окно
(@pxref{Dedicated Windows}) никогда не является кандидатом, если
необязательный аргумент @var{dedicated} не равен не-@code{nil}.  Выбранное
окно не является кандидатом, если необязательный аргумент @var{not-selected}
- не-@code{nil}.  Если необязательный аргумент @var{not-selected} равен
не-@code{nil} и выбранное окно является единственным кандидатом, функция
возвращает @code{nil}.

Если есть два окна-кандидата одинакового размера, функция предпочитает то,
которое идет первым в циклическом порядке окон, начиная с выбранного окна.
@end defun

@cindex window that satisfies a predicate
@cindex conditional selection of windows
@defun get-window-with-predicate predicate &optional minibuf all-frames default
Функция вызывает функцию @var{predicate} для каждого из окон в циклическом
порядке окон по очереди, передавая ей окно в качестве аргумента.  Если
предикат возвращает не-@code{nil} для любого окна, функция останавливается
и возвращает это окно.  Если такое окно не найдено, возвращается значение
@var{default} (по умолчанию - @code{nil}).

Необязательные аргументы @var{minibuf} и @var{all-frames} указывают окна для
поиска и имеют то же значение, что и в @code{next-window}.
@end defun


@node Buffers and Windows
@section Буферы и Окна
@cindex examining windows
@cindex windows, controlling precisely
@cindex buffers, controlled in windows

  В этом разделе описаны низкоуровневые функции для проверки и настройки
содержимого окон.  @xref{Switching Buffers}, для высокоуровневых функций
отображения определенного буфера в окне.

@defun window-buffer &optional window
Функция возвращает буфер, отображаемый @var{window}.  Если @var{window}
опущен или @code{nil}, по умолчанию используется выбранное окно.  Если
@var{window} - внутреннее окно, функция возвращает @code{nil}.
@end defun

@defun set-window-buffer window buffer-or-name &optional keep-margins
Функция заставляет @var{window} отображать @var{buffer-or-name}.
@var{window} должно быть активным окном; если @code{nil}, по умолчанию
используется выбранное окно.  @var{buffer-or-name} должен быть буфером или
именем существующего буфера.  Функция не меняет, какое окно выбрано, и не
меняет напрямую, какой буфер является текущим (@pxref{Current Buffer}).
Возвращаемое значение - @code{nil}.

Если @var{window} - это @dfn{строго предназначеное} для буфера, а
@var{buffer-or-name} не указывает этот буфер, функция сигнализирует об
ошибке.  @xref{Dedicated Windows}.

По умолчанию функция сбрасывает положение @var{window}, поля отображения,
ширину границ и настройки полосы прокрутки на основе локальных переменных в
указанном буфере.  Однако, если необязательный аргумент @var{keep-margins} -
не-@code{nil}, оставляются только параметры отображения полей, полос и
полосы прокрутки @var{window}.

При написании приложения обычно требуется использовать @code{display-buffer}
(@pxref{Choosing Window}) или функции более высокого уровня, описанные в
@ref{Switching Buffers}, вместо прямого вызова @code{set-window-buffer}.

Запускает @code{window-scroll-functions}, а затем
@code{window-configuration-change-hook}.  @xref{Window Hooks}.
@end defun

@defvar buffer-display-count
Локальная для буфера переменная записывает, сколько раз буфер отображался в
окне.  Увеличивается каждый раз, когда @code{set-window-buffer} вызывается
для буфера.
@end defvar

@defvar buffer-display-time
Локальная для буфера переменная записывает время, когда буфер последний раз
отображался в окне.  Значение @code{nil}, если буфер никогда не отображался.
Обновляется каждый раз, когда @code{set-window-buffer} вызывается для
буфера, со значением, возвращаемым @code{current-time}.
(@pxref{Time of Day}).
@end defvar

@defun get-buffer-window &optional buffer-or-name all-frames
Функция возвращает первое окно, отображающее @var{buffer-or-name} в
циклическом порядке окон, начиная с выбранного окна
(@pxref{Cyclic Window Ordering}).  Если такого окна нет, возвращаемое
значение - @code{nil}.

@var{buffer-or-name} должен быть буфером или именем буфера; если опущено или
@code{nil}, по умолчанию используется текущий буфер.  Необязательный
аргумент @var{all-frames} указывает, какие окна следует учитывать:

@itemize @bullet
@item
@code{t} означает учитывать окна на всех существующих фреймах.
@item
@code{visible} означает считать окна на всех видимых фреймах.
@item
0 означает, что окна учитываются во всех видимых или иконизированных
фреймах.
@item
frame означает рассматривать окна только в этом фрейме.
@item
Любое другое значение означает, что окна будут учитываться в
выбранном фрейме.
@end itemize

Обратить внимание, что эти значения немного отличаются от значений аргумента
@var{all-frames} для @code{next-window} (@pxref{Cyclic Window Ordering}).
Функция может быть изменена в будущей версии Emacs, чтобы устранить это
несоответствие.
@end defun

@defun get-buffer-window-list &optional buffer-or-name minibuf all-frames
Функция возвращает список всех окон, в которых в данный момент отображается
@var{buffer-or-name}.  @var{buffer-or-name} должен быть буфером или именем
существующего буфера.  Если опущено или @code{nil}, по умолчанию
используется текущий буфер.  Если в текущем выбранном окне отображается
@var{buffer-or-name}, оно будет первым в списке, возвращаемом этой функцией.

Аргументы @var{minibuf} и @var{all-frames} имеют то же значение, что и в
функции @code{next-window} (@pxref{Cyclic Window Ordering}).  Обратить
внимание, что аргумент @var{all-frames} ведет себя точно так же, как
аргумент @code{get-buffer-window}.
@end defun

@deffn Command replace-buffer-in-windows &optional buffer-or-name
Команда заменяет @var{buffer-or-name} каким-либо другим буфером во всех
окнах, отображающих его.  @var{buffer-or-name} должен быть буфером или
именем существующего буфера; если опущено или @code{nil}, по умолчанию
используется текущий буфер.

Буфер замены в каждом окне выбирается через @code{switch-to-prev-buffer}
(@pxref{Window History}).  Любое выделенное окно, отображающее
@var{buffer-or-name}, по возможности удаляется (@pxref{Dedicated Windows}).
Если такое окно является единственным окном в своем фрейме и на том же
терминале есть другие фреймы, фрейм также удаляется.  Если выделенное окно
является единственным окном в единственном фрейме на своем терминале, буфер
все равно заменяется.
@end deffn


@node Switching Buffers
@section Переключение на Буфер в Окне
@cindex switching to a buffer

В этом разделе описаны высокоуровневые функции для переключения на указанный
буфер в некотором окне.  В общем, ``переключение на буфер'' означает (1)
показать буфер в некотором окне, (2) сделать это окно выбранным окном (а его
фрейм - выбранным фреймом) и (3) сделать буфер текущим буфером.

  @emph{Не} использовать эти функции, чтобы временно сделать буфер текущим
только для того, чтобы программа на Lisp могла получить к нему доступ или
изменить.  У них есть побочные эффекты, такие как изменение истории окон
(@pxref{Window History}), что удивит пользователя, если использовать его
таким образом.  Если требуется сделать буфер текущим, чтобы изменить его в
Lisp, использовать @code{with-current-buffer}, @code{save-current-buffer}
или @code{set-buffer}.  @xref{Current Buffer}.

@deffn Command switch-to-buffer buffer-or-name &optional norecord force-same-window
Команда пытается отобразить @var{buffer-or-name} в выбранном окне и сделать
его текущим буфером.  Часто используется интерактивно (как привязка
@kbd{C-x b}), а также в программах Lisp.  Возвращаемое значение - это буфер,
на который был переключен.

Если @var{buffer-or-name} установлено @code{nil}, по умолчанию используется
буфер, возвращаемый @code{other-buffer} (@pxref{Buffer List}).  Если
@var{buffer-or-name} - строка, которая не является именем какого-либо
существующего буфера, функция создает новый буфер с этим именем; основной
режим нового буфера определяется переменной @code{major-mode}
(@pxref{Major Modes}).

Обычно указанный буфер помещается в начало списка буферов - как глобального
списка буферов, так и списка буферов выбранного фрейма
(@pxref{Buffer List}).  Однако этого не происходит, если необязательный
аргумент @var{norecord} установлен в не-@code{nil}.

Иногда выбранное окно может не подходить для отображения буфера.  Это
происходит, если выбранное окно является окном минибуфера, или если
выбранное окно строго предназначено для своего буфера
(@pxref{Dedicated Windows}).  В таких случаях команда обычно пытается
отобразить буфер в другом окне, вызывая @code{pop-to-buffer} (смотреть
ниже).

Если необязательный аргумент @var{force-same-window} - не-@code{nil} и
выбранное окно не подходит для отображения буфера, функция всегда
сигнализирует об ошибке при неинтерактивном вызове.  При интерактивном
использовании, если выбранное окно является окном минибуфера, функция вместо
этого попытается использовать какое-нибудь другое окно.  Если выбранное окно
строго предназначено для своего буфера, для продолжения можно использовать
опцию @code{switch-to-buffer-in-dedicated-window}, описанную далее.
@end deffn

@defopt switch-to-buffer-in-dedicated-window
Опция, если не-@code{nil}, позволяет @code{switch-to-buffer} продолжить
работу при интерактивном вызове, а выбранное окно строго предназначено для
своего буфера.

Соблюдаются следующие ценности:

@table @code
@item nil
Запрещает при неинтерактивном использовании переключение и сигнализирует об
ошибке. 

@item prompt
Запрашивает пользователя, разрешить ли переключение.

@item pop
Для продолжения вызывает @code{pop-to-buffer}.

@item t
Помечает выбранное окно как незанятое и продолжается.
@end table

Эта опция не влияет на неинтерактивные вызовы @code{switch-to-buffer}.
@end defopt

По умолчанию @code{switch-to-buffer} пытается сохранить @code{window-point}.
Это поведение можно настроить с помощью следующей опции.

@defopt switch-to-buffer-preserve-window-point
Если переменная - @code{nil}, @code{switch-to-buffer}, отображается буфер,
указанный @var{buffer-or-name}, в позиции этого буфера @code{point}.  Если
переменная - @code{already-displayed}, проводится попытка отобразить буфер в
его предыдущей позиции в выбранном окне, при условии, что буфер в настоящее
время отображается в каком-либо другом окне в любом видимом или
иконизированном кадре.  Если переменная - @code{t}, @code{switch-to-buffer},
безоговорочно пытается отобразить буфер в его предыдущей позиции в
выбранном окне.

Переменная игнорируется, если буфер уже отображается в выбранном окне или
никогда не появлялся в нем раньше, или если @code{switch-to-buffer} вызывает
@code{pop-to-buffer} для отображения буфера.
@end defopt

Следующие две команды аналогичны @code{switch-to-buffer}, за исключением
описанных функций.

@deffn Command switch-to-buffer-other-window buffer-or-name &optional norecord
Функция отображает буфер, указанный @var{buffer-or-name}, в каком-то окне,
отличном от выбранного.  Используется внутренняя функция
@code{pop-to-buffer} (смотреть ниже).

Если в выбранном окне уже отображается указанный буфер, продолжает
отображаться, но, тем не менее, обнаруживается другое окно, которое также
отображает его.

Аргументы @var{buffer-or-name} и @var{norecord} имеют то же значение, что и
аргументы @code{switch-to-buffer}.
@end deffn

@deffn Command switch-to-buffer-other-frame buffer-or-name &optional norecord
Функция отображает буфер, указанный @var{buffer-or-name}, в новом фрейме.
Используется внутренняя функция @code{pop-to-buffer} (смотреть ниже).

Если указанный буфер уже отображается в другом окне, в любом фрейме на
текущем терминале, происходит переключенин на это окно вместо создания
нового фрейма.  Однако выбранное окно никогда не используется для этого.

Аргументы @var{buffer-or-name} и @var{norecord} имеют то же значение, что и
аргументы @code{switch-to-buffer}.
@end deffn

Вышеупомянутые команды используют функцию @code{pop-to-buffer}, которая
гибко отображает буфер в каком-либо окне и выбирает это окно для
редактирования.  В свою очередь @code{pop-to-buffer} использует
@code{display-buffer} для отображения буфера.  Следовательно, все
переменные, влияющие на @code{display-buffer}, также будут влиять на него.
@xref{Choosing Window}, для документации @code{display-buffer}.

@deffn Command pop-to-buffer buffer-or-name &optional action norecord
Функция делает @var{buffer-or-name} текущим буфером и отображает его в
каком-то окне, желательно не в текущем выбранном окне.  Затем выбирается
отображаемое окно.  Если это окно находится в другом графическом фрейме,
этот фрейм получает фокус ввода, если возможно (@pxref{Input Focus}).

Если @var{buffer-or-name} равно @code{nil}, по умолчанию используется буфер,
возвращаемый @code{other-buffer} (@pxref{Buffer List}).  Если
@var{buffer-or-name} - строка, которая не является именем какого-либо
существующего буфера, функция создает новый буфер с этим именем; основной
режим нового буфера определяется переменной @code{major-mode}
(@pxref{Major Modes}).  В любом случае буфер становится текущим и
возвращается, даже если не найдено подходящего окна для его отображения.

Если @var{action} равен не-@code{nil}, это должно быть действие отображения,
которое нужно передать в @code{display-buffer} (@pxref{Choosing Window}).
В качестве альтернативы, не-@code{nil}, значение, не входящее в список,
означает переход в окно, отличное от выбранного, даже если буфер уже
отображается в выбранном окне.

Как и @code{switch-to-buffer}, эта функция обновляет список буферов, если
@var{norecord} отлично от не-@code{nil}.
@end deffn


@node Displaying Buffers
@section Отображение Буфера в Подходящем Окне
@cindex buffer display
@cindex displaying a buffer

В этом разделе описаны функции нижнего уровня, которые Emacs использует для
поиска или создания окна для отображения указанного буфера.  Общая рабочая
лошадка этих функций - @code{display-buffer}, которая в конечном итоге
обрабатывает все входящие запросы на отображение буфера
(@pxref{Choosing Window}).

   @code{display-buffer} делегирует задачу поиска подходящего окна так
называемым функциям действия (@pxref{Buffer Display Action Functions}).
Во-первых, @code{display-buffer} составляет так называемый список действий -
специальный список ассоциаций, функции действия которых могут использовать
для точной настройки своего поведения.  Затем передается этот список каждой
функции действия, которую вызывает (@pxref{Buffer Display Action Alists}).

   Поведение @code{display-buffer} легко настраивается.  Чтобы понять, как
настройки используются на практике, можно изучить примеры, иллюстрирующие
порядок приоритета, который @code{display-buffer} использует для вызова
функций действий (@pxref{Precedence of Action Functions}).  Чтобы избежать
конфликтов между программами на Lisp, вызывающими @code{display-buffer}, и
пользовательскими настройками поведения, может иметь смысл следовать ряду
рекомендаций, которые набросаны в заключительной части этого раздела
(@pxref{The Zen of Buffer Display}).

@menu
* Choosing Window::         Как выбрать окно для отображения буфера.
* Buffer Display Action Functions:: Функции поддержки для отображения буфера.
* Buffer Display Action Alists:: Списки для тонкой настройки отображения буфера.
* Choosing Window Options:: Дополнительные параметры, влияющие на отображение буферов.
* Precedence of Action Functions:: Примеры, объясняющие приоритет функций действий.
* The Zen of Buffer Display:: Как избежать потери буферов между окнами.
@end menu


@node Choosing Window
@subsection Выбор Окна для Отображения Буфера

Команда @code{display-buffer} гибко выбирает окно для отображения и
отображает указанный буфер в этом окне.  Её можно вызвать интерактивно,
через привязку клавиш @kbd{C-x 4 C-o}.  Также используется в качестве
подпрограммы многими функциями и командами, включая @code{switch-to-buffer}
и @code{pop-to-buffer} (@pxref{Switching Buffers}).

@cindex buffer display display action
@cindex display action
  Команда выполняет несколько сложных шагов, чтобы найти окно для
отображения.  Эти шаги описываются с помощью @dfn{display actions}, что
имеет форму @code{(@var{functions} . @var{alist})}.  Здесь @var{functions} -
это либо отдельная функция, либо список функций, называемых
``функциями действия'' (@pxref{Buffer Display Action Functions}); и
@var{alist} - это список ассоциаций, называемый ``списком действий''
(@pxref{Buffer Display Action Alists}).  @xref{The Zen of Buffer Display},
для примеров действий отображения.

  Функция действия принимает два аргумента: отображаемый буфер и список
действий.  Пытается отобразить буфер в каком-то окне, выбирая или создавая
окно в соответствии со своими критериями.  В случае успеха возвращается
окно, в противном случае возвращается @code{nil}.

  @code{display-buffer} работает, комбинируя действия отображения из
нескольких источников и вызывая функции действий по очереди, пока одна из
них не сможет отобразить буфер и не вернет значение не-@code{nil}.

@deffn Command display-buffer buffer-or-name &optional action frame
Команда заставляет @var{buffer-or-name} появляться в каком-либо окне, не
выбирая окно и не делая буфер текущим.  Аргумент @var{buffer-or-name} должен
быть буфером или именем существующего буфера.  Возвращаемое значение - это
окно, выбранное для отображения буфера, или @code{nil}, если подходящего
окна не найдено.

Необязательный аргумент @var{action}, если не-@code{nil}, обычно должен быть
действием отображения (описано выше).  @code{display-buffer} создает список
функций действий и список действий, объединяя действия отображения из
следующих источников (в порядке их приоритета, от высшего к низшему):

@itemize
@item
Переменная @code{display-buffer-overriding-action}.

@item
Пользовательская опция @code{display-buffer-alist}.

@item
Аргумент @var{action}.

@item
Пользовательская опция @code{display-buffer-base-action}.

@item
Константа @code{display-buffer-fallback-action}.
@end itemize

@noindent
На практике это означает, что @code{display-buffer} формирует список всех
функций действий, определенных этими действиями отображения.  Первый элемент
этого списка - первая функция действия, заданная
@code{display-buffer-overriding-action}, если таковая имеется.  Его
последний элемент - @code{display-buffer-pop-up-frame} --- последняя функция
действия, указанная в @code{display-buffer-fallback-action}.  Дубликаты не
удаляются из этого списка - следовательно, одна и та же функция действия
может вызываться несколько раз за один вызов @code{display-buffer}.

@code{display-buffer} по очереди вызывает функции действий, указанные в этом
списке, передавая буфер в качестве первого аргумента и объединенный список
действий в качестве второго аргумента, пока одна из функций не вернет
не-@code{nil}.  @xref{Precedence of Action Functions}, например, как
отображать действия, указанные из разных источников, обрабатываются
@code{display-buffer}.

Обратить внимание, что вторым аргументом всегда является список записей
списка @emph{всех} действий , заданный указанными выше источниками.
Следовательно, первый элемент этого списка - первая запись списка действий,
заданная @code{display-buffer-overriding-action}, если таковая имеется.  Его
последний элемент - это последняя запись в списке
@code{display-buffer-base-action}, если таковая имеется (список действий
@code{display-buffer-fallback-action} пуст).

Также обратить внимание, что объединенный список действий может содержать
повторяющиеся записи и записи для одного и того же ключа с разными
значениями.  Как правило, функции действий всегда используют первую
ассоциацию найденного ими ключа.  Следовательно, ассоциация, которую
использует функция действия, не обязательно является ассоциацией,
предоставляемой действием отображения, которое задает эту функцию действия.

Аргумент @var{action} также может иметь значение не-@code{nil}, не входящее  в список.  Это имеет особое значение, буфер должен отображаться в окне,
отличном от выбранного, даже если выбранное окно уже отображает его.  При
интерактивном вызове с аргументом префикса @var{action} будет @code{t}.
Программы Lisp всегда должны предоставлять значение списка.

Необязательный аргумент @var{frame}, если не-@code{nil}, указывает, какие
фреймы проверять при принятии решения о том, отображается ли уже буфер.  Это
эквивалентно добавлению элемента @w{@code{(reusable-frames. @var{frame})}} в
список действий @var{action} (@pxref{Buffer Display Action Alists}).
Аргумент @var{frame} предоставляется из соображений совместимости, программы
Lisp не должны его использовать.
@end deffn

@defvar display-buffer-overriding-action
Значением этой переменной должно быть действие отображения, которое
обрабатывается @code{display-buffer} с наивысшим приоритетом.  Значение по
умолчанию - пустое действие отображения, то есть @w{@code{(nil . nil)}}.
@end defvar

@defopt display-buffer-alist
Значение этой опции - список условий отображения для отображения действий.
Каждое условие может быть либо регулярным выражением, соответствующим имени
буфера, либо функцией, которая принимает два аргумента: имя буфера и
аргумент @var{action}, переданный в @code{display-buffer}.  Если либо имя
буфера, переданное в @code{display-buffer}, совпадает с регулярным
выражением в этом списке, либо функция, заданная условием, возвращает
не-@code{nil}, то @code{display-buffer} использует соответствующее действие
display для отображения буфера.
@end defopt

@defopt display-buffer-base-action
Значением этого параметра должно быть действие отображения.  Этот параметр
можно использовать для определения стандартного действия отображения для
вызовов @code{display-buffer}.
@end defopt

@defvr Constant display-buffer-fallback-action
Это действие отображения задает резервное поведение для
@code{display-buffer}, если не заданы другие действия отображения.
@end defvr


@node Buffer Display Action Functions
@subsection Функции Действий для Отображения Буфера
@cindex buffer display action function
@cindex action function, for buffer display

@dfn{Функция действия} - это функция, вызываемая @code{display-buffer} для
выбора окна для отображения буфера.  Функции действий принимают два
аргумента: @var{buffer}, отображаемый буфер, и @var{alist}, список действий
(@pxref{Buffer Display Action Alists}).  Должны возвращать окно,
отображающее @var{buffer} в случае успеха и @code{nil} в случае неудачи.

   В Emacs определены следующие основные функции действий.

@defun display-buffer-same-window buffer alist
Функция пытается отобразить @var{buffer} в выбранном окне.  Это не удается,
если выбранное окно является окном минибуфера или выделено для другого
буфера (@pxref{Dedicated Windows}).  Это также не удается, если @var{alist}
имеет запись не-@code{nil} @code{inhibit-same-window}.
@end defun

@defun display-buffer-reuse-window buffer alist
Функция пытается отобразить @var{buffer}, находя окно, в котором он уже
отображается.

Если @var{alist} имеет запись не-@code{nil} @code{inhibit-same-window},
выбранное окно не может быть использовано повторно.  Набор фреймов для
поиска окна, в котором уже отображается @var{buffer}, можно указать с
помощью записи @code{reusable-frames} action alist.  Если @var{alist} не
содержит записи @code{reusable-frames}, функция ищет только выбранный фрейм.

Если функция выбирает окно в другом фрейме, делает этот фрейм видимым и,
если @var{alist} не содержит запись @code{inhibit-switch-frame}, при
необходимости поднимает этот фрейм.
@end defun

@defun display-buffer-reuse-mode-window buffer alist
Функция пытается отобразить @var{buffer}, находя окно, отображающее буфер в
заданном режиме.

Если @var{alist} содержит запись @code{mode}, его значение определяет
основной режим (символ) или список основных режимов.  Если @var{alist} не
содержит записи @code{mode}, вместо этого используется текущий основной
режим @var{buffer}.  Окно является кандидатом, если оно отображает буфер,
режим которого является производным от одного из указанных таким образом
режимов.

Поведение также контролируется записями @var{alist} для
@code{inhibit-same-window}, @code{reusable-frames} и
@code{inhibit-switch-frame}, как это делает
@code{display-buffer-reuse-window}.
@end defun

@defun display-buffer-pop-up-window buffer alist
Функция пытается отобразить @var{buffer} путем разделения самого большого
или наименее использованного окна (обычно расположенного в выбранном
фрейме).  Фактически выполняется разделение, вызывая функцию, указанную в
@code{split-window-preferred-function} (@pxref{Choosing Window Options}).

Размер нового окна можно настроить, добавив записи @code{window-height} и
@code{window-width} в @var{alist}.  Если @var{alist} содержит запись
@code{preserve-size}, Emacs также попытается сохранить размер нового окна
во время будущих операций изменения размера
(@pxref{Preserving Window Sizes}).

Функция не работает, если ни одно окно не может быть разделено.  Чаще всего
это происходит из-за того, что ни одно окно не является достаточно большим,
чтобы позволить разделение.  В этом отношении может помочь установка более
низких значений @code{split-height-threshold} или
@code{split-width-threshold}.  Разделение также не выполняется, если
выбранный фрейм имеет параметр фрейма @code{unsplittable},
@pxref{Buffer Parameters}.
@end defun

@defun display-buffer-in-previous-window buffer alist
Функция пытается отобразить @var{buffer} в окне, в котором он отображался
ранее.

Если @var{alist} содержит запись не-@code{nil} @code{inhibit-same-window},
выбранное окно нельзя использовать.  Выделенное окно можно использовать,
только если оно уже показывает @var{buffer}.  Если @var{alist} содержит
запись @code{previous-window}, окно, указанное этой записью, можно
использовать, даже если оно никогда раньше не отображало @var{buffer}.

Если @var{alist} содержит запись @code{reusable-frames}
(@pxref{Buffer Display Action Alists}), его значение определяет, в каких
фреймах искать подходящее окно.  Если @var{alist} не содержит записи
@code{reusable-frames}, функция ищет только выбранный фрейм, если
@code{display-buffer-reuse-frames} и @code{pop-up-frames} оба являются
@code{nil}; ищутся все фреймы на текущем терминале, если любая из этих
переменных имеет значение не-@code{nil}.

Если более одного окна квалифицируется как пригодное для использования в
соответствии с этими правилами, эта функция делает выбор в следующем порядке
предпочтения:

@itemize @bullet
@item
Окно, указанное любой записью @code{previous-window} @var{alist}, при
условии, что это не выбранное окно.

@item
Окно, которое раньше показывало @var{buffer}, при условии, что это не
выбранное окно.

@item
Выбранное окно, если оно либо указано записью @code{previous-window}
@var{alist}, либо ранее показывало @var{buffer}.
@end itemize
@end defun

@defun display-buffer-use-some-window buffer alist
Функция пытается отобразить @var{buffer}, выбирая существующее окно и
отображая буфер в этом окне.  Может произойти сбой, если все окна
предназначены для других буферов.  (@pxref{Dedicated Windows}).
@end defun

@defun display-buffer-below-selected buffer alist
Функция пытается отобразить @var{buffer} в окне под выбранным окном.  Если
под выбранным есть окно, и в этом окне уже отображается @var{buffer}, оно
повторно использует это окно.

Если такого окна нет, функция пытается создать новое окно, разделив
выбранное, и отображает там @var{buffer}.  Также попытается отрегулировать
размер этого окна при условии, что @var{alist} содержит подходящую запись
@code{window-height} или @code{window-width}, смотреть выше.

Если разделение выбранного окна не удается, а под выбранным есть не
выделенное окно, показывающее какой-либо другой буфер, функция пытается
использовать это окно для отображения @var{buffer}.
@end defun

@defun display-buffer-at-bottom buffer alist
Эта функция пытается отобразить @var{buffer} в окне внизу выбранного фрейма.

Это либо пытается разделить окно в нижней части фрейма, либо в корневом окне
фрейма, либо повторно использовать существующее окно в нижней части
выбранного фрейма.
@end defun

@defun display-buffer-pop-up-frame buffer alist
Функция создает новый фрейм и отображает буфер в окне этого фрейма.
Фактически он выполняет создание фрейма, вызывая функцию, указанную в
@code{pop-up-frame-function} (@pxref{Choosing Window Options}).  Если
@var{alist} содержит запись @code{pop-up-frame-parameters}, соответствующее
значение добавляется к параметрам вновь созданного фрейма.
@end defun

@defun display-buffer-in-child-frame buffer alist
Функция пытается отобразить @var{buffer} в дочернем фрейме
(@pxref{Child Frames}) выбранного фрейма, либо повторно используя
существующий дочерний фрейм, либо создавая новый.  Если @var{alist} имеет
запись не-@code{nil} @code{child-frame-parameters}, соответствующее значение
представляет собой список параметров фрейма для получения нового фрейма.
Параметр @code{parent-frame}, указывающий выбранный фрейм, предоставляется
по умолчанию.  Если дочерний фрейм должен стать потомком другого фрейма,
соответствующая запись должна быть добавлена в @var{alist}.

Внешний вид дочерних фреймов во многом зависит от параметров,
предоставленных через @var{alist}.  Рекомендуется использовать как минимум
отношения, чтобы указать размер (@pxref{Size Parameters}) и положение
(@pxref{Position Parameters}) дочернего кадра, а также добавить параметр
@code{keep-ratio} (@pxref{Frame Interaction Parameters}), чтобы убедиться,
что дочерний фрейм остается видимым.  Для других параметров, которые следует
учитывать смотреть @ref{Child Frames}.
@end defun

@defun display-buffer-use-some-frame buffer alist
Функция пытается отобразить @var{buffer}, находя фрейм, который
соответствует предикату (по умолчанию любой фрейм, кроме выбранного фрейма).

Если функция выбирает окно в другом фрейме, она делает этот фрейм видимым и,
если @var{alist} не содержит запись @code{inhibit-switch-frame}, при
необходимости поднимает этот фрейм.

Если @var{alist} имеет запись не-@code{nil} @code{frame-predicate}, ее
значением является функция, принимающая один аргумент (фрейм), возвращающая
не-@code{nil}, если фрейм является кандидатом; эта функция заменяет
предикат по умолчанию.

Если @var{alist} имеет запись не-@code{nil} @code{inhibit-same-window},
выбранное окно не используется; таким образом, если в выбранном фрейме есть
одно окно, оно не используется.
@end defun

@defun display-buffer-no-window buffer alist
Если @var{alist} имеет запись не-@code{nil} @code{allow-no-window}, то
функция не отображает @var{buffer} и возвращает символ @code{fail}.  Это
составляет единственное исключение из соглашения, согласно которому функция
действия возвращает либо @code{nil}, либо окно, показывающее @var{buffer}.
Если @var{alist} не имеет такой записи @code{allow-no-window}, функция
возвращает @code{nil}.

Если функция возвращает @code{fail}, @code{display-buffer} пропустит
выполнение любых дальнейших действий по отображению и немедленно вернет
@code{nil}.  Если эта функция возвращает @code{nil}, @code{display-buffer}
продолжит выполнение следующего действия по отображению, если таковое
имеется.

Предполагается, что когда вызывающий @code{display-buffer} указывает запись
не-@code{nil} @code{allow-no-window}, также может обрабатывать возвращаемое
значение @code{nil}.
@end defun

Две другие функции действий описаны в соответствующих разделах ---
@code{display-buffer-in-side-window}
(@pxref{Displaying Buffers in Side Windows}) и
@code{display-buffer-in-atom-window} (@pxref{Atomic Windows}).


@node Buffer Display Action Alists
@subsection Списки Действий для Отображения Буфера
@cindex buffer display action alist
@cindex action alist for buffer display

@dfn{Список действий} - это список ассоциаций, отображающий предопределенные
символы, распознаваемые функциями действий, на значения, которые эти функции
должны интерпретировать соответствующим образом.  В каждом вызове
@code{display-buffer} создает новый, возможно, пустой список действий и
передает весь этот список любой вызываемой им функции действия.

   По замыслу, функции действий могут свободно интерпретировать записи
списка действий.  Фактически, некоторые записи, такие как
@code{allow-no-window} или @code{previous-window}, имеют значение только для
одной или нескольких функций действий и игнорируются остальными.  Другие
записи, такие как @code{inhibit-same-window} или @code{window-parameters},
должны соблюдаться большинством функций действий, включая те, которые
предоставляются прикладными программами и внешними пакетами.

   В предыдущем подразделе подробно описано, как отдельные функции действий
интерпретируют записи списка действий, которые им важны.  Здесь даётся
справочный список всех известных записей списков действий в соответствии с
их символами, вместе с их значениями и функциями действий
(@pxref{Buffer Display Action Functions}), которые их распознают.  В этом
списке термины ``буфер'' будут относиться к буферу, который должен
отображать @code{display-buffer}, а ``значение'' - к значению записи.

@table @code
@vindex inhibit-same-window@r{, запись списка действий отображения буфера}
@item inhibit-same-window
Если значение равно не-@code{nil}, это сигнализирует, что выбранное окно не
должно использоваться для отображения буфера.  Все функции действий, которые
(повторно) используют существующее окно, должны учитывать эту запись.

@vindex previous-window@r{, запись списка действий отображения буфера}
@item previous-window
Значение должно указывать окно, которое могло ранее отображать буфер.
@code{display-buffer-in-previous-window} отдаст предпочтение такому окну,
если оно все еще активно и не предназначено для другого буфера.

@vindex mode@r{, запись списка действий отображения буфера}
@item mode
Значение - это либо основной режим, либо список основных режимов.
@code{display-buffer-reuse-mode-window} может повторно использовать окно
всякий раз, когда значение, указанное в этой записи, совпадает с основным
режимом буфера этого окна.  Другие функции действий игнорируют такие записи.

@vindex frame-predicate@r{, запись списка действий отображения буфера}
@item frame-predicate
Значение должно быть функцией, принимающей один аргумент (фрейм), которая
должна возвращать не-@code{nil}, если этот фрейм является кандидатом для
отображения буфера.  Эта запись используется
@code{display-buffer-use-some-frame}.

@vindex reusable-frames@r{, запись списка действий отображения буфера}
@item reusable-frames
Значение указывает набор фреймов для поиска окна, которое можно использовать
повторно, поскольку в нем уже отображается буфер.  Это можно установить
следующим образом:

@itemize @bullet
@item
@code{nil} означает, что рассматривать только окна в выбранном фрейме.
(Фактически, последний использованный фрейм, который не является фреймом
только для минибуфера.)
@item
@code{t} означает считать окна на всех фреймах.
@item
@code{visible} означает считать окна на всех видимых фреймах.
@item
0 означает учитывать окна на всех видимых или иконизированных фреймах.
@item
Фрейм означает рассматривать окна только в этом фрейме.
@end itemize

Обратить внимание, что значение @code{nil} немного отличается от значения
аргумента @var{all-frames} для @code{next-window}
(@pxref{Cyclic Window Ordering}).

Основным клиентом этого является @code{display-buffer-reuse-window}, но все
другие функции действий, которые пытаются повторно использовать окно, также
затрагиваются.  @code{display-buffer-in-previous-window} обращается к нему
при поиске окна, которое ранее отображало буфер в другом кадре.

@vindex inhibit-switch-frame@r{, запись списка действий отображения буфера}
@item inhibit-switch-frame
Значение не-@code{nil} предотвращает поднятие или выделение другого фрейма,
если там отображается окно, выбранное @code{display-buffer}.  В первую
очередь это влияет на @code{display-buffer-use-some-frame} и
@code{display-buffer-reuse-window}.  @code{display-buffer-pop-up-frame}
также должно быть затронуто, но нет гарантии, что оконный менеджер будет
соответствовать.

@vindex window-parameters@r{, a buffer display action alist entry}
@item window-parameters
Значение указывает список параметров окна, чтобы получить выбранное окно.
Все функции действий, которые выбирают окно, должны обрабатывать эту запись.

@vindex window-height@r{, a buffer display action alist entry}
@item window-height
Значение указывает, нужно ли и как регулировать высоту выбранного окна, и
может быть одно из следующих:

@itemize @bullet
@item
@code{nil} означает оставить высоту выбранного окна без изменений.

@item
Целое число определяет желаемую общую высоту выбранного окна в строках.

@item
Число с плавающей запятой указывает долю желаемой общей высоты выбранного
окна по отношению к общей высоте корневого окна его фрейма.

@item
Если значение определяет функцию, эта функция вызывается с одним аргументом
- выбранным окном.  Функция предназначена для регулировки высоты окна; его
возвращаемое значение игнорируется.  Подходящие функции:
@code{shrink-window-if-larger-than-buffer} и @code{fit-window-to-buffer},
смотреть @ref{Resizing Windows}.
@end itemize

По соглашению, высота выбранного окна регулируется только в том случае, если
окно является частью вертикальной комбинации (@pxref{Windows and Frames}),
чтобы избежать изменения высоты других, не связанных между собой окон.
Кроме того, эта запись должна обрабатываться только при определенных
условиях, которые указаны прямо под этим списком.

@vindex window-width@r{, a buffer display action alist entry}
@item window-width
Запись похожа на запись @code{window-height}, описанная ранее, но вместо
этого используется для настройки ширины выбранного окна.  Значение может
быть одним из следующих:

@itemize @bullet
@item
@code{nil} означает оставить только ширину выбранного окна.

@item
Целое число определяет желаемую общую ширину выбранного окна в столбцах.

@item
Число с плавающей запятой указывает долю желаемой общей ширины выбранного
окна по отношению к общей ширине корневого окна фрейма.

@item
Если значение определяет функцию, эта функция вызывается с одним аргументом
- выбранным окном.  Функция предназначена для регулировки ширины окна; его
возвращаемое значение игнорируется.
@end itemize

По соглашению, ширина выбранного окна регулируется только в том случае, если
окно является частью горизонтальной комбинации (@pxref{Windows and Frames}),
чтобы избежать изменения ширины других, не связанных между собой окон.
Кроме того, эта запись должна обрабатываться только при определенных
условиях, которые указаны прямо под этим списком.

@vindex preserve-size@r{, запись списка действий отображения буфера}
@item preserve-size
Если не-@code{nil}, такая запись говорит Emacs сохранить размер окна,
выбранного (@pxref{Preserving Window Sizes}).  Значение должно быть либо
@w{@code{(t . nil)}}, чтобы сохранить ширину окна, либо
@w{@code{(nil . t)}}, чтобы сохранить его высоту, либо @w{@code{(t . t)}},
чтобы сохранить его ширину и высоту.  Эта запись должна обрабатываться
только при определенных условиях, которые указаны сразу после этого списка.

@vindex pop-up-frame-parameters@r{, a buffer display action alist entry}
@item pop-up-frame-parameters
Значение определяет список параметров фрейма для создания нового фрейма,
если он создан.  @code{display-buffer-pop-up-frame} - его единственный
адресат.

@vindex parent-frame@r{, запись списка действий отображения буфера}
@item parent-frame
Значение указывает родительский фрейм, который будет использоваться при
отображении буфера в дочернем фрейме.  Эта запись используется только
@code{display-buffer-in-child-frame}.

@vindex child-frame-parameters@r{, запись списка действий отображения буфера}
@item child-frame-parameters
Значение определяет список параметров фрейма, которые будут использоваться
при отображении буфера в дочернем фрейме.  Эта запись используется только
@code{display-buffer-in-child-frame}.

@vindex side@r{, запись списка действий отображения буфера}
@item side
Значение обозначает сторону фрейма или окна, где должно быть создано новое
окно, отображающее буфер.  Эта запись используется
@code{display-buffer-in-side-window} для указания стороны фрейма, где должно
быть размещено новое боковое окно
(@pxref{Displaying Buffers in Side Windows}).  Также используется
@code{display-buffer-in-atom-window} для указания стороны существующего
окна, где должно располагаться новое окно (@pxref{Atomic Windows}).

@vindex slot@r{, запись списка действий отображения буфера}
@item slot
Если не-@code{nil}, значение указывает слот бокового окна, которое должно
отображать буфер.  Эта запись используется только
@code{display-buffer-in-side-window}.

@vindex window@r{, запись списка действий отображения буфера}
@item window
Значение определяет окно, которое каким-то образом связано с окном,
выбранным @code{display-buffer}.  Эта запись в настоящее время используется
@code{display-buffer-in-atom-window} для указания окна, на чьей стороне
должно быть создано новое окно.

@vindex allow-no-window@r{, запись списка действий отображения буфера}
@item allow-no-window
Если значение равно не-@code{nil}, @code{display-buffer} не обязательно
должен отображать буфер, и вызывающая сторона готова принять это.  Эта
запись не предназначена для пользовательских настроек, поскольку нет
гарантии, что произвольный вызывающий @code{display-buffer} сможет
обработать случай, когда ни одно окно не будет отображать буфер.
@code{display-buffer-no-window} - единственная функция действия, которая
заботится об этой записи.
@end table

По соглашению, записи @code{window-height}, @code{window-width} и
@code{preserve-size} применяются после того, как буфер выбранного окна был
установлен, и тогда и только тогда, когда это окно никогда раньше не
показывало другой буфер.  Точнее, последнее означает, что окно должно быть
либо создано текущим вызовом @code{display-buffer}, либо окно было создано
ранее @code{display-buffer} для отображения буфера и никогда не
использовалось для отображения другого буфера, пока оно не было повторно
использовано текущим вызовом @code{display-buffer}.


@node Choosing Window Options
@subsection Дополнительные Параметры для Отображения Буферов

Поведение действий отображения буфера (@pxref{Choosing Window}) может быть
дополнительно изменено следующими пользовательскими опциями.

@defopt pop-up-windows
Если значение этой переменной - не-@code{nil}, @code{display-buffer} может
разделить существующее окно, чтобы создать новое окно для отображения.  Это
значение по умолчанию.

Эта переменная предоставляется только для обратной совместимости.
Подчиняется @code{display-buffer} через специальный механизм в
@code{display-buffer-fallback-action}, который вызывает функцию действия
@code{display-buffer-pop-up-window}
(@pxref{Buffer Display Action Functions}), когда значение этой опции равно
не-@code{nil}.  Самостоятельно @code{display-buffer-pop-up-window} не
обращается, пользователь может указать непосредственно в
@code{display-buffer-alist} и так далее.
@end defopt

@defopt split-window-preferred-function
Эта переменная определяет функцию разделения окна, чтобы создать новое окно
для отображения буфера.  Используется функцией действия
@code{display-buffer-pop-up-window} для фактического разделения окна.

Значение должно быть функцией, которая принимает один аргумент, окно, и
возвращает либо новое окно (которое будет использоваться для отображения
желаемого буфера), либо @code{nil} (что означает сбой разделения).  Значение
по умолчанию - @code{split-window-sensibly}, которое задокументировано
далее.
@end defopt

@defun split-window-sensibly &optional window
Функция пытается разделить @var{window} и вернуть вновь созданное окно.
Если @var{window} нельзя разделить, возвращается @code{nil}.  Если
@var{window} опущен или @code{nil}, по умолчанию используется выбранное
окно.

Функция подчиняется обычным правилам, которые определяют, когда окно может
быть разделено (@pxref{Splitting Windows}).  Сначала проводится попытка
разделить, помещая новое окно ниже, с учетом ограничения, наложенного
@code{split-height-threshold} (смотреть ниже), в дополнение к любым другим
ограничениям.  Если это не удается, следует попытка разделить, помещая новое
окно справа, в зависимости от @code{split-width-threshold} (смотреть ниже).
Если это тоже не удается, и окно является единственным окном во фрейме, эта
функция снова пытается разделить и разместить новое окно ниже, игнорируя
@code{split-height-threshold}.  Если и это не удается, функция прекращает
работу и возвращает @code{nil}.
@end defun

@defopt split-height-threshold
Переменная определяет, разрешено ли @code{split-window-sensibly} разделить
окно, разместив новое окно ниже.  Если указано целое число, это означает
разделение только в том случае, если в исходном окне есть такое количество
строк.  Если @code{nil}, значит, не разделять таким образом.
@end defopt

@defopt split-width-threshold
Переменная определяет, разрешено ли @code{split-window-sensibly} разбивать
окно, помещая новое окно вправо.  Если значение является целым числом, это
означает разделение только в том случае, если исходное окно имеет как
минимум такое же количество столбцов.  Если значение равно @code{nil}, это
означает, что таким образом не разбивать.
@end defopt

@defopt even-window-sizes
Эта переменная, если не-@code{nil}, заставляет @code{display-buffer}
выравнивать размеры окна всякий раз, когда он повторно использует
существующее окно, и это окно находится рядом с выбранным.

Если значение - @code{width-only}, размеры выравниваются только в том
случае, если повторно используемое окно находится слева или справа от
выбранного, а выбранное окно шире, чем повторно используемое.  Если значение
- @code{height-only}, размеры выравниваются только в том случае, если
повторно используемое окно находится выше или ниже выбранного окна, а
выбранное окно выше повторно используемого.  Любое другое значение 
не-@code{nil} означает выравнивание размеров в любом из этих случаев при
условии, что выбранное окно больше повторно используемого в смысле их
комбинации.
@end defopt

@defopt pop-up-frames
Если значение этой переменной - не-@code{nil}, это означает, что
@code{display-buffer} может отображать буферы, создавая новые фреймы.  По
умолчанию - @code{nil}.

Значение не-@code{nil} также означает, что когда @code{display-buffer} ищет
окно, уже отображающее @var{buffer-or-name}, может искать любой видимый или
иконизированный фрейм, а не только выбранный фрейм.

Переменная предоставляется в основном для обратной совместимости.  Ей
подчиняется @code{display-buffer} через специальный механизм в
@code{display-buffer-fallback-action}, который вызывает функцию действия
@code{display-buffer-pop-up-frame}
(@pxref{Buffer Display Action Functions}), если значение равно
не-@code{nil}.  (Это делается перед попыткой разбить окно.)  Сам
@code{display-buffer-pop-up-frame} не обращается к этой переменной, которую
пользователь может указать непосредственно в @code{display-buffer-alist} и
так далее.
@end defopt

@defopt pop-up-frame-function
Переменная определяет функцию для создания нового фрейма, чтобы создать
новое окно для отображения буфера.  Используется функцией действия
@code{display-buffer-pop-up-frame}.

Значение должно быть функцией, которая не принимает аргументов и возвращает
фрейм, или @code{nil}, если фрейм не может быть создан.  Значение по
умолчанию - функция, которая создает фрейм, используя параметры, указанные в
@code{pop-up-frame-alist} (смотреть ниже.).
@end defopt

@defopt pop-up-frame-alist
Переменная содержит список параметров фрейма (@pxref{Frame Parameters}),
который используется функцией, заданной @code{pop-up-frame-function}, для
создания нового фрейма.  По умолчанию - @code{nil}.

Опция предусмотрена только для обратной совместимости.  Обратить внимание,
что когда @code{display-buffer-pop-up-frame} вызывает функцию, указанную в
@code{pop-up-frame-function}, добавляется значение всех записей списка
действий @code{pop-up-frame-parameters} к @code{pop-up-frame-alist}, так что
значения, указанные в записи списка действий, эффективно переопределяют
любые соответствующие значения @code{pop-up-frame-alist}.

Следовательно, пользователи должны настроить запись
@code{pop-up-frame-parameters} action alist в @code{display-buffer-alist}
вместо настройки @code{pop-up-frame-alist}.  Только это гарантирует, что
значение параметра, указанного пользователем, переопределяет значение этого
параметра, указанное вызывающим объектом @code{display-buffer}.
@end defopt

   При разработке @code{display-buffer} было приложено много усилий для
обеспечения совместимости с кодом, который использует более старые
параметры, такие как @code{pop-up-windows}, @code{pop-up-frames},
@code{pop-up-frame-alist}, @code{same-window-buffer-names} и
@code{same-window-regexps}.  Lisp Программы и пользователи должны
воздерживаться от использования этих параметров.  Выше уже предостерегалось
от настройки @code{pop-up-frame-alist}.  Здесь описывается, как
преобразовать оставшиеся параметры для использования вместо них действий
отображения.

@table @code
@item pop-up-windows
@vindex pop-up-windows@r{, замена}
По умолчанию переменная установлена в @code{t}.  Вместо того, чтобы
настраивать её в @code{nil} и, таким образом, указывать
@code{display-buffer}, чего не следует делать, гораздо лучше перечислить в
@code{display-buffer-base-action} функции действий, которые должны
попробоваться вместо этого, например:

@example
@group
(customize-set-variable
 'display-buffer-base-action
 '((display-buffer-reuse-window display-buffer-same-window
    display-buffer-in-previous-window
    display-buffer-use-some-window)))
@end group
@end example

@item pop-up-frames
@vindex pop-up-frames@r{, замена}
Вместо того, чтобы настраивать эту переменную в @code{t}, настраивается
@code{display-buffer-base-action}, например, следующим образом:

@example
@group
(customize-set-variable
 'display-buffer-base-action
 '((display-buffer-reuse-window display-buffer-pop-up-frame)
   (reusable-frames . 0)))
@end group
@end example

@item same-window-buffer-names
@itemx same-window-regexps
@vindex same-window-buffer-names@r{, замена}
@vindex same-window-regexps@r{, замена}
Вместо добавления имени буфера или регулярного выражения к одному из этих
параметров используется запись @code{display-buffer-alist} для этого буфера,
определяющая функцию действия @code{display-buffer-same-window}.

@example
@group
(customize-set-variable
 'display-buffer-alist
 (cons '("\\*foo\\*" (display-buffer-same-window))
        display-buffer-alist))
@end group
@end example
@end table


@node Precedence of Action Functions
@subsection Приоритет Функций Действий
@cindex precedence of buffer display action functions
@cindex execution order of buffer display action functions
@cindex buffer display action functions, precedence

Из предыдущих подразделов известно, что @code{display-buffer} должно быть
снабжено рядом действий отображения (@pxref{Choosing Window}) для
отображения буфера.  В полностью ненастроенном Emacs эти действия задаются
@code{display-buffer-fallback-action} в следующем порядке приоритета:
повторно использовать окно, выскакивается новое окно в том же фрейме,
использовать окно, ранее показывающее буфер, использовать какое-то окно и
выбрасывать новый фрейм.  (Обратить внимание, что остальные действия,
названные @code{display-buffer-fallback-action}, недействительны в
ненастроенном Emacs).

Рассматривается следующая форма:

@example
(display-buffer (get-buffer-create "*foo*"))
@end example

@noindent
При оценке этой формы в буфере @file{*scratch*} ненастроенного сеанса Emacs
обычно не удается повторно использовать окно, в котором уже отображается
@file{*foo*}, но появляется новое окно.  Повторная оценка той же формы
теперь не вызовет никаких видимых изменений - @code{display-buffer} повторно
использовал окно, уже показывающее @file{*foo*}, потому что это действие
было применимо и имело наивысший приоритет среди всех применимых действий.

   Выбросить новое окно не удастся, если в выбранном фрейме недостаточно
места.  В ненастроенном Emacs это обычно не работает, когда во фрейме уже
есть два окна.  Например, если еперь набрать @w{@kbd{C-x 1}}, а затем
@w{@kbd{C-x 2}} и еще раз оценить форму, @file{*foo*} должен появиться в
нижнем окне --- @code{display-buffer} только что ``немного'' использованное
окно.  Если бы перед вводом @w{@kbd{C-x 2}} набрать @w{@kbd{C-x o}},
@file{*foo*}, отображался бы в верхнем окне, потому что ``немного'' использованное окно обозначает окно ``наименее недавно использованное'', а выбранное
окно использовалось меньше всего в том и только том случае, если оно
находится в том же фрейме.

   Предположим, не набрано @w{@kbd{C-x o}} и @file{*foo*}, это показано в
нижнем окне.  Вводится @w{@kbd{C-x o}}, чтобы попасть туда, затем
@w{@kbd{C-x left}} и снова оценивается форма.  Должно отображать
@file{*foo*} в том же нижнем окне, потому что это окно уже показывало
@file{*foo*} ранее и поэтому было выбрано вместо какого-либо другого окна.

  До сих пор наблюдалось только поведение по умолчанию в ненастроенном
сеансе Emacs.  Чтобы увидеть, как это поведение можно настроить,
рассматривается параметр @code{display-buffer-base-action}.  Он обеспечивает
очень грубую настройку, которая концептуально влияет на отображение @emph{любого} буфера.  Можно использовать для дополнения действий, предоставляемых
@code{display-buffer-fallback-action}, путем их переупорядочивания или
добавления действий, которых там нет, но которые больше соответствуют
практике редактирования пользователя.  Однако его также можно использовать
для более глубокого изменения поведения по умолчанию.

   Рассмотрим пользователя, который, как правило, предпочитает отображать
буферы на другом фрейме.  Такой пользователь может предоставить следующую
настройку:

@example
@group
(customize-set-variable
 'display-buffer-base-action
 '((display-buffer-reuse-window display-buffer-pop-up-frame)
   (reusable-frames . 0)))
@end group
@end example

@noindent
Параметр указывает @code{display-buffer} сначала попытаться найти окно,
показывающее буфер в видимом или иконизированном фрейме, и, если такого
фрейма не существует, отобразит новый фрейм.  Можно наблюдать это поведение
в графической системе, набрав @w{@kbd{C-x 1}} в окне, показывающем
@file{*scratch*}, и оценив каноническую форму @code{display-buffer}.  Обычно
создает (и дает фокус) новый фрейм, в корневом окне которого отображается
@file{*foo*}.  Преобразовать этот фрейм в иконку и снова оценить
каноническую форму: @code{display-buffer} будет повторно использовать окно в
новом фрейме (обычно поднимая фрейм и уделяя ему фокус).

   Только в случае сбоя создания нового фрейма @code{display-buffer}
применит действия, предоставленные @code{display-buffer-fallback-action},
что означает повторную попытку повторного использования окна, появление
нового окна и так далее.  Тривиальный способ сделать невозможным создание
фрейма можно с помощью следующей формы:

@example
@group
(let ((pop-up-frame-function 'ignore))
  (display-buffer (get-buffer-create "*foo*")))
@end group
@end example

@noindent
Забыть об этой форме сразу после того, как видно, что она не может создать
новый фрейм и вместо этого использовать резервное действие.

   Обратить внимание, что @code{display-buffer-reuse-window} кажется
излишним при настройке @code{display-buffer-base-action}, потому что уже
является частью @code{display-buffer-fallback-action} и в любом случае это
следует попробовать.  Однако не получится, потому что из-за приоритета
@code{display-buffer-base-action} над @code{display-buffer-fallback-action},
в то время @code{display-buffer-pop-up-frame} уже выиграл гонку.  На самом
деле:

@example
@group
(customize-set-variable
 'display-buffer-base-action
 '(display-buffer-pop-up-frame (reusable-frames . 0)))
@end group
@end example

@noindent
приведет к тому, что @code{display-buffer} @emph{всегда} вызовет появление
нового фрейма, что, вероятно, не то, что хочет наш пользователь.

   До сих пор только показано, как @emph{пользователи} могут настроить
поведение @code{display-buffer} по умолчанию.  Теперь смотреть, как
@emph{Приложения} могут изменить курс @code{display-buffer}.  Канонический
способ сделать это - использовать аргумент @var{action} для
@code{display-buffer} или вызывающую его функцию, например,
@code{pop-to-buffer} (@pxref{Switching Buffers}).

   Предположить, приложение хочет отображать @file{*foo*} предпочтительно
под выбранным окном (чтобы сразу привлечь внимание пользователя к новому
окну) или, если это не удается, в окне внизу фрейма.  Можно сделать это с
помощью такого вызова:

@example
@group
(display-buffer
 (get-buffer-create "*foo*")
 '((display-buffer-below-selected display-buffer-at-bottom)))
@end group
@end example

@noindent
Чтобы увидеть, как работает эта новая измененная форма, удалить любой фрейм,
показывающий @file{*foo*}, ввести @w{@kbd{C-x 1}}, а затем @w{@kbd{C-x 2}} в
окне, показывающем @file{*scratch*}, и затем оценить эту форму.
@code{display-buffer} должен разделить верхнее окно и отобразить
@file{*foo*} в новом окне.  В качестве альтернативы, если бы после
@w{@kbd{C-x 2}} набрать @w{@kbd{C-x o}}, @code{display-buffer}, вместо этого
бы разбило окно внизу.

   Предположим теперь, что перед оценкой новой формы сделано выбранное окно
как можно меньшим, например, оценив форму @code{(fit-window-to-buffer)} в
этом окне.  В этом случае @code{display-buffer} не смог бы разделить
выбранное окно и вместо этого разделил бы корневое окно фрейма, эффективно
отображая @file{*foo*} внизу фрейма.

   В любом случае при оценке новой формы во второй раз следует повторно
использовать окно, уже показывающее @file{*foo*}, поскольку обе функции,
предоставленные аргументом @var{action}, сначала пытаются повторно
использовать такое окно.

   Устанавив аргумент @var{action}, приложение фактически отменяет любую
настройку @code{display-buffer-base-action}.  Теперь пользователь может либо
принять выбор приложения, либо повторить двойную настройку параметра
@code{display-buffer-alist} следующим образом:

@example
@group
(customize-set-variable
 'display-buffer-alist
 '(("\\*foo\\*"
    (display-buffer-reuse-window display-buffer-pop-up-frame))))
@end group
@end example

@noindent
Попытка сделать это с новой, измененной формой выше в конфигурации, в
которой нигде не отображается @file{*foo*}, отобразит @file{*foo*} в
отдельном фрейме, полностью игнорируя аргумент @var{action} для
@code{display-buffer}.

   Обратить внимание, что не позаботились указать запись списка действий
@code{reusable-frames} в спецификации @code{display-buffer-alist}.
@code{display-buffer} всегда берет первый найденный - в этом случае тот,
который указан в @code{display-buffer-base-action}.  Если бы требовалось
использовать другую спецификацию, например, чтобы исключить иконизированные
фреймы, показывающие @file{*foo*}, из списка многоразовых, нам пришлось бы
указать это отдельно, однако:

@example
@group
(customize-set-variable
 'display-buffer-alist
 '(("\\*foo\\*"
    (display-buffer-reuse-window display-buffer-pop-up-frame)
    (reusable-frames . visible))))
@end group
@end example

@noindent
Если попробовать это сделать, заметиться, что повторные попытки отобразить
@file{*foo*} позволят повторно использовать фрейм только в том случае, если
этот фрейм виден.

   Приведенный выше пример позволяет сделать вывод, что пользователи
настраивают @code{display-buffer-alist} с единственной целью - отменить
аргумент @var{action}, выбранный приложениями.  Такой вывод был бы неверным.
@code{display-buffer-alist} - это стандартный параметр, позволяющий
пользователям направлять ход отображения определенных буферов
предпочтительным образом независимо от того, управляется ли отображение
аргументом @var{action}.

   Однако можно сделать разумный вывод, что настройка
@code{display-buffer-alist} отличается от настройки
@code{display-buffer-base-action} в двух основных аспектах: она сильнее,
потому что переопределяет аргумент @var{action} для @code{display-buffer} и
позволяет явно указать затронутые буферы.  Фактически, настройка
@file{*foo*} никак не влияет на отображение других буферов.  Например,

@example
(display-buffer (get-buffer-create "*bar*"))
@end example

@noindent
продолжает регулироваться только настройками
@code{display-buffer-base-action} и @code{display-buffer-fallback-action}.

   Можно бы остановиться на наших примерах здесь, но у программ на Lisp все
еще есть козырь в рукаве, который они могут использовать для отмены любой
настройки @code{display-buffer-alist}.  Это переменная
@code{display-buffer-overriding-action}, которую они могут привязать к
вызовам @code{display-buffer} следующим образом:

@example
@group
(let ((display-buffer-overriding-action
       '((display-buffer-same-window))))
  (display-buffer
   (get-buffer-create "*foo*")
   '((display-buffer-below-selected display-buffer-at-bottom))))
@end group
@end example

@noindent
Оценка этой формы обычно отображает @file{*foo*} в выбранном окне независимо
от аргумента @var{action} и любых пользовательских настроек.  (Обычно
приложение не заботится о предоставлении аргумента @var{action}.  Здесь
просто служит для иллюстрации того факта, что он переопределяется.)

Было бы показательно взглянуть на список функций действий, которые
@code{display-buffer} пытались отобразить @file{*foo*} с настройками,
которые здесь предоставлены.  Список (включая комментарии, объясняющие, кто
добавил этот и последующие элементы)::

@example
@group
(display-buffer-same-window  ;; `display-buffer-overriding-action'
 display-buffer-reuse-window ;; `display-buffer-alist'
 display-buffer-pop-up-frame
 display-buffer-below-selected ;; ACTION argument
 display-buffer-at-bottom
 display-buffer-reuse-window ;; `display-buffer-base-action'
 display-buffer-pop-up-frame
 display-buffer--maybe-same-window ;; `display-buffer-fallback-action'
 display-buffer-reuse-window
 display-buffer--maybe-pop-up-frame-or-window
 display-buffer-in-previous-window
 display-buffer-use-some-window
 display-buffer-pop-up-frame)
@end group
@end example

@noindent
Обратить внимание, что среди перечисленных здесь внутренних функций
@code{display-buffer--maybe-same-window} фактически игнорируется, в то время
как @code{display-buffer--maybe-pop-up-frame-or-window} фактически выполняет
@code{display-buffer-pop-up-window}.

Список действий, переданный при каждом вызове функции,:

@example
@group
((reusable-frames . visible)
 (reusable-frames . 0))
@end group
@end example

@noindent
что показывает, что использована вторая спецификация
@code{display-buffer-alist} выше, которая переопределила спецификацию,
предоставленную @code{display-buffer-base-action}.  Предположив, что
пользователь написал это как

@example
@group
(customize-set-variable
 'display-buffer-alist
 '(("\\*foo\\*"
    (display-buffer-reuse-window display-buffer-pop-up-frame)
    (inhibit-same-window . t)
    (reusable-frames . visible))))
@end group
@end example

@noindent
В этом случае запись @code{inhibit-same-window} alist успешно аннулирует
спецификацию @code{display-buffer-same-window} из
@code{display-buffer-overriding-action} и @code{display-buffer}, будет
отображаться @file{*foo*} в другом фрейме.  Чтобы сделать
@code{display-buffer-overriding-action} более надежным в этом отношении,
приложение должно также указать соответствующую запись
@code{inhibit-same-window}, например, следующим образом:

@example
@group
(let ((display-buffer-overriding-action
       '(display-buffer-same-window (inhibit-same-window . nil))))
  (display-buffer (get-buffer-create "*foo*")))
@end group
@end example

@noindent
Этот последний пример показывает, что, хотя порядок приоритета функций
действий фиксирован, как описано в @ref{Choosing Window}, запись списка
действий, заданная действием отображения с более низким рангом в этом
порядке, может влиять на выполнение действия отображения с более высоким
рейтингом.


@node The Zen of Buffer Display
@subsection The Zen of Buffer Display
@cindex guidelines for buffer display
@cindex writing buffer display actions
@cindex buffer display conventions

В наиболее упрощенной форме фрейм всегда включает в себя одно окно, которое
можно использовать для отображения буфера.  Как следствие, всегда последний
вызов @code{display-buffer} успешно помещает туда свой буфер.

   Поскольку работа с таким фреймом не очень практична, Emacs по умолчанию
допускает более сложные макеты фреймов, управляемые значениями по умолчанию
для размера фрейма и опциями @code{split-height-threshold} и
@code{split-width-threshold}.  Отображение буфера, еще не показанного в
фрейме, затем либо разделяет одно окно на этот фрейм, либо (повторно)
использует одно из двух окон.

   От поведения по умолчанию отказываются, как только пользователь
настраивает один из этих пороговых значений или вручную изменяет макет
фрейма.  От поведения по умолчанию также отказываются при вызове
@code{display-buffer} с аргументом не-@code{nil} @var{action} или когда
пользователь настраивает один из параметров, упомянутых в предыдущих
подразделах.  Освоение @code{display-buffer} скоро может стать неприятным
занятием из-за множества применимых действий отображения и результирующих
макетов фреймов.

   Однако воздержание от использования функций отображения буфера и
использование метафоры разделения и удаления окон также не является хорошей
идеей.  Функции отображения буфера дают программам и пользователям на Lisp
основу для согласования их различных потребностей; сопоставимой структуры
для разделения и удаления окон не существует.  Функции отображения буфера
также позволяют хотя бы частично восстановить макет фрейма при удалении из
него буфера позже (@pxref{Quitting Windows}).

   Ниже даны ряд рекомендаций, чтобы избавиться от разочарования,
упомянутого выше, и, таким образом, избежать буквально потери буферов между
окнами фрейма.

@table @asis
@item Написать действия с дисплеем без напряга
Написание действий отображения может быть проблемой, потому что нужно
объединить функции действий и списки действий в один огромный список.
(Исторические причины не позволили @code{display-buffer} поддержать
отдельные аргументы в их пользу.)  Может быть полезно запомнить некоторые
основные формы, подобные перечисленным ниже:

@example
'(nil (inhibit-same-window . t))
@end example

@noindent
определяет только запись списка действий и не функцию действия.  Его
единственная цель - запретить функции @code{display-buffer-same-window},
указанной в другом месте, отображать буфер в том же окне, смотреть также
последний пример в предыдущем подразделе.

@example
'(display-buffer-below-selected)
@end example

@noindent
с другой стороны, определяет одну функцию действия и пустой список действий.
Чтобы объединить эффекты двух вышеупомянутых спецификаций, нужно написать
форму

@example
'(display-buffer-below-selected (inhibit-same-window . t))
@end example

@noindent
чтобы добавить еще одну функцию действия, нужно написать

@example
@group
'((display-buffer-below-selected display-buffer-at-bottom)
  (inhibit-same-window . t))
@end group
@end example

@noindent
и чтобы добавить еще одну запись в список, нужно написать

@example
@group
'((display-buffer-below-selected display-buffer-at-bottom)
  (inhibit-same-window . t)
  (window-height . fit-window-to-buffer))
@end group
@end example

@noindent
Эту последнюю форму можно использовать как аргумент @var{action} для
@code{display-buffer} следующим образом:

@example
@group
(display-buffer
 (get-buffer-create "*foo*")
 '((display-buffer-below-selected display-buffer-at-bottom)
   (inhibit-same-window . t)
   (window-height . fit-window-to-buffer)))
@end group
@end example

@noindent
При настройке @code{display-buffer-alist} будет использоваться следующим
образом:

@example
@group
(customize-set-variable
 'display-buffer-alist
 '(("\\*foo\\*"
    (display-buffer-below-selected display-buffer-at-bottom)
    (inhibit-same-window . t)
    (window-height . fit-window-to-buffer))))
@end group
@end example

@noindent
Чтобы добавить настройку для второго буфера, нужно написать:

@example
@group
(customize-set-variable
 'display-buffer-alist
 '(("\\*foo\\*"
    (display-buffer-below-selected display-buffer-at-bottom)
    (inhibit-same-window . t)
    (window-height . fit-window-to-buffer))
   ("\\*bar\\*"
    (display-buffer-reuse-window display-buffer-pop-up-frame)
    (reusable-frames . visible))))
@end group
@end example

@item Относиться друг к другу с уважением
@code{display-buffer-alist} и @code{display-buffer-base-action} - это
пользовательские параметры --- программы Lisp никогда не должны
устанавливать или повторно связывать их.
@code{display-buffer-overriding-action}, с другой стороны, зарезервирован
для приложений - которые редко используют эту опцию, а если они используют
ее, то с особой осторожностью.

   Более старые реализации @code{display-buffer} часто заставляли
пользователей и приложения драться из-за настроек пользовательских
параметров, таких как @code{pop-up-frames} и @code{pop-up-windows}
(@pxref{Choosing Window Options}).  Это было одной из основных причин
переделки @code{display-buffer} - чтобы обеспечить четкую структуру,
определяющую, что пользователям и приложениям должно быть разрешено делать.

   Программы Lisp должны быть подготовлены к тому, что пользовательские
настройки могут привести к неожиданному отображению буферов.  Они никогда не
должны предполагать в своем последующем поведении, что буфер был показан
именно так, как они просили в аргументе @var{action} для
@code{display-buffer}.

   Пользователи не должны устанавливать слишком много и слишком жестких
ограничений на отображение произвольных буферов.  В противном случае они
рискуют потерять характеристики показа буфера для определенной цели.
Предположим, что программа на Lisp была написана для параллельного сравнения
различных версий буфера в двух окнах.  Если настройка
@code{display-buffer-alist} предписывает, что любой такой буфер всегда
должен отображаться в выбранном окне или под ним, программе будет сложно
настроить желаемую конфигурацию окна через @code{display-buffer}.

   Чтобы указать предпочтение для отображения произвольного буфера,
пользователи должны настроить @code{display-buffer-base-action}.  Пример
того, как это будут делать пользователи, предпочитающие работать с
несколькими фреймами, был приведен в предыдущем подразделе.
@code{display-buffer-alist} следует зарезервировать для отображения
определенных буферов определенным образом.

@item Рассмотреть возможность повторного использования окна, в котором уже отображается буфер
Как правило, для пользователей и программистов на Lisp всегда полезно быть
готовым к тому случаю, когда в окне уже отображается рассматриваемый буфер,
и повторно использовать это окно.  В предыдущем подразделе показано, что
невыполнение этого требования может привести к тому, что
@code{display-buffer} будет постоянно отображать новый буфер, хотя буфер,
показывающий, что буфер уже существует.  Только в некоторых случаях может
быть нежелательно повторно использовать окно, например, когда в этом окне
должна отображаться другая часть буфера.

   Следовательно, @code{display-buffer-reuse-window} - это одна функция
действия, которую следует использовать как можно чаще, как в аргументах
@var{action}, так и в настройках.  Запись @code{inhibit-same-window} в
аргументе @var{action} обычно касается наиболее распространенного случая,
когда следует избегать повторного использования окна, показывающего буфер, -
когда рассматриваемое окно является выбранным.

@item Привлечь внимание к выбранному окну
Это простая задача для людей, работающих с несколькими фреймами - фрейм,
показывающий буфер, автоматически поднимется и получит фокус, если запись
@code{inhibit-switch-frame} не запрещает это.  Для пользователей одного
фрейма эта задача может быть значительно сложнее.  В частности,
@code{display-buffer-pop-up-window} и @code{display-buffer-use-some-window}
в этом отношении могут стать навязчивыми.  Они разделяют или используют
кажущееся произвольным (часто самое большое или недавно использовавшееся)
окно, отвлекая внимание пользователя.

Поэтому некоторые программы Lisp пытаются выбрать окно внизу кадра,
например, чтобы отобразить буфер рядом с окном минибуфера, где пользователь
должен ответить на вопрос, связанный с новым окном.  Для действий, не
связанных с вводом, может быть предпочтительнее
@code{display-buffer-below-selected}, потому что выбранное окно обычно уже
привлекает внимание пользователя.

@item Обработка последующих вызовов @code{display-buffer}
@code{display-buffer} не слишком хорошо подходит для последовательного
отображения нескольких буферов и обеспечения упорядоченного отображения всех
этих буферов в итоговой конфигурации окна.  Опять же, стандартные функции
действий @code{display-buffer-pop-up-window} и
@code{display-buffer-use-some-window} не очень подходят для этой цели из-за
их несколько хаотичного характера в более сложных конфигурациях.

   Чтобы создать конфигурацию окна, отображающую несколько буферов (или
разные представления одного и того же буфера) в одном и том же цикле
отображения, программистам на Lisp неизбежно придется писать свои
собственные функции действий.  Несколько уловок, перечисленных ниже, могут
помочь в этом отношении.

@itemize @bullet
@item
Создание атомарных окон (@pxref{Atomic Windows}) позволяет избежать
разрушения существующей композиции окна при открытии нового окна.  Вместо
этого новое окно появится за пределами композиции.

@item
Временное выделение окон для их буферов (@pxref{Dedicated Windows})
позволяет избежать использования окна для отображения другого буфера.
Вместо этого будет использоваться неспециализированное окно.

@item
Вызов @code{window-preserve-size} (@pxref{Preserving Window Sizes})
попытается сохранить размер окна аргументов неизменным при открытии нового
окна.  Однако потребуется убедиться, что вместо этого можно уменьшить другое
окно в той же комбинации.

@item
Боковые окна (@pxref{Side Windows}) могут использоваться для отображения
определенных буферов всегда в окне в одной и той же позиции фрейма.  Это
позволяет группировать буферы, которые не конкурируют за одновременное
отображение в фрейме, и отображать любой такой буфер в одном окне без
нарушения отображения других буферов.

@item
Дочерние фреймы (@pxref{Child Frames}) могут использоваться для отображения
буфера в пределах экранного состояния выбранного фрейма без нарушения
конфигурации окна этого фрейма и без накладных расходов, связанных с
полнофункциональными фреймами, как это вызвано
@code{display-buffer-pop-up-frame}.
@end itemize
@end table


@node Window History
@section История Окон
@cindex window history

Каждое окно запоминает в списке буферы, которые оно отображало ранее, и
порядок, в котором эти буферы были удалены из него.  Эту историю использует,
например, @code{replace-buffer-in-windows} (@pxref{Buffers and Windows}), 
при выходе из окна (@pxref{Quitting Windows}).  Список автоматически
поддерживается Emacs, но можно использовать следующие функции, чтобы явно
проверить или изменить его:

@defun window-prev-buffers &optional window
Функция возвращает список, в котором указано предыдущее содержимое
@var{window}.  Необязательный аргумент @var{window} должен быть активным
окном и по умолчанию выбран выбранным.

Каждый элемент списка имеет форму @code{(@var{buffer} @var{window-start}
@var{window-pos})}, где @var{buffer} - это буфер, ранее показанный в окне,
@var{window-start} - это начальная позиция окна,
(@pxref{Window Start and End}), когда этот буфер был показан в последний
раз, а @var{window-pos} - это позиция точки (@pxref{Window Point}), когда
этот буфер последний раз отображался в @var{window}.

Список упорядочен так, что более ранние элементы соответствуют недавно
показанным буферам, а первый элемент обычно соответствует буферу, который
был удален из окна последним.
@end defun

@defun set-window-prev-buffers window prev-buffers
Функция устанавливает предыдущие буферы @var{window} в значение
@var{prev-buffers}.  Аргумент @var{window} должен быть активным окном и по
умолчанию быть выбранным.  Аргумент @var{prev-buffers} должен быть списком
той же формы, что и возвращаемый @code{window-prev-buffers}.
@end defun

Кроме того, каждое окно поддерживает список @dfn{next buffers}, который
представляет собой список буферов, повторно отображаемый
@code{switch-to-prev-buffer} (смотреть ниже).  Этот список в основном
используется @code{switch-to-prev-buffer} и @code{switch-to-next-buffer} для
выбора буферов для переключения.

@defun window-next-buffers &optional window
Функция возвращает список буферов, недавно повторно показанных в
@var{window} через @code{switch-to-prev-buffer}.  Аргумент @var{window}
должен обозначать активное окно или @code{nil} (то есть выбранное окно).
@end defun

@defun set-window-next-buffers window next-buffers
Функция устанавливает следующий список буферов @var{window} в
@var{next-buffers}.  Аргумент @var{window} должен быть активным окном или
@code{nil} (то есть выбранным окном).  Аргумент @var{next-buffers} должен
быть списком буферов.
@end defun

Следующие команды могут использоваться для циклического просмотра
глобального списка буферов, таких как @code{bury-buffer} и
@code{unbury-buffer}.  Однако они циклически меняются в соответствии со
списком истории указанного окна, а не глобальным списком буферов.  Кроме
того, восстанавливают зависящие от окна положения начала и точки окна и
могут отображать буфер, даже если он уже отображается в другом окне.  В
частности, команда @code{switch-to-prev-buffer} используется
@code{replace-buffer-in-windows}, @code{bury-buffer} и @code{quit-window}
для поиска буфера замены для окна.

@deffn Command switch-to-prev-buffer &optional window bury-or-kill
Команда отображает предыдущий буфер в @var{window}.  Аргумент @var{window}
должен быть активным окном или @code{nil} (то есть выбранным окном).  Если
необязательный аргумент @var{bury-or-kill} - не-@code{nil}, это означает,
что буфер, показанный в настоящее время в @var{window}, вот-вот будет
оставлен или уничтожен и, следовательно, не должен переключаться на него
при будущих вызовах этой команды.

Предыдущий буфер обычно является буфером, показанным перед буфером,
показанным в настоящее время в @var{window}.  Однако буфер, который был
оставлен или уничтожен, или уже был показан последним вызовом
@code{switch-to-prev-buffer}, не квалифицируется как предыдущий буфер.

Если повторные вызовы этой команды уже показали все буферы, ранее показанные
в @var{window}, дальнейшие вызовы покажут буферы из списка буферов фрейма
@var{window} появляются на (@pxref{Buffer List}), пытаясь пропустить буферы,
которые уже показаны в другом окне этого фрейма.
@end deffn

@deffn Command switch-to-next-buffer &optional window
Команда переключает на следующий буфер в @var{window}, таким образом отменяя
действие последней команды @code{switch-to-prev-buffer} в @var{window}.
Аргумент @var{window} должен быть активным окном и по умолчанию быть
выбранным.

Если нет недавнего вызова @code{switch-to-prev-buffer}, который можно
отменить, эта функция пытается показать буфер из списка буферов фрейма,
в котором @var{window} появляется в (@pxref{Buffer List}).
@end deffn

По умолчанию @code{switch-to-prev-buffer} и @code{switch-to-next-buffer}
может переключиться на буфер, который уже отображается в другом окне в том
же фрейме.  Следующая опция может использоваться, чтобы переопределить это
поведение.

@defopt switch-to-visible-buffer
Если эта переменная - не-@code{nil}, @code{switch-to-prev-buffer} и
@code{switch-to-next-buffer}, можно переключиться на буфер, который уже
виден в том же фрейме, при условии, что буфер ранее был показан в
соответствующем окне.  Если это @code{nil}, @code{switch-to-prev-buffer} и
@code{switch-to-next-buffer} всегда старается избегать переключения на
буфер, который уже виден в другом окне в том же фрейме. По умолчанию -
@code{t}.
@end defopt


@node Dedicated Windows
@section Выделения Окон
@cindex dedicated window

Можно указать функциям для отображения буфера не использовать определенные
окна, пометив эти окна как @dfn{выделенные} для их буферов.
@code{display-buffer} (@pxref{Choosing Window}) никогда не использует
выделенное окно для отображения в нем другого буфера.  @code{get-lru-window}
и @code{get-largest-window} (@pxref{Cyclic Window Ordering}) не
рассматривает выделенные окна в качестве кандидатов, если их аргумент
@var{dedicated} - не-@code{nil}.  Поведение @code{set-window-buffer}
(@pxref{Buffers and Windows}) по отношению к выделенным окнам немного
отличается, смотреть ниже.

   Функции, предназначенные для удаления буфера из окна или окна из фрейма,
могут вести себя особым образом, когда окно, над которым они работают,
выделено.  Различаются три основных случая, а именно, когда (1) окно - не
единственное окно в своем фрейме, (2) окно является единственным окном в
своём фрейме, но на том же терминале слева есть другие фреймы, и (3) окно -
единственное окно в единственном фрейме на том же терминале.

   В частности, @code{delete-windows-on} (@pxref{Deleting Windows})
обрабатывает case (2), удаляя связанный фрейм, и case (3), показывая другой
буфер в единственном окне этого фрейма.  Функция
@code{replace-buffer-in-windows} (@pxref{Buffers and Windows}), которая
вызывается при уничтожении буфера, удаляет окно в случае (1) и ведет себя
как @code{delete-windows-on} в противном случае.
@c FIXME: Заменяет-буфер-в-окнах _удалено_ окно в случае (1)?

   Когда @code{bury-buffer} (@pxref{Buffer List}) работает с выбранным окном
(которое показывает буфер, который должен быть скрыт), обрабатывает case
(2), вызывая @code{frame-auto-hide-function} (@pxref{Quitting Windows}) для
работы с выбранным фреймом.  Остальные два случая обрабатываются как с
@code{replace-buffer-in-windows}.

@defun window-dedicated-p &optional window
Функция возвращает не-@code{nil}, если @var{window} выделен для своего
буфера, и @code{nil} в противном случае.  Точнее, возвращаемое значение -
это значение, присвоенное последним вызовом @code{set-window-dedicated-p}
для @var{window} или @code{nil}, если эта функция никогда не вызывалась с
@var{window} в качестве аргумента.  По умолчанию для @var{window} выбрано
окно.
@end defun

@defun set-window-dedicated-p window flag
Функция отмечает @var{window} как выделенный для своего буфера, если
@var{flag} имеет значение не-@code{nil}, и как не выделенный в противном
случае.

В особом случае, если @var{flag} равен @code{t}, @var{window} становится
@dfn{строго} выделенным для своего буфера.  @code{set-window-buffer}
сигнализирует об ошибке, когда окно, с которым оно работает, строго выделено
для своего буфера и еще не отображает буфер, который требуется отобразить.
Другие функции не обрабатывают @code{t} иначе, чем любое значение
не-@code{nil}.
@end defun


@node Quitting Windows
@section Quitting Windows

When you want to get rid of a window used for displaying a buffer, you
can call @code{delete-window} or @code{delete-windows-on}
(@pxref{Deleting Windows}) to remove that window from its frame.  If the
buffer is shown on a separate frame, you might want to call
@code{delete-frame} (@pxref{Deleting Frames}) instead.  If, on the other
hand, a window has been reused for displaying the buffer, you might
prefer showing the buffer previously shown in that window, by calling the
function @code{switch-to-prev-buffer} (@pxref{Window History}).
Finally, you might want to either bury (@pxref{Buffer List}) or kill
(@pxref{Killing Buffers}) the window's buffer.

   The following command uses information on how the window for
displaying the buffer was obtained in the first place, thus attempting
to automate the above decisions for you.

@deffn Command quit-window &optional kill window
This command quits @var{window} and buries its buffer.  The argument
@var{window} must be a live window and defaults to the selected one.
With prefix argument @var{kill} не-@code{nil}, it kills the buffer
instead of burying it.  It calls the function @code{quit-restore-window}
described next to deal with the window and its buffer.
@end deffn

@defun quit-restore-window &optional window bury-or-kill
This function handles @var{window} and its buffer after quitting.  The
optional argument @var{window} must be a live window and defaults to
the selected one. The function's behavior is determined by the four
elements of the list specified by @var{window}'s @code{quit-restore}
parameter (@pxref{Window Parameters}).

The first element of the @code{quit-restore} parameter is one of the
symbols @code{window}, meaning that the window has been specially
created by @code{display-buffer}; @code{frame}, a separate frame has
been created; @code{same}, the window has only ever displayed this
buffer; or @code{other}, the window showed another buffer before.
@code{frame} and @code{window} affect how the window is quit, while
@code{same} and @code{other} affect the redisplay of buffers
previously shown in @var{window}.

The parameter's second element is either one of the symbols
@code{window} or @code{frame}, or a list whose elements are the buffer
shown in @var{window} before, that buffer's window start and window
point positions, and @var{window}'s height at that time.  If that
buffer is still live when @var{window} is quit, then this function may
reuse @var{window} to display it.

The third element is the window selected at the time the parameter was
created.  If this function deletes @var{window}, it subsequently tries
to reselect the window named by that element.

The fourth element is the buffer whose display caused the creation of
this parameter.  This function may delete @var{window} if and only if
it still shows that buffer.

This function will try to delete @var{window} if and only if (1) the
first element of its @code{quit-restore} parameter is either
@code{window} or @code{frame}, (2) the window has no history of
previously-displayed buffers and (3) the fourth element of the
@code{quit-restore} parameter specifies the buffer currently displayed
in @var{window}.  If @var{window} is part of an atomic window
(@pxref{Atomic Windows}), it will try to delete the root of that
atomic window instead.  In either case, it tries to avoid signaling an
error when @var{window} cannot be deleted.

If @var{window} shall be deleted, is the only window on its frame and
there are other frames on that frame's terminal, the value of the
optional argument @var{bury-or-kill} determines how to proceed with
the window.  If @var{bury-or-kill} equals @code{kill}, the frame is
deleted unconditionally.  Otherwise, the fate of the frame is
determined by calling @code{frame-auto-hide-function} (see below) with
that frame as sole argument.

If the third element of the @code{quit-restore} parameter is a list of
buffer, window start (@pxref{Window Start and End}), and point
(@pxref{Window Point}), and that buffer is still live, the buffer will
be displayed, and start and point set accordingly.  If, in addition,
@var{window}'s buffer was temporarily resized, this function will also
try to restore the original height of @var{window}.

Otherwise, if @var{window} was previously used for displaying other
buffers (@pxref{Window History}), the most recent buffer in that
history will be displayed.  In either case, if @var{window} is not
deleted, its @code{quit-restore} parameter is reset to @code{nil}.

The optional argument @var{bury-or-kill} specifies how to deal with
@var{window}'s buffer.  The following values are handled:

@table @code
@item nil
This means to not deal with the buffer in any particular way.  As a
consequence, if @var{window} is not deleted, invoking
@code{switch-to-prev-buffer} will usually show the buffer again.

@item append
This means that if @var{window} is not deleted, its buffer is moved to
the end of @var{window}'s list of previous buffers, so it's less likely
that a future invocation of @code{switch-to-prev-buffer} will switch to
it.  Also, it moves the buffer to the end of the frame's buffer list.

@item bury
This means that if @var{window} is not deleted, its buffer is removed
from @var{window}'s list of previous buffers.  Also, it moves the buffer
to the end of the frame's buffer list.  This value provides the most
reliable remedy to not have @code{switch-to-prev-buffer} switch to this
buffer again without killing the buffer.

@item kill
This means to kill @var{window}'s buffer.
@end table

Typically, the display routines run by @code{display-buffer} will set
the @code{quit-restore} window parameter correctly.  It's also
possible to set it manually, using the following code for displaying
@var{buffer} in @var{window}:

@example
@group
(display-buffer-record-window type window buffer)

(set-window-buffer window buffer)

(set-window-prev-buffers window nil)
@end group
@end example

Setting the window history to @code{nil} ensures that a future call to
@code{quit-window} can delete the window altogether.

@end defun

The following option specifies how to deal with a frame containing just
one window that should be either quit, or whose buffer should be buried.

@defopt frame-auto-hide-function
The function specified by this option is called to automatically hide
frames.  This function is called with one argument---a frame.

The function specified here is called by @code{bury-buffer}
(@pxref{Buffer List}) when the selected window is dedicated and shows
the buffer to bury.  It is also called by @code{quit-restore-window}
(see above) when the frame of the window to quit has been specially
created for displaying that window's buffer and the buffer is not
killed.

The default is to call @code{iconify-frame} (@pxref{Visibility of
Frames}).  Alternatively, you may specify either @code{delete-frame}
(@pxref{Deleting Frames}) to remove the frame from its display,
@code{make-frame-invisible} to make the frame invisible, @code{ignore}
to leave the frame unchanged, or any other function that can take a
frame as its sole argument.

Note that the function specified by this option is called only if the
specified frame contains just one live window and there is at least one
other frame on the same terminal.

For a particular frame, the value specified here may be overridden by
that frame's @code{auto-hide-function} frame parameter (@pxref{Frame
Interaction Parameters}).
@end defopt


@node Side Windows
@section Side Windows
@cindex side windows
@cindex main window
@cindex main window of a frame

Side windows are special windows positioned at any of the four sides of
a frame's root window (@pxref{Windows and Frames}).  In practice, this
means that the area of the frame's root window is subdivided into a main
window and a number of side windows surrounding that main window.  The
main window is either a ``normal'' live window or specifies the area
containing all the normal windows.

   In their most simple form of use, side windows allow to display
specific buffers always in the same area of a frame.  Hence they can
be regarded as a generalization of the concept provided by
@code{display-buffer-at-bottom} (@pxref{Buffer Display Action
Functions}) to the remaining sides of a frame.  With suitable
customizations, however, side windows can be also used to provide
frame layouts similar to those found in so-called integrated
development environments (IDEs).

@menu
* Displaying Buffers in Side Windows:: An action function for displaying
                              buffers in side windows.
* Side Window Options and Functions:: Further tuning of side windows.
* Frame Layouts with Side Windows:: Setting up frame layouts with side
                              windows.
@end menu


@node Displaying Buffers in Side Windows
@subsection Displaying Buffers in Side Windows

The following action function for @code{display-buffer} (@pxref{Buffer
Display Action Functions}) creates or reuses a side window for
displaying the specified buffer.

@defun display-buffer-in-side-window buffer alist
This function displays @var{buffer} in a side window of the selected
frame.  It returns the window used for displaying @var{buffer},
@code{nil} if no such window can be found or created.

@var{alist} is an association list of symbols and values as for
@code{display-buffer}.  The following symbols in @var{alist} are special
for this function:

@table @code
@item side
Denotes the side of the frame where the window shall be located.  Valid
values are @code{left}, @code{top}, @code{right} and @code{bottom}.  If
unspecified, the window is located at the bottom of the frame.

@item slot
Denotes a slot at the specified side where to locate the window.  A
value of zero means to preferably position the window in the middle of
the specified side.  A negative value means to use a slot preceding
(that is, above or on the left of) the middle slot.  A positive value
means to use a slot following (that is, below or on the right of) the
middle slot.  Hence, all windows on a specific side are ordered by their
@code{slot} value.  If unspecified, the window is located in the middle
of the specified side.
@end table

If you specify the same slot on the same side for two or more different
buffers, the buffer displayed last is shown in the corresponding window.
Hence, slots can be used for sharing the same side window between
buffers.

This function installs the @code{window-side} and @code{window-slot}
parameters (@pxref{Window Parameters}) and makes them persistent.  It
does not install any other window parameters unless they have been
explicitly provided via a @code{window-parameters} entry in @var{alist}.
@end defun

By default, side windows cannot be split via @code{split-window}
(@pxref{Splitting Windows}).  Also, a side window is not reused or
split by any buffer display action (@pxref{Buffer Display Action
Functions}) unless it is explicitly specified as target of that
action.  Note also that @code{delete-other-windows} cannot make a side
window the only window on its frame (@pxref{Deleting Windows}).

   Once set up, side windows also change the behavior of the commands
@code{switch-to-prev-buffer} and @code{switch-to-next-buffer}
(@pxref{Window History}).  In particular, these commands will refrain
from showing, in a side window, buffers that have not been displayed in
that window before.  They will also refrain from having a normal,
non-side window show a buffer that has been already displayed in a side
window.  A notable exception to the latter rule occurs when an
application, after displaying a buffer, resets that buffer's local
variables.


@node Side Window Options and Functions
@subsection Side Window Options and Functions

The following options provide additional control over the placement of
side windows.

@defopt window-sides-vertical
If не-@code{nil}, the side windows on the left and right of a frame
occupy the frame's full height.  Otherwise, the side windows on the top
and bottom of the frame occupy the frame's full width.
@end defopt

@defopt window-sides-slots
This option specifies the maximum number of side windows on each side of
a frame.  The value is a list of four elements specifying the number of
side window slots on (in this order) the left, top, right and bottom of
each frame.  If an element is a number, it means to display at most that
many windows on the corresponding side.  If an element is @code{nil}, it
means there's no bound on the number of slots on that side.

If any of the specified values is zero, no window can be created on the
corresponding side.  @code{display-buffer-in-side-window} will not
signal an error in that case, but will return @code{nil}.  If a specified
value just forbids the creation of an additional side window, the most
suitable window on that side is reused and may have its
@code{window-slot} parameter changed accordingly.
@end defopt

@defopt window-sides-reversed
This option specifies whether top/bottom side windows should appear in
reverse order.  When this is @code{nil}, side windows on the top and
bottom of a frame are always drawn from left to right with increasing
slot values.  When this is @code{t}, the drawing order is reversed and
side windows on the top and bottom of a frame are drawn from right to
left with increasing slot values.

When this is @code{bidi}, the drawing order is reversed if and only if
the value of @code{bidi-paragraph-direction} (@pxref{Bidirectional
Display}) is @code{right-to-left} in the buffer displayed in the window
most recently selected within the main window area of this frame.
Sometimes that window may be hard to find, so heuristics are used to
avoid that the drawing order changes inadvertently when another window
gets selected.

The layout of side windows on the left or right of a frame is not
affected by the value of this variable.
@end defopt

When a frame has side windows, the following function returns the main
window of that frame.

@defun window-main-window &optional frame
This function returns the main window of the specified @var{frame}.  The
optional argument @var{frame} must be a live frame and defaults to the
selected one.

If @var{frame} has no side windows, it returns @var{frame}'s root
window.  Otherwise, it returns either an internal non-side window such
that all other non-side windows on @var{frame} descend from it, or the
single live non-side window of @var{frame}.  Note that the main window
of a frame cannot be deleted via @code{delete-window}.
@end defun

The following command is handy to toggle the appearance of all side
windows on a specified frame.

@deffn Command window-toggle-side-windows &optional frame
This command toggles side windows on the specified @var{frame}.  The
optional argument @var{frame} must be a live frame and defaults to the
selected one.

If @var{frame} has at least one side window, this command saves the
state of @var{frame}'s root window in the @var{frame}'s
@code{window-state} frame parameter and deletes all side windows on
@var{frame} afterwards.

If @var{frame} has no side windows, but does have a @code{window-state}
parameter, this command uses that parameter's value to restore the side
windows on @var{frame} leaving @var{frame}'s main window alone.

An error is signaled if @var{frame} has no side windows and no saved
state is found for it.
@end deffn


@node Frame Layouts with Side Windows
@subsection Frame Layouts with Side Windows

Side windows can be used to create more complex frame layouts like those
provided by integrated development environments (IDEs).  In such
layouts, the area of the main window is where the normal editing
activities take place.  Side windows are not conceived for editing in
the usual sense.  Rather, they are supposed to display information
complementary to the current editing activity, like lists of files, tags
or buffers, help information, search or grep results or shell output.

   The layout of such a frame might appear as follows:

@smallexample
@group
     ___________________________________
    |          *Buffer List*            |
    |___________________________________|
    |     |                       |     |
    |  *  |                       |  *  |
    |  d  |                       |  T  |
    |  i  |                       |  a  |
    |  r  |   Main Window Area    |  g  |
    |  e  |                       |  s  |
    |  d  |                       |  *  |
    |  *  |                       |     |
    |_____|_______________________|_____|
    | *help*/*grep*/  |  *shell*/       |
    | *Completions*   |  *compilation*  |
    |_________________|_________________|
    |             Echo Area             |
    |___________________________________|


@end group
@end smallexample

The following example illustrates how window parameters (@pxref{Window
Parameters}) can be used with @code{display-buffer-in-side-window}
(@pxref{Displaying Buffers in Side Windows}) to set up code for
producing the frame layout sketched above.

@example
@group
(defvar parameters
  '(window-parameters . ((no-other-window . t)
                         (no-delete-other-windows . t))))

(setq fit-window-to-buffer-horizontally t)
(setq window-resize-pixelwise t)

(setq
 display-buffer-alist
 `(("\\*Buffer List\\*" display-buffer-in-side-window
    (side . top) (slot . 0) (window-height . fit-window-to-buffer)
    (preserve-size . (nil . t)) ,parameters)
   ("\\*Tags List\\*" display-buffer-in-side-window
    (side . right) (slot . 0) (window-width . fit-window-to-buffer)
    (preserve-size . (t . nil)) ,parameters)
   ("\\*\\(?:help\\|grep\\|Completions\\)\\*"
    display-buffer-in-side-window
    (side . bottom) (slot . -1) (preserve-size . (nil . t))
    ,parameters)
   ("\\*\\(?:shell\\|compilation\\)\\*" display-buffer-in-side-window
    (side . bottom) (slot . 1) (preserve-size . (nil . t))
    ,parameters)))
@end group
@end example

This specifies @code{display-buffer-alist} entries (@pxref{Choosing
Window}) for buffers with fixed names.  In particular, it asks for
showing @file{*Buffer List*} with adjustable height at the top of the
frame and @file{*Tags List*} with adjustable width on the frame's right.
It also asks for having the @file{*help*}, @file{*grep*} and
@file{*Completions*} buffers share a window on the bottom left side of
the frame and the @file{*shell*} and @file{*compilation*} buffers appear
in a window on the bottom right side of the frame.

   Note that the option @code{fit-window-to-buffer-horizontally} must
have a не-@code{nil} value in order to allow horizontal adjustment of
windows.  Entries are also added that ask for preserving the height of
side windows at the top and bottom of the frame and the width of side
windows at the left or right of the frame.  To assure that side windows
retain their respective sizes when maximizing the frame, the variable
@code{window-resize-pixelwise} is set to a не-@code{nil} value.
@xref{Resizing Windows}.

   The last form also makes sure that none of the created side windows
are accessible via @w{@kbd{C-x o}} by installing the @code{no-other-window}
parameter for each of these windows.  In addition, it makes sure that
side windows are not deleted via @w{@kbd{C-x 1}} by installing the
@code{no-delete-other-windows} parameter for each of these windows.

   Since @code{dired} buffers have no fixed names, we use a special
function @code{dired-default-directory-on-left} in order to display a
lean directory buffer on the left side of the frame.

@example
@group
(defun dired-default-directory-on-left ()
  "Display `default-directory' in side window on left, hiding details."
  (interactive)
  (let ((buffer (dired-noselect default-directory)))
    (with-current-buffer buffer (dired-hide-details-mode t))
    (display-buffer-in-side-window
     buffer `((side . left) (slot . 0)
              (window-width . fit-window-to-buffer)
              (preserve-size . (t . nil)) ,parameters))))
@end group
@end example

Evaluating the preceding forms and typing, in any order, @w{@kbd{M-x
list-buffers}}, @kbd{C-h f}, @kbd{M-x shell}, @w{@kbd{M-x list-tags}},
and @kbd{M-x dired-default-directory-on-left} should now reproduce the
frame layout sketched above.


@node Atomic Windows
@section Atomic Windows
@cindex atomic windows

Atomic windows are rectangular compositions of at least two live
windows.  They have the following distinctive characteristics:

@itemize @bullet
@item
The function @code{split-window} (@pxref{Splitting Windows}), when
applied to a constituent of an atomic window, will try to create the new
window outside of the atomic window.

@item
The function @code{delete-window} (@pxref{Deleting Windows}), when
applied to a constituent of an atomic window, will try to delete the
entire atomic window instead.

@item
The function @code{delete-other-windows} (@pxref{Deleting Windows}),
when applied to a constituent of an atomic window, will try to make the
atomic window fill its frame or main window (@pxref{Side Windows}).
@end itemize

This means that the basic groups of functions that alter the window
structure treat an atomic window like a live one, thus preserving the
internal structure of the atomic window.

   Atomic windows are useful to construct and preserve window layouts
that are meaningful only when all involved buffers are shown
simultaneously in a specific manner, such as when showing differences
between file revisions, or the same text in different languages or
markups.  They can also be used to permanently display information
pertinent to a specific window in bars on that window's sides.

@cindex root window of atomic window
   Atomic windows are implemented with the help of the reserved
@code{window-atom} window parameter (@pxref{Window Parameters}) and an
internal window (@pxref{Basic Windows}) called the root window of the
atomic window.  All windows that are part of the same atomic window have
this root window as their common ancestor and are assigned a
не-@code{nil} @code{window-atom} parameter.

  The following function returns the root of the atomic window a
specified window is part of:

@defun window-atom-root &optional window
This functions returns the root of the atomic window @var{window} is a
part of.  The specified @var{window} must be a valid window and defaults
to the selected one.  It returns @code{nil} if @var{window} is not part
of an atomic window.
@end defun

The most simple approach to make a new atomic window is to take an
existing internal window and apply the following function:

@defun window-make-atom window
This function converts @var{window} into an atomic window.  The
specified @var{window} must be an internal window.  All this function
does is to set the @code{window-atom} parameter of each descendant of
@var{window} to @code{t}.
@end defun

To create a new atomic window from an existing live window or to add a
new window to an existing atomic window, the following buffer display
action function (@pxref{Buffer Display Action Functions}) can be used:

@defun display-buffer-in-atom-window buffer alist
This function tries to display @var{buffer} in a new window that will be
combined with an existing window to form an atomic window.  If the
existing window is already part of an atomic window, it adds the new
window to that atomic window.

The specified @var{alist} is an association list of symbols and values.
The following symbols have a special meaning:

@table @code
@item window
The value of such an element specifies an existing window the new window
shall be combined with.  If it specifies an internal window, all
children of that window become part of the atomic window too.  If no
window is specified, the new window becomes a sibling of the selected
window.  The @code{window-atom} parameter of the existing window is set
to @code{main} provided that window is live and its @code{window-atom}
parameter was not already set.

@item side
The value of such an element denotes the side of the existing window
where the new window shall be located.  Valid values are @code{below},
@code{right}, @code{above} and @code{left}.  The default is
@code{below}.  The @code{window-atom} parameter of the new window is set
to this value.
@end table

The return value is the new window, @code{nil} when creating that window
failed.
@end defun

Note that the value of the @code{window-atom} parameter does not really
matter as long as it is не-@code{nil}.  The values assigned by
@code{display-buffer-in-atom-window} just allow for easy retrieval of
the original and the new window after that function has been applied.
Note also that the @code{window-atom} parameter is the only window
parameter assigned by @code{display-buffer-in-atom-window}.  Further
parameters have to be set by the application explicitly via a
@code{window-parameters} entry in @var{alist}.

   Atomic windows automatically cease to exist when one of their
constituents gets deleted.  To dissolve an atomic window manually,
reset the @code{window-atom} parameter of its constituents---the root
of the atomic window and all its descendants.

   The following code snippet, when applied to a single-window frame,
first splits the selected window and makes the selected and the new
window constituents of an atomic window with their parent as root.  It
then displays the buffer @file{*Messages*} in a new window at the
frame's bottom and makes that new window part of the atomic window just
created.

@example
@group
(let ((window (split-window-right)))
  (window-make-atom (window-parent window))
  (display-buffer-in-atom-window
   (get-buffer-create "*Messages*")
   `((window . ,(window-parent window)) (window-height . 5))))
@end group
@end example

At this moment typing @w{@kbd{C-x 2}} in any window of that frame
produces a new window at the bottom of the frame.  Typing @w{@kbd{C-x
3}} instead will put the new window at the frame's right.  In either
case, typing now @w{@kbd{C-x 1}} in any window of the atomic window will
remove the new window only.  Typing @w{@kbd{C-x 0}} in any window of the
atomic window will make that new window fill the frame.


@node Window Point
@section Windows and Point
@cindex window position
@cindex window point
@cindex position in window
@cindex point in window

  Each window has its own value of point (@pxref{Point}), independent of
the value of point in other windows displaying the same buffer.  This
makes it useful to have multiple windows showing one buffer.

@itemize @bullet
@item
The window point is established when a window is first created; it is
initialized from the buffer's point, or from the window point of another
window opened on the buffer if such a window exists.

@item
Selecting a window sets the value of point in its buffer from the
window's value of point.  Conversely, deselecting a window sets the
window's value of point from that of the buffer.  Thus, when you switch
between windows that display a given buffer, the point value for the
selected window is in effect in the buffer, while the point values for
the other windows are stored in those windows.

@item
As long as the selected window displays the current buffer, the window's
point and the buffer's point always move together; they remain equal.
@end itemize

@cindex cursor
   Emacs displays the cursor, by default as a rectangular block, in
each window at the position of that window's point.  When the user
switches to another buffer in a window, Emacs moves that window's
cursor to where point is in that buffer.  If the exact position of
point is hidden behind some display element, such as a display string
or an image, Emacs displays the cursor immediately before or after
that display element.

@defun window-point &optional window
This function returns the current position of point in @var{window}.
For a nonselected window, this is the value point would have (in that
window's buffer) if that window were selected.  The default for
@var{window} is the selected window.

When @var{window} is the selected window, the value returned is the
value of point in that window's buffer.  Strictly speaking, it would be
more correct to return the top-level value of point, outside of any
@code{save-excursion} forms.  But that value is hard to find.
@end defun

@defun set-window-point window position
This function positions point in @var{window} at position
@var{position} in @var{window}'s buffer.  It returns @var{position}.

If @var{window} is selected, this simply does @code{goto-char} in
@var{window}'s buffer.
@end defun

@defvar window-point-insertion-type
This variable specifies the marker insertion type (@pxref{Marker
Insertion Types}) of @code{window-point}.  The default is @code{nil},
so @code{window-point} will stay behind text inserted there.
@end defvar

@node Window Start and End
@section The Window Start and End Positions
@cindex window start position
@cindex display-start position

  Each window maintains a marker used to keep track of a buffer position
that specifies where in the buffer display should start.  This position
is called the @dfn{display-start} position of the window (or just the
@dfn{start}).  The character after this position is the one that appears
at the upper left corner of the window.  It is usually, but not
inevitably, at the beginning of a text line.

  After switching windows or buffers, and in some other cases, if the
window start is in the middle of a line, Emacs adjusts the window
start to the start of a line.  This prevents certain operations from
leaving the window start at a meaningless point within a line.  This
feature may interfere with testing some Lisp code by executing it
using the commands of Lisp mode, because they trigger this
readjustment.  To test such code, put it into a command and bind the
command to a key.

@defun window-start &optional window
@cindex window top line
This function returns the display-start position of window
@var{window}.  If @var{window} is @code{nil}, the selected window is
used.

When you create a window, or display a different buffer in it, the
display-start position is set to a display-start position recently used
for the same buffer, or to @code{point-min} if the buffer doesn't have
any.

Redisplay updates the window-start position (if you have not specified
it explicitly since the previous redisplay)---to make sure point appears
on the screen.  Nothing except redisplay automatically changes the
window-start position; if you move point, do not expect the window-start
position to change in response until after the next redisplay.
@end defun

@defun window-group-start &optional window
@vindex window-group-start-function
This function is like @code{window-start}, except that when
@var{window} is a part of a group of windows (@pxref{Window Group}),
@code{window-group-start} returns the start position of the entire
group.  This condition holds when the buffer local variable
@code{window-group-start-function} is set to a function.  In this
case, @code{window-group-start} calls the function with the single
argument @var{window}, then returns its result.
@end defun

@cindex window end position
@cindex last visible position in a window
@defun window-end &optional window update
This function returns the position where display of its buffer ends in
@var{window}.  The default for @var{window} is the selected window.

Simply changing the buffer text or moving point does not update the
value that @code{window-end} returns.  The value is updated only when
Emacs redisplays and redisplay completes without being preempted.

If the last redisplay of @var{window} was preempted, and did not finish,
Emacs does not know the position of the end of display in that window.
In that case, this function returns @code{nil}.

If @var{update} is не-@code{nil}, @code{window-end} always returns an
up-to-date value for where display ends, based on the current
@code{window-start} value.  If a previously saved value of that position
is still valid, @code{window-end} returns that value; otherwise it
computes the correct value by scanning the buffer text.

Even if @var{update} is не-@code{nil}, @code{window-end} does not
attempt to scroll the display if point has moved off the screen, the
way real redisplay would do.  It does not alter the
@code{window-start} value.  In effect, it reports where the displayed
text will end if scrolling is not required.  Note that the position it
returns might be only partially visible.
@end defun

@vindex window-group-end-function
@defun window-group-end &optional window update
This function is like @code{window-end}, except that when @var{window}
is a part of a group of windows (@pxref{Window Group}),
@code{window-group-end} returns the end position of the entire group.
This condition holds when the buffer local variable
@code{window-group-end-function} is set to a function.  In this case,
@code{window-group-end} calls the function with the two arguments
@var{window} and @var{update}, then returns its result.  The argument
@var{update} has the same meaning as in @code{window-end}.
@end defun

@defun set-window-start window position &optional noforce
This function sets the display-start position of @var{window} to
@var{position} in @var{window}'s buffer.  It returns @var{position}.

The display routines insist that the position of point be visible when a
buffer is displayed.  Normally, they select the display-start position
according to their internal logic (and scroll the window if necessary)
to make point visible.  However, if you specify the start position
with this function using @code{nil} for @var{noforce}, it means you
want display to start at @var{position} even if that would put the
location of point off the screen.  If this does place point off
screen, the display routines attempt to move point to the left margin
on the middle line in the window.

For example, if point @w{is 1} and you set the start of the window
@w{to 37}, the start of the next line, point will be above the top
of the window.  The display routines will automatically move point if
it is still 1 when redisplay occurs.  Here is an example:

@example
@group
;; @r{Here is what @samp{foo} looks like before executing}
;;   @r{the @code{set-window-start} expression.}
@end group

@group
---------- Buffer: foo ----------
@point{}This is the contents of buffer foo.
2
3
4
5
6
---------- Buffer: foo ----------
@end group

@group
(set-window-start
 (selected-window)
 (save-excursion
   (goto-char 1)
   (forward-line 1)
   (point)))
@result{} 37
@end group

@group
;; @r{Here is what @samp{foo} looks like after executing}
;;   @r{the @code{set-window-start} expression.}
---------- Buffer: foo ----------
2
3
@point{}4
5
6
---------- Buffer: foo ----------
@end group
@end example

If the attempt to make point visible (i.e., in a fully-visible screen
line) fails, the display routines will disregard the requested
window-start position and compute a new one anyway.  Thus, for
reliable results Lisp programs that call this function should always
move point to be inside the window whose display starts at
@var{position}.

If @var{noforce} is не-@code{nil}, and @var{position} would place point
off screen at the next redisplay, then redisplay computes a new window-start
position that works well with point, and thus @var{position} is not used.
@end defun

@vindex set-window-group-start-function
@defun set-window-group-start window position &optional noforce
This function is like @code{set-window-start}, except that when
@var{window} is a part of a group of windows (@pxref{Window Group}),
@code{set-window-group-start} sets the start position of the entire
group.  This condition holds when the buffer local variable
@code{set-window-group-start-function} is set to a function.  In this
case, @code{set-window-group-start} calls the function with the three
arguments @var{window}, @var{position}, and @var{noforce}, then
returns its result.  The arguments @var{position} and @var{noforce} in
this function have the same meaning as in @code{set-window-start}.
@end defun

@defun pos-visible-in-window-p &optional position window partially
This function returns не-@code{nil} if @var{position} is within the
range of text currently visible on the screen in @var{window}.  It
returns @code{nil} if @var{position} is scrolled vertically out of
view.  Locations that are partially obscured are not considered
visible unless @var{partially} is не-@code{nil}.  The argument
@var{position} defaults to the current position of point in
@var{window}; @var{window} defaults to the selected window.  If
@var{position} is @code{t}, that means to check either the first
visible position of the last screen line in @var{window}, or the
end-of-buffer position, whichever comes first.

This function considers only vertical scrolling.  If @var{position} is
out of view only because @var{window} has been scrolled horizontally,
@code{pos-visible-in-window-p} returns не-@code{nil} anyway.
@xref{Horizontal Scrolling}.

If @var{position} is visible, @code{pos-visible-in-window-p} returns
@code{t} if @var{partially} is @code{nil}; if @var{partially} is
не-@code{nil}, and the character following @var{position} is fully
visible, it returns a list of the form @code{(@var{x} @var{y})}, where
@var{x} and @var{y} are the pixel coordinates relative to the top left
corner of the window; otherwise it returns an extended list of the form
@code{(@var{x} @var{y} @var{rtop} @var{rbot} @var{rowh} @var{vpos})},
where @var{rtop} and @var{rbot} specify the number of off-window pixels
at the top and bottom of the row at @var{position}, @var{rowh} specifies
the visible height of that row, and @var{vpos} specifies the vertical
position (zero-based row number) of that row.

Here is an example:

@example
@group
;; @r{If point is off the screen now, recenter it now.}
(or (pos-visible-in-window-p
     (point) (selected-window))
    (recenter 0))
@end group
@end example
@end defun

@vindex pos-visible-in-window-group-p-function
@defun pos-visible-in-window-group-p &optional position window partially
This function is like @code{pos-visible-in-window-p}, except that when
@var{window} is a part of a group of windows (@pxref{Window Group}),
@code{pos-visible-in-window-group-p} tests the visibility of @var{pos}
in the entire group, not just in the single @var{window}.  This
condition holds when the buffer local variable
@code{pos-visible-in-window-group-p-function} is set to a function.
In this case @code{pos-visible-in-window-group-p} calls the function
with the three arguments @var{position}, @var{window}, and
@var{partially}, then returns its result.  The arguments
@var{position} and @var{partially} have the same meaning as in
@code{pos-visible-in-window-p}.
@end defun

@defun window-line-height &optional line window
This function returns the height of text line @var{line} in
@var{window}.  If @var{line} is one of @code{header-line} or
@code{mode-line}, @code{window-line-height} returns information about
the corresponding line of the window.  Otherwise, @var{line} is a text
line number starting from 0.  A negative number counts from the end of
the window.  The default for @var{line} is the current line in
@var{window}; the default for @var{window} is the selected window.

If the display is not up to date, @code{window-line-height} returns
@code{nil}.  In that case, @code{pos-visible-in-window-p} may be used
to obtain related information.

If there is no line corresponding to the specified @var{line},
@code{window-line-height} returns @code{nil}.  Otherwise, it returns
a list @code{(@var{height} @var{vpos} @var{ypos} @var{offbot})},
where @var{height} is the height in pixels of the visible part of the
line, @var{vpos} and @var{ypos} are the vertical position in lines and
pixels of the line relative to the top of the first text line, and
@var{offbot} is the number of off-window pixels at the bottom of the
text line.  If there are off-window pixels at the top of the (first)
text line, @var{ypos} is negative.
@end defun

@node Textual Scrolling
@section Textual Scrolling
@cindex textual scrolling
@cindex scrolling textually

  @dfn{Textual scrolling} means moving the text up or down through a
window.  It works by changing the window's display-start location.  It
may also change the value of @code{window-point} to keep point on the
screen (@pxref{Window Point}).

  The basic textual scrolling functions are @code{scroll-up} (which
scrolls forward) and @code{scroll-down} (which scrolls backward).  In
these function names, ``up'' and ``down'' refer to the direction of
motion of the buffer text relative to the window.  Imagine that the
text is written on a long roll of paper and that the scrolling
commands move the paper up and down.  Thus, if you are looking at the
middle of a buffer and repeatedly call @code{scroll-down}, you will
eventually see the beginning of the buffer.

  Unfortunately, this sometimes causes confusion, because some people
tend to think in terms of the opposite convention: they
imagine the window moving over text that remains in place, so that
``down'' commands take you to the end of the buffer.  This convention
is consistent with fact that such a command is bound to a key named
@key{PageDown} on modern keyboards.
@ignore
We have not switched to this convention as that is likely to break
existing Emacs Lisp code.
@end ignore

  Textual scrolling functions (aside from @code{scroll-other-window})
have unpredictable results if the current buffer is not the one
displayed in the selected window.  @xref{Current Buffer}.

  If the window contains a row taller than the height of the window
(for example in the presence of a large image), the scroll functions
will adjust the window's vertical scroll position to scroll the
partially visible row.  Lisp callers can disable this feature by
binding the variable @code{auto-window-vscroll} to @code{nil}
(@pxref{Vertical Scrolling}).

@deffn Command scroll-up &optional count
This function scrolls forward by @var{count} lines in the selected
window.

If @var{count} is negative, it scrolls backward instead.  If
@var{count} is @code{nil} (or omitted), the distance scrolled is
@code{next-screen-context-lines} lines less than the height of the
window's text area.

If the selected window cannot be scrolled any further, this function
signals an error.  Otherwise, it returns @code{nil}.
@end deffn

@deffn Command scroll-down &optional count
This function scrolls backward by @var{count} lines in the selected
window.

If @var{count} is negative, it scrolls forward instead.  In other
respects, it behaves the same way as @code{scroll-up} does.
@end deffn

@deffn Command scroll-up-command &optional count
This behaves like @code{scroll-up}, except that if the selected window
cannot be scrolled any further and the value of the variable
@code{scroll-error-top-bottom} is @code{t}, it tries to move to the
end of the buffer instead.  If point is already there, it signals an
error.
@end deffn

@deffn Command scroll-down-command &optional count
This behaves like @code{scroll-down}, except that if the selected
window cannot be scrolled any further and the value of the variable
@code{scroll-error-top-bottom} is @code{t}, it tries to move to the
beginning of the buffer instead.  If point is already there, it
signals an error.
@end deffn

@deffn Command scroll-other-window &optional count
This function scrolls the text in another window upward @var{count}
lines.  Negative values of @var{count}, or @code{nil}, are handled
as in @code{scroll-up}.

You can specify which buffer to scroll by setting the variable
@code{other-window-scroll-buffer} to a buffer.  If that buffer isn't
already displayed, @code{scroll-other-window} displays it in some
window.

When the selected window is the minibuffer, the next window is normally
the leftmost one immediately above it.  You can specify a different
window to scroll, when the minibuffer is selected, by setting the variable
@code{minibuffer-scroll-window}.  This variable has no effect when any
other window is selected.  When it is не-@code{nil} and the
minibuffer is selected, it takes precedence over
@code{other-window-scroll-buffer}.  @xref{Definition of
minibuffer-scroll-window}.

When the minibuffer is active, it is the next window if the selected
window is the one at the bottom right corner.  In this case,
@code{scroll-other-window} attempts to scroll the minibuffer.  If the
minibuffer contains just one line, it has nowhere to scroll to, so the
line reappears after the echo area momentarily displays the message
@samp{End of buffer}.
@end deffn

@defvar other-window-scroll-buffer
If this variable is не-@code{nil}, it tells @code{scroll-other-window}
which buffer's window to scroll.
@end defvar

@defopt scroll-margin
This option specifies the size of the scroll margin---a minimum number
of lines between point and the top or bottom of a window.  Whenever
point gets within this many lines of the top or bottom of the window,
redisplay scrolls the text automatically (if possible) to move point
out of the margin, closer to the center of the window.
@end defopt

@defopt maximum-scroll-margin
This variable limits the effective value of @code{scroll-margin} to a
fraction of the current window line height.  For example, if the
current window has 20 lines and @code{maximum-scroll-margin} is 0.1,
then the scroll margins will never be larger than 2 lines, no matter
how big @code{scroll-margin} is.

@code{maximum-scroll-margin} itself has a maximum value of 0.5, which
allows setting margins large to keep the cursor at the middle line of
the window (or two middle lines if the window has an even number of
lines).  If it's set to a larger value (or any value other than a
float between 0.0 and 0.5) then the default value of 0.25 will be used
instead.
@end defopt

@defopt scroll-conservatively
This variable controls how scrolling is done automatically when point
moves off the screen (or into the scroll margin).  If the value is a
positive integer @var{n}, then redisplay scrolls the text up to
@var{n} lines in either direction, if that will bring point back into
proper view.  This behavior is called @dfn{conservative scrolling}.
Otherwise, scrolling happens in the usual way, under the control of
other variables such as @code{scroll-up-aggressively} and
@code{scroll-down-aggressively}.

The default value is zero, which means that conservative scrolling
never happens.
@end defopt

@defopt scroll-down-aggressively
The value of this variable should be either @code{nil} or a fraction
@var{f} between 0 and 1.  If it is a fraction, that specifies where on
the screen to put point when scrolling down.  More precisely, when a
window scrolls down because point is above the window start, the new
start position is chosen to put point @var{f} part of the window
height from the top.  The larger @var{f}, the more aggressive the
scrolling.

A value of @code{nil} is equivalent to .5, since its effect is to center
point.  This variable automatically becomes buffer-local when set in any
fashion.
@end defopt

@defopt scroll-up-aggressively
Likewise, for scrolling up.  The value, @var{f}, specifies how far
point should be placed from the bottom of the window; thus, as with
@code{scroll-down-aggressively}, a larger value scrolls more
aggressively.
@end defopt

@defopt scroll-step
This variable is an older variant of @code{scroll-conservatively}.
The difference is that if its value is @var{n}, that permits scrolling
only by precisely @var{n} lines, not a smaller number.  This feature
does not work with @code{scroll-margin}.  The default value is zero.
@end defopt

@cindex @code{scroll-command} property
@defopt scroll-preserve-screen-position
If this option is @code{t}, whenever a scrolling command moves point
off-window, Emacs tries to adjust point to keep the cursor at its old
vertical position in the window, rather than the window edge.

If the value is не-@code{nil} and not @code{t}, Emacs adjusts point
to keep the cursor at the same vertical position, even if the
scrolling command didn't move point off-window.

This option affects all scroll commands that have a не-@code{nil}
@code{scroll-command} symbol property.
@end defopt

@defopt next-screen-context-lines
The value of this variable is the number of lines of continuity to
retain when scrolling by full screens.  For example, @code{scroll-up}
with an argument of @code{nil} scrolls so that this many lines at the
bottom of the window appear instead at the top.  The default value is
@code{2}.
@end defopt

@defopt scroll-error-top-bottom
If this option is @code{nil} (the default), @code{scroll-up-command}
and @code{scroll-down-command} simply signal an error when no more
scrolling is possible.

If the value is @code{t}, these commands instead move point to the
beginning or end of the buffer (depending on scrolling direction);
only if point is already on that position do they signal an error.
@end defopt

@deffn Command recenter &optional count
@cindex centering point
This function scrolls the text in the selected window so that point is
displayed at a specified vertical position within the window.  It does
not move point with respect to the text.

If @var{count} is a non-negative number, that puts the line containing
point @var{count} lines down from the top of the window.  If
@var{count} is a negative number, then it counts upward from the
bottom of the window, so that @minus{}1 stands for the last usable
line in the window.

If @var{count} is @code{nil} (or a не-@code{nil} list),
@code{recenter} puts the line containing point in the middle of the
window.  If @var{count} is @code{nil}, this function may redraw the
frame, according to the value of @code{recenter-redisplay}.

When @code{recenter} is called interactively, @var{count} is the raw
prefix argument.  Thus, typing @kbd{C-u} as the prefix sets the
@var{count} to a не-@code{nil} list, while typing @kbd{C-u 4} sets
@var{count} to 4, which positions the current line four lines from the
top.

With an argument of zero, @code{recenter} positions the current line at
the top of the window.  The command @code{recenter-top-bottom} offers
a more convenient way to achieve this.
@end deffn

@vindex recenter-window-group-function
@defun recenter-window-group &optional count
This function is like @code{recenter}, except that when the selected
window is part of a group of windows (@pxref{Window Group}),
@code{recenter-window-group} scrolls the entire group.  This condition
holds when the buffer local variable
@code{recenter-window-group-function} is set to a function.  In this
case, @code{recenter-window-group} calls the function with the
argument @var{count}, then returns its result.  The argument
@var{count} has the same meaning as in @code{recenter}, but with
respect to the entire window group.
@end defun

@defopt recenter-redisplay
If this variable is не-@code{nil}, calling @code{recenter} with a
@code{nil} argument redraws the frame.  The default value is
@code{tty}, which means only redraw the frame if it is a tty frame.
@end defopt

@deffn Command recenter-top-bottom &optional count
This command, which is the default binding for @kbd{C-l}, acts like
@code{recenter}, except if called with no argument.  In that case,
successive calls place point according to the cycling order defined
by the variable @code{recenter-positions}.
@end deffn

@defopt recenter-positions
This variable controls how @code{recenter-top-bottom} behaves when
called with no argument.  The default value is @code{(middle top
bottom)}, which means that successive calls of
@code{recenter-top-bottom} with no argument cycle between placing
point at the middle, top, and bottom of the window.
@end defopt


@node Vertical Scrolling
@section Vertical Fractional Scrolling
@cindex vertical fractional scrolling
@cindex vertical scroll position

   @dfn{Vertical fractional scrolling} means shifting text in a window
up or down by a specified multiple or fraction of a line.  Emacs uses
it, for example, on images and screen lines which are taller than the
window.  Each window has a @dfn{vertical scroll position}, which is a
number, never less than zero.  It specifies how far to raise the
contents of the window when displaying them.  Raising the window
contents generally makes all or part of some lines disappear off the
top, and all or part of some other lines appear at the bottom.  The
usual value is zero.

   The vertical scroll position is measured in units of the normal line
height, which is the height of the default font.  Thus, if the value is
.5, that means the window contents will be scrolled up half the normal
line height.  If it is 3.3, that means the window contents are scrolled
up somewhat over three times the normal line height.

   What fraction of a line the vertical scrolling covers, or how many
lines, depends on what the lines contain.  A value of .5 could scroll a
line whose height is very short off the screen, while a value of 3.3
could scroll just part of the way through a tall line or an image.

@defun window-vscroll &optional window pixels-p
This function returns the current vertical scroll position of
@var{window}.  The default for @var{window} is the selected window.
If @var{pixels-p} is не-@code{nil}, the return value is measured in
pixels, rather than in units of the normal line height.

@example
@group
(window-vscroll)
     @result{} 0
@end group
@end example
@end defun

@defun set-window-vscroll window lines &optional pixels-p
This function sets @var{window}'s vertical scroll position to
@var{lines}.  If @var{window} is @code{nil}, the selected window is
used.  The argument @var{lines} should be zero or positive; if not, it
is taken as zero.


The actual vertical scroll position must always correspond
to an integral number of pixels, so the value you specify
is rounded accordingly.

The return value is the result of this rounding.

@example
@group
(set-window-vscroll (selected-window) 1.2)
     @result{} 1.13
@end group
@end example

If @var{pixels-p} is не-@code{nil}, @var{lines} specifies a number of
pixels.  In this case, the return value is @var{lines}.
@end defun

@defvar auto-window-vscroll
If this variable is не-@code{nil}, the @code{line-move},
@code{scroll-up}, and @code{scroll-down} functions will automatically
modify the vertical scroll position to scroll through display rows
that are taller than the height of the window, for example in the
presence of large images.
@end defvar

@node Horizontal Scrolling
@section Horizontal Scrolling
@cindex horizontal scrolling

  @dfn{Horizontal scrolling} means shifting the image in the window left
or right by a specified multiple of the normal character width.  Each
window has a @dfn{horizontal scroll position}, which is a number, never
less than zero.  It specifies how far to shift the contents left.
Shifting the window contents left generally makes all or part of some
characters disappear off the left, and all or part of some other
characters appear at the right.  The usual value is zero.

  The horizontal scroll position is measured in units of the normal
character width, which is the width of space in the default font.  Thus,
if the value is 5, that means the window contents are scrolled left by 5
times the normal character width.  How many characters actually
disappear off to the left depends on their width, and could vary from
line to line.

  Because we read from side to side in the inner loop, and from top
to bottom in the outer loop, the effect of horizontal scrolling is
not like that of textual or vertical scrolling.  Textual scrolling
involves selection of a portion of text to display, and vertical
scrolling moves the window contents contiguously; but horizontal
scrolling causes part of @emph{each line} to go off screen.

  Usually, no horizontal scrolling is in effect; then the leftmost
column is at the left edge of the window.  In this state, scrolling to
the right is meaningless, since there is no data to the left of the edge
to be revealed by it; so this is not allowed.  Scrolling to the left is
allowed; it scrolls the first columns of text off the edge of the window
and can reveal additional columns on the right that were truncated
before.  Once a window has a nonzero amount of leftward horizontal
scrolling, you can scroll it back to the right, but only so far as to
reduce the net horizontal scroll to zero.  There is no limit to how far
left you can scroll, but eventually all the text will disappear off the
left edge.

@vindex auto-hscroll-mode
  If @code{auto-hscroll-mode} is set, redisplay automatically alters
the horizontal scrolling of a window as necessary to ensure that point
is always visible.  However, you can still set the horizontal
scrolling value explicitly.  The value you specify serves as a lower
bound for automatic scrolling, i.e., automatic scrolling will not
scroll a window to a column less than the specified one.

  The default value of @code{auto-hscroll-mode} is @code{t}; setting
it to @code{current-line} activates a variant of automatic horizontal
scrolling whereby only the line showing the cursor is horizontally
scrolled to make point visible, the rest of the window is left either
unscrolled, or at the minimum scroll amount set by @code{scroll-left}
and @code{scroll-right}, see below.

@deffn Command scroll-left &optional count set-minimum
This function scrolls the selected window @var{count} columns to the
left (or to the right if @var{count} is negative).  The default
for @var{count} is the window width, minus 2.

The return value is the total amount of leftward horizontal scrolling in
effect after the change---just like the value returned by
@code{window-hscroll} (below).

Note that text in paragraphs whose base direction is right-to-left
(@pxref{Bidirectional Display}) moves in the opposite direction: e.g.,
it moves to the right when @code{scroll-left} is invoked with a
positive value of @var{count}.

Once you scroll a window as far right as it can go, back to its normal
position where the total leftward scrolling is zero, attempts to scroll
any farther right have no effect.

If @var{set-minimum} is не-@code{nil}, the new scroll amount becomes
the lower bound for automatic scrolling; that is, automatic scrolling
will not scroll a window to a column less than the value returned by
this function.  Interactive calls pass не-@code{nil} for
@var{set-minimum}.
@end deffn

@deffn Command scroll-right &optional count set-minimum
This function scrolls the selected window @var{count} columns to the
right (or to the left if @var{count} is negative).  The default
for @var{count} is the window width, minus 2.  Aside from the direction
of scrolling, this works just like @code{scroll-left}.
@end deffn

@defun window-hscroll &optional window
This function returns the total leftward horizontal scrolling of
@var{window}---the number of columns by which the text in @var{window}
is scrolled left past the left margin.  (In right-to-left paragraphs,
the value is the total amount of the rightward scrolling instead.)
The default for @var{window} is the selected window.

The return value is never negative.  It is zero when no horizontal
scrolling has been done in @var{window} (which is usually the case).


@example
@group
(window-hscroll)
     @result{} 0
@end group
@group
(scroll-left 5)
     @result{} 5
@end group
@group
(window-hscroll)
     @result{} 5
@end group
@end example
@end defun

@defun set-window-hscroll window columns
This function sets horizontal scrolling of @var{window}.  The value of
@var{columns} specifies the amount of scrolling, in terms of columns
from the left margin (right margin in right-to-left paragraphs).  The
argument @var{columns} should be zero or positive; if not, it is taken
as zero.  Fractional values of @var{columns} are not supported at
present.

Note that @code{set-window-hscroll} may appear not to work if you test
it by evaluating a call with @kbd{M-:} in a simple way.  What happens
is that the function sets the horizontal scroll value and returns, but
then redisplay adjusts the horizontal scrolling to make point visible,
and this overrides what the function did.  You can observe the
function's effect if you call it while point is sufficiently far from
the left margin that it will remain visible.

The value returned is @var{columns}.

@example
@group
(set-window-hscroll (selected-window) 10)
     @result{} 10
@end group
@end example
@end defun

   Here is how you can determine whether a given position @var{position}
is off the screen due to horizontal scrolling:

@c FIXME: Maybe hscroll-on-screen-p is a better name?
@example
@group
(defun hscroll-on-screen (window position)
  (save-excursion
    (goto-char position)
    (and
     (>= (- (current-column) (window-hscroll window)) 0)
     (< (- (current-column) (window-hscroll window))
        (window-width window)))))
@end group
@end example


@node Coordinates and Windows
@section Coordinates and Windows
@cindex frame-relative coordinate
@cindex coordinate, relative to frame
@cindex window position

This section describes functions that report positions of and within a
window.  Most of these functions report positions relative to an origin
at the native position of the window's frame (@pxref{Frame Geometry}).
Some functions report positions relative to the origin of the display of
the window's frame.  In any case, the origin has the coordinates (0, 0)
and X and Y coordinates increase rightward and downward respectively.

  For the following functions, X and Y coordinates are reported in
integer character units, i.e., numbers of lines and columns
respectively.  On a graphical display, each ``line'' and ``column''
corresponds to the height and width of the default character specified by
the frame's default font (@pxref{Frame Font}).

@defun window-edges &optional window body absolute pixelwise
This function returns a list of the edge coordinates of @var{window}.
If @var{window} is omitted or @code{nil}, it defaults to the selected
window.

The return value has the form @code{(@var{left} @var{top} @var{right}
@var{bottom})}.  These list elements are, respectively, the X
coordinate of the leftmost column occupied by the window, the Y
coordinate of the topmost row, the X coordinate one column to the
right of the rightmost column, and the Y coordinate one row down from
the bottommost row.

Note that these are the actual outer edges of the window, including any
header line, mode line, scroll bar, fringes, window divider and display
margins.  On a text terminal, if the window has a neighbor on its right,
its right edge includes the separator line between the window and its
neighbor.

If the optional argument @var{body} is @code{nil}, this means to
return the edges corresponding to the total size of @var{window}.
@var{body} не-@code{nil} means to return the edges of @var{window}'s
body (aka text area).  If @var{body} is не-@code{nil}, @var{window}
must specify a live window.

If the optional argument @var{absolute} is @code{nil}, this means to
return edges relative to the native position of @var{window}'s frame.
@var{absolute} не-@code{nil} means to return coordinates relative to
the origin (0, 0) of @var{window}'s display.  On non-graphical systems
this argument has no effect.

If the optional argument @var{pixelwise} is @code{nil}, this means to
return the coordinates in terms of the default character width and
height of @var{window}'s frame (@pxref{Frame Font}), rounded if
necessary.  @var{pixelwise} не-@code{nil} means to return the
coordinates in pixels.  Note that the pixel specified by @var{right} and
@var{bottom} is immediately outside of these edges.  If @var{absolute}
is не-@code{nil}, @var{pixelwise} is implicitly не-@code{nil} too.
@end defun

@defun window-body-edges &optional window
This function returns the edges of @var{window}'s body (@pxref{Window
Sizes}).  Calling @code{(window-body-edges window)} is equivalent to
calling @code{(window-edges window t)}, see above.
@end defun

@comment The following two functions are confusing and hardly used.
@ignore
@defun window-left-column &optional window
This function returns the leftmost column of @var{window}.  This value
equals the @var{left} entry in the list returned by @code{(window-edges
window)} minus the number of columns occupied by the internal border of
@var{window}'s frame.
@end defun

@defun window-top-line &optional window
This function returns the topmost row of @var{window}.  This value is
equal to the @var{top} entry in the list returned by @code{(window-edges
window)} minus the number of lines occupied by the internal border of
@var{window}'s frame.
@end defun
@end ignore

  The following functions can be used to relate a set of
frame-relative coordinates to a window:

@defun window-at x y &optional frame
This function returns the live window at the coordinates @var{x} and
@var{y} given in default character sizes (@pxref{Frame Font}) relative
to the native position of @var{frame} (@pxref{Frame Geometry}).

If there is no window at that position, the return value is @code{nil}.
If @var{frame} is omitted or @code{nil}, it defaults to the selected
frame.
@end defun

@defun coordinates-in-window-p coordinates window
This function checks whether a window @var{window} occupies the frame
relative coordinates @var{coordinates}, and if so, which part of the
window that is.  @var{window} should be a live window.

@var{coordinates} should be a cons cell of the form @code{(@var{x}
. @var{y})}, where @var{x} and @var{y} are given in default character
sizes (@pxref{Frame Font}) relative to the native position of
@var{window}'s frame (@pxref{Frame Geometry}).

If there is no window at the specified position, the return value is
@code{nil} .  Otherwise, the return value is one of the following:

@table @code
@item (@var{relx} . @var{rely})
The coordinates are inside @var{window}.  The numbers @var{relx} and
@var{rely} are the equivalent window-relative coordinates for the
specified position, counting from 0 at the top left corner of the
window.

@item mode-line
The coordinates are in the mode line of @var{window}.

@item header-line
The coordinates are in the header line of @var{window}.

@item right-divider
The coordinates are in the divider separating @var{window} from a
window on the right.

@item bottom-divider
The coordinates are in the divider separating @var{window} from a
window beneath.

@item vertical-line
The coordinates are in the vertical line between @var{window} and its
neighbor to the right.  This value occurs only if the window doesn't
have a scroll bar; positions in a scroll bar are considered outside the
window for these purposes.

@item left-fringe
@itemx right-fringe
The coordinates are in the left or right fringe of the window.

@item left-margin
@itemx right-margin
The coordinates are in the left or right margin of the window.

@item nil
The coordinates are not in any part of @var{window}.
@end table

The function @code{coordinates-in-window-p} does not require a frame as
argument because it always uses the frame that @var{window} is on.
@end defun

  The following functions return window positions in pixels, rather
than character units.  Though mostly useful on graphical displays,
they can also be called on text terminals, where the screen area of
each text character is taken to be one pixel.

@defun window-pixel-edges &optional window
This function returns a list of pixel coordinates for the edges of
@var{window}.  Calling @code{(window-pixel-edges window)} is equivalent
to calling @code{(window-edges window nil nil t)}, see above.
@end defun

@comment The following two functions are confusing and hardly used.
@ignore
@defun window-pixel-left &optional window
This function returns the left pixel edge of window @var{window}.  This
value equals the @var{left} entry in the list returned by
@code{(window-pixel-edges window)} minus the number of pixels occupied
by the internal border of @var{window}'s frame.  @var{window} must be a
valid window and defaults to the selected one.
@end defun

@defun window-pixel-top &optional window
This function returns the top pixel edge of window @var{window}.  This
value is equal to the @var{top} entry in the list returned by
@code{(window-pixel-edges window)} minus the number of pixels occupied
by the internal border of @var{window}'s frame.  @var{window} must be a
valid window and defaults to the selected one.
@end defun
@end ignore

@defun window-body-pixel-edges &optional window
This function returns the pixel edges of @var{window}'s body.  Calling
@code{(window-body-pixel-edges window)} is equivalent to calling
@code{(window-edges window t nil t)}, see above.
@end defun

  The following functions return window positions in pixels, relative to
the origin of the display screen rather than that of the frame:

@defun window-absolute-pixel-edges &optional window
This function returns the pixel coordinates of @var{window} relative to
an origin at (0, 0) of the display of @var{window}'s frame.  Calling
@code{(window-absolute-pixel-edges)} is equivalent to calling
@code{(window-edges window nil t t)}, see above.
@end defun

@defun window-absolute-body-pixel-edges &optional window
This function returns the pixel coordinates of @var{window}'s body
relative to an origin at (0, 0) of the display of @var{window}'s frame.
Calling @code{(window-absolute-body-pixel-edges window)} is equivalent
to calling @code{(window-edges window t t t)}, see above.

Combined with @code{set-mouse-absolute-pixel-position}, this function
can be used to move the mouse pointer to an arbitrary buffer position
visible in some window:

@example
@group
(let ((edges (window-absolute-body-pixel-edges))
      (position (pos-visible-in-window-p nil nil t)))
  (set-mouse-absolute-pixel-position
   (+ (nth 0 edges) (nth 0 position))
   (+ (nth 1 edges) (nth 1 position))))
@end group
@end example

On a graphical terminal this form ``warps'' the mouse cursor to the
upper left corner of the glyph at the selected window's point.  A
position calculated this way can be also used to show a tooltip window
there.
@end defun

The following function returns the screen coordinates of a buffer
position visible in a window:

@defun window-absolute-pixel-position &optional position window
If the buffer position @var{position} is visible in window @var{window},
this function returns the display coordinates of the upper/left corner
of the glyph at @var{position}.  The return value is a cons of the X-
and Y-coordinates of that corner, relative to an origin at (0, 0) of
@var{window}'s display.  It returns @code{nil} if @var{position} is not
visible in @var{window}.

@var{window} must be a live window and defaults to the selected
window.  @var{position} defaults to the value of @code{window-point}
of @var{window}.

This means that in order to move the mouse pointer to the position of
point in the selected window, it's sufficient to write:

@example
@group
(let ((position (window-absolute-pixel-position)))
  (set-mouse-absolute-pixel-position
   (car position) (cdr position)))
@end group
@end example
@end defun

The following function returns the largest rectangle that can be
inscribed in a window without covering text displayed in that window.

@defun window-largest-empty-rectangle &optional window count min-width min-height positions left
This function calculates the dimensions of the largest empty rectangle
that can be inscribed in the specified @var{window}'s text area.
@var{window} must be a live window and defaults to the selected one.

The return value is a triple of the width and the start and end
y-coordinates of the largest rectangle that can be inscribed into the
empty space (space not displaying any text) of the text area of
@var{window}.  No x-coordinates are returned by this function---any such
rectangle is assumed to end at the right edge of @var{window}'s text
area.  If no empty space can be found, the return value is @code{nil}.

The optional argument @var{count}, if не-@code{nil}, specifies a
maximum number of rectangles to return.  This means that the return
value is a list of triples specifying rectangles with the largest
rectangle first.  @var{count} can be also a cons cell whose car
specifies the number of rectangles to return and whose @sc{cdr}, if
не-@code{nil}, states that all rectangles returned must be disjoint.

The optional arguments @var{min-width} and @var{min-height}, if
не-@code{nil}, specify the minimum width and height of any rectangle
returned.

The optional argument @var{positions}, if не-@code{nil}, is a cons cell
whose @sc{car} specifies the uppermost and whose @sc{cdr} specifies the
lowermost pixel position that must be covered by any rectangle returned.
These positions measure from the start of the text area of @var{window}.

The optional argument @var{left}, if не-@code{nil}, means to return
values suitable for buffers displaying right to left text.  In that
case, any rectangle returned is assumed to start at the left edge of
@var{window}'s text area.

Note that this function has to retrieve the dimensions of each line of
@var{window}'s glyph matrix via @code{window-lines-pixel-dimensions}
(@pxref{Size of Displayed Text}).  Hence, this function may also return
@code{nil} when the current glyph matrix of @var{window} is not
up-to-date.
@end defun


@node Mouse Window Auto-selection
@section Mouse Window Auto-selection
@cindex window auto-selection
@cindex auto-selection of window
The following option allows to automatically select the window under the
mouse pointer.  This accomplishes a policy similar to that of window
managers that give focus to a frame (and thus trigger its subsequent
selection) whenever the mouse pointer enters its window-system window
(@pxref{Input Focus}).

@defopt mouse-autoselect-window
If this variable is не-@code{nil}, Emacs will try to automatically
select the window under the mouse pointer.  The following values are
meaningful:

@table @asis
@item A positive number
This specifies a delay in seconds after which auto-selection triggers.
The window under the mouse pointer is selected after the mouse has
remained in it for the entire duration of the delay.

@item A negative number
A negative number has a similar effect as a positive number, but selects
the window under the mouse pointer only after the mouse pointer has
remained in it for the entire duration of the absolute value of that
number and in addition has stopped moving.

@item Other value
Any other не-@code{nil} value means to select a window instantaneously
as soon as the mouse pointer enters it.
@end table

In either case, the mouse pointer must enter the text area of a window in
order to trigger its selection.  Dragging the scroll bar slider or the
mode line of a window conceptually should not cause its auto-selection.

Mouse auto-selection selects the minibuffer window only if it is active,
and never deselects the active minibuffer window.
@end defopt

Mouse auto-selection can be used to emulate a focus follows mouse policy
for child frames (@pxref{Child Frames}) which usually are not tracked by
the window manager.  This requires to set the value of
@code{focus-follows-mouse} (@pxref{Input Focus}) to a не-@code{nil}
value.  If the value of @code{focus-follows-mouse} is @code{auto-raise},
entering a child frame with the mouse will raise it automatically above
all other child frames of that frame's parent frame.


@node Window Configurations
@section Window Configurations
@cindex window configurations
@cindex saving window information

A @dfn{window configuration} records the entire layout of one
frame---all windows, their sizes, which buffers they contain, how those
buffers are scrolled, and their value of point; also their
fringes, margins, and scroll bar settings.  It also includes the value
of @code{minibuffer-scroll-window}.  As a special exception, the window
configuration does not record the value of point in the selected window
for the current buffer.

  You can bring back an entire frame layout by restoring a previously
saved window configuration.  If you want to record the layout of all
frames instead of just one, use a frame configuration instead of a
window configuration.  @xref{Frame Configurations}.

@defun current-window-configuration &optional frame
This function returns a new object representing @var{frame}'s current
window configuration.  The default for @var{frame} is the selected
frame.  The variable @code{window-persistent-parameters} specifies
which window parameters (if any) are saved by this function.
@xref{Window Parameters}.
@end defun

@defun set-window-configuration configuration
This function restores the configuration of windows and buffers as
specified by @var{configuration}, for the frame that @var{configuration}
was created for.

The argument @var{configuration} must be a value that was previously
returned by @code{current-window-configuration}.  The configuration is
restored in the frame from which @var{configuration} was made, whether
that frame is selected or not.  In some rare cases this may trigger
execution of the @code{window-size-change-functions} (@pxref{Window
Hooks}) even if the size of windows did not change at all.  The
@code{window-configuration-change-hook} functions will be called if and
only if at least one window was added to or deleted from the frame.

If the frame from which @var{configuration} was saved is dead, all this
function does is restore the three variables @code{window-min-height},
@code{window-min-width} and @code{minibuffer-scroll-window}.  In this
case, the function returns @code{nil}.  Otherwise, it returns @code{t}.

Here is a way of using this function to get the same effect
as @code{save-window-excursion}:

@example
@group
(let ((config (current-window-configuration)))
  (unwind-protect
      (progn (split-window-below nil)
             @dots{})
    (set-window-configuration config)))
@end group
@end example
@end defun

@defmac save-window-excursion forms@dots{}
This macro records the window configuration of the selected frame,
executes @var{forms} in sequence, then restores the earlier window
configuration.  The return value is the value of the final form in
@var{forms}.

Most Lisp code should not use this macro; @code{save-selected-window}
is typically sufficient.  In particular, this macro cannot reliably
prevent the code in @var{forms} from opening new windows, because new
windows might be opened in other frames (@pxref{Choosing Window}), and
@code{save-window-excursion} only saves and restores the window
configuration on the current frame.

Do not use this macro in @code{window-size-change-functions}; exiting
the macro triggers execution of @code{window-size-change-functions},
leading to an endless loop.
@end defmac

@defun window-configuration-p object
This function returns @code{t} if @var{object} is a window configuration.
@end defun

@defun compare-window-configurations config1 config2
This function compares two window configurations as regards the
structure of windows, but ignores the values of point and the
saved scrolling positions---it can return @code{t} even if those
aspects differ.

The function @code{equal} can also compare two window configurations; it
regards configurations as unequal if they differ in any respect, even a
saved point.
@end defun

@defun window-configuration-frame config
This function returns the frame for which the window configuration
@var{config} was made.
@end defun

  Other primitives to look inside of window configurations would make
sense, but are not implemented because we did not need them.  See the
file @file{winner.el} for some more operations on windows
configurations.

  The objects returned by @code{current-window-configuration} die
together with the Emacs process.  In order to store a window
configuration on disk and read it back in another Emacs session, you
can use the functions described next.  These functions are also useful
to clone the state of a frame into an arbitrary live window
(@code{set-window-configuration} effectively clones the windows of a
frame into the root window of that very frame only).

@cindex window state
@defun window-state-get &optional window writable
This function returns the state of @var{window} as a Lisp object.  The
argument @var{window} must be a valid window and defaults to the root
window of the selected frame.

If the optional argument @var{writable} is не-@code{nil}, this means to
not use markers for sampling positions like @code{window-point} or
@code{window-start}.  This argument should be не-@code{nil} when the
state will be written to disk and read back in another session.

Together, the argument @var{writable} and the variable
@code{window-persistent-parameters} specify which window parameters are
saved by this function.  @xref{Window Parameters}.
@end defun

The value returned by @code{window-state-get} can be used in the same
session to make a clone of a window in another window.  It can be also
written to disk and read back in another session.  In either case, use
the following function to restore the state of the window.

@defun window-state-put state &optional window ignore
This function puts the window state @var{state} into @var{window}.
The argument @var{state} should be the state of a window returned by
an earlier invocation of @code{window-state-get}, see above.  The
optional argument @var{window} can be either a live window or an
internal window (@pxref{Windows and Frames}) and defaults to the
selected one.  If @var{window} is not live, it is replaced by a live
window before putting @var{state} into it.

If the optional argument @var{ignore} is не-@code{nil}, it means to ignore
minimum window sizes and fixed-size restrictions.  If @var{ignore}
is @code{safe}, this means windows can get as small as one line
and/or two columns.
@end defun

The functions @code{window-state-get} and @code{window-state-put} also
allow to exchange the contents of two live windows.  The following
function does precisely that:

@deffn Command window-swap-states &optional window-1 window-2 size
This command swaps the states of the two live windows @var{window-1} and
@var{window-2}.  @var{window-1} must specify a live window and defaults
to the selected one.  @var{window-2} must specify a live window and
defaults to the window following @var{window-1} in the cyclic ordering
of windows, excluding minibuffer windows and including live windows on
all visible frames.

Optional argument @var{size} не-@code{nil} means to try swapping the
sizes of @var{window-1} and @var{window-2} as well.  A value of
@code{height} means to swap heights only, a value of @code{width}
means to swap widths only, while @code{t} means to swap both widths
and heights, if possible.  Frames are not resized by this function.
@end deffn


@node Window Parameters
@section Window Parameters
@cindex window parameters

This section describes the window parameters that can be used to
associate additional information with windows.

@defun window-parameter window parameter
This function returns @var{window}'s value for @var{parameter}.  The
default for @var{window} is the selected window.  If @var{window} has no
setting for @var{parameter}, this function returns @code{nil}.
@end defun

@defun window-parameters &optional window
This function returns all parameters of @var{window} and their values.
The default for @var{window} is the selected window.  The return value
is either @code{nil}, or an association list whose elements have the form
@code{(@var{parameter} . @var{value})}.
@end defun

@defun set-window-parameter window parameter value
This function sets @var{window}'s value of @var{parameter} to
@var{value} and returns @var{value}.  The default for @var{window}
is the selected window.
@end defun

By default, the functions that save and restore window configurations or the
states of windows (@pxref{Window Configurations}) do not care about
window parameters.  This means that when you change the value of a
parameter within the body of a @code{save-window-excursion}, the
previous value is not restored when that macro exits.  It also means
that when you restore via @code{window-state-put} a window state saved
earlier by @code{window-state-get}, all cloned windows have their
parameters reset to @code{nil}.  The following variable allows you to
override the standard behavior:

@cindex persistent window parameters
@defvar window-persistent-parameters
This variable is an alist specifying which parameters get saved by
@code{current-window-configuration} and @code{window-state-get}, and
subsequently restored by @code{set-window-configuration} and
@code{window-state-put}.  @xref{Window Configurations}.

The @sc{car} of each entry of this alist is a symbol specifying the
parameter.  The @sc{cdr} should be one of the following:

@table @asis
@item @code{nil}
This value means the parameter is saved neither by
@code{window-state-get} nor by @code{current-window-configuration}.

@item @code{t}
This value specifies that the parameter is saved by
@code{current-window-configuration} and (provided its @var{writable}
argument is @code{nil}) by @code{window-state-get}.

@item @code{writable}
This means that the parameter is saved unconditionally by both
@code{current-window-configuration} and @code{window-state-get}.  This
value should not be used for parameters whose values do not have a read
syntax.  Otherwise, invoking @code{window-state-put} in another session
may fail with an @code{invalid-read-syntax} error.
@end table
@end defvar

Some functions (notably @code{delete-window},
@code{delete-other-windows} and @code{split-window}), may behave
specially when the window specified by their @var{window} argument has
a parameter whose name is equal to the function's name.  You can
override such special behavior by binding the following variable to a
не-@code{nil} value:

@defvar ignore-window-parameters
If this variable is не-@code{nil}, some standard functions do not
process window parameters.  The functions currently affected by this are
@code{split-window}, @code{delete-window}, @code{delete-other-windows},
and @code{other-window}.

An application can bind this variable to a не-@code{nil} value around
calls to these functions.  If it does so, the application is fully
responsible for correctly assigning the parameters of all involved
windows when exiting that function.
@end defvar

The following parameters are currently used by the window management
code:

@table @code
@item delete-window
@vindex delete-window@r{, a window parameter}
This parameter affects the execution of @code{delete-window}
(@pxref{Deleting Windows}).

@item delete-other-windows
@vindex delete-other-windows@r{, a window parameter}
This parameter affects the execution of @code{delete-other-windows}
(@pxref{Deleting Windows}).

@item no-delete-other-windows
@vindex no-delete-other-windows@r{, a window parameter}
This parameter marks the window as not deletable by
@code{delete-other-windows} (@pxref{Deleting Windows}).

@item split-window
@vindex split-window@r{, a window parameter}
This parameter affects the execution of @code{split-window}
(@pxref{Splitting Windows}).

@item other-window
@vindex other-window@r{, a window parameter}
This parameter affects the execution of @code{other-window}
(@pxref{Cyclic Window Ordering}).

@item no-other-window
@vindex no-other-window@r{, a window parameter}
This parameter marks the window as not selectable by @code{other-window}
(@pxref{Cyclic Window Ordering}).

@item clone-of
@vindex clone-of@r{, a window parameter}
This parameter specifies the window that this one has been cloned
from.  It is installed by @code{window-state-get} (@pxref{Window
Configurations}).

@item window-preserved-size
@vindex window-preserved-size@r{, a window parameter}
This parameter specifies a buffer, a direction where @code{nil} means
vertical and @code{t} horizontal, and a size in pixels.  If this window
displays the specified buffer and its size in the indicated direction
equals the size specified by this parameter, then Emacs will try to
preserve the size of this window in the indicated direction.  This
parameter is installed and updated by the function
@code{window-preserve-size} (@pxref{Preserving Window Sizes}).

@item quit-restore
@vindex quit-restore@r{, a window parameter}
This parameter is installed by the buffer display functions
(@pxref{Choosing Window}) and consulted by @code{quit-restore-window}
(@pxref{Quitting Windows}).  It is a list of four elements, see the
description of @code{quit-restore-window} in @ref{Quitting Windows}
for details.

@item window-side
@itemx window-slot
@vindex window-side@r{, a window parameter}
@vindex window-slot@r{, a window parameter}
These parameters are used internally for implementing side windows
(@pxref{Side Windows}).

@item window-atom
@vindex window-atom@r{, a window parameter}
This parameter is used internally for implementing atomic windows, see
@ref{Atomic Windows}.

@item mode-line-format
@vindex mode-line-format@r{, a window parameter}
This parameter replaces the value of the buffer-local variable
@code{mode-line-format} (@pxref{Mode Line Basics}) of this window's
buffer whenever this window is displayed.  The symbol @code{none} means
to suppress display of a mode line for this window.  Display and
contents of the mode line on other windows showing this buffer are not
affected.

@item header-line-format
@vindex header-line-format@r{, a window parameter}
This parameter replaces the value of the buffer-local variable
@code{header-line-format} (@pxref{Mode Line Basics}) of this window's
buffer whenever this window is displayed.  The symbol @code{none} means
to suppress display of a header line for this window.  Display and
contents of the header line on other windows showing this buffer are not
affected.

@item min-margins
@vindex min-margins@r{, a window parameter}
The value of this parameter is a cons cell whose @sc{car} and
@sc{cdr}, if не-@code{nil}, specify the minimum values (in columns)
for the left and right margin of this window (@pxref{Display Margins}.
When present, Emacs will use these values instead of the actual margin
widths for determining whether a window can be split or shrunk
horizontally.

Emacs never auto-adjusts the margins of any window after splitting or
resizing it.  It is the sole responsibility of any application setting
this parameter to adjust the margins of this window as well as those of
any new window that inherits this window's margins due to a split.
Both @code{window-configuration-change-hook} and
@code{window-size-change-functions} (@pxref{Window Hooks}) should be
employed for this purpose.

This parameter was introduced in Emacs version 25.1 to support
applications that use large margins to center buffer text within a
window and should be used, with due care, exclusively by those
applications.  It might be replaced by an improved solution in future
versions of Emacs.
@end table

@node Window Hooks
@section Hooks for Window Scrolling and Changes
@cindex hooks for window operations

This section describes how a Lisp program can take action whenever a
window displays a different part of its buffer or a different buffer.
There are three actions that can change this: scrolling the window,
switching buffers in the window, and changing the size of the window.
The first two actions run @code{window-scroll-functions}; the last runs
@code{window-size-change-functions}.

@defvar window-scroll-functions
This variable holds a list of functions that Emacs should call before
redisplaying a window with scrolling.  Displaying a different buffer in
the window also runs these functions.

This variable is not a normal hook, because each function is called with
two arguments: the window, and its new display-start position.  At the
time of the call, the display-start position of the window argument is
already set to its new value, and the buffer to be displayed in the
window is already set as the current buffer.

These functions must take care when using @code{window-end}
(@pxref{Window Start and End}); if you need an up-to-date value, you
must use the @var{update} argument to ensure you get it.

@strong{Warning:} don't use this feature to alter the way the window
is scrolled.  It's not designed for that, and such use probably won't
work.
@end defvar

@defun run-window-scroll-functions &optional window
This function calls @code{window-scroll-functions} for the specified
@var{window}, which defaults to the selected window.
@end defun

@defvar window-size-change-functions
This variable holds a list of functions to be called if the size of any
window changes for any reason.  The functions are called once per
redisplay, and once for each frame on which size changes have occurred.

Each function receives the frame as its sole argument.  To find out
whether a specific window has changed size, compare the return values of
@code{window-pixel-width-before-size-change} and
@code{window-pixel-width} respectively
@code{window-pixel-height-before-size-change} and
@code{window-pixel-height} for that window (@pxref{Window Sizes}).

These function are usually only called when at least one window was
added or has changed size since the last time this hook was run for
the associated frame.  In some rare cases this hook also runs when a
window that was added intermittently has been deleted afterwards.  In
these cases none of the windows on the frame will appear to have
changed its size.
@end defvar

@defvar window-configuration-change-hook
A normal hook that is run every time the window configuration of a
frame changes.  Window configuration changes include splitting and
deleting windows, and the display of a different buffer in a window.

The hook can be also used for tracking changes of window sizes.  It
is, however, not run when the size of a frame changes or automatic
resizing of a minibuffer window (@pxref{Minibuffer Windows}) changes
the size of another window.  As a rule, adding a function to
@code{window-size-change-functions}, see above, is the recommended way
for reliably tracking size changes of any window.

The buffer-local value of this hook is run once for each window on the
affected frame, with the relevant window selected and its buffer
current.  The global value of this hook is run once for the modified
frame, with that frame selected.
@end defvar

@defun run-window-configuration-change-hook &optional frame
This function runs @code{window-configuration-change-hook} for the
specified @var{frame}, which defaults to the selected frame.
@end defun

  In addition, you can use @code{jit-lock-register} to register a Font
Lock fontification function, which will be called whenever parts of a
buffer are (re)fontified because a window was scrolled or its size
changed.  @xref{Other Font Lock Variables}.
