@c -*- mode: texinfo; coding: utf-8 -*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1993, 1995, 1998-1999, 2001-2019 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Tips
@appendix Советы и Условные Обозначения
@cindex tips for writing Lisp
@cindex standards of coding style
@cindex coding standards

  Эта глава не описывает никаких дополнительных возможностей Emacs Lisp.  Вместо
этого дает советы по эффективному использованию возможностей, описанных в предыдущих
главах, и описывает соглашения, которым должны следовать программисты Emacs Lisp.

@findex checkdoc
@findex checkdoc-current-buffer
@findex checkdoc-file
  Можно автоматически проверить некоторые из соглашений, описанных ниже, запустив
команду @kbd{M-x checkdoc @key{RET}} при посещении файла Lisp.  Не выйдет проверить
все условные обозначения, и не все предупреждения, которые выдаются, обязательно
соответствуют проблемам, но стоит изучить их все.  В качестве альтернативы
использовать команду @kbd{M-x checkdoc-current-buffer @key{RET}}, чтобы проверить
соглашения в текущем буфере, или @code{checkdoc-file}, если требуется проверить файл
в пакетном режиме, например, с помощью команды, выполняемой
@kbd{@w{M-x compile @key{RET}}}.

@menu
* Coding Conventions::        Условные обозначения для чистых и надежных программ.
* Key Binding Conventions::   Какие ключи должны быть связаны какими программами.
* Programming Tips::          Приведение кода Emacs в соответствие с Emacs.
* Compilation Tips::          Обеспечение быстрой работы скомпилированного кода.
* Warning Tips::              Отключение предупреждений компилятора.
* Documentation Tips::        Написание читаемых строк документации.
* Comment Tips::              Правила написания комментариев.
* Library Headers::           Стандартные заголовки для библиотечных пакетов.
@end menu

@node Coding Conventions
@section Соглашения о кодировании Emacs Lisp

@cindex coding conventions in Emacs Lisp
  Вот соглашения, которым требуется следовать при написании кода Emacs Lisp,
предназначенного для широкого использования:

@itemize @bullet
@item
Простая загрузка пакета не должна изменять поведение Emacs при редактировании.
Включить команду или команды для включения и отключения функции или для ее вызова.

Это соглашение является обязательным для любого файла, который включает
пользовательские определения.  Если для исправления такого файла в соответствии с этим
соглашением требуется несовместимое изменение, сделайте несовместимое изменение; не
откладывать это.

@item
Требуется выбрать короткое слово, чтобы отличить программу от других программ на
Lisp.  Имена всех глобальных символов в программе, то есть имена переменных, констант
и функций, должны начинаться с выбранного префикса.  Отделитm префикс от остальной
части имени дефисом @samp{-}.  Эта практика помогает избежать конфликтов имен,
поскольку все глобальные переменные в Emacs Lisp используют одно и то же пространство
имен, а все функции совместно используют другое пространство имен @footnote{Считается,
что преимущества системы пакетов в стиле Common Lisp не перевешивают затрат.}.
Используйте два дефиса для разделения префикса и имени, если символ не предназначен
для использования другими пакетами.

Иногда для имени команды, предназначенной для использования пользователями, удобнее,
если перед префиксом имени пакета стоит несколько слов.  Например, по соглашению
команды, перечисляющие объекты с именем @samp{list-@var{something}}, например, пакет
с именем @samp{frob} может иметь команду @samp{list-frobs}, когда другие его
глобальные символы начинаются с @samp{frob-}.  Кроме того, конструкции, которые
определяют функции, переменные и так далее, работают лучше, если начинаются с
@samp{defun} или @samp{defvar}, поэтому вставить префикс имени позже в имя.

Эта рекомендация применима даже к именам традиционных примитивов Lisp, которые не
являются примитивами в Emacs Lisp, например, @code{copy-list}.  Хотите верьте, хотите
нет, но существует более одного правдоподобного способа определить @code{copy-list}.
Играть безопасно; добавить префикс своего имени, чтобы вместо него получилось имя
типа @code{foo-copy-list} или @code{mylib-copy-list}.

Если писать функцию, которую, следует добавить в Emacs под определенным именем,
например @code{twiddle-files}, не называть ее этим именем в программе. Назвать её
@code{mylib-twiddle-files} в программе и отправить письмо на
@samp{bug-gnu-emacs@@gnu.org} с предложением добавить его в Emacs.  Если и когда это
осуществится, можно достаточно легко изменить имя.

Если одного префикса недостаточно, пакет может использовать два или три альтернативных
общих префикса, если это имеет смысл.

@item
Добавить вызов @code{provide} в конец каждого отдельного файла Lisp.
@xref{Named Features}.

@item
Если файл требует предварительной загрузки некоторых других программ на Lisp, то об
этом должно быть сказано в комментариях в начале файла.  Также использовать
@code{require}, чтобы убедиться, что они загружены.  @xref{Named Features}.

@item
Если файл @var{foo} использует макрос, определенный в другом файле @var{bar}, но не
использует никаких функций или переменных, определенных в @var{bar}, то @var{foo}
должно содержать следующее выражение:

@example
(eval-when-compile (require '@var{bar}))
@end example

@noindent
Указывает Emacs загрузить @var{bar} непосредственно перед байт-компиляцией @var{foo},
чтобы определение макроса было доступно во время компиляции.  Использование
@code{eval-when-compile} позволяет избежать загрузки @var{bar}, когда
@emph{используется} скомпилированная версия @var{foo}.  Это следует вызывать перед
первым использованием макроса в файле.  @xref{Compiling Macros}.

@item
Избегать загрузки дополнительных библиотек во время выполнения, если они действительно
не нужны.  Если файл просто не может работать без какой-либо другой библиотеки, тогда
просто обрезать эту библиотеку на верхнем уровне и покончить с ней.  Но если файл
содержит несколько независимых функций, и только для одного или двух требуется
дополнительная библиотека, рассмотреть возможность размещения операторов
@code{require} внутри соответствующих функций, а не на верхнем уровне.  Или
использовать операторы @code{autoload} для загрузки дополнительной библиотеки, когда
это необходимо.  Таким образом, людям, которые не используют эти аспекты файла, не
требуется загружать дополнительную библиотеку.

@item
Если нужны расширения Common Lisp, использовать библиотеку @code{cl-lib}, а не старую
библиотеку @code{cl}.  Последнее не использует чистое пространство имен (то есть её
определения не начинаются с префикса @samp{cl-}).  Если пакет загружает @code{cl} во
время выполнения, это может вызвать конфликты имен для пользователей, которые не
используют этот пакет.

Нет проблем с использованием пакета @code{cl} во время @emph{компиляции}, с
@code{(eval-when-compile (require 'cl))}.  Этого достаточно для использования макросов
в пакете @code{cl}, потому что компилятор расширяет их перед генерацией байт-кода.
Однако в этом случае все же лучше использовать более современный @code{cl-lib}.

@item
При определении основного режима следовать правилам основного режима.
@xref{Major Mode Conventions}.

@item
При определении второстепенного режима следуйте правилам второстепенного режима.
@xref{Minor Mode Conventions}.

@item
Если цель функции - сказать, истинно ли определенное условие или нет, дать функции
имя, которое заканчивается на @samp{p} (что означает ``предикат'').  Если имя состоит
из одного слова, добавить просто @samp{p}; если имя состоит из нескольких слов,
добавить @samp{-p}.  Примеры: @code{framep} и @code{frame-live-p}.

@item
Если цель переменной - сохранить одну функцию, дать ей имя, заканчивающееся на
@samp{-function}.  Если целью переменной является хранение списка функций (то есть
переменная является ловушкой), пожалуйста, следовать соглашениям об именах для
ловушек.  @xref{Hooks}.

@item
@cindex unloading packages, preparing for
Если загрузка файла добавляет функции к перехватчикам, определить функцию
@code{@var{feature}-unload-function}, где @var{feature} - это имя функции,
предоставляемой пакетом, и отменить любые такие изменения.  Использование
@code{unload-feature} для выгрузки файла запустит эту функцию.  @xref{Unloading}.

@item
Определение псевдонимов для примитивов Emacs - плохая идея.  Обычно вместо этого
следует использовать стандартные имена.  Случай, когда псевдоним может быть полезен,
- это когда он способствует обратной совместимости или переносимости.

@item
Если пакету необходимо определить псевдоним или новую функцию для совместимости с
какой-либо другой версией Emacs, назвать его префиксом пакета, а не исходным именем,
с которым встречается в другой версии.  Вот пример от Gnus, который предоставляет
множество примеров таких проблем с совместимостью.

@example
(defalias 'gnus-point-at-bol
  (if (fboundp 'point-at-bol)
      'point-at-bol
    'line-beginning-position))
@end example

@item
Переопределять или рекомендовать примитив Emacs - плохая идея.  Это может быть
правильным для конкретной программы, но неизвестно, какие другие программы могут
сломаться в результате.

@item
Точно так же плохая идея для одного пакета Lisp рекомендовать функцию в другом
пакете Lisp.  (@pxref{Advising Functions}).

@item
Избегать использования @code{eval-after-load} и @code{with-eval-after-load} в
библиотеках и пакетах (@pxref{Hooks for Loading}).  Эта функция предназначена для
личных настроек; использовать её в программе на lisp нечисто, потому что изменяется
поведение другого файла Lisp таким образом, который не виден в этом файле.  Это
препятствие для отладки, очень похоже на функцию рекомендацию в другом пакете.

@item
Если файл действительно заменяет какие-либо стандартные функции или библиотечные
программы Emacs, заметные комментарии в начале файла должны указывать, какие функции
заменяются и чем поведение замен отличается от поведения оригиналов.

@item
Конструкции, определяющие функцию или переменную, должны быть макросами, а не
функциями, и их имена должны начинаться с @samp{define-}.  Макрос должен получить имя,
которое будет определено в качестве первого аргумента.  Это поможет различным
инструментам автоматически находить определение.  Избегать создания имен в самом
макросе, поскольку это может сбить с толку эти инструменты.

@item
В некоторых других системах существует соглашение о выборе имен переменных, которые
начинаются и заканчиваются на @samp{*}.  Не используется это соглашение в Emacs Lisp,
поэтому, пожалуйста, не использовать его в программах.  (Emacs использует такие имена
только для буферов специального назначения.)  Люди сочтут Emacs более согласованным,
если все библиотеки используют одни и те же соглашения.

@item
Система кодирования файлов по умолчанию для исходных файлов Emacs Lisp - UTF-8
(@pxref{Text Representations}).  В редких случаях, когда программа содержит символы,
которые @emph{не} являются UTF-8, потребуется указать соответствующую систему
кодирования в строке @samp{-*-} исходного файла или в списке локальных переменных.
@xref{File Variables, , Local Variables in Files, emacs, The GNU Emacs Manual}.

@item
Сделать отступ файла, используя параметры отступа по умолчанию.

@item
Не делать привычкой ставить закрывающие скобки на строки сами по себе;
Программистов на Lisp это смущает.

@item
Пожалуйста, поместить уведомление об авторских правах и уведомление о разрешении на
копирование в файл, если распространяются копии.  @xref{Library Headers}.

@end itemize

@node Key Binding Conventions
@section Основные Соглашения о Привязке
@cindex key binding, conventions for

@itemize @bullet
@item
@cindex mouse-2
@cindex references, following
Многие специальные основные режимы, такие как Dired, Info, Compilation и Occur,
предназначены для обработки текста, доступного только для чтения, который содержит
@dfn{гиперссылки}.  Такой основной режим должен переопределить @kbd{mouse-2} и
@key{RET} для перехода по ссылкам.  Также требуется установить условие
@code{follow-link}, чтобы ссылка подчинялась @code{mouse-1-click-follows-link}.
@xref{Clickable Text}.  @xref{Buttons}, для простого способа реализации таких
интерактивных ссылок.

@item
@cindex reserved keys
@cindex keys, reserved
Не определять @kbd{C-c @var{letter}} как ключ в программах на Lisp.
Последовательности, состоящие из @kbd{C-c} и буквы (верхнего или нижнего регистра),
зарезервированы для пользователей; это @strong{единственные} последовательности,
зарезервированные для пользователей, поэтому не блокировать их.

Изменение всех основных режимов Emacs в соответствии с этим соглашением потребовало
много усилий; отказ от этой конвенции сделает эту работу напрасной и доставит
неудобства пользователям.  Пожалуйста, соблюдать это.

@item
Функциональные клавиши с @key{F5} по @key{F9} без клавиш-модификаторов также
зарезервированы для определения пользователями.

@item
Последовательности, состоящие из @kbd{C-c}, за которыми следует управляющий символ
или цифра, зарезервированы для основных режимов.

@item
Последовательности, состоящие из @kbd{C-c}, за которым следует @kbd{@{}, @kbd{@}},
@kbd{<}, @kbd{>}, @kbd{:} или @kbd{;}, также зарезервированы для основных режимов.

@item
Последовательности, состоящие из @kbd{C-c}, за которым следует любой другой знак
препинания или символ @acronym{ASCII}, выделяются для второстепенных режимов.
Использование их в основном режиме не является абсолютно запрещенным, но если это
сделать, привязка основного режима может время от времени затеняться второстепенными
режимами.

@item
Не привязывать @kbd{C-h} к любому символу префикса (включая @kbd{C-c}).  Если не
привязывать @kbd{C-h}, оно автоматически доступно в качестве символа справки для
перечисления подкоманд символа префикса.

@item
Не привязывать последовательность ключей, оканчивающуюся на @key{ESC}, кроме следующих
за другим @key{ESC}.  (То есть можно связать последовательность, заканчивающуюся на
@kbd{@key{ESC} @key{ESC}}.)

Причина этого правила в том, что привязка без префикса для @key{ESC} в любом контексте
предотвращает распознавание escape-последовательностей как функциональных клавиш в
этом контексте.

@item
Точно так же не привязывать последовательность ключей, заканчивающуюся на @kbd{C-g},
поскольку это обычно используется для отмены последовательности ключей.

@item
Все, что действует как временный режим или состояние, в которое пользователь может
войти и выйти, должно определять @kbd{@key{ESC} @key{ESC}} или
@kbd{@key{ESC} @key{ESC} @key{ESC}} как способ выхода.

Для состояния, которое принимает обычные команды Emacs, или, в более общем смысле,
любого состояния, в котором потенциально значимым является @key{ESC}, за которым
следует функциональная клавиша или клавиша со стрелкой, тогда не нужно определять
@kbd{@key{ESC} @key{ESC}}, так как это помешает распознать escape-последовательность
после @key{ESC}.  В этих состояниях потребуется определить
@kbd{@key{ESC} @key{ESC} @key{ESC}} как способ выхода.  В противном случае вместо
этого определить @kbd{@key{ESC} @key{ESC}}.
@end itemize

@node Programming Tips
@section Советы по Программированию в Emacs
@cindex programming conventions

  Следование этим соглашениям поможет программе лучше вписаться в Emacs при
ее запуске.

@itemize @bullet
@item
Не использовать @code{next-line} или @code{previous-line} в программах; почти всегда
@code{forward-line} удобнее, а также более предсказуемо и надежно.  @xref{Text Lines}.

@item
Не вызывать функции, устанавливающие метку, если установка метки не является одной из
предполагаемых функций программы.  Метка - это функция на уровне пользователя, поэтому
ее нельзя изменять, кроме как для указания значения в интересах пользователя.
@xref{The Mark}.

В частности, не использовать ни одну из этих функций:

@itemize @bullet
@item
@code{beginning-of-buffer}, @code{end-of-buffer}
@item
@code{replace-string}, @code{replace-regexp}
@item
@code{insert-file}, @code{insert-buffer}
@end itemize

Если просто требуется переместить точку, или заменить определенную строку, или
вставить содержимое файла или буфера, без каких-либо других функций, предназначенных
для интерактивных пользователей, можно заменить эти функции одной или двумя строками
простого кода Lisp.

@item
Использовать списки, а не векторы, за исключением случаев, когда есть особая причина
для использования вектора.  В Lisp больше возможностей для работы со списками, чем с
векторами, и работа со списками обычно более удобна.

Векторы выгодны для таблиц, которые имеют значительный размер и доступ к ним
осуществляется в случайном порядке (поиск не выполняется спереди назад), при условии,
что нет необходимости вставлять или удалять элементы (это позволяют только списки).

@item
Рекомендуемый способ показать сообщение в эхо-области - использовать функцию
@code{message}, а не @code{princ}.  @xref{The Echo Area}.

@item
Когда столкнуться с ошибкой, вызвать функцию @code{error} (или @code{signal}).
Функция @code{error} не возвращает.  @xref{Signaling Errors}.

Не использовать @code{message}, @code{throw}, @code{sleep-for} или @code{beep} для
сообщения об ошибках.

@item
Сообщение об ошибке должно начинаться с заглавной буквы, но не заканчиваться точкой.

@item
Вопрос, задаваемый в минибуфере с @code{yes-or-no-p} или @code{y-or-n-p}, должен
начинаться с заглавной буквы и заканчиваться @samp{? }.

@item
Когда упоминается значение по умолчанию в приглашении минибуфера, поместить его и
слово @samp{default} в круглые скобки.  Должно получиться так:

@example
Enter the answer (default 42):
@end example

@item
В @code{interactive}, если используется выражение Lisp для создания списка аргументов,
не пытаться предоставить правильные значения по умолчанию для аргументов региона или
позиции.  Вместо этого предоставить @code{nil} для этих аргументов, если они не
указаны, и попросить тело функции вычислить значение по умолчанию, если аргумент -
@code{nil}.  Например, написать это:

@example
(defun foo (pos)
  (interactive
   (list (if @var{specified} @var{specified-pos})))
  (unless pos (setq pos @var{default-pos}))
  ...)
@end example

@noindent
а не это:

@example
(defun foo (pos)
  (interactive
   (list (if @var{specified} @var{specified-pos}
             @var{default-pos})))
  ...)
@end example

@noindent
Это сделано для того, чтобы повторение команды пересчитало эти значения по умолчанию
в зависимости от текущих обстоятельств.

Не нужно принимать такие меры предосторожности при использовании интерактивных
спецификаций @samp{d}, @samp{m} и @samp{r}, потому что они принимают специальные
меры для пересчета значений аргументов при повторении команды.

@item
Многие команды, выполнение которых занимает много времени, при запуске выводят
сообщение, которое говорит что-то вроде @samp{Operating...}, и меняют его на
@samp{Operating...done} по завершении.  Пожалуйста, сохранять единообразный стиль
этих сообщений: @emph{без} пробела вокруг многоточия и @emph{без} точки после
@samp{done}.  @xref{Progress}, чтобы упростить создание таких сообщений.

@item
Стараться избегать рекурсивного редактирования.  Вместо этого сделать то, что делает
команда Rmail @kbd{e}: использовать новую локальную карту, содержащую команду,
определенную для возврата к старой локальной ключевой карте.  Или просто переключиться
на другой буфер и позволить пользователю переключиться обратно по желанию.
@xref{Recursive Editing}.
@end itemize

@node Compilation Tips
@section Советы по Ускорению Скомпилированного Кода
@cindex execution speed
@cindex speedups

  Вот способы улучшить скорость выполнения байт-скомпилированных программ на Lisp.

@itemize @bullet
@item
Профилировать свою программу, чтобы узнать, на что тратиться время.
@xref{Profiling}.

@item
По возможности использовать итерацию, а не рекурсию.  Вызов функций в Emacs Lisp
выполняется медленно, даже когда скомпилированная функция вызывает другую
скомпилированную функцию.

@item
Использование примитивных функций поиска по списку @code{memq}, @code{member},
@code{assq} или @code{assoc} даже быстрее, чем явная итерация.  Возможно, стоит
перестроить структуру данных так, чтобы можно было использовать одну из этих
примитивных функций поиска.

@item
Некоторые встроенные функции обрабатываются особым образом в байт-скомпилированном
коде, что позволяет избежать необходимости в обычном вызове функции.  Рекомендуется
использовать эти функции, а не альтернативы.  Чтобы узнать, обрабатывается ли функция
специально компилятором, изучить ее свойство @code{byte-compile}.  Если свойство -
не-@code{nil}, то функция обрабатывается особым образом.

Например, следующий ввод покажет, что @code{aref} скомпилирована специально
(@pxref{Array Functions}):

@example
@group
(get 'aref 'byte-compile)
     @result{} byte-compile-two-args
@end group
@end example

@noindent
Обратить внимание, что в этом случае (и во многих других) потребуется сначала
загрузить библиотеку @file{bytecomp}, которая определяет свойство @code{byte-compile}.

@item
Если на вызов небольшой функции приходится значительная часть времени выполнения
программы, сделать функцию встроенной.  Это устраняет накладные расходы на вызов
функции.  Поскольку встроенная функция снижает гибкость изменения программы, не
делать этого, если это не дает заметного ускорения в чем-то достаточно медленном,
чтобы пользователи заботились о скорости.  @xref{Inline Functions}.
@end itemize

@node Warning Tips
@section Советы по Тому, как Избежать Предупреждения Компилятора
@cindex byte compiler warnings, how to avoid

@itemize @bullet
@item
Стараться избегать предупреждений компилятора о неопределенных свободных переменных,
добавляя фиктивные определения @code{defvar} для этих переменных, например:

@example
(defvar foo)
@end example

Такое определение не имеет никакого эффекта, кроме указания компилятору не
предупреждать об использовании переменной @code{foo} в этом файле.

@item
Точно так же, чтобы избежать предупреждения компилятора о неопределенной функции,
которая, как известно, @emph{будет} определена, использовать оператор
@code{declare-function} (@pxref{Declaring Functions}).

@item
Если использовать много функций, макросов и переменных из определенного файла, можно
добавить @code{require} (@pxref{Named Features, require}) для этого пакета, чтобы
избежать предупреждений компиляции для них, например:

@example
(require 'foo)
@end example

@noindent
Если нужны только макросы из какого-то файла, можно потребовать их только во время
компиляции (@pxref{Eval During Compile}).  Например,

@example
(eval-when-compile
  (require 'foo))
@end example

@item
Если привязать переменную к одной функции и использовать ее или устанавливать в другой
функции, компилятор предупреждает о последней функции, если переменная не имеет
определения.  Но добавление определения было бы нечистым, если переменная имеет
короткое имя, поскольку пакеты Lisp не должны определять короткие имена переменных.
Правильнее всего переименовать эту переменную, чтобы она начиналась с префикса имени,
используемого для других функций и переменных в вашем пакете.

@item
Последнее средство, позволяющее избежать предупреждения, если требуется сделать
что-то, что обычно является ошибкой, знать, что это не ошибка в таком использовании,
- поместить это в @code{with-no-warnings}.  @xref{Compiler Errors}.
@end itemize

@node Documentation Tips
@section Советы по Строкам Документации
@cindex documentation strings, conventions and tips

@findex checkdoc-minor-mode
  Вот несколько советов и соглашений по написанию строк документации.  Можно проверить
многие из этих соглашений, выполнив команду @kbd{M-x checkdoc-minor-mode}.

@itemize @bullet
@item
Каждая команда, функция или переменная, предназначенная для пользователей, должна
иметь строку документации.

@item
Внутренняя переменная или подпрограмма программы на Lisp также может иметь строку
документации.  Строки документации занимают очень мало места в работающем Emacs.

@item
Отформатировать строку документации так, чтобы она поместилась в окне Emacs на экране
с 80 столбцами.  Рекомендуется, чтобы длина большинства строк не превышала 60
символов.  Первая строка не должна быть шире 67 символов, иначе она будет плохо
выглядеть в выводе @code{apropos}.

@vindex emacs-lisp-docstring-fill-column
Можно заполнить текст, если он подходит.  Режим Emacs Lisp заполняет строки
документации до ширины, указанной @code{emacs-lisp-docstring-fill-column}.  Тем не
менее, иногда можно сделать строку документации более читаемой, осторожно изменив
разрывы строк.  Использовать пустые строки между разделами, если строка документации
длинная.

@item
Первая строка документации должна состоять из одного или двух полных предложений,
которые представляют собой резюме.  @kbd{M-x apropos} отображает только первую строку,
и если содержимое этой строки не стоит само по себе, результат выглядит плохим.  В
частности, начинайте первую строку с заглавной буквы и заканчивайте точкой.

Для функции первая строка должна кратко отвечать на вопрос ``Что делает эта функция?''
Для переменной первая строка должна кратко отвечать на вопрос
``Что означает это значение?''

Не ограничивать строку документации одной строкой; использовать столько строк, сколько
нужно, чтобы объяснить детали того, как использовать функцию или переменную.
Пожалуйста, использовать полные предложения и для остального текста.

@item
Когда пользователь пытается использовать отключенную команду, Emacs отображает только
первый абзац своей строки документации - все до первой пустой строки.  При желании
можно выбрать, какую информацию включать перед первой пустой строкой, чтобы сделать
это отображение полезным.

@item
В первой строке следует упомянуть все важные аргументы функции и указать их в том
порядке, в котором они записаны при вызове функции.  Если у функции много аргументов,
то невозможно указать их все в первой строке; в этом случае в первой строке должны
быть указаны первые несколько аргументов, включая наиболее важные аргументы.

@item
Когда в строке документации функции упоминается значение аргумента функции,
использовать имя аргумента заглавными буквами, как если бы это было имя для этого
значения.  Таким образом, строка документации функции @code{eval} ссылается на свой
первый аргумент как на @samp{FORM}, потому что фактическое имя аргумента -
@code{form}:

@example
Оценить FORM и вернуть его значение.
@end example

Также написать метасинтаксические переменные заглавными буквами, например, когда
показываются разложение списка или вектора на подъединицы, некоторые из которых могут
различаться.  @samp{KEY} и @samp{VALUE} в следующем примере иллюстрирует эту практику:

@example
Аргумент TABLE должен быть списком, элементы которого имеют вид
(KEY . VALUE).  Здесь KEY - это ...
@end example

@item
Никогда не менять регистр символа Lisp, когда упоминается он в строке документации.
Если имя символа - @code{foo}, писать ``foo'', а не ``Foo'' (это другой символ).

Может показаться, что это противоречит политике записи значений аргументов функции,
но реального противоречия нет; @emph{значение} аргумента - это не то же самое, что
@emph{символ}, который функция использует для хранения значения.

Если это ставит строчную букву в начало предложения и это раздражает, переписать
предложение так, чтобы символ не был в его начале.

@item
Не начинать и не заканчивать строку документации пробелом.

@item
@strong{Не делать} отступы в последующих строках строки документации, чтобы текст в
исходном коде выровнялся с текстом первой строки.  Это хорошо выглядит в исходном
коде, но выглядит странно, когда пользователи просматривают документацию.  Помнить,
что отступ перед начальной двойной кавычкой не является частью строки!

@anchor{Docstring hyperlinks}
@item
@cindex curly quotes
@cindex curved quotes
Когда строка документации ссылается на символ Lisp, запиать ее так, как она будет
напечатана (что обычно означает в нижнем регистре), заключив ее в изогнутые одинарные
кавычки (@t{‘..’}).  Есть два исключения: написать @code{t} и @code{nil} без
окружающих знаков препинания.  Например:

@example
 CODE can be ‘lambda’, nil, or t.
@end example

@noindent
@xref{Quotation Marks,,, emacs, The GNU Emacs Manual}, о том, как вводить
изогнутые одинарные кавычки.

Строки документации также могут использовать старое соглашение об одинарных кавычках,
в котором символы заключаются в кавычки с серьезным ударением @t{`} и апострофом
@t{'}: @t{`like-this'}, а не @t{‘like-this’}.  Это старое соглашение было разработано
для устаревших дисплеев, в которых серьезный акцент и апостроф были зеркальным
отображением.  Документация, использующая это соглашение, преобразуется в
предпочтительный для пользователя формат при копировании в буфер справки.
@xref{Keys in Documentation}.

@cindex hyperlinks in documentation strings
Режим справки автоматически создает гиперссылку, когда в строке документации
используется имя символа в одинарных кавычках, если символ имеет либо функцию, либо
определение переменной.  Не нужно делать ничего особенного, чтобы воспользоваться этой
функцией.  Однако, если у символа есть и определение функции, и определение
переменной, и требуется сослаться только на одно из них, можно указать, какое из них,
написав одно из слов @samp{variable}, @samp{option}, @samp{function} или
@samp{command} непосредственно перед именем символа.  (Регистр не имеет значения для
распознавания этих индикаторных слов.)  Например, если написать

@example
Эта функция устанавливает variable `buffer-file-name'.
@end example

@noindent
тогда гиперссылка будет относиться только к документации переменных
@code{buffer-file-name}, а не к документации по функциям.

Если у символа есть определение функции и/или определение переменной, но они не имеют
отношения к использованию символа, который документируется, можно написать слова
@samp{symbol} или @samp{program} перед именем символа, чтобы предотвратить создание
любой гиперссылки.  Например,

@example
Если аргумент KIND-OF-RESULT - это symbol `list', эта функция возвращает список всех
объектов, удовлетворяющих критерию.
@end example

@noindent
не делает гиперссылку на не имеющую отношения к делу документацию функции @code{list}.

Обычно для переменной без документации по переменной гиперссылки не создаются.
Можно принудительно создать гиперссылку для таких переменных, поставив перед ними
одно из слов @samp{variable} или @samp{option}.

Гиперссылки для видов отображения создаются только в том случае, если имени вида
предшествует или следует слово @samp{face}.  В этом случае будет показана только
документация вида, даже если символ также определен как переменная или как функция.

Чтобы сделать гиперссылку на документацию Info, написать в одинарных кавычках имя
узла Info (или якоря), которому предшествует @samp{info node}, @samp{Info node},
@samp{info anchor} или @samp{Info anchor}.  Имя Info-файла по умолчанию -
@samp{emacs}.  Например,

@smallexample
Смотреть Info node `Font Lock' и Info node `(elisp)Font Lock Basics'.
@end smallexample

Наконец, чтобы создать гиперссылку на URL-адреса, написать URL-адрес в одинарных
кавычках, которому предшествует @samp{URL}.  Например,

@smallexample
На домашней странице проекта GNU есть дополнительная информация.  (смотреть URL
`https://www.gnu.org/').
@end smallexample

@item
Не записывать последовательности ключей непосредственно в строках документации.
Вместо этого использовать конструкцию @samp{\[@dots{}]} для их обозначения.  Например,
вместо записи @samp{C-f} написать конструкцию @samp{\[forward-char]}.  Когда Emacs
отображает строку документации, заменяется любой ключ, привязанный в настоящее время
к @code{forward-char}.  (Обычно это @samp{C-f}, но это может быть другой символ,
если пользователь переместил привязки ключей.)  @xref{Keys in Documentation}.

@item
В строках документации для основного режима нужно будет ссылаться на привязки ключей
локальной карты этого режима, а не на глобальные.  Поэтому использовать конструкцию
@samp{\<@dots{}>} один раз в строке документации, чтобы указать, какую карту ключей
использовать.  Сделать это перед первым использованием @samp{\[@dots{}]}.  Текст
внутри @samp{\<@dots{}>} должен быть именем переменной, содержащей локальную
карту ключей для основного режима.

Нецелесообразно использовать @samp{\[@dots{}]} очень много раз, потому что отображение
строки документации станет медленным.  Поэтому использовать это для описания наиболее
важных команд в основном режиме, а затем использовать @samp{\@{@dots{}@}} для
отображения остальной ключевой карты режима.

@item
Для единообразия, сформулировать глагол в первом предложении строки документации
функции как императив --- например, использовать ``Return the cons of A and B.@:''
вместо ``Returns the cons of A and B@.''.  Обычно выглядит хорошо, чтобы сделать то
же самое для остальной части первого абзаца.  Последующие абзацы обычно выглядят
лучше, если каждое предложение носит ориентировочный характер и имеет соответствующую
тему.

@item
Строка документации для функции, которая является предикатом да или нет, должна
начинаться с таких слов, как ``Return t if'', чтобы явно указать, что составляет
истину.  Слово ``return'' избегает начало предложения с ``t'' в нижнем регистре,
что может несколько отвлекать.

@item
Если строка в строке документации начинается с открытой круглой скобки, написать
обратную косую черту перед открывающей скобкой, например:

@example
Аргумент FOO может быть числом
\(позицией в буфере) или строкой (именем файла).
@end example

Предотвращает обработку открывающей скобки как начала defun
(@pxref{Defuns,, Defuns, emacs, The GNU Emacs Manual}).

@item
Писать строки документации активным, а не пассивным, и в настоящем времени, а не в
будущем.  Например, использовать ``Return a list containing A and B.@:'' вместо
``A list containing A and B will be returned.''

@item
Избегать ненужного использования слова ``cause'' (или его эквивалентов).  Вместо
``Cause Emacs to display text in boldface'' написать просто
``Display text in boldface''.

@item
Избегать использования ``iff'' (математический термин, означающий ``if and only if''),
поскольку многие люди с ним не знакомы и принимают его за опечатку.  В большинстве
случаев смысл понятен только с помощью ``if''.  В противном случае пробовать найти
альтернативную формулировку, передающую смысл.

@item
Если команда имеет смысл только в определенном режиме или ситуации, обязательно
указать это в строке документации.  Например, документация @code{dired-find-file}:

@example
В Dired посетить файл или каталог, указанные в этой строке.
@end example

@item
Когда определяется переменная, которая представляет параметр, который пользователи
могут захотеть установить, использовать @code{defcustom}.  @xref{Defining Variables}.

@item
Строка документации для переменной, которая является флагом «да» или «нет», должна
начинаться со слов, таких как ``Non-nil means'', чтобы было ясно, что все значения
не-@code{nil} эквивалентны и явно указывают, что означают @code{nil} и не-@code{nil}.
@end itemize

@node Comment Tips
@section Советы по Написанию Комментариев
@cindex comments, Lisp convention for

  Рекомендуется следующие условные обозначения для комментариев:

@table @samp
@item ;
Комментарии, начинающиеся с одной точки с запятой, @samp{;}, должны быть выровнены
по одному столбцу справа от исходного кода.  Такие комментарии обычно объясняют, как
код в этой строке выполняет свою работу.  Например:

@smallexample
@group
(setq base-version-list                 ; Была базовая
      (assoc (substring fn 0 start-vn)  ; версия, для которой
             file-version-assoc-list))  ; это выглядело как
                                        ; подверсия.

@end group
@end smallexample

@item ;;
Комментарии, начинающиеся с двух точек с запятой, @samp{;;}, должны быть выровнены
по тому же уровню отступа, что и код.  Такие комментарии обычно описывают цель
следующих строк или состояние программы в этот момент.  Например:

@smallexample
@group
(prog1 (setq auto-fill-function
             @dots{}
             @dots{}
  ;; Обновление строки режима.
  (force-mode-line-update)))
@end group
@end smallexample

Также обычно используются две точки с запятой для комментариев вне функций.

@smallexample
@group
;; Этот код Lisp запускается в Emacs, когда должен работать как
;; сервер для других процессов.
@end group
@end smallexample

Если у функции нет строки документации, вместо этого она должна иметь комментарий
с двумя точками с запятой прямо перед функцией, объясняющий, что функция делает и как
ее правильно вызывать.  Точно объяснить, что означает каждый аргумент и как функция
интерпретирует его возможные значения.  Однако гораздо лучше преобразовать такие
комментарии в строки документации.

@item ;;;
Комментарии, начинающиеся с трех точек с запятой, @samp{;;;}, должны начинаться с
левого поля.  Использовать их для комментариев, которые следует рассматривать как
заголовок в второстепенном режиме Outline.  По умолчанию комментарии, начинающиеся
как минимум с трех точек с запятой (за которыми следует один пробел и непробельный
символ), считаются заголовками, а комментарии, начинающиеся с двух или менее, - нет.
Исторически, комментарии с тройной точкой с запятой также использовались для
комментирования строк внутри функции, но такое использование не рекомендуется.

Комментируя функции целиком, использовать две точки с запятой.

@item ;;;;
Комментарии, начинающиеся с четырех точек с запятой, @samp{;;;;}, должны быть
выровнены по левому краю и используются для заголовков основных разделов программы.
Например:

@smallexample
;;;; Кольцо уничтожения
@end smallexample
@end table

@noindent
Вообще говоря, команда @kbd{M-;} (@code{comment-dwim}) автоматически запускает
комментарий соответствующего типа; или переносит существующий комментарий в нужное
место, в зависимости от количества точек с запятой.
@xref{Comments,, Manipulating Comments, emacs, The GNU Emacs Manual}.

@node Library Headers
@section Обычные Заголовки для Библиотек Emacs
@cindex header comments
@cindex library header comments

  В Emacs есть соглашения об использовании специальных комментариев в библиотеках
Lisp, чтобы разделить их на разделы и предоставить информацию, например, о том, кто
их написал.  Использование стандартного формата для этих элементов облегчает
инструментам (и людям) извлечение необходимой информации.  В этом разделе объясняются
эти соглашения, начиная с примера:

@smallexample
@group
;;; foo.el --- Поддержка языка программирования Foo

;; Copyright (C) 2010-2019 Ваше имя
@end group

;; Author: Ваше имя <yourname@@example.com>
;; Maintainer: Кто-то еще <someone@@example.com>
;; Created: 14 Jul 2010
@group
;; Keywords: языки
;; Homepage: http://example.com/foo

;; Этот файл не является частью GNU Emacs.

;; Этот файл является бесплатным программным обеспечением@dots{}
@dots{}
;; вместе с этим файлом.  Если нет, смотреть <https://www.gnu.org/licenses/>.
@end group
@end smallexample

  Самая первая строка должна иметь такой формат:

@example
;;; @var{filename} --- @var{description}
@end example

@noindent
Описание должно содержаться в одной строке.  Если файлу требуется спецификация
@samp{-*-}, поместить её после @var{description}.  Если это сделает первую строку
слишком длинной, использовать раздел локальных переменных в конце файла.

  В уведомлении об авторских правах обычно указывается ваше имя (если вы написали
файл).  Если у вас есть работодатель, заявляющий об авторских правах на вашу работу,
вам, возможно, придется указать его вместо этого.  Не говорите, что владельцем
авторских прав является Free Software Foundation (или что файл является частью GNU
Emacs), если ваш файл не был принят в дистрибутив Emacs.  Для получения дополнительной
информации о форме уведомлений об авторских правах и лицензиях, смотреть
@uref{https://www.gnu.org/licenses/gpl-howto.html, the guide on the GNU
website}.

  После уведомления об авторских правах идет несколько строк
@dfn{заголовок комментария}, каждая из которых начинается с
@samp{;; @var{header-name}:}.  Вот таблица стандартных возможностей @var{header-name}:

@table @samp
@item Author
В этой строке указываются имя и адрес электронной почты, по крайней мере, основного
автора библиотеки.  Если авторов несколько, указать их в строках продолжения,
обозначенных @code{;;} и табуляцией или как минимум двумя пробелами.  Рекомендуется
указать контактный адрес электронной почты в форме @samp{<@dots{}>}.  Например:

@smallexample
@group
;; Author: Your Name <yourname@@example.com>
;;      Someone Else <someone@@example.com>
;;      Another Person <another@@example.com>
@end group
@end smallexample

@item Maintainer
Этот заголовок имеет тот же формат, что и заголовок автора.  В нем перечислены лица,
которые в настоящее время обслуживают файл (отвечают на отчеты об ошибках и так
далее).

Если нет строки сопровождающего, предполагается, что лица в поле «Автор» являются
сопровождающими.  Некоторые файлы в Emacs используют @samp{FSF} для сопровождающего.
Это означает, что первоначальный автор больше не несет ответственности за файл и что
он поддерживается как часть Emacs.

@item Created
Необязательная строка дает исходную дату создания файла и предназначена только для
исторического интереса.

@item Version
Если требуется записать номера версий для отдельной программы на Lisp, поместить их в
эту строку.  Файлы Lisp, распространяемые с Emacs, обычно не имеют заголовка
@samp{Version}, поскольку номер версии самого Emacs служит той же цели.  Если
распространяется коллекция из нескольких файлов, рекомендуется не записывать версию
в каждом файле, а только в основном.

@item Keywords
@vindex checkdoc-package-keywords-flag
@findex checkdoc-package-keywords
В этой строке перечислены ключевые слова для команды справки @code{finder-by-keyword}.
Использовать эту команду, чтобы просмотреть список значимых ключевых слов.  Команда
@kbd{M-x checkdoc-package-keywords @key{RET}} найдет и отобразит любые ключевые слова,
которых нет в @code{finder-known-keywords}.  Если установить переменную
@code{checkdoc-package-keywords-flag} не-@code{nil}, команды checkdoc будут включать
проверку ключевого слова в свои проверки.

Это поле показывает, как люди найдут пакет, когда будут искать вещи по теме.  Чтобы
разделить ключевые слова, можно использовать пробелы, запятые или и то, и другое.

Имя этого поля неудачное, поскольку люди часто предполагают, что это место для
написания произвольных ключевых слов, описывающих их пакет, а не только
соответствующих ключевых слов Finder.

@item Homepage
@itemx URL
В этих строках указывается домашняя страница библиотеки.

@item Package-Version
Если @samp{Version} не подходит для использования менеджером пакетов, тогда пакет
может определять @samp{Package-Version}; будет использоваться вместо него.  Это
удобно, если @samp{Version} - это идентификатор RCS или что-то еще, что не может быть
проанализировано @code{version-to-list}.  @xref{Packaging Basics}.

@item Package-Requires
Если существует, называет пакеты, от которых текущий пакет зависит для правильной
работы.  @xref{Packaging Basics}.  Это используется диспетчером пакетов как во время
загрузки (чтобы гарантировать, что полный набор пакетов загружен), так и во время
активации (чтобы гарантировать, что пакет будет активирован только в том случае, если
были выполнены все его зависимости).

Его формат - список списков в одной строке.  @code{car} каждого подсписка - это имя
пакета в виде символа.  @code{cadr} каждого подсписка - это минимально допустимый
номер версии в виде строки, которую может проанализировать @code{version-to-list}.
Запись, в которой отсутствует версия (то есть запись, которая представляет собой
просто символ, или подсписок из одного элемента), эквивалентна записи с версией 0.
Например:

@smallexample
;; Package-Requires: ((gnus "1.0") (bubbles "2.7.2") cl-lib (seq))
@end smallexample

Код пакета автоматически определяет пакет с именем @samp{emacs} с номером версии
текущего запущенного Emacs.  Это можно использовать, чтобы потребовать минимальную
версию Emacs для пакета.
@end table

  Практически каждая библиотека Lisp должна иметь строки комментариев заголовка
@samp{Author} и @samp{Keywords}.  Использовать другие, если они подходят.  Также
можете вставлять строки заголовков с другими именами заголовков - они не имеют
стандартного значения, поэтому не могут причинить никакого вреда.

  Используются дополнительные стилизованные комментарии для разделения содержимого
файла библиотеки.  Они должны быть отделены от всего остального пустыми строками.
Вот их таблица:

@cindex commentary, in a Lisp library
@table @samp
@item ;;; Commentary:
Здесь начинаются вводные комментарии, объясняющие, как работает библиотека.
Должно идти сразу после разрешений на копирование и завершаться строкой комментария
@samp{Change Log}, @samp{History} или @samp{Code}.  Этот текст используется пакетом
Finder, поэтому должен иметь смысл в этом контексте.

@item ;;; Change Log:
Это начинает необязательный журнал изменений файла с течением времени.  Не помещать
слишком много информации в этот раздел - лучше вести подробные журналы в системе
контроля версий (как это делает Emacs) или в отдельном файле @file{ChangeLog}.
@samp{History} - альтернатива @samp{Change Log}.

@item ;;; Code:
Это начинает собственно код программы.

@item ;;; @var{filename} ends here
Это @dfn{нижний колонтитул}; появляется в самом конце файла.  Его цель - позволить
людям обнаруживать усеченные версии файла из-за отсутствия строки нижнего колонтитула.
@end table
