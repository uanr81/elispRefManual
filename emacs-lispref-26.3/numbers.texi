@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2019 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Numbers
@chapter Числа
@cindex integers
@cindex numbers

  GNU Emacs поддерживает два числовых типов данных: @dfn{Целое число} и
  @dfn{Число с плавающей точкой}.  Целые числа --- это такие как @minus{}3,
  0, 7, 13 и 511.  Числа с плавающей точкой являются числами с дробными
  частями, такими как @minus{}4.5, 0.0, и 2,71828.  Они также могут быть
  выражены в экспоненциальной форме: число @samp{150.0} можно выразить как
  @samp{1.5e2}, где @samp{e2} означает десять до второй степени, и
  умножается на 1,5.  Целочисленные вычисления являются точными, хотя они
  могут переполняться.  Вычисления с плавающей запятой часто связаны с
  ошибками округления, так как числа имеют фиксированную точность.

@menu
* Integer Basics::            Представление и диапазон целых чисел.
* Float Basics::              Представление и диапазон с плавающей точкой.
* Predicates on Numbers::     Проверка чисел.
* Comparison of Numbers::     Предикаты равенства и неравенства.
* Numeric Conversions::       Преобразование числа с плавающей точкой в
                              ​​целое и наоборот.
* Arithmetic Operations::     Сложение, вычитание, умножение и деление.
* Rounding Operations::       Явное округления чисел с плавающей точкой.
* Bitwise Operations::        Логическиое и, или, не, смещение.
* Math Functions::            Тригонометрические, экспоненциальные и
                              логарифмические функции.
* Random Numbers::            Получение случайных чисел, предсказуемых
                              или нет.
@end menu

@node Integer Basics
@section Целое Число Основы

  Диапазон значений для целого зависит от машины.  Минимальный диапазон
  @minus{}536,870,912 до 536,870,911 (30 бит; i.e.,
@ifnottex
@minus{}2**29
@end ifnottex
@tex
@math{-2^{29}}
@end tex
to
@ifnottex
2**29 @minus{} 1),
@end ifnottex
@tex
@math{2^{29}-1}),
@end tex
но многие машины обеспечивают более широкий диапазон. Многие примеры в этой
главе предполагают минимальную ширину целого числа, равное 30 бит.
@cindex overflow

  Lisp читатель считывает целое число в виде последовательности цифр с
  необязательным начальным знаком и дополнительной конечной точкой.
  Целое число, которое находится вне указанного диапазона Emacs,
  рассматривается как число с плавающей точкой.

@example
 1               ; @r{Целочисленное 1.}
 1.              ; @r{Целочисленное 1.}
+1               ; @r{Также целочисленное 1.}
-1               ; @r{Целочисленное @minus{}1.}
 9000000000000000000
                 ; @r{Число с плавающей точкой 9e18.}
 0               ; @r{Целочисленное 0.}
-0               ; @r{Целочисленное 0.}
@end example

@cindex integers in specific radix
@cindex radix for reading an integer
@cindex base for reading an integer
@cindex hex numbers
@cindex octal numbers
@cindex reading numbers in hex, octal, and binary
  Синтаксис для целых чисел, отличных от используемого основания 10,
  использует @samp{#} с последующей буквой, которая указывает систему
  счисления: @samp{b} для двоичной, @samp{o} для восьмеричной, @samp{x}
  для шестнадцатеричной или @samp{@var{система счисления}r} для указания
  основания @var{системы счисления}.  Для буквы, определяющей основание
  системы счисления, регистр не имеет значения.  Таким образом,
  @samp{#b@var{целочисленное}} читает @var{целочисленное} в двоичной
  системе, и @samp{#@var{система счисления}r@var{целочисленное}} читает
  @var{целочисленное} в натальной @var{системе счисления}.  Допустимые
  значения @var{систем счисления} от 2 до 36. Например:

@example
#b101100 @result{} 44
#o54 @result{} 44
#x2c @result{} 44
#24r1k @result{} 44
@end example

  Чтобы понять, как различные функции работают с целыми числами, особенно
  побитовые операторы (@pxref{Bitwise Operations}), часто бывает полезно
  просмотреть числа в двоичном виде.

  В 30-разрядным двоичном формате, десятичное число 5 выглядит следующим
  образом:

@example
0000...000101 (всего 30 бит)
@end example

@noindent
(@samp{...} означает достаточно битов, чтобы заполнить 30-разрядное слово;
в этом случае, @samp{...} стоит из двадцати бит со значением 0.  В более
поздних примерах также используется @samp{...} обозначение, чтобы двоичные
числа было легче читать.)

  Целочисленное @minus{}1 выглядит следующим образом:

@example
1111...111111 (всего 30 бит)
@end example

@noindent
@cindex two's complement
@minus{}1 представляется как 30 единиц 1.  (Это обозначение называется
@dfn{двойное дополнение}.)

  Вычитание 4 из @minus{}1 возвращает отрицательное целое число @minus{}5.
  В двоичной системе десятичной целое число 4 равно 100. Следовательно,
  @minus{}5 выглядит следующим образом:

@example
1111...111011 (всего 30 бит)
@end example

  В этом реализации наибольшее 30-разрядное двоичное целое число 536,870,911
  в десятичной системе. В двоичном формате, это выглядит следующим образом:

@example
0111...111111 (всего 30 бит)
@end example

  Поскольку арифметические функции не проверяют, выходят ли целые числа за
  пределы своего диапазона, при добавлении 1 к 536,870,911, значение
  будет отрицательным целым числом @minus{}536,870,912:

@example
(+ 1 536870911)
     @result{} -536870912
     @result{} 1000...000000 (всего 30 бит)
@end example

  Многие из функций, описанных в этой главе, принимают маркеры в качестве
  аргументов вместо чисел.  (@xref{Markers}.)  Поскольку фактическими
  аргументами таких функций могут числа или маркеры, мы часто даем этим
  аргументам имя @var{число-или-макркер}.  Когда значение аргумента является
  маркером, используется его значение позиции, а его буфер игнорируется.

@cindex largest Lisp integer
@cindex maximum Lisp integer
@defvar most-positive-fixnum
Значение этой переменной наибольшее целое число, которое может обработать
Emacs Lisp.  Типичные значения
@ifnottex
2**29 @minus{} 1
@end ifnottex
@tex
@math{2^{29}-1}
@end tex
для 32-бит и
@ifnottex
2**61 @minus{} 1
@end ifnottex
@tex
@math{2^{61}-1}
@end tex
для 64-бит платформ.
@end defvar

@cindex smallest Lisp integer
@cindex minimum Lisp integer
@defvar most-negative-fixnum
Значение этой переменной является наименьшим целым числом, которое может
обрабатывать Emacs Lisp.  Это отрицательное число.  Типичные значения
@ifnottex
@minus{}2**29
@end ifnottex
@tex
@math{-2^{29}}
@end tex
для 32-бит и
@ifnottex
@minus{}2**61
@end ifnottex
@tex
@math{-2^{61}}
@end tex
для 64-бит платформ.
@end defvar

  В Emacs Lisp, текстовые символы представлены целыми числами. Любое целое
  число между нулем и значением @code{(max-char)} включительно, считаются
  допустимыми в качестве символа.  @xref{Character Codes}.

@node Float Basics
@section Плавающая Точка Основы

@cindex @acronym{IEEE} floating point
  Числа с плавающей точкой используются для представления чисел, которые не
  являются целочисленными.  Диапазон чисел с плавающей точкой является таким
  же, как диапазон типа данных С @code{double} на компьютере, который вы
  используете.  На всех компьютерах, поддерживаемых в настоящее время Emacs,
  это числа с плавающей точкой двойной точности @acronym{IEEE}.

  Синтаксис чтения для чисел с плавающей точкой требует либо десятичной
  точки, либо показателя степени, или обоих.  Необязательные знаки
  (@samp{+} или @samp{-}) предшествуют числу и его показателю.  Например,
  @samp{1500.0}, @samp{+15e2}, @samp{15.0e+2}, @samp{+1500000e-3}, и
  @samp{.15e4} представляют пять способов записи числа с плавающей точкой,
  значение которого 1500.  Все они эквивалентны.  Как Common Lisp,
  Emacs Lisp требует, по крайней мере, наличие одной цифры после десятичной
  точки в числе с плавающей точкой; @samp{1500.} представляет собой целое
  число, а не число с плавающей точкой.

  Emacs Lisp считает @code{-0.0}, как численно равным обычному нулю
  относительно операций @code{equal} и @code{=}. Это соответствует стандарту
  с плавающей точкой @acronym{IEEE}, который говорит, что @code{-0.0} и
  @code{0.0} численно равны, хотя другие операции могут различать их.

@cindex positive infinity
@cindex negative infinity
@cindex infinity
@cindex NaN
  @acronym{IEEE} стандарт с плавающей точкой поддерживает положительную
  и отрицательную бесконечности в качестве значений с плавающей точкой.  Он
  также предусматривает класс значений, называемых NaN или ``не число'';
  Числовые функции возвращают такие значения в тех случаях, когда нет
  правильного ответа.  Например, @code{(/ 0.0 0.0)} возвращает NaN@.  Хотя
  значения NaN имеют знак, для практических целей, нет никакой существенной
  разницы между разными значениями NaN в Emacs Lisp.

Вот синтаксисы чтения для этих специальных значений с плавающей точкой:

@table @asis
@item infinity
@samp{1.0e+INF} and @samp{-1.0e+INF}
@item not-a-number
@samp{0.0e+NaN} and @samp{-0.0e+NaN}
@end table

  Следующие функции специализированы для обработки чисел с плавающей точкой:

@defun isnan x
Этот предикат возвращает @code{t}, если его аргумент с плавающей точкой
является NaN, @code{nil} иначе.
@end defun

@defun frexp x
Эта функция возвращает cons-ячейку @code{(@var{s} . @var{e})}, где @var{s}
и @var{e} являются соответственно мантисса и экспонента числа с плавающей
точкой @var{x}.

Если @var{x} конечное, то @var{s} представляет собой число с плавающей
точкой в ​​диапазоне от 0,5 (включительно) и 1,0 (исключительного), @var{e}
представляет собой целое число, и
@ifnottex
@var{x} = @var{s} * 2**@var{e}.
@end ifnottex
@tex
@math{x = s 2^e}.
@end tex
Если @var{x} равен нулю или бесконечности, то @var{s} совпадает с @var{x}.
Если @var{x} является NaN, то @var{s} также NaN@.
Если @var{x} равен нулю, то @var{e} является 0.
@end defun

@defun ldexp s e
Учитывается числовая мантисса @var{s} и целочисленный показатель @var{e},
эта функция возвращает число с плавающей точкой
@ifnottex
@var{s} * 2**@var{e}.
@end ifnottex
@tex
@math{s 2^e}.
@end tex
@end defun

@defun copysign x1 x2
Эта функция копирует знак @var{x2} в значению @var{x1}, и возвращает
результат. @var{x1} и @var{x2} должны быть плавающей точкой.
@end defun

@defun logb x
Эта функция возвращает двоичную экспоненту @var{x}. Более точно, значение
представляет собой логарифм по основанию 2 от @math{|x|}, округленый до
целого числа.

@example
(logb 10)
     @result{} 3
(logb 10.0e20)
     @result{} 69
@end example
@end defun

@node Predicates on Numbers
@section Тип Предикат для Чисел
@cindex predicates for numbers

  Функции в этом разделе проверяют числа, или числа определённого типа.
  Функции @code{integerp} и @code{floatp} могут принимать любой тип Lisp
  объекта в качестве аргумента (они не были бы очень ползны), но
  @code{zerop} предикат требует число в качестве аргумента.  Смотри
  @code{integer-or-marker-p} и @code{number-or-marker-p}, в
  @ref{Predicates on Markers}.

@defun floatp object
Этот предикат проверяет, является ли ее аргумент с плавающей точкой и
возвращает @code{t} если да, и @code{nil} в противном случае.
@end defun

@defun integerp object
Этот предикат проверяет является ли аргумент целым числом, и возвращает
@code{t} если да, и @code{nil} в противном случае.
@end defun

@defun numberp object
Этот предикат проверяет является ли его аргумент числом (либо целым или
с плавающей точкой) и возвращает @code{t} если да, и @code{nil} в
противном случае.
@end defun

@defun natnump object
@cindex natural numbers
Этот предикат (чье название происходит от фразы ``натуральное число'')
проверяет, является ли аргумент неотрицательным целым числом, и возвращает
@code{t} если да, и @code{nil} в противном случае.  0 считается
неотрицательным.

@findex wholenump
@code{wholenump} это синоним @code{natnump}.
@end defun

@defun zerop number
Этот предикат проверяет, равен ли ее аргумент нулю, и возвращает @code{t}
если да, и @code{nil} в противном случае.  Аргумент должен быть числом.

@code{(zerop x)} синоним @code{(= x 0)}.
@end defun

@node Comparison of Numbers
@section Сравнение Чисел
@cindex number comparison
@cindex comparing numbers

  Для проверки чисел на численное равенство, обычно следует использовать
  @code{=}, не @code{eq}.  Может быть много различных объектов с плавающей
  точкой с одинаковым числовым значением.  Используете @code{eq},
  чтобы сравнить являются ли два значения одим и тем же @emph{объектом}.
  В противоположность этому, @code{=} сравнивает только числовые значения
  объектов.

  В Emacs Lisp, каждое целое число является уникальным объектом Lisp.
  Поэтому @code{eq} эквивалентно @code{=} для целых чисел.  Иногда удобно
  использовать @code{eq} для сравнения неизвестного значения с целым числом,
  потому что @code{eq} не сообщает об ошибке, если неизвестное значение не
  является числом --- приинимаются аргументы любого типа.  В
  противоположность этому, @code{=} сигнализирует об ошибке, если аргументы
  не являются числами или маркерами.  Тем не менее, лучшая практика
  программирования по возможности использовать @code{=} для сравнения целых
  чисел.

  Иногда бывает полезно сравнить числа с помощью @code{equal}, при этом два
  числа рассматриваются как равные, если они имеют один и тот же тип данных
  (оба целые числа, или оба с плавающей точкой) и одно и то же значение. В
  отличие от этого, @code{=} может рассматривать целое число и число с
  плавающей точкой, как равные.  @xref{Equality Predicates}.

  Существует еще одна загвоздка: потому что арифметика с плавающей точкой не
  является точной, часто бывает плохая идея проверять равенство значений с
  плавающей точкой.  Обычно лучше проверить примерное равенства.  Вот
  функция, которая делает это:

@example
(defvar fuzz-factor 1.0e-6)
(defun approx-equal (x y)
  (or (= x y)
      (< (/ (abs (- x y))
            (max (abs x) (abs y)))
         fuzz-factor)))
@end example

@cindex CL note---integers vrs @code{eq}
@quotation
@b{Common Lisp примечание:} Сравнение чисел в Common Lisp всегда требует
@code{=}, потому что Common Lisp реализует многословные целые числа, и два
различных целочисленных объекта могут иметь одно и то же числовое значение.
Emacs Lisp может иметь только один целочисленный объект для любого заданного
значения, поскольку он имеет ограниченный диапазон целых чисел.
@end quotation

@defun = number-or-marker &rest number-or-markers
Эта функция проверяет, является ли все ее аргументы численно равными, и
возвращает @code{t} если да, и @code{nil} в противном случае.
@end defun

@defun eql value1 value2
Эта функция действует как @code{eq}, за  исключением случаев, когда оба
аргумента это числа.  Она сравнивает числа по типу и числовому значению,
так что @code{(eql 1.0 1)} возвращает @code{nil}, но @code{(eql 1.0 1.0)}
и @code{(eql 1 1)} как возвращает @code{t}.
@end defun

@defun /= number-or-marker1 number-or-marker2
Эта функция проверяет, является ли его аргументы численно равными, и
возвращает @code{t}, если не являются, и @code{nil} если значения равны.
@end defun

@defun <  number-or-marker &rest number-or-markers
Эта функция проверяет, является ли каждый аргумент строго меньше, чем
следующий аргумент.  Она возвращает @code{t} если да, и @code{nil} в
противном случае.
@end defun

@defun <= number-or-marker &rest number-or-markers
Эта функция проверяет, является ли каждый аргумент меньше или равным
следующему аргументу.  Она возвращает @code{t} если да, и @code{nil} в
противном случае.
@end defun

@defun > number-or-marker &rest number-or-markers
Эта функция проверяет, является ли каждый аргумент строго больше, чем
следующи.  Она возвращает @code{t} если да, и @code{nil} в противном случае.
@end defun

@defun >= number-or-marker &rest number-or-markers
Эта функция проверяет, является ли большим или равным аргумент, чем каждый
следующий аргумент.  Она возвращает @code{t} если да, и @code{nil} в
противном случае.
@end defun

@defun max number-or-marker &rest numbers-or-markers
Эта функция возвращает наибольший из ее аргументов.

@example
(max 20)
     @result{} 20
(max 1 2.5)
     @result{} 2.5
(max 1 3 2.5)
     @result{} 3
@end example
@end defun

@defun min number-or-marker &rest numbers-or-markers
Эта функция возвращает наименьший из ее аргументов.

@example
(min -4 1)
     @result{} -4
@end example
@end defun

@defun abs number
Эта функция возвращает абсолютное значение @var{number}.
@end defun

@node Numeric Conversions
@section Numeric Conversions
@cindex rounding in conversions
@cindex number conversions
@cindex converting numbers

To convert an integer to floating point, use the function @code{float}.

@defun float number
This returns @var{number} converted to floating point.
If @var{number} is already floating point, @code{float} returns
it unchanged.
@end defun

  There are four functions to convert floating-point numbers to
integers; they differ in how they round.  All accept an argument
@var{number} and an optional argument @var{divisor}.  Both arguments
may be integers or floating-point numbers.  @var{divisor} may also be
@code{nil}.  If @var{divisor} is @code{nil} or omitted, these
functions convert @var{number} to an integer, or return it unchanged
if it already is an integer.  If @var{divisor} is non-@code{nil}, they
divide @var{number} by @var{divisor} and convert the result to an
integer.  If @var{divisor} is zero (whether integer or
floating point), Emacs signals an @code{arith-error} error.

@defun truncate number &optional divisor
This returns @var{number}, converted to an integer by rounding towards
zero.

@example
(truncate 1.2)
     @result{} 1
(truncate 1.7)
     @result{} 1
(truncate -1.2)
     @result{} -1
(truncate -1.7)
     @result{} -1
@end example
@end defun

@defun floor number &optional divisor
This returns @var{number}, converted to an integer by rounding downward
(towards negative infinity).

If @var{divisor} is specified, this uses the kind of division
operation that corresponds to @code{mod}, rounding downward.

@example
(floor 1.2)
     @result{} 1
(floor 1.7)
     @result{} 1
(floor -1.2)
     @result{} -2
(floor -1.7)
     @result{} -2
(floor 5.99 3)
     @result{} 1
@end example
@end defun

@defun ceiling number &optional divisor
This returns @var{number}, converted to an integer by rounding upward
(towards positive infinity).

@example
(ceiling 1.2)
     @result{} 2
(ceiling 1.7)
     @result{} 2
(ceiling -1.2)
     @result{} -1
(ceiling -1.7)
     @result{} -1
@end example
@end defun

@defun round number &optional divisor
This returns @var{number}, converted to an integer by rounding towards the
nearest integer.  Rounding a value equidistant between two integers
returns the even integer.

@example
(round 1.2)
     @result{} 1
(round 1.7)
     @result{} 2
(round -1.2)
     @result{} -1
(round -1.7)
     @result{} -2
@end example
@end defun

@node Arithmetic Operations
@section Arithmetic Operations
@cindex arithmetic operations

  Emacs Lisp provides the traditional four arithmetic operations
(addition, subtraction, multiplication, and division), as well as
remainder and modulus functions, and functions to add or subtract 1.
Except for @code{%}, each of these functions accepts both integer and
floating-point arguments, and returns a floating-point number if any
argument is floating point.

  Emacs Lisp arithmetic functions do not check for integer overflow.
Thus @code{(1+ 536870911)} may evaluate to
@minus{}536870912, depending on your hardware.

@defun 1+ number-or-marker
This function returns @var{number-or-marker} plus 1.
For example,

@example
(setq foo 4)
     @result{} 4
(1+ foo)
     @result{} 5
@end example

This function is not analogous to the C operator @code{++}---it does not
increment a variable.  It just computes a sum.  Thus, if we continue,

@example
foo
     @result{} 4
@end example

If you want to increment the variable, you must use @code{setq},
like this:

@example
(setq foo (1+ foo))
     @result{} 5
@end example
@end defun

@defun 1- number-or-marker
This function returns @var{number-or-marker} minus 1.
@end defun

@defun + &rest numbers-or-markers
This function adds its arguments together.  When given no arguments,
@code{+} returns 0.

@example
(+)
     @result{} 0
(+ 1)
     @result{} 1
(+ 1 2 3 4)
     @result{} 10
@end example
@end defun

@defun - &optional number-or-marker &rest more-numbers-or-markers
The @code{-} function serves two purposes: negation and subtraction.
When @code{-} has a single argument, the value is the negative of the
argument.  When there are multiple arguments, @code{-} subtracts each of
the @var{more-numbers-or-markers} from @var{number-or-marker},
cumulatively.  If there are no arguments, the result is 0.

@example
(- 10 1 2 3 4)
     @result{} 0
(- 10)
     @result{} -10
(-)
     @result{} 0
@end example
@end defun

@defun * &rest numbers-or-markers
This function multiplies its arguments together, and returns the
product.  When given no arguments, @code{*} returns 1.

@example
(*)
     @result{} 1
(* 1)
     @result{} 1
(* 1 2 3 4)
     @result{} 24
@end example
@end defun

@defun / number &rest divisors
With one or more @var{divisors}, this function divides @var{number}
by each divisor in @var{divisors} in turn, and returns the quotient.
With no @var{divisors}, this function returns 1/@var{number}, i.e.,
the multiplicative inverse of @var{number}.  Each argument may be a
number or a marker.

If all the arguments are integers, the result is an integer, obtained
by rounding the quotient towards zero after each division.

@example
@group
(/ 6 2)
     @result{} 3
@end group
@group
(/ 5 2)
     @result{} 2
@end group
@group
(/ 5.0 2)
     @result{} 2.5
@end group
@group
(/ 5 2.0)
     @result{} 2.5
@end group
@group
(/ 5.0 2.0)
     @result{} 2.5
@end group
@group
(/ 4.0)
     @result{} 0.25
@end group
@group
(/ 4)
     @result{} 0
@end group
@group
(/ 25 3 2)
     @result{} 4
@end group
@group
(/ -17 6)
     @result{} -2
@end group
@end example

@cindex @code{arith-error} in division
If you divide an integer by the integer 0, Emacs signals an
@code{arith-error} error (@pxref{Errors}).  Floating-point division of
a nonzero number by zero yields either positive or negative infinity
(@pxref{Float Basics}).
@end defun

@defun % dividend divisor
@cindex remainder
This function returns the integer remainder after division of @var{dividend}
by @var{divisor}.  The arguments must be integers or markers.

For any two integers @var{dividend} and @var{divisor},

@example
@group
(+ (% @var{dividend} @var{divisor})
   (* (/ @var{dividend} @var{divisor}) @var{divisor}))
@end group
@end example

@noindent
always equals @var{dividend} if @var{divisor} is nonzero.

@example
(% 9 4)
     @result{} 1
(% -9 4)
     @result{} -1
(% 9 -4)
     @result{} 1
(% -9 -4)
     @result{} -1
@end example
@end defun

@defun mod dividend divisor
@cindex modulus
This function returns the value of @var{dividend} modulo @var{divisor};
in other words, the remainder after division of @var{dividend}
by @var{divisor}, but with the same sign as @var{divisor}.
The arguments must be numbers or markers.

Unlike @code{%}, @code{mod} permits floating-point arguments; it
rounds the quotient downward (towards minus infinity) to an integer,
and uses that quotient to compute the remainder.

If @var{divisor} is zero, @code{mod} signals an @code{arith-error}
error if both arguments are integers, and returns a NaN otherwise.

@example
@group
(mod 9 4)
     @result{} 1
@end group
@group
(mod -9 4)
     @result{} 3
@end group
@group
(mod 9 -4)
     @result{} -3
@end group
@group
(mod -9 -4)
     @result{} -1
@end group
@group
(mod 5.5 2.5)
     @result{} .5
@end group
@end example

For any two numbers @var{dividend} and @var{divisor},

@example
@group
(+ (mod @var{dividend} @var{divisor})
   (* (floor @var{dividend} @var{divisor}) @var{divisor}))
@end group
@end example

@noindent
always equals @var{dividend}, subject to rounding error if either
argument is floating point and to an @code{arith-error} if @var{dividend} is an
integer and @var{divisor} is 0.  For @code{floor}, see @ref{Numeric
Conversions}.
@end defun

@node Rounding Operations
@section Rounding Operations
@cindex rounding without conversion

The functions @code{ffloor}, @code{fceiling}, @code{fround}, and
@code{ftruncate} take a floating-point argument and return a floating-point
result whose value is a nearby integer.  @code{ffloor} returns the
nearest integer below; @code{fceiling}, the nearest integer above;
@code{ftruncate}, the nearest integer in the direction towards zero;
@code{fround}, the nearest integer.

@defun ffloor float
This function rounds @var{float} to the next lower integral value, and
returns that value as a floating-point number.
@end defun

@defun fceiling float
This function rounds @var{float} to the next higher integral value, and
returns that value as a floating-point number.
@end defun

@defun ftruncate float
This function rounds @var{float} towards zero to an integral value, and
returns that value as a floating-point number.
@end defun

@defun fround float
This function rounds @var{float} to the nearest integral value,
and returns that value as a floating-point number.
Rounding a value equidistant between two integers returns the even integer.
@end defun

@node Bitwise Operations
@section Bitwise Operations on Integers
@cindex bitwise arithmetic
@cindex logical arithmetic

  In a computer, an integer is represented as a binary number, a
sequence of @dfn{bits} (digits which are either zero or one).  A bitwise
operation acts on the individual bits of such a sequence.  For example,
@dfn{shifting} moves the whole sequence left or right one or more places,
reproducing the same pattern moved over.

  The bitwise operations in Emacs Lisp apply only to integers.

@defun lsh integer1 count
@cindex logical shift
@code{lsh}, which is an abbreviation for @dfn{logical shift}, shifts the
bits in @var{integer1} to the left @var{count} places, or to the right
if @var{count} is negative, bringing zeros into the vacated bits.  If
@var{count} is negative, @code{lsh} shifts zeros into the leftmost
(most-significant) bit, producing a positive result even if
@var{integer1} is negative.  Contrast this with @code{ash}, below.

Here are two examples of @code{lsh}, shifting a pattern of bits one
place to the left.  We show only the low-order eight bits of the binary
pattern; the rest are all zero.

@example
@group
(lsh 5 1)
     @result{} 10
;; @r{Decimal 5 becomes decimal 10.}
00000101 @result{} 00001010

(lsh 7 1)
     @result{} 14
;; @r{Decimal 7 becomes decimal 14.}
00000111 @result{} 00001110
@end group
@end example

@noindent
As the examples illustrate, shifting the pattern of bits one place to
the left produces a number that is twice the value of the previous
number.

Shifting a pattern of bits two places to the left produces results
like this (with 8-bit binary numbers):

@example
@group
(lsh 3 2)
     @result{} 12
;; @r{Decimal 3 becomes decimal 12.}
00000011 @result{} 00001100
@end group
@end example

On the other hand, shifting one place to the right looks like this:

@example
@group
(lsh 6 -1)
     @result{} 3
;; @r{Decimal 6 becomes decimal 3.}
00000110 @result{} 00000011
@end group

@group
(lsh 5 -1)
     @result{} 2
;; @r{Decimal 5 becomes decimal 2.}
00000101 @result{} 00000010
@end group
@end example

@noindent
As the example illustrates, shifting one place to the right divides the
value of a positive integer by two, rounding downward.

The function @code{lsh}, like all Emacs Lisp arithmetic functions, does
not check for overflow, so shifting left can discard significant bits
and change the sign of the number.  For example, left shifting
536,870,911 produces @minus{}2 in the 30-bit implementation:

@example
(lsh 536870911 1)          ; @r{left shift}
     @result{} -2
@end example

In binary, the argument looks like this:

@example
@group
;; @r{Decimal 536,870,911}
0111...111111 (30 bits total)
@end group
@end example

@noindent
which becomes the following when left shifted:

@example
@group
;; @r{Decimal @minus{}2}
1111...111110 (30 bits total)
@end group
@end example
@end defun

@defun ash integer1 count
@cindex arithmetic shift
@code{ash} (@dfn{arithmetic shift}) shifts the bits in @var{integer1}
to the left @var{count} places, or to the right if @var{count}
is negative.

@code{ash} gives the same results as @code{lsh} except when
@var{integer1} and @var{count} are both negative.  In that case,
@code{ash} puts ones in the empty bit positions on the left, while
@code{lsh} puts zeros in those bit positions.

Thus, with @code{ash}, shifting the pattern of bits one place to the right
looks like this:

@example
@group
(ash -6 -1) @result{} -3
;; @r{Decimal @minus{}6 becomes decimal @minus{}3.}
1111...111010 (30 bits total)
     @result{}
1111...111101 (30 bits total)
@end group
@end example

In contrast, shifting the pattern of bits one place to the right with
@code{lsh} looks like this:

@example
@group
(lsh -6 -1) @result{} 536870909
;; @r{Decimal @minus{}6 becomes decimal 536,870,909.}
1111...111010 (30 bits total)
     @result{}
0111...111101 (30 bits total)
@end group
@end example

Here are other examples:

@c !!! Check if lined up in smallbook format!  XDVI shows problem
@c     with smallbook but not with regular book! --rjc 16mar92
@smallexample
@group
                   ;  @r{       30-bit binary values}

(lsh 5 2)          ;   5  =  @r{0000...000101}
     @result{} 20         ;      =  @r{0000...010100}
@end group
@group
(ash 5 2)
     @result{} 20
(lsh -5 2)         ;  -5  =  @r{1111...111011}
     @result{} -20        ;      =  @r{1111...101100}
(ash -5 2)
     @result{} -20
@end group
@group
(lsh 5 -2)         ;   5  =  @r{0000...000101}
     @result{} 1          ;      =  @r{0000...000001}
@end group
@group
(ash 5 -2)
     @result{} 1
@end group
@group
(lsh -5 -2)        ;  -5  =  @r{1111...111011}
     @result{} 268435454
                   ;      =  @r{0011...111110}
@end group
@group
(ash -5 -2)        ;  -5  =  @r{1111...111011}
     @result{} -2         ;      =  @r{1111...111110}
@end group
@end smallexample
@end defun

@defun logand &rest ints-or-markers
This function returns the bitwise AND of the arguments: the @var{n}th
bit is 1 in the result if, and only if, the @var{n}th bit is 1 in all
the arguments.

For example, using 4-bit binary numbers, the bitwise AND of 13 and
12 is 12: 1101 combined with 1100 produces 1100.
In both the binary numbers, the leftmost two bits are both 1
so the leftmost two bits of the returned value are both 1.
However, for the rightmost two bits, each is 0 in at least one of
the arguments, so the rightmost two bits of the returned value are both 0.

@noindent
Therefore,

@example
@group
(logand 13 12)
     @result{} 12
@end group
@end example

If @code{logand} is not passed any argument, it returns a value of
@minus{}1.  This number is an identity element for @code{logand}
because its binary representation consists entirely of ones.  If
@code{logand} is passed just one argument, it returns that argument.

@smallexample
@group
                   ; @r{       30-bit binary values}

(logand 14 13)     ; 14  =  @r{0000...001110}
                   ; 13  =  @r{0000...001101}
     @result{} 12         ; 12  =  @r{0000...001100}
@end group

@group
(logand 14 13 4)   ; 14  =  @r{0000...001110}
                   ; 13  =  @r{0000...001101}
                   ;  4  =  @r{0000...000100}
     @result{} 4          ;  4  =  @r{0000...000100}
@end group

@group
(logand)
     @result{} -1         ; -1  =  @r{1111...111111}
@end group
@end smallexample
@end defun

@defun logior &rest ints-or-markers
This function returns the bitwise inclusive OR of its arguments: the @var{n}th
bit is 1 in the result if, and only if, the @var{n}th bit is 1 in at
least one of the arguments.  If there are no arguments, the result is 0,
which is an identity element for this operation.  If @code{logior} is
passed just one argument, it returns that argument.

@smallexample
@group
                   ; @r{       30-bit binary values}

(logior 12 5)      ; 12  =  @r{0000...001100}
                   ;  5  =  @r{0000...000101}
     @result{} 13         ; 13  =  @r{0000...001101}
@end group

@group
(logior 12 5 7)    ; 12  =  @r{0000...001100}
                   ;  5  =  @r{0000...000101}
                   ;  7  =  @r{0000...000111}
     @result{} 15         ; 15  =  @r{0000...001111}
@end group
@end smallexample
@end defun

@defun logxor &rest ints-or-markers
This function returns the bitwise exclusive OR of its arguments: the
@var{n}th bit is 1 in the result if, and only if, the @var{n}th bit is
1 in an odd number of the arguments.  If there are no arguments, the
result is 0, which is an identity element for this operation.  If
@code{logxor} is passed just one argument, it returns that argument.

@smallexample
@group
                   ; @r{       30-bit binary values}

(logxor 12 5)      ; 12  =  @r{0000...001100}
                   ;  5  =  @r{0000...000101}
     @result{} 9          ;  9  =  @r{0000...001001}
@end group

@group
(logxor 12 5 7)    ; 12  =  @r{0000...001100}
                   ;  5  =  @r{0000...000101}
                   ;  7  =  @r{0000...000111}
     @result{} 14         ; 14  =  @r{0000...001110}
@end group
@end smallexample
@end defun

@defun lognot integer
This function returns the bitwise complement of its argument: the @var{n}th
bit is one in the result if, and only if, the @var{n}th bit is zero in
@var{integer}, and vice-versa.

@example
(lognot 5)
     @result{} -6
;;  5  =  @r{0000...000101} (30 bits total)
;; @r{becomes}
;; -6  =  @r{1111...111010} (30 bits total)
@end example
@end defun

@node Math Functions
@section Standard Mathematical Functions
@cindex transcendental functions
@cindex mathematical functions
@cindex floating-point functions

  These mathematical functions allow integers as well as floating-point
numbers as arguments.

@defun sin arg
@defunx cos arg
@defunx tan arg
These are the basic trigonometric functions, with argument @var{arg}
measured in radians.
@end defun

@defun asin arg
The value of @code{(asin @var{arg})} is a number between
@ifnottex
@minus{}pi/2
@end ifnottex
@tex
@math{-\pi/2}
@end tex
and
@ifnottex
pi/2
@end ifnottex
@tex
@math{\pi/2}
@end tex
(inclusive) whose sine is @var{arg}.  If @var{arg} is out of range
(outside [@minus{}1, 1]), @code{asin} returns a NaN.
@end defun

@defun acos arg
The value of @code{(acos @var{arg})} is a number between 0 and
@ifnottex
pi
@end ifnottex
@tex
@math{\pi}
@end tex
(inclusive) whose cosine is @var{arg}.  If @var{arg} is out of range
(outside [@minus{}1, 1]), @code{acos} returns a NaN.
@end defun

@defun atan y &optional x
The value of @code{(atan @var{y})} is a number between
@ifnottex
@minus{}pi/2
@end ifnottex
@tex
@math{-\pi/2}
@end tex
and
@ifnottex
pi/2
@end ifnottex
@tex
@math{\pi/2}
@end tex
(exclusive) whose tangent is @var{y}.  If the optional second
argument @var{x} is given, the value of @code{(atan y x)} is the
angle in radians between the vector @code{[@var{x}, @var{y}]} and the
@code{X} axis.
@end defun

@defun exp arg
This is the exponential function; it returns @math{e} to the power
@var{arg}.
@end defun

@defun log arg &optional base
This function returns the logarithm of @var{arg}, with base
@var{base}.  If you don't specify @var{base}, the natural base
@math{e} is used.  If @var{arg} or @var{base} is negative, @code{log}
returns a NaN.
@end defun

@defun expt x y
This function returns @var{x} raised to power @var{y}.  If both
arguments are integers and @var{y} is positive, the result is an
integer; in this case, overflow causes truncation, so watch out.
If @var{x} is a finite negative number and @var{y} is a finite
non-integer, @code{expt} returns a NaN.
@end defun

@defun sqrt arg
This returns the square root of @var{arg}.  If @var{arg} is finite
and less than zero, @code{sqrt} returns a NaN.
@end defun

In addition, Emacs defines the following common mathematical
constants:

@defvar float-e
The mathematical constant @math{e} (2.71828@dots{}).
@end defvar

@defvar float-pi
The mathematical constant @math{pi} (3.14159@dots{}).
@end defvar

@node Random Numbers
@section Random Numbers
@cindex random numbers

  A deterministic computer program cannot generate true random
numbers.  For most purposes, @dfn{pseudo-random numbers} suffice.  A
series of pseudo-random numbers is generated in a deterministic
fashion.  The numbers are not truly random, but they have certain
properties that mimic a random series.  For example, all possible
values occur equally often in a pseudo-random series.

@cindex seed, for random number generation
  Pseudo-random numbers are generated from a @dfn{seed value}.  Starting from
any given seed, the @code{random} function always generates the same
sequence of numbers.  By default, Emacs initializes the random seed at
startup, in such a way that the sequence of values of @code{random}
(with overwhelming likelihood) differs in each Emacs run.

  Sometimes you want the random number sequence to be repeatable.  For
example, when debugging a program whose behavior depends on the random
number sequence, it is helpful to get the same behavior in each
program run.  To make the sequence repeat, execute @code{(random "")}.
This sets the seed to a constant value for your particular Emacs
executable (though it may differ for other Emacs builds).  You can use
other strings to choose various seed values.

@defun random &optional limit
This function returns a pseudo-random integer.  Repeated calls return a
series of pseudo-random integers.

If @var{limit} is a positive integer, the value is chosen to be
nonnegative and less than @var{limit}.  Otherwise, the value might be
any integer representable in Lisp, i.e., an integer between
@code{most-negative-fixnum} and @code{most-positive-fixnum}
(@pxref{Integer Basics}).

If @var{limit} is @code{t}, it means to choose a new seed as if Emacs
were restarting, typically from the system entropy.  On systems
lacking entropy pools, choose the seed from less-random volatile data
such as the current time.

If @var{limit} is a string, it means to choose a new seed based on the
string's contents.

@end defun
