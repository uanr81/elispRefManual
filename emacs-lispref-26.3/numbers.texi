@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2019 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Numbers
@chapter Числа
@cindex integers
@cindex numbers

  GNU Emacs поддерживает два числовых типов данных: @dfn{Целое число} и
  @dfn{Число с плавающей точкой}.  Целые числа --- это такие как @minus{}3,
  0, 7, 13 и 511.  Числа с плавающей точкой являются числами с дробными
  частями, такими как @minus{}4.5, 0.0, и 2,71828.  Они также могут быть
  выражены в экспоненциальной форме: число @samp{150.0} можно выразить как
  @samp{1.5e2}, где @samp{e2} означает десять до второй степени, и
  умножается на 1,5.  Целочисленные вычисления являются точными, хотя они
  могут переполняться.  Вычисления с плавающей запятой часто связаны с
  ошибками округления, так как числа имеют фиксированную точность.

@menu
* Integer Basics::            Представление и диапазон целых чисел.
* Float Basics::              Представление и диапазон с плавающей точкой.
* Predicates on Numbers::     Проверка чисел.
* Comparison of Numbers::     Предикаты равенства и неравенства.
* Numeric Conversions::       Преобразование числа с плавающей точкой в
                              ​​целое и наоборот.
* Arithmetic Operations::     Сложение, вычитание, умножение и деление.
* Rounding Operations::       Явное округления чисел с плавающей точкой.
* Bitwise Operations::        Логическиое и, или, не, смещение.
* Math Functions::            Тригонометрические, экспоненциальные и
                              логарифмические функции.
* Random Numbers::            Получение случайных чисел, предсказуемых
                              или нет.
@end menu

@node Integer Basics
@section Целое Число Основы

  Диапазон значений для целого зависит от машины.  Минимальный диапазон
  @minus{}536,870,912 до 536,870,911 (30 бит; i.e.,
@ifnottex
@minus{}2**29
@end ifnottex
@tex
@math{-2^{29}}
@end tex
to
@ifnottex
2**29 @minus{} 1),
@end ifnottex
@tex
@math{2^{29}-1}),
@end tex
но многие машины обеспечивают более широкий диапазон. Многие примеры в этой
главе предполагают минимальную ширину целого числа, равное 30 бит.
@cindex overflow

  Lisp читатель считывает целое число в виде последовательности цифр с
  необязательным начальным знаком и дополнительной конечной точкой.
  Целое число, которое находится вне указанного диапазона Emacs,
  рассматривается как число с плавающей точкой.

@example
 1               ; @r{Целочисленное 1.}
 1.              ; @r{Целочисленное 1.}
+1               ; @r{Также целочисленное 1.}
-1               ; @r{Целочисленное @minus{}1.}
 9000000000000000000
                 ; @r{Число с плавающей точкой 9e18.}
 0               ; @r{Целочисленное 0.}
-0               ; @r{Целочисленное 0.}
@end example

@cindex integers in specific radix
@cindex radix for reading an integer
@cindex base for reading an integer
@cindex hex numbers
@cindex octal numbers
@cindex reading numbers in hex, octal, and binary
  Синтаксис для целых чисел, отличных от используемого основания 10,
  использует @samp{#} с последующей буквой, которая указывает систему
  счисления: @samp{b} для двоичной, @samp{o} для восьмеричной, @samp{x}
  для шестнадцатеричной или @samp{@var{система счисления}r} для указания
  основания @var{системы счисления}.  Для буквы, определяющей основание
  системы счисления, регистр не имеет значения.  Таким образом,
  @samp{#b@var{целочисленное}} читает @var{целочисленное} в двоичной
  системе, и @samp{#@var{система счисления}r@var{целочисленное}} читает
  @var{целочисленное} в натальной @var{системе счисления}.  Допустимые
  значения @var{систем счисления} от 2 до 36. Например:

@example
#b101100 @result{} 44
#o54 @result{} 44
#x2c @result{} 44
#24r1k @result{} 44
@end example

  Чтобы понять, как различные функции работают с целыми числами, особенно
  побитовые операторы (@pxref{Bitwise Operations}), часто бывает полезно
  просмотреть числа в двоичном виде.

  В 30-разрядным двоичном формате, десятичное число 5 выглядит следующим
  образом:

@example
0000...000101 (всего 30 бит)
@end example

@noindent
(@samp{...} означает достаточно битов, чтобы заполнить 30-разрядное слово;
в этом случае, @samp{...} стоит из двадцати бит со значением 0.  В более
поздних примерах также используется @samp{...} обозначение, чтобы двоичные
числа было легче читать.)

  Целочисленное @minus{}1 выглядит следующим образом:

@example
1111...111111 (всего 30 бит)
@end example

@noindent
@cindex two's complement
@minus{}1 представляется как 30 единиц 1.  (Это обозначение называется
@dfn{двойное дополнение}.)

  Вычитание 4 из @minus{}1 возвращает отрицательное целое число @minus{}5.
  В двоичной системе десятичной целое число 4 равно 100. Следовательно,
  @minus{}5 выглядит следующим образом:

@example
1111...111011 (всего 30 бит)
@end example

  В этом реализации наибольшее 30-разрядное двоичное целое число 536,870,911
  в десятичной системе. В двоичном формате, это выглядит следующим образом:

@example
0111...111111 (всего 30 бит)
@end example

  Поскольку арифметические функции не проверяют, выходят ли целые числа за
  пределы своего диапазона, при добавлении 1 к 536,870,911, значение
  будет отрицательным целым числом @minus{}536,870,912:

@example
(+ 1 536870911)
     @result{} -536870912
     @result{} 1000...000000 (всего 30 бит)
@end example

  Многие из функций, описанных в этой главе, принимают маркеры в качестве
  аргументов вместо чисел.  (@xref{Markers}.)  Поскольку фактическими
  аргументами таких функций могут числа или маркеры, мы часто даем этим
  аргументам имя @var{число-или-макркер}.  Когда значение аргумента является
  маркером, используется его значение позиции, а его буфер игнорируется.

@cindex largest Lisp integer
@cindex maximum Lisp integer
@defvar most-positive-fixnum
Значение этой переменной наибольшее целое число, которое может обработать
Emacs Lisp.  Типичные значения
@ifnottex
2**29 @minus{} 1
@end ifnottex
@tex
@math{2^{29}-1}
@end tex
для 32-бит и
@ifnottex
2**61 @minus{} 1
@end ifnottex
@tex
@math{2^{61}-1}
@end tex
для 64-бит платформ.
@end defvar

@cindex smallest Lisp integer
@cindex minimum Lisp integer
@defvar most-negative-fixnum
Значение этой переменной является наименьшим целым числом, которое может
обрабатывать Emacs Lisp.  Это отрицательное число.  Типичные значения
@ifnottex
@minus{}2**29
@end ifnottex
@tex
@math{-2^{29}}
@end tex
для 32-бит и
@ifnottex
@minus{}2**61
@end ifnottex
@tex
@math{-2^{61}}
@end tex
для 64-бит платформ.
@end defvar

  В Emacs Lisp, текстовые символы представлены целыми числами. Любое целое
  число между нулем и значением @code{(max-char)} включительно, считаются
  допустимыми в качестве символа.  @xref{Character Codes}.

@node Float Basics
@section Плавающая Точка Основы

@cindex @acronym{IEEE} floating point
  Числа с плавающей точкой используются для представления чисел, которые не
  являются целочисленными.  Диапазон чисел с плавающей точкой является таким
  же, как диапазон типа данных С @code{double} на компьютере, который вы
  используете.  На всех компьютерах, поддерживаемых в настоящее время Emacs,
  это числа с плавающей точкой двойной точности @acronym{IEEE}.

  Синтаксис чтения для чисел с плавающей точкой требует либо десятичной
  точки, либо показателя степени, или обоих.  Необязательные знаки
  (@samp{+} или @samp{-}) предшествуют числу и его показателю.  Например,
  @samp{1500.0}, @samp{+15e2}, @samp{15.0e+2}, @samp{+1500000e-3}, и
  @samp{.15e4} представляют пять способов записи числа с плавающей точкой,
  значение которого 1500.  Все они эквивалентны.  Как Common Lisp,
  Emacs Lisp требует, по крайней мере, наличие одной цифры после десятичной
  точки в числе с плавающей точкой; @samp{1500.} представляет собой целое
  число, а не число с плавающей точкой.

  Emacs Lisp считает @code{-0.0}, как численно равным обычному нулю
  относительно операций @code{equal} и @code{=}. Это соответствует стандарту
  с плавающей точкой @acronym{IEEE}, который говорит, что @code{-0.0} и
  @code{0.0} численно равны, хотя другие операции могут различать их.

@cindex positive infinity
@cindex negative infinity
@cindex infinity
@cindex NaN
  @acronym{IEEE} стандарт с плавающей точкой поддерживает положительную
  и отрицательную бесконечности в качестве значений с плавающей точкой.  Он
  также предусматривает класс значений, называемых NaN или ``не число'';
  Числовые функции возвращают такие значения в тех случаях, когда нет
  правильного ответа.  Например, @code{(/ 0.0 0.0)} возвращает NaN@.  Хотя
  значения NaN имеют знак, для практических целей, нет никакой существенной
  разницы между разными значениями NaN в Emacs Lisp.

Вот синтаксисы чтения для этих специальных значений с плавающей точкой:

@table @asis
@item infinity
@samp{1.0e+INF} and @samp{-1.0e+INF}
@item not-a-number
@samp{0.0e+NaN} and @samp{-0.0e+NaN}
@end table

  Следующие функции специализированы для обработки чисел с плавающей точкой:

@defun isnan x
Этот предикат возвращает @code{t}, если его аргумент с плавающей точкой
является NaN, @code{nil} иначе.
@end defun

@defun frexp x
Эта функция возвращает cons-ячейку @code{(@var{s} . @var{e})}, где @var{s}
и @var{e} являются соответственно мантисса и экспонента числа с плавающей
точкой @var{x}.

Если @var{x} конечное, то @var{s} представляет собой число с плавающей
точкой в ​​диапазоне от 0,5 (включительно) и 1,0 (исключительного), @var{e}
представляет собой целое число, и
@ifnottex
@var{x} = @var{s} * 2**@var{e}.
@end ifnottex
@tex
@math{x = s 2^e}.
@end tex
Если @var{x} равен нулю или бесконечности, то @var{s} совпадает с @var{x}.
Если @var{x} является NaN, то @var{s} также NaN@.
Если @var{x} равен нулю, то @var{e} является 0.
@end defun

@defun ldexp s e
Учитывается числовая мантисса @var{s} и целочисленный показатель @var{e},
эта функция возвращает число с плавающей точкой
@ifnottex
@var{s} * 2**@var{e}.
@end ifnottex
@tex
@math{s 2^e}.
@end tex
@end defun

@defun copysign x1 x2
Эта функция копирует знак @var{x2} в значению @var{x1}, и возвращает
результат. @var{x1} и @var{x2} должны быть плавающей точкой.
@end defun

@defun logb x
Эта функция возвращает двоичную экспоненту @var{x}. Более точно, значение
представляет собой логарифм по основанию 2 от @math{|x|}, округленый до
целого числа.

@example
(logb 10)
     @result{} 3
(logb 10.0e20)
     @result{} 69
@end example
@end defun

@node Predicates on Numbers
@section Тип Предикат для Чисел
@cindex predicates for numbers

  Функции в этом разделе проверяют числа, или числа определённого типа.
  Функции @code{integerp} и @code{floatp} могут принимать любой тип Lisp
  объекта в качестве аргумента (они не были бы очень ползны), но
  @code{zerop} предикат требует число в качестве аргумента.  Смотри
  @code{integer-or-marker-p} и @code{number-or-marker-p}, в
  @ref{Predicates on Markers}.

@defun floatp object
Этот предикат проверяет, является ли ее аргумент с плавающей точкой и
возвращает @code{t} если да, и @code{nil} в противном случае.
@end defun

@defun integerp object
Этот предикат проверяет является ли аргумент целым числом, и возвращает
@code{t} если да, и @code{nil} в противном случае.
@end defun

@defun numberp object
Этот предикат проверяет является ли его аргумент числом (либо целым или
с плавающей точкой) и возвращает @code{t} если да, и @code{nil} в
противном случае.
@end defun

@defun natnump object
@cindex natural numbers
Этот предикат (чье название происходит от фразы ``натуральное число'')
проверяет, является ли аргумент неотрицательным целым числом, и возвращает
@code{t} если да, и @code{nil} в противном случае.  0 считается
неотрицательным.

@findex wholenump
@code{wholenump} это синоним @code{natnump}.
@end defun

@defun zerop number
Этот предикат проверяет, равен ли ее аргумент нулю, и возвращает @code{t}
если да, и @code{nil} в противном случае.  Аргумент должен быть числом.

@code{(zerop x)} синоним @code{(= x 0)}.
@end defun

@node Comparison of Numbers
@section Сравнение Чисел
@cindex number comparison
@cindex comparing numbers

  Для проверки чисел на численное равенство, обычно следует использовать
  @code{=}, не @code{eq}.  Может быть много различных объектов с плавающей
  точкой с одинаковым числовым значением.  Используете @code{eq},
  чтобы сравнить являются ли два значения одим и тем же @emph{объектом}.
  В противоположность этому, @code{=} сравнивает только числовые значения
  объектов.

  В Emacs Lisp, каждое целое число является уникальным объектом Lisp.
  Поэтому @code{eq} эквивалентно @code{=} для целых чисел.  Иногда удобно
  использовать @code{eq} для сравнения неизвестного значения с целым числом,
  потому что @code{eq} не сообщает об ошибке, если неизвестное значение не
  является числом --- приинимаются аргументы любого типа.  В
  противоположность этому, @code{=} сигнализирует об ошибке, если аргументы
  не являются числами или маркерами.  Тем не менее, лучшая практика
  программирования по возможности использовать @code{=} для сравнения целых
  чисел.

  Иногда бывает полезно сравнить числа с помощью @code{equal}, при этом два
  числа рассматриваются как равные, если они имеют один и тот же тип данных
  (оба целые числа, или оба с плавающей точкой) и одно и то же значение. В
  отличие от этого, @code{=} может рассматривать целое число и число с
  плавающей точкой, как равные.  @xref{Equality Predicates}.

  Существует еще одна загвоздка: потому что арифметика с плавающей точкой не
  является точной, часто бывает плохая идея проверять равенство значений с
  плавающей точкой.  Обычно лучше проверить примерное равенства.  Вот
  функция, которая делает это:

@example
(defvar fuzz-factor 1.0e-6)
(defun approx-equal (x y)
  (or (= x y)
      (< (/ (abs (- x y))
            (max (abs x) (abs y)))
         fuzz-factor)))
@end example

@cindex CL note---integers vrs @code{eq}
@quotation
@b{Common Lisp примечание:} Сравнение чисел в Common Lisp всегда требует
@code{=}, потому что Common Lisp реализует многословные целые числа, и два
различных целочисленных объекта могут иметь одно и то же числовое значение.
Emacs Lisp может иметь только один целочисленный объект для любого заданного
значения, поскольку он имеет ограниченный диапазон целых чисел.
@end quotation

@defun = number-or-marker &rest number-or-markers
Эта функция проверяет, является ли все ее аргументы численно равными, и
возвращает @code{t} если да, и @code{nil} в противном случае.
@end defun

@defun eql value1 value2
Эта функция действует как @code{eq}, за  исключением случаев, когда оба
аргумента это числа.  Она сравнивает числа по типу и числовому значению,
так что @code{(eql 1.0 1)} возвращает @code{nil}, но @code{(eql 1.0 1.0)}
и @code{(eql 1 1)} как возвращает @code{t}.
@end defun

@defun /= number-or-marker1 number-or-marker2
Эта функция проверяет, является ли его аргументы численно равными, и
возвращает @code{t}, если не являются, и @code{nil} если значения равны.
@end defun

@defun <  number-or-marker &rest number-or-markers
Эта функция проверяет, является ли каждый аргумент строго меньше, чем
следующий аргумент.  Она возвращает @code{t} если да, и @code{nil} в
противном случае.
@end defun

@defun <= number-or-marker &rest number-or-markers
Эта функция проверяет, является ли каждый аргумент меньше или равным
следующему аргументу.  Она возвращает @code{t} если да, и @code{nil} в
противном случае.
@end defun

@defun > number-or-marker &rest number-or-markers
Эта функция проверяет, является ли каждый аргумент строго больше, чем
следующи.  Она возвращает @code{t} если да, и @code{nil} в противном случае.
@end defun

@defun >= number-or-marker &rest number-or-markers
Эта функция проверяет, является ли большим или равным аргумент, чем каждый
следующий аргумент.  Она возвращает @code{t} если да, и @code{nil} в
противном случае.
@end defun

@defun max number-or-marker &rest numbers-or-markers
Эта функция возвращает наибольший из ее аргументов.

@example
(max 20)
     @result{} 20
(max 1 2.5)
     @result{} 2.5
(max 1 3 2.5)
     @result{} 3
@end example
@end defun

@defun min number-or-marker &rest numbers-or-markers
Эта функция возвращает наименьший из ее аргументов.

@example
(min -4 1)
     @result{} -4
@end example
@end defun

@defun abs number
Эта функция возвращает абсолютное значение @var{number}.
@end defun

@node Numeric Conversions
@section Числовые Преобразования
@cindex rounding in conversions
@cindex number conversions
@cindex converting numbers

Чтобы преобразовать целое число с плавающей точкой, используйте
функцию @code{float}.

@defun float number
Это возвращает @var{number}, преобразованное в число с плавающей точкой.
Если @var{number} уже число с плавающей точкой, @code{float} возвращает
его без изменений.
@end defun

  Есть четыре функции для преобразования чисел с плавающей точкой в ​​целые
  числа; они отличаются тем, как они округляют число.  Все принимают
  аргумент @var{number} и необязательный аргумент @var{divisor}.  Оба
  аргумента могут быть целыми числами или числами с плавающей точкой.
  @var{divisor} также может быть @code{nil}.  Если @var{divisor} является
  @code{nil} или опущен, то эти функции преобразовуют @var{number} в целое
  число, или возвращают его без изменений, если оно и так целое число.
  Если @var{divisor} является не-@code{nil}, функции делят @var{number} на
  @var{divisor} и преобразовывают результат в целое число.  Если
  @var{divisor} равен нулю (целочисленному или с плавающей точкой), то
  Emacs сигнализирует об ошибке @code{arith-error}.

@defun truncate number &optional divisor
Возвращает @var{number}, преобразованное в целое число путем округления в
сторону нуля.

@example
(truncate 1.2)
     @result{} 1
(truncate 1.7)
     @result{} 1
(truncate -1.2)
     @result{} -1
(truncate -1.7)
     @result{} -1
@end example
@end defun

@defun floor number &optional divisor
Возвращает @var{number}, преобразованное в целое число путем округления
в меньшую сторону (в сторону отрицательной бесконечности).

Если указан @var{divisor}, это использует операцию деления, что
соответствует @code{mod}, округлению в меньшую сторону.

@example
(floor 1.2)
     @result{} 1
(floor 1.7)
     @result{} 1
(floor -1.2)
     @result{} -2
(floor -1.7)
     @result{} -2
(floor 5.99 3)
     @result{} 1
@end example
@end defun

@defun ceiling number &optional divisor
Возвращает @var{number}, преобразованное в целое число путем округления
в большую сторону (по направлению к положительной бесконечности).

@example
(ceiling 1.2)
     @result{} 2
(ceiling 1.7)
     @result{} 2
(ceiling -1.2)
     @result{} -1
(ceiling -1.7)
     @result{} -1
@end example
@end defun

@defun round number &optional divisor
Возвращает @var{number}, преобразованное в целое число путем округления в
сторону ближайшего целого числа.  Округление равноудалённого значения между
двумя целыми числами возвращает чётное целое число.

@example
(round 1.2)
     @result{} 1
(round 1.7)
     @result{} 2
(round -1.2)
     @result{} -1
(round -1.7)
     @result{} -2
@end example
@end defun

@node Arithmetic Operations
@section Арифметические Операции
@cindex arithmetic operations

  Emacs Lisp обеспечивает четыре традиционные арифметические операции
  (сложение, вычитание, умножение и деление), функцию остатка от деления
  и функции приращения и вычитания 1.  За исключением @code{%}, каждая из
  этих функций принимают как целые, так и чмсла с плавающей точкой в
  качестве аргументов и возвращает число с плавающей точкой, если какой-либо
  аргумент был числом с плавающей точкой.

  Арифметические функции Emacs Lisp не проверяют целочисленное переполнение.
  Таким образом @code{(1+ 536870911)} может оценено как @minus{}536870912,
  в зависимости от вашего оборудования.

@defun 1+ number-or-marker
Функция возвращает @var{number-or-marker} плюс 1.
Пример,

@example
(setq foo 4)
     @result{} 4
(1+ foo)
     @result{} 5
@end example

Функция не является аналогом оператора C @code{++} --- она не увеличивает
значение переменной.  Она просто вычисляет сумму.  Таким образом, если мы
продолжим,

@example
foo
     @result{} 4
@end example

Если вы хотите увеличить значение переменной, вы должны использовать
@code{setq}, как здесь:

@example
(setq foo (1+ foo))
     @result{} 5
@end example
@end defun

@defun 1- number-or-marker
Функция возвращает @var{number-or-marker} минус 1.
@end defun

@defun + &rest numbers-or-markers
Функция складывает все свои аргументы вместе.  Если не задано никаких
аргументов, @code{+} возвращает 0.

@example
(+)
     @result{} 0
(+ 1)
     @result{} 1
(+ 1 2 3 4)
     @result{} 10
@end example
@end defun

@defun - &optional number-or-marker &rest more-numbers-or-markers
Функция @code{-} служит двум целям: отрицание и вычитание. Когда @code{-}
имеет один аргумент, то значение --- отрицательное значение аргумента.  При
наличии нескольких аргументов, @code{-} вычитает значение каждого аргумента
@var{more-numbers-or-markers} из оставшегося (кумулятивного) значения
@var{number-or-marker}.  Если аргументов аргументов нет, результатом будет 0.

@example
(- 10 1 2 3 4)
     @result{} 0
(- 10)
     @result{} -10
(-)
     @result{} 0
@end example
@end defun

@defun * &rest numbers-or-markers
Функция перемножает все свои аргументы, и возвращает результат.  Когда не
задано никаких аргументов, @code{*} возвращает 1.

@example
(*)
     @result{} 1
(* 1)
     @result{} 1
(* 1 2 3 4)
     @result{} 24
@end example
@end defun

@defun / number &rest divisors
С одним или несколькими @var{divisors}, эта функция по очереди делит
кумулятивное значение @var{number} с каждым последующим делителем
@var{divisors}, и возвращает частное.  При отсутствии @var{divisors}, эта
функция возвращает 1/@var{number}, то есть, мультипликативную инверсию
значения @var{number}.  Каждый аргумент может быть числом или маркером.

Если все аргументы являются целыми числами, то результат будет представлять
собой целое число, полученное округлением частного в сторону нуля после
каждого деления.

@example
@group
(/ 6 2)
     @result{} 3
@end group
@group
(/ 5 2)
     @result{} 2
@end group
@group
(/ 5.0 2)
     @result{} 2.5
@end group
@group
(/ 5 2.0)
     @result{} 2.5
@end group
@group
(/ 5.0 2.0)
     @result{} 2.5
@end group
@group
(/ 4.0)
     @result{} 0.25
@end group
@group
(/ 4)
     @result{} 0
@end group
@group
(/ 25 3 2)
     @result{} 4
@end group
@group
(/ -17 6)
     @result{} -2
@end group
@end example

@cindex @code{arith-error} in division
Если разделить целое число на целое число 0, Emacs сигнализирует об ошибке
(@pxref{Errors}) @code{arith-error}.  Деление ненулевого значения
числа с плавающей точкой на ноль даёт в результате либо положительную, либо
отрицательную бесконечность (@pxref{Float Basics}).
@end defun

@defun % dividend divisor
@cindex remainder
Функция возвращает целочисленный остаток после деления @var{dividend} на
@var{divisor}.  Аргументы должны быть целыми числами или маркерами.

Для любых двух целых чисел @var{dividend} и @var{divisor},
(Здесь неясность nunbers720)
@example
@group
(+ (% @var{dividend} @var{divisor})
   (* (/ @var{dividend} @var{divisor}) @var{divisor}))
@end group
@end example

@noindent
всегда равна @var{dividend} если @var{divisor} не равен нулю.

@example
(% 9 4)
     @result{} 1
(% -9 4)
     @result{} -1
(% 9 -4)
     @result{} 1
(% -9 -4)
     @result{} -1
@end example
@end defun

@defun mod dividend divisor
@cindex modulus
Функция возвращает значение @var{dividend} по модулю  @var{divisor};
Другими словами, после того, как остаток от деления @var{dividend} на
@var{divisor}, но с тем же знаком, что и @var{divisor}.  Аргументы должны
быть числами или маркерами.

В отличие от @code{%}, @code{mod} поддерживает аргументы чисел с плавающей
точкой; он округляет частное вниз (в сторону минус бесконечности) до целого
числа, и использует это частное для вычисления остатка.

Если @var{divisor} равен нулю, @code{mod} сигнализирует об ошибке
@code{arith-error}, если оба аргумента являются целыми числами, и возвращает
NaN в противном случае. (Здесь не понятно numbers756)

@example
@group
(mod 9 4)
     @result{} 1
@end group
@group
(mod -9 4)
     @result{} 3
@end group
@group
(mod 9 -4)
     @result{} -3
@end group
@group
(mod -9 -4)
     @result{} -1
@end group
@group
(mod 5.5 2.5)
     @result{} .5
@end group
@end example

Для любых двух чисел @var{dividend} и @var{divisor},

@example
@group
(+ (mod @var{dividend} @var{divisor})
   (* (floor @var{dividend} @var{divisor}) @var{divisor}))
@end group
@end example

@noindent
всегда равняется @var{dividend}, с учётом ошибки округления, если любой из
аргументов имеет значение числа с плавающей точкой, и @code{arith-error},
если @var{dividend} является целым числом, а @var{divisor} равно 0 .  Для
@code{floor}, смотри @ref{Numeric Conversions}.
@end defun

@node Rounding Operations
@section Операции Округления
@cindex rounding without conversion

Функции @code{ffloor}, @code{fceiling}, @code{fround} и @code{ftruncate}
принимают в аргументы, числа с плавающей точкой и возвращают в результате
число с плавающей точкой, значение которого ближнее соседнее целое.
@code{ffloor} возвращает ближайшее меньшее целое число; @code{fceiling},
ближайшее большее целое число; @code{ftruncate}, ближайшее целое в
направлении к нулю; @code{fround}, ближайшее целое число.

@defun ffloor float
Функция округляет @var{float} до ближаешему меньшему целому значению, и
возвращает это значение в виде числа с плавающей точкой.
@end defun

@defun fceiling float
Функция округляет @var{float} до ближайшего большему целому значению, и
возвращает это значение в виде числа с плавающей точкой.
@end defun

@defun ftruncate float
Функция округляет @var{float} в сторону нуля до ближайшего целого значения,
и возвращает это значение в виде числа с плавающей точкой.
@end defun

@defun fround float
Функция округляет @var{float} до ближайшего целого значения, и возвращает
это значение в виде числа с плавающей точкой.  Округление равноудалённого
значения между двумя целыми числами, возвращает чётное целое число.
@end defun

@node Bitwise Operations
@section Побитовые Операции с Целыми Числами
@cindex bitwise arithmetic
@cindex logical arithmetic

  В компьютере целое число представлено в виде двоичного числа,
  последовательностью @dfn{бит} (цифр, которые либо ноль либо единица).
  Поразрядная операция действует на отдельные биты такой последовательности.
  Например, @dfn{сдвиг} перемещает всю последовательность влево или вправо
  на одну или несколько позиций, воспроизводя один и тот же перемещённый
  паттерн.

  Побитовые операции в Emacs Lisp применяются только к целым числам.

@defun lsh integer1 count
@cindex logical shift
@code{lsh}, что это аббревиатура для @dfn{логического сдвига}, сдвигает биты
в @var{integer1} в лево на @var{count} позиций, или вправо, если @var{count}
отрицателен, в результате в освободившиеся биты помещаются нули.  Если
аргумент @var{count} отрицательный, @code{lsh} сдвигает нули в самый левый
крайний (самый старший) бит, производя положительный результат, даже если
@var{integer1} отрицателен. Сравните это с @code{ash} ниже.

Ниже приведены два примера @code{lsh}, сдвига паттерна битов на одну позицию
влево.  Мы показываем только младшие восемь бит двоичного шаблона; остальные
равны нулю.

@example
@group
(lsh 5 1)
     @result{} 10
;; @r{Десятичное 5 становится десятичным 10.}
00000101 @result{} 00001010

(lsh 7 1)
     @result{} 14
;; @r{Десятичное 7 становится десятичным 14.}
00000111 @result{} 00001110
@end group
@end example

@noindent
Как видно из примеров, сдвиг последовательности битов на одну позицию влево
производит число, которое в два раза превышает значение предыдущего числа.

Сдвиг шаблона битов две позиции влево дает такие результаты(с 8-битными
двоичными числами):

@example
@group
(lsh 3 2)
     @result{} 12
;; @r{Десятичное 3 становится десятичным 12.}
00000011 @result{} 00001100
@end group
@end example

С другой стороны, смещение на одну позицию вправо выглядит следующим образом:

@example
@group
(lsh 6 -1)
     @result{} 3
;; @r{Десятичное 6 становится десятичным 3.}
00000110 @result{} 00000011
@end group

@group
(lsh 5 -1)
     @result{} 2
;; @r{Десятичное 5 становится десятичным 2.}
00000101 @result{} 00000010
@end group
@end example

@noindent
Как видно из примера, сдвиг на одну позицию вправо делит значение
положительного целого числа на два, округляя в меньщую сторону.

Функция @code{lsh}, как и все Emacs Lisp арифметические функции, не
проверяет переполнение, поэтому сдвиг влево может отброзить старшие биты и
изменить знак числа.  Например, сдвиг влево числа 536,870,911 производит
@minus{}2 в реализации 30-bit:

@example
(lsh 536870911 1)          ; @r{левый сдвиг}
     @result{} -2
@end example

В двоичном формате, аргумент выглядит следующим образом:

@example
@group
;; @r{Десятичное 536,870,911}
0111...111111 (всего 30 бит)
@end group
@end example

@noindent
после сдвига влево становится:

@example
@group
;; @r{Десятичное @minus{}2}
1111...111110 (всего 30 бит)
@end group
@end example
@end defun

@defun ash integer1 count
@cindex arithmetic shift
@code{ash} (@dfn{арифметический сдвиг}) сдвигает биты в @var{integer1} в
лево на @var{count} позиций и вправо, если @var{count} отрицательный.

@code{ash} дает те же результаты, что и @code{lsh}, когда  @var{integer1}
и @var{count} оба отрицательны.  В этом случае, @code{ash} помещает единицы
в пустые позиции битов слева, в то время как @code{lsh} помещает нули в
этих битовых позициях.

Таким образом, с @code{ash}, сдвиг последовательности бит на одну позицию
вправо выглядят следующим образом:

@example
@group
(ash -6 -1) @result{} -3
;; @r{Десятичное @minus{}6 становится десятичным @minus{}3.}
1111...111010 (всего 30 бит)
     @result{}
1111...111101 (всего 30 бит)
@end group
@end example

В отличие от этого, смещение последовательности битов на одну позицию вправо
по средствам @code{lsh} выглядит следующим образом:

@example
@group
(lsh -6 -1) @result{} 536870909
;; @r{Десятичное @minus{}6 становится десятичным 536,870,909.}
1111...111010 (всего 30 бит)
     @result{}
0111...111101 (всего 30 бит)
@end group
@end example

Вот другие примеры:

@c !!! Проверьте, построение в smallbook формате! XDVI показывает
@c проблемы с smallbook, но не с стандартной книгой! --rjc 16mar92
@smallexample
@group
                   ;  @r{       30-битное двоичное значение}

(lsh 5 2)          ;   5  =  @r{0000...000101}
     @result{} 20         ;      =  @r{0000...010100}
@end group
@group
(ash 5 2)
     @result{} 20
(lsh -5 2)         ;  -5  =  @r{1111...111011}
     @result{} -20        ;      =  @r{1111...101100}
(ash -5 2)
     @result{} -20
@end group
@group
(lsh 5 -2)         ;   5  =  @r{0000...000101}
     @result{} 1          ;      =  @r{0000...000001}
@end group
@group
(ash 5 -2)
     @result{} 1
@end group
@group
(lsh -5 -2)        ;  -5  =  @r{1111...111011}
     @result{} 268435454
                   ;      =  @r{0011...111110}
@end group
@group
(ash -5 -2)        ;  -5  =  @r{1111...111011}
     @result{} -2         ;      =  @r{1111...111110}
@end group
@end smallexample
@end defun

@defun logand &rest ints-or-markers
Функция возвращает побитовое И из аргумента: в результате @var{n}й бит
устанавливается в 1, если, и только тогда, когда @var{n}й бит всех
аргументов является 1.

Например, при использовании 4-битных двоичных чисел, побитовое И из 13 и 12
продукцирует 12: 1101 в сочетании с 1100 производит 1100.  В обоих двоичных
числах, крайние левые два бита установлены в 1, так что крайние левые два
бита возвращаемого значения равны по 1.  Однако для правых крайних двух
битов, в одном из аргументов присутствует 0 в другом 1, поэтому крайние
два бита возвращаемого значения установлены в 0.

@noindent
Следовательно,

@example
@group
(logand 13 12)
     @result{} 12
@end group
@end example

Если @code{logand} не передается никаких аргументов, она возвращает значение
@minus{}1.  Это число является показателем идентичности для @code{logand},
поскольку его двоичное представление полностью состоит из единиц.  Если
@code{logand} передается только один аргумент, возвращается этот аргумент.

@smallexample
@group
                   ; @r{       30-битное двоичное значение}

(logand 14 13)     ; 14  =  @r{0000...001110}
                   ; 13  =  @r{0000...001101}
     @result{} 12         ; 12  =  @r{0000...001100}
@end group

@group
(logand 14 13 4)   ; 14  =  @r{0000...001110}
                   ; 13  =  @r{0000...001101}
                   ;  4  =  @r{0000...000100}
     @result{} 4          ;  4  =  @r{0000...000100}
@end group

@group
(logand)
     @result{} -1         ; -1  =  @r{1111...111111}
@end group
@end smallexample
@end defun

@defun logior &rest ints-or-markers
Функция возвращает поразрядное ИЛИ своих аргументов: @var{n}й бит
устанавливается в 1, если, и только тогда, когда @var{n}й бит, по меньшей
мере, одного из аргументов установлен в 1.  Если аргументов не передаётся,
результат будет 0, который является показателем идентичности для этой
операции.  Если @code{logior} передается только один аргумент,
возвращается этот аргумент.

@smallexample
@group
                   ; @r{       30-битное двоичное значение}

(logior 12 5)      ; 12  =  @r{0000...001100}
                   ;  5  =  @r{0000...000101}
     @result{} 13         ; 13  =  @r{0000...001101}
@end group

@group
(logior 12 5 7)    ; 12  =  @r{0000...001100}
                   ;  5  =  @r{0000...000101}
                   ;  7  =  @r{0000...000111}
     @result{} 15         ; 15  =  @r{0000...001111}
@end group
@end smallexample
@end defun

@defun logxor &rest ints-or-markers
Функция возвращает побитовое исключающее ИЛИ своих аргументов: @var{n}й
бит результата устанавливается в 1, если, и только если, хотя бы один
@var{n}й бит из числа всех аргументов установлен в 1.  Если нет аргументов,
результатом будет 0, который является показателем идентичности для этой
операции.  Если @code{logxor} передается только один аргумент,
возвращается этот аргумент.

@smallexample
@group
                   ; @r{       30-битное двоичное число}

(logxor 12 5)      ; 12  =  @r{0000...001100}
                   ;  5  =  @r{0000...000101}
     @result{} 9          ;  9  =  @r{0000...001001}
@end group

@group
(logxor 12 5 7)    ; 12  =  @r{0000...001100}
                   ;  5  =  @r{0000...000101}
                   ;  7  =  @r{0000...000111}
     @result{} 14         ; 14  =  @r{0000...001110}
@end group
@end smallexample
@end defun

@defun lognot integer
Функция возвращает побитовое дополнение своего аргумента: @var{n}й бит
результата устанавливается в еденицу, если, и только если, @var{n}й бит
в @var{integer} установлен в ноль, и наоборот.

@example
(lognot 5)
     @result{} -6
;;  5  =  @r{0000...000101} (всего 30 бит)
;; @r{becomes}
;; -6  =  @r{1111...111010} (всего 30 бит)
@end example
@end defun

@node Math Functions
@section Стандартные Математические Функции
@cindex transcendental functions
@cindex mathematical functions
@cindex floating-point functions

  Эти математические функции позволяют использовать в качестве аргументов
  как целые числа, так и числа с плавающей точкой.

@defun sin arg
@defunx cos arg
@defunx tan arg
Это основные тригонометрические функции с аргументом @var{arg} измеряемом
в радианах.
@end defun

@defun asin arg
Значение @code{(asin @var{arg})} является числом между
@ifnottex
@minus{}pi/2
@end ifnottex
@tex
@math{-\pi/2}
@end tex
и
@ifnottex
pi/2
@end ifnottex
@tex
@math{\pi/2}
@end tex
(включительно), синус которого равен @var{arg}.  Если @var{arg} находится
вне допустимого диапазона (за пределами [@minus{}1, 1]), @code{asin}
возвращает NaN.
@end defun

@defun acos arg
Значение @code{(acos @var{arg})} представляет собой число от 0 до
@ifnottex
pi
@end ifnottex
@tex
@math{\pi}
@end tex
(включительно), косинус которого равен @var{arg}.  Если @var{arg} находится
вне допустимого диапазона (за пределами [@minus{}1, 1]), @code{acos}
возвращает NaN.
@end defun

@defun atan y &optional x
Значение @code{(atan @var{y})} является числом между
@ifnottex
@minus{}pi/2
@end ifnottex
@tex
@math{-\pi/2}
@end tex
и
@ifnottex
pi/2
@end ifnottex
@tex
@math{\pi/2}
@end tex
(исключая), тангенс которого равен @var{y}.  Если указан необязательный
второй аргумент @var{x}, значение @code{(atan y x)} представляет собой угол
в радианах между вектором @code{[@var{x}, @var{y}]} и осью @code{X}.
@end defun

@defun exp arg
Экспоненциальная функция; она возвращает экспоненту @math{e} к аргументу
(Нужно разбираться numbers1200)@var{arg}.
@end defun

@defun log arg &optional base
Функция возвращает логарифм @var{arg}, с основанием @var{base}.  Если не
указано основание @var{base}, используется естественная основание @math{e}.
Если @var{arg} или @var{base} отрицательны, @code{log} возвращает NaN.
@end defun

@defun expt x y
Функция возвращает @var{x} в степени @var{y}.  Если оба аргумента являются
целыми числами и @var{y} положительное число, результат будет целым числом;
в этом случае, переполнение вызывает усечение, так что будте внимательны.
Если @var{x} конечное отрицательное число и @var{y} конечное нецелое число,
@code{expt} возвращает NaN.
@end defun

@defun sqrt arg
Возвращает квадратный корень @var{arg}.  Если @var{arg} конечно и меньше
нуля, @code{sqrt} возвращает NaN. (Неточность1219)
@end defun

Кроме того, в Emacs определены следующие общие математические константы:

@defvar float-e
Математическая константа @math{e} (2.71828@dots{}).
@end defvar

@defvar float-pi
Математическая константа @math{pi} (3.14159@dots{}).
@end defvar

@node Random Numbers
@section Случайные Числа
@cindex random numbers

  Детерминированная компьютерная программа не может генерировать случайные
  числа.  В большинстве случаев, @dfn{псевдо-случайных-чисел} достаточно.
  Серия псевдослучайных чисел генерируются детерминированным образом.  Числа
  не являются истинно случайными, но они имеют определенные свойства,
  которые имитируют случайный ряд.  Например, все возможные значения
  встречаются с одинаковой частотой в псевдослучайном ряду.

@cindex seed, for random number generation
  Псевдослучайные числа генерируются из @dfn{начального значения}.  Начиная
  с любого заданного начального числа, функция @code{random} всегда
  порождает одну и ту же последовательность чисел.  По умолчанию, Emacs
  инициализирует начальное число при запуске, таким образом, что
  последовательность значений @code{random} (с подавляющей вероятностью)
  отличается в каждом запуске Emacs.

  Иногда требуется, чтобы случайная последовательность чисел повторялась.
  Например, при отладке программы, поведение которой зависит от
  последовательности случайных чисел, полезно, чтобы получить такое же
  поведение при каждом запуске программы.  Для того, чтобы повторить
  последовательность, выполнить @code{(random "")}.  Это установит для
  начального значения постоянное значение для вашего конкретного
  исполняемого файла Emacs (хотя онj может отличаться для другой Emacs
  сборки).  Вы можете использовать содержание других строки, чтобы выбрать
  различные значения начальных значений.

@defun random &optional limit
Функция возвращает псевдослучайное целое число.  Повторные вызовы возвращают
серию псевдослучайных целых чисел.

Если @var{limit} является положительным целым числом, значение выбирается
так, чтобы быть неотрицательным и меньше, чем @var{limit}.  В противном
случае, значение может быть любым целым, представимым в Lisp, то есть
целое число между @code{most-negative-fixnum} и @code{most-positive-fixnum}
(@pxref{Integer Basics}).

Если @var{limit} установлен в @code{t}, значит выбрается новое начальное
значение, как если бы Emacs был перезапущен, обычно из энтропии системы.  В
системах, без пулов энтропии, выбраются значения из менее случайных
изменчивых данных, такие как текущее время.

Если @var{limit} является строкой, то это значит выбрать начальное значение
на основе содержимого строки.

@end defun
