@c -*- mode: texinfo; coding: utf-8 -*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2019 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Control Structures
@chapter Управляющие Структуры
@cindex special forms for control structures
@cindex forms for control structures
@cindex control structures

  Lisp программа состоит из набора @dfn{выражений} или @dfn{форм}
  (@pxref{Forms}).  Контроль порядка выполнения этих форм, реализуется
  заключением их в @dfn{управляющие структуры}.  Управляющие структуры
  являются специальными формами, которые контролируют, когда, сколько раз,
  каким образом и нужно ли вообще оценивать содержащиеся в них формы.

@cindex textual order
  Простейший порядок выполнения - последовательное выполнение: вначале
  оценивается @var{a}, затем оценивается @var{b}, и так далее.  Это то, что
  происходит, когда написано несколько форм подряд в теле функции, или на
  верхнем уровне в файле Lisp кода --- формы выполняются в том порядке в
  котором написаны.  Называется это @dfn{текстовый порядок}.  Например, если
  тело функции состоит из двух форм @var{a} и @var{b}, оценка функции
  оценивает вначале @var{a}, а затем @var{b}.  Результат вычисления @var{b}
  становится значением функции.

  Явные структуры управления делают возможным порядок исполнения, отличным от
  последовательного.

  Emacs Lisp обеспечивает несколько видов структур управления, в том числе
  других разновидностей упорядочивания выполнения: условные выражения,
  итерации, и (управляемых) переходов --- все обсуждается ниже.  Встроенные
  управляющие структуры являются особыми формами, так как их подчиненные
  формы не обязательно все оценеваются или оцениваются последовательно.
  Можно использовать макросы, чтобы определить свои собственные конструкции
  структур управления (@pxref{Macros}).

@menu
* Sequencing::             Оценка в текстовом порядке.
* Conditionals::           @code{if}, @code{cond}, @code{when}, @code{unless}.
* Combining Conditions::   @code{and}, @code{or}, @code{not}.
* Pattern-Matching Conditional::  Как использовать @code{pcase} и друзей.(БаянControl43)
* Iteration::              @code{while} циклы.
* Generators::             Общие последовательности и сопрограммы.
* Nonlocal Exits::         Выход из последовательности.
@end menu

@node Sequencing
@section Последовательное Выпрлнение
@cindex sequencing
@cindex sequential execution
@cindex forms for sequential execution

  Оценка форм, в порядке их появления, является наиболее распостраненным
  способом перехода управления от одной формы в другую.  В некоторых случаях,
  например, в теле функции, это происходит автоматически.  В другом случае
  нужно использовать конструкцию управляющей структуры: @code{progn},
  простейшая управляющая структура Lisp.

  @code{progn} - особая форма выглядит следующим образом:

@example
@group
(progn @var{a} @var{b} @var{c} @dots{})
@end group
@end example

@noindent
что определяет выполнение форм @var{a}, @var{b}, @var{c}, и так далее, в
указанном порядке.  Эти формы называются @dfn{тело} формы @code{progn}.
Значение последней формы в этом теле, становится значением всей формы
@code{progn}.  @code{(progn)} возвращает значение @code{nil}.

@cindex implicit @code{progn}
  На заре Lisp, @code{progn} был единственный способ выполнить две или более
  форм последовательно и использовать значение последней из них.  Но
  программисты обнаружили, что часто необходимо использовать @code{progn} в
  теле функции, где (в то время) разрешена была только одна форма.  Таким
  образом, тело функции было преобразовано в неявном @code{progn}:  несколько
  форм так же разрешаются, как в теле фактического @code{progn}.  Многие
  другие управляющие структуры также содержат неявный @code{progn}.  В
  результате, @code{progn} не используется так часто, как это было много лет
  назад.  В настоящее время данная форма нужна чаще всего внутри
  @code{unwind-protect}, @code{and}, @code{or}, или в качестве
  @var{then}-части в конструкции @code{if}.

@defspec progn forms@dots{}
Эта особая форма оценивает все @var{forms} в текстовом порядке и возвращаят
результат оценки последней формы.

@example
@group
(progn (print "Первая форма")
       (print "Вторая форма")
       (print "Третья форма"))
     @print{} "Первая форма"
     @print{} "Вторая форма"
     @print{} "Третья форма"
@result{} "Третья форма"
@end group
@end example
@end defspec

  Две другие конструкции также оценивают ряд форм, но возвращатют разные
  значения:

@defspec prog1 form1 forms@dots{}
Эта специальная форма оценивает @var{form1} и все остальные @var{forms} в
текстовом порядке и возвращает результат @var{form1}.

@example
@group
(prog1 (print "Первая форма")
       (print "Вторая форма")
       (print "Третья форма"))
     @print{} "Первая форма"
     @print{} "Вторая форма"
     @print{} "Третья форма"
@result{} "Первая форма"
@end group
@end example

Вот способ, чтобы удалить первый элемент из списка в переменной @code{x}, а
затем вернуть значение удалённого элемента:

@example
(prog1 (car x) (setq x (cdr x)))
@end example
@end defspec

@defspec prog2 form1 form2 forms@dots{}
Эта особая форма оценивает @var{form1}, @var{form2}, и все следующие
@var{forms}, в текстовом порядке и возвращает результат @var{form2}.

@example
@group
(prog2 (print "Первая форма")
       (print "Вторая форма")
       (print "Третья форма"))
     @print{} "Первая форма"
     @print{} "Вторая форма"
     @print{} "Третья форма"
@result{} "Вторая форма"
@end group
@end example
@end defspec

@node Conditionals
@section Условные Выражения
@cindex conditional evaluation
@cindex forms, conditional

  Условные структуры управления выбрают один из вариантов.  Emacs Lisp имеет
  пять условных форм: @code{if}, которая является такой же, как и в других
  языках; @code{when} и @code{unless}, которые являются вариантами @code{if};
  @code{cond}, который является обобщенным оператором case; и @code{pcase},
  который представляет собой обобщение @code{cond}
  (@pxref{Pattern-Matching Conditional}).

@defspec if condition then-form else-forms@dots{}
@code{if} направляет управление между ветками @var{then-form} и
@var{else-forms} на основе оцененного значения условия @var{condition}.  Если
@var{condition} оценивается в не-@code{nil}, оценивается ветка
@var{then-form} и  этот результат возвращается. В противном случае,
оценивается ветка @var{else-forms} в текстовом порядке, и значение
последней формы этой ветки возвращается.  (@var{else}-ветка
@code{if} является примером неявного использования @code{progn}.
@xref{Sequencing}.)

Если условие @var{condition} оценивается в @code{nil}, а формы в ветке
@var{else-forms} не указаны, @code{if} возвращает значение @code{nil}.

@code{if} - это особая форма, так как ветвь, которая не выбрана, никогда не
оценивается---игнорируется.  Таким образом, в этом примере, @code{истина} не
печатается, потому что @code{print} не выполняется:

@example
@group
(if nil
    (print 'истина)
  'ложь)
@result{} ложь
@end group
@end example
@end defspec

@defmac when condition then-forms@dots{}
Вариант @code{if} где отсутствует ветка @var{else-forms}, и, возможно
присутствие нескольких форм в ветке @var{then-forms}. В частности,

@example
(when @var{condition} @var{a} @var{b} @var{c})
@end example

@noindent
что полностью эквивалентно

@example
(if @var{condition} (progn @var{a} @var{b} @var{c}) nil)
@end example
@end defmac

@defmac unless condition forms@dots{}
Это вариант @code{if} где нет ветки @var{then-form}:

@example
(unless @var{condition} @var{a} @var{b} @var{c})
@end example

@noindent
что полностью эквивалентно

@example
(if @var{condition} nil
   @var{a} @var{b} @var{c})
@end example
@end defmac

@defspec cond clause@dots{}
@code{cond} выбирает между произвольным числом альтернатив (или предложений).
Каждый аргумент @var{clause} в форме @code{cond} является такой альтернативой
и представляет из себя список @sc{car} которого - это  @var{условие};
остальные элементы, если таковые имеются, @var{тело-формы}. Выглядит такое
предложение (альтернатива) следующим образом:

@example
(@var{условие} @var{тело-формы}@dots{})
@end example

@code{cond} проверяет каждую альтернативу в текстовом порядке, путем оценки
@var{условия}.  Если значение @var{условия} устанавленно в не-@code{nil},
предложение считается успешным и @code{cond} оценивает @var{тело-формы} и
возвращает значение последней формы из @var{тела-формы}. Все остальные
альтернативы далее игнорируются.

Если оценивается значение @var{условие} в @code{nil}, альтернатива считается
неподходящей и @code{cond} переходит к следующей альтернативе оценивая уже
её @var{условие}.

Альтернатива также может выглядеть следующим образом:

@example
(@var{условие})
@end example

@noindent
в случае, если @var{условие} при проверки альтернативы оценевается в
не-@code{nil}, форма @code{cond} возвращает значение оценнённое значение
@var{условия}.

Если каждое @var{условие} имеет значение @code{nil} и не отрабатывает ни
единая альтернатива, @code{cond} возвращает @code{nil}.

Следующий пример имеет четыре альтернативы, которые выполняются в зависимости
от того, что из себя представляет значение @code{x}, а именно: число, строку,
буфер или символ:

@example
@group
(cond ((numberp x) x)
      ((stringp x) x)
      ((bufferp x)
       (setq temporary-hack x) ; @r{несколько форм в теле-формы}
       (buffer-name x))        ; @r{одной альтернативы}
      ((symbolp x) (symbol-value x)))
@end group
@end example

Часто требуется оценить последнюю альтернативу, когда ни одна из предыдущих
не была принята.  Для этого используется @code{t} в качестве @var{условия}
последней альтернативы, как здесь: @code{(t @var{body-forms})}.  Форма
@code{t} всегда принимает значение @code{t} и никогда значение @code{nil},
поэтому эта альтернатива выбирается, если до неё доходит очередь @code{cond}.
Например:

@example
@group
(setq a 5)
(cond ((eq a 'hack) 'foo)
      (t "default"))
@result{} "default"
@end group
@end example

@noindent
@code{cond} выражение возвращает @code{foo}, если значение @code{a}
удовлетворяет условию @code{eq} к @code{hack}, и возвращает строку
@code{"default"} в другом случае.
@end defspec

Любая условная конструкция может быть выражена с @code{cond} или @code{if}.
Таким образом, выбор между ними является вопросом стиля. Например:

@example
@group
(if @var{a} @var{b} @var{c})
@equiv{}
(cond (@var{a} @var{b}) (t @var{c}))
@end group
@end example

@node Combining Conditions
@section Конструкции для Комбинирования Услвных Выражений
@cindex combining conditions

  В этом разделе описаны три конструкции, которые часто используются вместе
  с @code{if} и @code{cond}, чтобы выразить сложные условия.  Конструкции
  @code{and} и @code{or} также могут быть использованы по отдельности как
  разновидности нескольких условных конструкций.

@defun not condition
Функция проверяет ложность @var{condition}.  Возвращает @code{t} если
@var{condition} оценивается в @code{nil} и @code{nil} в противном лучае.
Функция @code{not} идентична @code{null}, и мы рекомендуем функцию с именем
@code{null}, когда проверяется значение пустого списка.
@end defun

@defspec and conditions@dots{}
@code{and} проверяет все ли условия @var{conditions} истинны.  Оценивает
@var{conditions} один за другим в текстовом порядке.

Если какой-либо из @var{conditions} вычисляется в @code{nil}, то результат
@code{and} устанавливается в @code{nil} независимо от результата оценки
остальных @var{conditions}; поэтому @code{and} возвращает @code{nil} сразу,
не оценивая оставшиеся условия @var{conditions}.

Если все @var{conditions} оцениваются в не-@code{nil}, то значение последнего
из них становится значением формы @code{and}.  Просто @code{(and)}, без
@var{conditions}, возвращает @code{t}, потому что все @var{conditions}
оценились в не-@code{nil}. (Подумайте об этом, почему это так?)

Вот пример.  Первое условие возвращает целое число 1, которое не является
@code{nil}.  Аналогичным образом, второе условие возвращает целое число 2,
которое не является @code{nil}.  Третье условие @code{nil}, поэтому
оставшееся условие никогда не оценивали.

@example
@group
(and (print 1) (print 2) nil (print 3))
     @print{} 1
     @print{} 2
@result{} nil
@end group
@end example

Вот более реалистичный пример использования @code{and}:

@example
@group
(if (and (consp foo) (eq (car foo) 'x))
    (message "foo список, который начинается с x"))
@end group
@end example

@noindent
Обратите внимание, что @code{(car foo)} не выполняется, если
@code{(consp foo)} возвращает @code{nil}, что позволяет избежать ошибок.

@code{and} выражение может быть написано с использованием выражения @code{if}
или @code{cond}. Вот как:

@example
@group
(and @var{arg1} @var{arg2} @var{arg3})
@equiv{}
(if @var{arg1} (if @var{arg2} @var{arg3}))
@equiv{}
(cond (@var{arg1} (cond (@var{arg2} @var{arg3}))))
@end group
@end example
@end defspec

@defspec or conditions@dots{}
@code{or} специальная форма, в которой проверяется является ли, по крайней
мере одно из условий @var{conditions} истиной.  Оцениваются все условия
@var{conditions} формы один за другим, в текстовом порядке.

Если какое-либо из условий @var{conditions} оценивается в не-@code{nil}, то
результат @code{or} устанавливается в не-@code{nil} и @code{or} сразу
возвращает это значение результатом, не обращая внимания на оставшиеся
условия @var{conditions}.

Если все @var{conditions} оценены в @code{nil}, то @code{or} выражение
возвращает @code{nil}.  Просто @code{(or)}, без условий @var{conditions},
возвращает @code{nil}, это потому, что все @var{conditions} оценились в
@code{nil}.  (Подумайте об этом, почему это так?)

Например, это выражение проверяет удовлетворяет @code{x} @code{eq} к
@code{nil} или целому числу нуль:

@example
(or (eq x nil) (eq x 0))
@end example

Как и @code{and} конструкцию, @code{or} можно записать в терминах
@code{cond}.  Например:

@example
@group
(or @var{arg1} @var{arg2} @var{arg3})
@equiv{}
(cond (@var{arg1})
      (@var{arg2})
      (@var{arg3}))
@end group
@end example

Можно, но не совсем точно, реализовать @code{or} по средствам @code{if}:

@example
@group
(if @var{arg1} @var{arg1}
  (if @var{arg2} @var{arg2}
    @var{arg3}))
@end group
@end example

@noindent
Это не полностью эквивалентно, так как возможно вычисление @var{arg1} или
@var{arg2} дважды.  В противоположность этому,
@code{(or @var{arg1} @var{arg2} @var{arg3})} никогда не оценивает любой
свой аргумент более чем один раз.
@end defspec

@node Pattern-Matching Conditional
@section Шаблон-Соответствие Условию
@cindex pcase
@cindex pattern matching, programming style

Помимо четырех основных условных форм, Emacs Lisp также имеет условную форму
сопоставления с образцом, макрос @code{pcase}, гибрид @code{cond} и
@code{cl-case} (@pxref{Conditionals,,,cl,Common Lisp Extensions}), с помощью
которой, преодолеваются их ограничения и вводится
@dfn{стиль программирования сопоставления с образцом}.  Ограничения, которые
преодолевает @code{pcase}:

@itemize
@item
Форма @code{cond} выбирает среди альтернатив, путем оценки предиката
@var{условия} каждой из своих веток (@pxref{Conditionals}).  Основным
ограничением является то, что эти переменные @var{условия} не доступны
для @var{формы-тела} соответствующей ветки.

Ещё ограничение (скорее неудобство, чем ограничение) заключается в том, что
для проверки ряда @var{условий}, требуется написание много повторяющегося
кода.  (@code{cl-case} решает эти неудобства.)

@item
Макрос @code{cl-case} выбирает среди альтернатив путем оценки равенства
первого аргумента с набором конкретных значений.

Его ограничения в двояко:

@enumerate
@item
Для проверки равенства используется @code{eql}.
@item
Значения должны быть известны и записаны заранее.
@end enumerate

@noindent
Это делает @code{cl-case} непригодным использования со строками или
составными структурами данных (например, списками или векторами).
(@code{cond} не имеет этих ограничений, но у него есть другие, см. выше)
@end itemize

@noindent
Концептуально, @code{pcase} макрос заимствует способ обработки первого
аргумента из @code{cl-case} и способ обработки выбранной ветки @code{cond},
заменяя @var{условие} обобщением проверки на равенство варианта
@dfn{сопоставление шаблону} и добавляя средства, позволяющие кратко выразить
предикат альтернативы и организовать LET-привязку между предикатом и
@var{тела-формы} альтернативы. (ВопросControl474 Баян полный)

Краткое выражение предиката известно как @dfn{шаблон}.  Когда предикат,
вызванный для проверки первого аргумента альтернативы, возвращает
не-@code{nil}, подразумевается, что ``шаблон совпадает со значением''
(или иногда ``значение соответствует шаблону'').

@menu
* The @code{pcase} macro: pcase Macro. Примеры и предостережения.
* Extending @code{pcase}: Extending pcase.  Определение новых видов шаблонов.
* Backquote-Style Patterns: Backquote Patterns.  Сопоставление моделей
                                                 структур.
* Destructuring with pcase Patterns:: Использование шаблонов pcase для
                                      извлечения подполей.
@end menu

@node pcase Macro
@subsection The @code{pcase} macro

Для справки, @xref{Pattern-Matching Conditional}.

@defmac pcase expression &rest clauses
Каждая альтернатива в @var{clauses} имеет вид:
@w{@code{(@var{шаблон} @var{тело-формы}@dots{})}}.

Оценивается @var{expression}, для определения его значения, @var{expval}.
Ищется первый элемент альтернатив в @var{clauses}, значение @var{pattern}
которого соответствует @var{expval} и передаётся управление @var{телу-формы}
подобранной альтернативы.

Если есть совпадение, значением @code{pcase} является значение последней из
@var{тела-формы} подобранной альтернативы.  В противном случае, @code{pcase}
оценивается в @code{nil}.
@end defmac

@cindex pcase pattern
Каждый @var{шаблон} должен быть @dfn{pcase шаблоном}, который может
использовать либо один любой из основных шаблонов, определенных ниже, либо
один из шаблонов, определенных с помощью @code{pcase-defmacro}
(@pxref{Extending pcase}).

Остальная часть этого подраздела описывает различные формы основных шаблонов,
приведены примеры и, в заключении, важные предосторежения по использованию
LET-связывающего механизма, предоставляемый некоторыми формами шаблонов.
Основные шаблоны могут принимать следующие формы:

@table @code

@item _
Соответствие любому @var{expval}.
Это также известно как @dfn{don't care} или @dfn{wildcard}.(ВопросControl524)

@item '@var{val}
Соответствие, если @var{expval} равен @var{val}. Сравнение производится
с использованием @code{equal} (@pxref{Equality Predicates}).

@item @var{keyword}
@itemx @var{integer}
@itemx @var{string}
Соответствие, если @var{expval} равен буквально объекту.  Это особый случай
@code{'@var{val}}, описанный выше, потому, сравнивается буквально объекты
заключённые в кавычки(ВопросControl535 ,баян полнейший).

@item @var{symbol}
Соответствует любому @var{expval}, и к тому же, LET связывает @var{symbol}
с @var{expval}, таким образом, что эта привязка доступна @var{телу-формы}
(@pxref{Dynamic Binding}).

Если @var{symbol} является частью последовательности шаблона @var{seqpat}
(например, с помощью @code{and}, ниже), связывание также доступно в части
@var{seqpat} после появления @var{symbol}.  Такое использование имеет
некоторые предостережения, смотреть @ref{pcase-symbol-caveats,,caveats}.

Два символа, которых здесь нужно избегать это @code{t}, который ведет себя
как @code{_} (выше) и является устаревшим, и @code{nil}, при использовании
которого сигнализируется ошибка.  Кроме того, не имеет смысла связывать
символы ключевых слов (@pxref{Constant Variables}).

@item (pred @var{function})
Соответствует, если предикат @var{function} возпращает не-@code{nil} при
вызове с @var{expval}.  Предикат @var{function} может иметь одну из
следующих форм:

@table @asis
@item именованная функция (символ)
Вызов именованной функции с одним аргументом, @var{expval}.

Пример: @code{integerp}

@item лямбда-выражение
Вызов анонимной функции с одним аргументом,
@var{expval} (@pxref{Lambda Expressions}).

Пример: @code{(lambda (n) (= 42 n))}

@item вызов функции с @var{n} аргументами
Вызов функции (первый элемент вызова функции) с аргументами @var{n}
(другие элементы) и дополнительным @var{n}+1 аргументом, @var{expval}.

Пример: @code{(= 42)}@*
В этом примере функция равна @code{=}, @var{n} равен единице, а фактический
вызов функции это: @w{@code{(= 42 @var{expval})}}.
@end table

@item (app @var{функция} @var{шаблон})
Соответствует, когда вызов функции @var{функция}, возвращает значение
@var{expval}, которое соответствует @var{шаблон}.
@var{функция} может принимать одну из форм, описанных для @code{pred}, выше.
В отличии от @code{pred}, @code{app} проверяет результат с @var{шаблоном}, а
не с логическим значением истинности.

@item (guard @var{логическое-выражение})
Соответствует, когда @var{логическое-выражение} устанвленно в не-@code{nil}
значение.

@item (let @var{шаблон} @var{expr})
Соответствует, когда при оценки @var{expr}, чтобы получить @var{exprval},
@var{exprval} соответствует @var{шаблон}.  (Это вызвано тем, что @code{let}
может связывать @var{шаблон} со значением символа @var{symbol}.)
(ВопросControl593 баян всем баянам)
@end table

@cindex sequencing pattern
@dfn{последовательность шаблонов} (известно как @var{seqpat}) представляет
собой образец, который обрабатывает свои аргументы суб-шаблонов в
последовательности.  Есть два для @code{pcase}: @code{and} и @code{or}.
Ведут себя аналогично специальным формам, разделяя их имена
(@pxref{Combining Conditions}), но вместо обработки значений, они
обрабатывают суб-шаблоны.

@table @code
@item (and @var{pattern1}@dots{})
Попытка сопоставить @var{pattern1}@dots{} по порядку, пока один из них не
совпадает.  В этом случае, @code{and} также не совпадает, а остальные
подшаблоны не проверяются.  Если все суб-шаблоны совпадают, @code{and}
считается совпавшим.

@item (or @var{pattern1} @var{pattern2}@dots{})
Попытка сопоставить @var{pattern1}, @var{pattern2}, @dots{} по порядку, пока
один из них не совпаст.  В этом случае, @code{or}, также соответствует, а
остальные подшаблонам бльше не проверяются.  (Обратите внимание, что должно
быть по крайней мере, два суб-шаблона.  Простой
@w{@code{(or @var{pattern1})}} сигнализирует об ошибке.)
@c Вопрос: Правильно ли это и предназначен?
@c        Есть ли исключения, квалификация?
@c        (Btw, ``Пожалуйста, избегайте его'' плохое сообщение об ошибке.)

Для того, чтобы представить согласованную среду (@pxref{Intro Eval}) к
@var{body-forms} (что позволяет избежать ошибки оценки при совпадении), если
какой-либо из подшаблонов LET, связывает набор символов, все они
@emph{должны} связывать один и тот же набор символов.
@end table

@anchor{pcase-example-0}
@subheading Пример: Превосходство Над @code{cl-case}

Вот пример, который почёркивает некоторые преимущества @code{pcase}
перед @code{cl-case} (@pxref{Conditionals,,,cl,Common Lisp Extensions}).

@example
@group
(pcase (get-return-code x)
  ;; string
  ((and (pred stringp) msg)
   (message "%s" msg))
@end group
@group
  ;; символы
  ('success       (message "Готово!"))
  ('would-block   (message "К сожалению, не может быть выполнено сейчас"))
  ('read-only     (message "Shmliblick только для чтения"))
  ('access-denied (message "У вас нет необходимых прав"))
@end group
@group
  ;; по умолчанию
  (code           (message "Неизвестный код возврата %S")))
@end group
@end example

@noindent
С @code{cl-case}, требуется явно объявить локальную переменную @code{code}
для хранения возвращаемого значения @code{get-return-code}.  Также
@code{cl-case} трудно использовать со строками, поскольку используется
@code{eql} для сравнения.

@anchor{pcase-example-1}
@subheading Example: Using @code{and}

Общей идиомой, является написание шаблона, начиная с @code{and}, с одним или
несколькими @var{symbol} суб-шаблонами, обеспечивающими привязку к
последующим суб-шаблонам (а также к формам тела).  Например, следующий шаблон
соответствует однозначным целым числам.

@example
@group
(and
  (pred integerp)
  n                     ; @r{связывают @code{n} с @var{expval}}
  (guard (<= -9 n 9)))
@end group
@end example

@noindent
Во-первых, @code{pred} соответствует, если @w{@code{(integerp @var{expval})}}
принимает значение не-@code{nil}.  Далее, @code{n} является шаблоном
@var{symbol}, который соответствует чему угодно и привязывает @code{n} к
@var{expval}.  Наконец, @code{guard} соответствует, если логическое выражение
@w{@code{(<= -9 n 9)}} (обратите внимание на ссылку на @code{n}) оценивается
в не-@code{nil}. Если все эти суб-шаблоны совпадают, @code{and}
соответствует.

@anchor{pcase-example-2}
@subheading Пример: Переформулировка для @code{pcase}

Вот еще один пример, который показывает, как переформулировать простую задачу
сопостовления с её традиционной реализацией (функция @code{grok/traditional})
на задачу с использованием @code{pcase} (функции @code{grok/pcase}).  Строка
документации для обеих этих функций: ``Если OBJ является строка вида
"key:NUMBER", возвращается NUMBER (строка). В противном случае возвращается
список ("149" по умолчанию).''.  Во-первых, традиционная реализация
(@pxref{Regular Expressions}):

@example
@group
(defun grok/traditional (obj)
  (if (and (stringp obj)
           (string-match "^key:\\([[:digit:]]+\\)$" obj))
      (match-string 1 obj)
    (list "149" 'default)))
@end group

@group
(grok/traditional "key:0")   @result{} "0"
(grok/traditional "key:149") @result{} "149"
(grok/traditional 'monolith) @result{} ("149" default)
@end group
@end example

@noindent
Переформулировка демонстрирует @var{symbol} связывания, а также @code{or},
@code{and}, @code{pred}, @code{app} и @code{let}.

@example
@group
(defun grok/pcase (obj)
  (pcase obj
    ((or                                     ; @r{строка 1}
      (and                                   ; @r{строка 2}
       (pred stringp)                        ; @r{строка 3}
       (pred (string-match                   ; @r{строка 4}
              "^key:\\([[:digit:]]+\\)$"))   ; @r{строка 5}
       (app (match-string 1)                 ; @r{строка 6}
            val))                            ; @r{строка 7}
      (let val (list "149" 'default)))       ; @r{строка 8}
     val)))                                  ; @r{строка 9}
@end group

@group
(grok/pcase "key:0")   @result{} "0"
(grok/pcase "key:149") @result{} "149"
(grok/pcase 'monolith) @result{} ("149" по умолчанию)
@end group
@end example

@noindent
Основная часть @code{grok/pcase} - это одна альтернатива формы @code{pcase},
шаблоны на строках 1-8, (единственная) основная форма в строке 9.  Шаблон
@code{or}, который пытается сопоставить в свою очередь, подшаблоны
аргументов, первым @code{and} (строки 2-7), а затем @code{let} (строка 8),
пока один из них не совпадёт.

Как и в предыдущем примере (@pxref{pcase-example-1,,Example 1}), @code{and}
начинается с @code{pred} суб-шаблоном, чтобы обеспечить следующие подшаблоны
работать с объектом правильного типа (строкой, в данном случае).  Если
@w{@code{(stringp @var{expval})}} возвращает @code{nil}, @code{pred} терпит
неудачу, и, таким образом, @code{and} также терпит неудачу.

Следующая @code{pred} (строки 4-5) оценивает
@w{@code{(string-match RX @var{expval})}} и соответствует, если результат
установлен в не-@code{nil}, что означает, что @var{expval} имеет нужную
форму: @code{key:NUMBER}.  Опять же, если это невозможно, @code{pred}
терпит неудачу как и @code{and}.

И наконец (в этой серии @code{and} подшаблонов), @code{app} оценивает
@w{@code{(match-string 1 @var{expval})}} (строка 6), чтобы получить
@var{tmp} временное значение (то есть, ``NUMBER'' подстроку) и пытается
соответствовать @var{tmp} шаблону @code{val} (строка 7). Поскольку это
шаблон @var{symbol}, он соответствует безоговорочно и дополнительно
связывает @code{val} с @var{tmp}.

Теперь, когда @code{app} совпало, все @code{and} суб-шаблоны совпали, и
поэтому @code{and} совпадает.  Точно так же, как только @code{and} совпало,
@code{or} не проводит попытки сопоставления суб-шаблона @code{let}
(строка 8).

Давайте рассмотрим ситуацию, когда @code{obj} не является строкой, или это
строка неправильной  формы.  В этом случае, одна из @code{pred} (строки 3-5)
не совпадает, таким образом, @code{and} (строка 2) не совпадает, таким
образом, @code{or} (линия 1) переходит к сопоставлению под-шаблона @code{let}
(строка 8).

Во-первых, @code{let} оценивает @w{@code{(list "149" 'default)}} чтобы
получить @w{@code{("149" default)}}, в @var{exprval}, а затем пытается
сопоставить @var{exprval} с шаблоном @code{val}.  Поскольку это шаблон
@var{symbol}, он соответствует безоговорочно и дополнительно связывает
@code{val} с @var{exprval}. Теперь, когда @code{let} совпало, @code{or}
совпадает.

Обратите внимание, как оба @code{and} и @code{let} подшаблоны оканчиваются
одинаковым образом: пытаясь (всегда успешно), сопоставить @var{symbol} с
@code{val}, в процессе связывания @code{val}.  Таким образом, @code{or}
всегда соответствует и управления всегда переходит к форме тела (строка 9).
Поскольук это последняя форма тела в успешно согласованной альтернативе
@code{pcase}, это значение @code{pcase} также возвращаемое значение
@code{grok/pcase} (@pxref{What Is a Function}).

@anchor{pcase-symbol-caveats}
@subheading Предостережения для @var{символа} в Последовательностях Шаблонов

В предыдущих примерах, все последовательности шаблонов, каким-то образом
включают @var{symbol} суб-шаблон в некотором роде.  Вот некоторые важные
детали при использовании.

@enumerate
@item Когда @var{symbol} встречается более чем один раз в @var{seqpat},
вторые и последующие появления не расширяются для повторного связывания, но
расширяются для теста равенства с помощью @code{eq}.

Следующий пример показывает форму @code{pcase} с двумя пунктами и двумя
@var{seqpat}, A и B.  И А и В в первую очередь проверяются на соответствие
@var{expval} (с использованием @code{pred}), а затем связывают символы к
@code{car} и @code{cdr} из @var{expval} (с использованием @code{app} для
каждого). (ВопросControl806)

Для А, так как символ @code{st} упоминается дважды, второе упоминание
становится проверка на равенство с использованием @code{eq}.  С другой
стороны, B использует два отдельных символа, @code{s1} и @code{s2}, оба из
которых устанавлмваются независимыми привязками.

@example
@group
(defun grok (object)
  (pcase object
    ((and (pred consp)        ; seqpat A
          (app car st)        ; первое упоминание: st
          (app cdr st))       ; второе упоминание: st
     (list 'eq st))
@end group
@group
    ((and (pred consp)        ; seqpat B
          (app car s1)        ; первое упоминание: s1
          (app cdr s2))       ; первое упоминание: s2
     (list 'not-eq s1 s2))))
@end group

@group
(let ((s "yow!"))
  (grok (cons s s)))      @result{} (eq "yow!")
(grok (cons "yo!" "yo!")) @result{} (not-eq "yo!" "yo!")
(grok '(4 2))             @result{} (not-eq 4 (2))
@end group
@end example

@item Побочное действия кода на который ссылается @var{symbol} не определено.
Избегайте этого.  Например, вот две аналогичные функции.
Оба используют @code{and}, @var{symbol} и @code{guard}:

@example
@group
(defun square-double-digit-p/CLEAN (integer)
  (pcase (* integer integer)
    ((and n (guard (< 9 n 100))) (list 'yes n))
    (sorry (list 'no sorry))))

(square-double-digit-p/CLEAN 9) @result{} (да 81)
(square-double-digit-p/CLEAN 3) @result{} (не 9)
@end group

@group
(defun square-double-digit-p/MAYBE (integer)
  (pcase (* integer integer)
    ((and n (guard (< 9 (incf n) 100))) (list 'yes n))
    (sorry (list 'no sorry))))

(square-double-digit-p/MAYBE 9) @result{} (да 81)
(square-double-digit-p/MAYBE 3) @result{} (да 9)  ; @r{НЕПРАВИЛЬНО!}
@end group
@end example

@noindent
Разница заключается в @var{boolean-expression} в @code{guard}: @code{CLEAN}
ссылки @code{n} просто и непосредственно, в то время как ссылки @code{MAYBE}
@code{n} с побочным эффектом, в выражении @code{(incf n)}.  Когда
@code{integer} 3, вот что происходит:

@itemize
@item Первый @code{n} связывает его с @var{expval}, то есть, результат
вычисления @code{(* 3 3)}, или 9.

@item @var{boolean-expression} is evaluated:

@example
@group
start:   (< 9 (incf n)        100)
becomes: (< 9 (setq n (1+ n)) 100)
becomes: (< 9 (setq n (1+ 9)) 100)
@end group
@group
becomes: (< 9 (setq n 10)     100)
                                   ; @r{Побочный эффект здесь!}
becomes: (< 9       n         100) ; @r{@code{n} теперь связан с 10}
becomes: (< 9      10         100)
becomes: t
@end group
@end example

@item Так как результат оценки @code{guard} соответствия устанавливатся в
не-@code{nil}, управление переходит к формам тела @code{and} соответствия.
@end itemize

@noindent
Помимо математической некорректности, утверждая, что 9 является двузначным
числом, есть еще одна проблема, с @code{MAYBE}.  Основная форма вычисляется
ещё @code{n} раз, пока мы не увидим обновленное значение---10---ки для всех.
Что случилось?

Подводя итог, лучше, целиком избегать побочных ссылок @var{symbol} на
шаблоны, а не только в @var{boolean-expression} (in @code{guard}), но и в
@var{expr} (in @code{let}) и @var{function} (в @code{pred} и @code{app}).

@item При соответствиие, форма тела альтернативы может ссылаться на набор
символов шаблона let-привязки.  Когда @var{seqpat} обрабатывает @code{and},
это множество является объединением всех символов в каждой из его
суб-шаблонов let-привязки.  Это имеет смысл, потому что, @code{and} для
соответствия требует, чтобы все суб-шаблоны совпали.

Когда @var{seqpat} пользуется @code{or}, дело обстоит иначе: @code{or}
отработает на первом суб-шаблоне, который соответствует; остальная часть
sub-шаблонов игнорируются.  Это не имеет никакого смысла для каждого
sub-шаблона чтобы определять let-привязку другого набора символов, потому
что формы тела не имеют никакого способа определить, какой sub-шаблон
отработал соответствию и выбирать среди различных наборов.  Например,
следующее недействительно:

@example
@group
(pcase (read-number "Введите целое число: ")
  ((or (and (pred evenp)
            e-num)      ; @r{связывают @code{e-num} с @var{expval}}
       o-num)           ; @r{связывают @code{o-num} с @var{expval}}
   (list e-num o-num)))
@end group

@group
Введите целое число: 42
@error{} Значение символа как переменный, является недействительным: o-num
@end group
@group
Введите целое число: 149
@error{} значение символа как переменный, является недействительным: e-num
@end group
@end example

@noindent
Оценка формы @w{@code{(list e-num o-num)}} сигнализирует об ошибке.  Для
того, чтобы различать подшаблоны, вы можете использовать другой символ,
идентичный по имени во всех подшаблонах но различающийся по значению.
Переделывая приведенный выше пример:

@example
@group
(pcase (read-number "Введите целое число: ")
  ((and num                                ; @r{строка 1}
        (or (and (pred evenp)              ; @r{строка 2}
                 (let spin 'even))         ; @r{строка 3}
            (let spin 'odd)))              ; @r{строка 4}
   (list spin num)))                       ; @r{строка 5}
@end group

@group
Введите целое число: 42
@result{} (even 42)
@end group
@group
Введите целое число: 149
@result{} (odd 149)
@end group
@end example

@noindent
Строка 1 ``фактический вывод'' @var{expval} связывает с @code{and} и
@var{symbol} (в данном случае, @code{num}).  В строке 2, @code{or} вначале
отрабатывает таким же образом, как и раньше, но вместо того, чтобы связывать
различные символы, использует дважды @code{let} (строки 3-4), чтобы связать
один и тот же символ @code{spin} в обоих подшаблонах.  Значение @code{spin}
различает суб-шаблоны. Тело формы ссылается на оба символа (строка 5).
@end enumerate

@node Extending pcase
@subsection Расширение @code{pcase}
@cindex pcase, defining new kinds of patterns

Макрос @code{pcase} поддерживает несколько видов шаблонов
(@pxref{Pattern-Matching Conditional}).
Можно добавить поддержку других видов шаблонов используя
@code{pcase-defmacro} макрос.

@defmac pcase-defmacro name args [doc] &rest body
Определить новый вид шаблона для @code{pcase}, который будет вызыватся формой
@w{@code{(@var{name} @var{actual-args})}}.
@code{pcase} макрос это вызов функции, которая оценивает @var{body}, чтобы
переписать Вызванный шаблон в какой-то другой, в среде, где @var{args}
связан с @var{actual-args}.

Кроме того, организовывается отображение @var{doc} вместе с @code{pcase} в
строку документации.  По соглашению, для @var{doc} требуется использовать
@code{EXPVAL} обозначения результата оценки @var{expression} (первый
аргумент в @code{pcase}).
@end defmac

@noindent
Как правило, @var{body} переписывает вызванный шаблон, для использования
более простых шаблонов.  Хотя все шаблоны в конечном счете сводятся к
основному шаблону, нельзя использовать основные модели @code{body} сразу.
Следующий пример определяет два шаблона, с именами @code{less-than} и
@code{integer-less-than}.

@example
@group
(pcase-defmacro less-than (n)
  "Matches if EXPVAL is a number less than N."
  `(pred (> ,n)))
@end group

@group
(pcase-defmacro integer-less-than (n)
  "Matches if EXPVAL is an integer less than N."
  `(and (pred integerp)
        (less-than ,n)))
@end group
@end example

@noindent
Обратите внимание, что в строке документации @var{args} (в данном случае
только один: @code{n}) упоменается обычным способом, а также упомянуто
соглашение @code{EXPVAL}.  Первый переписывают (т.е. @var{body} для
@code{less-than}) использует один основной шаблон с: @code{pred}.  Второй
использует два основных шаблона с: @code{and} и @code{pred}, а также вновь
определенный шаблон @code{less-than}.  Оба используют единую конструкцию
кавычки (@pxref{Backquote}).

@node Backquote Patterns
@subsection Шаблоны в Обратных Кавычках
@cindex backquote-style patterns
@cindex matching, structural
@cindex structural matching

В этом подразделе описаны @dfn{шаблоны в обратных кавычках}, набор шаблонов,
облегчающих структурное сопоставление. Для примера,
@pxref{Pattern-Matching Conditional}.

Шаблоны в обратных кавычках - мощный набор @code{pcase} расширений шаблонов
(созданных с помощью @code{pcase-defmacro}), которые позволяют легко
сопоставить @var{expval} со спецификациями его @emph{структуры}.

Например, чтобы соответствовать @var{expval}, который должен быть списком из
двух элементов, первый элемент которого представляет собой определенную
строку, а второй элемент является любое значение, вы можете написать
основной шаблон:

@example
@group
(and (pred listp)
     ls
@end group
@group
     (guard (= 2 (length ls)))
     (guard (string= "first" (car ls)))
     (let second-elem (cadr ls)))
@end group
@end example

@noindent
или вы можете написать эквивалентный шаблон в стиле обратных кавычек:

@example
`("first" ,second-elem)
@end example

@noindent
Шаблон в стиле обратных кавычек более краткий, напоминает структуру
@var{expval}, и избегает привязки @code{ls}.

Стиль шаблона в обратных кавычках имеет вид @code{`@var{qpat}} где
@var{qpat} может иметь следующие формы:

@table @code

@item (@var{qpat1} . @var{qpat2})
Срабатывает, если @var{expval} cons-ячейки, @code{car} которой соответствует
@var{qpat1} и чей @code{cdr} соответствует @var{qpat2}.  Это легко обобщается
на списки, как в  @w{@code{(@var{qpat1} @var{qpat2} @dots{})}}.

@item [@var{qpat1} @var{qpat2} @dots{} @var{qpatm}]
Срабатывает, если @var{expval} является вектором длиной @var{m}, чьи элементы
соответствуют @code{0}..@code{(@var{m}-1)} @var{qpat1}, @var{qpat2} @dots{} @var{qpatm}, соответственно.

@item @var{symbol}
@itemx @var{keyword}
@itemx @var{integer}
@itemx @var{string}
Совпадение, если соответствующий элемент @var{expval} удовлетворяет
@code{equal} к указанному буквальному объекту.
Следует отметить, что, помимо @var{symbol}, это тот же самый набор
самостоятельно процитированных литералов объектов, которые являются
приемлемыми в качестве основного шаблона.

@item ,@var{pattern}
Совпадение, если соответствующий элемент @var{expval} соответствует
@var{pattern}.  Обратите внимание, что @var{pattern} является любым видом,
поддерживаемым @code{pcase}.  (В приведенном выше примере, @code{second-elem}
является основным @var{symbol} шаблона, поэтому он соответствует чему угодно,
и let-связанным с @code{second-elem}.)
@end table

@dfn{Связанный элемент} представляет собой часть @var{expval}, которая
находится в той же позиции, что и в структурной позиции @var{qpat} в шаблоне
в стиле обратных кавычек.  (В приведенном выше примере, соответствующий
элемент @code{second-elem} является вторым элементом @var{expval}.)

Ниже приведен пример использования @code{pcase} реализации простого
интерпретатора для небольшого языка выражений (заметим, что это требует
лексического связывания для лямбда-выражения в альтернативе @code{fn}, чтобы
должным образом захватить @code{body} и @code{arg} (@pxref{Lexical Binding}):

@example
@group
(defun evaluate (form env)
  (pcase form
    (`(add ,x ,y)       (+ (evaluate x env)
                           (evaluate y env)))
@end group
@group
    (`(call ,fun ,arg)  (funcall (evaluate fun env)
                                 (evaluate arg env)))
    (`(fn ,arg ,body)   (lambda (val)
                          (evaluate body (cons (cons arg val)
                                               env))))
@end group
@group
    ((pred numberp)     form)
    ((pred symbolp)     (cdr (assq form env)))
    (_                  (error "Syntax error: %S" form))))
@end group
@end example

@noindent
Первые три альтернативы используют шаблоны в обратных кавычках.
@code{`(add ,x ,y)} это шаблон, который проверяет, @code{form} как список из
трех элементов, начиная с буквального символа @code{add}, затем извлекает
второй и третий элементы и связывают их с символами @code{x} и @code{y},
соответственно.  Тело альтернативы оценивает @code{x} и @code{y} и добавляет
результаты.  Аналогичным образом, @code{call} альтернатива реализует функцию
вызова, а условие реализует @code{fn} анонимное определение функции.

Остальные альтернативы используют основные шаблоны.  @code{(pred numberp)}
совпадает, если @code{form} является числом.  При соответствии, оценивается
его тело формы.  @code{(pred symbolp)} совпадает, если @code{form} является
символом.  При совпадении с @code{env}, тело формы возвращает его ассоциацию.
Наконец, @code{_} это универсальный шаблон, который соответствует чему
угодно, поэтому подходит для представления синтаксических ошибок.

Вот некоторые примеры программ в этом небольшом языке, в том числе их
результаты оценки:

@example
(evaluate '(add 1 2) nil)                 @result{} 3
(evaluate '(add x y) '((x . 1) (y . 2)))  @result{} 3
(evaluate '(call (fn x (add 1 x)) 2) nil) @result{} 3
(evaluate '(sub 1 2) nil)                 @result{} error
@end example

@node Destructuring with pcase Patterns
@subsection Деструктуризация Шаблонов @code{pcase}
@cindex destructuring with pcase patterns

@code{pcase} с помощью шаблоов выражает не только условие о форме объектов,
которые они могут совпадать, но они также может извлечь дополнительные поля
этих объектов.  Например, мы можем извлечь 2 элемента из списка, который
является значением переменной @code{my-list} со следующим кодом:

@example
  (pcase my-list
    (`(add ,x ,y)  (message "Contains %S and %S" x y)))
@end example

Это позволяет не только извлечь @code{x} и @code{y}, но будет дополнительно
проверенно, что @code{my-list} представляет собой список, содержащий ровно
3 элемента и чей первый элемент является символом @code{add}.  Если
какое-либо из этих условий не выполняется, @code{pcase} немедленно
возвращает @code{nil} без вызова @code{message}.

Извлечение нескольких значений, хранящихся в объекте известно как
@dfn{деструктуризация}.  Использование шаблонов с @code{pcase} позволяет
выполнять @dfn{деструктуризационную привязку}, похожую на локальное
связывание (@pxref{Local Variables}), но обрабатывает несколько значений
элементов в переменной, извлекая эти значения из объекта совместимой
структуры.

Макросы, описанные в этом разделе, используют @code{pcase} с шаблонами для
выполнения деструктуризационного связывания.  Чтобы это сработало, объект
должен иметь совместимую структуру, то есть соответствовать шаблону, что в
итоге позволяет извлекать подполя объекта.  Например:

@example
  (pcase-let ((`(add ,x ,y) my-list))
    (message "Contains %S and %S" x y))
@end example

@noindent
происходит то же самое, как и в предыдущем примере, за исключением того, что
непосредственно производится попытка извлечь @code{x} и @code{y} из
@code{my-list} без предварительной проверки, если @code{my-list} список,
который имеет нужное количество элементов и имеет @code{add} в качестве
первого элемента.  Точное поведение, когда объект фактически не
соответствует шаблону не определен, хотя тело не будет молча пропущено:
сигнализируется либо ошибка или тело отработает с некоторыми переменными,
потенциально связанными с произвольными значениями, например @code{nil}.

Шаблоны в pcase, которые полезны для деструктурированных привязок, обычно
записываются в стиле @ref{Backquote Patterns}, поскольку могут выразить
специфическую структуру объектов, которым будут соответствовать.

В качестве альтернативного средства для деструктурированного связывания,
смотреть @ref{seq-let}.

@defmac pcase-let bindings body@dots{}
Выполняется деструктуризированное связывание переменных в соответствии с
@var{bindings}, а затем оценивается @var{body}.

@var{bindings} представляет собой список привязок вида
@w{@code{(@var{pattern} @var{exp})}}, где @var{exp} является выражением
для оценки и @var{pattern} является шаблоном @code{pcase}.

Все @var{exp} вычисляются в первую очередь, после чего они сопоставляются
с их соответствующими @var{pattern}, вводя новые привязки переменных,
которые затем могут быть использованы внутри @var{body}.  Cвязывание
переменных производится путём деструткризированной привязки элементов шаблона
@var{pattern} к значениям соответствующих элементов оцениваемого @var{exp}.
@end defmac

@defmac pcase-let* bindings body@dots{}
Выполняется деструктуризированное связывание переменных в соответствии с
@var{bindings}, а затем оценивается @var{body}.

@var{bindings} представляет собой список привязок вида
@code{(@var{pattern} @var{exp})}, где @var{exp} является выражением для
оценки и @var{pattern} является шаблоном @code{pcase}.  Связывание переменных
производится путём деструктуризированного связывания элементов @var{pattern}
к значениям соответствующих элементов оцениваемого @var{exp}.

В отличие от @code{pcase-let} и так же, как @code{let*}, каждое @var{exp}
сравнивается с соответствующим ему шаблону @var{pattern} перед обработкой
следующей привязки элемента @var{bindings}, поэтому привязки переменных,
введенные в каждой одной привязки @var{bindings} доступны @var{exp}s 
привязки @var{bindings} в дополнение доступности в теле @var{body}.
@end defmac

@defmac pcase-dolist (pattern list) body@dots{}
Выполняет тело @var{body} один раз для каждого элемента списка @var{list},
на каждой итерации, выполняя деструтурирующее связывания переменных
шаблона @var{pattern} к значениям соответствующих подполей элемента списка
@var{list}.  Привязка выполняются как бы и по @code{pcase-let}.  Когда
шаблон @var{pattern} является простой переменной, это в конечном итоге
эквивалентно @code{dolist} (@pxref{Iteration}).
@end defmac


@node Iteration
@section Итерация
@cindex iteration
@cindex recursion
@cindex forms, iteration

  Итерация означает повторное выполнение части программы.  Например, нужно
  повторить некоторые вычисления один раз для каждого элемента списка или
  один раз для каждого целого числа от 0 до @var{n}.  Сделать это в Emacs
  Lisp можно используя специальную форму @code{while}:

@defspec while condition forms@dots{}
Выражение @code{while} сначала вычисляет состояния @var{condition}.  Если
установленно в не-@code{nil}, оценивается тело формы @var{forms} в текстовом
порядке.  Затем переоценивает состояние @var{condition}, и если оно снова
установлено в не-@code{nil}, снова оценивается тело формы @var{forms}.  Этот
процесс повторяется до тех пор, состояние @var{condition} будет установлено в
@code{nil}.

Нет ограничений на количество итераций, которые могут произойти.  Цикл будет
продолжаться до тех пор, пока либо состояние @var{condition} не будет
установлено в @code{nil} либо не произойдёт выход @code{throw} из него
(@pxref{Nonlocal Exits}).

Оценка формы @code{while} всегда @code{nil}.

@example
@group
(setq num 0)
     @result{} 0
@end group
@group
(while (< num 4)
  (princ (format "Iteration %d." num))
  (setq num (1+ num)))
     @print{} Iteration 0.
     @print{} Iteration 1.
     @print{} Iteration 2.
     @print{} Iteration 3.
     @result{} nil
@end group
@end example

Для реализации выполнения инструкций в итерации цикла до проверки состояния,
поместите инструкции в форму @code{progn} в качестве первого аргумента
@code{while}, как показано здесь:

@example
@group
(while (progn
         (forward-line 1)
         (not (looking-at "^$"))))
@end group
@end example

@noindent
Здесь точка перемещается вперед на одну строку и движется по строке до тех
пор, пока не достигнет пустой строки.   Особенность такого подхода в том, что
форма @code{while} не имеет тела инструкции, только инструкцию состояния
(которая кроме проверки, также перемещает точку).
@end defspec

  @code{dolist} и @code{dotimes} макросы обеспечивают удобный способ, чтобы
  написать два общих вида цикла.

@defmac dolist (var list [result]) body@dots{}
Конструкция выполняет тело формы @var{body}, один раз для каждого элемента
списка @var{list}, локально связывая переменную @var{var} для хранения
текущего элемента.  Затем возвращает значение оценки переменной @var{result}
или @code{nil}, если @var{result} не задано.  Например, вот как вы можете
использовать @code{dolist} для определения функции @code{reverse}:

@example
(defun reverse (list)
  (let (value)
    (dolist (elt list value)
      (setq value (cons elt value)))))
@end example
@end defmac

@defmac dotimes (var count [result]) body@dots{}
Конструкция оценивает тело формы @var{body}, один раз для каждого целого
числа, от 0 (включительно) до @var{count} (исключительно), связывая
переменную @var{var} с целым числом текущей итерации.  Затем возвращает
значение оценки @var{result} или @code{nil}, если @var{result} опущен.
Ниже приведен пример использования @code{dotimes} сделать что-то 100 раз:

@example
(dotimes (i 100)
  (insert "Я не буду выполнять абсурдные приказы\n"))
@end example
@end defmac

@node Generators
@section Генераторы
@cindex generators

  @dfn{Генератор} представляет из себя функцию, которая производит
  потенциально бесконечный поток выполнения.  Каждый раз, когда функция
  производит значение, приостанавливается и ждет вызывающего абонента для
  запроса следующего значения. (ВопросControl1352)

@defmac iter-defun name args [doc] [declare] [interactive] body@dots{}
@code{iter-defun} определяет функцию генератора.  Функция генератора имеет
сигнатуру нормальной функции, но работает по-другому.  Вместо выполнения
@var{body} при вызове функции генератора, возвращается объект итератора.
Этот итератор запускает @var{body} для генерации значений, выдачи значений и
пауз, в местах появления @code{iter-yield} или @code{iter-yield-from}.  Когда
@var{body} возвращается, как правило, @code{iter-next} сигнализирует
@code{iter-end-of-sequence} с @var{body} результатом в качестве данных
состояния.

Любой вид кода Lisp действует внутри @var{body}, но @code{iter-yield} и
@code{iter-yield-from} не могут появляться внутри формы
@code{unwind-protect}.

@end defmac

@defmac iter-lambda args [doc] [interactive] body@dots{}
@code{iter-lambda} создаёт безымянную функцию генератора, которая работает
точно так же, как функции генератора созданная @code{iter-defun}.
@end defmac

@defmac iter-yield value
Когда появляется внутри функции генератора, @code{iter-yield} указывает на
то, что текущий итератор должен сделать паузу и вернуть @var{value} из
@code{iter-next}.  @code{iter-yield} принимает значение параметра
@code{value} следующего вызова @code{iter-next}.
@end defmac

@defmac iter-yield-from iterator
@code{iter-yield-from} дает все значения, которые @var{iterator} производит
и определяет этой функции @var{iterator} когда генератор возвращается в
нормальном режиме.  Пока существует контроль, @var{iterator} принимает
значения, отправленные итератору с помощью @code{iter-next}.
@end defmac

  Для того, чтобы использовать функцию генератора, сначала требуется вызвать
  её как обычно, создав объект @dfn{iterator}.  Итератор - это конкретный
  экземпляр генератора.  Затем используется @code{iter-next} для извлечения
  значений из этого итератора.  Когда больше нет значений, чтобы получить из
  итератора, @code{iter-next} используется состояние
  @code{iter-end-of-sequence} с конечным значением итератора.

Важно отметить, что тело функции генератора выполняется только внутри вызова
@code{iter-next}.  Вызов функции, определенной с помощью @code{iter-defun}
создаёт итератор; нужно управлять этим итератором с помощью @code{iter-next}
для получения чего-нибудь полезного.  Каждый вызов функции генератора
производит @emph{разные} итераторы, каждый со своим собственным состоянием.

@defun iter-next iterator value
Получение следующего значения из @var{iterator}.  Если нет больше значений,
которые требуется сгенерировать (поскольку @var{iterator} вернулас функци.
генератора), @code{iter-next} сигнализирует состояние
@code{iter-end-of-sequence}; значение данных, связанное с этим условием
является значением, с которым @var{iterator} вернула функция генератора.

@var{value} отправляется в итератор и становится значением, которое
@code{iter-yield} оценивает.  @var{value} игнорируется для первого вызова
@code{iter-next} данного итератора, так как в начале функция генератора
@var{iterator}, функция генератор не оценивает какую-либо форму
@code{iter-yield}. (ВопросControl1413)
@end defun

@defun iter-close iterator
Если @var{iterator} подвешен внутри @code{unwind-protect}'s @code{bodyform} и
становится недоступным, Emacs в конечном итоге запустит UNWIND обработчиков
после сбора мусора прохода.  (Обратите внимание, что @code{iter-yield}
не допускается внутри @code{unwind-protect}'s @code{unwindforms}.).  Для
гарантии запуска этих обработчиков, используйте @code{iter-close}.
@end defun

Для облегчения работы с итераторами предусмотрены некоторые удобные функции:

@defmac iter-do (var iterator) body @dots{}
Оценивается тело @var{body} с переменной @var{var}, связанной с каждым
значением, которое @var{iterator} производит.
@end defmac

Common Lisp объект цикла также содержит функции для работы с итераторами.
@xref{Loop Facility,,,cl,Common Lisp Extensions}.

Следующий фрагмент кода демонстрирует некоторые важные принципы работы
с итераторами.

@example
(require 'generator)
(iter-defun my-iter (x)
  (iter-yield (1+ (iter-yield (1+ x))))
   ;; Нормальное возвращение
  -1)

(let* ((iter (my-iter 5))
       (iter2 (my-iter 0)))
  ;; Вывод 6
  (print (iter-next iter))
  ;; Вывод 9
  (print (iter-next iter 8))
  ;; Вывод 1; iter и iter2 имеют различные состояния
  (print (iter-next iter2 nil))

  ;; Мы ожидаем, что последовательность iter завершится сейчас
  (condition-case x
      (iter-next iter)
    (iter-end-of-sequence
      ;; Вывод -1, которое обычно возвращает my-iter
      (print (cdr x)))))
@end example

@node Nonlocal Exits
@section Нелокальные Выходы
@cindex nonlocal exits

  @dfn{Нелокальный выход} - это передача управления от одной точки в
  программе на другую удаленную точку.  Нелокальные выходы могут происходить
  в Emacs Lisp в результате ошибок; можно также использовать их под явным
  контролем.  Нелокальные выходы разрывают все привязки переменных,
  сделанные конструкциями осуществляющими выход.

@menu
* Catch and Throw::     Нелокальные выходы для собственных целей программы.
* Examples of Catch::   Каким образом записать нелокальные выходы.
* Errors::              Как ошибки сигнализируются и обрабатываются.
* Cleanups::            Организация запуска формы очистки при ошибке.
@end menu

@node Catch and Throw
@subsection Явные Нелокальные Выходы: @code{catch} и @code{throw}
@cindex forms for nonlocal exits

  Большинство конструкций управления влияют только на поток управления
  внутри самой конструкции.  Функция @code{throw} является исключением из
  этого правила нормального выполнения программы: она выполняет нелокальный
  выход по требованию.  (Есть и другие исключения, но они предназначены для
  обработки только ошибок.)   @code{throw} используется внутри @code{catch},
  и возвращается к этому @code{catch}. Например: (ВопросControl1487)

@example
@group
(defun foo-outer ()
  (catch 'foo
    (foo-inner)))

(defun foo-inner ()
  @dots{}
  (if x
      (throw 'foo t))
  @dots{})
@end group
@end example

@noindent
Форма @code{throw}, если выполняется, передает управление прямо назад к
соответствующему @code{catch}, который возвращает немедленно.  Код после
@code{throw} не выполняется.  Второй аргумент @code{throw} используется в
качестве возвращаемого значения @code{catch}.

  Функция @code{throw} находит совпадение @code{catch} на основе первого
  аргумента: ищется @code{catch} чей первый аргумент @code{eq} к одному
  указанному в @code{throw}.  Если @code{catch} применено более одного раза,
  приоритет за самым внутренним.  Таким образом, в приведенном выше примере,
  @code{throw} указывает @code{foo} а @code{catch} указывает @code{foo-outer}
  указывает тот же символ, так что @code{catch} является применимым
  (при условии, что нет никакого другого соответствия @code{catch} между
  ними).(ВопросControl1516)

  Выполнение @code{throw} производит выход из всех Lisp конструкций до
  согласования @code{catch}, включая вызовы функций.  Когда конструкции
  привязки, такие как @code{let} или вызовы функций, завеншаются таким
  образом, привязка не выполняется, так же, как при обычном выходе этих
  конструкций (@pxref{Local Variables}).  Кроме того, @code{throw}
  восстанавливает буфер и позицию, сохраненную @code{save-excursion}
  (@pxref{Excursions}) и статус сужения буфера, сохраненную
  @code{save-restriction}.  Запускаются все очистки, установленные с
  помощью специальной формы @code{unwind-protect}, при выходе из этой формы.
  (@pxref{Cleanups}).

  Не требуется лексического появления @code{throw} для перехода в
  @code{catch}.  Может одинаково хорошо быть вызван из другой функции,
  вызываемой в @code{catch}.  Пока действия @code{throw} происходят в
  хронологическом порядке после входа в @code{catch}, и хронологическом
  порядке перед выходом из него, имеется доступ к этому @code{catch}. Именно
  поэтому @code{throw} может быть использована в таких командах, как
  @code{exit-recursive-edit}, которые выходят обратно в цикл команд
  редактора (@pxref{Recursive Editing}).

@cindex CL note---only @code{throw} in Emacs
@quotation
@b{Common Lisp предупреждение:} Большинство других версий Lisp, включая
Common Lisp, имеют несколько способов передачи непоследовательного
управления: @code{return}, @code{return-from}, и @code{go}, например.  Emacs
Lisp имеет только @code{throw}.  @file{cl-lib} библиотека предоставляет
версии некоторых из них.
@xref{Blocks and Exits,,,cl,Common Lisp Extensions}.
@end quotation

@defspec catch tag body@dots{}
@cindex tag on run time stack
@code{catch} устанавливает точку возврата для функции @code{throw}.  Точка
возврата отличаются от других таких точек возврата по тегу @var{tag}, который
может быть любым объектом Lisp, за исключением бъекта @code{nil}.  Аргумент
@var{tag} оценивается, как правило, прежде чем устанавливается точка
возврата.

С присутствующей точкой возврата, @code{catch} оценивает форму @var{body} в
текстовом порядке.  Если формы выполнения нормально (без ошибок или
нелокального выхода) значение последней формы тела возвращается из
@code{catch}.

Если @code{throw} выполняется во время выполнения @var{body} с указанным
значением тега @var{tag}, оценка формы @code{catch} немедленно завершается;
возвращается то значение, которое указано в качестве второго аргумента
@code{throw}.
@end defspec

@defun throw tag value
Целью @code{throw} является возвращение с точки возврата ранее установленной
в @code{catch}.  Аргумент @var{tag} используется для выбора среди различных
существующих точек возврата; должно быть соответствие @code{eq} к значению,
указанному в @code{catch}.  Если несколько точек соответствуют тегу
@var{tag}, используется самый внутренний.

Аргумент @var{value} используется в качестве значения для возврата из
этого @code{catch}.

@kindex no-catch
Если нет точки возврата с тегаом @var{tag}, то сигнализируется ошибка
@code{no-catch} данных @code{(@var{tag} @var{value})}.
@end defun

@node Examples of Catch
@subsection Примеры @code{catch} и @code{throw}

  Один из способов использовать @code{catch} и @code{throw}, чтобы выйти из
  двукратно вложенного цикла.  (В большинстве языков, это будет сделано с
  помощью @code{goto}.).   Здесь мы вычисляем @code{(foo @var{i} @var{j})}
  для @var{i} и @var{j} изменяющихся от 0 до 9:

@example
@group
(defun search-foo ()
  (catch 'loop
    (let ((i 0))
      (while (< i 10)
        (let ((j 0))
          (while (< j 10)
            (if (foo i j)
                (throw 'loop (list i j)))
            (setq j (1+ j))))
        (setq i (1+ i))))))
@end group
@end example

@noindent
Если @code{foo} когда-либо возвращает не-@code{nil}, немедленно прекратить и
вернуть список @var{i} и @var{j}.  Если @code{foo} всегда возвращает
@code{nil}, в @code{catch} возвращается нормально, а значение @code{nil}, так
как это результат оценки @code{while}.

  Вот два хитрых примера, немного разные, показывают две точки возврата
  сразу.  Во-первых, две точки возврата с тем же тегом, @code{hack}:

@example
@group
(defun catch2 (tag)
  (catch tag
    (throw 'hack 'yes)))
@result{} catch2
@end group

@group
(catch 'hack
  (print (catch2 'hack))
  'no)
@print{} yes
@result{} no
@end group
@end example

@noindent
Поскольку обе точки возврата имеют метки, которые соответствуют @code{throw},
происходит переход во внутрений, установленный в @code{catch2}.  Поэтому
@code{catch2} возвращается нормально со значением @code{yes}, и это значение
выводится.  И, наконец, вторая форма тела во внешнем @code{catch}, то есть
@code{'no}, оценивается и возвращается из внешнего @code{catch}.

  Теперь давайте изменим рассуждения, приведенные в @code{catch2}:

@example
@group
(catch 'hack
  (print (catch2 'quux))
  'no)
@result{} yes
@end group
@end example

@noindent
У нас есть еще две возвратные точки, но на этот раз только внешняя имеет тег
@code{hack}; а внутренняя имеет тег @code{quux}.  Поэтому внешний
@code{throw} по отношению к @code{catch}, возвращает значение @code{yes}.
Функция @code{print} никогда не вызывается, а тело-форма @code{'no} никогда
не оценивается.  (ВопросControl1654)

@node Errors
@subsection Ошибки
@cindex errors

  Когда Emacs Lisp попытки оценить форму, которая, по некоторым причинам,
  не может быть оценена, он @dfn{сигнализирует} @dfn{ошибку}.

  Когда поступает сигнал об ошибке, по умолчанию Emacs выводит сообщение об
  ошибке и прекращает выполнение текущей команды.  Это то, что нужно делать
  в большинстве случаев, например, если вы наберете @kbd{C-f} в конце буфера.

  В сложных программах, просто прекращение не может быть то, что нужно.
  Например, программа могла внести временные изменения в структуры данных или
  создать временные буферы, которые должны быть удалены до завершения
  программы.  В таких случаях нужно использовать @code{unwind-protect} и
  установить @dfn{выражения очистки}, которые оценеваются в случае ошибки.
  (@xref{Cleanups}.).   Иногда, требуется продолжить выполнение программы
  несмотря на ошибку в подпрограмме.  В этих случаях нужно использовать
  @code{condition-case} установить @dfn{обработчики ошибок} для
  восстановления управления в случае возникновения ошибки.

  Не поддавайтесь искушению использовать обработку ошибок для контроля
  передачи управления из одной части программы в другую; используйте
  @code{catch} и @code{throw} вместо этого.  @xref{Catch and Throw}.

@menu
* Signaling Errors::      Как сообщить об ошибке.
* Processing of Errors::  Что Emacs делает, когда вы сообщаете об ошибке.
* Handling Errors::       Как перехватывать ошибки и продолжать выполнение.
* Error Symbols::         Как классифицируются ошибки для их захвата.
@end menu

@node Signaling Errors
@subsubsection Как Сообщить об Ошибке
@cindex signaling errors

   @dfn{Сигнал} об ошибке означает начало обработки ошибки.  Обработка ошибок
   обычно прерывает всю или часть выполняющейся программы и возвращается в
   точку, которая настроена для обработки ошибки
   (@pxref{Processing of Errors}).  Здесь описывается, как реализован
   сигнал об ошибке.

  Большинство ошибок в Lisp сигнализируют примитивы автоматически, которые
  вызваны не по назначению, например, если вы попытаетесь взять @sc{car}
  целого числа или двигать точку вперед в конце буфера.  Возможно также
  сигнализировать ошибки в явном виде с функциями @code{error} и
  @code{signal}.

  Выход, который происходит, когда пользователь набирает @kbd{C-g}, не
  считается ошибкой, но он обрабатывается почти как ошибка.
@xref{Quitting}.

  Каждая ошибка так или иначе указывает сообщение об ошибке.  В сообщение
  должно быть указано, что не так (``File does not exist
  (Файл не существует)''), не так (``File must exist (Файл должен
  существовать)'').  По соглашению в Emacs Lisp сообщения об ошибках должны
  начинаться с заглавной буквой, но не должны заканчиваться с каким-либо
  знаками препинания.

@defun error format-string &rest args
Функция сигнализирует об ошибке сообщением об ошибке, построенном с
применением @code{format-message} (@pxref{Formatting Strings}) к
@var{format-string} и @var{args}.

Эти примеры показывают типичное использование @code{error}:

@example
@group
(error "Это ошибка -- попробуйте что-то другое")
     @error{} Это ошибка -- попробуйте что-то другое
@end group

@group
(error "Неправильное имя `%s'" "A%%B")
     @error{} Неправильное имя ‘A%%B’
@end group
@end example

@code{error} работает, вызывая @code{signal} с двумя аргументами: символом
ошибки @code{error}, и списком, содержащим строку, возвращаемую
@code{format-message}.

Как правило, апостроф и ударение при форматировании переводятся на
соответствующие перевёрнутые кавычки, например, @t{"Отсутствует `%s'"} может привести к @t{"Отсутствует ‘foo’"}.  @xref{Text Quoting Style}, о том, как
влиять или запретить этот перевод.

@strong{Предупреждение:} Если требуется использовать свою собственную строку
в качестве дословного сообщения об ошибке, не пишиться
@code{(error @var{string})}.  Если @var{string} содержит @samp{%}, @samp{`}
или @samp{'} это может быть переформатировано, с нежелательными результатами.
Вместо этого используется @code{(error "%s" @var{string})}.
@end defun

@defun signal error-symbol data
@anchor{Definition of signal}
This function signals an error named by @var{error-symbol}.  The
argument @var{data} is a list of additional Lisp objects relevant to
the circumstances of the error.

The argument @var{error-symbol} must be an @dfn{error symbol}---a symbol
defined with @code{define-error}.  This is how Emacs Lisp classifies different
sorts of errors.  @xref{Error Symbols}, for a description of error symbols,
error conditions and condition names.

If the error is not handled, the two arguments are used in printing
the error message.  Normally, this error message is provided by the
@code{error-message} property of @var{error-symbol}.  If @var{data} is
non-@code{nil}, this is followed by a colon and a comma separated list
of the unevaluated elements of @var{data}.  For @code{error}, the
error message is the @sc{car} of @var{data} (that must be a string).
Subcategories of @code{file-error} are handled specially.

The number and significance of the objects in @var{data} depends on
@var{error-symbol}.  For example, with a @code{wrong-type-argument} error,
there should be two objects in the list: a predicate that describes the type
that was expected, and the object that failed to fit that type.

Both @var{error-symbol} and @var{data} are available to any error
handlers that handle the error: @code{condition-case} binds a local
variable to a list of the form @code{(@var{error-symbol} .@:
@var{data})} (@pxref{Handling Errors}).

The function @code{signal} never returns.
@c (though in older Emacs versions it sometimes could).

@example
@group
(signal 'wrong-number-of-arguments '(x y))
     @error{} Wrong number of arguments: x, y
@end group

@group
(signal 'no-such-error '("My unknown error condition"))
     @error{} peculiar error: "My unknown error condition"
@end group
@end example
@end defun

@cindex user errors, signaling
@defun user-error format-string &rest args
This function behaves exactly like @code{error}, except that it uses
the error symbol @code{user-error} rather than @code{error}.  As the
name suggests, this is intended to report errors on the part of the
user, rather than errors in the code itself.  For example,
if you try to use the command @code{Info-history-back} (@kbd{l}) to
move back beyond the start of your Info browsing history, Emacs
signals a @code{user-error}.  Such errors do not cause entry to the
debugger, even when @code{debug-on-error} is non-@code{nil}.
@xref{Error Debugging}.
@end defun

@cindex CL note---no continuable errors
@quotation
@b{Common Lisp note:} Emacs Lisp has nothing like the Common Lisp
concept of continuable errors.
@end quotation

@node Processing of Errors
@subsubsection How Emacs Processes Errors
@cindex processing of errors

When an error is signaled, @code{signal} searches for an active
@dfn{handler} for the error.  A handler is a sequence of Lisp
expressions designated to be executed if an error happens in part of the
Lisp program.  If the error has an applicable handler, the handler is
executed, and control resumes following the handler.  The handler
executes in the environment of the @code{condition-case} that
established it; all functions called within that @code{condition-case}
have already been exited, and the handler cannot return to them.

If there is no applicable handler for the error, it terminates the
current command and returns control to the editor command loop.  (The
command loop has an implicit handler for all kinds of errors.)  The
command loop's handler uses the error symbol and associated data to
print an error message.  You can use the variable
@code{command-error-function} to control how this is done:

@defvar command-error-function
This variable, if non-@code{nil}, specifies a function to use to
handle errors that return control to the Emacs command loop.  The
function should take three arguments: @var{data}, a list of the same
form that @code{condition-case} would bind to its variable;
@var{context}, a string describing the situation in which the error
occurred, or (more often) @code{nil}; and @var{caller}, the Lisp
function which called the primitive that signaled the error.
@end defvar

@cindex @code{debug-on-error} use
An error that has no explicit handler may call the Lisp debugger.  The
debugger is enabled if the variable @code{debug-on-error} (@pxref{Error
Debugging}) is non-@code{nil}.  Unlike error handlers, the debugger runs
in the environment of the error, so that you can examine values of
variables precisely as they were at the time of the error.

@node Handling Errors
@subsubsection Writing Code to Handle Errors
@cindex error handler
@cindex handling errors
@cindex forms for handling errors

  The usual effect of signaling an error is to terminate the command
that is running and return immediately to the Emacs editor command loop.
You can arrange to trap errors occurring in a part of your program by
establishing an error handler, with the special form
@code{condition-case}.  A simple example looks like this:

@example
@group
(condition-case nil
    (delete-file filename)
  (error nil))
@end group
@end example

@noindent
This deletes the file named @var{filename}, catching any error and
returning @code{nil} if an error occurs.  (You can use the macro
@code{ignore-errors} for a simple case like this; see below.)

  The @code{condition-case} construct is often used to trap errors that
are predictable, such as failure to open a file in a call to
@code{insert-file-contents}.  It is also used to trap errors that are
totally unpredictable, such as when the program evaluates an expression
read from the user.

  The second argument of @code{condition-case} is called the
@dfn{protected form}.  (In the example above, the protected form is a
call to @code{delete-file}.)  The error handlers go into effect when
this form begins execution and are deactivated when this form returns.
They remain in effect for all the intervening time.  In particular, they
are in effect during the execution of functions called by this form, in
their subroutines, and so on.  This is a good thing, since, strictly
speaking, errors can be signaled only by Lisp primitives (including
@code{signal} and @code{error}) called by the protected form, not by the
protected form itself.

  The arguments after the protected form are handlers.  Each handler
lists one or more @dfn{condition names} (which are symbols) to specify
which errors it will handle.  The error symbol specified when an error
is signaled also defines a list of condition names.  A handler applies
to an error if they have any condition names in common.  In the example
above, there is one handler, and it specifies one condition name,
@code{error}, which covers all errors.

  The search for an applicable handler checks all the established handlers
starting with the most recently established one.  Thus, if two nested
@code{condition-case} forms offer to handle the same error, the inner of
the two gets to handle it.

  If an error is handled by some @code{condition-case} form, this
ordinarily prevents the debugger from being run, even if
@code{debug-on-error} says this error should invoke the debugger.

  If you want to be able to debug errors that are caught by a
@code{condition-case}, set the variable @code{debug-on-signal} to a
non-@code{nil} value.  You can also specify that a particular handler
should let the debugger run first, by writing @code{debug} among the
conditions, like this:

@example
@group
(condition-case nil
    (delete-file filename)
  ((debug error) nil))
@end group
@end example

@noindent
The effect of @code{debug} here is only to prevent
@code{condition-case} from suppressing the call to the debugger.  Any
given error will invoke the debugger only if @code{debug-on-error} and
the other usual filtering mechanisms say it should.  @xref{Error Debugging}.

@defmac condition-case-unless-debug var protected-form handlers@dots{}
The macro @code{condition-case-unless-debug} provides another way to
handle debugging of such forms.  It behaves exactly like
@code{condition-case}, unless the variable @code{debug-on-error} is
non-@code{nil}, in which case it does not handle any errors at all.
@end defmac

  Once Emacs decides that a certain handler handles the error, it
returns control to that handler.  To do so, Emacs unbinds all variable
bindings made by binding constructs that are being exited, and
executes the cleanups of all @code{unwind-protect} forms that are
being exited.  Once control arrives at the handler, the body of the
handler executes normally.

  After execution of the handler body, execution returns from the
@code{condition-case} form.  Because the protected form is exited
completely before execution of the handler, the handler cannot resume
execution at the point of the error, nor can it examine variable
bindings that were made within the protected form.  All it can do is
clean up and proceed.

  Error signaling and handling have some resemblance to @code{throw} and
@code{catch} (@pxref{Catch and Throw}), but they are entirely separate
facilities.  An error cannot be caught by a @code{catch}, and a
@code{throw} cannot be handled by an error handler (though using
@code{throw} when there is no suitable @code{catch} signals an error
that can be handled).

@defspec condition-case var protected-form handlers@dots{}
This special form establishes the error handlers @var{handlers} around
the execution of @var{protected-form}.  If @var{protected-form} executes
without error, the value it returns becomes the value of the
@code{condition-case} form; in this case, the @code{condition-case} has
no effect.  The @code{condition-case} form makes a difference when an
error occurs during @var{protected-form}.

Each of the @var{handlers} is a list of the form @code{(@var{conditions}
@var{body}@dots{})}.  Here @var{conditions} is an error condition name
to be handled, or a list of condition names (which can include @code{debug}
to allow the debugger to run before the handler); @var{body} is one or more
Lisp expressions to be executed when this handler handles an error.
Here are examples of handlers:

@example
@group
(error nil)

(arith-error (message "Division by zero"))

((arith-error file-error)
 (message
  "Either division by zero or failure to open a file"))
@end group
@end example

Each error that occurs has an @dfn{error symbol} that describes what
kind of error it is, and which describes also a list of condition names
(@pxref{Error Symbols}).  Emacs
searches all the active @code{condition-case} forms for a handler that
specifies one or more of these condition names; the innermost matching
@code{condition-case} handles the error.  Within this
@code{condition-case}, the first applicable handler handles the error.

After executing the body of the handler, the @code{condition-case}
returns normally, using the value of the last form in the handler body
as the overall value.

@cindex error description
The argument @var{var} is a variable.  @code{condition-case} does not
bind this variable when executing the @var{protected-form}, only when it
handles an error.  At that time, it binds @var{var} locally to an
@dfn{error description}, which is a list giving the particulars of the
error.  The error description has the form @code{(@var{error-symbol}
. @var{data})}.  The handler can refer to this list to decide what to
do.  For example, if the error is for failure opening a file, the file
name is the second element of @var{data}---the third element of the
error description.

If @var{var} is @code{nil}, that means no variable is bound.  Then the
error symbol and associated data are not available to the handler.

@cindex rethrow a signal
Sometimes it is necessary to re-throw a signal caught by
@code{condition-case}, for some outer-level handler to catch.  Here's
how to do that:

@example
  (signal (car err) (cdr err))
@end example

@noindent
where @code{err} is the error description variable, the first argument
to @code{condition-case} whose error condition you want to re-throw.
@xref{Definition of signal}.
@end defspec

@defun error-message-string error-descriptor
This function returns the error message string for a given error
descriptor.  It is useful if you want to handle an error by printing the
usual error message for that error.  @xref{Definition of signal}.
@end defun

@cindex @code{arith-error} example
Here is an example of using @code{condition-case} to handle the error
that results from dividing by zero.  The handler displays the error
message (but without a beep), then returns a very large number.

@example
@group
(defun safe-divide (dividend divisor)
  (condition-case err
      ;; @r{Protected form.}
      (/ dividend divisor)
@end group
@group
    ;; @r{The handler.}
    (arith-error                        ; @r{Condition.}
     ;; @r{Display the usual message for this error.}
     (message "%s" (error-message-string err))
     1000000)))
@result{} safe-divide
@end group

@group
(safe-divide 5 0)
     @print{} Arithmetic error: (arith-error)
@result{} 1000000
@end group
@end example

@noindent
The handler specifies condition name @code{arith-error} so that it
will handle only division-by-zero errors.  Other kinds of errors will
not be handled (by this @code{condition-case}).  Thus:

@example
@group
(safe-divide nil 3)
     @error{} Wrong type argument: number-or-marker-p, nil
@end group
@end example

  Here is a @code{condition-case} that catches all kinds of errors,
including those from @code{error}:

@example
@group
(setq baz 34)
     @result{} 34
@end group

@group
(condition-case err
    (if (eq baz 35)
        t
      ;; @r{This is a call to the function @code{error}.}
      (error "Rats!  The variable %s was %s, not 35" 'baz baz))
  ;; @r{This is the handler; it is not a form.}
  (error (princ (format "The error was: %s" err))
         2))
@print{} The error was: (error "Rats!  The variable baz was 34, not 35")
@result{} 2
@end group
@end example

@defmac ignore-errors body@dots{}
This construct executes @var{body}, ignoring any errors that occur
during its execution.  If the execution is without error,
@code{ignore-errors} returns the value of the last form in @var{body};
otherwise, it returns @code{nil}.

Here's the example at the beginning of this subsection rewritten using
@code{ignore-errors}:

@example
@group
  (ignore-errors
   (delete-file filename))
@end group
@end example
@end defmac

@defmac with-demoted-errors format body@dots{}
This macro is like a milder version of @code{ignore-errors}.  Rather
than suppressing errors altogether, it converts them into messages.
It uses the string @var{format} to format the message.
@var{format} should contain a single @samp{%}-sequence; e.g.,
@code{"Error: %S"}.  Use @code{with-demoted-errors} around code
that is not expected to signal errors, but
should be robust if one does occur.  Note that this macro uses
@code{condition-case-unless-debug} rather than @code{condition-case}.
@end defmac

@node Error Symbols
@subsubsection Error Symbols and Condition Names
@cindex error symbol
@cindex error name
@cindex condition name
@cindex user-defined error
@kindex error-conditions
@kindex define-error

  When you signal an error, you specify an @dfn{error symbol} to specify
the kind of error you have in mind.  Each error has one and only one
error symbol to categorize it.  This is the finest classification of
errors defined by the Emacs Lisp language.

  These narrow classifications are grouped into a hierarchy of wider
classes called @dfn{error conditions}, identified by @dfn{condition
names}.  The narrowest such classes belong to the error symbols
themselves: each error symbol is also a condition name.  There are also
condition names for more extensive classes, up to the condition name
@code{error} which takes in all kinds of errors (but not @code{quit}).
Thus, each error has one or more condition names: @code{error}, the
error symbol if that is distinct from @code{error}, and perhaps some
intermediate classifications.

@defun define-error name message &optional parent
  In order for a symbol to be an error symbol, it must be defined with
@code{define-error} which takes a parent condition (defaults to @code{error}).
This parent defines the conditions that this kind of error belongs to.
The transitive set of parents always includes the error symbol itself, and the
symbol @code{error}.  Because quitting is not considered an error, the set of
parents of @code{quit} is just @code{(quit)}.
@end defun

@cindex peculiar error
  In addition to its parents, the error symbol has a @var{message} which
is a string to be printed when that error is signaled but not handled.  If that
message is not valid, the error message @samp{peculiar error} is used.
@xref{Definition of signal}.

Internally, the set of parents is stored in the @code{error-conditions}
property of the error symbol and the message is stored in the
@code{error-message} property of the error symbol.

  Here is how we define a new error symbol, @code{new-error}:

@example
@group
(define-error 'new-error "A new error" 'my-own-errors)
@end group
@end example

@noindent
This error has several condition names: @code{new-error}, the narrowest
classification; @code{my-own-errors}, which we imagine is a wider
classification; and all the conditions of @code{my-own-errors} which should
include @code{error}, which is the widest of all.

  The error string should start with a capital letter but it should
not end with a period.  This is for consistency with the rest of Emacs.

  Naturally, Emacs will never signal @code{new-error} on its own; only
an explicit call to @code{signal} (@pxref{Definition of signal}) in
your code can do this:

@example
@group
(signal 'new-error '(x y))
     @error{} A new error: x, y
@end group
@end example

  This error can be handled through any of its condition names.
This example handles @code{new-error} and any other errors in the class
@code{my-own-errors}:

@example
@group
(condition-case foo
    (bar nil t)
  (my-own-errors nil))
@end group
@end example

  The significant way that errors are classified is by their condition
names---the names used to match errors with handlers.  An error symbol
serves only as a convenient way to specify the intended error message
and list of condition names.  It would be cumbersome to give
@code{signal} a list of condition names rather than one error symbol.

  By contrast, using only error symbols without condition names would
seriously decrease the power of @code{condition-case}.  Condition names
make it possible to categorize errors at various levels of generality
when you write an error handler.  Using error symbols alone would
eliminate all but the narrowest level of classification.

  @xref{Standard Errors}, for a list of the main error symbols
and their conditions.

@node Cleanups
@subsection Cleaning Up from Nonlocal Exits
@cindex nonlocal exits, cleaning up
@cindex forms for cleanup

  The @code{unwind-protect} construct is essential whenever you
temporarily put a data structure in an inconsistent state; it permits
you to make the data consistent again in the event of an error or
throw.  (Another more specific cleanup construct that is used only for
changes in buffer contents is the atomic change group; @ref{Atomic
Changes}.)

@defspec unwind-protect body-form cleanup-forms@dots{}
@cindex cleanup forms
@cindex protected forms
@cindex error cleanup
@cindex unwinding
@code{unwind-protect} executes @var{body-form} with a guarantee that
the @var{cleanup-forms} will be evaluated if control leaves
@var{body-form}, no matter how that happens.  @var{body-form} may
complete normally, or execute a @code{throw} out of the
@code{unwind-protect}, or cause an error; in all cases, the
@var{cleanup-forms} will be evaluated.

If @var{body-form} finishes normally, @code{unwind-protect} returns the
value of @var{body-form}, after it evaluates the @var{cleanup-forms}.
If @var{body-form} does not finish, @code{unwind-protect} does not
return any value in the normal sense.

Only @var{body-form} is protected by the @code{unwind-protect}.  If any
of the @var{cleanup-forms} themselves exits nonlocally (via a
@code{throw} or an error), @code{unwind-protect} is @emph{not}
guaranteed to evaluate the rest of them.  If the failure of one of the
@var{cleanup-forms} has the potential to cause trouble, then protect
it with another @code{unwind-protect} around that form.

The number of currently active @code{unwind-protect} forms counts,
together with the number of local variable bindings, against the limit
@code{max-specpdl-size} (@pxref{Definition of max-specpdl-size,, Local
Variables}).
@end defspec

  For example, here we make an invisible buffer for temporary use, and
make sure to kill it before finishing:

@example
@group
(let ((buffer (get-buffer-create " *temp*")))
  (with-current-buffer buffer
    (unwind-protect
        @var{body-form}
      (kill-buffer buffer))))
@end group
@end example

@noindent
You might think that we could just as well write @code{(kill-buffer
(current-buffer))} and dispense with the variable @code{buffer}.
However, the way shown above is safer, if @var{body-form} happens to
get an error after switching to a different buffer!  (Alternatively,
you could write a @code{save-current-buffer} around @var{body-form},
to ensure that the temporary buffer becomes current again in time to
kill it.)

  Emacs includes a standard macro called @code{with-temp-buffer} which
expands into more or less the code shown above (@pxref{Definition of
with-temp-buffer,, Current Buffer}).  Several of the macros defined in
this manual use @code{unwind-protect} in this way.

@findex ftp-login
  Here is an actual example derived from an FTP package.  It creates a
process (@pxref{Processes}) to try to establish a connection to a remote
machine.  As the function @code{ftp-login} is highly susceptible to
numerous problems that the writer of the function cannot anticipate, it
is protected with a form that guarantees deletion of the process in the
event of failure.  Otherwise, Emacs might fill up with useless
subprocesses.

@example
@group
(let ((win nil))
  (unwind-protect
      (progn
        (setq process (ftp-setup-buffer host file))
        (if (setq win (ftp-login process host user password))
            (message "Logged in")
          (error "Ftp login failed")))
    (or win (and process (delete-process process)))))
@end group
@end example

  This example has a small bug: if the user types @kbd{C-g} to
quit, and the quit happens immediately after the function
@code{ftp-setup-buffer} returns but before the variable @code{process} is
set, the process will not be killed.  There is no easy way to fix this bug,
but at least it is very unlikely.
