@c -*- mode: texinfo; coding: utf-8 -*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2019 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Control Structures
@chapter Управляющие Структуры
@cindex special forms for control structures
@cindex forms for control structures
@cindex control structures

  Lisp программа состоит из набора @dfn{выражений} или @dfn{форм}
  (@pxref{Forms}).  Контроль порядка выполнения этих форм, реализуется
  заключением их в @dfn{управляющие структуры}.  Управляющие структуры
  являются специальными формами, которые контролируют, когда, сколько раз,
  каким образом, и нужно ли вообще оценивать содержащиеся в них формы.

@cindex textual order
  Простейший порядок выполнения - последовательное выполнение: вначале
  оценивается @var{a}, затем оценивается @var{b}, и так далее.  Это то, что
  происходит, когда написано несколько форм подряд в теле функции, или на
  верхнем уровне в файле Lisp кода --- формы выполняются в том порядке в
  котором написаны.  Называется это @dfn{текстовый порядок}.  Например, если
  тело функции состоит из двух форм @var{a} и @var{b}, оценка функции
  оценивает вначале @var{a}, а затем @var{b}.  Результат вычисления @var{b}
  становится значением функции.

  Явные структуры управления делают возможным порядок исполнения, отличным от
  последовательного.

  Emacs Lisp обеспечивает несколько видов структур управления, в том числе
  другие разновидности упорядочивания выполнения: условные выражения,
  итерация, и (управляемые) переходы---все обсуждается ниже.  Встроенные
  управляющие структуры являются особыми формами, так как их подчиненные
  формы не обязательно оценеваются все или оцениваются последовательно.
  Можно использовать макросы, чтобы определить свои собственные конструкции
  структур управления (@pxref{Macros}).

@menu
* Sequencing::             Оценка в текстовом порядке.
* Conditionals::           @code{if}, @code{cond}, @code{when}, @code{unless}.
* Combining Conditions::   @code{and}, @code{or}, @code{not}.
* Pattern-Matching Conditional::  Как использовать @code{pcase} и друзей.(БаянControl43)
* Iteration::              @code{while} циклы.
* Generators::             Общие последовательности и сопрограммы.
* Nonlocal Exits::         Выход из последовательности.
@end menu

@node Sequencing
@section Последовательное Выполнение
@cindex sequencing
@cindex sequential execution
@cindex forms for sequential execution

  Оценка форм, в порядке их появления, является наиболее распостраненным
  способом перехода управления от одной формы к другой.  В некоторых случаях,
  например, в теле функции, это происходит автоматически.  В другом случае
  нужно использовать конструкцию управляющей структуры: @code{progn},
  простейшая управляющая структура Lisp.

  @code{progn} - особая форма выглядит следующим образом:

@example
@group
(progn @var{a} @var{b} @var{c} @dots{})
@end group
@end example

@noindent
что определяет выполнение форм @var{a}, @var{b}, @var{c}, и так далее, в
указанном порядке.  Эти формы составляют @dfn{тело} формы @code{progn}.
Значение последней формы в этом теле, становится значением всей формы
@code{progn}.  Форма @code{(progn)} возвращает значение @code{nil}.

@cindex implicit @code{progn}
  На заре Lisp, @code{progn} была единственный способ выполнить две или более
  форм последовательно и использовать значение последней из них.  Но
  программисты обнаружили, что часто необходимо использовать @code{progn} в
  теле функции, где (в то время) разрешена была только одна форма.  Таким
  образом, тело функции было преобразовано в неявное @code{progn}:  несколько
  форм оцениваются также, как в теле фактического @code{progn}.  Многие
  другие управляющие структуры, также содержат неявно @code{progn}.  В
  результате, @code{progn} не используется так часто, как это было много лет
  назад.  В настоящее время данная форма нужна чаще всего внутри
  @code{unwind-protect}, @code{and}, @code{or}, или в качестве
  @var{then}-части в конструкции @code{if}.

@defspec progn forms@dots{}
Особая форма, оценивает все формы @var{forms} в текстовом порядке и
возвращает результат оценки последней формы.

@example
@group
(progn (print "Первая форма")
       (print "Вторая форма")
       (print "Третья форма"))
     @print{} "Первая форма"
     @print{} "Вторая форма"
     @print{} "Третья форма"
@result{} "Третья форма"
@end group
@end example
@end defspec

  Две другие конструкции также оценивают ряд форм, но возвращают разные
  значения:

@defspec prog1 form1 forms@dots{}
Cпециальная форма, оценивает @var{form1} и все остальные @var{forms} в
текстовом порядке и возвращает результат @var{form1}.

@example
@group
(prog1 (print "Первая форма")
       (print "Вторая форма")
       (print "Третья форма"))
     @print{} "Первая форма"
     @print{} "Вторая форма"
     @print{} "Третья форма"
@result{} "Первая форма"
@end group
@end example

Вот способ, чтобы удалить первый элемент из списка в переменной @code{x}, а
затем вернуть значение удалённого элемента:

@example
(prog1 (car x) (setq x (cdr x)))
@end example
@end defspec

@defspec prog2 form1 form2 forms@dots{}
Особая форма, оценивает @var{form1}, @var{form2}, и все следующие
@var{forms} в текстовом порядке и возвращает результат @var{form2}.

@example
@group
(prog2 (print "Первая форма")
       (print "Вторая форма")
       (print "Третья форма"))
     @print{} "Первая форма"
     @print{} "Вторая форма"
     @print{} "Третья форма"
@result{} "Вторая форма"
@end group
@end example
@end defspec

@node Conditionals
@section Условные Выражения
@cindex conditional evaluation
@cindex forms, conditional

  Условные управляющие структуры выбрают один из вариантов.  Emacs Lisp имеет
  пять условных форм: @code{if}, которая является такой же, как и в других
  языках; @code{when} и @code{unless}, которые являются вариантами @code{if};
  @code{cond}, который является обобщенным оператором case; и @code{pcase},
  который представляет собой обобщение @code{cond}
  (@pxref{Pattern-Matching Conditional}).

@defspec if condition then-form else-forms@dots{}
@code{if} регулирует управление между ветками @var{then-form} и
@var{else-forms} на основе состояния условия @var{condition}.  Если
@var{condition} оценивается в не-@code{nil}, оценивается ветка
@var{then-form} и  этот результат возвращается. В противном случае,
оценивается ветка @var{else-forms} в текстовом порядке, и возвращается
значение последней формы этой ветки.  (@var{else}-ветка
@code{if}, является примером неявного использования @code{progn}.
@xref{Sequencing}.)

Если условие @var{condition} оценивается в @code{nil}, а формы в ветке
@var{else-forms} не указаны, @code{if} возвращает значение @code{nil}.

@code{if} - это особая форма, так как формы ветви, которая не выбрана,
никогда не оцениваются---игнорируются.  Таким образом, в этом примере,
@code{истина} не печатается, потому что @code{print} не выполняется:

@example
@group
(if nil
    (print 'истина)
  'ложь)
@result{} ложь
@end group
@end example
@end defspec

@defmac when condition then-forms@dots{}
Вариант @code{if}, где отсутствует ветка @var{else-forms}, и, возможно,
присутствие нескольких форм в ветке @var{then-forms}. В частности,

@example
(when @var{condition} @var{a} @var{b} @var{c})
@end example

@noindent
что полностью эквивалентно

@example
(if @var{condition} (progn @var{a} @var{b} @var{c}) nil)
@end example
@end defmac

@defmac unless condition forms@dots{}
Вариант @code{if}, где нет ветки @var{then-form}:

@example
(unless @var{condition} @var{a} @var{b} @var{c})
@end example

@noindent
что полностью эквивалентно

@example
(if @var{condition} nil
   @var{a} @var{b} @var{c})
@end example
@end defmac

@defspec cond clause@dots{}
@code{cond} выбирает между произвольным числом альтернатив (или предложений).
Каждый аргумент @var{clause} в форме @code{cond} является такой альтернативой
и представляет из себя список @sc{car} которого - это  @var{условие};
остальные элементы, если таковые имеются, @var{тело-формы}. Выглядит такое
предложение (альтернатива) следующим образом:

@example
(@var{условие} @var{тело-формы}@dots{})
@end example

@code{cond} проверяет каждую альтернативу в текстовом порядке, путем оценки
@var{условия}.  Если значение @var{условия} устанавленно в не-@code{nil},
предложение считается успешным и @code{cond} оценивает @var{тело-формы} и
возвращает значение последней формы из @var{тело-формы}.  Все остальные
альтернативы далее игнорируются.

Если значение @var{условие} оценивается в @code{nil}, альтернатива считается
неподходящей и @code{cond} переходит к следующей альтернативе, оценивая уже
её @var{условие}.

Альтернатива также может выглядеть следующим образом:

@example
(@var{условие})
@end example

@noindent
в случае, если @var{условие} при проверки альтернативы оценивается в
не-@code{nil}, форма @code{cond} возвращает значение оценнённое значение
@var{условия}.

Если каждое @var{условие} имеет значение @code{nil} и не отрабатывает ни
одна альтернатива, @code{cond} возвращается @code{nil}.

Следующий пример имеет четыре альтернативы, которые выполняются в зависимости
от того, что из себя представляет значение @code{x}, а именно: число, строку,
буфер или символ:

@example
@group
(cond ((numberp x) x)
      ((stringp x) x)
      ((bufferp x)
       (setq temporary-hack x) ; @r{несколько форм в теле-формы}
       (buffer-name x))        ; @r{одной альтернативы}
      ((symbolp x) (symbol-value x)))
@end group
@end example

Часто требуется оценить последнюю альтернативу, когда ни одна из предыдущих
не была принята.  Для этого используется @code{t} в качестве @var{условия}
последней альтернативы, как здесь: @code{(t @var{body-forms})}.  Форма
@code{t} всегда принимает значение @code{t} и никогда значение @code{nil},
поэтому эта альтернатива выбирается, если до неё доходит очередь @code{cond}.
Например:

@example
@group
(setq a 5)
(cond ((eq a 'hack) 'foo)
      (t "default"))
@result{} "default"
@end group
@end example

@noindent
@code{cond} выражение возвращает @code{foo}, если значение @code{a}
удовлетворяет условию @code{eq} к @code{hack}, и возвращает строку
@code{"default"} в другом случае.
@end defspec

Любая условная конструкция может быть выражена с @code{cond} или @code{if}.
Таким образом, выбор между ними является вопросом стиля. Например:

@example
@group
(if @var{a} @var{b} @var{c})
@equiv{}
(cond (@var{a} @var{b}) (t @var{c}))
@end group
@end example

@node Combining Conditions
@section Конструкции для Комбинирования Услвных Выражений
@cindex combining conditions

  В этом разделе описаны три конструкции, которые часто используются вместе
  с @code{if} и @code{cond}, чтобы выразить сложные условия.  Конструкции
  @code{and} и @code{or} также могут быть использованы по отдельности как
  разновидности нескольких условных конструкций.

@defun not condition
Функция проверяет ложность @var{condition}.  Возвращает @code{t} если
@var{condition} оценивается в @code{nil} и @code{nil} в противном лучае.
Функция @code{not} идентична @code{null}, и мы рекомендуем функцию с именем
@code{null}, когда проверяется значение пустого списка.
@end defun

@defspec and conditions@dots{}
@code{and} проверяет все ли условия @var{conditions} истинны.  Оценивает
@var{conditions} один за другим в текстовом порядке.

Если какой-либо из @var{conditions} вычисляется в @code{nil}, то результат
@code{and} устанавливается в @code{nil} независимо от результата оценки
остальных @var{conditions}; поэтому @code{and} возвращает @code{nil} сразу,
не оценивая оставшиеся условия @var{conditions}.

Если все @var{conditions} оцениваются в не-@code{nil}, то значение последнего
из них становится значением формы @code{and}.  Просто @code{(and)}, без
@var{conditions}, возвращает @code{t}, потому что все @var{conditions}
оценились в не-@code{nil}. (Подумайте об этом, почему это так?)

Вот пример.  Первое условие возвращает целое число 1, которое не является
@code{nil}.  Аналогичным образом, второе условие возвращает целое число 2,
которое не является @code{nil}.  Третье условие @code{nil}, поэтому
оставшееся условие никогда не оценивали.

@example
@group
(and (print 1) (print 2) nil (print 3))
     @print{} 1
     @print{} 2
@result{} nil
@end group
@end example

Вот более реалистичный пример использования @code{and}:

@example
@group
(if (and (consp foo) (eq (car foo) 'x))
    (message "foo список, который начинается с x"))
@end group
@end example

@noindent
Обратите внимание, что @code{(car foo)} не выполняется, если
@code{(consp foo)} возвращает @code{nil}, что позволяет избежать ошибок.

@code{and} выражение может быть написано с использованием выражения @code{if}
или @code{cond}. Вот как:

@example
@group
(and @var{arg1} @var{arg2} @var{arg3})
@equiv{}
(if @var{arg1} (if @var{arg2} @var{arg3}))
@equiv{}
(cond (@var{arg1} (cond (@var{arg2} @var{arg3}))))
@end group
@end example
@end defspec

@defspec or conditions@dots{}
@code{or} специальная форма, в которой проверяется является ли, по крайней
мере одно из условий @var{conditions} истиной.  Оцениваются все условия
@var{conditions} формы один за другим, в текстовом порядке.

Если какое-либо из условий @var{conditions} оценивается в не-@code{nil}, то
результат @code{or} устанавливается в не-@code{nil} и @code{or} сразу
возвращает это значение результатом, не обращая внимания на оставшиеся
условия @var{conditions}.

Если все @var{conditions} оценены в @code{nil}, то @code{or} выражение
возвращает @code{nil}.  Просто @code{(or)}, без условий @var{conditions},
возвращает @code{nil}, это потому, что все @var{conditions} оценились в
@code{nil}.  (Подумайте об этом, почему это так?)

Например, это выражение проверяет удовлетворяет @code{x} @code{eq} к
@code{nil} или целому числу нуль:

@example
(or (eq x nil) (eq x 0))
@end example

Как и @code{and} конструкцию, @code{or} можно записать в терминах
@code{cond}.  Например:

@example
@group
(or @var{arg1} @var{arg2} @var{arg3})
@equiv{}
(cond (@var{arg1})
      (@var{arg2})
      (@var{arg3}))
@end group
@end example

Можно, но не совсем точно, реализовать @code{or} по средствам @code{if}:

@example
@group
(if @var{arg1} @var{arg1}
  (if @var{arg2} @var{arg2}
    @var{arg3}))
@end group
@end example

@noindent
Это не полностью эквивалентно, так как возможно вычисление @var{arg1} или
@var{arg2} дважды.  В противоположность этому,
@code{(or @var{arg1} @var{arg2} @var{arg3})} никогда не оценивает любой
свой аргумент более чем один раз.
@end defspec

@node Pattern-Matching Conditional
@section Шаблон-Соответствие Условию
@cindex pcase
@cindex pattern matching, programming style

Помимо четырех основных условных форм, Emacs Lisp также имеет условную форму
сопоставления с образцом, макрос @code{pcase}, гибрид @code{cond} и
@code{cl-case} (@pxref{Conditionals,,,cl,Common Lisp Extensions}), с помощью
которой, преодолеваются их ограничения и вводится
@dfn{стиль программирования сопоставления с образцом}.  Ограничения, которые
преодолевает @code{pcase}:

@itemize
@item
Форма @code{cond} выбирает среди альтернатив, путем оценки предиката
@var{условия} каждой из своих веток (@pxref{Conditionals}).  Основным
ограничением является то, что эти переменные @var{условия} не доступны
для @var{формы-тела} соответствующей ветки.

Ещё ограничение (скорее неудобство, чем ограничение) заключается в том, что
для проверки ряда @var{условий}, требуется написание много повторяющегося
кода.  (@code{cl-case} решает эти неудобства.)

@item
Макрос @code{cl-case} выбирает среди альтернатив путем оценки равенства
первого аргумента с набором конкретных значений.

Его ограничения в двояко:

@enumerate
@item
Для проверки равенства используется @code{eql}.
@item
Значения должны быть известны и записаны заранее.
@end enumerate

@noindent
Это делает @code{cl-case} непригодным использования со строками или
составными структурами данных (например, списками или векторами).
(@code{cond} не имеет этих ограничений, но у него есть другие, см. выше)
@end itemize

@noindent
Концептуально, @code{pcase} макрос заимствует способ обработки первого
аргумента из @code{cl-case} и способ обработки выбранной ветки @code{cond},
заменяя @var{условие} обобщением проверки на равенство варианта
@dfn{сопоставление шаблону} и добавляя средства, позволяющие кратко выразить
предикат альтернативы и организовать LET-привязку между предикатом и
@var{тела-формы} альтернативы. (ВопросControl474 Баян полный)

Краткое выражение предиката известно как @dfn{шаблон}.  Когда предикат,
вызванный для проверки первого аргумента альтернативы, возвращает
не-@code{nil}, подразумевается, что ``шаблон совпадает со значением''
(или иногда ``значение соответствует шаблону'').

@menu
* The @code{pcase} macro: pcase Macro. Примеры и предостережения.
* Extending @code{pcase}: Extending pcase.  Определение новых видов шаблонов.
* Backquote-Style Patterns: Backquote Patterns.  Сопоставление моделей
                                                 структур.
* Destructuring with pcase Patterns:: Использование шаблонов pcase для
                                      извлечения подполей.
@end menu

@node pcase Macro
@subsection The @code{pcase} macro

Для справки, @xref{Pattern-Matching Conditional}.

@defmac pcase expression &rest clauses
Каждая альтернатива в @var{clauses} имеет вид:
@w{@code{(@var{шаблон} @var{тело-формы}@dots{})}}.

Оценивается @var{expression}, для определения его значения, @var{expval}.
Ищется первый элемент альтернатив в @var{clauses}, значение @var{pattern}
которого соответствует @var{expval} и передаётся управление @var{телу-формы}
подобранной альтернативы.

Если есть совпадение, значением @code{pcase} является значение последней из
@var{тела-формы} подобранной альтернативы.  В противном случае, @code{pcase}
оценивается в @code{nil}.
@end defmac

@cindex pcase pattern
Каждый @var{шаблон} должен быть @dfn{pcase шаблоном}, который может
использовать либо один любой из основных шаблонов, определенных ниже, либо
один из шаблонов, определенных с помощью @code{pcase-defmacro}
(@pxref{Extending pcase}).

Остальная часть этого подраздела описывает различные формы основных шаблонов,
приведены примеры и, в заключении, важные предосторежения по использованию
LET-связывающего механизма, предоставляемый некоторыми формами шаблонов.
Основные шаблоны могут принимать следующие формы:

@table @code

@item _
Соответствие любому @var{expval}.
Это также известно как @dfn{don't care} или @dfn{wildcard}.(ВопросControl524)

@item '@var{val}
Соответствие, если @var{expval} равен @var{val}. Сравнение производится
с использованием @code{equal} (@pxref{Equality Predicates}).

@item @var{keyword}
@itemx @var{integer}
@itemx @var{string}
Соответствие, если @var{expval} равен буквально объекту.  Это особый случай
@code{'@var{val}}, описанный выше, потому, сравнивается буквально объекты
заключённые в кавычки(ВопросControl535 ,баян полнейший).

@item @var{symbol}
Соответствует любому @var{expval}, и к тому же, LET связывает @var{symbol}
с @var{expval}, таким образом, что эта привязка доступна @var{телу-формы}
(@pxref{Dynamic Binding}).

Если @var{symbol} является частью последовательности шаблона @var{seqpat}
(например, с помощью @code{and}, ниже), связывание также доступно в части
@var{seqpat} после появления @var{symbol}.  Такое использование имеет
некоторые предостережения, смотреть @ref{pcase-symbol-caveats,,caveats}.

Два символа, которых здесь нужно избегать это @code{t}, который ведет себя
как @code{_} (выше) и является устаревшим, и @code{nil}, при использовании
которого сигнализируется ошибка.  Кроме того, не имеет смысла связывать
символы ключевых слов (@pxref{Constant Variables}).

@item (pred @var{function})
Соответствует, если предикат @var{function} возпращает не-@code{nil} при
вызове с @var{expval}.  Предикат @var{function} может иметь одну из
следующих форм:

@table @asis
@item именованная функция (символ)
Вызов именованной функции с одним аргументом, @var{expval}.

Пример: @code{integerp}

@item лямбда-выражение
Вызов анонимной функции с одним аргументом,
@var{expval} (@pxref{Lambda Expressions}).

Пример: @code{(lambda (n) (= 42 n))}

@item вызов функции с @var{n} аргументами
Вызов функции (первый элемент вызова функции) с аргументами @var{n}
(другие элементы) и дополнительным @var{n}+1 аргументом, @var{expval}.

Пример: @code{(= 42)}@*
В этом примере функция равна @code{=}, @var{n} равен единице, а фактический
вызов функции это: @w{@code{(= 42 @var{expval})}}.
@end table

@item (app @var{функция} @var{шаблон})
Соответствует, когда вызов функции @var{функция}, возвращает значение
@var{expval}, которое соответствует @var{шаблон}.
@var{функция} может принимать одну из форм, описанных для @code{pred}, выше.
В отличии от @code{pred}, @code{app} проверяет результат с @var{шаблоном}, а
не с логическим значением истинности.

@item (guard @var{логическое-выражение})
Соответствует, когда @var{логическое-выражение} устанвленно в не-@code{nil}
значение.

@item (let @var{шаблон} @var{expr})
Соответствует, когда при оценки @var{expr}, чтобы получить @var{exprval},
@var{exprval} соответствует @var{шаблон}.  (Это вызвано тем, что @code{let}
может связывать @var{шаблон} со значением символа @var{symbol}.)
(ВопросControl593 баян всем баянам)
@end table

@cindex sequencing pattern
@dfn{последовательность шаблонов} (известно как @var{seqpat}) представляет
собой образец, который обрабатывает свои аргументы суб-шаблонов в
последовательности.  Есть два для @code{pcase}: @code{and} и @code{or}.
Ведут себя аналогично специальным формам, разделяя их имена
(@pxref{Combining Conditions}), но вместо обработки значений, они
обрабатывают суб-шаблоны.

@table @code
@item (and @var{pattern1}@dots{})
Попытка сопоставить @var{pattern1}@dots{} по порядку, пока один из них не
совпадает.  В этом случае, @code{and} также не совпадает, а остальные
подшаблоны не проверяются.  Если все суб-шаблоны совпадают, @code{and}
считается совпавшим.

@item (or @var{pattern1} @var{pattern2}@dots{})
Попытка сопоставить @var{pattern1}, @var{pattern2}, @dots{} по порядку, пока
один из них не совпаст.  В этом случае, @code{or}, также соответствует, а
остальные подшаблонам бльше не проверяются.  (Обратите внимание, что должно
быть по крайней мере, два суб-шаблона.  Простой
@w{@code{(or @var{pattern1})}} сигнализирует об ошибке.)
@c Вопрос: Правильно ли это и предназначен?
@c        Есть ли исключения, квалификация?
@c        (Btw, ``Пожалуйста, избегайте его'' плохое сообщение об ошибке.)

Для того, чтобы представить согласованную среду (@pxref{Intro Eval}) к
@var{body-forms} (что позволяет избежать ошибки оценки при совпадении), если
какой-либо из подшаблонов LET, связывает набор символов, все они
@emph{должны} связывать один и тот же набор символов.
@end table

@anchor{pcase-example-0}
@subheading Пример: Превосходство Над @code{cl-case}

Вот пример, который почёркивает некоторые преимущества @code{pcase}
перед @code{cl-case} (@pxref{Conditionals,,,cl,Common Lisp Extensions}).

@example
@group
(pcase (get-return-code x)
  ;; string
  ((and (pred stringp) msg)
   (message "%s" msg))
@end group
@group
  ;; символы
  ('success       (message "Готово!"))
  ('would-block   (message "К сожалению, не может быть выполнено сейчас"))
  ('read-only     (message "Shmliblick только для чтения"))
  ('access-denied (message "У вас нет необходимых прав"))
@end group
@group
  ;; по умолчанию
  (code           (message "Неизвестный код возврата %S")))
@end group
@end example

@noindent
С @code{cl-case}, требуется явно объявить локальную переменную @code{code}
для хранения возвращаемого значения @code{get-return-code}.  Также
@code{cl-case} трудно использовать со строками, поскольку используется
@code{eql} для сравнения.

@anchor{pcase-example-1}
@subheading Example: Using @code{and}

Общей идиомой, является написание шаблона, начиная с @code{and}, с одним или
несколькими @var{symbol} суб-шаблонами, обеспечивающими привязку к
последующим суб-шаблонам (а также к формам тела).  Например, следующий шаблон
соответствует однозначным целым числам.

@example
@group
(and
  (pred integerp)
  n                     ; @r{связывают @code{n} с @var{expval}}
  (guard (<= -9 n 9)))
@end group
@end example

@noindent
Во-первых, @code{pred} соответствует, если @w{@code{(integerp @var{expval})}}
принимает значение не-@code{nil}.  Далее, @code{n} является шаблоном
@var{symbol}, который соответствует чему угодно и привязывает @code{n} к
@var{expval}.  Наконец, @code{guard} соответствует, если логическое выражение
@w{@code{(<= -9 n 9)}} (обратите внимание на ссылку на @code{n}) оценивается
в не-@code{nil}. Если все эти суб-шаблоны совпадают, @code{and}
соответствует.

@anchor{pcase-example-2}
@subheading Пример: Переформулировка для @code{pcase}

Вот еще один пример, который показывает, как переформулировать простую задачу
сопостовления с её традиционной реализацией (функция @code{grok/traditional})
на задачу с использованием @code{pcase} (функции @code{grok/pcase}).  Строка
документации для обеих этих функций: ``Если OBJ является строка вида
"key:NUMBER", возвращается NUMBER (строка). В противном случае возвращается
список ("149" по умолчанию).''.  Во-первых, традиционная реализация
(@pxref{Regular Expressions}):

@example
@group
(defun grok/traditional (obj)
  (if (and (stringp obj)
           (string-match "^key:\\([[:digit:]]+\\)$" obj))
      (match-string 1 obj)
    (list "149" 'default)))
@end group

@group
(grok/traditional "key:0")   @result{} "0"
(grok/traditional "key:149") @result{} "149"
(grok/traditional 'monolith) @result{} ("149" default)
@end group
@end example

@noindent
Переформулировка демонстрирует @var{symbol} связывания, а также @code{or},
@code{and}, @code{pred}, @code{app} и @code{let}.

@example
@group
(defun grok/pcase (obj)
  (pcase obj
    ((or                                     ; @r{строка 1}
      (and                                   ; @r{строка 2}
       (pred stringp)                        ; @r{строка 3}
       (pred (string-match                   ; @r{строка 4}
              "^key:\\([[:digit:]]+\\)$"))   ; @r{строка 5}
       (app (match-string 1)                 ; @r{строка 6}
            val))                            ; @r{строка 7}
      (let val (list "149" 'default)))       ; @r{строка 8}
     val)))                                  ; @r{строка 9}
@end group

@group
(grok/pcase "key:0")   @result{} "0"
(grok/pcase "key:149") @result{} "149"
(grok/pcase 'monolith) @result{} ("149" по умолчанию)
@end group
@end example

@noindent
Основная часть @code{grok/pcase} - это одна альтернатива формы @code{pcase},
шаблоны на строках 1-8, (единственная) основная форма в строке 9.  Шаблон
@code{or}, который пытается сопоставить в свою очередь, подшаблоны
аргументов, первым @code{and} (строки 2-7), а затем @code{let} (строка 8),
пока один из них не совпадёт.

Как и в предыдущем примере (@pxref{pcase-example-1,,Example 1}), @code{and}
начинается с @code{pred} суб-шаблоном, чтобы обеспечить следующие подшаблоны
работать с объектом правильного типа (строкой, в данном случае).  Если
@w{@code{(stringp @var{expval})}} возвращает @code{nil}, @code{pred} терпит
неудачу, и, таким образом, @code{and} также терпит неудачу.

Следующая @code{pred} (строки 4-5) оценивает
@w{@code{(string-match RX @var{expval})}} и соответствует, если результат
установлен в не-@code{nil}, что означает, что @var{expval} имеет нужную
форму: @code{key:NUMBER}.  Опять же, если это невозможно, @code{pred}
терпит неудачу как и @code{and}.

И наконец (в этой серии @code{and} подшаблонов), @code{app} оценивает
@w{@code{(match-string 1 @var{expval})}} (строка 6), чтобы получить
@var{tmp} временное значение (то есть, ``NUMBER'' подстроку) и пытается
соответствовать @var{tmp} шаблону @code{val} (строка 7). Поскольку это
шаблон @var{symbol}, он соответствует безоговорочно и дополнительно
связывает @code{val} с @var{tmp}.

Теперь, когда @code{app} совпало, все @code{and} суб-шаблоны совпали, и
поэтому @code{and} совпадает.  Точно так же, как только @code{and} совпало,
@code{or} не проводит попытки сопоставления суб-шаблона @code{let}
(строка 8).

Давайте рассмотрим ситуацию, когда @code{obj} не является строкой, или это
строка неправильной  формы.  В этом случае, одна из @code{pred} (строки 3-5)
не совпадает, таким образом, @code{and} (строка 2) не совпадает, таким
образом, @code{or} (линия 1) переходит к сопоставлению под-шаблона @code{let}
(строка 8).

Во-первых, @code{let} оценивает @w{@code{(list "149" 'default)}} чтобы
получить @w{@code{("149" default)}}, в @var{exprval}, а затем пытается
сопоставить @var{exprval} с шаблоном @code{val}.  Поскольку это шаблон
@var{symbol}, он соответствует безоговорочно и дополнительно связывает
@code{val} с @var{exprval}. Теперь, когда @code{let} совпало, @code{or}
совпадает.

Обратите внимание, как оба @code{and} и @code{let} подшаблоны оканчиваются
одинаковым образом: пытаясь (всегда успешно), сопоставить @var{symbol} с
@code{val}, в процессе связывания @code{val}.  Таким образом, @code{or}
всегда соответствует и управления всегда переходит к форме тела (строка 9).
Поскольук это последняя форма тела в успешно согласованной альтернативе
@code{pcase}, это значение @code{pcase} также возвращаемое значение
@code{grok/pcase} (@pxref{What Is a Function}).

@anchor{pcase-symbol-caveats}
@subheading Предостережения для @var{символа} в Последовательностях Шаблонов

В предыдущих примерах, все последовательности шаблонов, каким-то образом
включают @var{symbol} суб-шаблон в некотором роде.  Вот некоторые важные
детали при использовании.

@enumerate
@item Когда @var{symbol} встречается более чем один раз в @var{seqpat},
вторые и последующие появления не расширяются для повторного связывания, но
расширяются для теста равенства с помощью @code{eq}.

Следующий пример показывает форму @code{pcase} с двумя пунктами и двумя
@var{seqpat}, A и B.  И А и В в первую очередь проверяются на соответствие
@var{expval} (с использованием @code{pred}), а затем связывают символы к
@code{car} и @code{cdr} из @var{expval} (с использованием @code{app} для
каждого). (ВопросControl806)

Для А, так как символ @code{st} упоминается дважды, второе упоминание
становится проверка на равенство с использованием @code{eq}.  С другой
стороны, B использует два отдельных символа, @code{s1} и @code{s2}, оба из
которых устанавлмваются независимыми привязками.

@example
@group
(defun grok (object)
  (pcase object
    ((and (pred consp)        ; seqpat A
          (app car st)        ; первое упоминание: st
          (app cdr st))       ; второе упоминание: st
     (list 'eq st))
@end group
@group
    ((and (pred consp)        ; seqpat B
          (app car s1)        ; первое упоминание: s1
          (app cdr s2))       ; первое упоминание: s2
     (list 'not-eq s1 s2))))
@end group

@group
(let ((s "yow!"))
  (grok (cons s s)))      @result{} (eq "yow!")
(grok (cons "yo!" "yo!")) @result{} (not-eq "yo!" "yo!")
(grok '(4 2))             @result{} (not-eq 4 (2))
@end group
@end example

@item Побочное действия кода на который ссылается @var{symbol} не определено.
Избегайте этого.  Например, вот две аналогичные функции.
Оба используют @code{and}, @var{symbol} и @code{guard}:

@example
@group
(defun square-double-digit-p/CLEAN (integer)
  (pcase (* integer integer)
    ((and n (guard (< 9 n 100))) (list 'yes n))
    (sorry (list 'no sorry))))

(square-double-digit-p/CLEAN 9) @result{} (да 81)
(square-double-digit-p/CLEAN 3) @result{} (не 9)
@end group

@group
(defun square-double-digit-p/MAYBE (integer)
  (pcase (* integer integer)
    ((and n (guard (< 9 (incf n) 100))) (list 'yes n))
    (sorry (list 'no sorry))))

(square-double-digit-p/MAYBE 9) @result{} (да 81)
(square-double-digit-p/MAYBE 3) @result{} (да 9)  ; @r{НЕПРАВИЛЬНО!}
@end group
@end example

@noindent
Разница заключается в @var{boolean-expression} в @code{guard}: @code{CLEAN}
ссылки @code{n} просто и непосредственно, в то время как ссылки @code{MAYBE}
@code{n} с побочным эффектом, в выражении @code{(incf n)}.  Когда
@code{integer} 3, вот что происходит:

@itemize
@item Первый @code{n} связывает его с @var{expval}, то есть, результат
вычисления @code{(* 3 3)}, или 9.

@item @var{boolean-expression} is evaluated:

@example
@group
start:   (< 9 (incf n)        100)
becomes: (< 9 (setq n (1+ n)) 100)
becomes: (< 9 (setq n (1+ 9)) 100)
@end group
@group
becomes: (< 9 (setq n 10)     100)
                                   ; @r{Побочный эффект здесь!}
becomes: (< 9       n         100) ; @r{@code{n} теперь связан с 10}
becomes: (< 9      10         100)
becomes: t
@end group
@end example

@item Так как результат оценки @code{guard} соответствия устанавливатся в
не-@code{nil}, управление переходит к формам тела @code{and} соответствия.
@end itemize

@noindent
Помимо математической некорректности, утверждая, что 9 является двузначным
числом, есть еще одна проблема, с @code{MAYBE}.  Основная форма вычисляется
ещё @code{n} раз, пока мы не увидим обновленное значение---10---ки для всех.
Что случилось?

Подводя итог, лучше, целиком избегать побочных ссылок @var{symbol} на
шаблоны, а не только в @var{boolean-expression} (in @code{guard}), но и в
@var{expr} (in @code{let}) и @var{function} (в @code{pred} и @code{app}).

@item При соответствиие, форма тела альтернативы может ссылаться на набор
символов шаблона let-привязки.  Когда @var{seqpat} обрабатывает @code{and},
это множество является объединением всех символов в каждой из его
суб-шаблонов let-привязки.  Это имеет смысл, потому что, @code{and} для
соответствия требует, чтобы все суб-шаблоны совпали.

Когда @var{seqpat} пользуется @code{or}, дело обстоит иначе: @code{or}
отработает на первом суб-шаблоне, который соответствует; остальная часть
sub-шаблонов игнорируются.  Это не имеет никакого смысла для каждого
sub-шаблона чтобы определять let-привязку другого набора символов, потому
что формы тела не имеют никакого способа определить, какой sub-шаблон
отработал соответствию и выбирать среди различных наборов.  Например,
следующее недействительно:

@example
@group
(pcase (read-number "Введите целое число: ")
  ((or (and (pred evenp)
            e-num)      ; @r{связывают @code{e-num} с @var{expval}}
       o-num)           ; @r{связывают @code{o-num} с @var{expval}}
   (list e-num o-num)))
@end group

@group
Введите целое число: 42
@error{} Значение символа как переменный, является недействительным: o-num
@end group
@group
Введите целое число: 149
@error{} значение символа как переменный, является недействительным: e-num
@end group
@end example

@noindent
Оценка формы @w{@code{(list e-num o-num)}} сигнализирует об ошибке.  Для
того, чтобы различать подшаблоны, вы можете использовать другой символ,
идентичный по имени во всех подшаблонах но различающийся по значению.
Переделывая приведенный выше пример:

@example
@group
(pcase (read-number "Введите целое число: ")
  ((and num                                ; @r{строка 1}
        (or (and (pred evenp)              ; @r{строка 2}
                 (let spin 'even))         ; @r{строка 3}
            (let spin 'odd)))              ; @r{строка 4}
   (list spin num)))                       ; @r{строка 5}
@end group

@group
Введите целое число: 42
@result{} (even 42)
@end group
@group
Введите целое число: 149
@result{} (odd 149)
@end group
@end example

@noindent
Строка 1 ``фактический вывод'' @var{expval} связывает с @code{and} и
@var{symbol} (в данном случае, @code{num}).  В строке 2, @code{or} вначале
отрабатывает таким же образом, как и раньше, но вместо того, чтобы связывать
различные символы, использует дважды @code{let} (строки 3-4), чтобы связать
один и тот же символ @code{spin} в обоих подшаблонах.  Значение @code{spin}
различает суб-шаблоны. Тело формы ссылается на оба символа (строка 5).
@end enumerate

@node Extending pcase
@subsection Расширение @code{pcase}
@cindex pcase, defining new kinds of patterns

Макрос @code{pcase} поддерживает несколько видов шаблонов
(@pxref{Pattern-Matching Conditional}).
Можно добавить поддержку других видов шаблонов используя
@code{pcase-defmacro} макрос.

@defmac pcase-defmacro name args [doc] &rest body
Определить новый вид шаблона для @code{pcase}, который будет вызыватся формой
@w{@code{(@var{name} @var{actual-args})}}.
@code{pcase} макрос это вызов функции, которая оценивает @var{body}, чтобы
переписать Вызванный шаблон в какой-то другой, в среде, где @var{args}
связан с @var{actual-args}.

Кроме того, организовывается отображение @var{doc} вместе с @code{pcase} в
строку документации.  По соглашению, для @var{doc} требуется использовать
@code{EXPVAL} обозначения результата оценки @var{expression} (первый
аргумент в @code{pcase}).
@end defmac

@noindent
Как правило, @var{body} переписывает вызванный шаблон, для использования
более простых шаблонов.  Хотя все шаблоны в конечном счете сводятся к
основному шаблону, нельзя использовать основные модели @code{body} сразу.
Следующий пример определяет два шаблона, с именами @code{less-than} и
@code{integer-less-than}.

@example
@group
(pcase-defmacro less-than (n)
  "Matches if EXPVAL is a number less than N."
  `(pred (> ,n)))
@end group

@group
(pcase-defmacro integer-less-than (n)
  "Matches if EXPVAL is an integer less than N."
  `(and (pred integerp)
        (less-than ,n)))
@end group
@end example

@noindent
Обратите внимание, что в строке документации @var{args} (в данном случае
только один: @code{n}) упоменается обычным способом, а также упомянуто
соглашение @code{EXPVAL}.  Первый переписывают (т.е. @var{body} для
@code{less-than}) использует один основной шаблон с: @code{pred}.  Второй
использует два основных шаблона с: @code{and} и @code{pred}, а также вновь
определенный шаблон @code{less-than}.  Оба используют единую конструкцию
кавычки (@pxref{Backquote}).

@node Backquote Patterns
@subsection Шаблоны в Обратных Кавычках
@cindex backquote-style patterns
@cindex matching, structural
@cindex structural matching

В этом подразделе описаны @dfn{шаблоны в обратных кавычках}, набор шаблонов,
облегчающих структурное сопоставление. Для примера,
@pxref{Pattern-Matching Conditional}.

Шаблоны в обратных кавычках - мощный набор @code{pcase} расширений шаблонов
(созданных с помощью @code{pcase-defmacro}), которые позволяют легко
сопоставить @var{expval} со спецификациями его @emph{структуры}.

Например, чтобы соответствовать @var{expval}, который должен быть списком из
двух элементов, первый элемент которого представляет собой определенную
строку, а второй элемент является любое значение, вы можете написать
основной шаблон:

@example
@group
(and (pred listp)
     ls
@end group
@group
     (guard (= 2 (length ls)))
     (guard (string= "first" (car ls)))
     (let second-elem (cadr ls)))
@end group
@end example

@noindent
или вы можете написать эквивалентный шаблон в стиле обратных кавычек:

@example
`("first" ,second-elem)
@end example

@noindent
Шаблон в стиле обратных кавычек более краткий, напоминает структуру
@var{expval}, и избегает привязки @code{ls}.

Стиль шаблона в обратных кавычках имеет вид @code{`@var{qpat}} где
@var{qpat} может иметь следующие формы:

@table @code

@item (@var{qpat1} . @var{qpat2})
Срабатывает, если @var{expval} cons-ячейки, @code{car} которой соответствует
@var{qpat1} и чей @code{cdr} соответствует @var{qpat2}.  Это легко обобщается
на списки, как в  @w{@code{(@var{qpat1} @var{qpat2} @dots{})}}.

@item [@var{qpat1} @var{qpat2} @dots{} @var{qpatm}]
Срабатывает, если @var{expval} является вектором длиной @var{m}, чьи элементы
соответствуют @code{0}..@code{(@var{m}-1)} @var{qpat1}, @var{qpat2} @dots{} @var{qpatm}, соответственно.

@item @var{symbol}
@itemx @var{keyword}
@itemx @var{integer}
@itemx @var{string}
Совпадение, если соответствующий элемент @var{expval} удовлетворяет
@code{equal} к указанному буквальному объекту.
Следует отметить, что, помимо @var{symbol}, это тот же самый набор
самостоятельно процитированных литералов объектов, которые являются
приемлемыми в качестве основного шаблона.

@item ,@var{pattern}
Совпадение, если соответствующий элемент @var{expval} соответствует
@var{pattern}.  Обратите внимание, что @var{pattern} является любым видом,
поддерживаемым @code{pcase}.  (В приведенном выше примере, @code{second-elem}
является основным @var{symbol} шаблона, поэтому он соответствует чему угодно,
и let-связанным с @code{second-elem}.)
@end table

@dfn{Связанный элемент} представляет собой часть @var{expval}, которая
находится в той же позиции, что и в структурной позиции @var{qpat} в шаблоне
в стиле обратных кавычек.  (В приведенном выше примере, соответствующий
элемент @code{second-elem} является вторым элементом @var{expval}.)

Ниже приведен пример использования @code{pcase} реализации простого
интерпретатора для небольшого языка выражений (заметим, что это требует
лексического связывания для лямбда-выражения в альтернативе @code{fn}, чтобы
должным образом захватить @code{body} и @code{arg} (@pxref{Lexical Binding}):

@example
@group
(defun evaluate (form env)
  (pcase form
    (`(add ,x ,y)       (+ (evaluate x env)
                           (evaluate y env)))
@end group
@group
    (`(call ,fun ,arg)  (funcall (evaluate fun env)
                                 (evaluate arg env)))
    (`(fn ,arg ,body)   (lambda (val)
                          (evaluate body (cons (cons arg val)
                                               env))))
@end group
@group
    ((pred numberp)     form)
    ((pred symbolp)     (cdr (assq form env)))
    (_                  (error "Syntax error: %S" form))))
@end group
@end example

@noindent
Первые три альтернативы используют шаблоны в обратных кавычках.
@code{`(add ,x ,y)} это шаблон, который проверяет, @code{form} как список из
трех элементов, начиная с буквального символа @code{add}, затем извлекает
второй и третий элементы и связывают их с символами @code{x} и @code{y},
соответственно.  Тело альтернативы оценивает @code{x} и @code{y} и добавляет
результаты.  Аналогичным образом, @code{call} альтернатива реализует функцию
вызова, а условие реализует @code{fn} анонимное определение функции.

Остальные альтернативы используют основные шаблоны.  @code{(pred numberp)}
совпадает, если @code{form} является числом.  При соответствии, оценивается
его тело формы.  @code{(pred symbolp)} совпадает, если @code{form} является
символом.  При совпадении с @code{env}, тело формы возвращает его ассоциацию.
Наконец, @code{_} это универсальный шаблон, который соответствует чему
угодно, поэтому подходит для представления синтаксических ошибок.

Вот некоторые примеры программ в этом небольшом языке, в том числе их
результаты оценки:

@example
(evaluate '(add 1 2) nil)                 @result{} 3
(evaluate '(add x y) '((x . 1) (y . 2)))  @result{} 3
(evaluate '(call (fn x (add 1 x)) 2) nil) @result{} 3
(evaluate '(sub 1 2) nil)                 @result{} error
@end example

@node Destructuring with pcase Patterns
@subsection Деструктуризация Шаблонов @code{pcase}
@cindex destructuring with pcase patterns

@code{pcase} с помощью шаблоов выражает не только условие о форме объектов,
которые они могут совпадать, но они также может извлечь дополнительные поля
этих объектов.  Например, мы можем извлечь 2 элемента из списка, который
является значением переменной @code{my-list} со следующим кодом:

@example
  (pcase my-list
    (`(add ,x ,y)  (message "Contains %S and %S" x y)))
@end example

Это позволяет не только извлечь @code{x} и @code{y}, но будет дополнительно
проверенно, что @code{my-list} представляет собой список, содержащий ровно
3 элемента и чей первый элемент является символом @code{add}.  Если
какое-либо из этих условий не выполняется, @code{pcase} немедленно
возвращает @code{nil} без вызова @code{message}.

Извлечение нескольких значений, хранящихся в объекте известно как
@dfn{деструктуризация}.  Использование шаблонов с @code{pcase} позволяет
выполнять @dfn{деструктуризационную привязку}, похожую на локальное
связывание (@pxref{Local Variables}), но обрабатывает несколько значений
элементов в переменной, извлекая эти значения из объекта совместимой
структуры.

Макросы, описанные в этом разделе, используют @code{pcase} с шаблонами для
выполнения деструктуризационного связывания.  Чтобы это сработало, объект
должен иметь совместимую структуру, то есть соответствовать шаблону, что в
итоге позволяет извлекать подполя объекта.  Например:

@example
  (pcase-let ((`(add ,x ,y) my-list))
    (message "Contains %S and %S" x y))
@end example

@noindent
происходит то же самое, как и в предыдущем примере, за исключением того, что
непосредственно производится попытка извлечь @code{x} и @code{y} из
@code{my-list} без предварительной проверки, если @code{my-list} список,
который имеет нужное количество элементов и имеет @code{add} в качестве
первого элемента.  Точное поведение, когда объект фактически не
соответствует шаблону не определен, хотя тело не будет молча пропущено:
сигнализируется либо ошибка или тело отработает с некоторыми переменными,
потенциально связанными с произвольными значениями, например @code{nil}.

Шаблоны в pcase, которые полезны для деструктурированных привязок, обычно
записываются в стиле @ref{Backquote Patterns}, поскольку могут выразить
специфическую структуру объектов, которым будут соответствовать.

В качестве альтернативного средства для деструктурированного связывания,
смотреть @ref{seq-let}.

@defmac pcase-let bindings body@dots{}
Выполняется деструктуризированное связывание переменных в соответствии с
@var{bindings}, а затем оценивается @var{body}.

@var{bindings} представляет собой список привязок вида
@w{@code{(@var{pattern} @var{exp})}}, где @var{exp} является выражением
для оценки и @var{pattern} является шаблоном @code{pcase}.

Все @var{exp} вычисляются в первую очередь, после чего они сопоставляются
с их соответствующими @var{pattern}, вводя новые привязки переменных,
которые затем могут быть использованы внутри @var{body}.  Cвязывание
переменных производится путём деструткризированной привязки элементов шаблона
@var{pattern} к значениям соответствующих элементов оцениваемого @var{exp}.
@end defmac

@defmac pcase-let* bindings body@dots{}
Выполняется деструктуризированное связывание переменных в соответствии с
@var{bindings}, а затем оценивается @var{body}.

@var{bindings} представляет собой список привязок вида
@code{(@var{pattern} @var{exp})}, где @var{exp} является выражением для
оценки и @var{pattern} является шаблоном @code{pcase}.  Связывание переменных
производится путём деструктуризированного связывания элементов @var{pattern}
к значениям соответствующих элементов оцениваемого @var{exp}.

В отличие от @code{pcase-let} и так же, как @code{let*}, каждое @var{exp}
сравнивается с соответствующим ему шаблону @var{pattern} перед обработкой
следующей привязки элемента @var{bindings}, поэтому привязки переменных,
введенные в каждой одной привязки @var{bindings} доступны @var{exp}s 
привязки @var{bindings} в дополнение доступности в теле @var{body}.
@end defmac

@defmac pcase-dolist (pattern list) body@dots{}
Выполняет тело @var{body} один раз для каждого элемента списка @var{list},
на каждой итерации, выполняя деструтурирующее связывания переменных
шаблона @var{pattern} к значениям соответствующих подполей элемента списка
@var{list}.  Привязка выполняются как бы и по @code{pcase-let}.  Когда
шаблон @var{pattern} является простой переменной, это в конечном итоге
эквивалентно @code{dolist} (@pxref{Iteration}).
@end defmac


@node Iteration
@section Итерация
@cindex iteration
@cindex recursion
@cindex forms, iteration

  Итерация означает повторное выполнение части программы.  Например, нужно
  повторить некоторые вычисления один раз для каждого элемента списка или
  один раз для каждого целого числа от 0 до @var{n}.  Сделать это в Emacs
  Lisp можно используя специальную форму @code{while}:

@defspec while condition forms@dots{}
Выражение @code{while} сначала вычисляет состояния @var{condition}.  Если
установленно в не-@code{nil}, оценивается тело формы @var{forms} в текстовом
порядке.  Затем переоценивает состояние @var{condition}, и если оно снова
установлено в не-@code{nil}, снова оценивается тело формы @var{forms}.  Этот
процесс повторяется до тех пор, состояние @var{condition} будет установлено в
@code{nil}.

Нет ограничений на количество итераций, которые могут произойти.  Цикл будет
продолжаться до тех пор, пока либо состояние @var{condition} не будет
установлено в @code{nil} либо не произойдёт выход @code{throw} из него
(@pxref{Nonlocal Exits}).

Оценка формы @code{while} всегда @code{nil}.

@example
@group
(setq num 0)
     @result{} 0
@end group
@group
(while (< num 4)
  (princ (format "Iteration %d." num))
  (setq num (1+ num)))
     @print{} Iteration 0.
     @print{} Iteration 1.
     @print{} Iteration 2.
     @print{} Iteration 3.
     @result{} nil
@end group
@end example

Для реализации выполнения инструкций в итерации цикла до проверки состояния,
поместите инструкции в форму @code{progn} в качестве первого аргумента
@code{while}, как показано здесь:

@example
@group
(while (progn
         (forward-line 1)
         (not (looking-at "^$"))))
@end group
@end example

@noindent
Здесь точка перемещается вперед на одну строку и движется по строке до тех
пор, пока не достигнет пустой строки.   Особенность такого подхода в том, что
форма @code{while} не имеет тела инструкции, только инструкцию состояния
(которая кроме проверки, также перемещает точку).
@end defspec

  @code{dolist} и @code{dotimes} макросы обеспечивают удобный способ, чтобы
  написать два общих вида цикла.

@defmac dolist (var list [result]) body@dots{}
Конструкция выполняет тело формы @var{body}, один раз для каждого элемента
списка @var{list}, локально связывая переменную @var{var} для хранения
текущего элемента.  Затем возвращает значение оценки переменной @var{result}
или @code{nil}, если @var{result} не задано.  Например, вот как вы можете
использовать @code{dolist} для определения функции @code{reverse}:

@example
(defun reverse (list)
  (let (value)
    (dolist (elt list value)
      (setq value (cons elt value)))))
@end example
@end defmac

@defmac dotimes (var count [result]) body@dots{}
Конструкция оценивает тело формы @var{body}, один раз для каждого целого
числа, от 0 (включительно) до @var{count} (исключительно), связывая
переменную @var{var} с целым числом текущей итерации.  Затем возвращает
значение оценки @var{result} или @code{nil}, если @var{result} опущен.
Ниже приведен пример использования @code{dotimes} сделать что-то 100 раз:

@example
(dotimes (i 100)
  (insert "Я не буду выполнять абсурдные приказы\n"))
@end example
@end defmac

@node Generators
@section Генераторы
@cindex generators

  @dfn{Генератор} представляет из себя функцию, которая производит
  потенциально бесконечный поток выполнения.  Каждый раз, когда функция
  производит значение, приостанавливается и ждет вызывающего абонента для
  запроса следующего значения. (ВопросControl1352)

@defmac iter-defun name args [doc] [declare] [interactive] body@dots{}
@code{iter-defun} определяет функцию генератора.  Функция генератора имеет
сигнатуру нормальной функции, но работает по-другому.  Вместо выполнения
@var{body} при вызове функции генератора, возвращается объект итератора.
Этот итератор запускает @var{body} для генерации значений, выдачи значений и
пауз, в местах появления @code{iter-yield} или @code{iter-yield-from}.  Когда
@var{body} возвращается, как правило, @code{iter-next} сигнализирует
@code{iter-end-of-sequence} с @var{body} результатом в качестве данных
состояния.

Любой вид кода Lisp действует внутри @var{body}, но @code{iter-yield} и
@code{iter-yield-from} не могут появляться внутри формы
@code{unwind-protect}.

@end defmac

@defmac iter-lambda args [doc] [interactive] body@dots{}
@code{iter-lambda} создаёт безымянную функцию генератора, которая работает
точно так же, как функции генератора созданная @code{iter-defun}.
@end defmac

@defmac iter-yield value
Когда появляется внутри функции генератора, @code{iter-yield} указывает на
то, что текущий итератор должен сделать паузу и вернуть @var{value} из
@code{iter-next}.  @code{iter-yield} принимает значение параметра
@code{value} следующего вызова @code{iter-next}.
@end defmac

@defmac iter-yield-from iterator
@code{iter-yield-from} дает все значения, которые @var{iterator} производит
и определяет этой функции @var{iterator} когда генератор возвращается в
нормальном режиме.  Пока существует контроль, @var{iterator} принимает
значения, отправленные итератору с помощью @code{iter-next}.
@end defmac

  Для того, чтобы использовать функцию генератора, сначала требуется вызвать
  её как обычно, создав объект @dfn{iterator}.  Итератор - это конкретный
  экземпляр генератора.  Затем используется @code{iter-next} для извлечения
  значений из этого итератора.  Когда больше нет значений, чтобы получить из
  итератора, @code{iter-next} используется состояние
  @code{iter-end-of-sequence} с конечным значением итератора.

Важно отметить, что тело функции генератора выполняется только внутри вызова
@code{iter-next}.  Вызов функции, определенной с помощью @code{iter-defun}
создаёт итератор; нужно управлять этим итератором с помощью @code{iter-next}
для получения чего-нибудь полезного.  Каждый вызов функции генератора
производит @emph{разные} итераторы, каждый со своим собственным состоянием.

@defun iter-next iterator value
Получение следующего значения из @var{iterator}.  Если нет больше значений,
которые требуется сгенерировать (поскольку @var{iterator} вернулас функци.
генератора), @code{iter-next} сигнализирует состояние
@code{iter-end-of-sequence}; значение данных, связанное с этим условием
является значением, с которым @var{iterator} вернула функция генератора.

@var{value} отправляется в итератор и становится значением, которое
@code{iter-yield} оценивает.  @var{value} игнорируется для первого вызова
@code{iter-next} данного итератора, так как в начале функция генератора
@var{iterator}, функция генератор не оценивает какую-либо форму
@code{iter-yield}. (ВопросControl1413)
@end defun

@defun iter-close iterator
Если @var{iterator} подвешен внутри @code{unwind-protect}'s @code{bodyform} и
становится недоступным, Emacs в конечном итоге запустит UNWIND обработчиков
после сбора мусора прохода.  (Обратите внимание, что @code{iter-yield}
не допускается внутри @code{unwind-protect}'s @code{unwindforms}.).  Для
гарантии запуска этих обработчиков, используйте @code{iter-close}.
@end defun

Для облегчения работы с итераторами предусмотрены некоторые удобные функции:

@defmac iter-do (var iterator) body @dots{}
Оценивается тело @var{body} с переменной @var{var}, связанной с каждым
значением, которое @var{iterator} производит.
@end defmac

Common Lisp объект цикла также содержит функции для работы с итераторами.
@xref{Loop Facility,,,cl,Common Lisp Extensions}.

Следующий фрагмент кода демонстрирует некоторые важные принципы работы
с итераторами.

@example
(require 'generator)
(iter-defun my-iter (x)
  (iter-yield (1+ (iter-yield (1+ x))))
   ;; Нормальное возвращение
  -1)

(let* ((iter (my-iter 5))
       (iter2 (my-iter 0)))
  ;; Вывод 6
  (print (iter-next iter))
  ;; Вывод 9
  (print (iter-next iter 8))
  ;; Вывод 1; iter и iter2 имеют различные состояния
  (print (iter-next iter2 nil))

  ;; Мы ожидаем, что последовательность iter завершится сейчас
  (condition-case x
      (iter-next iter)
    (iter-end-of-sequence
      ;; Вывод -1, которое обычно возвращает my-iter
      (print (cdr x)))))
@end example

@node Nonlocal Exits
@section Нелокальные Выходы
@cindex nonlocal exits

  @dfn{Нелокальный выход} - это передача управления от одной точки в
  программе на другую удаленную точку.  Нелокальные выходы могут происходить
  в Emacs Lisp в результате ошибок; можно также использовать их под явным
  контролем.  Нелокальные выходы разрывают все привязки переменных,
  сделанные конструкциями осуществляющими выход.

@menu
* Catch and Throw::     Нелокальные выходы для собственных целей программы.
* Examples of Catch::   Каким образом записать нелокальные выходы.
* Errors::              Как ошибки сигнализируются и обрабатываются.
* Cleanups::            Организация запуска формы очистки при ошибке.
@end menu

@node Catch and Throw
@subsection Явные Нелокальные Выходы: @code{catch} и @code{throw}
@cindex forms for nonlocal exits

  Большинство конструкций управления влияют только на поток управления
  внутри самой конструкции.  Функция @code{throw} является исключением из
  этого правила нормального выполнения программы: она выполняет нелокальный
  выход по требованию.  (Есть и другие исключения, но они предназначены для
  обработки только ошибок.)   @code{throw} используется внутри @code{catch},
  и возвращается к этому @code{catch}. Например: (ВопросControl1487)

@example
@group
(defun foo-outer ()
  (catch 'foo
    (foo-inner)))

(defun foo-inner ()
  @dots{}
  (if x
      (throw 'foo t))
  @dots{})
@end group
@end example

@noindent
Форма @code{throw}, если выполняется, передает управление прямо назад к
соответствующему @code{catch}, который возвращает немедленно.  Код после
@code{throw} не выполняется.  Второй аргумент @code{throw} используется в
качестве возвращаемого значения @code{catch}.

  Функция @code{throw} находит совпадение @code{catch} на основе первого
  аргумента: ищется @code{catch} чей первый аргумент @code{eq} к одному
  указанному в @code{throw}.  Если @code{catch} применено более одного раза,
  приоритет за самым внутренним.  Таким образом, в приведенном выше примере,
  @code{throw} указывает @code{foo} а @code{catch} указывает @code{foo-outer}
  указывает тот же символ, так что @code{catch} является применимым
  (при условии, что нет никакого другого соответствия @code{catch} между
  ними).(ВопросControl1516)

  Выполнение @code{throw} производит выход из всех Lisp конструкций до
  согласования @code{catch}, включая вызовы функций.  Когда конструкции
  привязки, такие как @code{let} или вызовы функций, завеншаются таким
  образом, привязка не выполняется, так же, как при обычном выходе этих
  конструкций (@pxref{Local Variables}).  Кроме того, @code{throw}
  восстанавливает буфер и позицию, сохраненную @code{save-excursion}
  (@pxref{Excursions}) и статус сужения буфера, сохраненную
  @code{save-restriction}.  Запускаются все очистки, установленные с
  помощью специальной формы @code{unwind-protect}, при выходе из этой формы.
  (@pxref{Cleanups}).

  Не требуется лексического появления @code{throw} для перехода в
  @code{catch}.  Может одинаково хорошо быть вызван из другой функции,
  вызываемой в @code{catch}.  Пока действия @code{throw} происходят в
  хронологическом порядке после входа в @code{catch}, и хронологическом
  порядке перед выходом из него, имеется доступ к этому @code{catch}. Именно
  поэтому @code{throw} может быть использована в таких командах, как
  @code{exit-recursive-edit}, которые выходят обратно в цикл команд
  редактора (@pxref{Recursive Editing}).

@cindex CL note---only @code{throw} in Emacs
@quotation
@b{Common Lisp предупреждение:} Большинство других версий Lisp, включая
Common Lisp, имеют несколько способов передачи непоследовательного
управления: @code{return}, @code{return-from}, и @code{go}, например.  Emacs
Lisp имеет только @code{throw}.  @file{cl-lib} библиотека предоставляет
версии некоторых из них.
@xref{Blocks and Exits,,,cl,Common Lisp Extensions}.
@end quotation

@defspec catch tag body@dots{}
@cindex tag on run time stack
@code{catch} устанавливает точку возврата для функции @code{throw}.  Точка
возврата отличаются от других таких точек возврата по тегу @var{tag}, который
может быть любым объектом Lisp, за исключением бъекта @code{nil}.  Аргумент
@var{tag} оценивается, как правило, прежде чем устанавливается точка
возврата.

С присутствующей точкой возврата, @code{catch} оценивает форму @var{body} в
текстовом порядке.  Если формы выполнения нормально (без ошибок или
нелокального выхода) значение последней формы тела возвращается из
@code{catch}.

Если @code{throw} выполняется во время выполнения @var{body} с указанным
значением тега @var{tag}, оценка формы @code{catch} немедленно завершается;
возвращается то значение, которое указано в качестве второго аргумента
@code{throw}.
@end defspec

@defun throw tag value
Целью @code{throw} является возвращение с точки возврата ранее установленной
в @code{catch}.  Аргумент @var{tag} используется для выбора среди различных
существующих точек возврата; должно быть соответствие @code{eq} к значению,
указанному в @code{catch}.  Если несколько точек соответствуют тегу
@var{tag}, используется самый внутренний.

Аргумент @var{value} используется в качестве значения для возврата из
этого @code{catch}.

@kindex no-catch
Если нет точки возврата с тегаом @var{tag}, то сигнализируется ошибка
@code{no-catch} данных @code{(@var{tag} @var{value})}.
@end defun

@node Examples of Catch
@subsection Примеры @code{catch} и @code{throw}

  Один из способов использовать @code{catch} и @code{throw}, чтобы выйти из
  двукратно вложенного цикла.  (В большинстве языков, это будет сделано с
  помощью @code{goto}.).   Здесь мы вычисляем @code{(foo @var{i} @var{j})}
  для @var{i} и @var{j} изменяющихся от 0 до 9:

@example
@group
(defun search-foo ()
  (catch 'loop
    (let ((i 0))
      (while (< i 10)
        (let ((j 0))
          (while (< j 10)
            (if (foo i j)
                (throw 'loop (list i j)))
            (setq j (1+ j))))
        (setq i (1+ i))))))
@end group
@end example

@noindent
Если @code{foo} когда-либо возвращает не-@code{nil}, немедленно прекратить и
вернуть список @var{i} и @var{j}.  Если @code{foo} всегда возвращает
@code{nil}, в @code{catch} возвращается нормально, а значение @code{nil}, так
как это результат оценки @code{while}.

  Вот два хитрых примера, немного разные, показывают две точки возврата
  сразу.  Во-первых, две точки возврата с тем же тегом, @code{hack}:

@example
@group
(defun catch2 (tag)
  (catch tag
    (throw 'hack 'yes)))
@result{} catch2
@end group

@group
(catch 'hack
  (print (catch2 'hack))
  'no)
@print{} yes
@result{} no
@end group
@end example

@noindent
Поскольку обе точки возврата имеют метки, которые соответствуют @code{throw},
происходит переход во внутрений, установленный в @code{catch2}.  Поэтому
@code{catch2} возвращается нормально со значением @code{yes}, и это значение
выводится.  И, наконец, вторая форма тела во внешнем @code{catch}, то есть
@code{'no}, оценивается и возвращается из внешнего @code{catch}.

  Теперь давайте изменим рассуждения, приведенные в @code{catch2}:

@example
@group
(catch 'hack
  (print (catch2 'quux))
  'no)
@result{} yes
@end group
@end example

@noindent
У нас есть еще две возвратные точки, но на этот раз только внешняя имеет тег
@code{hack}; а внутренняя имеет тег @code{quux}.  Поэтому внешний
@code{throw} по отношению к @code{catch}, возвращает значение @code{yes}.
Функция @code{print} никогда не вызывается, а тело-форма @code{'no} никогда
не оценивается.  (ВопросControl1654)

@node Errors
@subsection Ошибки
@cindex errors

  Когда Emacs Lisp попытки оценить форму, которая, по некоторым причинам,
  не может быть оценена, он @dfn{сигнализирует} @dfn{ошибку}.

  Когда поступает сигнал об ошибке, по умолчанию Emacs выводит сообщение об
  ошибке и прекращает выполнение текущей команды.  Это то, что нужно делать
  в большинстве случаев, например, если вы наберете @kbd{C-f} в конце буфера.

  В сложных программах, просто прекращение не может быть то, что нужно.
  Например, программа могла внести временные изменения в структуры данных или
  создать временные буферы, которые должны быть удалены до завершения
  программы.  В таких случаях нужно использовать @code{unwind-protect} и
  установить @dfn{выражения очистки}, которые оценеваются в случае ошибки.
  (@xref{Cleanups}.).   Иногда, требуется продолжить выполнение программы
  несмотря на ошибку в подпрограмме.  В этих случаях нужно использовать
  @code{condition-case} установить @dfn{обработчики ошибок} для
  восстановления управления в случае возникновения ошибки.

  Не поддавайтесь искушению использовать обработку ошибок для контроля
  передачи управления из одной части программы в другую; используйте
  @code{catch} и @code{throw} вместо этого.  @xref{Catch and Throw}.

@menu
* Signaling Errors::      Как сообщить об ошибке.
* Processing of Errors::  Что Emacs делает, когда вы сообщаете об ошибке.
* Handling Errors::       Как перехватывать ошибки и продолжать выполнение.
* Error Symbols::         Как классифицируются ошибки для их захвата.
@end menu

@node Signaling Errors
@subsubsection Как Сообщить об Ошибке
@cindex signaling errors

   @dfn{Сигнал} об ошибке означает начало обработки ошибки.  Обработка ошибок
   обычно прерывает всю или часть выполняющейся программы и возвращается в
   точку, которая настроена для обработки ошибки
   (@pxref{Processing of Errors}).  Здесь описывается, как реализован
   сигнал об ошибке.

  Большинство ошибок в Lisp сигнализируют примитивы автоматически, которые
  вызваны не по назначению, например, если вы попытаетесь взять @sc{car}
  целого числа или двигать точку вперед в конце буфера.  Возможно также
  сигнализировать ошибки в явном виде с функциями @code{error} и
  @code{signal}.

  Выход, который происходит, когда пользователь набирает @kbd{C-g}, не
  считается ошибкой, но он обрабатывается почти как ошибка.
@xref{Quitting}.

  Каждая ошибка так или иначе указывает сообщение об ошибке.  В сообщение
  должно быть указано, что не так (``File does not exist
  (Файл не существует)''), не так (``File must exist (Файл должен
  существовать)'').  По соглашению в Emacs Lisp сообщения об ошибках должны
  начинаться с заглавной буквой, но не должны заканчиваться с каким-либо
  знаками препинания.

@defun error format-string &rest args
Функция сигнализирует об ошибке сообщением об ошибке, построенном с
применением @code{format-message} (@pxref{Formatting Strings}) к
@var{format-string} и @var{args}.

Эти примеры показывают типичное использование @code{error}:

@example
@group
(error "Это ошибка -- попробуйте что-то другое")
     @error{} Это ошибка -- попробуйте что-то другое
@end group

@group
(error "Неправильное имя `%s'" "A%%B")
     @error{} Неправильное имя ‘A%%B’
@end group
@end example

@code{error} работает, вызывая @code{signal} с двумя аргументами: символом
ошибки @code{error}, и списком, содержащим строку, возвращаемую
@code{format-message}.

Как правило, апостроф и ударение при форматировании переводятся на
соответствующие перевёрнутые кавычки, например, @t{"Отсутствует `%s'"} может привести к @t{"Отсутствует ‘foo’"}.  @xref{Text Quoting Style}, о том, как
влиять или запретить этот перевод.

@strong{Предупреждение:} Если требуется использовать свою собственную строку
в качестве дословного сообщения об ошибке, не пишиться
@code{(error @var{string})}.  Если @var{string} содержит @samp{%}, @samp{`}
или @samp{'} это может быть переформатировано, с нежелательными результатами.
Вместо этого используется @code{(error "%s" @var{string})}.
@end defun

@defun signal error-symbol data
@anchor{Definition of signal}
Эта функция сигнализирует об ошибке с именем, @var{error-symbol}.  Аргумент
@var{data} представляет собой список дополнительных Lisp объектов имеющих
отношение к обстоятельствам ошибки.

Аргумент @var{error-symbol} должен быть @dfn{символом ошибки}--- символом,
определенным с помощью @code{define-error}.  Именно так Emacs Lisp
классифицирует различные виды ошибок.  @xref{Error Symbols}, для описания
символов ошибок, условий ошибки и имён условий.

Если ошибка не обрабатывается, два аргумента используются в выводе печати
сообщения об ошибке.  Как правило, это сообщение об ошибке обеспечивается
@code{error-message} свойством @var{error-symbol}.  Если @var{data}
установленно в не-@code{nil}, это сопровождается двоеточием и списком
невычисленных элементов @var{data}, разделенных запятыми.  Для @code{error},
сообщение об ошибке является @sc{car} из @var{data} (что должно быть
строкой).  Подкатегории @code{file-error} обрабатываются специальным образом.

Количество и природа объектов @var{data} зависит от @var{error-symbol}.
Например, с ошибкой @code{wrong-type-argument}, должно быть два объекта в
списке: предикат, который описывает ожидаемый тип и объект, который не в
состоянии соответствовать этому типу.

И @var{error-symbol} и @var{data} доступны для любых обработчиков ошибок,
которые обрабатывают ошибки: @code{condition-case} связывая локальную
переменную в список вида @code{(@var{error-symbol} .@:
@var{data})} (@pxref{Handling Errors}).

Функция @code{signal} ничего не возвращает.
@c (хотя в более ранних версиях Emacs иногда может).

@example
@group
(signal 'wrong-number-of-arguments '(x y))
     @error{} Wrong number of arguments: x, y
@end group

@group
(signal 'no-such-error '("Моё неизвестное состояние ошибки"))
     @error{} peculiar error: "Моё неизвестное состояние ошибки"
@end group
@end example
@end defun

@cindex user errors, signaling
@defun user-error format-string &rest args
Функция ведет себя так же, как @code{error}, за исключением того, что
используется символ ошибки @code{user-error} а не @code{error}.  Как следует
из названия, это предназначено для сообщения об ошибках со стороны
пользователя, а не для ошибок в самом коде.  Например, если вы пытаетесь
использовать команду @code{Info-history-back} (@kbd{l}), чтобы вернуться за
пределы начала вошей истории просмотра Info, Emacs сигнализирует об ошибке
@code{user-error}.  Такие ошибки не вызывают вход в отладчик, даже когда
@code{debug-on-error} установленно в не-@code{nil}.
@xref{Error Debugging}.
@end defun

@cindex CL note---no continuable errors
@quotation
@b{Common Lisp замечание:} Emacs Lisp не имеет ничего подобного Common Lisp
относительно концепции продолжаемых ошибок.
@end quotation

@node Processing of Errors
@subsubsection Как Emacs Обрабатывает Ошибки
@cindex processing of errors

Когда сигнализируется ошибка, @code{signal} ищет активный @dfn{обработчик}
для ошибки.  Обработчик представляет собой последовательность Lisp выражений,
предназначенных для исполнения, если ошибка происходит в рамках программы
Lisp.  Если ошибка имеет применимый обработчик, обработчик выполняется, и
управление возобновляется после обработчика.  Обработчик выполняется в среде
@code{condition-case}, создавшей его; все функции, которые вызываются в
пределах этого @code{condition-case} уже завершены, и обработчик не может
вернуться к ним.

Если для ошибки нет требуемого обработчика, прерывается текущая команда и
возвращается управление циклу команд редактора.  (У командного цикла команд
есть неявный обработчик для всех типов ошибок.)  Обработчик командного цикла
использует символ ошибки и связанные с ними данные для вывода печати
сообщения об ошибке.  Можно использовать переменную
@code{command-error-function} для управления, вот как это делается:

@defvar command-error-function
Переменная, установленная в не-@code{nil}, определяет функцию, которая
используется для обработки ошибок, которые возвращают контроль в командный
цикл Emacs.  Функция принимает три аргумента: @var{data}, список той же
формы, которую @code{condition-case} будет связывать с её переменными;
@var{context}, строка, описывающая ситуацию, в которой произошла ошибка, или
(чаще) @code{nil}, что указывает @var{вызов} примитивной функции Lisp,
сигнализации об ошибке.
@end defvar

@cindex @code{debug-on-error} use
Ошибка, которая не имеет явного обработчика может вызвать Lisp отладчик.
Отладчик включен, если переменная @code{debug-on-error}
(@pxref{Error Debugging}) установлена в не-@code{nil}.  В отличии от
обработчиков ошибок, отладчик работает в среде ошибки, поэтому существует
возможность проверить значения переменных именно те, которые были в момент
ошибки.

@node Handling Errors
@subsubsection Написание Кода для Обработки Ошибки
@cindex error handler
@cindex handling errors
@cindex forms for handling errors

  Обычный эффект подачи сигнала об ошибке - завершить выполняемую команду и
  немедленно вернуться к командному циклу редактора Emacs.  Можно
  организовать перехват ошибок, возникающих в рамках вашей программы путем
  создания обработчика ошибок, со специальной формой @code{condition-case}.
  Простой пример выглядит следующим образом:

@example
@group
(condition-case nil
    (delete-file filename)
  (error nil))
@end group
@end example

@noindent
Это удаляет файл с именем @var{filename}, отлавливая любую ошибку и
возвращая @code{nil}, если произошла ошибка.  (Вы можете использовать
@code{ignore-errors} макрос для такого простого случая, как этот.  см. Ниже)

  @code{condition-case} конструкция часто используется для перехвата ошибок,
  которые предсказуемы, таких как невозможность открыть файл при вызове
  @code{insert-file-contents}.  Также используется для перехвата ошибок,
  которые совершенно непредсказуемы, например, когда программа вычисляет
  выражение введённое пользователем.

  Второй аргумент @code{condition-case} называется @dfn{защищённой формой}.
  (В приведенном выше примере, защищенная форма является вызовом
  @code{delete-file}.)   Обработчики ошибок вступают в силу, когда эта форма
  начинает выполнение и деактивируются, когда эта форма вычислена.  Они
  остаются в силе на все время.  В частности, они действуют во время
  выполнения функций, вызываемых с помощью этой формы, в их подпрограммах и
  так далее.  Это хорошо, так как, строго говоря, ошибки могут
  сигнализировать только примитивы Lisp (включая @code{signal} и
  @code{error}), вызываемые в защищенной форме, а не самой защищенной формой.

  Аргументы после защищенной формы являются обработчиками.  Каждые обработчик
  перечисляет одно или более @dfn{имя условия} (которые являются символами),
  чтобы определить, какие ошибки будут обрабатываться.  Символ ошибки,
  указанный для сигнализации об ошибке также определяет список имен условий.
  Обработчик относится к ошибке, если есть какие-либо общие имена условий.
  В приведенном выше примере, есть один обработчик, и это указывает на одно
  условие с именем @code{error}, которое охватывает все ошибки.

  Поиск применимого обработчик проверяет все установленные обработчики,
  начиная с самого последнего установленного.  Таким образом, если две
  вложенные формы @code{condition-case} предлагают обрабатывать одну и ту же
  ошибку, саммая вложенная из двух, обработает эту ошибку.

  Если ошибка обрабатываются какой-либо формой @code{condition-case}, это
  обычно предотвращает запуск отладчика, даже если @code{debug-on-error}
  установлена так, что эта ошибка должна вызвать отладчик.

  Если вы хотите иметь возможность отладки ошибок, которые обнаружены
  в @code{condition-case}, установите переменную @code{debug-on-signal} в
  не-@code{nil}.  Можно также указать, что конкретный обработчик должен
  позволить отладчику запуститься первый, указав @code{debug} среди условий,
  например:

@example
@group
(condition-case nil
    (delete-file filename)
  ((debug error) nil))
@end group
@end example

@noindent
Эффект @code{debug} здесь заключается в том, чтобы предотвратить
@code{condition-case} от подавления вызова отладчика.  Любая данная ошибка
будет вызывать отладчик только если @code{debug-on-error} и другие обычные
механизмы устанолены к выполнению этого.  @xref{Error Debugging}.

@defmac condition-case-unless-debug var protected-form handlers@dots{}
Макрос @code{condition-case-unless-debug} обеспечивает другой способ
обработки отладки таких форм.  Он ведет себя так же, как
@code{condition-case}, если переменная @code{debug-on-error} установлена в
не-@code{nil}, в этом случае вообще не обрабатывается никаких ошибок.
@end defmac

  После того, как Emacs решает, что определенный обработчик должен
  обрабатать ошибку, он передаёт управление обработчику.  Для этого, Emacs
  развязывает все привязки переменных, сделанные конструкциями связывания,
  из которых в настоящее время происходит выход, и выполняет очитку всех форм
  @code{unwind-protect}, из которых сейчас происходит выход.  После того, как
  управление поступает в обработчик, тело обработчика выполняется нормально.

  После выполнения тела обработчика, выполнение возвращается из формы
  @code{condition-case}.  Поскольку защищенная форма вышла полностью перед
  выполнением обработчика, обработчик не может возобновить выполнение в точке
  ошибки и не может исследовать связывание переменных, которые были сделаны
  в защищенной форме. Все что можно сделать это очистить и продолжить.

  Сигнализации ошибок и их обработка имеют некоторое сходство с
  @code{throw} и @code{catch} (@pxref{Catch and Throw}), но это совершенно
  разные объекты.  Ошибка не может быть обнаружена в @code{catch} и
  @code{throw} и не может быть обработана с помощью обработчика ошибок
  (хотя с помощью @code{throw}, когда нет подходящей @code{catch}
  сигнализируется об ошибке, которую можно обработать).

@defspec condition-case var protected-form handlers@dots{}
Cпециальная форма устанавливает обработчики ошибок @var{handlers} вокруг
выполнения защищенной формы @var{protected-form}.  Если @var{protected-form}
выполняется без ошибок, то возвращаемое значение становится значением формы
@code{condition-case}; в этом случае @code{condition-case} не имеет никакого
эффекта.  @code{condition-case} форма имеет значение, когда происходит ошибка
во время оценки защищённой формы @var{protected-form}.

Каждый из обработчиков @var{handlers} представляется списком вида
@code{(@var{conditions} @var{body}@dots{})}.  Здесь @var{conditions} - это
имя условия ошибки, которая должна быть обработана, или список имен условий
(которые могут включать в себя @code{debug}, для запуска отладчика перед
запуском обработчика); форма @var{body} это один или несколько Lisp
выражений, которые будут выполняться, когда этот обработчик обрабатывает
ошибку. Вот примеры обработчиков:

@example
@group
(error nil)

(arith-error (message "Деление на ноль"))

((arith-error file-error)
 (message
  "Либо деление на ноль или невозможно открыть файл"))
@end group
@end example

Каждая ошибка, которая возникает имеет @dfn{символ ошибки}, который
описывает, что это за ошибка, а также описывает список имен условий
(@pxref{Error Symbols}).  Emacs ищет во всех активных формах
@code{condition-case} обработчик, который определяет один или несколько из
этих имен условий; самое вложенное согласованное условие
@code{condition-case} обрабатывает ошибку.  В этом @code{condition-case},
первый применимый обработчик обрабатывает ошибку.

После выполнения тела обработчика, @code{condition-case} оценивается в
обычном режиме, используя значение последней формы в теле обработчика в
качестве возвращаемого значения.

@cindex error description
Аргумент @var{var} является переменной.  @code{condition-case} не связывает
эту переменную при выполнении @var{protected-form}, только тогда, когда
обрабатывается ошибка.  В это время, связывается @var{var} локально к
@dfn{дескриптору ошибки}, который представляет собой список, давая подробные
сведения об ошибке.  Описание ошибки имеет вид
@code{(@var{error-symbol} . @var{data})}.  Обработчик может обратиться к
этому списку, чтобы решить, что делать.  Например, если ошибка связана с
неудачным открытием файла, имя файла является вторым элементом, а @var{data}
--- третьим элементом описания ошибки. (ВопросControl2005)

Если @var{var} установленно в @code{nil}, это означает, что ни одна
переменная не связана.  Тогда символ ошибки и связанные с ними данные не
доступны для обработчика.

@cindex rethrow a signal
Иногда необходимо, чтобы повторно выбросить перехваченный сигнал
@code{condition-case},  для некоторого обработчика внешнего уровня, который
должен его поймать и обработать.  Вот как это сделать:

@example
  (signal (car err) (cdr err))
@end example

@noindent
Где @code{err} является переменной описания ошибки, где первый аргумент
@code{condition-case} условие ошибки, которое требуется повторно пробросить.
@xref{Definition of signal}.  (ВопросControl2023)
@end defspec

@defun error-message-string error-descriptor
Функция возвращает строку сообщения об ошибке для данного дескриптора ошибки.
Это полезно, если требуется обработать ошибку, напечатав сообщение об ошибке
для этой ошибки.  @xref{Definition of signal}.
@end defun

@cindex @code{arith-error} example
Ниже приведен пример использования @code{condition-case} для обработки
ошибки, как результат от деления на ноль.  Обработчик выводит сообщение об
ошибке (но без звукового сигнала), затем возвращает очень большое число.

@example
@group
(defun safe-divide (dividend divisor)
  (condition-case err
      ;; @r{Защищенная форма.}
      (/ dividend divisor)
@end group
@group
    ;; @r{обработчик.}
    (arith-error                        ; @r{Услвие.}
     ;; @r{Вывод обычного сообщения об этой ошибке.}
     (message "%s" (error-message-string err))
     1000000)))
@result{} safe-divide
@end group

@group
(safe-divide 5 0)
     @print{} Арифметическая ошибка: (arith-error)
@result{} 1000000
@end group
@end example

@noindent
Обработчик определяет имя условия @code{arith-error} так, что он будет
обрабатывать только ошибки деления на ноль.  Другие виды ошибок не будут
обработаны (этим @code{condition-case}). таким образом:

@example
@group
(safe-divide nil 3)
     @error{} Неправильный тип аргумента: number-or-marker-p, nil
@end group
@end example

  Вот @code{condition-case}, для отлавливания всех виды ошибок, в том числе
  из @code{error}:

@example
@group
(setq baz 34)
     @result{} 34
@end group

@group
(condition-case err
    (if (eq baz 35)
        t
      ;; @r{Это вызов функции @code{error}.}
      (error "Враньё!  Переменная %s была %s, а не 35" 'baz baz))
  ;; @r{Это обработчик; это не форма.}
  (error (princ (format "Ошибка: %s" err))
         2))
@print{} Ошибка: (error "Враньё! Переменная baz была 34, а не 35")
@result{} 2
@end group
@end example

@defmac ignore-errors body@dots{}
Конструкция выполняет форму @var{body}, игнорируя любые ошибки, возникающие в
процессе её оценки.  Если оценка без ошибок, @code{ignore-errors}
возвращается значение последней формы в @var{body}; в противном случае
возвращается @code{nil}.

Вот пример в начале этого подраздела, переписанный с использованием
@code{ignore-errors}:

@example
@group
  (ignore-errors
   (delete-file filename))
@end group
@end example
@end defmac

@defmac with-demoted-errors format body@dots{}
Макрос подобен мягкой версии @code{ignore-errors}.  Вместо того, чтобы
подавлять ошибки вообще, они преобразуются в сообщения.  Используется строка
@var{format} для форматирования сообщения.  @var{format} должен содержать
одну @samp{%}-последовательность; например, @code{"Error: %S"}.  Используйте
@code{with-demoted-errors} вокруг кода, который не ожидает сигналов ошибок,
и это должен быть надёжный код в случае возникновения ошибок.  Обратите
внимание, что этот макрос использует @code{condition-case-unless-debug}
вместо @code{condition-case}.
@end defmac

@node Error Symbols
@subsubsection Символы Ошибок и Имена Условий
@cindex error symbol
@cindex error name
@cindex condition name
@cindex user-defined error
@kindex error-conditions
@kindex define-error

  Когда появляется сигнал об ошибке, указывается @dfn{символ ошибки}, чтобы
  указать тип ошибки который имеется в виду.  Каждая ошибка имеет один и
  только один символ ошибки для описания её категории. Это лучшая
  классификация ошибок, определенная языком Emacs Lisp.

  Эти узкие классификации сгруппированы в иерархии более широких классов,
  называемых @dfn{состояниями ошибок}, которые были определены
  @dfn{именами условий}.  Самые узкие такие классы принадлежат к самим
  символам ошибки: каждый символ ошибки - также является именем условия. Есть
  также имена условия для более широких классов, вплоть до имени условия
  @code{error}, которое принимает все виды ошибок (но только не @code{quit}).
  Таким образом, каждая ошибка имеет одно или несколько имен условий:
  @code{error}, символ ошибки, если имя отлично от @code{error}, и, возможно,
  некоторые промежуточные классификации.  (ВопросControl2145)

@defun define-error name message &optional parent
  Для того, чтобы символ, выступал в роли символа ошибки, он должен быть
  определен с @code{define-error} которое принимает родительское условие
  (по умолчанию @code{error}).  Этот родитель определяет условия, которым
  принадлежит такого рода ошибка.  Транзитивное множество родителей всегда
  включает в себя также сам символ ошибки и символ @code{error}.  Потому что
  выход не считается ошибкой, множество родителей @code{quit} просто
  @code{(quit)}. (ВопросControl2154)
@end defun

@cindex peculiar error
  В дополнение к своим родителям, символ ошибки имеет @var{message}, которое
  является строкой и которая будет напечатана, когда сигнализируется ошибка,
  но не обрабатывается.  Если это сообщение не является действительным,
  используются сообщение об ошибке @samp{своеобразная ошибка}.
@xref{Definition of signal}.

Внутренне множество родителей хранится в @code{error-conditions} свойстве
символа ошибки а сообщение хранится в @code{error-message} свойства символа
ошибки.

  Вот как определяется новый символ ошибки, @code{new-error}:

@example
@group
(define-error 'new-error "A new error" 'my-own-errors)
@end group
@end example

@noindent
Эта ошибка имеет несколько имён услвий: условие @code{new-error}, самая
узкая классификация; @code{my-own-errors}, предположительно представляет
более широкую классификацию; и все условия @code{my-own-errors}, которые
должны включать в себя @code{error}, которое является самой широкой
класификацией из всех.

  The error string should start with a capital letter but it should
not end with a period.  This is for consistency with the rest of Emacs.

  Естественно, Emacs никогда не будет сигнализировать @code{new-error} самим
  по себе; только явный вызов @code{signal} (@pxref{Definition of signal}) в
  коде может сделать это:

@example
@group
(signal 'new-error '(x y))
     @error{} A new error: x, y
@end group
@end example

  Эту ошибку можно обработать с помощью любого из его имен условий.  Этот
  пример обрабатывает @code{new-error} и любые другие ошибки класса
  @code{my-own-errors}:

@example
@group
(condition-case foo
    (bar nil t)
  (my-own-errors nil))
@end group
@end example

  Естественный способ класификации ошибок - это использование их имен условий
  сопоставимыми с их именами ошибки.  Символ ошибки служит только в качестве
  удобного способа указать предполагаемое сообщение об ошибке и список имен
  условий.  Было бы громоздким, давать @code{signal} список имен условий, а
  не использовать один символ ошибки.

  В противоположность этому, используя только символы ошибок без имен условий
  серьезно уменьшило бы возможности @code{condition-case}.  Имена условий
  позволяют классифицировать ошибки на различных уровнях общности, когда вы
  пишете обработчик ошибок.  Использование одних только символов ошибок
  устранило бы все, кроме самого узкого уровня классификации.

  @xref{Standard Errors}, где приведен список основных символов ошибок и
  их условий.

@node Cleanups
@subsection Очистка Нелокальных Выходов
@cindex nonlocal exits, cleaning up
@cindex forms for cleanup

  @code{unwind-protect} конструкция имеет важное значение, когда вы временно
  переводите структуру данных в несогласованное состояние; она позволяет вам
  сделать данные снова согласованные в случае ошибки или сбоя.  (Еще одна
  более конкретная конструкция очистки, которая используется только для
  изменения содержимого буфера и относится к группе атомарных изменений;
  @ref{Atomic Changes}.)

@defspec unwind-protect body-form cleanup-forms@dots{}
@cindex cleanup forms
@cindex protected forms
@cindex error cleanup
@cindex unwinding
@code{unwind-protect} исполняет @var{body-form} с гарантией того, что
@var{cleanup-forms} будут оценены, если элемент управления покинет форму
@var{body-form}, независимо от того, как это произойдёт.  @var{body-form}
может завершаться нормально, или выполнить @code{throw} из
@code{unwind-protect}, или вызвать ошибку; во всех случаях,
@var{cleanup-forms} будет оцениваться.

Если @var{body-form} нормально завершается, @code{unwind-protect} возвращает
значение @var{body-form}, после того, как оценивается @var{cleanup-forms}.
Если @var{body-form} не завершается, @code{unwind-protect} не возвращает
никакого значения в обычном смысле этого слова.

Только @var{body-form} защищена @code{unwind-protect}.  Если какая-либо форма
из @var{cleanup-forms} выходит нелокально (через @code{throw} или ошибки),
@code{unwind-protect} @emph{не} гарантированно оценит остальные.  Если
одна из форм @var{cleanup-forms} потенциально может вызвать проблемы,
защитите его с помощью другого @code{unwind-protect} вокруг этой формы.

Количество активных форм @code{unwind-protect}, в определёный момент
времени, учитывается вместе с числом локальных привязок переменных, с
учётом предельных значений @code{max-specpdl-size}
(@pxref{Definition of max-specpdl-size,, Local Variables}).
@end defspec

  Например, здесь мы делаем невидимый буфер для временного использования, и
  обязательно уничтожаем его, пред завершением:

@example
@group
(let ((buffer (get-buffer-create " *temp*")))
  (with-current-buffer buffer
    (unwind-protect
        @var{body-form}
      (kill-buffer buffer))))
@end group
@end example

@noindent
Можно подумать, что можно использовать @code{(kill-buffer (current-buffer))}
и забыть о переменной @code{buffer}.  Однако, способ показанный выше,
является более безопасным, если @var{body-form} выдаст ошибку после
переключения на другой буфер!  (В качестве альтернативы, можно написать
@code{save-current-buffer} вокруг формы  @var{body-form}, чтобы
гарантировать, что временный буфер снова станет текущим, чтобы убить его.)

  Emacs включает в себя стандартный макрос @code{with-temp-buffer}, который
  расширяется к более или менее похожему коду, показанной выше
  (@pxref{Definition of with-temp-buffer,, Current Buffer}).  Некоторые из
  макросов, определенных в данном руководстве, используют
  @code{unwind-protect} таким образом.

@findex ftp-login
  Вот конкретный пример, полученный из пакета FTP.  Создает процесс
  (@pxref{Processes}), чтобы попытаться установить соединение с удаленным
  компьютером.  Поскольку функция @code{ftp-login} очень восприимчива к
  многочисленным проблемам, которые автор функции не может предвидеть, она
  защищена формой, которая гарантирует удаление процесса в случае сбоя.
  В противном случае, Emacs может заполниться бесполезными подпроцессами.

@example
@group
(let ((win nil))
  (unwind-protect
      (progn
        (setq process (ftp-setup-buffer host file))
        (if (setq win (ftp-login process host user password))
            (message "Logged in")
          (error "Ftp login failed")))
    (or win (and process (delete-process process)))))
@end group
@end example

  В этом примере есть небольшая ошибка: если пользователь вводит @kbd{C-g},
  чтобы выйти, а выход происходит сразу после возвращения функции
  @code{ftp-setup-buffer} но перед тем как переменная @code{process}
  будет установлена, то процесс не будет убит.  Нет простого способа
  исправить эту ошибку, но, по крайней мере, это очень маловероятно.
