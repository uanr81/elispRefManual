@c -*- mode: texinfo; coding: utf-8 -*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2019 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Control Structures
@chapter Управляющие Структуры
@cindex special forms for control structures
@cindex forms for control structures
@cindex control structures

  Lisp программа состоит из набора @dfn{выражений} или @dfn{форм}
  (@pxref{Forms}).  Контроль порядка выполнения этих форм, реализуется
  заключением их в @dfn{управляющие структуры}.  Управляющие структуры
  являются специальными формами, которые контролируют, когда, сколько раз,
  каким образом и нужно ли вообще оценивать содержащиеся в них формы.

@cindex textual order
  Простейший порядок выполнения - последовательное выполнение: вначале
  оценивается @var{a}, затем оценивается @var{b}, и так далее.  Это то, что
  происходит, когда написано несколько форм подряд в теле функции, или на
  верхнем уровне в файле Lisp кода --- формы выполняются в том порядке в
  котором написаны.  Называется это @dfn{текстовый порядок}.  Например, если
  тело функции состоит из двух форм @var{a} и @var{b}, оценка функции
  оценивает вначале @var{a}, а затем @var{b}.  Результат вычисления @var{b}
  становится значением функции.

  Явные структуры управления делают возможным порядок исполнения, отличным от
  последовательного.

  Emacs Lisp обеспечивает несколько видов структур управления, в том числе
  других разновидностей упорядочивания выполнения: условные выражения,
  итерации, и (управляемых) переходов --- все обсуждается ниже.  Встроенные
  управляющие структуры являются особыми формами, так как их подчиненные
  формы не обязательно все оценеваются или оцениваются последовательно.
  Можно использовать макросы, чтобы определить свои собственные конструкции
  структур управления (@pxref{Macros}).

@menu
* Sequencing::             Оценка в текстовом порядке.
* Conditionals::           @code{if}, @code{cond}, @code{when}, @code{unless}.
* Combining Conditions::   @code{and}, @code{or}, @code{not}.
* Pattern-Matching Conditional::  Как использовать @code{pcase} и друзей.(БаянControl43)
* Iteration::              @code{while} циклы.
* Generators::             Общие последовательности и сопрограммы.
* Nonlocal Exits::         Выход из последовательности.
@end menu

@node Sequencing
@section Последовательное Выпрлнение
@cindex sequencing
@cindex sequential execution
@cindex forms for sequential execution

  Оценка форм, в порядке их появления, является наиболее распостраненным
  способом перехода управления от одной формы в другую.  В некоторых случаях,
  например, в теле функции, это происходит автоматически.  В другом случае
  нужно использовать конструкцию управляющей структуры: @code{progn},
  простейшая управляющая структура Lisp.

  @code{progn} - особая форма выглядит следующим образом:

@example
@group
(progn @var{a} @var{b} @var{c} @dots{})
@end group
@end example

@noindent
что определяет выполнение форм @var{a}, @var{b}, @var{c}, и так далее, в
указанном порядке.  Эти формы называются @dfn{тело} формы @code{progn}.
Значение последней формы в этом теле, становится значением всей формы
@code{progn}.  @code{(progn)} возвращает значение @code{nil}.

@cindex implicit @code{progn}
  На заре Lisp, @code{progn} был единственный способ выполнить две или более
  форм последовательно и использовать значение последней из них.  Но
  программисты обнаружили, что часто необходимо использовать @code{progn} в
  теле функции, где (в то время) разрешена была только одна форма.  Таким
  образом, тело функции было преобразовано в неявном @code{progn}:  несколько
  форм так же разрешаются, как в теле фактического @code{progn}.  Многие
  другие управляющие структуры также содержат неявный @code{progn}.  В
  результате, @code{progn} не используется так часто, как это было много лет
  назад.  В настоящее время данная форма нужна чаще всего внутри
  @code{unwind-protect}, @code{and}, @code{or}, или в качестве
  @var{then}-части в конструкции @code{if}.

@defspec progn forms@dots{}
Эта особая форма оценивает все @var{forms} в текстовом порядке и возвращаят
результат оценки последней формы.

@example
@group
(progn (print "Первая форма")
       (print "Вторая форма")
       (print "Третья форма"))
     @print{} "Первая форма"
     @print{} "Вторая форма"
     @print{} "Третья форма"
@result{} "Третья форма"
@end group
@end example
@end defspec

  Две другие конструкции также оценивают ряд форм, но возвращатют разные
  значения:

@defspec prog1 form1 forms@dots{}
Эта специальная форма оценивает @var{form1} и все остальные @var{forms} в
текстовом порядке и возвращает результат @var{form1}.

@example
@group
(prog1 (print "Первая форма")
       (print "Вторая форма")
       (print "Третья форма"))
     @print{} "Первая форма"
     @print{} "Вторая форма"
     @print{} "Третья форма"
@result{} "Первая форма"
@end group
@end example

Вот способ, чтобы удалить первый элемент из списка в переменной @code{x}, а
затем вернуть значение удалённого элемента:

@example
(prog1 (car x) (setq x (cdr x)))
@end example
@end defspec

@defspec prog2 form1 form2 forms@dots{}
Эта особая форма оценивает @var{form1}, @var{form2}, и все следующие
@var{forms}, в текстовом порядке и возвращает результат @var{form2}.

@example
@group
(prog2 (print "Первая форма")
       (print "Вторая форма")
       (print "Третья форма"))
     @print{} "Первая форма"
     @print{} "Вторая форма"
     @print{} "Третья форма"
@result{} "Вторая форма"
@end group
@end example
@end defspec

@node Conditionals
@section Условные Выражения
@cindex conditional evaluation
@cindex forms, conditional

  Условные структуры управления выбрают один из вариантов.  Emacs Lisp имеет
  пять условных форм: @code{if}, которая является такой же, как и в других
  языках; @code{when} и @code{unless}, которые являются вариантами @code{if};
  @code{cond}, который является обобщенным оператором case; и @code{pcase},
  который представляет собой обобщение @code{cond}
  (@pxref{Pattern-Matching Conditional}).

@defspec if condition then-form else-forms@dots{}
@code{if} направляет управление между ветками @var{then-form} и
@var{else-forms} на основе оцененного значения условия @var{condition}.  Если
@var{condition} оценивается в не-@code{nil}, оценивается ветка
@var{then-form} и  этот результат возвращается. В противном случае,
оценивается ветка @var{else-forms} в текстовом порядке, и значение
последней формы этой ветки возвращается.  (@var{else}-ветка
@code{if} является примером неявного использования @code{progn}.
@xref{Sequencing}.)

Если условие @var{condition} оценивается в @code{nil}, а формы в ветке
@var{else-forms} не указаны, @code{if} возвращает значение @code{nil}.

@code{if} - это особая форма, так как ветвь, которая не выбрана, никогда не
оценивается---игнорируется.  Таким образом, в этом примере, @code{истина} не
печатается, потому что @code{print} не выполняется:

@example
@group
(if nil
    (print 'истина)
  'ложь)
@result{} ложь
@end group
@end example
@end defspec

@defmac when condition then-forms@dots{}
Вариант @code{if} где отсутствует ветка @var{else-forms}, и, возможно
присутствие нескольких форм в ветке @var{then-forms}. В частности,

@example
(when @var{condition} @var{a} @var{b} @var{c})
@end example

@noindent
что полностью эквивалентно

@example
(if @var{condition} (progn @var{a} @var{b} @var{c}) nil)
@end example
@end defmac

@defmac unless condition forms@dots{}
Это вариант @code{if} где нет ветки @var{then-form}:

@example
(unless @var{condition} @var{a} @var{b} @var{c})
@end example

@noindent
что полностью эквивалентно

@example
(if @var{condition} nil
   @var{a} @var{b} @var{c})
@end example
@end defmac

@defspec cond clause@dots{}
@code{cond} выбирает между произвольным числом альтернатив (или предложений).
Каждый аргумент @var{clause} в форме @code{cond} является такой альтернативой
и представляет из себя список @sc{car} которого - это  @var{условие};
остальные элементы, если таковые имеются, @var{тело-формы}. Выглядит такое
предложение (альтернатива) следующим образом:

@example
(@var{условие} @var{тело-формы}@dots{})
@end example

@code{cond} проверяет каждую альтернативу в текстовом порядке, путем оценки
@var{условия}.  Если значение @var{условия} устанавленно в не-@code{nil},
предложение считается успешным и @code{cond} оценивает @var{тело-формы} и
возвращает значение последней формы из @var{тела-формы}. Все остальные
альтернативы далее игнорируются.

Если оценивается значение @var{условие} в @code{nil}, альтернатива считается
неподходящей и @code{cond} переходит к следующей альтернативе оценивая уже
её @var{условие}.

Альтернатива также может выглядеть следующим образом:

@example
(@var{условие})
@end example

@noindent
в случае, если @var{условие} при проверки альтернативы оценевается в
не-@code{nil}, форма @code{cond} возвращает значение оценнённое значение
@var{условия}.

Если каждое @var{условие} имеет значение @code{nil} и не отрабатывает ни
единая альтернатива, @code{cond} возвращает @code{nil}.

Следующий пример имеет четыре альтернативы, которые выполняются в зависимости
от того, что из себя представляет значение @code{x}, а именно: число, строку,
буфер или символ:

@example
@group
(cond ((numberp x) x)
      ((stringp x) x)
      ((bufferp x)
       (setq temporary-hack x) ; @r{несколько форм в теле-формы}
       (buffer-name x))        ; @r{одной альтернативы}
      ((symbolp x) (symbol-value x)))
@end group
@end example

Часто требуется оценить последнюю альтернативу, когда ни одна из предыдущих
не была принята.  Для этого используется @code{t} в качестве @var{условия}
последней альтернативы, как здесь: @code{(t @var{body-forms})}.  Форма
@code{t} всегда принимает значение @code{t} и никогда значение @code{nil},
поэтому эта альтернатива выбирается, если до неё доходит очередь @code{cond}.
Например:

@example
@group
(setq a 5)
(cond ((eq a 'hack) 'foo)
      (t "default"))
@result{} "default"
@end group
@end example

@noindent
@code{cond} выражение возвращает @code{foo}, если значение @code{a}
удовлетворяет условию @code{eq} к @code{hack}, и возвращает строку
@code{"default"} в другом случае.
@end defspec

Любая условная конструкция может быть выражена с @code{cond} или @code{if}.
Таким образом, выбор между ними является вопросом стиля. Например:

@example
@group
(if @var{a} @var{b} @var{c})
@equiv{}
(cond (@var{a} @var{b}) (t @var{c}))
@end group
@end example

@node Combining Conditions
@section Конструкции для Комбинирования Услвных Выражений
@cindex combining conditions

  В этом разделе описаны три конструкции, которые часто используются вместе
  с @code{if} и @code{cond}, чтобы выразить сложные условия.  Конструкции
  @code{and} и @code{or} также могут быть использованы по отдельности как
  разновидности нескольких условных конструкций.

@defun not condition
Функция проверяет ложность @var{condition}.  Возвращает @code{t} если
@var{condition} оценивается в @code{nil} и @code{nil} в противном лучае.
Функция @code{not} идентична @code{null}, и мы рекомендуем функцию с именем
@code{null}, когда проверяется значение пустого списка.
@end defun

@defspec and conditions@dots{}
@code{and} проверяет все ли условия @var{conditions} истинны.  Оценивает
@var{conditions} один за другим в текстовом порядке.

Если какой-либо из @var{conditions} вычисляется в @code{nil}, то результат
@code{and} устанавливается в @code{nil} независимо от результата оценки
остальных @var{conditions}; поэтому @code{and} возвращает @code{nil} сразу,
не оценивая оставшиеся условия @var{conditions}.

Если все @var{conditions} оцениваются в не-@code{nil}, то значение последнего
из них становится значением формы @code{and}.  Просто @code{(and)}, без
@var{conditions}, возвращает @code{t}, потому что все @var{conditions}
оценились в не-@code{nil}. (Подумайте об этом, почему это так?)

Вот пример.  Первое условие возвращает целое число 1, которое не является
@code{nil}.  Аналогичным образом, второе условие возвращает целое число 2,
которое не является @code{nil}.  Третье условие @code{nil}, поэтому
оставшееся условие никогда не оценивали.

@example
@group
(and (print 1) (print 2) nil (print 3))
     @print{} 1
     @print{} 2
@result{} nil
@end group
@end example

Вот более реалистичный пример использования @code{and}:

@example
@group
(if (and (consp foo) (eq (car foo) 'x))
    (message "foo список, который начинается с x"))
@end group
@end example

@noindent
Обратите внимание, что @code{(car foo)} не выполняется, если
@code{(consp foo)} возвращает @code{nil}, что позволяет избежать ошибок.

@code{and} выражение может быть написано с использованием выражения @code{if}
или @code{cond}. Вот как:

@example
@group
(and @var{arg1} @var{arg2} @var{arg3})
@equiv{}
(if @var{arg1} (if @var{arg2} @var{arg3}))
@equiv{}
(cond (@var{arg1} (cond (@var{arg2} @var{arg3}))))
@end group
@end example
@end defspec

@defspec or conditions@dots{}
@code{or} специальная форма, в которой проверяется является ли, по крайней
мере одно из условий @var{conditions} истиной.  Оцениваются все условия
@var{conditions} формы один за другим, в текстовом порядке.

Если какое-либо из условий @var{conditions} оценивается в не-@code{nil}, то
результат @code{or} устанавливается в не-@code{nil} и @code{or} сразу
возвращает это значение результатом, не обращая внимания на оставшиеся
условия @var{conditions}.

Если все @var{conditions} оценены в @code{nil}, то @code{or} выражение
возвращает @code{nil}.  Просто @code{(or)}, без условий @var{conditions},
возвращает @code{nil}, это потому, что все @var{conditions} оценились в
@code{nil}.  (Подумайте об этом, почему это так?)

Например, это выражение проверяет удовлетворяет @code{x} @code{eq} к
@code{nil} или целому числу нуль:

@example
(or (eq x nil) (eq x 0))
@end example

Как и @code{and} конструкцию, @code{or} можно записать в терминах
@code{cond}.  Например:

@example
@group
(or @var{arg1} @var{arg2} @var{arg3})
@equiv{}
(cond (@var{arg1})
      (@var{arg2})
      (@var{arg3}))
@end group
@end example

Можно, но не совсем точно, реализовать @code{or} по средствам @code{if}:

@example
@group
(if @var{arg1} @var{arg1}
  (if @var{arg2} @var{arg2}
    @var{arg3}))
@end group
@end example

@noindent
Это не полностью эквивалентно, так как возможно вычисление @var{arg1} или
@var{arg2} дважды.  В противоположность этому,
@code{(or @var{arg1} @var{arg2} @var{arg3})} никогда не оценивает любой
свой аргумент более чем один раз.
@end defspec

@node Pattern-Matching Conditional
@section Шаблон-Соответствие Условию
@cindex pcase
@cindex pattern matching, programming style

Помимо четырех основных условных форм, Emacs Lisp также имеет условную форму
сопоставления с образцом, макрос @code{pcase}, гибрид @code{cond} и
@code{cl-case} (@pxref{Conditionals,,,cl,Common Lisp Extensions}), с помощью
которой, преодолеваются их ограничения и вводится
@dfn{стиль программирования сопоставления с образцом}.  Ограничения, которые
преодолевает @code{pcase}:

@itemize
@item
Форма @code{cond} выбирает среди альтернатив, путем оценки предиката
@var{условия} каждой из своих веток (@pxref{Conditionals}).  Основным
ограничением является то, что эти переменные @var{условия} не доступны
для @var{формы-тела} соответствующей ветки.

Ещё ограничение (скорее неудобство, чем ограничение) заключается в том, что
для проверки ряда @var{условий}, требуется написание много повторяющегося
кода.  (@code{cl-case} решает эти неудобства.)

@item
Макрос @code{cl-case} выбирает среди альтернатив путем оценки равенства
первого аргумента с набором конкретных значений.

Его ограничения в двояко:

@enumerate
@item
Для проверки равенства используется @code{eql}.
@item
Значения должны быть известны и записаны заранее.
@end enumerate

@noindent
Это делает @code{cl-case} непригодным использования со строками или
составными структурами данных (например, списками или векторами).
(@code{cond} не имеет этих ограничений, но у него есть другие, см. выше)
@end itemize

@noindent
Концептуально, @code{pcase} макрос заимствует способ обработки первого
аргумента из @code{cl-case} и способ обработки выбранной ветки @code{cond},
заменяя @var{условие} обобщением проверки на равенство варианта
@dfn{сопоставление шаблону} и добавляя средства, позволяющие кратко выразить
предикат альтернативы и организовать LET-привязку между предикатом и
@var{тела-формы} альтернативы. (ВопросControl474 Баян полный)

Краткое выражение предиката известно как @dfn{шаблон}.  Когда предикат,
вызванный для проверки первого аргумента альтернативы, возвращает
не-@code{nil}, подразумевается, что ``шаблон совпадает со значением''
(или иногда ``значение соответствует шаблону'').

@menu
* The @code{pcase} macro: pcase Macro. Примеры и предостережения.
* Extending @code{pcase}: Extending pcase.  Определение новых видов шаблонов.
* Backquote-Style Patterns: Backquote Patterns.  Сопоставление моделей
                                                 структур.
* Destructuring with pcase Patterns:: Использование шаблонов pcase для
                                      извлечения подполей.
@end menu

@node pcase Macro
@subsection The @code{pcase} macro

Для справки, @xref{Pattern-Matching Conditional}.

@defmac pcase expression &rest clauses
Каждая альтернатива в @var{clauses} имеет вид:
@w{@code{(@var{шаблон} @var{тело-формы}@dots{})}}.

Оценивается @var{expression}, для определения его значения, @var{expval}.
Ищется первый элемент альтернатив в @var{clauses}, значение @var{pattern}
которого соответствует @var{expval} и передаётся управление @var{телу-формы}
подобранной альтернативы.

Если есть совпадение, значением @code{pcase} является значение последней из
@var{тела-формы} подобранной альтернативы.  В противном случае, @code{pcase}
оценивается в @code{nil}.
@end defmac

@cindex pcase pattern
Каждый @var{шаблон} должен быть @dfn{pcase шаблоном}, который может
использовать либо один любой из основных шаблонов, определенных ниже, либо
один из шаблонов, определенных с помощью @code{pcase-defmacro}
(@pxref{Extending pcase}).

Остальная часть этого подраздела описывает различные формы основных шаблонов,
приведены примеры и, в заключении, важные предосторежения по использованию
LET-связывающего механизма, предоставляемый некоторыми формами шаблонов.
Основные шаблоны могут принимать следующие формы:

@table @code

@item _
Соответствие любому @var{expval}.
Это также известно как @dfn{don't care} или @dfn{wildcard}.(ВопросControl524)

@item '@var{val}
Соответствие, если @var{expval} равен @var{val}. Сравнение производится
с использованием @code{equal} (@pxref{Equality Predicates}).

@item @var{keyword}
@itemx @var{integer}
@itemx @var{string}
Соответствие, если @var{expval} равен буквально объекту.  Это особый случай
@code{'@var{val}}, описанный выше, потому, сравнивается буквально объекты
заключённые в кавычки(ВопросControl535 ,баян полнейший).

@item @var{symbol}
Соответствует любому @var{expval}, и к тому же, LET связывает @var{symbol}
с @var{expval}, таким образом, что эта привязка доступна @var{телу-формы}
(@pxref{Dynamic Binding}).

Если @var{symbol} является частью последовательности шаблона @var{seqpat}
(например, с помощью @code{and}, ниже), связывание также доступно в части
@var{seqpat} после появления @var{symbol}.  Такое использование имеет
некоторые предостережения, смотреть @ref{pcase-symbol-caveats,,caveats}.

Два символа, которых здесь нужно избегать это @code{t}, который ведет себя
как @code{_} (выше) и является устаревшим, и @code{nil}, при использовании
которого сигнализируется ошибка.  Кроме того, не имеет смысла связывать
символы ключевых слов (@pxref{Constant Variables}).

@item (pred @var{function})
Соответствует, если предикат @var{function} возпращает не-@code{nil} при
вызове с @var{expval}.  Предикат @var{function} может иметь одну из
следующих форм:

@table @asis
@item именованная функция (символ)
Вызов именованной функции с одним аргументом, @var{expval}.

Пример: @code{integerp}

@item лямбда-выражение
Вызов анонимной функции с одним аргументом,
@var{expval} (@pxref{Lambda Expressions}).

Пример: @code{(lambda (n) (= 42 n))}

@item вызов функции с @var{n} аргументами
Вызов функции (первый элемент вызова функции) с аргументами @var{n}
(другие элементы) и дополнительным @var{n}+1 аргументом, @var{expval}.

Пример: @code{(= 42)}@*
В этом примере функция равна @code{=}, @var{n} равен единице, а фактический
вызов функции это: @w{@code{(= 42 @var{expval})}}.
@end table

@item (app @var{функция} @var{шаблон})
Соответствует, когда вызов функции @var{функция}, возвращает значение
@var{expval}, которое соответствует @var{шаблон}.
@var{функция} может принимать одну из форм, описанных для @code{pred}, выше.
В отличии от @code{pred}, @code{app} проверяет результат с @var{шаблоном}, а
не с логическим значением истинности.

@item (guard @var{логическое-выражение})
Соответствует, когда @var{логическое-выражение} устанвленно в не-@code{nil}
значение.

@item (let @var{шаблон} @var{expr})
Соответствует, когда при оценки @var{expr}, чтобы получить @var{exprval},
@var{exprval} соответствует @var{шаблон}.  (Это вызвано тем, что @code{let}
может связывать @var{шаблон} со значением символа @var{symbol}.)
(ВопросControl593 баян всем баянам)
@end table

@cindex sequencing pattern
@dfn{последовательность шаблонов} (известно как @var{seqpat}) представляет
собой образец, который обрабатывает свои аргументы суб-шаблонов в
последовательности.  Есть два для @code{pcase}: @code{and} и @code{or}.
Ведут себя аналогично специальным формам, разделяя их имена
(@pxref{Combining Conditions}), но вместо обработки значений, они
обрабатывают суб-шаблоны.

@table @code
@item (and @var{pattern1}@dots{})
Попытка сопоставить @var{pattern1}@dots{} по порядку, пока один из них не
совпадает.  В этом случае, @code{and} также не совпадает, а остальные
подшаблоны не проверяются.  Если все суб-шаблоны совпадают, @code{and}
считается совпавшим.

@item (or @var{pattern1} @var{pattern2}@dots{})
Попытка сопоставить @var{pattern1}, @var{pattern2}, @dots{} по порядку, пока
один из них не совпаст.  В этом случае, @code{or}, также соответствует, а
остальные подшаблонам бльше не проверяются.  (Обратите внимание, что должно
быть по крайней мере, два суб-шаблона.  Простой
@w{@code{(or @var{pattern1})}} сигнализирует об ошибке.)
@c Вопрос: Правильно ли это и предназначен?
@c        Есть ли исключения, квалификация?
@c        (Btw, ``Пожалуйста, избегайте его'' плохое сообщение об ошибке.)

Для того, чтобы представить согласованную среду (@pxref{Intro Eval}) к
@var{body-forms} (что позволяет избежать ошибки оценки при совпадении), если
какой-либо из подшаблонов LET, связывает набор символов, все они
@emph{должны} связывать один и тот же набор символов.
@end table

@anchor{pcase-example-0}
@subheading Пример: Превосходство Над @code{cl-case}

Вот пример, который почёркивает некоторые преимущества @code{pcase}
перед @code{cl-case} (@pxref{Conditionals,,,cl,Common Lisp Extensions}).

@example
@group
(pcase (get-return-code x)
  ;; string
  ((and (pred stringp) msg)
   (message "%s" msg))
@end group
@group
  ;; символы
  ('success       (message "Готово!"))
  ('would-block   (message "К сожалению, не может быть выполнено сейчас"))
  ('read-only     (message "Shmliblick только для чтения"))
  ('access-denied (message "У вас нет необходимых прав"))
@end group
@group
  ;; по умолчанию
  (code           (message "Неизвестный код возврата %S")))
@end group
@end example

@noindent
С @code{cl-case}, требуется явно объявить локальную переменную @code{code}
для хранения возвращаемого значения @code{get-return-code}.  Также
@code{cl-case} трудно использовать со строками, поскольку используется
@code{eql} для сравнения.

@anchor{pcase-example-1}
@subheading Example: Using @code{and}

Общей идиомой, является написание шаблона, начиная с @code{and}, с одним или
несколькими @var{symbol} суб-шаблонами, обеспечивающими привязку к
последующим суб-шаблонам (а также к формам тела).  Например, следующий шаблон
соответствует однозначным целым числам.

@example
@group
(and
  (pred integerp)
  n                     ; @r{связывают @code{n} с @var{expval}}
  (guard (<= -9 n 9)))
@end group
@end example

@noindent
Во-первых, @code{pred} соответствует, если @w{@code{(integerp @var{expval})}}
принимает значение не-@code{nil}.  Далее, @code{n} является шаблоном
@var{symbol}, который соответствует чему угодно и привязывает @code{n} к
@var{expval}.  Наконец, @code{guard} соответствует, если логическое выражение
@w{@code{(<= -9 n 9)}} (обратите внимание на ссылку на @code{n}) оценивается
в не-@code{nil}. Если все эти суб-шаблоны совпадают, @code{and}
соответствует.

@anchor{pcase-example-2}
@subheading Пример: Переформулировка для @code{pcase}

Вот еще один пример, который показывает, как переформулировать простую задачу
сопостовления с её традиционной реализацией (функция @code{grok/traditional})
на задачу с использованием @code{pcase} (функции @code{grok/pcase}).  Строка
документации для обеих этих функций: ``Если OBJ является строка вида
"key:NUMBER", возвращается NUMBER (строка). В противном случае возвращается
список ("149" по умолчанию).''.  Во-первых, традиционная реализация
(@pxref{Regular Expressions}):

@example
@group
(defun grok/traditional (obj)
  (if (and (stringp obj)
           (string-match "^key:\\([[:digit:]]+\\)$" obj))
      (match-string 1 obj)
    (list "149" 'default)))
@end group

@group
(grok/traditional "key:0")   @result{} "0"
(grok/traditional "key:149") @result{} "149"
(grok/traditional 'monolith) @result{} ("149" default)
@end group
@end example

@noindent
Переформулировка демонстрирует @var{symbol} связывания, а также @code{or},
@code{and}, @code{pred}, @code{app} и @code{let}.

@example
@group
(defun grok/pcase (obj)
  (pcase obj
    ((or                                     ; @r{строка 1}
      (and                                   ; @r{строка 2}
       (pred stringp)                        ; @r{строка 3}
       (pred (string-match                   ; @r{строка 4}
              "^key:\\([[:digit:]]+\\)$"))   ; @r{строка 5}
       (app (match-string 1)                 ; @r{строка 6}
            val))                            ; @r{строка 7}
      (let val (list "149" 'default)))       ; @r{строка 8}
     val)))                                  ; @r{строка 9}
@end group

@group
(grok/pcase "key:0")   @result{} "0"
(grok/pcase "key:149") @result{} "149"
(grok/pcase 'monolith) @result{} ("149" по умолчанию)
@end group
@end example

@noindent
Основная часть @code{grok/pcase} - это одна альтернатива формы @code{pcase},
шаблоны на строках 1-8, (единственная) основная форма в строке 9.  Шаблон
@code{or}, который пытается сопоставить в свою очередь, подшаблоны
аргументов, первым @code{and} (строки 2-7), а затем @code{let} (строка 8),
пока один из них не совпадёт.

Как и в предыдущем примере (@pxref{pcase-example-1,,Example 1}), @code{and}
начинается с @code{pred} суб-шаблоном, чтобы обеспечить следующие подшаблоны
работать с объектом правильного типа (строкой, в данном случае).  Если
@w{@code{(stringp @var{expval})}} возвращает @code{nil}, @code{pred} терпит
неудачу, и, таким образом, @code{and} также терпит неудачу.

Следующая @code{pred} (строки 4-5) оценивает
@w{@code{(string-match RX @var{expval})}} и соответствует, если результат
установлен в не-@code{nil}, что означает, что @var{expval} имеет нужную
форму: @code{key:NUMBER}.  Опять же, если это невозможно, @code{pred}
терпит неудачу как и @code{and}.

И наконец (в этой серии @code{and} подшаблонов), @code{app} оценивает
@w{@code{(match-string 1 @var{expval})}} (строка 6), чтобы получить
@var{tmp} временное значение (то есть, ``NUMBER'' подстроку) и пытается
соответствовать @var{tmp} шаблону @code{val} (строка 7). Поскольку это
шаблон @var{symbol}, он соответствует безоговорочно и дополнительно
связывает @code{val} с @var{tmp}.

Теперь, когда @code{app} совпало, все @code{and} суб-шаблоны совпали, и
поэтому @code{and} совпадает.  Точно так же, как только @code{and} совпало,
@code{or} не проводит попытки сопоставления суб-шаблона @code{let}
(строка 8).

Давайте рассмотрим ситуацию, когда @code{obj} не является строкой, или это
строка неправильной  формы.  В этом случае, одна из @code{pred} (строки 3-5)
не совпадает, таким образом, @code{and} (строка 2) не совпадает, таким
образом, @code{or} (линия 1) переходит к сопоставлению под-шаблона @code{let}
(строка 8).

Во-первых, @code{let} оценивает @w{@code{(list "149" 'default)}} чтобы
получить @w{@code{("149" default)}}, в @var{exprval}, а затем пытается
сопоставить @var{exprval} с шаблоном @code{val}.  Поскольку это шаблон
@var{symbol}, он соответствует безоговорочно и дополнительно связывает
@code{val} с @var{exprval}. Теперь, когда @code{let} совпало, @code{or}
совпадает.

Обратите внимание, как оба @code{and} и @code{let} подшаблоны оканчиваются
одинаковым образом: пытаясь (всегда успешно), сопоставить @var{symbol} с
@code{val}, в процессе связывания @code{val}.  Таким образом, @code{or}
всегда соответствует и управления всегда переходит к форме тела (строка 9).
Поскольук это последняя форма тела в успешно согласованной альтернативе
@code{pcase}, это значение @code{pcase} также возвращаемое значение
@code{grok/pcase} (@pxref{What Is a Function}).

@anchor{pcase-symbol-caveats}
@subheading Предостережения для @var{символа} в Последовательностях Шаблонов

The preceding examples all use sequencing patterns
which include the @var{symbol}
sub-pattern in some way.
Here are some important details about that usage.

@enumerate
@item When @var{symbol} occurs more than once in @var{seqpat},
the second and subsequent occurrences do not expand to re-binding,
but instead expand to an equality test using @code{eq}.

The following example features a @code{pcase} form
with two clauses and two @var{seqpat}, A and B.
Both A and B first check that @var{expval} is a
pair (using @code{pred}),
and then bind symbols to the @code{car} and @code{cdr}
of @var{expval} (using one @code{app} each).

For A, because symbol @code{st} is mentioned twice, the second
mention becomes an equality test using @code{eq}.
On the other hand, B uses two separate symbols, @code{s1} and
@code{s2}, both of which become independent bindings.

@example
@group
(defun grok (object)
  (pcase object
    ((and (pred consp)        ; seqpat A
          (app car st)        ; first mention: st
          (app cdr st))       ; second mention: st
     (list 'eq st))
@end group
@group
    ((and (pred consp)        ; seqpat B
          (app car s1)        ; first mention: s1
          (app cdr s2))       ; first mention: s2
     (list 'not-eq s1 s2))))
@end group

@group
(let ((s "yow!"))
  (grok (cons s s)))      @result{} (eq "yow!")
(grok (cons "yo!" "yo!")) @result{} (not-eq "yo!" "yo!")
(grok '(4 2))             @result{} (not-eq 4 (2))
@end group
@end example

@item Side-effecting code referencing @var{symbol} is undefined.
Avoid.
For example, here are two similar functions.
Both use @code{and}, @var{symbol} and @code{guard}:

@example
@group
(defun square-double-digit-p/CLEAN (integer)
  (pcase (* integer integer)
    ((and n (guard (< 9 n 100))) (list 'yes n))
    (sorry (list 'no sorry))))

(square-double-digit-p/CLEAN 9) @result{} (yes 81)
(square-double-digit-p/CLEAN 3) @result{} (no 9)
@end group

@group
(defun square-double-digit-p/MAYBE (integer)
  (pcase (* integer integer)
    ((and n (guard (< 9 (incf n) 100))) (list 'yes n))
    (sorry (list 'no sorry))))

(square-double-digit-p/MAYBE 9) @result{} (yes 81)
(square-double-digit-p/MAYBE 3) @result{} (yes 9)  ; @r{WRONG!}
@end group
@end example

@noindent
The difference is in @var{boolean-expression} in @code{guard}:
@code{CLEAN} references @code{n} simply and directly,
while @code{MAYBE} references @code{n} with a side-effect,
in the expression @code{(incf n)}.
When @code{integer} is 3, here's what happens:

@itemize
@item The first @code{n} binds it to @var{expval},
i.e., the result of evaluating @code{(* 3 3)}, or 9.

@item @var{boolean-expression} is evaluated:

@example
@group
start:   (< 9 (incf n)        100)
becomes: (< 9 (setq n (1+ n)) 100)
becomes: (< 9 (setq n (1+ 9)) 100)
@end group
@group
becomes: (< 9 (setq n 10)     100)
                                   ; @r{side-effect here!}
becomes: (< 9       n         100) ; @r{@code{n} now bound to 10}
becomes: (< 9      10         100)
becomes: t
@end group
@end example

@item Because the result of the evaluation is non-@code{nil},
@code{guard} matches, @code{and} matches, and
control passes to that clause's body forms.
@end itemize

@noindent
Aside from the mathematical incorrectness of asserting that 9 is a
double-digit integer, there is another problem with @code{MAYBE}.
The body form references @code{n} once more, yet we do not see
the updated value---10---at all.  What happened to it?

To sum up, it's best to avoid side-effecting references to
@var{symbol} patterns entirely, not only
in @var{boolean-expression} (in @code{guard}),
but also in @var{expr} (in @code{let})
and @var{function} (in @code{pred} and @code{app}).

@item On match, the clause's body forms can reference the set
of symbols the pattern let-binds.
When @var{seqpat} is @code{and}, this set is
the union of all the symbols each of its sub-patterns let-binds.
This makes sense because, for @code{and} to match,
all the sub-patterns must match.

When @var{seqpat} is @code{or}, things are different:
@code{or} matches at the first sub-pattern that matches;
the rest of the sub-patterns are ignored.
It makes no sense for each sub-pattern to let-bind a different
set of symbols because the body forms have no way to distinguish
which sub-pattern matched and choose among the different sets.
For example, the following is invalid:

@example
@group
(pcase (read-number "Enter an integer: ")
  ((or (and (pred evenp)
            e-num)      ; @r{bind @code{e-num} to @var{expval}}
       o-num)           ; @r{bind @code{o-num} to @var{expval}}
   (list e-num o-num)))
@end group

@group
Enter an integer: 42
@error{} Symbol’s value as variable is void: o-num
@end group
@group
Enter an integer: 149
@error{} Symbol’s value as variable is void: e-num
@end group
@end example

@noindent
Evaluating body form @w{@code{(list e-num o-num)}} signals error.
To distinguish between sub-patterns, you can use another symbol,
identical in name in all sub-patterns but differing in value.
Reworking the above example:

@example
@group
(pcase (read-number "Enter an integer: ")
  ((and num                                ; @r{line 1}
        (or (and (pred evenp)              ; @r{line 2}
                 (let spin 'even))         ; @r{line 3}
            (let spin 'odd)))              ; @r{line 4}
   (list spin num)))                       ; @r{line 5}
@end group

@group
Enter an integer: 42
@result{} (even 42)
@end group
@group
Enter an integer: 149
@result{} (odd 149)
@end group
@end example

@noindent
Line 1 ``factors out'' the @var{expval} binding with
@code{and} and @var{symbol} (in this case, @code{num}).
On line 2, @code{or} begins in the same way as before,
but instead of binding different symbols, uses @code{let} twice
(lines 3-4) to bind the same symbol @code{spin} in both sub-patterns.
The value of @code{spin} distinguishes the sub-patterns.
The body form references both symbols (line 5).
@end enumerate

@node Extending pcase
@subsection Extending @code{pcase}
@cindex pcase, defining new kinds of patterns

The @code{pcase} macro supports several kinds of patterns
(@pxref{Pattern-Matching Conditional}).
You can add support for other kinds of patterns
using the @code{pcase-defmacro} macro.

@defmac pcase-defmacro name args [doc] &rest body
Define a new kind of pattern for @code{pcase}, to be invoked
as @w{@code{(@var{name} @var{actual-args})}}.
The @code{pcase} macro expands this into a function call
that evaluates @var{body}, whose job it is to
rewrite the invoked pattern into some other pattern,
in an environment where @var{args} are bound to @var{actual-args}.

Additionally, arrange to display @var{doc} along with
the docstring of @code{pcase}.
By convention, @var{doc} should use @code{EXPVAL}
to stand for the result of
evaluating @var{expression} (first arg to @code{pcase}).
@end defmac

@noindent
Typically, @var{body} rewrites the invoked pattern
to use more basic patterns.
Although all patterns eventually reduce to core patterns,
@code{body} need not use core patterns straight away.
The following example defines two patterns, named
@code{less-than} and @code{integer-less-than}.

@example
@group
(pcase-defmacro less-than (n)
  "Matches if EXPVAL is a number less than N."
  `(pred (> ,n)))
@end group

@group
(pcase-defmacro integer-less-than (n)
  "Matches if EXPVAL is an integer less than N."
  `(and (pred integerp)
        (less-than ,n)))
@end group
@end example

@noindent
Note that the docstrings mention @var{args}
(in this case, only one: @code{n}) in the usual way,
and also mention @code{EXPVAL} by convention.
The first rewrite (i.e., @var{body} for @code{less-than})
uses one core pattern: @code{pred}.
The second uses two core patterns: @code{and} and @code{pred},
as well as the newly-defined pattern @code{less-than}.
Both use a single backquote construct (@pxref{Backquote}).

@node Backquote Patterns
@subsection Backquote-Style Patterns
@cindex backquote-style patterns
@cindex matching, structural
@cindex structural matching

This subsection describes @dfn{backquote-style patterns},
a set of builtin patterns that eases structural matching.
For background, @pxref{Pattern-Matching Conditional}.

Backquote-style patterns are a powerful set of @code{pcase} pattern
extensions (created using @code{pcase-defmacro}) that make it easy to
match @var{expval} against specifications of its @emph{structure}.

For example, to match @var{expval} that must be a list of two
elements whose first element is a specific string and the second
element is any value, you can write a core pattern:

@example
@group
(and (pred listp)
     ls
@end group
@group
     (guard (= 2 (length ls)))
     (guard (string= "first" (car ls)))
     (let second-elem (cadr ls)))
@end group
@end example

@noindent
or you can write the equivalent backquote-style pattern:

@example
`("first" ,second-elem)
@end example

@noindent
The backquote-style pattern is more concise,
resembles the structure of @var{expval},
and avoids binding @code{ls}.

A backquote-style pattern has the form @code{`@var{qpat}} where
@var{qpat} can have the following forms:

@table @code

@item (@var{qpat1} . @var{qpat2})
Matches if @var{expval} is a cons cell whose @code{car}
matches @var{qpat1} and whose @code{cdr} matches @var{qpat2}.
This readily generalizes to lists as in
@w{@code{(@var{qpat1} @var{qpat2} @dots{})}}.

@item [@var{qpat1} @var{qpat2} @dots{} @var{qpatm}]
Matches if @var{expval} is a vector of length @var{m} whose
@code{0}..@code{(@var{m}-1)}th elements match @var{qpat1},
@var{qpat2} @dots{} @var{qpatm}, respectively.

@item @var{symbol}
@itemx @var{keyword}
@itemx @var{integer}
@itemx @var{string}
Matches if the corresponding element of @var{expval} is
@code{equal} to the specified literal object.
Note that, aside from @var{symbol}, this is the same set of
self-quoting literal objects that are acceptable as a core pattern.

@item ,@var{pattern}
Matches if the corresponding element of @var{expval}
matches @var{pattern}.
Note that @var{pattern} is any kind that @code{pcase} supports.
(In the example above, @code{second-elem} is a @var{symbol}
core pattern; it therefore matches anything,
and let-binds @code{second-elem}.)
@end table

The @dfn{corresponding element} is the portion of @var{expval}
that is in the same structural position as the structural position
of @var{qpat} in the backquote-style pattern.
(In the example above, the corresponding element of
@code{second-elem} is the second element of @var{expval}.)

Here is an example of using @code{pcase} to implement a simple
interpreter for a little expression language
(note that this requires lexical binding for the
lambda expression in the @code{fn} clause to properly
capture @code{body} and @code{arg} (@pxref{Lexical Binding}):

@example
@group
(defun evaluate (form env)
  (pcase form
    (`(add ,x ,y)       (+ (evaluate x env)
                           (evaluate y env)))
@end group
@group
    (`(call ,fun ,arg)  (funcall (evaluate fun env)
                                 (evaluate arg env)))
    (`(fn ,arg ,body)   (lambda (val)
                          (evaluate body (cons (cons arg val)
                                               env))))
@end group
@group
    ((pred numberp)     form)
    ((pred symbolp)     (cdr (assq form env)))
    (_                  (error "Syntax error: %S" form))))
@end group
@end example

@noindent
The first three clauses use backquote-style patterns.
@code{`(add ,x ,y)} is a pattern that checks that @code{form}
is a three-element list starting with the literal symbol @code{add},
then extracts the second and third elements and binds them
to symbols @code{x} and @code{y}, respectively.
The clause body evaluates @code{x} and @code{y} and adds the results.
Similarly, the @code{call} clause implements a function call,
and the @code{fn} clause implements an anonymous function definition.

The remaining clauses use core patterns.
@code{(pred numberp)} matches if @code{form} is a number.
On match, the body evaluates it.
@code{(pred symbolp)} matches if @code{form} is a symbol.
On match, the body looks up the symbol in @code{env} and
returns its association.
Finally, @code{_} is the catch-all pattern that
matches anything, so it's suitable for reporting syntax errors.

Here are some sample programs in this small language, including their
evaluation results:

@example
(evaluate '(add 1 2) nil)                 @result{} 3
(evaluate '(add x y) '((x . 1) (y . 2)))  @result{} 3
(evaluate '(call (fn x (add 1 x)) 2) nil) @result{} 3
(evaluate '(sub 1 2) nil)                 @result{} error
@end example

@node Destructuring with pcase Patterns
@subsection Destructuring with @code{pcase} Patterns
@cindex destructuring with pcase patterns

Pcase patterns not only express a condition on the form of the objects
they can match, but they can also extract sub-fields of those objects.
For example we can extract 2 elements from a list that is the value of
the variable @code{my-list} with the following code:

@example
  (pcase my-list
    (`(add ,x ,y)  (message "Contains %S and %S" x y)))
@end example

This will not only extract @code{x} and @code{y} but will additionally
test that @code{my-list} is a list containing exactly 3 elements and
whose first element is the symbol @code{add}.  If any of those tests
fail, @code{pcase} will immediately return @code{nil} without calling
@code{message}.

Extraction of multiple values stored in an object is known as
@dfn{destructuring}.  Using @code{pcase} patterns allows to perform
@dfn{destructuring binding}, which is similar to a local binding
(@pxref{Local Variables}), but gives values to multiple elements of
a variable by extracting those values from an object of compatible
structure.

The macros described in this section use @code{pcase} patterns to
perform destructuring binding.  The condition of the object to be of
compatible structure means that the object must match the pattern,
because only then the object's subfields can be extracted.  For
example:

@example
  (pcase-let ((`(add ,x ,y) my-list))
    (message "Contains %S and %S" x y))
@end example

@noindent
does the same as the previous example, except that it directly tries
to extract @code{x} and @code{y} from @code{my-list} without first
verifying if @code{my-list} is a list which has the right number of
elements and has @code{add} as its first element.  The precise
behavior when the object does not actually match the pattern is
undefined, although the body will not be silently skipped: either an
error is signaled or the body is run with some of the variables
potentially bound to arbitrary values like @code{nil}.

The pcase patterns that are useful for destructuring bindings are
generally those described in @ref{Backquote Patterns}, since they
express a specification of the structure of objects that will match.

For an alternative facility for destructuring binding, see
@ref{seq-let}.

@defmac pcase-let bindings body@dots{}
Perform destructuring binding of variables according to
@var{bindings}, and then evaluate @var{body}.

@var{bindings} is a list of bindings of the form @w{@code{(@var{pattern}
@var{exp})}}, where @var{exp} is an expression to evaluate and
@var{pattern} is a @code{pcase} pattern.

All @var{exp}s are evaluated first, after which they are matched
against their respective @var{pattern}, introducing new variable
bindings that can then be used inside @var{body}.  The variable
bindings are produced by destructuring binding of elements of
@var{pattern} to the values of the corresponding elements of the
evaluated @var{exp}.
@end defmac

@defmac pcase-let* bindings body@dots{}
Perform destructuring binding of variables according to
@var{bindings}, and then evaluate @var{body}.

@var{bindings} is a list of bindings of the form @code{(@var{pattern}
@var{exp})}, where @var{exp} is an expression to evaluate and
@var{pattern} is a @code{pcase} pattern.  The variable bindings are
produced by destructuring binding of elements of @var{pattern} to the
values of the corresponding elements of the evaluated @var{exp}.

Unlike @code{pcase-let}, but similarly to @code{let*}, each @var{exp}
is matched against its corresponding @var{pattern} before processing
the next element of @var{bindings}, so the variable bindings
introduced in each one of the @var{bindings} are available in the
@var{exp}s of the @var{bindings} that follow it, additionally to
being available in @var{body}.
@end defmac

@defmac pcase-dolist (pattern list) body@dots{}
Execute @var{body} once for each element of @var{list}, on each
iteration performing a destructuring binding of variables in
@var{pattern} to the values of the corresponding subfields of the
element of @var{list}.  The bindings are performed as if by
@code{pcase-let}.  When @var{pattern} is a simple variable, this ends
up being equivalent to @code{dolist} (@pxref{Iteration}).
@end defmac


@node Iteration
@section Iteration
@cindex iteration
@cindex recursion
@cindex forms, iteration

  Iteration means executing part of a program repetitively.  For
example, you might want to repeat some computation once for each element
of a list, or once for each integer from 0 to @var{n}.  You can do this
in Emacs Lisp with the special form @code{while}:

@defspec while condition forms@dots{}
@code{while} first evaluates @var{condition}.  If the result is
non-@code{nil}, it evaluates @var{forms} in textual order.  Then it
reevaluates @var{condition}, and if the result is non-@code{nil}, it
evaluates @var{forms} again.  This process repeats until @var{condition}
evaluates to @code{nil}.

There is no limit on the number of iterations that may occur.  The loop
will continue until either @var{condition} evaluates to @code{nil} or
until an error or @code{throw} jumps out of it (@pxref{Nonlocal Exits}).

The value of a @code{while} form is always @code{nil}.

@example
@group
(setq num 0)
     @result{} 0
@end group
@group
(while (< num 4)
  (princ (format "Iteration %d." num))
  (setq num (1+ num)))
     @print{} Iteration 0.
     @print{} Iteration 1.
     @print{} Iteration 2.
     @print{} Iteration 3.
     @result{} nil
@end group
@end example

To write a repeat-until loop, which will execute something on each
iteration and then do the end-test, put the body followed by the
end-test in a @code{progn} as the first argument of @code{while}, as
shown here:

@example
@group
(while (progn
         (forward-line 1)
         (not (looking-at "^$"))))
@end group
@end example

@noindent
This moves forward one line and continues moving by lines until it
reaches an empty line.  It is peculiar in that the @code{while} has no
body, just the end test (which also does the real work of moving point).
@end defspec

  The @code{dolist} and @code{dotimes} macros provide convenient ways to
write two common kinds of loops.

@defmac dolist (var list [result]) body@dots{}
This construct executes @var{body} once for each element of
@var{list}, binding the variable @var{var} locally to hold the current
element.  Then it returns the value of evaluating @var{result}, or
@code{nil} if @var{result} is omitted.  For example, here is how you
could use @code{dolist} to define the @code{reverse} function:

@example
(defun reverse (list)
  (let (value)
    (dolist (elt list value)
      (setq value (cons elt value)))))
@end example
@end defmac

@defmac dotimes (var count [result]) body@dots{}
This construct executes @var{body} once for each integer from 0
(inclusive) to @var{count} (exclusive), binding the variable @var{var}
to the integer for the current iteration.  Then it returns the value
of evaluating @var{result}, or @code{nil} if @var{result} is omitted.
Here is an example of using @code{dotimes} to do something 100 times:

@example
(dotimes (i 100)
  (insert "I will not obey absurd orders\n"))
@end example
@end defmac

@node Generators
@section Generators
@cindex generators

  A @dfn{generator} is a function that produces a potentially-infinite
stream of values.  Each time the function produces a value, it
suspends itself and waits for a caller to request the next value.

@defmac iter-defun name args [doc] [declare] [interactive] body@dots{}
@code{iter-defun} defines a generator function.  A generator function
has the same signature as a normal function, but works differently.
Instead of executing @var{body} when called, a generator function
returns an iterator object.  That iterator runs @var{body} to generate
values, emitting a value and pausing where @code{iter-yield} or
@code{iter-yield-from} appears.  When @var{body} returns normally,
@code{iter-next} signals @code{iter-end-of-sequence} with @var{body}'s
result as its condition data.

Any kind of Lisp code is valid inside @var{body}, but
@code{iter-yield} and @code{iter-yield-from} cannot appear inside
@code{unwind-protect} forms.

@end defmac

@defmac iter-lambda args [doc] [interactive] body@dots{}
@code{iter-lambda} produces an unnamed generator function that works
just like a generator function produced with @code{iter-defun}.
@end defmac

@defmac iter-yield value
When it appears inside a generator function, @code{iter-yield}
indicates that the current iterator should pause and return
@var{value} from @code{iter-next}.  @code{iter-yield} evaluates to the
@code{value} parameter of next call to @code{iter-next}.
@end defmac

@defmac iter-yield-from iterator
@code{iter-yield-from} yields all the values that @var{iterator}
produces and evaluates to the value that @var{iterator}'s generator
function returns normally.  While it has control, @var{iterator}
receives values sent to the iterator using @code{iter-next}.
@end defmac

  To use a generator function, first call it normally, producing a
@dfn{iterator} object.  An iterator is a specific instance of a
generator.  Then use @code{iter-next} to retrieve values from this
iterator.  When there are no more values to pull from an iterator,
@code{iter-next} raises an @code{iter-end-of-sequence} condition with
the iterator's final value.

It's important to note that generator function bodies only execute
inside calls to @code{iter-next}.  A call to a function defined with
@code{iter-defun} produces an iterator; you must drive this
iterator with @code{iter-next} for anything interesting to happen.
Each call to a generator function produces a @emph{different}
iterator, each with its own state.

@defun iter-next iterator value
Retrieve the next value from @var{iterator}.  If there are no more
values to be generated (because @var{iterator}'s generator function
returned), @code{iter-next} signals the @code{iter-end-of-sequence}
condition; the data value associated with this condition is the value
with which @var{iterator}'s generator function returned.

@var{value} is sent into the iterator and becomes the value to which
@code{iter-yield} evaluates.  @var{value} is ignored for the first
@code{iter-next} call to a given iterator, since at the start of
@var{iterator}'s generator function, the generator function is not
evaluating any @code{iter-yield} form.
@end defun

@defun iter-close iterator
If @var{iterator} is suspended inside an @code{unwind-protect}'s
@code{bodyform} and becomes unreachable, Emacs will eventually run
unwind handlers after a garbage collection pass.  (Note that
@code{iter-yield} is illegal inside an @code{unwind-protect}'s
@code{unwindforms}.)  To ensure that these handlers are run before
then, use @code{iter-close}.
@end defun

Some convenience functions are provided to make working with
iterators easier:

@defmac iter-do (var iterator) body @dots{}
Run @var{body} with @var{var} bound to each value that
@var{iterator} produces.
@end defmac

The Common Lisp loop facility also contains features for working with
iterators.  @xref{Loop Facility,,,cl,Common Lisp Extensions}.

The following piece of code demonstrates some important principles of
working with iterators.

@example
(require 'generator)
(iter-defun my-iter (x)
  (iter-yield (1+ (iter-yield (1+ x))))
   ;; Return normally
  -1)

(let* ((iter (my-iter 5))
       (iter2 (my-iter 0)))
  ;; Prints 6
  (print (iter-next iter))
  ;; Prints 9
  (print (iter-next iter 8))
  ;; Prints 1; iter and iter2 have distinct states
  (print (iter-next iter2 nil))

  ;; We expect the iter sequence to end now
  (condition-case x
      (iter-next iter)
    (iter-end-of-sequence
      ;; Prints -1, which my-iter returned normally
      (print (cdr x)))))
@end example

@node Nonlocal Exits
@section Nonlocal Exits
@cindex nonlocal exits

  A @dfn{nonlocal exit} is a transfer of control from one point in a
program to another remote point.  Nonlocal exits can occur in Emacs Lisp
as a result of errors; you can also use them under explicit control.
Nonlocal exits unbind all variable bindings made by the constructs being
exited.

@menu
* Catch and Throw::     Nonlocal exits for the program's own purposes.
* Examples of Catch::   Showing how such nonlocal exits can be written.
* Errors::              How errors are signaled and handled.
* Cleanups::            Arranging to run a cleanup form if an error happens.
@end menu

@node Catch and Throw
@subsection Explicit Nonlocal Exits: @code{catch} and @code{throw}
@cindex forms for nonlocal exits

  Most control constructs affect only the flow of control within the
construct itself.  The function @code{throw} is the exception to this
rule of normal program execution: it performs a nonlocal exit on
request.  (There are other exceptions, but they are for error handling
only.)  @code{throw} is used inside a @code{catch}, and jumps back to
that @code{catch}.  For example:

@example
@group
(defun foo-outer ()
  (catch 'foo
    (foo-inner)))

(defun foo-inner ()
  @dots{}
  (if x
      (throw 'foo t))
  @dots{})
@end group
@end example

@noindent
The @code{throw} form, if executed, transfers control straight back to
the corresponding @code{catch}, which returns immediately.  The code
following the @code{throw} is not executed.  The second argument of
@code{throw} is used as the return value of the @code{catch}.

  The function @code{throw} finds the matching @code{catch} based on the
first argument: it searches for a @code{catch} whose first argument is
@code{eq} to the one specified in the @code{throw}.  If there is more
than one applicable @code{catch}, the innermost one takes precedence.
Thus, in the above example, the @code{throw} specifies @code{foo}, and
the @code{catch} in @code{foo-outer} specifies the same symbol, so that
@code{catch} is the applicable one (assuming there is no other matching
@code{catch} in between).

  Executing @code{throw} exits all Lisp constructs up to the matching
@code{catch}, including function calls.  When binding constructs such
as @code{let} or function calls are exited in this way, the bindings
are unbound, just as they are when these constructs exit normally
(@pxref{Local Variables}).  Likewise, @code{throw} restores the buffer
and position saved by @code{save-excursion} (@pxref{Excursions}), and
the narrowing status saved by @code{save-restriction}.  It also runs
any cleanups established with the @code{unwind-protect} special form
when it exits that form (@pxref{Cleanups}).

  The @code{throw} need not appear lexically within the @code{catch}
that it jumps to.  It can equally well be called from another function
called within the @code{catch}.  As long as the @code{throw} takes place
chronologically after entry to the @code{catch}, and chronologically
before exit from it, it has access to that @code{catch}.  This is why
@code{throw} can be used in commands such as @code{exit-recursive-edit}
that throw back to the editor command loop (@pxref{Recursive Editing}).

@cindex CL note---only @code{throw} in Emacs
@quotation
@b{Common Lisp note:} Most other versions of Lisp, including Common Lisp,
have several ways of transferring control nonsequentially: @code{return},
@code{return-from}, and @code{go}, for example.  Emacs Lisp has only
@code{throw}.  The @file{cl-lib} library provides versions of some of
these.  @xref{Blocks and Exits,,,cl,Common Lisp Extensions}.
@end quotation

@defspec catch tag body@dots{}
@cindex tag on run time stack
@code{catch} establishes a return point for the @code{throw} function.
The return point is distinguished from other such return points by
@var{tag}, which may be any Lisp object except @code{nil}.  The argument
@var{tag} is evaluated normally before the return point is established.

With the return point in effect, @code{catch} evaluates the forms of the
@var{body} in textual order.  If the forms execute normally (without
error or nonlocal exit) the value of the last body form is returned from
the @code{catch}.

If a @code{throw} is executed during the execution of @var{body},
specifying the same value @var{tag}, the @code{catch} form exits
immediately; the value it returns is whatever was specified as the
second argument of @code{throw}.
@end defspec

@defun throw tag value
The purpose of @code{throw} is to return from a return point previously
established with @code{catch}.  The argument @var{tag} is used to choose
among the various existing return points; it must be @code{eq} to the value
specified in the @code{catch}.  If multiple return points match @var{tag},
the innermost one is used.

The argument @var{value} is used as the value to return from that
@code{catch}.

@kindex no-catch
If no return point is in effect with tag @var{tag}, then a @code{no-catch}
error is signaled with data @code{(@var{tag} @var{value})}.
@end defun

@node Examples of Catch
@subsection Examples of @code{catch} and @code{throw}

  One way to use @code{catch} and @code{throw} is to exit from a doubly
nested loop.  (In most languages, this would be done with a @code{goto}.)
Here we compute @code{(foo @var{i} @var{j})} for @var{i} and @var{j}
varying from 0 to 9:

@example
@group
(defun search-foo ()
  (catch 'loop
    (let ((i 0))
      (while (< i 10)
        (let ((j 0))
          (while (< j 10)
            (if (foo i j)
                (throw 'loop (list i j)))
            (setq j (1+ j))))
        (setq i (1+ i))))))
@end group
@end example

@noindent
If @code{foo} ever returns non-@code{nil}, we stop immediately and return a
list of @var{i} and @var{j}.  If @code{foo} always returns @code{nil}, the
@code{catch} returns normally, and the value is @code{nil}, since that
is the result of the @code{while}.

  Here are two tricky examples, slightly different, showing two
return points at once.  First, two return points with the same tag,
@code{hack}:

@example
@group
(defun catch2 (tag)
  (catch tag
    (throw 'hack 'yes)))
@result{} catch2
@end group

@group
(catch 'hack
  (print (catch2 'hack))
  'no)
@print{} yes
@result{} no
@end group
@end example

@noindent
Since both return points have tags that match the @code{throw}, it goes to
the inner one, the one established in @code{catch2}.  Therefore,
@code{catch2} returns normally with value @code{yes}, and this value is
printed.  Finally the second body form in the outer @code{catch}, which is
@code{'no}, is evaluated and returned from the outer @code{catch}.

  Now let's change the argument given to @code{catch2}:

@example
@group
(catch 'hack
  (print (catch2 'quux))
  'no)
@result{} yes
@end group
@end example

@noindent
We still have two return points, but this time only the outer one has
the tag @code{hack}; the inner one has the tag @code{quux} instead.
Therefore, @code{throw} makes the outer @code{catch} return the value
@code{yes}.  The function @code{print} is never called, and the
body-form @code{'no} is never evaluated.

@node Errors
@subsection Errors
@cindex errors

  When Emacs Lisp attempts to evaluate a form that, for some reason,
cannot be evaluated, it @dfn{signals} an @dfn{error}.

  When an error is signaled, Emacs's default reaction is to print an
error message and terminate execution of the current command.  This is
the right thing to do in most cases, such as if you type @kbd{C-f} at
the end of the buffer.

  In complicated programs, simple termination may not be what you want.
For example, the program may have made temporary changes in data
structures, or created temporary buffers that should be deleted before
the program is finished.  In such cases, you would use
@code{unwind-protect} to establish @dfn{cleanup expressions} to be
evaluated in case of error.  (@xref{Cleanups}.)  Occasionally, you may
wish the program to continue execution despite an error in a subroutine.
In these cases, you would use @code{condition-case} to establish
@dfn{error handlers} to recover control in case of error.

  Resist the temptation to use error handling to transfer control from
one part of the program to another; use @code{catch} and @code{throw}
instead.  @xref{Catch and Throw}.

@menu
* Signaling Errors::      How to report an error.
* Processing of Errors::  What Emacs does when you report an error.
* Handling Errors::       How you can trap errors and continue execution.
* Error Symbols::         How errors are classified for trapping them.
@end menu

@node Signaling Errors
@subsubsection How to Signal an Error
@cindex signaling errors

   @dfn{Signaling} an error means beginning error processing.  Error
processing normally aborts all or part of the running program and
returns to a point that is set up to handle the error
(@pxref{Processing of Errors}).  Here we describe how to signal an
error.

  Most errors are signaled automatically within Lisp primitives
which you call for other purposes, such as if you try to take the
@sc{car} of an integer or move forward a character at the end of the
buffer.  You can also signal errors explicitly with the functions
@code{error} and @code{signal}.

  Quitting, which happens when the user types @kbd{C-g}, is not
considered an error, but it is handled almost like an error.
@xref{Quitting}.

  Every error specifies an error message, one way or another.  The
message should state what is wrong (``File does not exist''), not how
things ought to be (``File must exist'').  The convention in Emacs
Lisp is that error messages should start with a capital letter, but
should not end with any sort of punctuation.

@defun error format-string &rest args
This function signals an error with an error message constructed by
applying @code{format-message} (@pxref{Formatting Strings}) to
@var{format-string} and @var{args}.

These examples show typical uses of @code{error}:

@example
@group
(error "That is an error -- try something else")
     @error{} That is an error -- try something else
@end group

@group
(error "Invalid name `%s'" "A%%B")
     @error{} Invalid name ‘A%%B’
@end group
@end example

@code{error} works by calling @code{signal} with two arguments: the
error symbol @code{error}, and a list containing the string returned by
@code{format-message}.

Typically grave accent and apostrophe in the format translate to
matching curved quotes, e.g., @t{"Missing `%s'"} might result in
@t{"Missing ‘foo’"}.  @xref{Text Quoting Style}, for how to influence
or inhibit this translation.

@strong{Warning:} If you want to use your own string as an error message
verbatim, don't just write @code{(error @var{string})}.  If @var{string}
@var{string} contains @samp{%}, @samp{`}, or @samp{'} it may be
reformatted, with undesirable results.  Instead, use @code{(error "%s"
@var{string})}.
@end defun

@defun signal error-symbol data
@anchor{Definition of signal}
This function signals an error named by @var{error-symbol}.  The
argument @var{data} is a list of additional Lisp objects relevant to
the circumstances of the error.

The argument @var{error-symbol} must be an @dfn{error symbol}---a symbol
defined with @code{define-error}.  This is how Emacs Lisp classifies different
sorts of errors.  @xref{Error Symbols}, for a description of error symbols,
error conditions and condition names.

If the error is not handled, the two arguments are used in printing
the error message.  Normally, this error message is provided by the
@code{error-message} property of @var{error-symbol}.  If @var{data} is
non-@code{nil}, this is followed by a colon and a comma separated list
of the unevaluated elements of @var{data}.  For @code{error}, the
error message is the @sc{car} of @var{data} (that must be a string).
Subcategories of @code{file-error} are handled specially.

The number and significance of the objects in @var{data} depends on
@var{error-symbol}.  For example, with a @code{wrong-type-argument} error,
there should be two objects in the list: a predicate that describes the type
that was expected, and the object that failed to fit that type.

Both @var{error-symbol} and @var{data} are available to any error
handlers that handle the error: @code{condition-case} binds a local
variable to a list of the form @code{(@var{error-symbol} .@:
@var{data})} (@pxref{Handling Errors}).

The function @code{signal} never returns.
@c (though in older Emacs versions it sometimes could).

@example
@group
(signal 'wrong-number-of-arguments '(x y))
     @error{} Wrong number of arguments: x, y
@end group

@group
(signal 'no-such-error '("My unknown error condition"))
     @error{} peculiar error: "My unknown error condition"
@end group
@end example
@end defun

@cindex user errors, signaling
@defun user-error format-string &rest args
This function behaves exactly like @code{error}, except that it uses
the error symbol @code{user-error} rather than @code{error}.  As the
name suggests, this is intended to report errors on the part of the
user, rather than errors in the code itself.  For example,
if you try to use the command @code{Info-history-back} (@kbd{l}) to
move back beyond the start of your Info browsing history, Emacs
signals a @code{user-error}.  Such errors do not cause entry to the
debugger, even when @code{debug-on-error} is non-@code{nil}.
@xref{Error Debugging}.
@end defun

@cindex CL note---no continuable errors
@quotation
@b{Common Lisp note:} Emacs Lisp has nothing like the Common Lisp
concept of continuable errors.
@end quotation

@node Processing of Errors
@subsubsection How Emacs Processes Errors
@cindex processing of errors

When an error is signaled, @code{signal} searches for an active
@dfn{handler} for the error.  A handler is a sequence of Lisp
expressions designated to be executed if an error happens in part of the
Lisp program.  If the error has an applicable handler, the handler is
executed, and control resumes following the handler.  The handler
executes in the environment of the @code{condition-case} that
established it; all functions called within that @code{condition-case}
have already been exited, and the handler cannot return to them.

If there is no applicable handler for the error, it terminates the
current command and returns control to the editor command loop.  (The
command loop has an implicit handler for all kinds of errors.)  The
command loop's handler uses the error symbol and associated data to
print an error message.  You can use the variable
@code{command-error-function} to control how this is done:

@defvar command-error-function
This variable, if non-@code{nil}, specifies a function to use to
handle errors that return control to the Emacs command loop.  The
function should take three arguments: @var{data}, a list of the same
form that @code{condition-case} would bind to its variable;
@var{context}, a string describing the situation in which the error
occurred, or (more often) @code{nil}; and @var{caller}, the Lisp
function which called the primitive that signaled the error.
@end defvar

@cindex @code{debug-on-error} use
An error that has no explicit handler may call the Lisp debugger.  The
debugger is enabled if the variable @code{debug-on-error} (@pxref{Error
Debugging}) is non-@code{nil}.  Unlike error handlers, the debugger runs
in the environment of the error, so that you can examine values of
variables precisely as they were at the time of the error.

@node Handling Errors
@subsubsection Writing Code to Handle Errors
@cindex error handler
@cindex handling errors
@cindex forms for handling errors

  The usual effect of signaling an error is to terminate the command
that is running and return immediately to the Emacs editor command loop.
You can arrange to trap errors occurring in a part of your program by
establishing an error handler, with the special form
@code{condition-case}.  A simple example looks like this:

@example
@group
(condition-case nil
    (delete-file filename)
  (error nil))
@end group
@end example

@noindent
This deletes the file named @var{filename}, catching any error and
returning @code{nil} if an error occurs.  (You can use the macro
@code{ignore-errors} for a simple case like this; see below.)

  The @code{condition-case} construct is often used to trap errors that
are predictable, such as failure to open a file in a call to
@code{insert-file-contents}.  It is also used to trap errors that are
totally unpredictable, such as when the program evaluates an expression
read from the user.

  The second argument of @code{condition-case} is called the
@dfn{protected form}.  (In the example above, the protected form is a
call to @code{delete-file}.)  The error handlers go into effect when
this form begins execution and are deactivated when this form returns.
They remain in effect for all the intervening time.  In particular, they
are in effect during the execution of functions called by this form, in
their subroutines, and so on.  This is a good thing, since, strictly
speaking, errors can be signaled only by Lisp primitives (including
@code{signal} and @code{error}) called by the protected form, not by the
protected form itself.

  The arguments after the protected form are handlers.  Each handler
lists one or more @dfn{condition names} (which are symbols) to specify
which errors it will handle.  The error symbol specified when an error
is signaled also defines a list of condition names.  A handler applies
to an error if they have any condition names in common.  In the example
above, there is one handler, and it specifies one condition name,
@code{error}, which covers all errors.

  The search for an applicable handler checks all the established handlers
starting with the most recently established one.  Thus, if two nested
@code{condition-case} forms offer to handle the same error, the inner of
the two gets to handle it.

  If an error is handled by some @code{condition-case} form, this
ordinarily prevents the debugger from being run, even if
@code{debug-on-error} says this error should invoke the debugger.

  If you want to be able to debug errors that are caught by a
@code{condition-case}, set the variable @code{debug-on-signal} to a
non-@code{nil} value.  You can also specify that a particular handler
should let the debugger run first, by writing @code{debug} among the
conditions, like this:

@example
@group
(condition-case nil
    (delete-file filename)
  ((debug error) nil))
@end group
@end example

@noindent
The effect of @code{debug} here is only to prevent
@code{condition-case} from suppressing the call to the debugger.  Any
given error will invoke the debugger only if @code{debug-on-error} and
the other usual filtering mechanisms say it should.  @xref{Error Debugging}.

@defmac condition-case-unless-debug var protected-form handlers@dots{}
The macro @code{condition-case-unless-debug} provides another way to
handle debugging of such forms.  It behaves exactly like
@code{condition-case}, unless the variable @code{debug-on-error} is
non-@code{nil}, in which case it does not handle any errors at all.
@end defmac

  Once Emacs decides that a certain handler handles the error, it
returns control to that handler.  To do so, Emacs unbinds all variable
bindings made by binding constructs that are being exited, and
executes the cleanups of all @code{unwind-protect} forms that are
being exited.  Once control arrives at the handler, the body of the
handler executes normally.

  After execution of the handler body, execution returns from the
@code{condition-case} form.  Because the protected form is exited
completely before execution of the handler, the handler cannot resume
execution at the point of the error, nor can it examine variable
bindings that were made within the protected form.  All it can do is
clean up and proceed.

  Error signaling and handling have some resemblance to @code{throw} and
@code{catch} (@pxref{Catch and Throw}), but they are entirely separate
facilities.  An error cannot be caught by a @code{catch}, and a
@code{throw} cannot be handled by an error handler (though using
@code{throw} when there is no suitable @code{catch} signals an error
that can be handled).

@defspec condition-case var protected-form handlers@dots{}
This special form establishes the error handlers @var{handlers} around
the execution of @var{protected-form}.  If @var{protected-form} executes
without error, the value it returns becomes the value of the
@code{condition-case} form; in this case, the @code{condition-case} has
no effect.  The @code{condition-case} form makes a difference when an
error occurs during @var{protected-form}.

Each of the @var{handlers} is a list of the form @code{(@var{conditions}
@var{body}@dots{})}.  Here @var{conditions} is an error condition name
to be handled, or a list of condition names (which can include @code{debug}
to allow the debugger to run before the handler); @var{body} is one or more
Lisp expressions to be executed when this handler handles an error.
Here are examples of handlers:

@example
@group
(error nil)

(arith-error (message "Division by zero"))

((arith-error file-error)
 (message
  "Either division by zero or failure to open a file"))
@end group
@end example

Each error that occurs has an @dfn{error symbol} that describes what
kind of error it is, and which describes also a list of condition names
(@pxref{Error Symbols}).  Emacs
searches all the active @code{condition-case} forms for a handler that
specifies one or more of these condition names; the innermost matching
@code{condition-case} handles the error.  Within this
@code{condition-case}, the first applicable handler handles the error.

After executing the body of the handler, the @code{condition-case}
returns normally, using the value of the last form in the handler body
as the overall value.

@cindex error description
The argument @var{var} is a variable.  @code{condition-case} does not
bind this variable when executing the @var{protected-form}, only when it
handles an error.  At that time, it binds @var{var} locally to an
@dfn{error description}, which is a list giving the particulars of the
error.  The error description has the form @code{(@var{error-symbol}
. @var{data})}.  The handler can refer to this list to decide what to
do.  For example, if the error is for failure opening a file, the file
name is the second element of @var{data}---the third element of the
error description.

If @var{var} is @code{nil}, that means no variable is bound.  Then the
error symbol and associated data are not available to the handler.

@cindex rethrow a signal
Sometimes it is necessary to re-throw a signal caught by
@code{condition-case}, for some outer-level handler to catch.  Here's
how to do that:

@example
  (signal (car err) (cdr err))
@end example

@noindent
where @code{err} is the error description variable, the first argument
to @code{condition-case} whose error condition you want to re-throw.
@xref{Definition of signal}.
@end defspec

@defun error-message-string error-descriptor
This function returns the error message string for a given error
descriptor.  It is useful if you want to handle an error by printing the
usual error message for that error.  @xref{Definition of signal}.
@end defun

@cindex @code{arith-error} example
Here is an example of using @code{condition-case} to handle the error
that results from dividing by zero.  The handler displays the error
message (but without a beep), then returns a very large number.

@example
@group
(defun safe-divide (dividend divisor)
  (condition-case err
      ;; @r{Protected form.}
      (/ dividend divisor)
@end group
@group
    ;; @r{The handler.}
    (arith-error                        ; @r{Condition.}
     ;; @r{Display the usual message for this error.}
     (message "%s" (error-message-string err))
     1000000)))
@result{} safe-divide
@end group

@group
(safe-divide 5 0)
     @print{} Arithmetic error: (arith-error)
@result{} 1000000
@end group
@end example

@noindent
The handler specifies condition name @code{arith-error} so that it
will handle only division-by-zero errors.  Other kinds of errors will
not be handled (by this @code{condition-case}).  Thus:

@example
@group
(safe-divide nil 3)
     @error{} Wrong type argument: number-or-marker-p, nil
@end group
@end example

  Here is a @code{condition-case} that catches all kinds of errors,
including those from @code{error}:

@example
@group
(setq baz 34)
     @result{} 34
@end group

@group
(condition-case err
    (if (eq baz 35)
        t
      ;; @r{This is a call to the function @code{error}.}
      (error "Rats!  The variable %s was %s, not 35" 'baz baz))
  ;; @r{This is the handler; it is not a form.}
  (error (princ (format "The error was: %s" err))
         2))
@print{} The error was: (error "Rats!  The variable baz was 34, not 35")
@result{} 2
@end group
@end example

@defmac ignore-errors body@dots{}
This construct executes @var{body}, ignoring any errors that occur
during its execution.  If the execution is without error,
@code{ignore-errors} returns the value of the last form in @var{body};
otherwise, it returns @code{nil}.

Here's the example at the beginning of this subsection rewritten using
@code{ignore-errors}:

@example
@group
  (ignore-errors
   (delete-file filename))
@end group
@end example
@end defmac

@defmac with-demoted-errors format body@dots{}
This macro is like a milder version of @code{ignore-errors}.  Rather
than suppressing errors altogether, it converts them into messages.
It uses the string @var{format} to format the message.
@var{format} should contain a single @samp{%}-sequence; e.g.,
@code{"Error: %S"}.  Use @code{with-demoted-errors} around code
that is not expected to signal errors, but
should be robust if one does occur.  Note that this macro uses
@code{condition-case-unless-debug} rather than @code{condition-case}.
@end defmac

@node Error Symbols
@subsubsection Error Symbols and Condition Names
@cindex error symbol
@cindex error name
@cindex condition name
@cindex user-defined error
@kindex error-conditions
@kindex define-error

  When you signal an error, you specify an @dfn{error symbol} to specify
the kind of error you have in mind.  Each error has one and only one
error symbol to categorize it.  This is the finest classification of
errors defined by the Emacs Lisp language.

  These narrow classifications are grouped into a hierarchy of wider
classes called @dfn{error conditions}, identified by @dfn{condition
names}.  The narrowest such classes belong to the error symbols
themselves: each error symbol is also a condition name.  There are also
condition names for more extensive classes, up to the condition name
@code{error} which takes in all kinds of errors (but not @code{quit}).
Thus, each error has one or more condition names: @code{error}, the
error symbol if that is distinct from @code{error}, and perhaps some
intermediate classifications.

@defun define-error name message &optional parent
  In order for a symbol to be an error symbol, it must be defined with
@code{define-error} which takes a parent condition (defaults to @code{error}).
This parent defines the conditions that this kind of error belongs to.
The transitive set of parents always includes the error symbol itself, and the
symbol @code{error}.  Because quitting is not considered an error, the set of
parents of @code{quit} is just @code{(quit)}.
@end defun

@cindex peculiar error
  In addition to its parents, the error symbol has a @var{message} which
is a string to be printed when that error is signaled but not handled.  If that
message is not valid, the error message @samp{peculiar error} is used.
@xref{Definition of signal}.

Internally, the set of parents is stored in the @code{error-conditions}
property of the error symbol and the message is stored in the
@code{error-message} property of the error symbol.

  Here is how we define a new error symbol, @code{new-error}:

@example
@group
(define-error 'new-error "A new error" 'my-own-errors)
@end group
@end example

@noindent
This error has several condition names: @code{new-error}, the narrowest
classification; @code{my-own-errors}, which we imagine is a wider
classification; and all the conditions of @code{my-own-errors} which should
include @code{error}, which is the widest of all.

  The error string should start with a capital letter but it should
not end with a period.  This is for consistency with the rest of Emacs.

  Naturally, Emacs will never signal @code{new-error} on its own; only
an explicit call to @code{signal} (@pxref{Definition of signal}) in
your code can do this:

@example
@group
(signal 'new-error '(x y))
     @error{} A new error: x, y
@end group
@end example

  This error can be handled through any of its condition names.
This example handles @code{new-error} and any other errors in the class
@code{my-own-errors}:

@example
@group
(condition-case foo
    (bar nil t)
  (my-own-errors nil))
@end group
@end example

  The significant way that errors are classified is by their condition
names---the names used to match errors with handlers.  An error symbol
serves only as a convenient way to specify the intended error message
and list of condition names.  It would be cumbersome to give
@code{signal} a list of condition names rather than one error symbol.

  By contrast, using only error symbols without condition names would
seriously decrease the power of @code{condition-case}.  Condition names
make it possible to categorize errors at various levels of generality
when you write an error handler.  Using error symbols alone would
eliminate all but the narrowest level of classification.

  @xref{Standard Errors}, for a list of the main error symbols
and their conditions.

@node Cleanups
@subsection Cleaning Up from Nonlocal Exits
@cindex nonlocal exits, cleaning up
@cindex forms for cleanup

  The @code{unwind-protect} construct is essential whenever you
temporarily put a data structure in an inconsistent state; it permits
you to make the data consistent again in the event of an error or
throw.  (Another more specific cleanup construct that is used only for
changes in buffer contents is the atomic change group; @ref{Atomic
Changes}.)

@defspec unwind-protect body-form cleanup-forms@dots{}
@cindex cleanup forms
@cindex protected forms
@cindex error cleanup
@cindex unwinding
@code{unwind-protect} executes @var{body-form} with a guarantee that
the @var{cleanup-forms} will be evaluated if control leaves
@var{body-form}, no matter how that happens.  @var{body-form} may
complete normally, or execute a @code{throw} out of the
@code{unwind-protect}, or cause an error; in all cases, the
@var{cleanup-forms} will be evaluated.

If @var{body-form} finishes normally, @code{unwind-protect} returns the
value of @var{body-form}, after it evaluates the @var{cleanup-forms}.
If @var{body-form} does not finish, @code{unwind-protect} does not
return any value in the normal sense.

Only @var{body-form} is protected by the @code{unwind-protect}.  If any
of the @var{cleanup-forms} themselves exits nonlocally (via a
@code{throw} or an error), @code{unwind-protect} is @emph{not}
guaranteed to evaluate the rest of them.  If the failure of one of the
@var{cleanup-forms} has the potential to cause trouble, then protect
it with another @code{unwind-protect} around that form.

The number of currently active @code{unwind-protect} forms counts,
together with the number of local variable bindings, against the limit
@code{max-specpdl-size} (@pxref{Definition of max-specpdl-size,, Local
Variables}).
@end defspec

  For example, here we make an invisible buffer for temporary use, and
make sure to kill it before finishing:

@example
@group
(let ((buffer (get-buffer-create " *temp*")))
  (with-current-buffer buffer
    (unwind-protect
        @var{body-form}
      (kill-buffer buffer))))
@end group
@end example

@noindent
You might think that we could just as well write @code{(kill-buffer
(current-buffer))} and dispense with the variable @code{buffer}.
However, the way shown above is safer, if @var{body-form} happens to
get an error after switching to a different buffer!  (Alternatively,
you could write a @code{save-current-buffer} around @var{body-form},
to ensure that the temporary buffer becomes current again in time to
kill it.)

  Emacs includes a standard macro called @code{with-temp-buffer} which
expands into more or less the code shown above (@pxref{Definition of
with-temp-buffer,, Current Buffer}).  Several of the macros defined in
this manual use @code{unwind-protect} in this way.

@findex ftp-login
  Here is an actual example derived from an FTP package.  It creates a
process (@pxref{Processes}) to try to establish a connection to a remote
machine.  As the function @code{ftp-login} is highly susceptible to
numerous problems that the writer of the function cannot anticipate, it
is protected with a form that guarantees deletion of the process in the
event of failure.  Otherwise, Emacs might fill up with useless
subprocesses.

@example
@group
(let ((win nil))
  (unwind-protect
      (progn
        (setq process (ftp-setup-buffer host file))
        (if (setq win (ftp-login process host user password))
            (message "Logged in")
          (error "Ftp login failed")))
    (or win (and process (delete-process process)))))
@end group
@end example

  This example has a small bug: if the user types @kbd{C-g} to
quit, and the quit happens immediately after the function
@code{ftp-setup-buffer} returns but before the variable @code{process} is
set, the process will not be killed.  There is no easy way to fix this bug,
but at least it is very unlikely.
