@c -*- mode: texinfo; coding: utf-8 -*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-2019 Free Software Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Positions
@chapter Позиции
@cindex position (in buffer)
@cindex buffer position

  @dfn{Позиция} - индекс символа в тексте буфера.  Точнее, позиция
определяет место между двумя символами (или перед первым символом, или после
последнего символа), поэтому можно говорить о символе до или после данной
позиции.  Однако часто говорится о символе ``в'' позиции, имея в виду символ
после этой позиции.

  Позиции обычно представлены как целые числа, начинающиеся с 1, но также
могут быть представлены как @dfn{маркеры} --- специальные объекты, которые
автоматически перемещаются при вставке или удалении текста, поэтому они
остаются с окружающими символами.  Функции, которые ожидают, что аргумент
будет позицией (целым числом), но принимают маркер в качестве замены, обычно
игнорируют, в какой буфер указывает маркер; они преобразуют маркер в целое
число и используют это целое число, как если передано целое число в качестве
аргумента, даже если маркер указывает на неправильный буфер.  Маркер,
который никуда не указывает, не может быть преобразован в целое число;
использование его вместо целого числа вызывает ошибку.  @xref{Markers}.

  Смотреть также функцию поля (@pxref{Fields}), которая предоставляет
функции, которые используются многими командами перемещения курсора.

@menu
* Point::         Особое место, где происходит редактирование.
* Motion::        Точка изменения.
* Excursions::    Временные передвижения и изменения буфера.
* Narrowing::     Ограничение редактирования частью буфера.
@end menu

@node Point
@section Точка
@cindex point

  @dfn{Точка} - это специальная позиция в буфере, используемая многими
командами редактирования, включая самовставляющиеся печатные символы и
функции вставки текста.  Другие команды перемещают точку по тексту, чтобы
разрешить редактирование и вставку в разных местах.

  Как и другие позиции, точка обозначает место между двумя символами (или
перед первым символом, или после последнего символа), а не между конкретным
символом.  Обычно терминалы отображают курсор над символом, который следует
сразу за точкой; точка фактически стоит перед символом, на котором находится
курсор.

@cindex point with narrowing
  Значение точки - это число не меньше 1 и не больше, чем размер буфера
плюс 1.  Если действует сужение (@pxref{Narrowing}), то точка ограничивается
доступной частью буфера (возможно, находится на одном его конце).

  Каждый буфер имеет собственное значение точки, которое не зависит от
значения точки в других буферах.  Каждое окно также имеет значение точки,
которое не зависит от значения точки в других окнах того же буфера.  Вот
почему точка может иметь разные значения в разных окнах, отображающих один
и тот же буфер.  Когда буфер появляется только в одном окне, точка буфера и
точка окна обычно имеют одно и то же значение, поэтому различие редко бывает
важным.  @xref{Window Point}, подробнее.

@defun point
@cindex current buffer position
Функция возвращает значение точки в текущем буфере в виде целого числа.

@need 700
@example
@group
(point)
     @result{} 175
@end group
@end example
@end defun

@defun point-min
Функция возвращает минимально доступное значение точки в текущем буфере.
Обычно это 1, но если действует сужение, это позиция начала области, до
которой проведено сужение (@xref{Narrowing}).
@end defun

@defun point-max
Функция возвращает максимально доступное значение точки в текущем буфере.
Это @code{(1+ (buffer-size))}, если не действует сужение; в этом случае это
позиция конца области, до которой проведено сужение.  (@xref{Narrowing}.)
@end defun

@defun buffer-end flag
Функция возвращает @code{(point-max)}, если @var{flag} больше 0, и
@code{(point-min)} в противном случае.  Аргумент @var{flag} должен быть
числом.
@end defun

@defun buffer-size &optional buffer
Функция возвращает общее количество символов в текущем буфере.  В отсутствие
сужения (@pxref{Narrowing}) @code{point-max} возвращает значение на единицу
больше этого.

Если указан буфер @var{buffer}, то значение будет размером @var{buffer}.

@example
@group
(buffer-size)
     @result{} 35
@end group
@group
(point-max)
     @result{} 36
@end group
@end example
@end defun

@node Motion
@section Перемещение
@cindex motion by chars, words, lines, lists

  Функции перемещения изменяют значение точки относительно текущего значения
точки, относительно начала или конца буфера или относительно краев
выбранного окна.  @xref{Point}.

@menu
* Character Motion::       Перемещение по символам.
* Word Motion::            Перемещение по словам.
* Buffer End Motion::      Переход к началу или концу буфера.
* Text Lines::             Перемещение по строкам текста.
* Screen Lines::           Перемещение по линиям, как показано.
* List Motion::            Перемещение по спискам парсинга.
* Skipping Characters::    Пропуск символов, определенного набора.
@end menu

@node Character Motion
@subsection Движение по Символам

  Эти функции перемещают точку в зависимости от количества символов.
@code{goto-char} - фундаментальный примитив; другие функции используют это.

@deffn Command goto-char position
Функция устанавливает точку в текущем буфере на значение @var{position}.
@c Это поведение документировалось до тех пор, пока 2013/08.
@ignore
Если @var{position} меньше 1, перемещается точка в начало буфера.  Если
 @var{position} больше длины буфера, точка перемещается в конец.
@end ignore

Если действует сужение, @var{position} по-прежнему считается с начала
буфера, но точка не может выходить за пределы доступной части.  Если
@var{position} выходит за пределы допустимого диапазона, @code{goto-char}
перемещает точку в начало или конец доступной части.

Когда функция вызывается в интерактивном режиме, @var{position} является
аргументом числового префикса, если он указан; в противном случае он
читается из минибуфера.

@code{goto-char} returns @var{position}.
@end deffn

@deffn Command forward-char &optional count
@c @kindex beginning-of-buffer
@c @kindex end-of-buffer
Функция перемещает точечные символы @var{count} вперед, к концу буфера (или
назад, к началу буфера, если @var{count} отрицательное значение).  Если
@var{count} - @code{nil}, значение по умолчанию - 1.

Если проводится попытка переместиться за начало или конец буфера (или за
пределы доступной части, когда действует сужение), сигнализируется об ошибке
с помощью символа ошибки @code{beginning-of-buffer} или
@code{end-of-buffer}.

В интерактивном вызове @var{count} - это числовой префиксный аргумент.
@end deffn

@deffn Command backward-char &optional count
Это похоже на @code{forward-char}, за исключением того, что движение в
противоположном направлении.
@end deffn

@node Word Motion
@subsection Движение по Словам

  Функции синтаксического анализа слов, описанные ниже, используют таблицу
синтаксиса и @code{char-script-table}, чтобы решить, является ли данный
символ частью слова.  @xref{Syntax Tables},  и смотреть
@ref{Character Properties}.

@deffn Command forward-word &optional count
Функция перемещает точку вперед по словам @var{count} (или назад, если
@var{count} отрицательное значение).  Если @var{count} опущен или
@code{nil}, по умолчанию используется 1.  В интерактивном вызове @var{count}
задается аргументом числового префикса.

``Перемещение через одно слово'' означает движение до тех пор, пока точка не
пересечет символ, составляющий слово, что указывает на начало слова, а затем
продолжить движение, пока слово не закончится.  По умолчанию символы,
которые начинают и заканчивают слова, известные как @dfn{границы слова},
определяются таблицей синтаксиса текущего буфера
(@pxref{Syntax Class Table}), но режимы могут переопределить это, установив
подходящий @code{find-word-boundary-function-table}, как описано ниже.
Символы, принадлежащие разным скриптам (как определено
@code{char-script-table}), также определяют границу слова
(@pxref{Character Properties}).  В любом случае эта функция не может
перемещать точку за границу доступной части буфера или за границу поля
(@pxref{Fields}).  Самый распространенный случай границы поля - это конец
подсказки в минибуфере.

Если возможно переместить на @var{count} слов без преждевременного останова
границей буфера или границей поля, значение будет @code{t}.  В противном
случае возвращаемое значение - @code{nil}, и точка останавливается на
границе буфера или границе поля.

Если @code{inhibit-field-text-motion} равен non-@code{nil}, эта функция
игнорирует границы поля.

@end deffn

@deffn Command backward-word &optional count
Функция аналогична @code{forward-word}, за исключением того, что
перемещает назад, пока не встретит начало слова, а не вперед.
@end deffn

@defopt words-include-escapes
@c Emacs 19 feature
Переменная влияет на поведение @code{forward-word} и @code{backward-word} и
всего, что их использует.  Если non-@code{nil}, то символы в классах
синтаксиса escape и символьных кавычек считаются частью слов.  В противном
случае они этого не делают.
@end defopt

@defvar inhibit-field-text-motion
Если переменная установлена в неnon-@code{nil}, некоторые функции движения, включая @code{forward-word}, @code{forward-sentence} и @code{forward-paragraph}, игнорируют границы поля.
@end defvar

@defvar find-word-boundary-function-table
Переменная влияет на поведение @code{forward-word} и @code{backward-word} и
всего, что их использует.  Её значение представляет собой символьную таблицу
(@pxref{Char-Tables}) функций для поиска границ слова.  Если у символа есть
запись не-@code{nil} в этой таблице, то, когда слово начинается или
заканчивается этим символом, будет вызываться соответствующая функция с
двумя аргументами: @var{pos} и @var{limit}.  Функция должна возвращать
позицию другой границы слова.  В частности, если @var{pos} меньше
@var{limit}, то @var{pos} находится в начале слова, и функция должна
возвращать позицию после последнего символа слова; в противном случае
@var{pos} стоит на последнем символе слова, и функция должна возвращать
позицию первого символа этого слова.
@end defvar

@defun forward-word-strictly &optional count
Функция похожа на @code{forward-word}, но на нее не влияет
@code{find-word-boundary-function-table}.  Программы Lisp, которые не должны
изменять поведение при изменении движения слова режимами, которые
устанавливают эту таблицу, например @code{subword-mode}, должны использовать
эту функцию вместо @code{forward-word}.
@end defun

@defun backward-word-strictly &optional count
Функция похожа на @code{backward-word}, но на нее не влияет
@code{find-word-boundary-function-table}.  Как и в случае с
@code{forward-word-strictly}, использовать эту функцию вместо
@code{backward-word}, когда перемещение по словам должно учитывать только
таблицы синтаксиса.
@end defun

@node Buffer End Motion
@subsection Движение к Концу Буфера
@cindex move to beginning or end of buffer

  Чтобы переместить точку в начало буфера, пишется:

@example
@group
(goto-char (point-min))
@end group
@end example

@noindent
Аналогичным образом, чтобы перейти к концу буфера, использовать:

@example
@group
(goto-char (point-max))
@end group
@end example

  Вот две команды, которые пользователи используют для этого.  Они
задокументированы здесь, чтобы предупредить не использовать их в программах
на Lisp, потому что они устанавливают метку и отображают сообщения в
эхо-области.

@deffn Command beginning-of-buffer &optional n
Функция перемещает точку в начало буфера (или границы доступной части, когда
действует сужение), устанавливая метку в предыдущую позицию (за исключением
режима Transient Mark, если метка уже активна, не установится отметка.)

Если @var{n} равен не-@code{nil}, то точка @var{n} ставится на десятые доли
пути от начала доступной части буфера.  В интерактивном вызове @var{n}
является аргументом числового префикса, если указан; в противном случае для
@var{n} по умолчанию используется @code{nil}.

@strong{Предупреждение:} Не использовать эту функцию в программах Lisp!
@end deffn

@deffn Command end-of-buffer &optional n
Функция перемещает точку в конец буфера (или границы доступной части, когда
действует сужение), устанавливая метку в предыдущую позицию (за исключением
режима временной метки, когда метка уже активна).  Если @var{n} равен
не-@code{nil}, то точка @var{n} ставится на десятые доли пути от конца
доступной части буфера.

В интерактивном вызове @var{n} - это числовой префиксный аргумент, если он
указан; в противном случае для @var{n} по умолчанию используется @code{nil}.

@strong{Предупреждение:} Не использовать эту функцию в программах Lisp!
@end deffn

@node Text Lines
@subsection Движение по Текстовым Строкам
@cindex lines

  Текстовые строки - это части буфера, разделенные символами новой строки,
которые рассматриваются как часть предыдущей строки.  Первая текстовая
строка начинается в начале буфера, а последняя текстовая строка
заканчивается в конце буфера, независимо от того, является ли последний
символ новой строкой.  Разделение буфера на текстовые строки не зависит от
ширины окна, продолжения строки при отображении или от того, как
отображаются табуляция и управляющие символы.

@deffn Command beginning-of-line &optional count
Функция перемещает точку в начало текущей строки.  С аргументом @var{count},
а не @code{nil} или 1, перемещает вперед на @var{count}@minus{}1 строк, а
затем в начало строки.

Функция не перемещает точку через границу поля (@pxref{Fields}), если это не
переместит ее на другую строку; следовательно, если @var{count} равно
@code{nil} или 1 и точка начинается на границе поля, точка не перемещается.
Чтобы игнорировать границы поля, либо привязывается
@code{inhibit-field-text-motion} к @code{t}, либо используется вместо этого
функция @code{forward-line}.  Например, @code{(forward-line 0)} делает то же
самое, что и @code{(beginning-of-line)}, за исключением того, что
игнорирует границы полей.

Если функция достигает конца буфера (или доступной части, если действует
сужение), позиционирует точку там.  Об ошибках не сообщается.
@end deffn

@defun line-beginning-position &optional count
Вернуть позицию, в которую переместится
@code{(beginning-of-line @var{count})}.
@end defun

@deffn Command end-of-line &optional count
Функция перемещает точку в конец текущей строки.  С аргументом @var{count},
а не @code{nil} или 1, перемещает вперед на @var{count}@minus{}1 строк, а
затем до конца строки.

Функция не перемещает точку через границу поля (@pxref{Fields}), если это
не переместит ее на другую строку; следовательно, если @var{count}
установить в @code{nil} или 1 и точка начинается на границе поля, точка не
перемещается.  Чтобы игнорировать границы поля, привязывается
@code{inhibit-field-text-motion} к @code{t}.

Если функция достигает конца буфера (или доступной части, если действует
сужение), позиционируется точка там.  Об ошибках не сообщается.
@end deffn

@defun line-end-position &optional count
Вернуть позицию, в которую переместится @code{(end-of-line @var{count})}.
@end defun

@deffn Command forward-line &optional count
@cindex beginning of line
Функция перемещает точку вперед на @var{count} строк, в начало следующей за
ними строки.  Если @var{count} отрицательно, перемещается точка на
@minus{}@var{count} назад, в начало предыдущей строки.  Если @var{count}
равно нулю, перемещается точка в начало текущей строки.  Если @var{count}
равно @code{nil}, это означает 1.

Если @code{forward-line} встречает начало или конец буфера (или доступной
части) до того, как обнаруживает такое количество строк, устанавливается там
точка.  Об ошибках не сообщается.

@code{forward-line} возвращает разницу между @var{count} и количеством
фактически перемещенных строк.  Если попытаться переместиться на пять строк
вниз от начала буфера, который имеет только три строки, точка остановится в
конце последней строки, и значение будет равно 2.  В качестве явного
исключения, если последняя доступная строка не-пуста, но не имеет новой
строки (например, если буфер заканчивается без новой строки), функция
устанавливает точку в конец этой строки, а значение, возвращаемое функцией,
считает эту строку одной успешно перемещенной.

В интерактивном вызове @var{count} - это числовой префиксный аргумент.
@end deffn

@defun count-lines start end
@cindex lines in region
@anchor{Definition of count-lines}
Функция возвращает количество строк между позициями @var{start} и @var{end}
в текущем буфере.  Если @var{start} и @var{end} равны, возвращается 0.  В
противном случае возвращается не менее 1, даже если @var{start} и @var{end}
находятся на одной и той же строке.  Это связано с тем, что текст между
ними, рассматриваемый изолированно, должен содержать хотя бы одну строку,
если есть.
@end defun

@deffn Command count-words start end
@cindex words in region
Функция возвращает количество слов между позициями @var{start} и @var{end}
в текущем буфере.

Эту функцию также можно вызывать в интерактивном режиме.  В этом случае
печатается сообщение с указанием количества строк, слов и символов в буфере
или в регионе, если регион активен.
@end deffn

@defun line-number-at-pos &optional pos absolute
@cindex line number
Функция возвращает номер строки в текущем буфере, соответствующий позиции в
буфере @var{pos}.  Если @var{pos} установленно в @code{nil} или опущено,
используется текущая позиция буфера.  Если @var{absolute} - @code{nil}, по
умолчанию подсчет начинается с @code{(point-min)}, поэтому значение
относится к содержимому доступной части (потенциально суженного) буфера.
Если @var{absolute} установленно в не-@code{nil}, игнорируется любое сужение
и возвращайте абсолютный номер строки.
@end defun

@ignore
@c ================
Команды @code{previous-line} и @code{next-line} - это функции, которые не
следует использовать в программах.  Предназначаются для пользователей и
упомянуты здесь только для полноты картины.

@deffn Command previous-line count
@cindex goal column
Функция перемещает точку вверх по строкам @var{count} (вниз, если
@var{count} отрицательное значение).  При перемещении пытается сохраниться
точка в @dfn{goal column} (обычно в том же столбце, что и в начале
перемещения).

Если в целевой строке нет символа точно под текущим столбцом, точка
помещается после символа в той строке, которая охватывает этот столбец или
в конце строки, если она недостаточно длинна.

Если происходит попытка выйти за пределы верхней или нижней границы буфера
(или суженной области), то точка помещается в столбец цели в верхней или
нижней строке.  Об ошибках не сообщается.

В интерактивном вызове @var{count} будет аргументом числового префикса.

Команду @code{set-goal-column} можно использовать для создания столбца
полупостоянной цели, к которому эта команда всегда перемещается.  Тогда не
пытается двигаться по вертикали.

Если думать об использовании этого в программе Lisp, рассмотреть возможность
использования вместо этого @code{forward-line} с отрицательным аргументом. 
Обычно проще в использовании и надежнее (нет зависимости от столбца целей и
так далее).
@end deffn

@deffn Command next-line count
Функция перемещает точку вниз на @var{count} строк (вверх, если @var{count}
отрицательное значение).  При перемещении пытается сохранить точку в столбце
цели (обычно в том же столбце, что и в начале движения).

Если в целевой строке нет символа точно под текущим столбцом, точка
помещается после символа в той строке, которая охватывает этот столбец, или
в конце строки, если она недостаточно длинна.

Если проводится попытка выйти за пределы верхней или нижней границы буфера
(или обрезанной области), то точка помещается в столбец цели в верхней или
нижней строке.  Об ошибках не сообщается.

В случае, когда @var{count} равен 1, а точка находится на последней строке
буфера (или обрезанной области), новая пустая строка вставляется в конец
буфера (или обрезанной области) и точка перемещается туда.

В интерактивном вызове @var{count} будет аргументом числового префикса.

Команду @code{set-goal-column} можно использовать для создания столбца
полупостоянной цели, к которому эта команда всегда перемещается.  Тогда не
проводится попытка двигаться по вертикали.

Если предполагается использование этого в программе Lisp, как кандидат
использовать вместо этого @code{forward-line}.  Обычно это проще в
 использовании и надежнее (нет зависимости от столбца целей и так далее).
@end deffn

@c ================
@end ignore

  Также смотреть функции @code{bolp} и @code{eolp} в @ref{Near Point}.  Эти
функции не перемещают точку, а проверяют, находится ли она уже в начале или
в конце строки.

@node Screen Lines
@subsection Движение по Строкам Экрана
@cindex screen lines, moving by

  Строчные функции в предыдущем разделе подсчитывают текстовые строки,
разделенные только символами новой строки.  Напротив, эти функции
подсчитывают строки экрана, которые определяются способом отображения текста
на экране.  Текстовая строка - это одна экранная строка, если она достаточно
короткая, чтобы соответствовать ширине выбранного окна, но в противном
случае она может занимать несколько экранных строк.

  В некоторых случаях текстовые строки обрезаются на экране, а не
продолжаются на дополнительных строках экрана.  В этих случаях
@code{vertical-motion} перемещает точку так же, как @code{forward-line}.
@xref{Truncation}.

  Поскольку ширина данной строки зависит от флагов, которые управляют
появлением определенных символов, @code{vertical-motion} ведет себя
по-разному для данного фрагмента текста, в зависимости от буфера, в котором
находится, и даже от выбранного окна (поскольку ширина флаг усечения, и
таблица отображения может отличаться в зависимости от окна).
@xref{Usual Display}.

  Эти функции сканируют текст, чтобы определить, где разрываются строки
экрана, и, таким образом, занимают время, пропорциональное сканированному
расстоянию.
@ignore
Если собираться интенсивно их использовать, Emacs предоставляет кеши,
 которые могут улучшить производительность вашего кода.
  @xref{Truncation, cache-long-scans}.
@end ignore

@defun vertical-motion count &optional window cur-col
Функция перемещает точку в начало строки экрана на @var{count} вниз от
строки экрана, содержащей точку.  Если @var{count} отрицательно, вместо
этого перемещается вверх.

Аргумент @var{count} может быть cons-ячейкой
@code{(@var{cols} . @var{lines})} вместо целого числа.  Затем функция
перемещается на @var{lines} экранных строк и помещает точку в @var{cols}
столбец от визуального начала этой экранной строки.  Обратить внимание,
что @var{cols} отсчитываются от начала @emph{визуальной} строки ; если окно
прокручивается по горизонтали (@pxref{Horizontal Scrolling}), столбец, на
котором будет заканчиваться точка, будет добавлен к количеству столбцов, по
которым прокручивается текст.

Возвращаемое значение - это количество строк экрана, на которое была
перемещена точка.  Значение может быть меньше по абсолютной величины, чем
@var{count}, если было достигнуто начало или конец буфера.

Окно @var{window} используется для получения таких параметров, как ширина,
горизонтальная прокрутка и таблица отображения.  Но @code{vertical-motion}
всегда работает с текущим буфером, даже если @var{window} в настоящее время
отображает какой-то другой буфер.

Необязательный аргумент @var{cur-col} указывает текущий столбец при вызове
функции.  Координата точки по горизонтали относительно окна, измеряемая в
единицах ширины шрифта лицевой стороны фрейма по умолчанию.  Это ускоряет
выполнение функции, особенно в очень длинных строках, потому что функции не
нужно возвращаться в буфер, чтобы определить текущий столбец.  Обратить
внимание, что @var{cur-col} также отсчитывается от визуального начала
строки.
@end defun

@defun count-screen-lines &optional beg end count-final-newline window
Функция возвращает количество экранных строк в тексте от @var{beg} до
@var{end}.  Количество строк экрана может отличаться от количества
фактических строк из-за продолжения строки, таблицы отображения и так далее.
Если @var{beg} и @var{end} являются @code{nil} или опущены, они по умолчанию
соответствуют началу и концу доступной части буфера.

Если область заканчивается новой строкой, она игнорируется, если только
необязательный третий аргумент @var{count-final-newline} не равен
не-@code{nil}.

Необязательный четвертый аргумент @var{window} указывает окно для получения
таких параметров, как ширина, горизонтальная прокрутка и так далее.  По
умолчанию используются параметры выбранного окна.

Подобно @code{vertical-motion}, @code{count-screen-lines} всегда использует
текущий буфер, независимо от того, какой буфер отображается в @var{window}.
Это позволяет использовать @code{count-screen-lines} в любом буфере,
независимо от того, отображается он в данный момент в каком-либо окне.
@end defun

@deffn Command move-to-window-line count
Функция перемещает точку относительно текста, отображаемого в текущий момент
в выбранном окне.  Перемещает точку в начало строки экрана @var{count}
экранных строк из верхней части окна; ноль означает самую верхнюю строку.
Если @var{count} отрицательное, это указывает позицию
@w{@minus{}@var{count}} строки снизу (или последней строки буфера, если
буфер заканчивается выше указанной позиции экрана); таким образом,
@var{count} из @minus{}1 задает последнюю полностью видимую экранную строку
окна.

Если @var{count} равен @code{nil}, то точка перемещается в начало строки в
середине окна.  Если абсолютное значение @var{count} больше, чем размер
окна, то точка перемещается в то место, которое появилось бы в этой строке
экрана, если бы окно было достаточно высоким.  Это, вероятно, приведет к
прокрутке следующего повторного отображения, чтобы отобразить это место на
экране.

В интерактивном вызове @var{count} - это числовой префиксный аргумент.

Возвращаемое значение - это номер строки экрана, на которую
переместилась точка относительно верхней строки окна.
@end deffn

@vindex move-to-window-group-line-function
@defun move-to-window-group-line count
Функция похожа на @code{move-to-window-line}, за исключением того, что когда
выбранное окно является частью группы окон, (@pxref{Window Group}),
@code{move-to-window-group-line} переместится в позицию по отношению ко всей
группе, а не только к одному окну.  Это условие выполняется, когда в
локальной переменной буфера @code{move-to-window-group-line-function} задана
функция.  В этом случае @code{move-to-window-group-line} вызывает функцию с
аргументом @var{count}, а затем возвращает ее результат.
@end defun

@defun compute-motion from frompos to topos width offsets window
Функция сканирует текущий буфер, вычисляя положение экрана.  Сканирует буфер
вперед от позиции @var{from}, предполагая, что находится в экранных
координатах @var{frompos}, до позиции @var{to} или координат @var{topos}, в
зависимости от того, что наступит раньше.  Возвращается конечная позиция
буфера и экранные координаты.

Координатные аргументы @var{frompos} и @var{topos} являются cons-ячейками
вида @code{(@var{hpos} . @var{vpos})}.

Аргумент @var{width} - это количество столбцов, доступных для отображения
текста; это влияет на обработку строк продолжения.  @code{nil} означает
фактическое количество используемых текстовых столбцов в окне, что
эквивалентно значению, возвращаемому @code{(window-width window)}.

Аргумент @var{offsets} - это либо @code{nil}, либо cons-ячейка вида
@code{(@var{hscroll} . @var{tab-offset})}.  Здесь @var{hscroll} - количество
столбцов, не отображаемых на левом поле; большинство вызывающих абонентов
получают это, вызывая @code{window-hscroll}.  Между тем @var{tab-offset} -
это смещение между номерами столбцов на экране и номерами столбцов в буфере.
Это может быть ненулевое значение в строке продолжения, когда ширина
предыдущих строк экрана не кратна @code{tab-width}.  В непродолжительной
строке он всегда равен нулю.

Окно @var{window} служит только для указания, какую таблицу отображения
использовать.  @code{compute-motion} всегда работает с текущим буфером,
независимо от того, какой буфер отображается в @var{window}.

Возвращаемое значение - список из пяти элементов.:

@example
(@var{pos} @var{hpos} @var{vpos} @var{prevhpos} @var{contin})
@end example

@noindent
Здесь @var{pos} - позиция в буфере, на которой остановлено сканирование,
@var{vpos} - вертикальное положение экрана, а @var{hpos} - горизонтальное
положение экрана.

Результат @var{prevhpos} - это горизонтальная позиция на один символ назад
от @var{pos}.  Результат @var{contin} - @code{t}, если последняя строка была
продолжена после (или внутри) предыдущего символа.

Например, чтобы найти положение в буфере столбца @var{col} строки экрана
@var{line} определенного окна, передатm положение начала отображения окна
как @var{from}, а координаты левого верхнего угла окна как @var{frompos}.
Передать @code{(point-max)} буфера как @var{to}, чтобы ограничить
сканирование до конца доступной части буфера, и передать @var{line} и
@var{col} как @var{topos}.  Вот функция, которая делает это:

@example
(defun coordinates-of-position (col line)
  (car (compute-motion (window-start)
                       '(0 . 0)
                       (point-max)
                       (cons col line)
                       (window-width)
                       (cons (window-hscroll) 0)
                       (selected-window))))
@end example

Когда используется @code{compute-motion} для минибуфера, потребуется
использовать @code{minibuffer-prompt-width}, чтобы получить горизонтальное
положение начала первой строки экрана.  @xref{Minibuffer Contents}.
@end defun

@node List Motion
@subsection Переход к Сбалансированным Выражениям
@cindex sexp motion
@cindex Lisp expression motion
@cindex list motion
@cindex balanced parenthesis motion

  Вот несколько функций, связанных с выражениями сбалансированных скобок
(также называемых @dfn{sexps} в связи с перемещением по ним в Emacs).
Таблица синтаксиса определяет, как эти функции интерпретируют различные
символы; смотреть @ref{Syntax Tables}.  @xref{Parsing Expressions}, для
примитивов нижнего уровня для сканирования выражений или их частей.
Команды пользовательского уровня смотреть в @ref{Parentheses,, Команды для редактирования в круглых скобках, emacs, Руководство по GNU Emacs}.

@deffn Command forward-list &optional arg
Функция перемещается вперед по сбалансированным группам скобок @var{arg}
(по умолчанию 1).  (Другие синтаксические объекты, такие как слова или
парные строковые кавычки, игнорируются.)
@end deffn

@deffn Command backward-list &optional arg
Функция перемещается назад по сбалансированным группам скобок @var{arg} (по
умолчанию 1).  (Другие синтаксические объекты, такие как слова или парные
строковые кавычки, игнорируются.)
@end deffn

@deffn Command up-list &optional arg escape-strings no-syntax-crossing
Функция перемещается вперед за пределы скобок @var{arg} (по умолчанию 1).
Отрицательный аргумент означает движение назад, но все же в менее глубокое
место.  Если @var{escape-strings} равен не-@code{nil} (так как он работает
в интерактивном режиме), также выход из включающих строк.  Если
@var{no-syntax-crossing} - это не-@code{nil} (так как это происходит в
интерактивном режиме), предпочтительнее вырваться из любой включающей строки
вместо перехода к началу списка, разбитого на несколько строк.  В случае
ошибки местоположение точки не указано.
@end deffn

@deffn Command backward-up-list &optional arg escape-strings no-syntax-crossing
Функция аналогична @code{up-list}, но с отрицательным аргументом.
@end deffn

@deffn Command down-list &optional arg
Функция перемещается вперед на уровень круглых скобок @var{arg} (по
умолчанию 1).  Отрицательный аргумент означает движение назад, но все равно
в скобках (уровни @minus{}@var{arg}).
@end deffn

@deffn Command forward-sexp &optional arg
Функция перемещается вперед по сбалансированным выражениям @var{arg} (по
умолчанию 1).  Сбалансированные выражения включают как выражения,
разделенные круглыми скобками, так и другие выражения, такие как слова и
строковые константы.  @xref{Parsing Expressions}.  Например,

@example
@group
---------- Buffer: foo ----------
(concat@point{} "foo " (car x) y z)
---------- Buffer: foo ----------
@end group

@group
(forward-sexp 3)
     @result{} nil

---------- Buffer: foo ----------
(concat "foo " (car x) y@point{} z)
---------- Buffer: foo ----------
@end group
@end example
@end deffn

@deffn Command backward-sexp &optional arg
Функция перемещается назад по сбалансированным выражениям @var{arg} (по
умолчанию 1).
@end deffn

@deffn Command beginning-of-defun &optional arg
Функция возвращается к началу @var{arg}ов функции defun.  Если @var{arg}
отрицательно, это продвигается вперед, но по-прежнему перемещается в начало
defun, а не в конец.  @var{arg} по умолчанию 1.
@end deffn

@deffn Command end-of-defun &optional arg
Функция перемещается в конец @var{arg}ов defun.  Если @var{arg}
отрицательно, это фактически перемещается назад, но все равно перемещается в
конец defun, а не в начало.  @var{arg} по умолчанию 1.
@end deffn

@defopt defun-prompt-regexp
Если не-@code{nil}, эта локальная в буфере переменная содержит регулярное
выражение, определяющее, какой текст может появляться перед открывающей
круглой скобкой, которая запускает defun.  Другими словами, defun начинается
со строки, которая начинается с совпадения с этим регулярным выражением, за
которым следует символ с синтаксисом с открытыми скобками.
@end defopt

@cindex \( in strings
@defopt open-paren-in-column-0-is-defun-start
Если значение этой переменной - не-@code{nil}, открытая скобка в столбце 0
считается началом функции defun.  Если это @code{nil}, открывающая скобка в
столбце 0 не имеет особого значения.  По умолчанию - @code{t}.  Если у
строкового литерала есть скобка в столбце 0, закрывается обратной косой
чертой, чтобы избежать ложного срабатывания.
@xref{Left Margin Paren,, Соглашение о левом поле, emacs,
Руководство по GNU Emacs}.
@end defopt

@defvar beginning-of-defun-function
Если не-@code{nil}, эта переменная содержит функцию для поиска начала
функции defun.  Функция @code{beginning-of-defun} вызывает эту функцию
вместо использования ее обычного метода, передавая ей необязательный
аргумент.  Если аргумент - не-@code{nil}, функция должна вернуться на это
количество функций, как это делает @code{beginning-of-defun}.
@end defvar

@defvar end-of-defun-function
Если не-@code{nil}, переменная содержит функцию для поиска конца defun.
Функция @code{end-of-defun} вызывает эту функцию вместо использования ее
обычного метода.
@end defvar

@node Skipping Characters
@subsection Пропуск Символов
@cindex skipping characters

  Следующие две функции перемещают точку над указанным набором символов.
Например, они часто используются для пропуска пробелов.  Для связанных
функций, смотреть @ref{Motion and Syntax}.

Эти функции преобразуют заданную строку в многобайтовую, если буфер
многобайтовый, и в однобайтный, если буфер однобайтный, как это делают
функции поиска (@pxref{Searching and Matching}).

@defun skip-chars-forward character-set &optional limit
Функция перемещает точку в текущем буфере вперед, пропуская заданный набор
символов.  Проверяет символ, следующий за точкой, затем продвигает точку,
если символ соответствует @var{character-set}.  Это продолжается до тех пор,
пока не будет найден несоответствующий символ.  Функция возвращает
количество перемещенных символов.

Аргумент @var{character-set} - это строка, как внутри @samp{[@dots{}]} 
регулярного выражения, за исключением того, что @samp{]} не завершает его,
а @samp{\} цитирует @samp{^}, @samp{-} или @samp{\}.  Таким образом,
@code{"a-zA-Z"} пропускает все буквы, останавливаясь перед первой
небуквенной буквой, а @code{"^a-zA-Z"} пропускает небуквенные символы,
останавливаясь перед первой буквой (@pxref{Regular Expressions}).  Также
можно использовать классы символов, например, @code{"[:alnum:]"}
(@pxref{Char Classes}).

Если указан @var{limit} (это должно быть число или маркер), указывает
максимальную позицию в буфере, в которую можно пропустить точку.  Точка
остановится на @var{limit} или раньше.

В следующем примере точка изначально расположена непосредственно перед
@samp{T}.  После оценки формы точка находится в конце этой строки (между
@samp{t} @samp{hat} и новой строкой).  Функция пропускает все буквы и
пробелы, но не символы новой строки.

@example
@group
---------- Buffer: foo ----------
I read "@point{}The cat in the hat
comes back" twice.
---------- Buffer: foo ----------
@end group

@group
(skip-chars-forward "a-zA-Z ")
     @result{} 18

---------- Buffer: foo ----------
I read "The cat in the hat@point{}
comes back" twice.
---------- Buffer: foo ----------
@end group
@end example
@end defun

@defun skip-chars-backward character-set &optional limit
Функция перемещает точку назад, пропуская символы, соответствующие
@var{character-set}, до @var{limit}.  Кака и @code{skip-chars-forward}, за
исключением направления движения.

Возвращаемое значение указывает пройденное расстояние.  Это целое число,
равное нулю или меньше.
@end defun

@node Excursions
@section Excursions
@cindex excursion

  Часто бывает полезно временно переместить точку в локализованной части
программы.  Это называется @dfn{excursion} и делается с помощью специальной
формы @code{save-excursion}.  Конструкция запоминает исходный идентификатор
текущего буфера и его значение point и восстанавливает их после завершения
экскурсии.  Это стандартный способ перемещения точки в одной части программы
и избегания воздействия на остальную часть программы, что тысячи раз
используется в исходных текстах Lisp Emacs.

  Если требуется только сохранить и восстановить идентичность текущего
буфера, использовать @code{save-current-buffer} или
@code{with-current-buffer} вместо (@pxref{Current Buffer}).  Если нужно
сохранить или восстановить конфигурации окна, смотреть формы, описанные в
@ref{Window Configurations} и в @ref{Frame Configurations}.
@c набор фреймов?

@defspec save-excursion body@dots{}
@cindex point excursion
Специальная форма сохраняет идентификатор текущего буфера и значение точки в
нем, вычисляет @var{body} и, наконец, восстанавливает буфер и его
сохраненное значение точки.  Оба сохраненных значения восстанавливаются даже
в случае аварийного выхода через @code{throw} или ошибку
(@pxref{Nonlocal Exits}).

Значение, возвращаемое @code{save-excursion}, является результатом последней
формы в @var{body} или @code{nil}, если не было задано никаких форм тела.
@end defspec

  Поскольку @code{save-excursion} сохраняет точку только для буфера, который
был текущим в начале экскурсии, любые изменения, внесенные в точку в других
буферах во время экскурсии, останутся в силе и после этого.  Это часто
приводит к непредвиденным последствиям, поэтому байт-компилятор
предупреждает, если вызывается @code{set-buffer} во время экскурсии:

@example
Warning: Use ‘with-current-buffer’ rather than
         save-excursion+set-buffer
@end example

@noindent
To avoid such problems, you should call @code{save-excursion} only
after setting the desired current buffer, as in the following example:

@example
@group
(defun append-string-to-buffer (string buffer)
  "Добавить STRING в конец BUFFER."
  (with-current-buffer buffer
    (save-excursion
      (goto-char (point-max))
      (insert string))))
@end group
@end example

@cindex window excursions
  Точно так же @code{save-excursion} не восстанавливает соответствия окна и
буфера, измененные такими функциями, как @code{switch-to-buffer}.

  @strong{Предупреждение:} Обычная вставка текста рядом с сохраненным
значением точки перемещает сохраненное значение так же, как перемещает все
маркеры.  Точнее сохраненное значение - это маркер с типом вставки
@code{nil}.  @xref{Marker Insertion Types}.  Поэтому, когда сохраненное
значение точки восстанавливается, оно обычно появляется перед вставленным
текстом.

@defmac save-mark-and-excursion body@dots{}
@cindex mark excursion
@cindex point excursion
Макрос похож на @code{save-excursion}, но также сохраняет и восстанавливает
местоположение метки и @code{mark-active}.  Этот макрос делает то, что
делал @code{save-excursion} до Emacs 25.1.
@end defmac

@node Narrowing
@section Сужение
@cindex narrowing
@cindex restriction (in a buffer)
@cindex accessible portion (of a buffer)

  @dfn{Сужение} означает ограничение текста, адресуемого командами
редактирования Emacs, ограниченным диапазоном символов в буфере.  Текст,
который остается адресуемым, называется @dfn{доступной частью} буфера.

  Сужение задается двумя позициями буфера, которые становятся началом и
концом доступной части.  Для большинства команд редактирования и примитивов
эти позиции заменяют значения начала и конца буфера.  Пока действует
сужение, текст за пределами доступной части не отображается, и точка не
может перемещаться за пределы доступной части.  Обратить внимание, что
сужение не меняет фактических позиций буфера (@pxref{Point}); только
определяется, какие позиции считаются доступной частью буфера.  Большинство
функций отказываются работать с текстом, находящимся за пределами доступной
части.

  На команды для сохранения буферов сужение не влияет; сохраняют весь буфер
независимо от сужения.

  Если требуется отобразить в одном буфере несколько очень разных типов
текста, рассмотреть возможность использования альтернативного средства,
описанного в @ref{Swapping Text}.

@deffn Command narrow-to-region start end
Функция устанавливает доступную часть текущего буфера, чтобы она начиналась
с @var{start} и заканчивалась @var{end}.  Оба аргумента должны быть
позициями символов.

При интерактивном вызове @var{start} and @var{end} устанавливаются на
границы текущего региона (точка и метка, начиная с наименьшей).
@end deffn

@deffn Command narrow-to-page &optional move-count
Функция устанавливает доступную часть текущего буфера, чтобы включить только
текущую страницу.  Необязательный первый аргумент @var{move-count}
не-@code{nil} означает перемещение вперед или назад на страницу
@var{move-count}, а затем сужение до одной страницы.  Переменная
@code{page-delimiter} указывает, где страницы начинаются и где заканчиваются
(@pxref{Standard Regexps}).

В интерактивном вызове @var{move-count} присваивается аргумент числового
префикса.
@end deffn

@deffn Command widen
@cindex widening
Функция отменяет любое сужение текущего буфера, так что доступно все
содержимое.  Называется @dfn{расширение}.  Это эквивалентно следующему
выражению:

@example
(narrow-to-region 1 (1+ (buffer-size)))
@end example
@end deffn

@defun buffer-narrowed-p
Функция возвращает не-@code{nil}, если буфер сужен, и @code{nil} в противном
случае.
@end defun

@defspec save-restriction body@dots{}
Специальная форма сохраняет текущие границы доступной части, оценивает формы
@var{body} и, наконец, восстанавливает сохраненные границы, таким образом
восстанавливая то же состояние сужения (или его отсутствия), которое ранее
действовало.  Состояние сужения восстанавливается даже в случае аварийного
выхода через @code{throw} или ошибку (@pxref{Nonlocal Exits}).
Следовательно, эта конструкция - чистый способ временно сузить буфер.

Значение, возвращаемое @code{save-restriction}, - это значение, возвращаемое
последней формой в @var{body} или @code{nil}, если не было задано никаких
форм тела.

@c Многословный, чтобы избежать переполнения hbox.  --rjc 16mar92
@strong{Осторожно:} при использовании конструкции @code{save-restriction}
легко ошибиться.  Прочесть полное описание здесь, прежде чем попробовать.

Если @var{body} изменяет текущий буфер, @code{save-restriction} по-прежнему
восстанавливает ограничения исходного буфера (буфера, ограничения которого
сохранены), но не восстанавливает идентичность текущего буфера.

@code{save-restriction} @emph{не} делает точку восстановления ; использовать
для этого @code{save-excursion}.  Если использовать оба
@code{save-restriction} и @code{save-excursion} вместе,
@code{save-excursion} должно быть первым (снаружи).  В противном случае
будет восстановлено старое значение точки с сохранением временного сужения.
Если бы старое значение точки выходило за пределы временного сужения, это
не могло бы точно восстановить его.

Вот простой пример правильного использования @code{save-restriction}:

@example
@group
---------- Buffer: foo ----------
This is the contents of foo
This is the contents of foo
This is the contents of foo@point{}
---------- Buffer: foo ----------
@end group

@group
(save-excursion
  (save-restriction
    (goto-char 1)
    (forward-line 2)
    (narrow-to-region 1 (point))
    (goto-char (point-min))
    (replace-string "foo" "bar")))

---------- Buffer: foo ----------
This is the contents of bar
This is the contents of bar
This is the contents of foo@point{}
---------- Buffer: foo ----------
@end group
@end example
@end defspec
