@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2019 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Buffers
@chapter Буферы
@cindex buffer

  @dfn{Буфер} - объект Lisp, содержащий текст для редактирования.  Буферы
используются для хранения содержимого посещаемых файлов; также могут быть
буферы, которые не обращаются к файлам.  Хотя одновременно может
существовать несколько буферов, только один буфер обозначается как
@dfn{текущий буфер} в любой момент.  Большинство команд редактирования
воздействуют на содержимое текущего буфера.  Каждый буфер, включая текущий
буфер, может отображаться или не отображаться в любых окнах.

@menu
* Buffer Basics::       Что такое буфер?
* Current Buffer::      Назначение буфера текущим, чтобы примитивы имели
                           доступ к его содержимому.
* Buffer Names::        Доступ и изменение имен буферов.
* Buffer File Name::    Имя файла буфера указывает, какой файл посещается.
* Buffer Modification:: Буфер - @dfn{модифицированный}, если его нужно
                           сохранить.
* Modification Time::   Определение того, был ли изменен посещенный файл
                           за спиной Emacs.
* Read Only Buffers::   Изменение текста в буфере только для чтения
                           запрещено.
* Buffer List::         Как посмотреть все существующие буферы.
* Creating Buffers::    Функции, создающие буферы.
* Killing Buffers::     Буферы существуют до тех пор, пока явно не убиты.
* Indirect Buffers::    Косвенный буфер разделяет текст с другим буфером.
* Swapping Text::       Обмен текста между двумя буферами.
* Buffer Gap::          Разрыв в буфере.
@end menu

@node Buffer Basics
@section Буфер Основы

@ifnottex
  @dfn{Буфер} - объект Lisp, содержащий текст для редактирования.  Буферы
используются для хранения содержимого посещаемых файлов; также могут быть
буферы, которые не обращаются к файлам.  Хотя обычно существует несколько
буферов, только один буфер обозначается как @dfn{текущий буфер} в любое
время.  Большинство команд редактирования воздействуют на содержимое
текущего буфера.  Каждый буфер, включая текущий буфер, может отображаться
или не отображаться в любых окнах.
@end ifnottex

  Буферы при редактировании Emacs - это объекты, которые имеют разные имена
и содержат текст, который можно редактировать.  Для программ Lisp буферы
представляют собой особый тип данных.  Можно думать о содержимом буфера как
о строке, которую можно расширить; вставки и удаления могут происходить в
любой части буфера.  @xref{Text}.

  Объект-буфер Lisp содержит большое количество информации.  Часть этой
информации напрямую доступна программисту через переменные, в то время как
другая информация доступна только через специальные функции.  Например, имя
посещенного файла доступно напрямую через переменную, а значение точки
доступно только через примитивную функцию.

  Информация о конкретном буфере, доступная напрямую, хранится в привязках
переменных @dfn{локального буфера}, которые представляют собой значения
переменных, действующие только в определенном буфере.  Эта функция позволяет
каждому буферу переопределять значения определенных переменных.  Таким
образом, большинство основных режимов переопределяют такие переменные, как
@code{fill-column} или @code{comment-column}.  Дополнительные сведения о
локальных переменных буфера и связанных с ними функциях, смотреть
@ref{Buffer-Local Variables}.

  Для функций и переменных, связанных с посещением файлов в буферах,
смотреть @ref{Visiting Files} и @ref{Saving Buffers}.  Для функций и
переменных, связанных с отображением буферов в окнах, смотреть
@ref{Buffers and Windows}.

@defun bufferp object
Функция возвращает @code{t}, если @var{object} - буфер, и @code{nil} в
противном случае.
@end defun

@node Current Buffer
@section The Текущий Буфер
@cindex selecting a buffer
@cindex changing to another buffer
@cindex current buffer

  В общем, в сеансе Emacs есть много буферов. В любой момент один из них
обозначается как @dfn{текущий буфер} - буфер, в котором происходит большая
часть редактирования.  Большинство примитивов для проверки или изменения
текста неявно работают с текущим буфером (@pxref{Text}).

  Обычно буфер, отображаемый в выбранном окне, является текущим буфером, но
это не всегда так: программа Lisp может временно назначить любой буфер
текущим, чтобы работать с его содержимым, не изменяя то, что отображается на
экране.  Самая основная функция для обозначения текущего буфера -
@code{set-buffer}.

@defun current-buffer
Эта функция возвращает текущий буфер.

@example
@group
(current-buffer)
     @result{} #<buffer buffers.texi>
@end group
@end example
@end defun

@defun set-buffer buffer-or-name
Aункция делает @var{buffer-or-name} текущим буфером.  @var{buffer-or-name}
должен быть существующим буфером или именем существующего буфера.
Возвращаемое значение - текущий буфер.

Функция не отображает буфер ни в каком окне, поэтому пользователь не
обязательно может видеть буфер.  Но теперь программы на Lisp будут работать
с ним.
@end defun

  Когда команда редактирования возвращается в цикл команд редактора, Emacs
автоматически вызывает @code{set-buffer} для буфера, показанного в выбранном
окне.  Это сделано для предотвращения путаницы: это гарантирует, что буфер,
в котором находится курсор, когда Emacs читает команду, является буфером, к
которому эта команда применяет (@pxref{Command Loop}).  Таким образом, не
требуется использовать @code{set-buffer} для явного переключения на другой
буфер; для этого воспользоваться функциями, описанными в
@ref{Switching Buffers}.

  При написании функции на Lisp @emph{не} полагаются на восстановления
текущего буфера после операции командным циклом.  Команды редактирования
также могут вызываться как функции Lisp другими программами, а не только из
цикла команд; для вызывающей стороны удобно, если подпрограмма не меняет
текущий буфер (если, конечно, это не является целью подпрограммы).

  Чтобы временно работать с другим буфером, поместить @code{set-buffer} в
форму @code{save-current-buffer}.  Вот, например, упрощенная версия команды
@code{append-to-buffer}:

@example
@group
(defun append-to-buffer (buffer start end)
  "Добавьте текст региона в BUFFER."
  (interactive "BДобавить в буфер: \nr")
  (let ((oldbuf (current-buffer)))
    (save-current-buffer
      (set-buffer (get-buffer-create buffer))
      (insert-buffer-substring oldbuf start end))))
@end group
@end example

@noindent
Здесь привязывается локальная переменная для записи текущего буфера, а затем
@code{save-current-buffer} упорядочивает, чтобы сделать его снова текущим
позже.  Затем @code{set-buffer} делает указанный буфер текущим, а
@code{insert-buffer-substring} копирует строку из исходного буфера в
указанный (а теперь и текущий) буфер.

  В качестве альтернативы можно использовать макрос
@code{with-current-buffer}:

@example
@group
(defun append-to-buffer (buffer start end)
  "Добавляем текст региона в BUFFER."
  (interactive "BДобавить в буфер: \nr")
  (let ((oldbuf (current-buffer)))
    (with-current-buffer (get-buffer-create buffer)
      (insert-buffer-substring oldbuf start end))))
@end group
@end example

  В любом случае, если добавленный буфер отображается в каком-либо окне,
следующее повторное отображение покажет, как изменился его текст.  Если он
не отображается ни в одном окне, увидеть изменения сразу на экране.  Команда
заставляет буфер временно становиться текущим, но не отображает его.

  Если выполнить локальные привязки (с @code{let} или аргументами функции)
для переменной, которая также может иметь привязки к локальному буферу,
убедиться, что тот же буфер является текущим в начале и в конце области
локальной привязки.  В противном случае можно связать его в одном буфере и
отвязать в другом!

  Не полагаться на использование @code{set-buffer} для обратного изменения
текущего буфера, потому что это не сработает, если выход произойдет, когда
текущий буфер неверный.  Например, в предыдущем примере это было бы
неправильно:

@example
@group
  (let ((oldbuf (current-buffer)))
    (set-buffer (get-buffer-create buffer))
    (insert-buffer-substring oldbuf start end)
    (set-buffer oldbuf))
@end group
@end example

@noindent
Использование @code{save-current-buffer} или @code{with-current-buffer}, как
и здеся, корректно обрабатывает выход, ошибки и @code{throw}, а также
обычную оценку.

@defspec save-current-buffer body@dots{}
Специальная форма @code{save-current-buffer} сохраняет идентификатор
текущего буфера, оценивает формы @var{body} и, наконец, восстанавливает этот
буфер как текущий.  Возвращаемое значение - это значение последней формы в
теле @var{body}.  Текущий буфер восстанавливается даже при аварийном выходе
через @code{throw} или ошибку (@pxref{Nonlocal Exits}).

Если буфер, который раньше был текущим, был уничтожен к моменту выхода из
@code{save-current-buffer}, то, конечно, он не станет снова текущим.  Вместо
этого, тот буфер, который был текущим непосредственно перед выходом,
остается текущим.
@end defspec

@defmac with-current-buffer buffer-or-name body@dots{}
Макрос @code{with-current-buffer} сохраняет идентификатор текущего буфера,
делает @var{buffer-or-name} текущим, оценивает формы @var{body} и, наконец,
восстанавливает текущий буфер.  @var{buffer-or-name} должен указывать
существующий буфер или имя существующего буфера.

Возвращаемое значение - это значение последней формы в @var{body}.  Текущий
буфер восстанавливается даже в случае аварийного выхода через @code{throw}
или ошибку (@pxref{Nonlocal Exits}).
@end defmac

@defmac with-temp-buffer body@dots{}
@anchor{Definition of with-temp-buffer}
Макрос @code{with-temp-buffer} оценивает формы @var{body} с временным
буфером в качестве текущего буфера.  Cохраняет идентификатор текущего
буфера, создает временный буфер и делает его текущим, оценивает формы
@var{body} и, наконец, восстанавливает предыдущий текущий буфер, уничтожая
временный буфер.  По умолчанию информация об отмене (@pxref{Undo}) не
записывается в буфер, созданный этим макросом (но @var{body} может включить
это при необходимости).

Возвращаемое значение - это значение последней формы в @var{body}.  Можно
вернуть содержимое временного буфера, используя @code{(buffer-string)} в
качестве последней формы.

Текущий буфер восстанавливается даже в случае аварийного выхода через
@code{throw} или ошибки (@pxref{Nonlocal Exits}).

Смотреть также @code{with-temp-file} в
@ref{Definition of with-temp-file,,Writing to Files}.
@end defmac

@node Buffer Names
@section Имена Буферов
@cindex buffer names

  У каждого буфера есть уникальное имя, которое представляет собой строку.
Многие функции, работающие с буферами, принимают в качестве аргумента либо
буфер, либо имя буфера.  Любой аргумент с именем @var{buffer-or-name}
относится к этому типу, и выдается сигнал об ошибке, если он не является ни
строкой, ни буфером.  Любой аргумент с именем @var{buffer} должен быть
фактическим буферным объектом, а не именем.

@cindex hidden buffers
@cindex buffers without undo information
  Эфемерные буферы, которые обычно не интересны пользователю, имеют имена,
начинающиеся с пробела, поэтому команды @code{list-buffers} и
@code{buffer-menu} не упоминают их (но если такой буфер посещает файл, он
упоминает @strong{это}).  Имя, начинающееся с пробела, также изначально
отключает запись информации об отмене; смотреть @ref{Undo}.

@defun buffer-name &optional buffer
Функция возвращает имя @var{buffer} в виде строки.  @var{buffer} по
умолчанию использует текущий буфер.

Если @code{buffer-name} возвращает @code{nil}, это означает, что
@var{buffer} убит.  @xref{Killing Buffers}.

@example
@group
(buffer-name)
     @result{} "buffers.texi"
@end group

@group
(setq foo (get-buffer "temp"))
     @result{} #<buffer temp>
@end group
@group
(kill-buffer foo)
     @result{} nil
@end group
@group
(buffer-name foo)
     @result{} nil
@end group
@group
foo
     @result{} #<killed buffer>
@end group
@end example
@end defun

@deffn Command rename-buffer newname &optional unique
Функция переименовывает текущий буфер в @var{newname}.  Выдается сообщение
об ошибке, если @var{newname} не является строкой.

@c Emacs 19 feature
Обычно @code{rename-buffer} сигнализирует об ошибке, если @var{newname} уже
используется.  Однако, если @var{unique} равен не-@code{nil}, он изменяет
@var{newname}, чтобы получить имя, которое не используется.  В интерактивном
режиме можно сделать @var{unique} не-@code{nil} с числовым префиксом
аргумента.  (Так реализована команда @code{rename-uniquely}.)

Эта функция возвращает имя, фактически присвоенное буферу.
@end deffn

@defun get-buffer buffer-or-name
Функция возвращает буфер, указанный в @var{buffer-or-name}.  Если
@var{buffer-or-name} является строкой и буфера с таким именем не существует,
используется значение @code{nil}.  Если @var{buffer-or-name} является
буфером, он возвращается как заданный; это не очень полезно, поэтому
аргументом обычно является имя.  Например:

@example
@group
(setq b (get-buffer "lewis"))
     @result{} #<buffer lewis>
@end group
@group
(get-buffer b)
     @result{} #<buffer lewis>
@end group
@group
(get-buffer "Frazzle-nots")
     @result{} nil
@end group
@end example

Смотреть также функцию @code{get-buffer-create} в @ref{Creating Buffers}.
@end defun

@c Emacs 19 feature
@defun generate-new-buffer-name starting-name &optional ignore
Функция возвращает имя, которое будет уникальным для нового буфера, но не
создает буфер.  Начинается с @var{starting-name} и производит имя,
которое в настоящее время не используется ни для одного буфера, путем
добавления числа внутри @samp{<@dots{}>}.  Начинается с 2 и продолжает
увеличивать число, пока оно не перестанет быть именем существующего буфера.

Если необязательный второй аргумент @var{ignore} - не-@code{nil}, это должна
быть строка, потенциальное имя буфера.  Это означает, что потенциально
буфер считается приемлемым, если его создать, даже если это имя
существующего буфера (который обычно будет отклонено).  Таким образом, если
буферы с именем @samp{foo}, @samp{foo<2>}, @samp{foo<3>} и @samp{foo<4>}
существуют,

@example
(generate-new-buffer-name "foo")
     @result{} "foo<5>"
(generate-new-buffer-name "foo" "foo<3>")
     @result{} "foo<3>"
(generate-new-buffer-name "foo" "foo<6>")
     @result{} "foo<5>"
@end example

Смотреть соответствующую функцию @code{generate-new-buffer} в
@ref{Creating Buffers}.
@end defun

@node Buffer File Name
@section Имя Файла Буфера
@cindex visited file
@cindex buffer file name
@cindex file name of buffer

  @dfn{Имя файла буфера} - это имя файла, который просматривается в этом
буфере.  Когда буфер не обращается к файлу, его имя файла буфера -
@code{nil}.  В большинстве случаев имя буфера совпадает с не относящейся к
части имени каталога файла буфера, но имя файла буфера и имя буфера
различны и могут быть установлены независимо.  @xref{Visiting Files}.

@defun buffer-file-name &optional buffer
Функция возвращает абсолютное имя файла, который посещает @var{buffer}.
Если @var{buffer} не обращается ни к одному файлу, @code{buffer-file-name}
возвращает @code{nil}.  Если @var{buffer} не указан, по умолчанию
используется текущий буфер.

@example
@group
(buffer-file-name (other-buffer))
     @result{} "/usr/user/lewis/manual/files.texi"
@end group
@end example
@end defun

@defvar buffer-file-name
Локальная в буфере переменная содержит имя файла, посещаемого в текущем
буфере, или @code{nil}, если нет обращения к файлу.  Это постоянная
локальная переменная, на которую @code{kill-all-local-variables} не влияет.

@example
@group
buffer-file-name
     @result{} "/usr/user/lewis/manual/buffers.texi"
@end group
@end example

Рискованно изменять значение этой переменной, не выполняя других действий.
Обычно лучше использовать @code{set-visited-file-name} (смотреть ниже);
некоторые из вещей, которые там выполняются, например, изменение имени
буфера, не являются строго необходимыми, но другие необходимы, чтобы не
сбивать Emacs с толку.
@end defvar

@defvar buffer-file-truename
Локальная переменная буфера содержит сокращенное истинное имя файла,
посещенного в текущем буфере, или @code{nil}, если файл не был посещен.  Это
постоянный локальный объект, на который не влияет
@code{kill-all-local-variables}.  @xref{Truenames} и
@ref{abbreviate-file-name}.
@end defvar

@defvar buffer-file-number
Локальная переменная буфера содержит номер файла и номер устройства
каталога для файла, посещаемого в текущем буфере, или @code{nil}, если не
посещается ни один файл или файл несуществует.  Это постоянный локальный
объект, на который не влияет @code{kill-all-local-variables}.

Значение обычно представляет собой список вида
@code{(@var{filenum} @var{devnum})}.  Эта пара чисел однозначно
идентифицирует файл среди всех файлов, доступных в системе.  Смотреть
функцию @code{file-attributes} в @ref{File Attributes} для получения
дополнительной информации о них.

Если @code{buffer-file-name} - это имя символической ссылки, то оба числа
относятся к рекурсивной цели.
@end defvar

@defun get-file-buffer filename
Функция возвращает буфер посещения файла @var{filename}.  Если такого буфера
нет, возвращается @code{nil}.  Аргумент @var{filename}, который должен быть
строкой, раскрывается в (@pxref{File Name Expansion}), а затем сравнивается
с именами посещенных файлов всех активных буферов.  Обратить внимание, что
@code{buffer-file-name} буфера должен точно соответствовать расширению
@var{filename}.  Эта функция не распознает другие имена для того же файла.

@example
@group
(get-file-buffer "buffers.texi")
    @result{} #<buffer buffers.texi>
@end group
@end example

В необычных обстоятельствах одно и то же имя файла может посещать несколько
буферов.  В таких случаях эта функция возвращает первый такой буфер в списке
буферов.
@end defun

@defun find-buffer-visiting filename &optional predicate
Это похоже на @code{get-file-buffer}, за исключением того, что может
возвращать любой буфер, обращающийся к файлу
@emph{возможно под другим именем}.  То есть @code{buffer-file-name} буфера
не обязательно должно точно соответствовать расширению @var{filename}, ему
нужно только ссылаться на тот же файл.  Если @var{predicate} равен
не-@code{nil}, это должно быть функцией одного аргумента - буфера,
обращающегося к @var{filename}.  Буфер считается подходящим возвращаемым
значением, только если @var{predicate} возвращает не-@code{nil}.  Если не
удается найти подходящий буфер для возврата, @code{find-buffer-visiting}
возвращает @code{nil}.
@end defun

@deffn Command set-visited-file-name filename &optional no-query along-with-file
Если @var{filename} - непустая строка, эта функция изменяет имя файла,
посещаемого в текущем буфере, на @var{filename}.  (Если в буфере не было
посещенного файла, он его получает.)  @emph{В следующий раз} сохранения
буфера, будет помещен в новый указанный файл.

Команда помечает буфер как измененный, так как он (насколько известно Emacs)
не соответствует содержимому @var{filename}, даже если соответствует
предыдущему посещенному файлу.  Также переименовывает буфер в соответствии с
новым именем файла, если новое имя уже не используется.

Если @var{filename} - это @code{nil} или пустая строка, это обозначает
``нет посещенного файла''.  В этом случае @code{set-visited-file-name}
помечает буфер как не имеющий посещенного файла, не изменяя флаг изменения
буфера.

Обычно эта функция запрашивает у пользователя подтверждение, существует ли
уже буфер, обращающийся к @var{filename}.  Если @var{no-query} равно
не-@code{nil}, это не позволяет задать этот вопрос.  Если уже есть буфер,
посещающий @var{filename}, и пользователь подтверждает, что @var{no-query} -
не-@code{nil}, эта функция делает новое имя буфера уникальным, добавляя
число внутри @samp{<@dots{}>} к @var{filename}.

Если @var{along-with-file} равен не-@code{nil}, это означает, что предыдущий
посещенный файл был переименован в @var{filename}.  В этом случае команда не
изменяет ни флаг изменения буфера, ни время последней модификации файла,
записанное в буфере, как сообщает @code{visited-file-modtime}
(@pxref{Modification Time}).  Если @var{along-with-file} равен @code{nil},
эта функция очищает записанное время последней модификации файла, после чего
@code{visited-file-modtime} возвращает nil.

Когда функция @code{set-visited-file-name} вызывается в интерактивном
режиме, запрашивает @var{filename} в минибуфере.
@end deffn

@defvar list-buffers-directory
Эта локальная для буфера переменная определяет строку, отображаемую в списке
буферов, куда будет помещено имя посещенного файла для буферов, у которых
нет имени посещенного файла.  Буферы Dired используют эту переменную.
@end defvar

@node Buffer Modification
@section Модификация Буфера
@cindex buffer modification
@cindex modification flag (of buffer)

  Emacs хранит флаг @dfn{флаг модификации} для каждого буфера, чтобы
записывать, изменился ли текст буфера.  Этот флаг устанавливается в @code{t}
всякий раз, когда изменяется содержимое буфера, и сбрасывается в @code{nil}
при его сохранении.  Таким образом, флаг показывает, есть ли несохраненные
изменения.  Значение флага обычно отображается в строке режима
(@pxref{Mode Line Variables}) и управляет сохранением
(@pxref{Saving Buffers}) и автосохранением (@pxref{Auto-Saving}).

  Некоторые программы Lisp устанавливают этот флаг явно.  Например, функция
@code{set-visited-file-name} устанавливает флаг в @code{t}, потому что
текст не соответствует вновь посещенному файлу, даже если он не изменился
по сравнению с файлом, который ранее посещался.

  Функции, изменяющие содержимое буферов, описаны в @ref{Text}.

@defun buffer-modified-p &optional buffer
Функция возвращает @code{t}, если буфер @var{buffer} был изменен с момента
последнего считывания из файла или сохранения, или @code{nil} в противном
случае.  Если @var{buffer} не указан, проверяется текущий буфер.
@end defun

@defun set-buffer-modified-p flag
Функция отмечает текущий буфер как измененный, если @var{flag} равен
не-@code{nil}, или как немодифицированный, если флаг @code{nil}.

Другой эффект вызова этой функции - вызвать безусловное повторное
отображение строки режима для текущего буфера.  Фактически, функция
@code{force-mode-line-update} работает следующим образом:

@example
@group
(set-buffer-modified-p (buffer-modified-p))
@end group
@end example
@end defun

@defun restore-buffer-modified-p flag
Подобно @code{set-buffer-modified-p}, но не вызывает повторного отображения
строк режима.
@end defun

@deffn Command not-modified &optional arg
Команда помечает текущий буфер как немодифицированный и не требующий
сохранения.  Если @var{arg} равен не-@code{nil}, помечает буфер как
измененный, чтобы он был сохранен при следующем подходящем случае.  В
интерактивном режиме @var{arg} - это префиксный аргумент.

Не использовать эту функцию в программах, поскольку печатает сообщение в
эхо-области; использовать вместо неё @code{set-buffer-modified-p}
(смотреть выше).
@end deffn

@defun buffer-modified-tick &optional buffer
Функция возвращает количество модификаций @var{buffer}.  Это счетчик,
который увеличивается каждый раз при изменении буфера.  Если @var{buffer}
равен @code{nil} (или опущен), используется текущий буфер.  Счетчик может
время от времени обнулятся.
@end defun

@defun buffer-chars-modified-tick &optional buffer
Функция возвращает количество модификаций при изменении символа
@var{buffer}.  При изменении свойств текста этот счетчик остается
неизменным; однако каждый раз, когда текст вставляется или удаляется из
буфера, счетчик сбрасывается до значения, которое было бы возвращено
@code{buffer-modified-tick}.  Сравнивая значения, возвращаемые двумя
вызовами @code{buffer-chars-modified-tick}, можно определить, произошло ли
изменение символа в этом буфере между вызовами.  Если @var{buffer} имеет
значение @code{nil} (или опущено), используется текущий буфер.
@end defun

Иногда возникает необходимость изменить буфер таким образом, чтобы на самом
деле его текст не изменялся, например, если изменяются только его свойства
текста.  Если программе необходимо изменить буфер без запуска каких-либо
перехватчиков и функций, которые реагируют на изменения буфера,
использовать макрос @code{with-silent-modifications}.

@defmac with-silent-modifications body@dots{}
Выполнить @var{body}, делая вид, что не изменяется буфер.  Это включает в
себя проверку того, заблокирован ли файл буфера (@pxref{File Locks}),
выполнение обработчиков изменения буфера (@pxref{Change Hooks}) и так далее.
Обратить внимание, что если @var{body} действительно изменяет текст буфера,
его данные отмены могут быть повреждены.
@end defmac

@node Modification Time
@section Время Модификации Буфера
@cindex comparing file modification time
@cindex modification time of buffer

  Предположить, посещается файл и вносятся изменения в его буфер, а при этом
сам файл изменяется на диске.  На этом этапе сохранение буфера перезапишет
изменения в файле.  Иногда это может быть то, что нужно, но обычно это
приводит к потере ценной информации.  Поэтому Emacs проверяет время
модификации файла, используя функции, описанные ниже, перед сохранением
файла.  (@xref{File Attributes}, как проверить время изменения файла.)

@defun verify-visited-file-modtime &optional buffer
Функция сравнивает то, что @var{buffer} (по умолчанию, текущий-буфер)
записал для времени модификации посещенного файла, с фактическим временем
модификации файла, записанным операционной системой.  Должны быть
одинаковыми, если какой-либо другой процесс не записал файл с тех пор, как
Emacs посетил или сохранил его.

Функция возвращает @code{t}, если фактическое время последней модификации и
записанное время модификации Emacs совпадают, в противном случае -
@code{nil}.  Также возвращает @code{t}, если в буфере не записано время
последней модификации, то есть если @code{visited-file-modtime} вернет nil.

Всегда возвращает @code{t} для буферов, которые не обращаются к файлу, даже
если @code{visited-file-modtime} возвращает ненулевое значение.  Например,
всегда возвращает @code{t} для dired буферов.  Возвращает @code{t} для
буферов, обращающихся к файлу, который не существует и никогда не
существовал, но @code{nil} для буферов обращения к файлам, файл которых был
удален.
@end defun

@defun clear-visited-file-modtime
Функция очищает запись о времени последней модификации файла, который
посещает текущий буфер.  В результате следующая попытка сохранить этот буфер
не будет жаловаться на несоответствие во времени модификации файла.

Функция вызывается в @code{set-visited-file-name} и других исключительных
местах, где не следует выполнять обычный тест, чтобы избежать перезаписи
измененного файла.
@end defun

@defun visited-file-modtime
Функция возвращает время последней модификации файла, записанное в текущем
буфере, в виде списка вида
@code{(@var{high} @var{low} @var{microsec} @var{picosec})}.  (Это тот же
формат, который @code{file-attributes} использует для возврата значений
времени; @pxref{File Attributes}.)

Если в буфере не записано время последней модификации, эта функция
возвращает nil.  Этот случай возникает, например, если буфер не обращается к
файлу или если время было явно очищено @code{clear-visited-file-modtime}.
Однако обратить внимание, что @code{visited-file-modtime} также возвращает
список для некоторых нефайловых буферов.  Например, в буфере Dired, в
котором указан каталог, возвращает время последней модификации этого
каталога, записанное Dired.

Если буфер обращается к несуществующему файлу, эта функция возвращает
@minus{}1.
@end defun

@defun set-visited-file-modtime &optional time
Функция обновляет запись буфера о времени последней модификации посещенного
файла до значения, указанного @var{time}, если @var{time} не является
@code{nil}, и в противном случае до времени последнего изменения посещенного
файла.

Если @var{time} не является ни @code{nil}, ни целочисленным флагом,
возвращаемым @code{visited-file-modtime}, должен иметь форму
@code{(@var{high} @var{low} @var{microsec} @var{picosec})}, формат,
используемый @code{current-time} (@pxref{Time of Day}).

Функция полезна, если буфер не читался из файла в обычном режиме или если
сам файл был изменен по известной неопасной причине.
@end defun

@defun ask-user-about-supersession-threat filename
Функция используется, чтобы спросить пользователя, как действовать после
попытки изменить буфер, обращающийся к файлу @var{filename}, когда файл
новее, чем текст буфера.  Emacs обнаруживает это, потому что время
модификации файла на диске новее, чем время последнего сохранения, и его
содержимое изменилось.
Это означает, что какая-то другая программа, вероятно, изменила файл.

@kindex file-supersession
В зависимости от ответа пользователя функция может нормально возвращаться, и
в этом случае модификация буфера продолжается, или она может сигнализировать
об ошибке @code{file-supersession} с данными @code{(@var{filename})}, и в
этом случае предлагаемая модификация буфера не разрешена.

Функция автоматически вызывается Emacs в определенных случаях.  Вызывается,
поэтому можно настроить Emacs, переопределив её.  Стандартное определение
смотреть ы файле @file{userlock.el}.

Смотреть также механизм блокировки файлов в @ref{File Locks}.
@end defun

@node Read Only Buffers
@section Буферы Только для Чтения
@cindex read-only buffer
@cindex buffer, read-only

  Если буфер @dfn{только чтение}, то вы не выйдет изменить его содержимое,
хотя можно изменить вид содержимого, прокручивая и сужая.

  Буферы только для чтения используются в двух ситуациях.:

@itemize @bullet
@item
Буфер, обращающийся к защищенному от записи файлу, обычно доступен только
для чтения.

Здесь цель состоит в том, чтобы сообщить пользователю, что редактирование
буфера с целью сохранения его в файле может быть бесполезным или
нежелательным.  Пользователь, который хочет изменить текст буфера, несмотря
на это, может сделать это после сброса флага только для чтения с помощью
@kbd{C-x C-q}.

@item
Такие режимы, как Dired и Rmail, делают буферы доступными только для чтения,
когда изменение содержимого с помощью обычных команд редактирования,
вероятно, будет ошибкой.

Специальные команды этих режимов связывают @code{buffer-read-only} с
@code{nil} (с @code{let}) или связывают @code{inhibit-read-only} с @code{t}
вокруг тех мест, где они сами меняют текст.
@end itemize

@defvar buffer-read-only
Эта локальная для буфера переменная определяет, доступен ли буфер только для
чтения.  Буфер доступен только для чтения, если эта переменная -
не-@code{nil}.  Однако символы с текстовым свойством
@code{inhibit-read-only} все еще можно изменять.
@xref{Special Properties, inhibit-read-only}.
@end defvar

@defvar inhibit-read-only
Если эта переменная - не-@code{nil}, то буферы только для чтения и, в
зависимости от фактического значения, могут быть изменены некоторые или все
символы только для чтения.  Доступные только для чтения символы в буфере -
это те, которые имеют текстовое свойство не-@code{nil} @code{read-only}.
@xref{Special Properties}, для получения дополнительной информации о
свойствах текста.

Если @code{inhibit-read-only} равен @code{t}, все свойства символа
@code{read-only} не действуют.  Если @code{inhibit-read-only} - это список,
то свойства символов @code{read-only} не действуют, если они являются
членами списка (сравнение выполняется с @code{eq}).
@end defvar

@deffn Command read-only-mode &optional arg
Команда режима для второстепенного режима только для чтения, второстепенного
режима локального буфера. Когда режим включен, @code{buffer-read-only} - это
не-@code{nil} в буфере; когда отключено, @code{buffer-read-only} будет
@code{nil} в буфере.  Соглашение о вызовах такое же, как и для других команд
второстепенного режима (@pxref{Minor Mode Conventions}).

Этот второстепенный режим в основном служит оболочкой для
@code{buffer-read-only}; в отличие от большинства второстепенных режимов
здесь нет отдельной переменной @code{read-only-mode}.  Даже когда режим
только для чтения отключен, символы с текстовыми свойствами не-@code{nil}
@code{read-only} остаются доступными только для чтения.  Чтобы временно
игнорировать все состояния только для чтения, привязать
@code{inhibit-read-only}, как описано выше.

При включении режима «Только чтение» эта команда режима также включает
режим просмотра, если параметр @code{view-read-only} равен не-@code{nil}.
@xref{Misc Buffer,,Miscellaneous Buffer Operations, emacs, The GNU Emacs Manual}.
При отключении режима «Только чтение» отключает режим просмотра, если режим
просмотра был включен.
@end deffn

@defun barf-if-buffer-read-only &optional position
Функция сигнализирует об ошибке @code{buffer-read-only}, если текущий буфер
доступен только для чтения.  Если для текста в @var{position} (который по
умолчанию указывает на точку) установлено свойство текста
@code{inhibit-read-only}, ошибка не возникает.

@xref{Using Interactive}, для другого способа сообщить об ошибке, если
текущий буфер доступен только для чтения.
@end defun

@node Buffer List
@section Список Буферов
@cindex buffer list
@cindex listing all buffers

  @dfn{Список буферов} - это список всех живых буферов.  Порядок буферов в
этом списке в первую очередь зависит от того, как давно каждый буфер
отображался в окне.  Некоторые функции, в частности @code{other-buffer},
используют этот порядок.  Список буферов, отображаемый для пользователя,
также следует в этом порядке.

  Создание буфера добавляет его в конец списка буферов, а уничтожение буфера
удаляет его из этого списка.  Буфер перемещается в начало этого списка
всякий раз, когда он выбирается для отображения в окне
(@pxref{Switching Buffers}) или окно, отображающее его, выбирается
(@pxref{Selecting Windows}).  A buffer moves to the end of the list
when it is buried (смотреть @code{bury-buffer}, ниже).  Программисту на
Lisp не доступны функции, которые напрямую управляют списком буферов.

  В дополнение к только что описанному основному списку буферов Emacs
поддерживает список локальных буферов для каждого кадра, которые были
отображены (или были выбраны их окна) в этом кадре, идут первыми.  (Этот
порядок записывается в параметре кадра @code{buffer-list} кадра; смотреть
@ref{Buffer Parameters}.)  Буферы, никогда не отображаемые в этом кадре,
поступают позже, упорядоченные в соответствии с основным списком буферов.

@defun buffer-list &optional frame
Функция возвращает список буферов, включая все буферы, даже те, чьи имена
начинаются с пробела.  Элементы - это фактические буферы, а не их имена.

Если @var{frame} является фреймом, возвращается список локальных буферов
@var{frame}.  Если @var{frame} равен @code{nil} или опущен, используется
основной список буферов: буферы появляются в порядке последнего отображения
или выбора, независимо от того, в каких кадрах они были отображены.

@example
@group
(buffer-list)
     @result{} (#<buffer buffers.texi>
         #<buffer  *Minibuf-1*> #<buffer buffer.c>
         #<buffer *Help*> #<buffer TAGS>)
@end group

@group
;; @r{Обратите внимание, что имя минибуфера}
;;   @r{ начинается с пробела!}
(mapcar (function buffer-name) (buffer-list))
    @result{} ("buffers.texi" " *Minibuf-1*"
        "buffer.c" "*Help*" "TAGS")
@end group
@end example
@end defun

  Список, возвращаемый @code{buffer-list}, создается специально; это не
внутренняя структура данных Emacs, и ее изменение не влияет на порядок
буферов.  Если требуется изменить порядок буферов в основном списке буферов,
вот простой способ:

@example
(defun reorder-buffer-list (new-list)
  (while new-list
    (bury-buffer (car new-list))
    (setq new-list (cdr new-list))))
@end example

  С помощью этого метода можно указать любой порядок для списка, но нет
опасности потерять буфер или добавить что-то, что не является допустимым
оперативным буфером.

  Чтобы изменить порядок или значение в списке буферов определенного кадра,
установить для параметра @code{buffer-list} этого кадра значение
@code{modify-frame-parameters} (@pxref{Parameter Access}).

@defun other-buffer &optional buffer visible-ok frame
Функция возвращает первый буфер в списке буферов, кроме @var{buffer}.
Обычно это буфер, появляющийся в последнем выбранном окне (в кадре
@var{frame} или в выбранном кадре, @pxref{Input Focus}), помимо
@var{buffer}.  Буферы, имена которых начинаются с пробела, вообще не
рассматриваются.

Если @var{buffer} не указан (или если это не активный буфер), то
@code{other-buffer} возвращает первый буфер в списке локальных буферов
выбранного фрейма.  (Если @var{frame} равен не-@code{nil}, вместо этого
возвращается первый буфер в списке локальных буферов @var{frame}.)

Если @var{frame} имеет параметр не-@code{nil} @code{buffer-predicate}, то
@code{other-buffer} использует этот предикат, чтобы решить, какие буферы
рассматривать.  Вызывает предикат один раз для каждого буфера, и если
значение равно @code{nil}, этот буфер игнорируется.
@xref{Buffer Parameters}.

@c Emacs 19 feature
Если @var{visible-ok} равен @code{nil}, @code{other-buffer} избегает
возврата буфера, видимого в любом окне на любом видимом фрейме, кроме как в
крайнем случае.  Если @var{visible-ok} равен не-@code{nil}, то не имеет
значения, отображается где-то буфер или нет.

Если подходящего буфера не существует, возвращается буфер @file{*scratch*}
(и создается, если необходимо).
@end defun

@defun last-buffer &optional buffer visible-ok frame
Функция возвращает последний буфер в списке буферов @var{frame}, отличный от
@var{buffer}.  Если @var{frame} не указан или @code{nil}, использует список
буферов выбранного фрейма.

Аргумент @var{visible-ok} обрабатывается так же, как и @code{other-buffer},
смотреть выше.  Если подходящий буфер не может быть найден, возвращается
буфер @file{*scratch*}.
@end defun

@deffn Command bury-buffer &optional buffer-or-name
Команда помещает @var{buffer-or-name} в конец списка буферов, не меняя
порядок других буферов в списке.  Таким образом, этот буфер становится
наименее желательным кандидатом для возврата @code{other-buffer}.
Аргументом может быть либо сам буфер, либо его имя.

Функция работает с параметром @code{buffer-list} каждого кадра, а также с
основным списком буферов; таким образом, буфер, который поместите, будет
последним по значению @code{(buffer-list @var{frame})} и значению
@code{(buffer-list)}.  Кроме того, также помещает буфер в конец списка
буферов выбранного окна (@pxref{Window History}), если он отображается в
этом окне.

Если @var{buffer-or-name} равен @code{nil} или опущен, это означает, что
текущий буфер скрывается.  Кроме того, если текущий буфер отображается в
выбранном окне, это гарантирует, что окно либо удалено, либо в нем
отображается другой буфер.  Точнее, если выбранное окно предназначено для
(@pxref{Dedicated Windows}) и в его фрейме есть другие окна, окно удаляется.
Если это единственное окно в его фрейме, и этот фрейм не единственный фрейм
в его терминале, фрейм отклоняется путем вызова функции, указанной в
@code{frame-auto-hide-function} (@pxref{Quitting Windows}).  В противном
случае вызывается @code{switch-to-prev-buffer} (@pxref{Window History}),
чтобы показать другой буфер в этом окне.  Если @var{buffer-or-name}
отображается в каком-либо другом окне, он остается там.

Чтобы заменить буфер во всех окнах, в которых он отображается, использовать
@code{replace-buffer-in-windows}, @xref{Buffers and Windows}.
@end deffn

@deffn Command unbury-buffer
Команда переключает на последний буфер в списке локальных буферов выбранного
кадра.  Точнее, он вызывает функцию @code{switch-to-buffer}
(@pxref{Switching Buffers}), чтобы отобразить буфер, возвращаемый
@code{last-buffer} (смотреть выше), в выбранном окне.
@end deffn

@defvar buffer-list-update-hook
Это нормальный запуск ловушки при изменении списка буферов.  Функции
(неявно), запускающие эту ловушку: @code{get-buffer-create}
(@pxref{Creating Buffers}), @code{rename-buffer} (@pxref{Buffer Names}),
@code{kill-buffer} (@pxref{Killing Buffers}), @code{bury-buffer} (смотреть
выше) и @code{select-window} (@pxref{Selecting Windows}).

Функции, выполняемые этим перехватчиком, должны избегать вызова
@code{select-window} с аргументом nil @var{norecord} или
@code{with-temp-buffer}, поскольку любой из них может привести к
бесконечной рекурсии.
@end defvar

@node Creating Buffers
@section Создание Буферов
@cindex creating buffers
@cindex buffers, creating

  В этом разделе описаны два примитива для создания буферов.
@code{get-buffer-create} создает буфер, если не находит существующего буфера
с указанным именем; @code{generate-new-buffer} всегда создает новый буфер и
дает ему уникальное имя.

  Другие функции, которые можно использовать для создания буферов, включают
@code{with-output-to-temp-buffer} (@pxref{Temporary Displays}) и
@code{create-file-buffer} (@pxref{Visiting Files}).  Запуск подпроцесса
также может создать буфер (@pxref{Processes}).

@defun get-buffer-create buffer-or-name
Функция возвращает буфер с именем @var{buffer-or-name}.  Возвращенный буфер
не становится текущим - эта функция не меняет текущий буфер.

@var{buffer-or-name} должен быть либо строкой, либо существующим буфером.
Если это строка и активный буфер с таким именем уже существует,
@code{get-buffer-create} возвращает этот буфер.  Если такого буфера не
существует, создается новый буфер.  Если @var{buffer-or-name} - это буфер, а
не строка, он возвращается как заданный, даже если он убит.

@example
@group
(get-buffer-create "foo")
     @result{} #<buffer foo>
@end group
@end example

Основной режим для вновь созданного буфера установлен на Основной режим.
(Значение по умолчанию переменной @code{major-mode} обрабатывается на более
высоком уровне; смотреть @ref{Auto Major Mode}.)  Если имя начинается с
пробела, буфер изначально запрещает отмену записи информации (@pxref{Undo}).
@end defun

@defun generate-new-buffer name
Aункция возвращает вновь созданный пустой буфер, но не делает его текущим.
Имя буфера генерируется путем передачи @var{name} функции
@code{generate-new-buffer-name} (@pxref{Buffer Names}).  Таким образом, если
нет буфера с именем @var{name}, то это имя нового буфера; если это имя
используется, суффикс вида @samp{<@var{n}>}, где @var{n} - целое число,
добавляется к @var{name}.

Выдается сообщение об ошибке, если @var{name} не является строкой.

@example
@group
(generate-new-buffer "bar")
     @result{} #<buffer bar>
@end group
@group
(generate-new-buffer "bar")
     @result{} #<buffer bar<2>>
@end group
@group
(generate-new-buffer "bar")
     @result{} #<buffer bar<3>>
@end group
@end example

Основной режим для нового буфера установлен на Основной режим.  Значение по
умолчанию переменной @code{major-mode} обрабатывается на более высоком
уровне.  @xref{Auto Major Mode}.
@end defun

@node Killing Buffers
@section Уничтоженные Буферы
@cindex killing buffers
@cindex buffers, killing

  @dfn{Уничтоженние буфера} делает его имя неизвестным Emacs и занимаемое
пространство памяти доступным для других целей.

  Буферный объект для буфера, который был уничтожен, остается существующим,
пока что-либо ссылается на него, но он специально помечен, чтобы не сделать
его текущим или отобразить его.  Однако убитые буферы сохраняют свою
идентичность; если уничтожаются два разных буфера, они останутся разными
согласно @code{eq}, хотя оба убиты.

  Если уничтожается текущий или отображаемый в окне буфер, Emacs
автоматически выбирает или отображает вместо него какой-нибудь другой буфер.
Это означает, что уничтожение буфера может изменить текущий буфер.
Следовательно, когда уничтожается буфер, также потребуется принять меры
предосторожности, связанные с изменением текущего буфера (если только не
знаеть, что уничтожаемый буфер не является текущим).  @xref{Current Buffer}.

  Если уничтожается буфер, который является базовым буфером одного или
нескольких косвенных
@iftex
буферов,
@end iftex
@ifnottex
косвенные буферы (@pxref{Indirect Buffers}),
@end ifnottex
также автоматически уничтожаются.

@cindex live buffer
  @code{buffer-name} буфера имеет значение @code{nil} тогда и только тогда,
когда буфер уничтожен.  Буфер, который не был уничтожен, называется буфером
@dfn{живым}.  Чтобы проверить, активен ли буфер или убит, использовать
функцию @code{buffer-live-p} (смотреть ниже).

@deffn Command kill-buffer &optional buffer-or-name
Функция уничтожает буфер @var{buffer-or-name}, освобождая всю его память для
других целей или для возврата в операционную систему.  Если
@var{buffer-or-name} равен @code{nil} или опущен, текущий буфер
уничтожается.

Любые процессы, которые имеют этот буфер как @code{process-buffer},
отправляют сигнал @code{SIGHUP} (зависание), который обычно приводит к их
завершению.  @xref{Signals to Processes}.

Если буфер обращается к файлу и содержит несохраненные изменения,
@code{kill-buffer} просит пользователя подтвердить, прежде чем буфер будет
уничтожен.  Делается это, даже если не вызывается в интерактивном режиме.
Чтобы предотвратить запрос подтверждения, снимается измененный флаг перед
вызовом @code{kill-buffer}.  @xref{Buffer Modification}.

Функция вызывает @code{replace-buffer-in-windows} для очистки всех окон, в
настоящее время отображающих убиваемый буфер.

Удаление уже уничтоженного буфера не имеет никакого эффекта.

Функция возвращает @code{t}, если она действительно уничтожила буфер.
Возвращает @code{nil}, если пользователь отказывается подтвердить или
@var{buffer-or-name} если буфер уже уничтожен.

@smallexample
(kill-buffer "foo.unchanged")
     @result{} t
(kill-buffer "foo.changed")

---------- Buffer: Minibuffer ----------
Buffer foo.changed modified; kill anyway? (yes or no) @kbd{yes}
---------- Buffer: Minibuffer ----------

     @result{} t
@end smallexample
@end deffn

@defvar kill-buffer-query-functions
Перед подтверждением несохраненных изменений @code{kill-buffer} вызывает
функции из списка @code{kill-buffer-query-functions} в порядке появления без
аргументов.  Уничтожаемый буфер - это текущий буфер при их вызове.  Идея
этой функции заключается в том, что эти функции будут запрашивать
подтверждение у пользователя.  Если любое из них возвращает @code{nil},
@code{kill-buffer} сохраняет существование буфера.
@end defvar

@defvar kill-buffer-hook
Это обычная ловушка, которую @code{kill-buffer} запускает после того, как
задает все вопросы, которые собирался задать, непосредственно перед тем, как
фактически уничтожить буфер.  Буфер, который должен быть уничтожен, является
текущим, когда выполняются функции ловушки.  @xref{Hooks}.  Эта переменная
является постоянной локальной, поэтому ее локальная привязка не очищается
при изменении основных режимов.
@end defvar

@defopt buffer-offer-save
Переменная, если не-@code{nil} в определенном буфере, сообщает
@code{save-buffers-kill-emacs} предложить сохранить этот буфер, так же, как
она предлагает сохранять буферы обращения к файлам.  Если
@code{save-some-buffers} вызывается со вторым необязательным аргументом,
установленным в @code{t}, также предложит сохранить буфер.  Наконец, если
эта переменная установлена в символ @code{always}, и
@code{save-buffers-kill-emacs}, и @code{save-some-buffers} всегда будут
предлагать сохранить буфер.  @xref{Definition of save-some-buffers}.
Переменная @code{buffer-offer-save} автоматически становится локальной для
буфера при установке по любой причине.  @xref{Buffer-Local Variables}.
@end defopt

@defvar buffer-save-without-query
Эта переменная, если не-@code{nil} в определенном буфере, сообщает
@code{save-buffers-kill-emacs} и @code{save-some-buffers} сохранить этот
буфер (если он изменен), не спрашивая пользователя.  Переменная
автоматически становится локальной для буфера при установке по любой
причине.
@end defvar

@defun buffer-live-p object
Функция возвращает @code{t}, если @var{object} является активным буфером
(буфер, который не был уничтожен), в противном случае - @code{nil}.
@end defun

@node Indirect Buffers
@section Косвенные Буферы
@cindex indirect buffers
@cindex base buffer

  @dfn{Косвенный буфер} использует текст какого-то другого буфера, который
называется @dfn{базовый буфер} косвенного буфера.  В некотором смысле для
буферов это аналог символической ссылки между файлами.  Базовый буфер сам по
себе не может быть косвенным буфером.

  Текст косвенного буфера всегда идентичен тексту его базового буфера;
изменения, внесенные путем редактирования одного из них, сразу видны в
другом.  Сюда входят свойства текста, а также сами символы.

  Во всем остальном косвенный буфер и его базовый буфер полностью разделены.
У них разные имена, независимые значения точки, независимое сужение,
независимые маркеры и наложения (хотя вставка или удаление текста в любом
буфере перемещает маркеры и наложения для обоих), независимые основные
режимы и независимые привязки переменных локальной буфера.

  Косвенный буфер не может посещать файл, но его базовый буфер может.  Если
попытаться сохранить косвенный буфер, фактически сохранится базовый буфер.

  Удаление косвенного буфера не влияет на его базовый буфер.  Удаление
базового буфера эффективно уничтожает косвенный буфер, поскольку он больше
не может быть как таковым.

@deffn Command make-indirect-buffer base-buffer name &optional clone
Создает и возвращает косвенный буфер с именем @var{name}, базовым буфером
которого является @var{base-buffer}.  Аргумент @var{base-buffer} может быть
активным буфером или именем (строкой) существующего буфера.  Если @var{name}
- имя существующего буфера, сигнализируется ошибка.

Если @var{clone} равен не-@code{nil}, то косвенный буфер изначально
разделяет состояние @var{base-buffer}, такое как основной режим,
второстепенные режимы, локальные переменные буфера и так далее.  Если
@var{clone} опущен или @code{nil}, состояние косвенного буфера
устанавливается в состояние по умолчанию для новых буферов.

Если @var{base-buffer} является косвенным буфером, его базовый буфер
используется как основа для нового буфера.  Если дополнительно @var{clone}
установлено в не-@code{nil}, начальное состояние копируется из фактического
базового буфера, а не из @var{base-buffer}.
@end deffn

@deffn Command clone-indirect-buffer newname display-flag &optional norecord
Функция создает и возвращает новый косвенный буфер, который разделяет
базовый буфер текущего буфера и копирует остальные атрибуты текущего буфера.
(Если текущий буфер не является косвенным, он используется как базовый
буфер.)

Если @var{display-flag} равен не-@code{nil}, как всегда в интерактивных
вызовах, это означает отображение нового буфера путем вызова
@code{pop-to-buffer}.  Если @var{norecord} равно не-@code{nil}, это
означает, что новый буфер не следует помещать в начало списка буферов.
@end deffn

@defun buffer-base-buffer &optional buffer
Функция возвращает базовый буфер @var{buffer}, который по умолчанию равен
текущему буферу.  Если @var{buffer} не является косвенным, значение равно
@code{nil}.  В противном случае значение - это другой буфер, который никогда
не является косвенным буфером.
@end defun

@node Swapping Text
@section Обмен Текста Между Двумя Буферами
@cindex swap text between buffers
@cindex virtual buffers

  В специализированных режимах иногда требуется предоставить пользователю
доступ из одного буфера к нескольким совершенно различным типам текста.
Например, может потребоваться отобразить сводку текста буфера в дополнение к
разрешению пользователю доступа к самому тексту.

  Это может быть реализовано с использованием нескольких буферов
(синхронизированных, когда пользователь редактирует текст) или сужения
(@pxref{Narrowing}).  Но эти альтернативы могут иногда становиться
утомительными или чрезмерно дорогими, особенно если каждый тип текста
требует дорогостоящих глобальных операций с буфером, чтобы обеспечить
правильные команды отображения и редактирования.

  Emacs предоставляет еще одну возможность для таких режимов: можно быстро
переставлять текст буфера между двумя буферами с помощью
@code{buffer-swap-text}.  Эта функция очень быстрая, потому что она не
перемещает текст, она только изменяет внутренние структуры данных объекта
буфера, чтобы указать на другой фрагмент текста.  Используя её, можно
представить, что группа из двух или более буферов на самом деле является
одним виртуальным буфером, который хранит вместе содержимое всех отдельных
буферов.

@defun buffer-swap-text buffer
Функция меняет местами текст текущего буфера и его аргумента @var{buffer}.
Сигнализирует об ошибке, если один из двух буферов является косвенным
буфером (@pxref{Indirect Buffers}) или базовым буфером косвенного буфера.

Все свойства буфера, относящиеся к тексту буфера, также меняются местами:
позиции точки и метки, все маркеры, наложения, свойства текста, список
отмены, значение флага @code{enable-multibyte-characters}
(@pxref{Text Representations, enable-multibyte-characters}) и так далее.

@strong{Предупреждение:} Если функция вызывается из формы
@code{save-excursion}, текущий буфер будет установлен в @var{buffer} после
выхода из формы, поскольку маркер, используемый @code{save-excursion} для
сохранения позиции и буфера, также поменяется местами.
@end defun

  Если используется @code{buffer-swap-text} в буфере обращения к файлам,
потребуется настроить ловушку для сохранения исходного текста буфера, а не
того, с чем он был заменен.  @code{write-region-annotate-functions} подходит
для этой цели.  Вероятно, следует установить @code{buffer-saved-size} в
@minus{}2 в буфере, чтобы изменения в тексте, которым он заменяется, не
мешали автосохранению.

@node Buffer Gap
@section Разрыв Буфера
@cindex buffer gap

  Буферы Emacs реализованы с использованием невидимого @dfn{разрыва}, чтобы
ускорить вставку и удаление.  При вставке разрыв заполняется частично, а
при удалении разрыв увеличивается.  Конечно, это означает, что сначала нужно
переместить разрыв в место вставки или удаления.  Emacs перемещает разрыв
только тогда, когда пытаеться вставить или удалить.  Вот почему первая
команда редактирования в одной части большого буфера после предварительного
редактирования в другой удаленной части иногда вызывает заметную задержку.

  Этот механизм работает незаметно, и код Lisp никогда не должен зависеть от
текущего местоположения разрыва, но эти функции доступны для получения
информации о состоянии пробела.

@defun gap-position
Функция возвращает текущую позицию разрыва в текущем буфере.
@end defun

@defun gap-size
Функция возвращает текущий размер разрыва в текущем буфере.
@end defun
