@c -*- mode: texinfo; coding: utf-8 -*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2019 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Functions
@chapter Функции

  Программа Lisp состоит в основном из Lisp функций. В этой главе
  описывается, что такое функции, как они принимают аргументы, и как
  определить их.

@menu
* What Is a Function::          Lisp функции против примитивов; терминология.
* Lambda Expressions::          Выражение функции как объекта Lisp.
* Function Names::              Символ может служить именем функции.
* Defining Functions::          Lisp выражения для определения функций.
* Calling Functions::           Как использовать существующую функцию.
* Mapping Functions::           Применение функции к каждому элементу списка и т.д.
* Anonymous Functions::         Lambda выражения функции без каких-либо имен.
* Generic Functions::           Полиморфизм, Emacs-стиль.
* Function Cells::              Доступ к настройке или определение функции символа.
* Closures::                    Функции, вмещающие лексическую среду.
* Advising Functions::          Дополнение к определению функции.
* Obsolete Functions::          Объявление функцию устаревшей.
* Inline Functions::            Встроенные Функции, которые расширяет компилятор.(ВопросFunction26)
* Declare Form::                Добавление дополнительной информации о функции.
* Declaring Functions::         Собщение компилятору, что функция определена.(ВопросFunction28)
* Function Safety::             Определение, является ли функция безопасна для вызова.
* Related Topics::              Перекрестные ссылки на конкретные Lisp примитивы, которые имеют особое отношение к работе функций.
@end menu

@node What Is a Function
@section Что Такое Функция?

@cindex return value
@cindex value of function
@cindex argument
@cindex pure function
  В общем смысле, функция является правилом для проведения вычислений
  заданных входных значений, называемых @dfn{аргументами}.  Результат таких
  вычислений называется @dfn{значением} или @dfn{возвращаемым значением}
  функции.  Вычисление может также иметь побочные эффекты, такие как
  сохранение изменённого значения в переменных или содержимого структур
  данных (@pxref{Definition of side effect}).  @dfn{Чистая функция} является
  такой функцией, которая, в дополнение к тому, что не имеет каких-либо
  побочных эффектов, всегда возвращает то же значение для одной и той же
  комбинации аргументов, независимо от внешних факторов, таких как тип машины
  или состояния системы.

  В большинстве языков программирования, каждая функция имеет имя. Но в Lisp,
  функция в строгом смысле этого слова не имеет имени: это объект, который
  может быть связан @emph{по желанию} с символом (например, @code{car}),
  который служит в качестве имени функции.  @xref{Function Names}. Когда
  функция была связана с именем, помещён объект функции в компоненту ячейки
  функции символа, обычно относятся к этому символу, как к ``функции''
  (например, имеется в виду ``функция @code{car}'').  В этом руководстве,
  различие между именем символа, содержащего в своей компоненте функции
  объект функции и самой функции как объекта, как правило, неважно, но будет
  приниматься во внимание, где это уместно.

  Некоторые объекты, подобные функциям и называемые @dfn{специальные формы} и
  @dfn{макросы}, а также принимают аргументы для выполнения вычислений.
  Однако, как объяснено ниже, они не рассматриваются как функции Emacs Lisp.

  Вот важные условия для функций и объектов подобных функциям:

@table @dfn
@item lambda expression
Функция (в строгом смысле этого слова, то есть, функциональный объект),
написанная на языке Lisp.  Это описано в следующем разделе.
@ifnottex
@xref{Lambda Expressions}.
@end ifnottex

@item primitive
@cindex primitive
@cindex subr
@cindex built-in function
Функция, которая вызывается из Lisp, но на самом деле написана на C@.
Примитивы также называют @dfn{встроенными функциями}, или @dfn{subrs}.
Примеры включают в себя функции, такие как @code{car} и @code{append}. Кроме
того, все специальные формы (смотри ниже), также считаются примитивами.
(ВопросFunction84)

Как правило, функция реализуется как примитив, поскольку она является
основной частью Lisp (например, @code{car}), или потому, что она обеспечивает
интерфейс низкого уровня для работающих системных служб, или потому, что она
должна работать быстро.  В отличие от функций, определенных в Lisp, примитивы
могут быть изменены или добавлены только путем изменения источников С и
перекомпилированием Emacs.  Смотреть @ref{Writing Emacs Primitives}.

@item special form
Примитив, который подобен функции, но не оценивает все свои аргументы обычным
образом.  Он может оценить только некоторые из аргументов, или может оценить
их в необычном порядке, или по нескольку раз.  Примеры таких специальных
форм это формы @code{if}, @code{and} и @code{while}.
@xref{Special Forms}.

@item macro
@cindex macro
Конструкция определённая в Lisp, которая отличается от функции тем, что
преобразует одно выражение Lisp в другое выражение, которое должно быть
оценено вместо исходного выражения.  Макросы позволяют Lisp программистам
делать разные вещи, как те, что специальные формы сделать не могут.
@xref{Macros}.

@item command
@cindex command
Объект, который может быть вызван посредствам примитива
@code{command-execute}, как правило, из-за ввода пользователем
последовательности клавиш, @dfn{привязаной ключевой последовательности} к
этой команде.  @xref{Interactive Call}.  Команда, как правило, является
функцией; если функция написана на Lisp, она превращается в команду с помощью
специальной формы @code{interactive} при определении функции
(@pxref{Defining Commands}).  Команды, которые являются функциями, также
могут быть вызваны из Lisp выражений, так же как и другие функции.

Клавиатурные макросы (строки и векторы) также являются командами, хотя они не
являются функциями.  @xref{Keyboard Macros}.  Имеется в виду, при выражении,
символ является командой, это когда компонента символа ячека функции,
содержит команду (@pxref{Symbol Components}); такая @dfn{именованная команда}
может быть вызвана с помощью @kbd{M-x}.

@item closure
Объект функции, такой же, как лямбда-выражения, за исключением того, что
также охватывает лексическую среду привязки переменных.
@xref{Closures}.

@item byte-code function
Функция, которая была скомпилирована ​​байтовым компилятором.
@xref{Byte-Code Type}.

@item autoload object
@cindex autoload object
Место кода определения для реальной функции.  Если объект автозагрузка
вызывается, Emacs загружает файл, содержащий определение реальной функции, а
затем вызывает реальную функцию.  @xref{Autoload}.  (ВопросFunctions138)
@end table

  Вы можете использовать функцию @code{functionp} для прверки, является ли
  объект объектом функции:

@defun functionp object
Функция возвращает @code{t}, если @var{object} является любым видом функции,
то есть, может быть передан в @code{funcall}.  Обратите внимание, что
@code{functionp} возвращает @code{t} для символов, которые являются именами
функций и возвращает @code{nil} для специальных форм.
@end defun

  Также можно узнать, сколько аргументов ожидает функция:

@defun func-arity function
Функция предоставляет информацию о списке аргументов для указанной аргументом
@var{function} функции.  Возвращаемое значением является либо форма
cons-ячейки вида @w{@code{(@var{min} . @var{max})}}, где @var{min} является
минимальным, а @var{max} максимальным количеством аргументов, либо
символ @code{many} для функций использующих @code{&rest} аргументы, и
символ @code{unevalled}, если @var{function} является специальной формой.

Обратите внимание, что эта функция может возвращать неточные результаты в
некоторых ситуациях, таких как следующие:

@itemize @minus
@item
Функции определённые с помощью @code{apply-partially}
(@pxref{Calling Functions, apply-partially}).

@item
Функции, с которыми рекомендуется использовать @code{advice-add}
(@pxref{Advising Named Functions}). (ВопросFunctions171)

@item
Функции, которые определяют список аргументов динамически, как часть своего
кода.
@end itemize

@end defun

@noindent
В отличие от @code{functionp}, следующие три функции @emph{не} рассматривают
символ в качестве определения функции.

@defun subrp object
Функция возвращает @code{t}, если @var{object} является встроенной функцией
(т.е. Lisp примитивом).

@example
@group
(subrp 'message)            ; @r{символ @code{message}, не является}
     @result{} nil                 ;   @r{объектом встроенной функции (subr)}
@end group
@group
(subrp (symbol-function 'message))
     @result{} t
@end group
@end example
@end defun

@defun byte-code-function-p object
Функция возвращает @code{t} если @var{object} байт-компилированная функция.
Например:

@example
@group
(byte-code-function-p (symbol-function 'next-line))
     @result{} t
@end group
@end example
@end defun

@defun subr-arity subr
Это работает как @code{func-arity}, но только для встроенных функций и без
косвенной ссылки на символ функции.  Сигнализирует об ошибке для не
встроенных функций.  Рекомендуем использовать @code{func-arity} вместо этой.
@end defun

@node Lambda Expressions
@section Lambda Выражения
@cindex lambda expression

  Лямбда-выражение является объектом функции написанной на Lisp. Вот пример:

@example
(lambda (x)
  "Возвращает гиперболический косинус X."
  (* 0.5 (+ (exp x) (exp (- x)))))
@end example

@noindent
В Emacs Lisp, такой список является действительным выражением, которое
вычисляется в объект функции.

  Лямбда-выражения, само по себе, не имеет имени; это
  @dfn{анонимная функция}.  Хотя лямбда-выражения можно использовать таким
  способом (@pxref{Anonymous Functions}), они чаще связаны с символами, чтобы
  получить @dfn{именованную функцию} (@pxref{Function Names}). Прежде, чем
  погрузится в детали, следующие подразделы описывают компоненты
  лямбда-выражения и то, что они делают.

@menu
* Lambda Components::           Компоненты лямбда-выражения.
* Simple Lambda::               Простой пример.
* Argument List::               Детали и особенности списков аргументов.
* Function Documentation::      Как разместить документацию о функции.
@end menu

@node Lambda Components
@subsection Компоненты Лямбда-Выражения

  Лямбда-выражение - это список, который выглядит следующим образом:

@example
(lambda (@var{arg-variables}@dots{})
  [@var{documentation-string}]
  [@var{interactive-declaration}]
  @var{body-forms}@dots{})
@end example

@cindex lambda list
  Первый элемент лямбда-выражения всегда является символом @code{lambda}.
  Это указывает на то, что список представляет собой функцию.  Причина
  такого определения, использование первым элементом списка символ
  @code{lambda}, кроется в том, чтобы другие списки, предназначенные для
  использования в других целях, случайно не определялись в качестве функции.

  Второй элемент этого списка, представляет собой список символов --- имен
  переменных аргументов.  Это называется @dfn{лямбда-списком}.  Когда функция
  Lisp вызывается, значения аргументов сопостовляются с переменными
  @dfn{лямбда-списка}, которые получают локальные привязки предоставляемых
  значений. @xref{Local Variables}.

  Строка документации, предстовляет собой строковый объект Lisp, помещённый в
  определение функции и используется средствами помощи Emacs для описания
  функции.  @xref{Function Documentation}.

  Объявление интерактивности представляет собой список вида
  @code{(interactive @var{code-string})}. Это определяет, как обеспечить
  аргументами функцию, если вызов происходит в интерактивном режиме.  Функции
  с таким определением называются @dfn{командами}; могут быть вызваны с
  как с помощью сочетания нажатия клавиш @kbd{M-x} и набора привязанного
  ключа.  Функции не предназначены для вызова таким образом, не должен иметь
  интерактивного определения.  @xref{Defining Commands}, о том, как создать
  интерактивное заявление.

@cindex body of function
  Остальные элементы являются @dfn{телом} функции: Lisp-код, выполняет
  работу функции (или, как Lisp программист сказал бы, ``список Lisp форм
  для оценки'').  Значение, возвращаемое функцией является значением,
  возвращаемое последней оценённой формы этого тела.

@node Simple Lambda
@subsection Простой Пример Лямбда-Выражения

  Рассмотрим следующий пример:

@example
(lambda (a b c) (+ a b c))
@end example

@noindent
Мы можем вызвать эту функцию, передавая ее форме @code{funcall}, как здесь:

@example
@group
(funcall (lambda (a b c) (+ a b c))
         1 2 3)
@end group
@end example

@noindent
Этот вызов вычисляет тело лямбды-выражения связывая переменную @code{a} с 1,
@code{b} связывая с 2 и @code{c} связывая с 3.  Оценка тела формы складывает
эти три числа, производя результат 6; поэтому, этот вызов функции возвращает
значение 6.  Обратите внимание, что аргументы могут быть результатами других
вызовов функций, как в этом примере:

@example
@group
(funcall (lambda (a b c) (+ a b c))
         1 (* 2 3) (- 5 4))
@end group
@end example

@noindent
Вначале оцениваются аргументы @code{1}, @code{(* 2 3)}, и @code{(- 5 4)}
слева направо.  Затем их применяет лямбда-выражение со значениями аргументов
1, 6 и 1, в итоге получая значение 8.

  Как показывают эти примеры, вы можете использовать форму с
  лямбда-выражением в качестве её @sc{car}, а остальными элементами передать
  значения для переменных лямбда формы, тем самым получить локальные привязки
  переменных полученной формы.  В прежние времена Lisp, этот метод был
  единственный способ связать и инициализировать локальные переменные.  Но в
  наше время, это понятнее использовать специальную форму @code{let} для
  этого (@pxref{Local Variables}).  Лямбда-выражения в основном используются
  в качестве анонимных функций для передачи в качестве аргументов другим
  функциям (@pxref{Anonymous Functions}), или для хранения в виде определений
  в компоненте символа его ячейки функции для получения именованной функции
  (@pxref{Function Names}).

@node Argument List
@subsection Другие Особенности Списка Аргументов
@kindex wrong-number-of-arguments
@cindex argument binding
@cindex binding arguments
@cindex argument lists, features

  Простой пример, функция @code{(lambda (a b c) (+ a b c))}, определяет
  три аргумента, поэтому вызов производится с тремя аргументами: если
  попытаться передать в функцию два (и менее) или четыре (и более) аргумента,
  получиться ошибка @code{wrong-number-of-arguments} (@pxref{Errors}).

  Часто бывает удобно написать функцию, которая позволяет опускать некоторые
  аргументы.  Например, функция @code{substring} принимает три аргумента ---
  строку, индекс начала и индекс конца --- но третий аргумент привязывается
  к @var{длинне} строки по умолчанию, если он опущен.  Также удобно для
  некоторых функций принимать неопределенное количество аргументов, такие как
  функции @code{list} и @code{+}.

@cindex optional arguments
@cindex rest arguments
@kindex &optional
@kindex &rest
  Чтобы задать необязательные аргументы, которые могут быть опущены при
  вызове функции, включается ключевое слово @code{&optional} перед
  необязательными аргументами.  Чтобы указать список из нуля или более
  необязательных  аргументов, включается ключевое слово @code{&rest} до
  одного последнего аргумента списка аргументов.

  Таким образом, полный синтаксис списка аргументов выглядит следующим
  образом:

@example
@group
(@var{обязательные-переменные}@dots{}
 @r{[}&optional @var{опциональные-переменные}@dots{}@r{]}
 @r{[}&rest @var{дополнительные-переменные}@r{]})
@end group
@end example

@noindent
То что помещается в квадратные скобки, здесь @code{&optional} и @code{&rest},
а также переменные, которые заключены в них, не являются обязательными.

  Вызову функции требуется один фактический аргумент для каждого из
  @var{обязательные-переменные}.  Далее могут быть указаны ноль или более
  до определённого количества аргументов @var{опциональные-переменные}, и в
  конце после ключевого слова @code{&rest} может быть передано любое
  количество фактических аргументов @var{дополнительные-переменные}.
  (ВопросFunctions391)

  Если фактические аргументы для опцинальных и дополнительных переменных
  опущены, то они всегда привязываются по умолчанию к @code{nil}.  Нет
  никакого способа для функции различать явный аргумент @code{nil} и
  опущенный фактический аргумент.  Тем не менее, в теле функции свободно
  использовать аббревиатуру @code{nil} для какого-либо другого значимого
  значения.  Это то, что делает @code{substring}; @code{nil} в качестве
  третьего аргумента @code{substring} означает использовать всю длину
  предоставляемой строки.

@cindex CL note---default optional arg
@quotation
@b{Common Lisp замечание:} Common Lisp позволяет функции указать,
значение по умолчанию для необязательного аргумента если тот опущен;
Emacs Lisp всегда использует @code{nil}.  Emacs Lisp не поддерживает
@code{supplied-p} переменные, которые определяют, был ли явно предоставлен
аргумент.
@end quotation

  Например, список аргументов, который выглядит следующим образом:

@example
(a b &optional c d &rest e)
@end example

@noindent
связывает @code{a} и @code{b} с первыми двумя обязательными аргументами.
Если далее предоставлены один или два аргумента, @code{c} и @code{d}
связываются с ними соответственно; любые аргументы после первых четырех
собираются в список и @code{e} и привязывается к этому списку.  Таким
образом, если передано только два аргумента, @code{c}, @code{d} и @code{e}
устанавливаются в @code{nil}; если три аргумента, @code{d} и @code{e}
устанавливаются в @code{nil}; если не более четырёх аргументов, @code{e}
устанавливается в @code{nil}.  Обратите внимание, что ровно пять переданных
аргумента с явным @code{nil} в качестве пятого аргумента, приводит к тому,
что список @code{e} будет список с одним элементом @code{(nil)}, как с любым
другим одним значением для @code{e}.

  Нет никакого способа, чтобы указать фактические аргументы следующими за
  опущенными --- это не будет иметь смысла.  Чтобы понять, почему это так,
  предположим, что @code{c} в примере выше, является не обязательным а
  @code{d} обязательным.  Предположим, что функции передано три фактические
  аргумента; какая переменная будет связана с третим аргументом?  Будет ли
  она использована для @var{c}, или для @var{d}?  Можно утверждать оба
  случая.  Кроме того, также не имеет никакого смысла, использовать таким
  образом (либо обязательные либо необязательные) аргументы после ключевого
  слова @code{&rest}. (ВопросFunctions438)

  Вот некоторые примеры списков аргументов и соответствующих вызовов:

@example
(funcall (lambda (n) (1+ n))        ; @r{Один обязательный:}
         1)                         ; @r{передаётся только один аргумент.}
     @result{} 2
(funcall (lambda (n &optional n1); @r{Один обязательный и один опциональный:}
           (if n1 (+ n n1) (1+ n))) ; @r{1 или 2 аргумента.}
         1 2)
     @result{} 3
(funcall (lambda (n &rest ns); @r{Один обязательный и один дополнительный:}
           (+ n (apply '+ ns)))     ; @r{1 или более аргументов.}
         1 2 3 4 5)
     @result{} 15
@end example

@node Function Documentation
@subsection Строка Документации Функции
@cindex documentation of function

  Лямбда-выражение может иметь необязательную @dfn{строку документации} сразу
  после лямбда-списка.  Эта строка не влияет на выполнение функции; это
  своего рода комментарий, но систематизированый, который на самом деле
  имеет своё место в Lisp и может использоваться в справочных средствах
  Emacs.  @xref{Documentation}, для того, как получить доступ к строке
  документации.

  Это идея хорошая, чтобы обеспечить строкой документации все функции в вашей
  программе, даже те, которые вызываются только из вашей программы. Строка
  документации, похожа на комментарий, за исключением того, что к ней легче
  получить доступ.

  Первая строка документации должна быть самостоятельной и до конца
  осмысленной, потому что  @code{apropos} отображает только эту первую сроку.
  Лучше чтобы составлена была одного или двух полных предложений, которые
  описывают предназначение функции.

  Начало строки документации, как правило, пишется с отступом в исходном
  файле, но так как этот отступ приходится до начальной двойной кавычки,
  то не включается в содержание этой строки.  Некоторые делают отступ
  также для остальных дополнительных строки документации, чтобы выровнять
  текст в исходном тексте программы.  @emph{Это ошибка.}  Отступ на следующих
  строках находится внутри содержимого строки и выглядит красиво в исходном
  коде, но будет выглядеть некрасиво, при отображении командой справки.

  Можно задаться вопросом, как строка документации может быть необязательной,
  так как обязательные компоненты тела функции следуют за ней.  Поскольку
  оценка строки возвращает туже строку, без каких-либо побочных эффектов, это
  не имеет никакого эффекта, если это не последняя форма в теле.  Таким
  образом, на практике не существует путаницы между первой формой тела и
  строки документации; если форма тела является строкой, то она служит и в
  качестве возвращаемого значения и в качестве документации.

  В последней строке документации можно указать соглашения о вызовах,
  использующих различное количество фактических аргументов функции.  Пишется
  это так:

@example
\(fn @var{arglist})
@end example

@noindent
после пустой строки, в начале строки, без следующего символа перевода строки
строк документации.  (@samp{\} используется, чтобы избежать путаницы для
команд перемещения Emacs.).  Если придерживаться этого соглашение о вызовах,
в справочных сообщениях вместо обычного списка параметров, подставиться
список определённых в этой строке фактических аргументов функции.

  Эта функция особенно полезна для определения макросов, так как аргументы,
  написанные в определении макроса часто не соответствуют тому, что они
  собой представляют прибеглом взгляде программиста.

  Не нужно использовать эту функцию, если не придерживатся выше описанного
  соглашения.  Вместо этого используйте @code{advertised-calling-convention}
  объявление (@pxref{Declare Form}) или
  @code{set-advertised-calling-convention} (@pxref{Obsolete Functions}),
  потому что эти два способа заставят байт-компилятор выдавать предупреждение
  при компиляции Lisp программ, которые используют устаревшее соглашение
  строки документации о вызовах.

@node Function Names
@section Именование Функций
@cindex function definition
@cindex named function
@cindex function name

  Символ может служить в качестве имени функции.  Это происходит,
  когда компонента символа @dfn{ячейка функции} (@pxref{Symbol Components})
  содержит функциональный объект (например, лямбда-выражение).  Тогда сам
  символ становится действительным при использовании его как функции и его
  такой вызов эквивалентен вызову напрямую выражения, помещённого в его
  компоненте ячейки функции.

  Содержание компоненты символа ячейки функции также называют
  @dfn{определением функции} символа.  Порядок использования такого
  определения функции символа вместо символа называется использование
  @dfn{косвенного символа функции}; см @ref{Function Indirection}.  Если не
  задано символу определение функции, его компоненту ячейки функции называют
  @dfn{void (недействительной)}, и символ не может быть использован в
  качестве функции.

  На практике почти все функции имеют имена, и называются их именами.  Можно
  создать именованную функцию Lisp, путем определения лямбда-выражения и
  поместив это выражение в компоненту символа ячейку функции
  (@pxref{Function Cells}).  Тем не менее, чаще используется специальная
  форма @code{defun}, описанная в следующем разделе.
@ifnottex
@xref{Defining Functions}.
@end ifnottex

  Даются имена функциям, потому что удобно ссылаться на них по их именам в
  выражениях Lisp.  Кроме того, именованная функция Lisp может легко
  ссылаться на себя --- она может быть рекурсивной.  В добавок, на примитивы
  можно ссылаться только по их текстуально выраженным именам, так как они
  представляют собой объекты функций (@pxref{Primitive Function Type}) и не
  имеют синтаксис для чтения.

  Функция не должна иметь уникальное имя.  Данный объект функции
  @emph{обычно} появляется в компоненте ячейки функции только одного символа,
  но это всего лишь условность.  Легко можно сохранить такой объект в
  нескольких символах используя @code{fset}; и каждый из символов будет
  допустимым именем для одной и той же функции.

  Обратите внимание, что символ, используемый в качестве имени функции также
  может быть использован в качестве переменной;  Эти два варианта
  использования символа являются независимыми и не конфликтует.  (Это не так
  в некоторых диалектах Lisp, как Scheme.)

  По соглашению, если имя символа функции состоит из двух имен, разделенных
  @samp{--}, функция предназначается для внутреннего использования и первая
  часть относиться к имени файла определения функции.  Например, функция с
  именем @code{vc-git--rev-parse} внутренняя функция, определенная в
  файле @file{vc-git.el}.  Для внутреннего использования функции, написанные
  на C имеют имена, оканчивающиеся на @samp{-internal}, например,
  @code{bury-buffer-internal}.  Emacs код, относящийся к именованию функций
  для внутреннего использования написанный до 2018 года, может не
  придерживаться такого соглашения, которые постепенно отменяются.

@node Defining Functions
@section Определение Функций
@cindex defining a function

  Обычно имя функции присваивается при ее создании.  Это называется
  @dfn{определение функции}, и это делается с помощью макроса @code{defun}.

@defmac defun name args [doc] [declare] [interactive] body@dots{}
@code{defun} это обычный способ определение новой функции Lisp.  Определяет
символ @var{name} как функцию со списком аргументов @var{args} и телом формы,
заданным @var{body}.  Ни @var{name}, ни @var{args} не должны цитироваться.

@var{doc}, если присутствует, должно быть строкой с указанием строки
документации к функции (@pxref{Function Documentation}).  @var{declare}, если
присутствует, должно быть формой @code{declare} с указанием метаданных
функции (@pxref{Declare Form}).  @var{interactive}, если присутствует, должно
быть формой @code{interactive}, для указания как функция будет вызываться в
интерактивном режиме (@pxref {Interactive Call}).

Возвращаемое значение @code{defun} не определено.

Вот некоторые примеры:

@example
@group
(defun foo () 5)
(foo)
     @result{} 5
@end group

@group
(defun bar (a &optional b &rest c)
    (list a b c))
(bar 1 2 3 4 5)
     @result{} (1 2 (3 4 5))
@end group
@group
(bar 1)
     @result{} (1 nil nil)
@end group
@group
(bar)
@error{} Неверное число аргументов.
@end group

@group
(defun capitalize-backwards ()
  "Установить слову в точке заглавную букву."
  (interactive)
  (backward-word 1)
  (forward-word 1)
  (backward-char 1)
  (capitalize-word 1))
@end group
@end example

@cindex override existing functions
@cindex redefine existing functions
Будьте осторожны, чтобы не переопределить существующие функции неумышленно.
@code{defun} переопределяет даже примитивные функции, такие как @code{car},
без каких-либо колебаний или уведомления.  Emacs не мешает вам делать это,
потому что переопределение функции иногда делается намеренно, и нет никакого
способа отличить намеренное переопределение от непреднамеренного
переопределения.
@end defmac

@cindex function aliases
@cindex alias, for functions
@defun defalias name definition &optional doc
@anchor{Definition of defalias}
Эта функция определяет символ @var{name} как функцию, с определением
@var{definition} (который может быть любой действительной функцией Lisp).
Возвращаемое значение @emph{неопределенно}.

Если @var{doc} является не-@code{nil}, функции @var{name} устанавливается
документация.  В противном случае, используется документация, представленная
@var{definition}.

@cindex defalias-fset-function property
Внутри @code{defalias} обычно использует @code{fset} для установки
определения.  Однако, если @var{name} имеет свойство
@code{defalias-fset-function}, тогда ассоциированное с этим свойством
значение используется в качестве функции определения вместо @code{fset}.

Правильное место для использования @code{defalias}, то где специфическое имя
функции определяется --- особенно там, где это имя появляется в явном виде в
исходном загружаемом файле.  Это происходит потому, что @code{defalias}
записывает, в каком файле находится определение функции, так же, как и
@code{defun} (@pxref{Unloading}). (ВопросFunctions666)

By contrast, in programs that manipulate function definitions for other
purposes, it is better to use @code{fset}, which does not keep such
records.  @xref{Function Cells}.
@end defun

  Нельзя создать новую примитивную функцию используя @code{defun} или
  @code{defalias}, но можно использовать их, чтобы изменить определение
  функции любого символа, даже таких как @code{car} или @code{x-popup-menu},
  у которых нормальное определение является примитивным.  Тем не менее, это
  рискованно: к примеру, это почти невозможно, чтобы переопределить
  @code{car} без полного разрушения Lisp.  Переопределение неясной функции,
  такой как @code{x-popup-menu} менее опасно, но она все равно может работать
  не так, как ожидалось.  Если есть вызовы примитива из кода C, вызов
  происходит непосредственно, поэтому изменение определения символа не будет
  иметь никакого влияния на это.

  Смотреть также @code{defsubst}, определение функции как и  @code{defun} с
  выводом сообщающений Lisp компилятора при выполнения встроенного
  расширения.  @xref{Inline Functions}.

  Кроме того, можно определить функцию, предоставляя код, который будет
  сделает её встоеной как макрос компилятора.  Следующие макросы делают это
  возможным.

@c Исправте: Можно определить на месте использовать интерактивную
@c спецификацию?
@defmac define-inline name args [doc] [declare] body@dots{}
Определим функцию @var{name}, предоставляя код, который делает её
встраиваемой, как макрос компилятора.  Функция принимает список аргументов
@var{args} и будет иметь указанное тело @var{body}.

Если присутствует, @var{doc} это должно быть строкой документации функции
(@pxref{Function Documentation}); @var{declare}, если присутствует, должно
быть формой @code{declare} (@pxref{Declare Form}) задающей метаданные
функции.
@end defmac

Функции, определенные с помощью @code{define-inline} имеют ряд преимуществ
по сравнению с макросами, определяемой @code{defsubst} или @code{defmacro}:

@itemize @minus
@item
Они могут быть переданы @code{mapcar} (@pxref{Mapping Functions}).

@item
Они более эффективны.

@item
Они могут быть использованы в качестве @dfn{мест формы} для хранения
оценки (@pxref{Generalized Variables}).

@item
Они ведут себя более предсказуемо, чем @code{cl-defsubst}
(@pxref{Argument Lists,,, cl, Common Lisp Extensions for GNU Emacs
Lisp}).
@end itemize

Как функция полученная с использованием @code{defmacro}, так и встраиваемая
функция полученная с использованием  @code{define-inline}, наследует правила
видимости, либо динамическое или лексическое, из контекста вызова.
@xref{Variable Scoping}.

Следующие макросы должны использоваться в теле функции, определенной
@code{define-inline}.

@defmac inline-quote expression
Цитирует @var{expression} для @code{define-inline}. Это похоже на цитирование
(@pxref{Backquote}), но код котировки принимает только @code{,}, а не
@code{,@@}.
@end defmac

@defmac inline-letevals (bindings@dots{}) body@dots{}
Это похоже на @code{let} (@pxref{Local Variables}): устанавливаются локальные
привязки переменных, заданные @var{bindings}, а затем оценивается тело
@var{body} с полученными этими привязками.  Каждый элемент @var{bindings}
должен быть символом или списком вида @w{@code{(@var{var} @var{expr})}};
результат заключается в оценке @var{expr} и привязки @var{var} к результату.
Хвост @var{bindings} может быть @code{nil} или символом, который должен
содержать список аргументов, в этом случае вычисляется каждый аргумент, и
символ связывается с результирующим списком.  (ВопросFunctions747)
@end defmac

@defmac inline-const-p expression
Возврат не-@code{nil} если значение @var{expression} уже известно.
@end defmac

@defmac inline-const-val expression
Возвращает значение @var{expression}.
@end defmac

@defmac inline-error format &rest args
Сигнал ошибки, форматирование @var{args} согласно @var{format}.
@end defmac

Вот пример использования @code{define-inline}:

@lisp
(define-inline myaccessor (obj)
  (inline-letevals (obj)
    (inline-quote (if (foo-p ,obj) (aref (cdr ,obj) 3) (aref ,obj 2)))))
@end lisp

@noindent
Это эквивалентно

@lisp
(defsubst myaccessor (obj)
  (if (foo-p obj) (aref (cdr obj) 3) (aref obj 2)))
@end lisp

@node Calling Functions
@section Calling Functions
@cindex function invocation
@cindex calling a function

  Определение функций только полдела.  Функции ничего не делают, пока их
  @dfn{не вызовут}, то есть, обратятся к ним.  Обращение к функции также
  известно как @dfn{вызов}.

  Наиболее распространенный способ применения функции является оценка списка.
  Например, оценка списка @code{(concat "a" "b")} вызывает функцию
  @code{concat} с аргументами @code{"a"} и @code{"b"}.  @xref{Evaluation},
  для описания оценки.

  Когда вы пишете список как выражение в вашей программе, необходимо указать
  в тексте программы, какую функцию нужно вызвать и с какими аргументами.
  Обычно это именно то, что требуется.  Иногда нужно вычислить уже во время
  выполнения какую функции вызвать.  Чтобы сделать это, используется
  функция @code{funcall}.  Когда также необходимо определить во время
  выполнения, какие аргументы передать, используется @code{apply}.

@defun funcall function &rest arguments
@code{funcall} вызывает функцию @var{function} с аргументами @var{arguments},
и возвращает то, что возвращает функция @var{function}.

Поскольку @code{funcall} функция, все его аргументы, в том числе аргумент
@var{function}, вычисляются до вызова @code{funcall}.  Это означает, что
можно использовать любое выражение, чтобы получить функцию, которая будет
вызвана.  Это также означает, что @code{funcall} не видит выражения
используемые для оценки аргументов @var{arguments}, оперирует уже их
значениями.  Эти значения @emph{не} оценеваются во второй раз в момент
вызова функции @var{function}; работа @code{funcall} подобна обычному
вызова функции, когда её аргументы уже были оценены.

Аргумент @var{function} должен быть функцией Lisp или примитивной функцией.
Специальные формы и макросы не разрешены, потому что они имеют смысл только
тогда, когда заданы неоценённые выражение аргументов.  @code{funcall} не
может обеспечить этого, потому что, как описано выше, не обрабатывает их
перед непосредственным вызовом указанной функции.

Если требуется использовать @code{funcall} для вызова функции как команды и
заставить её вести себя так, как будто вызов происходит в интерактивном
режиме, используется @code{funcall-interactively} (@pxref{Interactive Call}).

@example
@group
(setq f 'list)
     @result{} list
@end group
@group
(funcall f 'x 'y 'z)
     @result{} (x y z)
@end group
@group
(funcall f 'x 'y '(z))
     @result{} (x y (z))
@end group
@group
(funcall 'and t nil)
@error{} Неверная функция: #<subr and>
@end group
@end example

Сравните эти примеры с примерами @code{apply}.
@end defun

@defun apply function &rest arguments
@code{apply} вызывает функцию @var{function} с аргументами @var{arguments},
так же, как и @code{funcall}, но с одним отличием: аргумент @var{arguments}
представляет собой список объектов, который передаётся в @var{function} с
разбором на отдельные аргументы, а не готовым списком аргументов.  Понимается
@code{apply} @dfn{расширяет} этот список, так что каждый отдельный элемент
становится аргументом.

@code{apply} возвращает результат вызова функции @var{function}.  Как и в
случае @code{funcall}, @var{function} должен либо быть функцией Lisp или
примитивной функции; специальные формы и макросы не имеют смысла при
использовании с @code{apply}.

@example
@group
(setq f 'list)
     @result{} list
@end group
@group
(apply f 'x 'y 'z)
@error{} Неправильный тип аргумента: listp, z
@end group
@group
(apply '+ 1 2 '(3 4))
     @result{} 10
@end group
@group
(apply '+ '(1 2 3 4))
     @result{} 10
@end group

@group
(apply 'append '((a b c) nil (x y z) nil))
     @result{} (a b c x y z)
@end group
@end example

Интересный пример использования @code{apply}, смотреть
@ref{Definition of mapcar}.
@end defun

@cindex partial application of functions
@cindex currying
  Иногда бывает полезно, привязать некоторые из аргументов функции к
  определенным значениях, не затрагивая остальные аргументы, когда функция
  на самом деле вызывается.  Акт такой фиксации некоторых из аргументов
  функции называется @dfn{частичным применением} функции@footnote{Это сходно,
  но отличается от @dfn{currying}, которое преобразует функцию, которая
  обрабатывает аргументы по очереди, получая цепочку вызова функции для
  каждого аргумента.}.  Результатом является новая функция, которая принимает
  остальные аргументы и вызывает исходную функцию со всеми аргументами,
  вместе взятыми.

  Вот как сделать частичное применение в Emacs Lisp:

@defun apply-partially func &rest args
Эта функция возвращает новую функцию, которая при вызове будет вызывать
@var{func} со списком аргументов, состоящих из @var{args} и дополнительных
аргументов, указанных в момент вызова.  Если @var{func} принимает @var{n}
аргументов, то вызов @code{apply-partially} с аргументами
@w{@code{@var{m} < @var{n}}} преобразуется в вызов функции с новыми
аргументами @w{@code{@var{n} - @var{m}}}.  (ВопросFunctions905)

Вот как можно было определить встроенную функцию @code{1+}, если её не
не существовало, используя @code{apply-partially} и другой встроенной функции
@code{+}:

@example
@group
(defalias '1+ (apply-partially '+ 1)
  "Приращение еденицы к аргументу.")
@end group
@group
(1+ 10)
     @result{} 11
@end group
@end example
@end defun

@cindex functionals
  Функции Lisp принимающие функции в качестве своих аргументов или
  использующие аргументы находящиеся в структурах данных (особенно в
  переменных-ловушках и списках свойств) обрабатывают их с помощью
  @code{funcall} или @code{apply}.  Функции, которые принимают в аргументах
  функции, часто называют @dfn{функциональными}.

  Иногда, когда требуется получить функционал, полезно указать функцию в
  качестве аргумента без действия.  Вот два разных вида такого вызова
  бездействующей функции:

@defun identity arg
Функция возвращает @var{arg} и не имеет побочных эффектов.
@end defun

@defun ignore &rest args
Функция игнорирует все аргументы и возвращает @code{nil}.
@end defun

  Некоторые функции представляются пользователю как @dfn{команды}, которые
  могут быть вызваны в интерактивном режиме (обычно с помощью
  нажатия последовательности клавиш).  Можно вызвать такую ​​команду в
  точности так, как если бы был её вызов в интерактивном режиме, используя
  функцию @code{call-interactively}.  @xref{Interactive Call}.

@node Mapping Functions
@section Сопоставление Функций
@cindex mapping functions

  @dfn{Сопоставление функции} применяет данную функцию (@emph{не} специальную
  форму или макрос) к каждому элементу списка или другой коллекции.  Emacs
  Lisp имеет несколько таких функций; В данном разделе описаны @code{mapcar},
  @code{mapc}, @code{mapconcat}, и @code{mapcan}, которые сопоставляют
  функцию к списку.  @xref{Definition of mapatoms} для функции
  @code{mapatoms}, сопоставляющая с символами массива obarray.
  @xref{Definition of maphash} для функции @code{maphash}, отображающая
  ключ/значение ассоциаций в хэш-таблице.  (ВопросFunctions959)

  Эти функции сопоставления не позволяют использовать символ-таблицу, так как
  символ-таблица представляет собой разреженный массив, чей номинальный
  диапазон индексов очень велик.  Чтобы отобразить символ-таблицу таким
  способом с должным образом, учитывая её разреженую природу, используется
  функция @code{map-char-table} (@pxref {Char-Tables}).

@defun mapcar function sequence
@anchor{Definition of mapcar}
@code{mapcar} соотносит функцию @var{function} по очереди  к каждому элементу
последовательности @var{sequence} и возвращает список результатов.

Аргумент @var{sequence} может быть любым видом последовательности, кроме
символ-таблицы; то есть представлять список, вектор, булев-вектор или строку.
Результат всегда список.  Длина результата такая же, как длина
последовательности @var{sequence}. Например:

@example
@group
(mapcar 'car '((a b) (c d) (e f)))
     @result{} (a c e)
(mapcar '1+ [1 2 3])
     @result{} (2 3 4)
(mapcar 'string "abc")
     @result{} ("a" "b" "c")
@end group

@group
;; @r{Вызов функции для каждого элемента в @code{my-hooks}.}
(mapcar 'funcall my-hooks)
@end group

@group
(defun mapcar* (function &rest args)
  "Сопоставляет последовательно FUNCTION к каждой предней части аргументов
ARGS. Возвращает список результатов."
  ;; @r{Пока список не будет исчерпан,}
  (if (not (memq nil args))
      ;; @r{применить функцию @sc{car}.}
      (cons (apply function (mapcar 'car args))
            (apply 'mapcar* function
                   ;; @r{Рекурсивный вызов для остальных аргументов.}
                   (mapcar 'cdr args)))))
@end group

@group
(mapcar* 'cons '(a b c) '(1 2 3 4))
     @result{} ((a . 1) (b . 2) (c . 3))
@end group
@end example
@end defun

@defun mapcan function sequence
Функция сопоставляет @var{function} к каждому элементу последовательности
@var{sequence}, как и @code{mapcar}, но вместо того, чтобы собирать
результаты в виде списка, возвращает один список со всеми элементами
результатов (которые должны быть списками), изменяя результаты (с
использованием @code{nconc}; @pxref{Rearrangement}).  Как и у @code{mapcar},
последовательность @var{sequence} может быть любого типа, кроме
символ-таблицы.

@example
@group
;; @r{Сравнить это:}
(mapcar 'list '(a b c d))
     @result{} ((a) (b) (c) (d))
;; @r{с этим:}
(mapcan 'list '(a b c d))
     @result{} (a b c d)
@end group
@end example
@end defun

@defun mapc function sequence
@code{mapc}, как и @code{mapcar} за исключением того, что @var{function}
используется только для побочных эффектов --- возвращаемые значения
игнорируются, не собираются в списке.  @code{mapc} всегда возвращает
последовательность @var{sequence}.
@end defun

@defun mapconcat function sequence separator
@code{mapconcat} сопоставляет функцию @var{function} к каждому элементу
последовательности @var{sequence}; результаты, которые должны быть
последовательностью символов (строки, векторы, или списки), объединяются в
одно строковое значение возврата.  Между каждой парой последовательности в
возвращаемом значении, @code{mapconcat} вставляет символы из @var{separator},
который также должен быть строкой вектором или списком символов.
@xref{Sequences Arrays Vectors}.

Аргумент @var{function} должен быть функцией, которая может принимать один
аргумент и возвращает последовательность символов: строку, вектор или список.
Аргумент @var{sequence} может быть любым видом последовательности, кроме
символ-таблицы; то есть списком, вектором, булевым-вектором или строкой.

@example
@group
(mapconcat 'symbol-name
           '(Кот в шляпе)
           " ")
     @result{} "Кот в шляпе"
@end group

@group
(mapconcat (function (lambda (x) (format "%c" (1+ x))))
           "HAL-8000"
           "")
     @result{} "IBM.9111"
@end group
@end example
@end defun

@node Anonymous Functions
@section Анонимные Функции
@cindex anonymous function

  Хотя функции, как правило, определяются с @code{defun} и получают имена в
  то же время, иногда удобно использовать явное выражение лямбды --- в
  @dfn{анонимной функции}.  Анонимные функции действуют везде, где и
  именованные функции.  Они часто назначается в качестве значений переменных
  или в качестве функций аргументов; например, можно передать анонимную
  функцию в качестве аргумента @var{function} к функции @code{mapcar},
  которая применит эту функцию к каждому элементу списка аргументов
  (@pxref{Mapping Functions}).  @xref{describe-symbols example}, более
  реалистичный пример этого.

  При определении лямбда-выражения, которое будет использоваться в качестве
  анонимной функции, можно в принципе использовать любой метод построения
  списка.  Но, как правило, нужно использовать @code{lambda} макрос или
  специальную форму @code{function}, или же @code{#'} синтакс чтения:

@defmac lambda args [doc] [interactive] body@dots{}
Макрос возвращает анонимную функцию с со списком аргументов @var{args}, со
строкой документации @var{doc} (если таковая предоставляется), с
интерактивной формой @var{interactive} (если таковая предоставляется), и с
формой тела @var{body} с данными.

При динамическом связывании, этот макрос фактически делает форму
@code{lambda} само-цитированой: оценка @sc{car} формы @code{lambda} дает
саму форму:  (ВопросFunctions1098)

@example
(lambda (x) (* x x))
     @result{} (lambda (x) (* x x))
@end example

Следует отметить, что при оценке в соответствии с лексическим правилом
связывания, результатом является объект замыкание (@pxref{Closures}).

Форма @code{lambda} имеет ещё один эффект: она сообщает оценщику и
байт-компилятору Emacs, что ее аргумент является функцией, с помощью
@code{function} в качестве подпрограммы (смотрим ниже).
@end defmac

@defspec function function-object
@cindex function quoting
Специальная форма возвращает @var{function-object} без его оценки.  В этом
есть сходство с @code{quote} (@pxref{Quoting}).  Но в отличие от
@code{quote}, это также служит в качестве примечания к оценщику и
байт-компилятору Emacs, что @var{function-object} предназначен для
использования в качестве функции.  Предполагая, что @var{function-object}
является допустимым лямбда-выражением, получается два эффекта:

@itemize
@item
Когда производиться байт-компиляция @var{function-object}, код компилируется
в байт-компилированный объект функции (@pxref{Byte Compilation}).

@item
Когда действуют правила лексической привязки, @var{function-object}
превращается в замыкание.  @xref{Closures}.
@end itemize
@end defspec

@cindex @samp{#'} syntax
Синтаксис чтения @code{#'} это стенография для использования @code{function}.
Следующие формы эквивалентны:

@example
(lambda (x) (* x x))
(function (lambda (x) (* x x)))
#'(lambda (x) (* x x))
@end example

  В следующем примере определяется функция @code{change-property}, которая
  принимает функцию в качестве третьего аргумента, а затем с помощью функции
  @code{double-property}, позволяет использовать @code{change-property},
  передавая ей анонимную функцию:

@example
@group
(defun change-property (symbol prop function)
  (let ((value (get symbol prop)))
    (put symbol prop (funcall function value))))
@end group

@group
(defun double-property (symbol prop)
  (change-property symbol prop (lambda (x) (* 2 x))))
@end group
@end example

@noindent
Обратите внимание, что мы не цитируем форму @code{lambda}.

  Если скомпилировать код выше, анонимная функция также будет скомпилирована.
  Этого бы не произошло, если, скажем, построить анонимную функцию,
  процитировав её в виде списка:

@c Нет цитате это лямбда!
@example
@group
(defun double-property (symbol prop)
  (change-property symbol prop '(lambda (x) (* 2 x))))
@end group
@end example

@noindent
В этом случае анонимная функция переходит как лямбда-выражения в
скомпилированный код.  Байт-компилятор не сможет принять этот список как
функцию, даже если он выглядит как функция, так как не берётся во внимание
то, что @code{change-property} будет использовать этот код в качестве
функции.

@node Generic Functions
@section Обобщённые Функции
@cindex generic functions
@cindex polymorphism

  Функции, определенные с помощью @code{defun} имеют жестко
  запрограммированный набор предположений о типах и ожидаемых значений своих
  аргументов.  Например, функция, которая была разработана для обработки
  значений своего аргумента, которые может быть числом или списком чисел,
  утратят достоверность или получат сигнал об ошибке при вызове со значением
  любого другого типа, например, в качестве вектора или строки.  Это
  происходит потому, что реализация функции не готова иметь дело с другими
  типами значения аргумента, чем те, которые предполагались при
  проектировании функции.

  Напротив, объектно-ориентированные программы используют
  @dfn{полиморфные функции}: набор специализированных функций, имеющие
  одинаковые имена, каждая из которых написана для определенного конкретного
  набора типов аргументов.  Какая из функций фактически будет вызвана,
  определяется во время выполнения вызова на основе типов фактических
  аргументов.

@cindex CLOS
  Emacs обеспечивает поддержку полиморфизма.  Как и в других средах, в
  частности Lisp диалекта Common Lisp и его Common Lisp Object System
  (@acronym{CLOS}), эта поддержка основана на @dfn{обобщённых функциях}.
  Обобщенные функции Emacs тесно связаны с @acronym{CLOS}, включая
  использование подобных имен, так что если есть опыт работы с
  @acronym{CLOS}, остальная часть этого раздела будет звучать очень знакомо.

  Обобщенная функция определяет абстрактную операцию, определяется её имя и
  список аргументов, но (как правило) без реализации.  Фактическая реализация
  для нескольких конкретных наборов типов аргументов обеспечивается
  @dfn{методами}, которые определяются отдельно.  Каждый метод, который
  реализует обобщённую функцию имеет то же имя, родительская обобщённая
  функция, но определение метода указует, какие аргументы он может
  обрабатывать с помощью @dfn{специализации} своих аргументов, определенных
  обобщенной функцией.  @dfn{Специализация аргумента} может быть более или
  менее конкретной; например, тип @code{строка} более конкретно, чем
  специализация более общего типа, такого, как @code{последовательность}.

  Обратите внимание, что, в отличие от объектно-ориентированных языков
  основанных на сообщениях, таких как C@t{++} и Simula, методы, которые
  реализуют обобщённые функции не принадлежат к самому набору, они
  принадлежат к обобщённой функции, которую они реализуют.

  Когда происходит вызов обобщённой функции, выбираются применимые методы,
  путем сравнения переданных фактических аргументов, специализаторами каждого
  метода.  Метод применяется, если фактические аргументы вызова совместимы с
  специализациями метода.  Если более чем один метод применим, они
  объединяются с помощью определенных правил, описанных ниже, и их комбинация
  затем обрабатывает вызов.

@defmac cl-defgeneric name arguments [documentation] [options-and-methods@dots{}] &rest body
Макрос определяет обобщенную функцию с указанным именем @var{name} и
аргументами @var{arguments}.  Если тело @var{body} присутствует, то оно
обеспечивает реализацию по умолчанию.  Если @var{documentation} присутствует
(оно всегда должно быть), это помещает строку документации для обобщенной
функции, в виде @code{(:documentation @var{docstring})}.  Дополнительно
@var{options-and-methods} можно предоставить в одной из следующих форм:

@table @code
@item (declare @var{declarations})
Форма объявления, как описано в @ref{Declare Form}.
@item (:argument-precedence-order &rest @var{args})
Форма влияет на порядок сортировки при объединении применимых методов.
Обычно, когда два метода сравниваются во время комбинации, аргументы методов
рассматриваются слева направо, и первый метод, чья специализация аргумента
более конкретна, преуспевает перед другим методом.  Порядок установленный
с помощью этой формы переопределяется и аргументы рассматриваются в
соответствии с указанным порядком в этой форме, а не слева направо.
@item (:method [@var{qualifiers}@dots{}] args &rest body)
Эта форма определяет метод, такой как @code{cl-defmethod}.
@end table
@end defmac

@defmac cl-defmethod name [qualifier] arguments &rest [docstring] body
Этот макрос определяет конкретную реализацию обобщённой функции, с именем
@var{name}.  Код реализации задается телом @var{body}.  Если присутствует,
@var{docstring} является строкой документации для метода.  Список
@var{arguments}, должен быть одинаковым во всех методах, которые реализуют
обобщенную функцию, и должен соответствовать списку аргументов этой функции,
аргументы обеспечиваются специализацией вида @code{(@var{arg} @var{spec})},
где @var{arg} это имя аргумента, как указано в вызове @code{cl-defgeneric} и
@var{spec} является одной из следующих форм специализации:

@table @code
@item @var{type}
Специализация требует, чтобы аргумент был заданного типа @var{type}, одним из
типов иерархии типов, описанной ниже.
@item (eql @var{object})
Специализация требует, чтобы аргумент удовлетворял @code{eql} к данному
@var{object}.
@item (head @var{object})
Аргумент должен быть cons-ячейкой @code{car} которой @code{eql} к
@var{object}.
@item @var{struct-type}
Аргумент должен быть экземпляром набора с именем @var{struct-type},
определенного с момощью @code{cl-defstruct}
(@pxref{Structures,,, cl, Common Lisp Extensions for GNU Emacs Lisp}), или
одного из его дочерних наборов.
@end table

В качестве альтернативы, специализация аргумента может иметь вид
@code{&context (@var{expr} @var{spec})}, в этом случае значение @var{expr}
должно быть совместимо с специализацией @var{spec}; @var{spec} может быть
любой из форм, описанных выше.  Другими словами, эта форма специализации
использует значение @var{expr} вместе с аргументом для решения, является ли
метод применимым.  Например, @code{&context (overwrite-mode (eql t))} сделает
метод совместим только тогда, когда @code{overwrite-mode} включен.
(ВопросFunctions1293)

Спецификация типа, @code{(@var{arg} @var{type})}, может указать один из
@dfn{системных типов} в следующем списке.  Если указан родительский тип,
аргумент, тип которого является любым наследником более конкретного типа,
а также наследником наследника и т.д., метод также будет применним.
(ВопросFunctions1299)

@table @code
@item integer
Родительский тип: @code{number}.
@item number
@item null
Родительский тип: @code{symbol}
@item symbol
@item string
Родительский тип: @code{array}.
@item array
Родительский тип: @code{sequence}.
@item cons
Родительский тип: @code{list}.
@item list
Родительский тип: @code{sequence}.
@item marker
@item overlay
@item float
Родительский тип: @code{number}.
@item window-configuration
@item process
@item window
@item subr
@item compiled-function
@item buffer
@item char-table
Родительский тип: @code{array}.
@item bool-vector
Родительский тип: @code{array}.
@item vector
Родительский тип: @code{array}.
@item frame
@item hash-table
@item font-spec
@item font-entity
@item font-object
@end table

Опция @var{qualifier} (спецификатор) позволяет комбинировать несколько
применимых методов.  Если нет, то описываемый метод представляет собой метод
@dfn{primary} (основной), ответственный за предоставление первичной
реализации обобщенной функции для специализированных аргументов.  Можно также
определить @dfn{auxiliary methods} (вспомогательные методы), с помощью одного
из следующих значений в качестве квалификатора @var{qualifier}:

@table @code
@item :before
Вспомогательный метод будет назначаться до основного метода.  Точнее, все
методы @code{:before} будут назначаться до основного, в порядке от наиболее
специфичных.
@item :after
Вспомогательный метод будет назначаться после основного метода.  Точнее, все
такие методы будут работать после основного, в порядке от наиболее
специфичного до последнего.
@item :around
Вспомогательный метод будет работать @emph{вместо} основного метода.
Наиболее специфичный из таких методов будет выполняться перед любым другим
методом.  Такие методы обычно используют @code{cl-call-next-method},
описанных ниже, чтобы ссылаться на другие вспомогательные или основные
методы.
@item :extra @var{string}
Позволяет добавить дополнительные методы, отличающиеся @var{string}, для
одних и тех же специализаций и классификаторов.
@end table

Функции, определенные с помощью @code{cl-defmethod} не могут быть сделаны
интерактивными, то есть @: командами (@pxref{Defining Commands}), путем
добавления формы @code{interactive} к ним.  Если нужна полиморфная команда,
рекомендуется определение нормальной команды, которая вызывает полиморфную
функцию, определенную с помощью @code{cl-defgeneric} и @code{cl-defmethod}.
@end defmac

@cindex dispatch of methods for generic function
@cindex multiple-dispatch methods
Каждый раз, когда вызывается обобщённая функция, строится
@dfn{эффективный метод}, который будет обрабатывать этот вызов путем
комбинирования применимых методов, определенные для функции.  Процесс поиска
применимых методов и получение эффективного метода называют @dfn{dispatch}
(отправкой).  Применимые методы это те, у которых все специализации
совместимы с фактическими аргументами вызова.  Поскольку все аргументы должны
быть совместимы со спецификациями, все они определяют, является ли метод
применимым.  Методы, которые явно специализируют более одного аргумента,
называются @dfn{multiple-dispatch methods} (методы множественной-отправки).

Применимые методы сортируются в порядке, в котором они будут объединены.
Метод, чей левый аргумент наиболее конкретен спкциализации будет первым в
порядке.  (Определение @code{:argument-precedence-order} как часть
@code{cl-defmethod} переопределение этого, как описано выше.) Если тело
метода вызывает @code{cl-call-next-method}, следующий наиболее специфический
метод будет работать.  Если есть применимые методы @code{:around}, наиболее
специфичные из них будут работать в первую очередь; это должно произвести
вызов @code{cl-call-next-method} запускающий любой из менее конкретных
методов @code{:around}.  Далее, методы @code{:before} выполняются в порядке
их специфичности, с последующим первичным методом, и, наконец, методы
@code{:after} в порядке, обратном порядку их специфичности.
(ВопросFunctions1395)

@defun cl-call-next-method &rest args
Когда вызываются из первичного лексического тела или @code{:around}
вспомогательного метода, вызывается следующий метод, применимый для одной и
той же обобщенной функции.  Как правило, она вызывается без аргументов, что
прводит к вызову следующего применимого метода с теми же аргументами, с
которыми метод был вызван.  В противном случае указанные аргументы
используются вместо этого.  (ВопросыFunctions1404)
@end defun

@defun cl-next-method-p
Функция, когда вызывается из первичного лексического тела или @code{:around}
вспомогательного метода, возвращает не-@code{nil}, если существует следующий
метод вызова.
@end defun


@node Function Cells
@section Доступ к Компоненте Символа Ячейки Функции

  @dfn{Определение функции} символа - является объект, хранящийся в
  компоненте символа ячейки функции.  Описанные здесь функции осуществляют
  доступ, тестирование и установку ячейки функции компоненты символа.

  Смотреть также функцию @code{indirect-function}.
  @xref{Definition of indirect-function}.

@defun symbol-function symbol
@kindex void-function
Возвращает объект находящийся в компоненте символа @var{symbol} его ячейки
функции.  Не проверяется, что возвращаемый объект является допустимой
функцией.

Если ячейка функции недействительна, возвращается значение @code{nil}.  Для
того, чтобы различать ячейки функции, которые является недействительными и
установленные в @code{nil}, используется @code{fboundp} (смотри ниже).

@example
@group
(defun bar (n) (+ n 2))
(symbol-function 'bar)
     @result{} (lambda (n) (+ n 2))
@end group
@group
(fset 'baz 'bar)
     @result{} bar
@end group
@group
(symbol-function 'baz)
     @result{} bar
@end group
@end example
@end defun

@cindex void function cell
  Если не присваивалось символу никакого определения функции, то понимается,
  что ячейка функции этого символа является @dfn{void} (недействительна).
  Другими словами, ячейка функции символа не содержит какой-либо объект Lisp.
  Если попытаться вызвать символ как функция, Emacs сигнализирует об ошибке
  @code{void-function} (недействительная-функция).

  Обратите внимание, что недействительное не то же самое, что @code{nil} или
  символ @code{void}.  Символы @code{nil} и @code{void} являются Lisp
  объектами, и могут быть сохранены в ячейки функции так же, как и любые
  другие объекты (и они могут быть действительными функциями, если
  определены как функции в свою очередь, с @code{defun}).  Недействительная
  ячейка функции не содержит объекта вообще.

  Можете проверить недействительность определения функции символа с
  помощью @code{fboundp}.  После того, как символ получил определение
  функции, можно снова сделать его недействительным с помощью
  @code{fmakunbound}.

@defun fboundp symbol
Функция возвращает @code{t} если символ имеет объект в его ячейке функции и
@code{nil} в противном случае.  Не проверяется, что объект является
допустимой функцией.
@end defun

@defun fmakunbound symbol
Функция делает ячейку функции символа @var{symbol} недействительной, так что
последующие попытки получить доступ к этой ячейке будут вызывать ошибку
@code{void-function}.  Возвращает @var{symbol}. (Смотри также
@code{makunbound}, в @ref{Void Variables}.)

@example
@group
(defun foo (x) x)
(foo 1)
     @result{}1
@end group
@group
(fmakunbound 'foo)
     @result{} foo
@end group
@group
(foo 1)
@error{} Symbol's function definition is void (Определение функции символа является недействительным): foo
@end group
@end example
@end defun

@defun fset symbol definition
Функция сохраняет определение @var{definition} в ячейки функции символа
@var{symbol}.  Возвращаемый результате определение @var{definition}.  Обычно
@var{definition} должно быть функцией или именем функции, но это не
проверяется.  Аргумент @var{symbol} обычный оцениваемый аргумент.

Основное применение этой функции в качестве подпрограммы применение
конструкций, которые определяют или изменяют функцию, таких как @code{defun}
или @code{advice-add} (@pxref{Advising Functions}).  Можно также использовать
это, чтобы дать символу определение функции, которая не является функцией,
например, представляет собой клавиатурный макрос (@pxref{Keyboard Macros}):

@example
;; @r{Определение имени макроса клавиатуры.}
(fset 'kill-two-lines "\^u2\^k")
     @result{} "\^u2\^k"
@end example

Вместо использования @code{fset} для получения альтернативного имени для
функции, рассмотрите возможность использования @code{defalias} вместо этого.
@xref{Definition of defalias}.
@end defun

@node Closures
@section Замыкания

  Как пояснялось в разделе @ref{Variable Scoping}, Emacs может дополнительно
  включить лексическое связывание переменных. Когда  действует правило
  лексической привязки, любая именованная функция, которая создаётся
  (например, с @code{defun}), а также любая анонимная функция, которая
  создаётся с использованием @code{lambda} макроса или специальной формы
  @code{function} или с использованием синтаксиса чтения  @code{#'}
  (@pxref{Anonymous Functions}), автоматически превращается в
  @dfn{замыкание}.

@cindex closure
  Замыкание это функция, которая также содержит запись лексической среды,
  которая существовала, когда функция была определена.  Когда она вызывается,
  любые ссылки на лексические переменные в пределах её определения используют
  её нераспределенную лексическую среду.  Во всех других отношениях,
  замыкания ведут себя так же, как и обычные функции; в частности, они могут
  быть вызваны таким же образом, как и обычные функции.

  @xref{Lexical Binding}, для примера использования замыкания.

  В настоящее время объект замыкания Emacs Lisp представляется списком с
  условным обозначением символа @code{closure} в качестве первого элемента,
  списком, представляющим лексическую среду в качестве второго элемента и
  списка аргументов и формы тела, в качестве остальных элементов:

@example
;; @r{Включено правило лексического связывания.}
(lambda (x) (* x x))
     @result{} (closure (t) (x) (* x x))
@end example
        
@noindent
Тем не менее, тот факт, что внутренняя структура замыкания открыта для
воздействия остального мира Lisp, это считается внутренней деталью
реализации.  По этой причине не рекомендуется непосредственно изучение или
изменение структуры объекта замыкания.

@node Advising Functions
@section Рекомендации по Функциям Emacs Lisp
@cindex advising functions
@cindex piece of advice

Если необходимо изменить функцию, определенную в другой библиотеке, или когда
нужно изменить ловушку, такую как @code{@var{foo}-function}, отдельный
процесс, поле объекта или любую переменную, где хранится значение функции,
можно использовать соответствующую функцию установки, например, @code{fset}
или @code{defun} для именованной функции, @code{setq} для переменных-ловушек
или @code{set-process-filter} для отдельных процессов, однако это слишком
грубый способ, полностью выбрасывается предыдущее значение.

  @dfn{advice} функция позволяет добавить к существующему определению
  функции, @dfn{рекомендации к функции}.  Это метод мягче, чем
  переопределение всей функции.

Система советов Emacs предоставляет два набора примитивов для этого:
основной набор, для значений функций, содержащихся в переменных и полях
объектов (соответствующие примитивы @code{add-function} и
@code{remove-function}) и другой набор, базирующийся поверх него для
именованных функций (с основными примитивами @code{advice-add} и
@code{advice-remove} ). (ВопросFunctions1583)

For example, in order to trace the calls to the process filter of a process
@var{proc}, you could use:

@example
(defun my-tracing-function (proc string)
  (message "Proc %S received %S" proc string))

(add-function :before (process-filter @var{proc}) #'my-tracing-function)
@end example

This will cause the process's output to be passed to @code{my-tracing-function}
before being passed to the original process filter.  @code{my-tracing-function}
receives the same arguments as the original function.  When you're done with
it, you can revert to the untraced behavior with:

@example
(remove-function (process-filter @var{proc}) #'my-tracing-function)
@end example

Similarly, if you want to trace the execution of the function named
@code{display-buffer}, you could use:

@example
(defun his-tracing-function (orig-fun &rest args)
  (message "display-buffer called with args %S" args)
  (let ((res (apply orig-fun args)))
    (message "display-buffer returned %S" res)
    res))

(advice-add 'display-buffer :around #'his-tracing-function)
@end example

Here, @code{his-tracing-function} is called instead of the original function
and receives the original function (additionally to that function's arguments)
as argument, so it can call it if and when it needs to.
When you're tired of seeing this output, you can revert to the untraced
behavior with:

@example
(advice-remove 'display-buffer #'his-tracing-function)
@end example

The arguments @code{:before} and @code{:around} used in the above examples
specify how the two functions are composed, since there are many different
ways to do it.  The added function is also called a piece of @emph{advice}.

@menu
* Core Advising Primitives::    Primitives to manipulate advice.
* Advising Named Functions::    Advising named functions.
* Advice combinators::          Ways to compose advice.
* Porting old advice::          Adapting code using the old defadvice.
@end menu

@node Core Advising Primitives
@subsection Primitives to manipulate advices
@cindex advice, add and remove

@defmac add-function where place function &optional props
This macro is the handy way to add the advice @var{function} to the function
stored in @var{place} (@pxref{Generalized Variables}).

@var{where} determines how @var{function} is composed with the
existing function, e.g., whether @var{function} should be called before, or
after the original function.  @xref{Advice combinators}, for the list of
available ways to compose the two functions.

When modifying a variable (whose name will usually end with @code{-function}),
you can choose whether @var{function} is used globally or only in the current
buffer: if @var{place} is just a symbol, then @var{function} is added to the
global value of @var{place}.  Whereas if @var{place} is of the form
@code{(local @var{symbol})}, where @var{symbol} is an expression which returns
the variable name, then @var{function} will only be added in the
current buffer.  Finally, if you want to modify a lexical variable, you will
have to use @code{(var @var{variable})}.

Every function added with @code{add-function} can be accompanied by an
association list of properties @var{props}.  Currently only two of those
properties have a special meaning:

@table @code
@item name
This gives a name to the advice, which @code{remove-function} can use to
identify which function to remove.  Typically used when @var{function} is an
anonymous function.

@item depth
This specifies how to order the advice, should several pieces of
advice be present.  By default, the depth is 0.  A depth of 100
indicates that this piece of advice should be kept as deep as
possible, whereas a depth of @minus{}100 indicates that it should stay as the
outermost piece.  When two pieces of advice specify the same depth,
the most recently added one will be outermost.

For @code{:before} advice, being outermost means that this advice will
be run first, before any other advice, whereas being innermost means
that it will run right before the original function, with no other
advice run between itself and the original function.  Similarly, for
@code{:after} advice innermost means that it will run right after the
original function, with no other advice run in between, whereas
outermost means that it will be run right at the end after all other
advice.  An innermost @code{:override} piece of advice will only
override the original function and other pieces of advice will apply
to it, whereas an outermost @code{:override} piece of advice will
override not only the original function but all other advice applied
to it as well.
@end table

If @var{function} is not interactive, then the combined function will inherit
the interactive spec, if any, of the original function.  Else, the combined
function will be interactive and will use the interactive spec of
@var{function}.  One exception: if the interactive spec of @var{function}
is a function (rather than an expression or a string), then the interactive
spec of the combined function will be a call to that function with as sole
argument the interactive spec of the original function.  To interpret the spec
received as argument, use @code{advice-eval-interactive-spec}.

Note: The interactive spec of @var{function} will apply to the combined
function and should hence obey the calling convention of the combined function
rather than that of @var{function}.  In many cases, it makes no difference
since they are identical, but it does matter for @code{:around},
@code{:filter-args}, and @code{:filter-return}, where @var{function}
receives different arguments than the original function stored in
@var{place}.
@end defmac

@defmac remove-function place function
This macro removes @var{function} from the function stored in
@var{place}.  This only works if @var{function} was added to @var{place}
using @code{add-function}.

@var{function} is compared with functions added to @var{place} using
@code{equal}, to try and make it work also with lambda expressions.  It is
additionally compared also with the @code{name} property of the functions added
to @var{place}, which can be more reliable than comparing lambda expressions
using @code{equal}.
@end defmac

@defun advice-function-member-p advice function-def
Return non-@code{nil} if @var{advice} is already in @var{function-def}.
Like for @code{remove-function} above, instead of @var{advice} being the actual
function, it can also be the @code{name} of the piece of advice.
@end defun

@defun advice-function-mapc f function-def
Call the function @var{f} for every piece of advice that was added to
@var{function-def}.  @var{f} is called with two arguments: the advice function
and its properties.
@end defun

@defun advice-eval-interactive-spec spec
Evaluate the interactive @var{spec} just like an interactive call to a function
with such a spec would, and then return the corresponding list of arguments
that was built.  E.g., @code{(advice-eval-interactive-spec "r\nP")} will
return a list of three elements, containing the boundaries of the region and
the current prefix argument.
@end defun

@node Advising Named Functions
@subsection Advising Named Functions
@cindex advising named functions

A common use of advice is for named functions and macros.
You could just use @code{add-function} as in:

@example
(add-function :around (symbol-function '@var{fun}) #'his-tracing-function)
@end example

  But you should use @code{advice-add} and @code{advice-remove} for that
instead.  This separate set of functions to manipulate pieces of advice applied
to named functions, offers the following extra features compared to
@code{add-function}: they know how to deal with macros and autoloaded
functions, they let @code{describe-function} preserve the original docstring as
well as document the added advice, and they let you add and remove advice
before a function is even defined.

  @code{advice-add} can be useful for altering the behavior of existing calls
to an existing function without having to redefine the whole function.
However, it can be a source of bugs, since existing callers to the function may
assume the old behavior, and work incorrectly when the behavior is changed by
advice.  Advice can also cause confusion in debugging, if the person doing the
debugging does not notice or remember that the function has been modified
by advice.

  For these reasons, advice should be reserved for the cases where you
cannot modify a function's behavior in any other way.  If it is
possible to do the same thing via a hook, that is preferable
(@pxref{Hooks}).  If you simply want to change what a particular key
does, it may be better to write a new command, and remap the old
command's key bindings to the new one (@pxref{Remapping Commands}).
In particular, Emacs's own source files should not put advice on
functions in Emacs.  (There are currently a few exceptions to this
convention, but we aim to correct them.)

  Special forms (@pxref{Special Forms}) cannot be advised, however macros can
be advised, in much the same way as functions.  Of course, this will not affect
code that has already been macro-expanded, so you need to make sure the advice
is installed before the macro is expanded.

  It is possible to advise a primitive (@pxref{What Is a Function}),
but one should typically @emph{not} do so, for two reasons.  Firstly,
some primitives are used by the advice mechanism, and advising them
could cause an infinite recursion.  Secondly, many primitives are
called directly from C, and such calls ignore advice; hence, one ends
up in a confusing situation where some calls (occurring from Lisp
code) obey the advice and other calls (from C code) do not.

@defmac define-advice symbol (where lambda-list &optional name depth) &rest body
This macro defines a piece of advice and adds it to the function named
@var{symbol}.  The advice is an anonymous function if @var{name} is
@code{nil} or a function named @code{symbol@@name}.  See
@code{advice-add} for explanation of other arguments.
@end defmac

@defun advice-add symbol where function &optional props
Add the advice @var{function} to the named function @var{symbol}.
@var{where} and @var{props} have the same meaning as for @code{add-function}
(@pxref{Core Advising Primitives}).
@end defun

@defun advice-remove symbol function
Remove the advice @var{function} from the named function @var{symbol}.
@var{function} can also be the @code{name} of a piece of advice.
@end defun

@defun advice-member-p function symbol
Return non-@code{nil} if the advice @var{function} is already in the named
function @var{symbol}.  @var{function} can also be the @code{name} of
a piece of advice.
@end defun

@defun advice-mapc function symbol
Call @var{function} for every piece of advice that was added to the
named function @var{symbol}.  @var{function} is called with two
arguments: the advice function and its properties.
@end defun

@node Advice combinators
@subsection Ways to compose advice

Here are the different possible values for the @var{where} argument of
@code{add-function} and @code{advice-add}, specifying how the advice
@var{function} and the original function should be composed.

@table @code
@item :before
Call @var{function} before the old function.  Both functions receive the
same arguments, and the return value of the composition is the return value of
the old function.  More specifically, the composition of the two functions
behaves like:
@example
(lambda (&rest r) (apply @var{function} r) (apply @var{oldfun} r))
@end example
@code{(add-function :before @var{funvar} @var{function})} is comparable for
single-function hooks to @code{(add-hook '@var{hookvar} @var{function})} for
normal hooks.

@item :after
Call @var{function} after the old function.  Both functions receive the
same arguments, and the return value of the composition is the return value of
the old function.  More specifically, the composition of the two functions
behaves like:
@example
(lambda (&rest r) (prog1 (apply @var{oldfun} r) (apply @var{function} r)))
@end example
@code{(add-function :after @var{funvar} @var{function})} is comparable for
single-function hooks to @code{(add-hook '@var{hookvar} @var{function}
'append)} for normal hooks.

@item :override
This completely replaces the old function with the new one.  The old function
can of course be recovered if you later call @code{remove-function}.

@item :around
Call @var{function} instead of the old function, but provide the old function
as an extra argument to @var{function}.  This is the most flexible composition.
For example, it lets you call the old function with different arguments, or
many times, or within a let-binding, or you can sometimes delegate the work to
the old function and sometimes override it completely.  More specifically, the
composition of the two functions behaves like:
@example
(lambda (&rest r) (apply @var{function} @var{oldfun} r))
@end example

@item :before-while
Call @var{function} before the old function and don't call the old
function if @var{function} returns @code{nil}.  Both functions receive the
same arguments, and the return value of the composition is the return value of
the old function.  More specifically, the composition of the two functions
behaves like:
@example
(lambda (&rest r) (and (apply @var{function} r) (apply @var{oldfun} r)))
@end example
@code{(add-function :before-while @var{funvar} @var{function})} is comparable
for single-function hooks to @code{(add-hook '@var{hookvar} @var{function})}
when @var{hookvar} is run via @code{run-hook-with-args-until-failure}.

@item :before-until
Call @var{function} before the old function and only call the old function if
@var{function} returns @code{nil}.  More specifically, the composition of the
two functions behaves like:
@example
(lambda (&rest r) (or (apply @var{function} r) (apply @var{oldfun} r)))
@end example
@code{(add-function :before-until @var{funvar} @var{function})} is comparable
for single-function hooks to @code{(add-hook '@var{hookvar} @var{function})}
when @var{hookvar} is run via @code{run-hook-with-args-until-success}.

@item :after-while
Call @var{function} after the old function and only if the old function
returned non-@code{nil}.  Both functions receive the same arguments, and the
return value of the composition is the return value of @var{function}.
More specifically, the composition of the two functions behaves like:
@example
(lambda (&rest r) (and (apply @var{oldfun} r) (apply @var{function} r)))
@end example
@code{(add-function :after-while @var{funvar} @var{function})} is comparable
for single-function hooks to @code{(add-hook '@var{hookvar} @var{function}
'append)} when @var{hookvar} is run via
@code{run-hook-with-args-until-failure}.

@item :after-until
Call @var{function} after the old function and only if the old function
returned @code{nil}.  More specifically, the composition of the two functions
behaves like:
@example
(lambda (&rest r) (or  (apply @var{oldfun} r) (apply @var{function} r)))
@end example
@code{(add-function :after-until @var{funvar} @var{function})} is comparable
for single-function hooks to @code{(add-hook '@var{hookvar} @var{function}
'append)} when @var{hookvar} is run via
@code{run-hook-with-args-until-success}.

@item :filter-args
Call @var{function} first and use the result (which should be a list) as the
new arguments to pass to the old function.  More specifically, the composition
of the two functions behaves like:
@example
(lambda (&rest r) (apply @var{oldfun} (funcall @var{function} r)))
@end example

@item :filter-return
Call the old function first and pass the result to @var{function}.
More specifically, the composition of the two functions behaves like:
@example
(lambda (&rest r) (funcall @var{function} (apply @var{oldfun} r)))
@end example
@end table


@node Porting old advice
@subsection Adapting code using the old defadvice
@cindex old advices, porting
@c NB: The following index entries deliberately avoid ``old'',
@c an adjective that does not come to mind for those who grew up
@c on ‘defadvice’ et al.  For those folks, that way is ``current''.
@c They discover its oldness reading this node.
@cindex advices, porting from @code{defadvice}
@findex defadvice
@findex ad-activate

A lot of code uses the old @code{defadvice} mechanism, which is largely made
obsolete by the new @code{advice-add}, whose implementation and semantics is
significantly simpler.

An old piece of advice such as:

@example
(defadvice previous-line (before next-line-at-end
                                 (&optional arg try-vscroll))
  "Insert an empty line when moving up from the top line."
  (if (and next-line-add-newlines (= arg 1)
           (save-excursion (beginning-of-line) (bobp)))
      (progn
        (beginning-of-line)
        (newline))))
@end example

could be translated in the new advice mechanism into a plain function:

@example
(defun previous-line--next-line-at-end (&optional arg try-vscroll)
  "Insert an empty line when moving up from the top line."
  (if (and next-line-add-newlines (= arg 1)
           (save-excursion (beginning-of-line) (bobp)))
      (progn
        (beginning-of-line)
        (newline))))
@end example

Obviously, this does not actually modify @code{previous-line}.  For that the
old advice needed:
@example
(ad-activate 'previous-line)
@end example
whereas the new advice mechanism needs:
@example
(advice-add 'previous-line :before #'previous-line--next-line-at-end)
@end example

Note that @code{ad-activate} had a global effect: it activated all pieces of
advice enabled for that specified function.  If you wanted to only activate or
deactivate a particular piece, you needed to @emph{enable} or @emph{disable}
it with @code{ad-enable-advice} and @code{ad-disable-advice}.
The new mechanism does away with this distinction.

Around advice such as:

@example
(defadvice foo (around foo-around)
  "Ignore case in `foo'."
  (let ((case-fold-search t))
    ad-do-it))
(ad-activate 'foo)
@end example

could translate into:

@example
(defun foo--foo-around (orig-fun &rest args)
  "Ignore case in `foo'."
  (let ((case-fold-search t))
    (apply orig-fun args)))
(advice-add 'foo :around #'foo--foo-around)
@end example

Regarding the advice's @emph{class}, note that the new @code{:before} is not
quite equivalent to the old @code{before}, because in the old advice you could
modify the function's arguments (e.g., with @code{ad-set-arg}), and that would
affect the argument values seen by the original function, whereas in the new
@code{:before}, modifying an argument via @code{setq} in the advice has no
effect on the arguments seen by the original function.
When porting @code{before} advice which relied on this behavior, you'll need
to turn it into new @code{:around} or @code{:filter-args} advice instead.

Similarly old @code{after} advice could modify the returned value by
changing @code{ad-return-value}, whereas new @code{:after} advice cannot, so
when porting such old @code{after} advice, you'll need to turn it into new
@code{:around} or @code{:filter-return} advice instead.

@node Obsolete Functions
@section Declaring Functions Obsolete
@cindex obsolete functions

  You can mark a named function as @dfn{obsolete}, meaning that it may
be removed at some point in the future.  This causes Emacs to warn
that the function is obsolete whenever it byte-compiles code
containing that function, and whenever it displays the documentation
for that function.  In all other respects, an obsolete function
behaves like any other function.

  The easiest way to mark a function as obsolete is to put a
@code{(declare (obsolete @dots{}))} form in the function's
@code{defun} definition.  @xref{Declare Form}.  Alternatively, you can
use the @code{make-obsolete} function, described below.

  A macro (@pxref{Macros}) can also be marked obsolete with
@code{make-obsolete}; this has the same effects as for a function.  An
alias for a function or macro can also be marked as obsolete; this
makes the alias itself obsolete, not the function or macro which it
resolves to.

@defun make-obsolete obsolete-name current-name &optional when
This function marks @var{obsolete-name} as obsolete.
@var{obsolete-name} should be a symbol naming a function or macro, or
an alias for a function or macro.

If @var{current-name} is a symbol, the warning message says to use
@var{current-name} instead of @var{obsolete-name}.  @var{current-name}
does not need to be an alias for @var{obsolete-name}; it can be a
different function with similar functionality.  @var{current-name} can
also be a string, which serves as the warning message.  The message
should begin in lower case, and end with a period.  It can also be
@code{nil}, in which case the warning message provides no additional
details.

If provided, @var{when} should be a string indicating when the function
was first made obsolete---for example, a date or a release number.
@end defun

@defmac define-obsolete-function-alias obsolete-name current-name &optional when doc
This convenience macro marks the function @var{obsolete-name} obsolete
and also defines it as an alias for the function @var{current-name}.
It is equivalent to the following:

@example
(defalias @var{obsolete-name} @var{current-name} @var{doc})
(make-obsolete @var{obsolete-name} @var{current-name} @var{when})
@end example
@end defmac

In addition, you can mark a particular calling convention for a
function as obsolete:

@defun set-advertised-calling-convention function signature when
This function specifies the argument list @var{signature} as the
correct way to call @var{function}.  This causes the Emacs byte
compiler to issue a warning whenever it comes across an Emacs Lisp
program that calls @var{function} any other way (however, it will
still allow the code to be byte compiled).  @var{when} should be a
string indicating when the variable was first made obsolete (usually a
version number string).

For instance, in old versions of Emacs the @code{sit-for} function
accepted three arguments, like this

@example
  (sit-for seconds milliseconds nodisp)
@end example

However, calling @code{sit-for} this way is considered obsolete
(@pxref{Waiting}).  The old calling convention is deprecated like
this:

@example
(set-advertised-calling-convention
  'sit-for '(seconds &optional nodisp) "22.1")
@end example
@end defun

@node Inline Functions
@section Inline Functions
@cindex inline functions

  An @dfn{inline function} is a function that works just like an
ordinary function, except for one thing: when you byte-compile a call
to the function (@pxref{Byte Compilation}), the function's definition
is expanded into the caller.  To define an inline function, use
@code{defsubst} instead of @code{defun}.

@defmac defsubst name args [doc] [declare] [interactive] body@dots{}
This macro defines an inline function.  Its syntax is exactly the same
as @code{defun} (@pxref{Defining Functions}).
@end defmac

  Making a function inline often makes its function calls run faster.
But it also has disadvantages.  For one thing, it reduces flexibility;
if you change the definition of the function, calls already inlined
still use the old definition until you recompile them.

  Another disadvantage is that making a large function inline can
increase the size of compiled code both in files and in memory.  Since
the speed advantage of inline functions is greatest for small
functions, you generally should not make large functions inline.

  Also, inline functions do not behave well with respect to debugging,
tracing, and advising (@pxref{Advising Functions}).  Since ease of
debugging and the flexibility of redefining functions are important
features of Emacs, you should not make a function inline, even if it's
small, unless its speed is really crucial, and you've timed the code
to verify that using @code{defun} actually has performance problems.

  After an inline function is defined, its inline expansion can be
performed later on in the same file, just like macros.

  It's possible to use @code{defmacro} to define a macro to expand
into the same code that an inline function would execute
(@pxref{Macros}).  But the macro would be limited to direct use in
expressions---a macro cannot be called with @code{apply},
@code{mapcar} and so on.  Also, it takes some work to convert an
ordinary function into a macro.  To convert it into an inline function
is easy; just replace @code{defun} with @code{defsubst}.  Since each
argument of an inline function is evaluated exactly once, you needn't
worry about how many times the body uses the arguments, as you do for
macros.

  As an alternative to @code{defsubst}, you can use
@code{define-inline} to define functions via their exhaustive compiler
macro.  @xref{Defining Functions, define-inline}.

@node Declare Form
@section The @code{declare} Form
@findex declare

  @code{declare} is a special macro which can be used to add meta
properties to a function or macro: for example, marking it as
obsolete, or giving its forms a special @key{TAB} indentation
convention in Emacs Lisp mode.

@anchor{Definition of declare}
@defmac declare specs@dots{}
This macro ignores its arguments and evaluates to @code{nil}; it has
no run-time effect.  However, when a @code{declare} form occurs in the
@var{declare} argument of a @code{defun} or @code{defsubst} function
definition (@pxref{Defining Functions}) or a @code{defmacro} macro
definition (@pxref{Defining Macros}), it appends the properties
specified by @var{specs} to the function or macro.  This work is
specially performed by @code{defun}, @code{defsubst}, and
@code{defmacro}.

Each element in @var{specs} should have the form @code{(@var{property}
@var{args}@dots{})}, which should not be quoted.  These have the
following effects:

@table @code
@item (advertised-calling-convention @var{signature} @var{when})
This acts like a call to @code{set-advertised-calling-convention}
(@pxref{Obsolete Functions}); @var{signature} specifies the correct
argument list for calling the function or macro, and @var{when} should
be a string indicating when the old argument list was first made obsolete.

@item (debug @var{edebug-form-spec})
This is valid for macros only.  When stepping through the macro with
Edebug, use @var{edebug-form-spec}.  @xref{Instrumenting Macro Calls}.

@item (doc-string @var{n})
This is used when defining a function or macro which itself will be used to
define entities like functions, macros, or variables.  It indicates that
the @var{n}th argument, if any, should be considered
as a documentation string.

@item (indent @var{indent-spec})
Indent calls to this function or macro according to @var{indent-spec}.
This is typically used for macros, though it works for functions too.
@xref{Indenting Macros}.

@item (interactive-only @var{value})
Set the function's @code{interactive-only} property to @var{value}.
@xref{The interactive-only property}.

@item (obsolete @var{current-name} @var{when})
Mark the function or macro as obsolete, similar to a call to
@code{make-obsolete} (@pxref{Obsolete Functions}).  @var{current-name}
should be a symbol (in which case the warning message says to use that
instead), a string (specifying the warning message), or @code{nil} (in
which case the warning message gives no extra details).  @var{when}
should be a string indicating when the function or macro was first
made obsolete.

@item (compiler-macro @var{expander})
This can only be used for functions, and tells the compiler to use
@var{expander} as an optimization function.  When encountering a call to the
function, of the form @code{(@var{function} @var{args}@dots{})}, the macro
expander will call @var{expander} with that form as well as with
@var{args}@dots{}, and @var{expander} can either return a new expression to use
instead of the function call, or it can return just the form unchanged,
to indicate that the function call should be left alone.  @var{expander} can
be a symbol, or it can be a form @code{(lambda (@var{arg}) @var{body})} in
which case @var{arg} will hold the original function call expression, and the
(unevaluated) arguments to the function can be accessed using the function's
formal arguments.

@item (gv-expander @var{expander})
Declare @var{expander} to be the function to handle calls to the macro (or
function) as a generalized variable, similarly to @code{gv-define-expander}.
@var{expander} can be a symbol or it can be of the form @code{(lambda
(@var{arg}) @var{body})} in which case that function will additionally have
access to the macro (or function)'s arguments.

@item (gv-setter @var{setter})
Declare @var{setter} to be the function to handle calls to the macro (or
function) as a generalized variable.  @var{setter} can be a symbol in which
case it will be passed to @code{gv-define-simple-setter}, or it can be of the
form @code{(lambda (@var{arg}) @var{body})} in which case that function will
additionally have access to the macro (or function)'s arguments and it will
passed to @code{gv-define-setter}.

@end table

@end defmac

@node Declaring Functions
@section Telling the Compiler that a Function is Defined
@cindex function declaration
@cindex declaring functions
@findex declare-function

Byte-compiling a file often produces warnings about functions that the
compiler doesn't know about (@pxref{Compiler Errors}).  Sometimes this
indicates a real problem, but usually the functions in question are
defined in other files which would be loaded if that code is run.  For
example, byte-compiling @file{simple.el} used to warn:

@example
simple.el:8727:1:Warning: the function ‘shell-mode’ is not known to be
    defined.
@end example

In fact, @code{shell-mode} is used only in a function that executes
@code{(require 'shell)} before calling @code{shell-mode}, so
@code{shell-mode} will be defined properly at run-time.  When you know
that such a warning does not indicate a real problem, it is good to
suppress the warning.  That makes new warnings which might mean real
problems more visible.  You do that with @code{declare-function}.

All you need to do is add a @code{declare-function} statement before the
first use of the function in question:

@example
(declare-function shell-mode "shell" ())
@end example

This says that @code{shell-mode} is defined in @file{shell.el} (the
@samp{.el} can be omitted).  The compiler takes for granted that that file
really defines the function, and does not check.

  The optional third argument specifies the argument list of
@code{shell-mode}.  In this case, it takes no arguments
(@code{nil} is different from not specifying a value).  In other
cases, this might be something like @code{(file &optional overwrite)}.
You don't have to specify the argument list, but if you do the
byte compiler can check that the calls match the declaration.

@defmac declare-function function file &optional arglist fileonly
Tell the byte compiler to assume that @var{function} is defined in the
file @var{file}.  The optional third argument @var{arglist} is either
@code{t}, meaning the argument list is unspecified, or a list of
formal parameters in the same style as @code{defun}.  An omitted
@var{arglist} defaults to @code{t}, not @code{nil}; this is atypical
behavior for omitted arguments, and it means that to supply a fourth
but not third argument one must specify @code{t} for the third-argument
placeholder instead of the usual @code{nil}.  The optional fourth
argument @var{fileonly} non-@code{nil} means check only that
@var{file} exists, not that it actually defines @var{function}.
@end defmac

  To verify that these functions really are declared where
@code{declare-function} says they are, use @code{check-declare-file}
to check all @code{declare-function} calls in one source file, or use
@code{check-declare-directory} check all the files in and under a
certain directory.

  These commands find the file that ought to contain a function's
definition using @code{locate-library}; if that finds no file, they
expand the definition file name relative to the directory of the file
that contains the @code{declare-function} call.

  You can also say that a function is a primitive by specifying a file
name ending in @samp{.c} or @samp{.m}.  This is useful only when you
call a primitive that is defined only on certain systems.  Most
primitives are always defined, so they will never give you a warning.

  Sometimes a file will optionally use functions from an external package.
If you prefix the filename in the @code{declare-function} statement with
@samp{ext:}, then it will be checked if it is found, otherwise skipped
without error.

  There are some function definitions that @samp{check-declare} does not
understand (e.g., @code{defstruct} and some other macros).  In such cases,
you can pass a non-@code{nil} @var{fileonly} argument to
@code{declare-function}, meaning to only check that the file exists, not
that it actually defines the function.  Note that to do this without
having to specify an argument list, you should set the @var{arglist}
argument to @code{t} (because @code{nil} means an empty argument list, as
opposed to an unspecified one).

@node Function Safety
@section Determining whether a Function is Safe to Call
@cindex function safety
@cindex safety of functions

Some major modes, such as SES, call functions that are stored in user
files.  (@inforef{Top, ,ses}, for more information on SES@.)  User
files sometimes have poor pedigrees---you can get a spreadsheet from
someone you've just met, or you can get one through email from someone
you've never met.  So it is risky to call a function whose source code
is stored in a user file until you have determined that it is safe.

@defun unsafep form &optional unsafep-vars
Returns @code{nil} if @var{form} is a @dfn{safe} Lisp expression, or
returns a list that describes why it might be unsafe.  The argument
@var{unsafep-vars} is a list of symbols known to have temporary
bindings at this point; it is mainly used for internal recursive
calls.  The current buffer is an implicit argument, which provides a
list of buffer-local bindings.
@end defun

Being quick and simple, @code{unsafep} does a very light analysis and
rejects many Lisp expressions that are actually safe.  There are no
known cases where @code{unsafep} returns @code{nil} for an unsafe
expression.  However, a safe Lisp expression can return a string
with a @code{display} property, containing an associated Lisp
expression to be executed after the string is inserted into a buffer.
This associated expression can be a virus.  In order to be safe, you
must delete properties from all strings calculated by user code before
inserting them into buffers.

@ignore
What is a safe Lisp expression?  Basically, it's an expression that
calls only built-in functions with no side effects (or only innocuous
ones).  Innocuous side effects include displaying messages and
altering non-risky buffer-local variables (but not global variables).

@table @dfn
@item Safe expression
@itemize
@item
An atom or quoted thing.
@item
A call to a safe function (see below), if all its arguments are
safe expressions.
@item
One of the special forms @code{and}, @code{catch}, @code{cond},
@code{if}, @code{or}, @code{prog1}, @code{prog2}, @code{progn},
@code{while}, and @code{unwind-protect}], if all its arguments are
safe.
@item
A form that creates temporary bindings (@code{condition-case},
@code{dolist}, @code{dotimes}, @code{lambda}, @code{let}, or
@code{let*}), if all args are safe and the symbols to be bound are not
explicitly risky (@pxref{File Local Variables}).
@item
An assignment using @code{add-to-list}, @code{setq}, @code{push}, or
@code{pop}, if all args are safe and the symbols to be assigned are
not explicitly risky and they already have temporary or buffer-local
bindings.
@item
One of [apply, mapc, mapcar, mapconcat] if the first argument is a
safe explicit lambda and the other args are safe expressions.
@end itemize

@item Safe function
@itemize
@item
A lambda containing safe expressions.
@item
A symbol on the list @code{safe-functions}, so the user says it's safe.
@item
A symbol with a non-@code{nil} @code{side-effect-free} property.
@item
A symbol with a non-@code{nil} @code{safe-function} property.  The
value @code{t} indicates a function that is safe but has innocuous
side effects.  Other values will someday indicate functions with
classes of side effects that are not always safe.
@end itemize

The @code{side-effect-free} and @code{safe-function} properties are
provided for built-in functions and for low-level functions and macros
defined in @file{subr.el}.  You can assign these properties for the
functions you write.
@end table
@end ignore

@node Related Topics
@section Other Topics Related to Functions

  Here is a table of several functions that do things related to
function calling and function definitions.  They are documented
elsewhere, but we provide cross references here.

@table @code
@item apply
See @ref{Calling Functions}.

@item autoload
See @ref{Autoload}.

@item call-interactively
See @ref{Interactive Call}.

@item called-interactively-p
See @ref{Distinguish Interactive}.

@item commandp
See @ref{Interactive Call}.

@item documentation
See @ref{Accessing Documentation}.

@item eval
See @ref{Eval}.

@item funcall
See @ref{Calling Functions}.

@item function
See @ref{Anonymous Functions}.

@item ignore
See @ref{Calling Functions}.

@item indirect-function
See @ref{Function Indirection}.

@item interactive
See @ref{Using Interactive}.

@item interactive-p
See @ref{Distinguish Interactive}.

@item mapatoms
See @ref{Creating Symbols}.

@item mapcar
See @ref{Mapping Functions}.

@item map-char-table
See @ref{Char-Tables}.

@item mapconcat
See @ref{Mapping Functions}.

@item undefined
See @ref{Functions for Key Lookup}.
@end table
