@c -*- mode: texinfo; coding: utf-8 -*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2019 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Functions
@chapter Функции

  Программа Lisp состоит в основном из Lisp функций. В этой главе
  описывается, что такое функции, как они принимают аргументы, и как
  определить их.

@menu
* What Is a Function::          Lisp функции, сравнение с примитивами; терминология.
* Lambda Expressions::          Выражение функции как объект Lisp.
* Function Names::              Символ может служить именем функции.
* Defining Functions::          Lisp выражение для определения функции.
* Calling Functions::           Как использовать существующую функцию.
* Mapping Functions::           Применение функции к каждому элементу списка и т.д.
* Anonymous Functions::         Lambda выражение функции без какого-либо имени.
* Generic Functions::           Полиморфизм, в Emacs-стиле.
* Function Cells::              Доступ к настройке или определение функции символа.
* Closures::                    Функции, использующие лексическую среду.
* Advising Functions::          Дополнение к определению функции.
* Obsolete Functions::          Объявление функции как устаревшей.
* Inline Functions::            Встроенные Функции, которые расширяет компилятор.(ВопросFunction26)
* Declare Form::                Добавление дополнительной информации о функции.
* Declaring Functions::         Собщение компилятору, что функция определена.(ВопросFunction28)
* Function Safety::             Определение, является ли функция безопасна для вызова.
* Related Topics::              Перекрестные ссылки на конкретные Lisp примитивы,
                                которые имеют особое отношение к работе функций.
@end menu

@node What Is a Function
@section Что Такое Функция?

@cindex return value
@cindex value of function
@cindex argument
@cindex pure function
  В общем смысле, функция является правилом для проведения вычислений
  заданных входных значений, называемых @dfn{аргументами}.  Результат таких
  вычислений называется @dfn{значением} или @dfn{возвращаемым значением}
  функции.  Вычисление может также иметь побочные эффекты, такие как
  сохранение изменённого значения в переменных или содержимого структур
  данных (@pxref{Definition of side effect}).  @dfn{Чистая функция} является
  такой функцией, которая, в дополнение к тому, что не имеет каких-либо
  побочных эффектов, всегда возвращает то же значение для одной и той же
  комбинации аргументов, независимо от внешних факторов, таких как тип машины
  или состояния системы.

  В большинстве языков программирования, каждая функция имеет имя. Но в Lisp,
  функция в строгом смысле этого слова не имеет имени: это объект, который
  может быть связан @emph{по желанию} с символом (например, @code{car}),
  который служит в качестве имени функции.  @xref{Function Names}. Когда
  функция была связана с именем, помещён объект функции в компоненту ячейки
  функции символа, обычно относятся к этому символу, как к ``функции''
  (например, имеется в виду ``функция @code{car}'').  В этом руководстве,
  различие между именем символа, содержащего в своей компоненте функции
  объект функции и самой функции как объекта, как правило, неважно, но будет
  приниматься во внимание, где это уместно.

  Некоторые объекты, подобные функциям и называемые @dfn{специальные формы} и
  @dfn{макросы}, а также принимают аргументы для выполнения вычислений.
  Однако, как объяснено ниже, они не рассматриваются как функции Emacs Lisp.

  Вот важные условия для функций и объектов подобных функциям:

@table @dfn
@item lambda expression
Функция (в строгом смысле этого слова, то есть, функциональный объект),
написанная на языке Lisp.  Это описано в следующем разделе.
@ifnottex
@xref{Lambda Expressions}.
@end ifnottex

@item primitive
@cindex primitive
@cindex subr
@cindex built-in function
Функция, которая вызывается из Lisp, но на самом деле написана на C@.
Примитивы также называют @dfn{встроенными функциями}, или @dfn{subrs}.
Примеры включают в себя функции, такие как @code{car} и @code{append}. Кроме
того, все специальные формы (смотри ниже), также считаются примитивами.
(ВопросFunction84)

Как правило, функция реализуется как примитив, поскольку она является
основной частью Lisp (например, @code{car}), или потому, что она обеспечивает
интерфейс низкого уровня для работающих системных служб, или потому, что она
должна работать быстро.  В отличие от функций, определенных в Lisp, примитивы
могут быть изменены или добавлены только путем изменения источников С и
перекомпилированием Emacs.  Смотреть @ref{Writing Emacs Primitives}.

@item special form
Примитив, который подобен функции, но не оценивает все свои аргументы обычным
образом.  Он может оценить только некоторые из аргументов, или может оценить
их в необычном порядке, или по нескольку раз.  Примеры таких специальных
форм это формы @code{if}, @code{and} и @code{while}.
@xref{Special Forms}.

@item macro
@cindex macro
Конструкция определённая в Lisp, которая отличается от функции тем, что
преобразует одно выражение Lisp в другое выражение, которое должно быть
оценено вместо исходного выражения.  Макросы позволяют Lisp программистам
делать разные вещи, как те, что специальные формы сделать не могут.
@xref{Macros}.

@item command
@cindex command
Объект, который может быть вызван посредствам примитива
@code{command-execute}, как правило, из-за ввода пользователем
последовательности клавиш, @dfn{привязаной ключевой последовательности} к
этой команде.  @xref{Interactive Call}.  Команда, как правило, является
функцией; если функция написана на Lisp, она превращается в команду с помощью
специальной формы @code{interactive} при определении функции
(@pxref{Defining Commands}).  Команды, которые являются функциями, также
могут быть вызваны из Lisp выражений, так же как и другие функции.

Клавиатурные макросы (строки и векторы) также являются командами, хотя они не
являются функциями.  @xref{Keyboard Macros}.  Имеется в виду, при выражении,
символ является командой, это когда компонента символа ячека функции,
содержит команду (@pxref{Symbol Components}); такая @dfn{именованная команда}
может быть вызвана с помощью @kbd{M-x}.

@item closure
Объект функции, такой же, как лямбда-выражения, за исключением того, что
также охватывает лексическую среду привязки переменных.
@xref{Closures}.

@item byte-code function
Функция, которая была скомпилирована ​​байтовым компилятором.
@xref{Byte-Code Type}.

@item autoload object
@cindex autoload object
Место кода определения для реальной функции.  Если объект автозагрузка
вызывается, Emacs загружает файл, содержащий определение реальной функции, а
затем вызывает реальную функцию.  @xref{Autoload}.  (ВопросFunctions138)
@end table

  Вы можете использовать функцию @code{functionp} для прверки, является ли
  объект объектом функции:

@defun functionp object
Функция возвращает @code{t}, если @var{object} является любым видом функции,
то есть, может быть передан в @code{funcall}.  Обратите внимание, что
@code{functionp} возвращает @code{t} для символов, которые являются именами
функций и возвращает @code{nil} для специальных форм.
@end defun

  Также можно узнать, сколько аргументов ожидает функция:

@defun func-arity function
Функция предоставляет информацию о списке аргументов для указанной аргументом
@var{function} функции.  Возвращаемое значением является либо форма
cons-ячейки вида @w{@code{(@var{min} . @var{max})}}, где @var{min} является
минимальным, а @var{max} максимальным количеством аргументов, либо
символ @code{many} для функций использующих @code{&rest} аргументы, и
символ @code{unevalled}, если @var{function} является специальной формой.

Обратите внимание, что эта функция может возвращать неточные результаты в
некоторых ситуациях, таких как следующие:

@itemize @minus
@item
Функции определённые с помощью @code{apply-partially}
(@pxref{Calling Functions, apply-partially}).

@item
Функции, с которыми рекомендуется использовать @code{advice-add}
(@pxref{Advising Named Functions}). (ВопросFunctions171)

@item
Функции, которые определяют список аргументов динамически, как часть своего
кода.
@end itemize

@end defun

@noindent
В отличие от @code{functionp}, следующие три функции @emph{не} рассматривают
символ в качестве определения функции.

@defun subrp object
Функция возвращает @code{t}, если @var{object} является встроенной функцией
(т.е. Lisp примитивом).

@example
@group
(subrp 'message)            ; @r{символ @code{message}, не является}
     @result{} nil                 ;   @r{объектом встроенной функции (subr)}
@end group
@group
(subrp (symbol-function 'message))
     @result{} t
@end group
@end example
@end defun

@defun byte-code-function-p object
Функция возвращает @code{t} если @var{object} байт-компилированная функция.
Например:

@example
@group
(byte-code-function-p (symbol-function 'next-line))
     @result{} t
@end group
@end example
@end defun

@defun subr-arity subr
Это работает как @code{func-arity}, но только для встроенных функций и без
косвенной ссылки на символ функции.  Сигнализирует об ошибке для не
встроенных функций.  Рекомендуем использовать @code{func-arity} вместо этой.
@end defun

@node Lambda Expressions
@section Lambda Выражения
@cindex lambda expression

  Лямбда-выражение является объектом функции написанной на Lisp. Вот пример:

@example
(lambda (x)
  "Возвращает гиперболический косинус X."
  (* 0.5 (+ (exp x) (exp (- x)))))
@end example

@noindent
В Emacs Lisp, такой список является действительным выражением, которое
вычисляется в объект функции.

  Лямбда-выражения, само по себе, не имеет имени; это
  @dfn{анонимная функция}.  Хотя лямбда-выражения можно использовать таким
  способом (@pxref{Anonymous Functions}), они чаще связаны с символами, чтобы
  получить @dfn{именованную функцию} (@pxref{Function Names}). Прежде, чем
  погрузится в детали, следующие подразделы описывают компоненты
  лямбда-выражения и то, что они делают.

@menu
* Lambda Components::           Компоненты лямбда-выражения.
* Simple Lambda::               Простой пример.
* Argument List::               Детали и особенности списков аргументов.
* Function Documentation::      Как разместить документацию о функции.
@end menu

@node Lambda Components
@subsection Компоненты Лямбда-Выражения

  Лямбда-выражение - это список, который выглядит следующим образом:

@example
(lambda (@var{arg-variables}@dots{})
  [@var{documentation-string}]
  [@var{interactive-declaration}]
  @var{body-forms}@dots{})
@end example

@cindex lambda list
  Первый элемент лямбда-выражения всегда является символом @code{lambda}.
  Это указывает на то, что список представляет собой функцию.  Причина
  такого определения, использование первым элементом списка символ
  @code{lambda}, кроется в том, чтобы другие списки, предназначенные для
  использования в других целях, случайно не определялись в качестве функции.

  Второй элемент этого списка, представляет собой список символов --- имен
  переменных аргументов.  Это называется @dfn{лямбда-списком}.  Когда функция
  Lisp вызывается, значения аргументов сопостовляются с переменными
  @dfn{лямбда-списка}, которые получают локальные привязки предоставляемых
  значений. @xref{Local Variables}.

  Строка документации, предстовляет собой строковый объект Lisp, помещённый в
  определение функции и используется средствами помощи Emacs для описания
  функции.  @xref{Function Documentation}.

  Объявление интерактивности представляет собой список вида
  @code{(interactive @var{code-string})}. Это определяет, как обеспечить
  аргументами функцию, если вызов происходит в интерактивном режиме.  Функции
  с таким определением называются @dfn{командами}; могут быть вызваны с
  как с помощью сочетания нажатия клавиш @kbd{M-x} и набора привязанного
  ключа.  Функции не предназначены для вызова таким образом, не должен иметь
  интерактивного определения.  @xref{Defining Commands}, о том, как создать
  интерактивное заявление.

@cindex body of function
  Остальные элементы являются @dfn{телом} функции: Lisp-код, выполняет
  работу функции (или, как Lisp программист сказал бы, ``список Lisp форм
  для оценки'').  Значение, возвращаемое функцией является значением,
  возвращаемое последней оценённой формы этого тела.

@node Simple Lambda
@subsection Простой Пример Лямбда-Выражения

  Рассмотрим следующий пример:

@example
(lambda (a b c) (+ a b c))
@end example

@noindent
Мы можем вызвать эту функцию, передавая ее форме @code{funcall}, как здесь:

@example
@group
(funcall (lambda (a b c) (+ a b c))
         1 2 3)
@end group
@end example

@noindent
Этот вызов вычисляет тело лямбды-выражения связывая переменную @code{a} с 1,
@code{b} связывая с 2 и @code{c} связывая с 3.  Оценка тела формы складывает
эти три числа, производя результат 6; поэтому, этот вызов функции возвращает
значение 6.  Обратите внимание, что аргументы могут быть результатами других
вызовов функций, как в этом примере:

@example
@group
(funcall (lambda (a b c) (+ a b c))
         1 (* 2 3) (- 5 4))
@end group
@end example

@noindent
Вначале оцениваются аргументы @code{1}, @code{(* 2 3)}, и @code{(- 5 4)}
слева направо.  Затем их применяет лямбда-выражение со значениями аргументов
1, 6 и 1, в итоге получая значение 8.

  Как показывают эти примеры, вы можете использовать форму с
  лямбда-выражением в качестве её @sc{car}, а остальными элементами передать
  значения для переменных лямбда формы, тем самым получить локальные привязки
  переменных полученной формы.  В прежние времена Lisp, этот метод был
  единственный способ связать и инициализировать локальные переменные.  Но в
  наше время, это понятнее использовать специальную форму @code{let} для
  этого (@pxref{Local Variables}).  Лямбда-выражения в основном используются
  в качестве анонимных функций для передачи в качестве аргументов другим
  функциям (@pxref{Anonymous Functions}), или для хранения в виде определений
  в компоненте символа его ячейки функции для получения именованной функции
  (@pxref{Function Names}).

@node Argument List
@subsection Другие Особенности Списка Аргументов
@kindex wrong-number-of-arguments
@cindex argument binding
@cindex binding arguments
@cindex argument lists, features

  Простой пример, функция @code{(lambda (a b c) (+ a b c))}, определяет
  три аргумента, поэтому вызов производится с тремя аргументами: если
  попытаться передать в функцию два (и менее) или четыре (и более) аргумента,
  получиться ошибка @code{wrong-number-of-arguments} (@pxref{Errors}).

  Часто бывает удобно написать функцию, которая позволяет опускать некоторые
  аргументы.  Например, функция @code{substring} принимает три аргумента ---
  строку, индекс начала и индекс конца --- но третий аргумент привязывается
  к @var{длинне} строки по умолчанию, если он опущен.  Также удобно для
  некоторых функций принимать неопределенное количество аргументов, такие как
  функции @code{list} и @code{+}.

@cindex optional arguments
@cindex rest arguments
@kindex &optional
@kindex &rest
  Чтобы задать необязательные аргументы, которые могут быть опущены при
  вызове функции, включается ключевое слово @code{&optional} перед
  необязательными аргументами.  Чтобы указать список из нуля или более
  необязательных  аргументов, включается ключевое слово @code{&rest} до
  одного последнего аргумента списка аргументов.

  Таким образом, полный синтаксис списка аргументов выглядит следующим
  образом:

@example
@group
(@var{обязательные-переменные}@dots{}
 @r{[}&optional @var{опциональные-переменные}@dots{}@r{]}
 @r{[}&rest @var{дополнительные-переменные}@r{]})
@end group
@end example

@noindent
То что помещается в квадратные скобки, здесь @code{&optional} и @code{&rest},
а также переменные, которые заключены в них, не являются обязательными.

  Вызову функции требуется один фактический аргумент для каждого из
  @var{обязательные-переменные}.  Далее могут быть указаны ноль или более
  до определённого количества аргументов @var{опциональные-переменные}, и в
  конце после ключевого слова @code{&rest} может быть передано любое
  количество фактических аргументов @var{дополнительные-переменные}.
  (ВопросFunctions391)

  Если фактические аргументы для опцинальных и дополнительных переменных
  опущены, то они всегда привязываются по умолчанию к @code{nil}.  Нет
  никакого способа для функции различать явный аргумент @code{nil} и
  опущенный фактический аргумент.  Тем не менее, в теле функции свободно
  использовать аббревиатуру @code{nil} для какого-либо другого значимого
  значения.  Это то, что делает @code{substring}; @code{nil} в качестве
  третьего аргумента @code{substring} означает использовать всю длину
  предоставляемой строки.

@cindex CL note---default optional arg
@quotation
@b{Common Lisp замечание:} Common Lisp позволяет функции указать,
значение по умолчанию для необязательного аргумента если тот опущен;
Emacs Lisp всегда использует @code{nil}.  Emacs Lisp не поддерживает
@code{supplied-p} переменные, которые определяют, был ли явно предоставлен
аргумент.
@end quotation

  Например, список аргументов, который выглядит следующим образом:

@example
(a b &optional c d &rest e)
@end example

@noindent
связывает @code{a} и @code{b} с первыми двумя обязательными аргументами.
Если далее предоставлены один или два аргумента, @code{c} и @code{d}
связываются с ними соответственно; любые аргументы после первых четырех
собираются в список и @code{e} и привязывается к этому списку.  Таким
образом, если передано только два аргумента, @code{c}, @code{d} и @code{e}
устанавливаются в @code{nil}; если три аргумента, @code{d} и @code{e}
устанавливаются в @code{nil}; если не более четырёх аргументов, @code{e}
устанавливается в @code{nil}.  Обратите внимание, что ровно пять переданных
аргумента с явным @code{nil} в качестве пятого аргумента, приводит к тому,
что список @code{e} будет список с одним элементом @code{(nil)}, как с любым
другим одним значением для @code{e}.

  Нет никакого способа, чтобы указать фактические аргументы следующими за
  опущенными --- это не будет иметь смысла.  Чтобы понять, почему это так,
  предположим, что @code{c} в примере выше, является не обязательным а
  @code{d} обязательным.  Предположим, что функции передано три фактические
  аргумента; какая переменная будет связана с третим аргументом?  Будет ли
  она использована для @var{c}, или для @var{d}?  Можно утверждать оба
  случая.  Кроме того, также не имеет никакого смысла, использовать таким
  образом (либо обязательные либо необязательные) аргументы после ключевого
  слова @code{&rest}. (ВопросFunctions438)

  Вот некоторые примеры списков аргументов и соответствующих вызовов:

@example
(funcall (lambda (n) (1+ n))        ; @r{Один обязательный:}
         1)                         ; @r{передаётся только один аргумент.}
     @result{} 2
(funcall (lambda (n &optional n1); @r{Один обязательный и один опциональный:}
           (if n1 (+ n n1) (1+ n))) ; @r{1 или 2 аргумента.}
         1 2)
     @result{} 3
(funcall (lambda (n &rest ns); @r{Один обязательный и один дополнительный:}
           (+ n (apply '+ ns)))     ; @r{1 или более аргументов.}
         1 2 3 4 5)
     @result{} 15
@end example

@node Function Documentation
@subsection Строка Документации Функции
@cindex documentation of function

  Лямбда-выражение может иметь необязательную @dfn{строку документации} сразу
  после лямбда-списка.  Эта строка не влияет на выполнение функции; это
  своего рода комментарий, но систематизированый, который на самом деле
  имеет своё место в Lisp и может использоваться в справочных средствах
  Emacs.  @xref{Documentation}, для того, как получить доступ к строке
  документации.

  Это идея хорошая, чтобы обеспечить строкой документации все функции в вашей
  программе, даже те, которые вызываются только из вашей программы. Строка
  документации, похожа на комментарий, за исключением того, что к ней легче
  получить доступ.

  Первая строка документации должна быть самостоятельной и до конца
  осмысленной, потому что  @code{apropos} отображает только эту первую сроку.
  Лучше чтобы составлена была одного или двух полных предложений, которые
  описывают предназначение функции.

  Начало строки документации, как правило, пишется с отступом в исходном
  файле, но так как этот отступ приходится до начальной двойной кавычки,
  то не включается в содержание этой строки.  Некоторые делают отступ
  также для остальных дополнительных строки документации, чтобы выровнять
  текст в исходном тексте программы.  @emph{Это ошибка.}  Отступ на следующих
  строках находится внутри содержимого строки и выглядит красиво в исходном
  коде, но будет выглядеть некрасиво, при отображении командой справки.

  Можно задаться вопросом, как строка документации может быть необязательной,
  так как обязательные компоненты тела функции следуют за ней.  Поскольку
  оценка строки возвращает туже строку, без каких-либо побочных эффектов, это
  не имеет никакого эффекта, если это не последняя форма в теле.  Таким
  образом, на практике не существует путаницы между первой формой тела и
  строки документации; если форма тела является строкой, то она служит и в
  качестве возвращаемого значения и в качестве документации.

  В последней строке документации можно указать соглашения о вызовах,
  использующих различное количество фактических аргументов функции.  Пишется
  это так:

@example
\(fn @var{arglist})
@end example

@noindent
после пустой строки, в начале строки, без следующего символа перевода строки
строк документации.  (@samp{\} используется, чтобы избежать путаницы для
команд перемещения Emacs.).  Если придерживаться этого соглашение о вызовах,
в справочных сообщениях вместо обычного списка параметров, подставиться
список определённых в этой строке фактических аргументов функции.

  Эта функция особенно полезна для определения макросов, так как аргументы,
  написанные в определении макроса часто не соответствуют тому, что они
  собой представляют прибеглом взгляде программиста.

  Не нужно использовать эту функцию, если не придерживатся выше описанного
  соглашения.  Вместо этого используйте @code{advertised-calling-convention}
  объявление (@pxref{Declare Form}) или
  @code{set-advertised-calling-convention} (@pxref{Obsolete Functions}),
  потому что эти два способа заставят байт-компилятор выдавать предупреждение
  при компиляции Lisp программ, которые используют устаревшее соглашение
  строки документации о вызовах.

@node Function Names
@section Именование Функций
@cindex function definition
@cindex named function
@cindex function name

  Символ может служить в качестве имени функции.  Это происходит,
  когда компонента символа @dfn{ячейка функции} (@pxref{Symbol Components})
  содержит функциональный объект (например, лямбда-выражение).  Тогда сам
  символ становится действительным при использовании его как функции и его
  такой вызов эквивалентен вызову напрямую выражения, помещённого в его
  компоненте ячейки функции.

  Содержание компоненты символа ячейки функции также называют
  @dfn{определением функции} символа.  Порядок использования такого
  определения функции символа вместо символа называется использование
  @dfn{косвенного символа функции}; см @ref{Function Indirection}.  Если не
  задано символу определение функции, его компоненту ячейки функции называют
  @dfn{void (недействительной)}, и символ не может быть использован в
  качестве функции.

  На практике почти все функции имеют имена, и называются их именами.  Можно
  создать именованную функцию Lisp, путем определения лямбда-выражения и
  поместив это выражение в компоненту символа ячейку функции
  (@pxref{Function Cells}).  Тем не менее, чаще используется специальная
  форма @code{defun}, описанная в следующем разделе.
@ifnottex
@xref{Defining Functions}.
@end ifnottex

  Даются имена функциям, потому что удобно ссылаться на них по их именам в
  выражениях Lisp.  Кроме того, именованная функция Lisp может легко
  ссылаться на себя --- она может быть рекурсивной.  В добавок, на примитивы
  можно ссылаться только по их текстуально выраженным именам, так как они
  представляют собой объекты функций (@pxref{Primitive Function Type}) и не
  имеют синтаксис для чтения.

  Функция не должна иметь уникальное имя.  Данный объект функции
  @emph{обычно} появляется в компоненте ячейки функции только одного символа,
  но это всего лишь условность.  Легко можно сохранить такой объект в
  нескольких символах используя @code{fset}; и каждый из символов будет
  допустимым именем для одной и той же функции.

  Обратите внимание, что символ, используемый в качестве имени функции также
  может быть использован в качестве переменной;  Эти два варианта
  использования символа являются независимыми и не конфликтует.  (Это не так
  в некоторых диалектах Lisp, как Scheme.)

  По соглашению, если имя символа функции состоит из двух имен, разделенных
  @samp{--}, функция предназначается для внутреннего использования и первая
  часть относиться к имени файла определения функции.  Например, функция с
  именем @code{vc-git--rev-parse} внутренняя функция, определенная в
  файле @file{vc-git.el}.  Для внутреннего использования функции, написанные
  на C имеют имена, оканчивающиеся на @samp{-internal}, например,
  @code{bury-buffer-internal}.  Emacs код, относящийся к именованию функций
  для внутреннего использования написанный до 2018 года, может не
  придерживаться такого соглашения, которые постепенно отменяются.

@node Defining Functions
@section Определение Функций
@cindex defining a function

  Обычно имя функции присваивается при ее создании.  Это называется
  @dfn{определение функции}, и это делается с помощью макроса @code{defun}.

@defmac defun name args [doc] [declare] [interactive] body@dots{}
@code{defun} это обычный способ определение новой функции Lisp.  Определяет
символ @var{name} как функцию со списком аргументов @var{args} и телом формы,
заданным @var{body}.  Ни @var{name}, ни @var{args} не должны цитироваться.

@var{doc}, если присутствует, должно быть строкой с указанием строки
документации к функции (@pxref{Function Documentation}).  @var{declare}, если
присутствует, должно быть формой @code{declare} с указанием метаданных
функции (@pxref{Declare Form}).  @var{interactive}, если присутствует, должно
быть формой @code{interactive}, для указания как функция будет вызываться в
интерактивном режиме (@pxref {Interactive Call}).

Возвращаемое значение @code{defun} не определено.

Вот некоторые примеры:

@example
@group
(defun foo () 5)
(foo)
     @result{} 5
@end group

@group
(defun bar (a &optional b &rest c)
    (list a b c))
(bar 1 2 3 4 5)
     @result{} (1 2 (3 4 5))
@end group
@group
(bar 1)
     @result{} (1 nil nil)
@end group
@group
(bar)
@error{} Неверное число аргументов.
@end group

@group
(defun capitalize-backwards ()
  "Установить слову в точке заглавную букву."
  (interactive)
  (backward-word 1)
  (forward-word 1)
  (backward-char 1)
  (capitalize-word 1))
@end group
@end example

@cindex override existing functions
@cindex redefine existing functions
Будьте осторожны, чтобы не переопределить существующие функции неумышленно.
@code{defun} переопределяет даже примитивные функции, такие как @code{car},
без каких-либо колебаний или уведомления.  Emacs не мешает вам делать это,
потому что переопределение функции иногда делается намеренно, и нет никакого
способа отличить намеренное переопределение от непреднамеренного
переопределения.
@end defmac

@cindex function aliases
@cindex alias, for functions
@defun defalias name definition &optional doc
@anchor{Definition of defalias}
Эта функция определяет символ @var{name} как функцию, с определением
@var{definition} (который может быть любой действительной функцией Lisp).
Возвращаемое значение @emph{неопределенно}.

Если @var{doc} является не-@code{nil}, функции @var{name} устанавливается
документация.  В противном случае, используется документация, представленная
@var{definition}.

@cindex defalias-fset-function property
Внутри @code{defalias} обычно использует @code{fset} для установки
определения.  Однако, если @var{name} имеет свойство
@code{defalias-fset-function}, тогда ассоциированное с этим свойством
значение используется в качестве функции определения вместо @code{fset}.

Правильное место для использования @code{defalias}, то где специфическое имя
функции определяется --- особенно там, где это имя появляется в явном виде в
исходном загружаемом файле.  Это происходит потому, что @code{defalias}
записывает, в каком файле находится определение функции, так же, как и
@code{defun} (@pxref{Unloading}). (ВопросFunctions666)

By contrast, in programs that manipulate function definitions for other
purposes, it is better to use @code{fset}, which does not keep such
records.  @xref{Function Cells}.
@end defun

  Нельзя создать новую примитивную функцию используя @code{defun} или
  @code{defalias}, но можно использовать их, чтобы изменить определение
  функции любого символа, даже таких как @code{car} или @code{x-popup-menu},
  у которых нормальное определение является примитивным.  Тем не менее, это
  рискованно: к примеру, это почти невозможно, чтобы переопределить
  @code{car} без полного разрушения Lisp.  Переопределение неясной функции,
  такой как @code{x-popup-menu} менее опасно, но она все равно может работать
  не так, как ожидалось.  Если есть вызовы примитива из кода C, вызов
  происходит непосредственно, поэтому изменение определения символа не будет
  иметь никакого влияния на это.

  Смотреть также @code{defsubst}, определение функции как и  @code{defun} с
  выводом сообщающений Lisp компилятора при выполнения встроенного
  расширения.  @xref{Inline Functions}.

  Кроме того, можно определить функцию, предоставляя код, который будет
  сделает её встоеной как макрос компилятора.  Следующие макросы делают это
  возможным.

@c Исправте: Можно определить на месте использовать интерактивную
@c спецификацию?
@defmac define-inline name args [doc] [declare] body@dots{}
Определим функцию @var{name}, предоставляя код, который делает её
встраиваемой, как макрос компилятора.  Функция принимает список аргументов
@var{args} и будет иметь указанное тело @var{body}.

Если присутствует, @var{doc} это должно быть строкой документации функции
(@pxref{Function Documentation}); @var{declare}, если присутствует, должно
быть формой @code{declare} (@pxref{Declare Form}) задающей метаданные
функции.
@end defmac

Функции, определенные с помощью @code{define-inline} имеют ряд преимуществ
по сравнению с макросами, определяемой @code{defsubst} или @code{defmacro}:

@itemize @minus
@item
Они могут быть переданы @code{mapcar} (@pxref{Mapping Functions}).

@item
Они более эффективны.

@item
Они могут быть использованы в качестве @dfn{мест формы} для хранения
оценки (@pxref{Generalized Variables}).

@item
Они ведут себя более предсказуемо, чем @code{cl-defsubst}
(@pxref{Argument Lists,,, cl, Common Lisp Extensions for GNU Emacs
Lisp}).
@end itemize

Как функция полученная с использованием @code{defmacro}, так и встраиваемая
функция полученная с использованием  @code{define-inline}, наследует правила
видимости, либо динамическое или лексическое, из контекста вызова.
@xref{Variable Scoping}.

Следующие макросы должны использоваться в теле функции, определенной
@code{define-inline}.

@defmac inline-quote expression
Цитирует @var{expression} для @code{define-inline}. Это похоже на цитирование
(@pxref{Backquote}), но код котировки принимает только @code{,}, а не
@code{,@@}.
@end defmac

@defmac inline-letevals (bindings@dots{}) body@dots{}
Это похоже на @code{let} (@pxref{Local Variables}): устанавливаются локальные
привязки переменных, заданные @var{bindings}, а затем оценивается тело
@var{body} с полученными этими привязками.  Каждый элемент @var{bindings}
должен быть символом или списком вида @w{@code{(@var{var} @var{expr})}};
результат заключается в оценке @var{expr} и привязки @var{var} к результату.
Хвост @var{bindings} может быть @code{nil} или символом, который должен
содержать список аргументов, в этом случае вычисляется каждый аргумент, и
символ связывается с результирующим списком.  (ВопросFunctions747)
@end defmac

@defmac inline-const-p expression
Возврат не-@code{nil} если значение @var{expression} уже известно.
@end defmac

@defmac inline-const-val expression
Возвращает значение @var{expression}.
@end defmac

@defmac inline-error format &rest args
Сигнал ошибки, форматирование @var{args} согласно @var{format}.
@end defmac

Вот пример использования @code{define-inline}:

@lisp
(define-inline myaccessor (obj)
  (inline-letevals (obj)
    (inline-quote (if (foo-p ,obj) (aref (cdr ,obj) 3) (aref ,obj 2)))))
@end lisp

@noindent
Это эквивалентно

@lisp
(defsubst myaccessor (obj)
  (if (foo-p obj) (aref (cdr obj) 3) (aref obj 2)))
@end lisp

@node Calling Functions
@section Calling Functions
@cindex function invocation
@cindex calling a function

  Определение функций только полдела.  Функции ничего не делают, пока их
  @dfn{не вызовут}, то есть, обратятся к ним.  Обращение к функции также
  известно как @dfn{вызов}.

  Наиболее распространенный способ применения функции является оценка списка.
  Например, оценка списка @code{(concat "a" "b")} вызывает функцию
  @code{concat} с аргументами @code{"a"} и @code{"b"}.  @xref{Evaluation},
  для описания оценки.

  Когда вы пишете список как выражение в вашей программе, необходимо указать
  в тексте программы, какую функцию нужно вызвать и с какими аргументами.
  Обычно это именно то, что требуется.  Иногда нужно вычислить уже во время
  выполнения какую функции вызвать.  Чтобы сделать это, используется
  функция @code{funcall}.  Когда также необходимо определить во время
  выполнения, какие аргументы передать, используется @code{apply}.

@defun funcall function &rest arguments
@code{funcall} вызывает функцию @var{function} с аргументами @var{arguments},
и возвращает то, что возвращает функция @var{function}.

Поскольку @code{funcall} функция, все его аргументы, в том числе аргумент
@var{function}, вычисляются до вызова @code{funcall}.  Это означает, что
можно использовать любое выражение, чтобы получить функцию, которая будет
вызвана.  Это также означает, что @code{funcall} не видит выражения
используемые для оценки аргументов @var{arguments}, оперирует уже их
значениями.  Эти значения @emph{не} оценеваются во второй раз в момент
вызова функции @var{function}; работа @code{funcall} подобна обычному
вызова функции, когда её аргументы уже были оценены.

Аргумент @var{function} должен быть функцией Lisp или примитивной функцией.
Специальные формы и макросы не разрешены, потому что они имеют смысл только
тогда, когда заданы неоценённые выражение аргументов.  @code{funcall} не
может обеспечить этого, потому что, как описано выше, не обрабатывает их
перед непосредственным вызовом указанной функции.

Если требуется использовать @code{funcall} для вызова функции как команды и
заставить её вести себя так, как будто вызов происходит в интерактивном
режиме, используется @code{funcall-interactively} (@pxref{Interactive Call}).

@example
@group
(setq f 'list)
     @result{} list
@end group
@group
(funcall f 'x 'y 'z)
     @result{} (x y z)
@end group
@group
(funcall f 'x 'y '(z))
     @result{} (x y (z))
@end group
@group
(funcall 'and t nil)
@error{} Неверная функция: #<subr and>
@end group
@end example

Сравните эти примеры с примерами @code{apply}.
@end defun

@defun apply function &rest arguments
@code{apply} вызывает функцию @var{function} с аргументами @var{arguments},
так же, как и @code{funcall}, но с одним отличием: аргумент @var{arguments}
представляет собой список объектов, который передаётся в @var{function} с
разбором на отдельные аргументы, а не готовым списком аргументов.  Понимается
@code{apply} @dfn{расширяет} этот список, так что каждый отдельный элемент
становится аргументом.

@code{apply} возвращает результат вызова функции @var{function}.  Как и в
случае @code{funcall}, @var{function} должен либо быть функцией Lisp или
примитивной функции; специальные формы и макросы не имеют смысла при
использовании с @code{apply}.

@example
@group
(setq f 'list)
     @result{} list
@end group
@group
(apply f 'x 'y 'z)
@error{} Неправильный тип аргумента: listp, z
@end group
@group
(apply '+ 1 2 '(3 4))
     @result{} 10
@end group
@group
(apply '+ '(1 2 3 4))
     @result{} 10
@end group

@group
(apply 'append '((a b c) nil (x y z) nil))
     @result{} (a b c x y z)
@end group
@end example

Интересный пример использования @code{apply}, смотреть
@ref{Definition of mapcar}.
@end defun

@cindex partial application of functions
@cindex currying
  Иногда бывает полезно, привязать некоторые из аргументов функции к
  определенным значениях, не затрагивая остальные аргументы, когда функция
  на самом деле вызывается.  Акт такой фиксации некоторых из аргументов
  функции называется @dfn{частичным применением} функции@footnote{Это сходно,
  но отличается от @dfn{currying}, которое преобразует функцию, которая
  обрабатывает аргументы по очереди, получая цепочку вызова функции для
  каждого аргумента.}.  Результатом является новая функция, которая принимает
  остальные аргументы и вызывает исходную функцию со всеми аргументами,
  вместе взятыми.

  Вот как сделать частичное применение в Emacs Lisp:

@defun apply-partially func &rest args
Эта функция возвращает новую функцию, которая при вызове будет вызывать
@var{func} со списком аргументов, состоящих из @var{args} и дополнительных
аргументов, указанных в момент вызова.  Если @var{func} принимает @var{n}
аргументов, то вызов @code{apply-partially} с аргументами
@w{@code{@var{m} < @var{n}}} преобразуется в вызов функции с новыми
аргументами @w{@code{@var{n} - @var{m}}}.  (ВопросFunctions905)

Вот как можно было определить встроенную функцию @code{1+}, если её не
не существовало, используя @code{apply-partially} и другой встроенной функции
@code{+}:

@example
@group
(defalias '1+ (apply-partially '+ 1)
  "Приращение еденицы к аргументу.")
@end group
@group
(1+ 10)
     @result{} 11
@end group
@end example
@end defun

@cindex functionals
  Функции Lisp принимающие функции в качестве своих аргументов или
  использующие аргументы находящиеся в структурах данных (особенно в
  переменных-ловушках и списках свойств) обрабатывают их с помощью
  @code{funcall} или @code{apply}.  Функции, которые принимают в аргументах
  функции, часто называют @dfn{функциональными}.

  Иногда, когда требуется получить функционал, полезно указать функцию в
  качестве аргумента без действия.  Вот два разных вида такого вызова
  бездействующей функции:

@defun identity arg
Функция возвращает @var{arg} и не имеет побочных эффектов.
@end defun

@defun ignore &rest args
Функция игнорирует все аргументы и возвращает @code{nil}.
@end defun

  Некоторые функции представляются пользователю как @dfn{команды}, которые
  могут быть вызваны в интерактивном режиме (обычно с помощью
  нажатия последовательности клавиш).  Можно вызвать такую ​​команду в
  точности так, как если бы был её вызов в интерактивном режиме, используя
  функцию @code{call-interactively}.  @xref{Interactive Call}.

@node Mapping Functions
@section Сопоставление Функций
@cindex mapping functions

  @dfn{Сопоставление функции} применяет данную функцию (@emph{не} специальную
  форму или макрос) к каждому элементу списка или другой коллекции.  Emacs
  Lisp имеет несколько таких функций; В данном разделе описаны @code{mapcar},
  @code{mapc}, @code{mapconcat}, и @code{mapcan}, которые сопоставляют
  функцию к списку.  @xref{Definition of mapatoms} для функции
  @code{mapatoms}, сопоставляющая с символами массива obarray.
  @xref{Definition of maphash} для функции @code{maphash}, отображающая
  ключ/значение ассоциаций в хэш-таблице.  (ВопросFunctions959)

  Эти функции сопоставления не позволяют использовать символ-таблицу, так как
  символ-таблица представляет собой разреженный массив, чей номинальный
  диапазон индексов очень велик.  Чтобы отобразить символ-таблицу таким
  способом с должным образом, учитывая её разреженую природу, используется
  функция @code{map-char-table} (@pxref {Char-Tables}).

@defun mapcar function sequence
@anchor{Definition of mapcar}
@code{mapcar} соотносит функцию @var{function} по очереди  к каждому элементу
последовательности @var{sequence} и возвращает список результатов.

Аргумент @var{sequence} может быть любым видом последовательности, кроме
символ-таблицы; то есть представлять список, вектор, булев-вектор или строку.
Результат всегда список.  Длина результата такая же, как длина
последовательности @var{sequence}. Например:

@example
@group
(mapcar 'car '((a b) (c d) (e f)))
     @result{} (a c e)
(mapcar '1+ [1 2 3])
     @result{} (2 3 4)
(mapcar 'string "abc")
     @result{} ("a" "b" "c")
@end group

@group
;; @r{Вызов функции для каждого элемента в @code{my-hooks}.}
(mapcar 'funcall my-hooks)
@end group

@group
(defun mapcar* (function &rest args)
  "Сопоставляет последовательно FUNCTION к каждой предней части аргументов
ARGS. Возвращает список результатов."
  ;; @r{Пока список не будет исчерпан,}
  (if (not (memq nil args))
      ;; @r{применить функцию @sc{car}.}
      (cons (apply function (mapcar 'car args))
            (apply 'mapcar* function
                   ;; @r{Рекурсивный вызов для остальных аргументов.}
                   (mapcar 'cdr args)))))
@end group

@group
(mapcar* 'cons '(a b c) '(1 2 3 4))
     @result{} ((a . 1) (b . 2) (c . 3))
@end group
@end example
@end defun

@defun mapcan function sequence
Функция сопоставляет @var{function} к каждому элементу последовательности
@var{sequence}, как и @code{mapcar}, но вместо того, чтобы собирать
результаты в виде списка, возвращает один список со всеми элементами
результатов (которые должны быть списками), изменяя результаты (с
использованием @code{nconc}; @pxref{Rearrangement}).  Как и у @code{mapcar},
последовательность @var{sequence} может быть любого типа, кроме
символ-таблицы.

@example
@group
;; @r{Сравнить это:}
(mapcar 'list '(a b c d))
     @result{} ((a) (b) (c) (d))
;; @r{с этим:}
(mapcan 'list '(a b c d))
     @result{} (a b c d)
@end group
@end example
@end defun

@defun mapc function sequence
@code{mapc}, как и @code{mapcar} за исключением того, что @var{function}
используется только для побочных эффектов --- возвращаемые значения
игнорируются, не собираются в списке.  @code{mapc} всегда возвращает
последовательность @var{sequence}.
@end defun

@defun mapconcat function sequence separator
@code{mapconcat} сопоставляет функцию @var{function} к каждому элементу
последовательности @var{sequence}; результаты, которые должны быть
последовательностью символов (строки, векторы, или списки), объединяются в
одно строковое значение возврата.  Между каждой парой последовательности в
возвращаемом значении, @code{mapconcat} вставляет символы из @var{separator},
который также должен быть строкой вектором или списком символов.
@xref{Sequences Arrays Vectors}.

Аргумент @var{function} должен быть функцией, которая может принимать один
аргумент и возвращает последовательность символов: строку, вектор или список.
Аргумент @var{sequence} может быть любым видом последовательности, кроме
символ-таблицы; то есть списком, вектором, булевым-вектором или строкой.

@example
@group
(mapconcat 'symbol-name
           '(Кот в шляпе)
           " ")
     @result{} "Кот в шляпе"
@end group

@group
(mapconcat (function (lambda (x) (format "%c" (1+ x))))
           "HAL-8000"
           "")
     @result{} "IBM.9111"
@end group
@end example
@end defun

@node Anonymous Functions
@section Анонимные Функции
@cindex anonymous function

  Хотя функции, как правило, определяются с @code{defun} и получают имена в
  то же время, иногда удобно использовать явное выражение лямбды --- в
  @dfn{анонимной функции}.  Анонимные функции действуют везде, где и
  именованные функции.  Они часто назначается в качестве значений переменных
  или в качестве функций аргументов; например, можно передать анонимную
  функцию в качестве аргумента @var{function} к функции @code{mapcar},
  которая применит эту функцию к каждому элементу списка аргументов
  (@pxref{Mapping Functions}).  @xref{describe-symbols example}, более
  реалистичный пример этого.

  При определении лямбда-выражения, которое будет использоваться в качестве
  анонимной функции, можно в принципе использовать любой метод построения
  списка.  Но, как правило, нужно использовать @code{lambda} макрос или
  специальную форму @code{function}, или же @code{#'} синтакс чтения:

@defmac lambda args [doc] [interactive] body@dots{}
Макрос возвращает анонимную функцию с со списком аргументов @var{args}, со
строкой документации @var{doc} (если таковая предоставляется), с
интерактивной формой @var{interactive} (если таковая предоставляется), и с
формой тела @var{body} с данными.

При динамическом связывании, этот макрос фактически делает форму
@code{lambda} само-цитированой: оценка @sc{car} формы @code{lambda} дает
саму форму:  (ВопросFunctions1098)

@example
(lambda (x) (* x x))
     @result{} (lambda (x) (* x x))
@end example

Следует отметить, что при оценке в соответствии с лексическим правилом
связывания, результатом является объект замыкание (@pxref{Closures}).

Форма @code{lambda} имеет ещё один эффект: она сообщает оценщику и
байт-компилятору Emacs, что ее аргумент является функцией, с помощью
@code{function} в качестве подпрограммы (смотрим ниже).
@end defmac

@defspec function function-object
@cindex function quoting
Специальная форма возвращает @var{function-object} без его оценки.  В этом
есть сходство с @code{quote} (@pxref{Quoting}).  Но в отличие от
@code{quote}, это также служит в качестве примечания к оценщику и
байт-компилятору Emacs, что @var{function-object} предназначен для
использования в качестве функции.  Предполагая, что @var{function-object}
является допустимым лямбда-выражением, получается два эффекта:

@itemize
@item
Когда производиться байт-компиляция @var{function-object}, код компилируется
в байт-компилированный объект функции (@pxref{Byte Compilation}).

@item
Когда действуют правила лексической привязки, @var{function-object}
превращается в замыкание.  @xref{Closures}.
@end itemize
@end defspec

@cindex @samp{#'} syntax
Синтаксис чтения @code{#'} это стенография для использования @code{function}.
Следующие формы эквивалентны:

@example
(lambda (x) (* x x))
(function (lambda (x) (* x x)))
#'(lambda (x) (* x x))
@end example

  В следующем примере определяется функция @code{change-property}, которая
  принимает функцию в качестве третьего аргумента, а затем с помощью функции
  @code{double-property}, позволяет использовать @code{change-property},
  передавая ей анонимную функцию:

@example
@group
(defun change-property (symbol prop function)
  (let ((value (get symbol prop)))
    (put symbol prop (funcall function value))))
@end group

@group
(defun double-property (symbol prop)
  (change-property symbol prop (lambda (x) (* 2 x))))
@end group
@end example

@noindent
Обратите внимание, что мы не цитируем форму @code{lambda}.

  Если скомпилировать код выше, анонимная функция также будет скомпилирована.
  Этого бы не произошло, если, скажем, построить анонимную функцию,
  процитировав её в виде списка:

@c Нет цитате это лямбда!
@example
@group
(defun double-property (symbol prop)
  (change-property symbol prop '(lambda (x) (* 2 x))))
@end group
@end example

@noindent
В этом случае анонимная функция переходит как лямбда-выражения в
скомпилированный код.  Байт-компилятор не сможет принять этот список как
функцию, даже если он выглядит как функция, так как не берётся во внимание
то, что @code{change-property} будет использовать этот код в качестве
функции.

@node Generic Functions
@section Обобщённые Функции
@cindex generic functions
@cindex polymorphism

  Функции, определенные с помощью @code{defun} имеют жестко
  запрограммированный набор предположений о типах и ожидаемых значений своих
  аргументов.  Например, функция, которая была разработана для обработки
  значений своего аргумента, которые может быть числом или списком чисел,
  утратят достоверность или получат сигнал об ошибке при вызове со значением
  любого другого типа, например, в качестве вектора или строки.  Это
  происходит потому, что реализация функции не готова иметь дело с другими
  типами значения аргумента, чем те, которые предполагались при
  проектировании функции.

  Напротив, объектно-ориентированные программы используют
  @dfn{полиморфные функции}: набор специализированных функций, имеющие
  одинаковые имена, каждая из которых написана для определенного конкретного
  набора типов аргументов.  Какая из функций фактически будет вызвана,
  определяется во время выполнения вызова на основе типов фактических
  аргументов.

@cindex CLOS
  Emacs обеспечивает поддержку полиморфизма.  Как и в других средах, в
  частности Lisp диалекта Common Lisp и его Common Lisp Object System
  (@acronym{CLOS}), эта поддержка основана на @dfn{обобщённых функциях}.
  Обобщенные функции Emacs тесно связаны с @acronym{CLOS}, включая
  использование подобных имен, так что если есть опыт работы с
  @acronym{CLOS}, остальная часть этого раздела будет звучать очень знакомо.

  Обобщенная функция определяет абстрактную операцию, определяется её имя и
  список аргументов, но (как правило) без реализации.  Фактическая реализация
  для нескольких конкретных наборов типов аргументов обеспечивается
  @dfn{методами}, которые определяются отдельно.  Каждый метод, который
  реализует обобщённую функцию имеет то же имя, родительская обобщённая
  функция, но определение метода указует, какие аргументы он может
  обрабатывать с помощью @dfn{специализации} своих аргументов, определенных
  обобщенной функцией.  @dfn{Специализация аргумента} может быть более или
  менее конкретной; например, тип @code{строка} более конкретно, чем
  специализация более общего типа, такого, как @code{последовательность}.

  Обратите внимание, что, в отличие от объектно-ориентированных языков
  основанных на сообщениях, таких как C@t{++} и Simula, методы, которые
  реализуют обобщённые функции не принадлежат к самому набору, они
  принадлежат к обобщённой функции, которую они реализуют.

  Когда происходит вызов обобщённой функции, выбираются применимые методы,
  путем сравнения переданных фактических аргументов, специализаторами каждого
  метода.  Метод применяется, если фактические аргументы вызова совместимы с
  специализациями метода.  Если более чем один метод применим, они
  объединяются с помощью определенных правил, описанных ниже, и их комбинация
  затем обрабатывает вызов.

@defmac cl-defgeneric name arguments [documentation] [options-and-methods@dots{}] &rest body
Макрос определяет обобщенную функцию с указанным именем @var{name} и
аргументами @var{arguments}.  Если тело @var{body} присутствует, то оно
обеспечивает реализацию по умолчанию.  Если @var{documentation} присутствует
(оно всегда должно быть), это помещает строку документации для обобщенной
функции, в виде @code{(:documentation @var{docstring})}.  Дополнительно
@var{options-and-methods} можно предоставить в одной из следующих форм:

@table @code
@item (declare @var{declarations})
Форма объявления, как описано в @ref{Declare Form}.
@item (:argument-precedence-order &rest @var{args})
Форма влияет на порядок сортировки при объединении применимых методов.
Обычно, когда два метода сравниваются во время комбинации, аргументы методов
рассматриваются слева направо, и первый метод, чья специализация аргумента
более конкретна, преуспевает перед другим методом.  Порядок установленный
с помощью этой формы переопределяется и аргументы рассматриваются в
соответствии с указанным порядком в этой форме, а не слева направо.
@item (:method [@var{qualifiers}@dots{}] args &rest body)
Эта форма определяет метод, такой как @code{cl-defmethod}.
@end table
@end defmac

@defmac cl-defmethod name [qualifier] arguments &rest [docstring] body
Этот макрос определяет конкретную реализацию обобщённой функции, с именем
@var{name}.  Код реализации задается телом @var{body}.  Если присутствует,
@var{docstring} является строкой документации для метода.  Список
@var{arguments}, должен быть одинаковым во всех методах, которые реализуют
обобщенную функцию, и должен соответствовать списку аргументов этой функции,
аргументы обеспечиваются специализацией вида @code{(@var{arg} @var{spec})},
где @var{arg} это имя аргумента, как указано в вызове @code{cl-defgeneric} и
@var{spec} является одной из следующих форм специализации:

@table @code
@item @var{type}
Специализация требует, чтобы аргумент был заданного типа @var{type}, одним из
типов иерархии типов, описанной ниже.
@item (eql @var{object})
Специализация требует, чтобы аргумент удовлетворял @code{eql} к данному
@var{object}.
@item (head @var{object})
Аргумент должен быть cons-ячейкой @code{car} которой @code{eql} к
@var{object}.
@item @var{struct-type}
Аргумент должен быть экземпляром набора с именем @var{struct-type},
определенного с момощью @code{cl-defstruct}
(@pxref{Structures,,, cl, Common Lisp Extensions for GNU Emacs Lisp}), или
одного из его дочерних наборов.
@end table

В качестве альтернативы, специализация аргумента может иметь вид
@code{&context (@var{expr} @var{spec})}, в этом случае значение @var{expr}
должно быть совместимо с специализацией @var{spec}; @var{spec} может быть
любой из форм, описанных выше.  Другими словами, эта форма специализации
использует значение @var{expr} вместе с аргументом для решения, является ли
метод применимым.  Например, @code{&context (overwrite-mode (eql t))} сделает
метод совместим только тогда, когда @code{overwrite-mode} включен.
(ВопросFunctions1293)

Спецификация типа, @code{(@var{arg} @var{type})}, может указать один из
@dfn{системных типов} в следующем списке.  Если указан родительский тип,
аргумент, тип которого является любым наследником более конкретного типа,
а также наследником наследника и т.д., метод также будет применним.
(ВопросFunctions1299)

@table @code
@item integer
Родительский тип: @code{number}.
@item number
@item null
Родительский тип: @code{symbol}
@item symbol
@item string
Родительский тип: @code{array}.
@item array
Родительский тип: @code{sequence}.
@item cons
Родительский тип: @code{list}.
@item list
Родительский тип: @code{sequence}.
@item marker
@item overlay
@item float
Родительский тип: @code{number}.
@item window-configuration
@item process
@item window
@item subr
@item compiled-function
@item buffer
@item char-table
Родительский тип: @code{array}.
@item bool-vector
Родительский тип: @code{array}.
@item vector
Родительский тип: @code{array}.
@item frame
@item hash-table
@item font-spec
@item font-entity
@item font-object
@end table

Опция @var{qualifier} (спецификатор) позволяет комбинировать несколько
применимых методов.  Если нет, то описываемый метод представляет собой метод
@dfn{primary} (основной), ответственный за предоставление первичной
реализации обобщенной функции для специализированных аргументов.  Можно также
определить @dfn{auxiliary methods} (вспомогательные методы), с помощью одного
из следующих значений в качестве квалификатора @var{qualifier}:

@table @code
@item :before
Вспомогательный метод будет назначаться до основного метода.  Точнее, все
методы @code{:before} будут назначаться до основного, в порядке от наиболее
специфичных.
@item :after
Вспомогательный метод будет назначаться после основного метода.  Точнее, все
такие методы будут работать после основного, в порядке от наиболее
специфичного до последнего.
@item :around
Вспомогательный метод будет работать @emph{вместо} основного метода.
Наиболее специфичный из таких методов будет выполняться перед любым другим
методом.  Такие методы обычно используют @code{cl-call-next-method},
описанных ниже, чтобы ссылаться на другие вспомогательные или основные
методы.
@item :extra @var{string}
Позволяет добавить дополнительные методы, отличающиеся @var{string}, для
одних и тех же специализаций и классификаторов.
@end table

Функции, определенные с помощью @code{cl-defmethod} не могут быть сделаны
интерактивными, то есть @: командами (@pxref{Defining Commands}), путем
добавления формы @code{interactive} к ним.  Если нужна полиморфная команда,
рекомендуется определение нормальной команды, которая вызывает полиморфную
функцию, определенную с помощью @code{cl-defgeneric} и @code{cl-defmethod}.
@end defmac

@cindex dispatch of methods for generic function
@cindex multiple-dispatch methods
Каждый раз, когда вызывается обобщённая функция, строится
@dfn{эффективный метод}, который будет обрабатывать этот вызов путем
комбинирования применимых методов, определенные для функции.  Процесс поиска
применимых методов и получение эффективного метода называют @dfn{dispatch}
(отправкой).  Применимые методы это те, у которых все специализации
совместимы с фактическими аргументами вызова.  Поскольку все аргументы должны
быть совместимы со спецификациями, все они определяют, является ли метод
применимым.  Методы, которые явно специализируют более одного аргумента,
называются @dfn{multiple-dispatch methods} (методы множественной-отправки).

Применимые методы сортируются в порядке, в котором они будут объединены.
Метод, чей левый аргумент наиболее конкретен спкциализации будет первым в
порядке.  (Определение @code{:argument-precedence-order} как часть
@code{cl-defmethod} переопределение этого, как описано выше.) Если тело
метода вызывает @code{cl-call-next-method}, следующий наиболее специфический
метод будет работать.  Если есть применимые методы @code{:around}, наиболее
специфичные из них будут работать в первую очередь; это должно произвести
вызов @code{cl-call-next-method} запускающий любой из менее конкретных
методов @code{:around}.  Далее, методы @code{:before} выполняются в порядке
их специфичности, с последующим первичным методом, и, наконец, методы
@code{:after} в порядке, обратном порядку их специфичности.
(ВопросFunctions1395)

@defun cl-call-next-method &rest args
Когда вызываются из первичного лексического тела или @code{:around}
вспомогательного метода, вызывается следующий метод, применимый для одной и
той же обобщенной функции.  Как правило, она вызывается без аргументов, что
прводит к вызову следующего применимого метода с теми же аргументами, с
которыми метод был вызван.  В противном случае указанные аргументы
используются вместо этого.  (ВопросыFunctions1404)
@end defun

@defun cl-next-method-p
Функция, когда вызывается из первичного лексического тела или @code{:around}
вспомогательного метода, возвращает не-@code{nil}, если существует следующий
метод вызова.
@end defun


@node Function Cells
@section Доступ к Компоненте Символа Ячейки Функции

  @dfn{Определение функции} символа - является объект, хранящийся в
  компоненте символа ячейки функции.  Описанные здесь функции осуществляют
  доступ, тестирование и установку ячейки функции компоненты символа.

  Смотреть также функцию @code{indirect-function}.
  @xref{Definition of indirect-function}.

@defun symbol-function symbol
@kindex void-function
Возвращает объект находящийся в компоненте символа @var{symbol} его ячейки
функции.  Не проверяется, что возвращаемый объект является допустимой
функцией.

Если ячейка функции недействительна, возвращается значение @code{nil}.  Для
того, чтобы различать ячейки функции, которые является недействительными и
установленные в @code{nil}, используется @code{fboundp} (смотри ниже).

@example
@group
(defun bar (n) (+ n 2))
(symbol-function 'bar)
     @result{} (lambda (n) (+ n 2))
@end group
@group
(fset 'baz 'bar)
     @result{} bar
@end group
@group
(symbol-function 'baz)
     @result{} bar
@end group
@end example
@end defun

@cindex void function cell
  Если не присваивалось символу никакого определения функции, то понимается,
  что ячейка функции этого символа является @dfn{void} (недействительна).
  Другими словами, ячейка функции символа не содержит какой-либо объект Lisp.
  Если попытаться вызвать символ как функция, Emacs сигнализирует об ошибке
  @code{void-function} (недействительная-функция).

  Обратите внимание, что недействительное не то же самое, что @code{nil} или
  символ @code{void}.  Символы @code{nil} и @code{void} являются Lisp
  объектами, и могут быть сохранены в ячейки функции так же, как и любые
  другие объекты (и они могут быть действительными функциями, если
  определены как функции в свою очередь, с @code{defun}).  Недействительная
  ячейка функции не содержит объекта вообще.

  Можете проверить недействительность определения функции символа с
  помощью @code{fboundp}.  После того, как символ получил определение
  функции, можно снова сделать его недействительным с помощью
  @code{fmakunbound}.

@defun fboundp symbol
Функция возвращает @code{t} если символ имеет объект в его ячейке функции и
@code{nil} в противном случае.  Не проверяется, что объект является
допустимой функцией.
@end defun

@defun fmakunbound symbol
Функция делает ячейку функции символа @var{symbol} недействительной, так что
последующие попытки получить доступ к этой ячейке будут вызывать ошибку
@code{void-function}.  Возвращает @var{symbol}. (Смотри также
@code{makunbound}, в @ref{Void Variables}.)

@example
@group
(defun foo (x) x)
(foo 1)
     @result{}1
@end group
@group
(fmakunbound 'foo)
     @result{} foo
@end group
@group
(foo 1)
@error{} Symbol's function definition is void (Определение функции символа является недействительным): foo
@end group
@end example
@end defun

@defun fset symbol definition
Функция сохраняет определение @var{definition} в ячейки функции символа
@var{symbol}.  Возвращаемый результате определение @var{definition}.  Обычно
@var{definition} должно быть функцией или именем функции, но это не
проверяется.  Аргумент @var{symbol} обычный оцениваемый аргумент.

Основное применение этой функции в качестве подпрограммы применение
конструкций, которые определяют или изменяют функцию, таких как @code{defun}
или @code{advice-add} (@pxref{Advising Functions}).  Можно также использовать
это, чтобы дать символу определение функции, которая не является функцией,
например, представляет собой клавиатурный макрос (@pxref{Keyboard Macros}):

@example
;; @r{Определение имени макроса клавиатуры.}
(fset 'kill-two-lines "\^u2\^k")
     @result{} "\^u2\^k"
@end example

Вместо использования @code{fset} для получения альтернативного имени для
функции, рассмотрите возможность использования @code{defalias} вместо этого.
@xref{Definition of defalias}.
@end defun

@node Closures
@section Замыкания

  Как пояснялось в разделе @ref{Variable Scoping}, Emacs может дополнительно
  включить лексическое связывание переменных. Когда  действует правило
  лексической привязки, любая именованная функция, которая создаётся
  (например, с @code{defun}), а также любая анонимная функция, которая
  создаётся с использованием @code{lambda} макроса или специальной формы
  @code{function} или с использованием синтаксиса чтения  @code{#'}
  (@pxref{Anonymous Functions}), автоматически превращается в
  @dfn{замыкание}.

@cindex closure
  Замыкание это функция, которая также содержит запись лексической среды,
  которая существовала, когда функция была определена.  Когда она вызывается,
  любые ссылки на лексические переменные в пределах её определения используют
  её нераспределенную лексическую среду.  Во всех других отношениях,
  замыкания ведут себя так же, как и обычные функции; в частности, они могут
  быть вызваны таким же образом, как и обычные функции.

  @xref{Lexical Binding}, для примера использования замыкания.

  В настоящее время объект замыкания Emacs Lisp представляется списком с
  условным обозначением символа @code{closure} в качестве первого элемента,
  списком, представляющим лексическую среду в качестве второго элемента и
  списка аргументов и формы тела, в качестве остальных элементов:

@example
;; @r{Включено правило лексического связывания.}
(lambda (x) (* x x))
     @result{} (closure (t) (x) (* x x))
@end example
        
@noindent
Тем не менее, тот факт, что внутренняя структура замыкания открыта для
воздействия остального мира Lisp, это считается внутренней деталью
реализации.  По этой причине не рекомендуется непосредственно изучение или
изменение структуры объекта замыкания.

@node Advising Functions
@section Рекомендации по Функциям Emacs Lisp
@cindex advising functions
@cindex piece of advice

Если необходимо изменить функцию, определенную в другой библиотеке, или когда
нужно изменить ловушку, такую как @code{@var{foo}-function}, трассировать
процесс, поле объекта или любую переменную, где хранится значение функции,
можно использовать соответствующую функцию установки, например, @code{fset}
или @code{defun} для именованной функции, @code{setq} для переменных-ловушек
или @code{set-process-filter} для трассировки процессов, однако это слишком
грубый способ, полностью выбрасывается предыдущее значение.

  Функция @dfn{совета} позволяет добавлять код к существующему определению
  функции, @dfn{рекомендации к функции}.  Этот метод мягче, чем
  переопределение всей функции.

Система рекомендаций Emacs предоставляет два набора примитивов для этого:
основной набор, для значений функций, содержащихся в переменных и полях
объектов (основанный на соответствующих примитивах @code{add-function} и
@code{remove-function}) и другой набор, базирующийся поверх него для
именованных функций (основанный на примитивах @code{advice-add} и
@code{advice-remove} ). (ВопросFunctions1583)

Например, для того, чтобы трассировать отслеживаемый процесс @var{proc},
можно использовать:

@example
(defun my-tracing-function (proc string)
  (message "Proc %S received %S" proc string))

(add-function :before (process-filter @var{proc}) #'my-tracing-function)
@end example

Это приведет к тому, что выходные данные процесса будут передены
@code{my-tracing-function} перед началом трассировки исходного процесса.
@code{my-tracing-function} получает те же аргументы, что и исходная функция.
Когда трассировка более не требуется, можно вернуться к нетрассируемому
поведению: (ВопросFunctions1599)

@example
(remove-function (process-filter @var{proc}) #'my-tracing-function)
@end example

Точно так же, если требуется отслеживать выполнение именованной функции
@code{display-buffer}, можно использовать:

@example
(defun his-tracing-function (orig-fun &rest args)
  (message "Отображение-буфера вызывается с аргументами %S" args)
  (let ((res (apply orig-fun args)))
    (message "Отображение-буфера, возврат без трассировки %S" res)
    res))

(advice-add 'display-buffer :around #'his-tracing-function)
@end example

(ВопросFunctions1618)

Здесь @code{his-tracing-function} вызывается вместо исходной функции и
получает исходную функцию (в дополнение к аргументам этой функции) в качестве
аргумента, так что можно сделать вызов функции, если это понадобится.  Когда
вывод этот более не требуется, можно вернуться к нетрассируемому поведению:

@example
(advice-remove 'display-buffer #'his-tracing-function)
@end example

Аргументы @code{:before} и @code{:around} в приведенных выше примерах
указывают, каким образом эти две функции состовляются, так как существует
много различных способов сделать это.  Добавленная часть функции также
называется @emph{рекомендацией}.

@menu
* Core Advising Primitives::    Примитивы манипулирования рекомендациями.
* Advising Named Functions::    Рекомендация именованных функций.
* Advice combinators::          Способы составления пекомендации.
* Porting old advice::          Адаптация кода прежднего @code{defadvice}.
@end menu

@node Core Advising Primitives
@subsection Примитивы Управления Рекомендациями
@cindex advice, add and remove

@defmac add-function where place function &optional props
Макрос является удобным способом добавить рекомендацию @var{function}, к
функции, хранящейся в месте @var{place} (@pxref{Generalized Variables}).

@var{where} определяет, как @var{function} составляется с существующей
функцией, например, следует ли @var{function} вызываться до или после
исходной функции.  @xref{Advice combinators}, для списка доступных способов,
чтобы составить две функции.

При изменении переменной (чье имя обычно заканчиваются на @code{-function}),
можно выбрать, используется ли @var{function} глобально или только в текущем
буфере: если @var{place} это просто символ, @var{function} добавить к
глобальному значению @var{place}.  Если место @var{place} имеет форму вида
@code{(local @var{symbol})}, где @var{symbol} это выражение, которое
возвращает имя переменной, тогда @var{function} будет привязана только к
текущему буферу.  И, наконец, если требуется изменить лексически связанную
переменную, нужно использовать @code{(var @var{variable})}.

Каждая функция, добавленная с @code{add-function} может сопровождаться
ассоциативным списком свойств @var{props}.  В настоящее время только два из
этих свойств имеют особое значение:

@table @code
@item name
Это даёт название рекомендации, которое можно использовать c
@code{remove-function} для определения того, какие функции удалить.  Обычно
используется, когда @var{function} является анонимной функцией.

@item depth
Это указывает, какую рекомендацию использовать, если присутствует несколько
рекомендаций.  По умолчанию глубина равна 0.  Глубина 100 указывает, что эта
рекомендация может быть настолько глубоко, насколько это возможно, в то время
как глубина @minus{}100 указывает на то, что она должна быть самой внешней.
Когда две рекомендации указывают одну и ту же глубину, последняя добавленная
будет преуспевать.

Для рекомендации @code{:before}, наиболее внешней означает, что эта
рекомендация будет обработана первой, перед любой другой рекомендацией, в то
время как самая внутренняя рекомендация означает, что она будет обработана
прямо перед исходной функцией, без обработки других рекомендаций между этой
рекомендацией и исходной функцией.  Аналогично, для самых внутренних
@code{:after} рекомендаций означает, что рекомендация будет отработана сразу
после исходной функции, без обработки других рекомедаций между ними, в то
время самая внешняя рекомендация означает то, что рекомендация будет
выполнятся прямо в конце после всех других рекомендаций.  Самая внутренняя
@code{:override} рекомендация перекрывает только исходную функцию и другие
рекомендации будут применяться к ней, в то время как внешний @code{:override}
рекомендация перекроет не только исходную функцию, но и также все другие
рекомендации применимые к ней.  (ВопросFunctions1693)
@end table

Если @var{function} не является интерактивной, то объединенная функция
наследует интерактивную спецификацию, если таковые имеются, исходной функции.
В противном случае, объединенная функция будет интерактивной и будет использо
интерактивную спецификацию @var{function}.  Одно исключение: если
интерактивная спецификация из @var{function} является функцией (а не
выражение или строкой), то интерактивная спецификации объединённой функции
будет вызовом этой функции в качестве единственного аргументом интерактивной
спецификации исходной функции.  Для того, чтобы интерпретировать спецификацию
полученную в качестве аргумента, используйте
@code{advice-eval-interactive-spec}.

Примечание: Интерактивная спецификация от функции @var{function} должна будет
применяться к обобщённой функции и, следовательно, подчиняться соглашениям
вызыва обобщённой функции, а не @var{function}.  Во многих случаях это не
имеет никакого значения, так как они идентичны, но это имеет значения для
@code{:around}, @code{:filter-args}, и @code{:filter-return}, где
@var{function} принимает различные аргументы, чем исходная функция,
хранящейся в месте @var{place}.
@end defmac

@defmac remove-function place function
Макрос удаляет @var{function} из обобщённой функции, хранящуюся в месте
@var{place}.  Это работает только если @var{function} была добавлен в
место @var{place} с использованием @code{add-function}.

@var{function} сравнивается с добавленной функцией в месте @var{place} с
использованием @code{equal}, чтобы попытаться работать это также с
лямбда-выражениями.  Также дополнительно сравнивают свойство функции
@code{name}, добавленной к месту @var{place}, что может быть более надежным,
чем сравнение лямбда-выражения с использованием @code{equal}.
@end defmac

@defun advice-function-member-p advice function-def
Возвращение не-@code{nil} если рекомендация @var{advice} уже присутствует к
функции @var{function-def}.  Как и для @code{remove-function} выше, вместо
фактической функции рекомендации @var{advice}, также может быть указано имя
@code{name} рекомендации.
@end defun

@defun advice-function-mapc f function-def
Вызов функции @var{f} для каждой рекомендации, добавленной к
@var{function-def}.  Функция @var{f} вызывается с двумя аргументами: функцией
рекомендации и её свойствами.  (ВопросFunctions1738)
@end defun

@defun advice-eval-interactive-spec spec
Оценит интерактивную спецификацию @var{spec} так же, как интерактивный вызов
функции с такой спецификацией, а затем вернёт соответствующий список
аргументов, который был построен. НАПРИМЕР,
@code{(advice-eval-interactive-spec "r\nP")} возвращает список из трех
элементов, содержащие границы области и текущий префиксный аргумент.
(ВопросFunctions1747 в html пример кода был)
@end defun

@node Advising Named Functions
@subsection Рекомендации Именованных Функций
@cindex advising named functions

Обычно используют рекомендации с именованными функциями и макросами.
Можно просто использовать @code{add-function} как здесь:

@example
(add-function :around (symbol-function '@var{fun}) #'his-tracing-function)
@end example

  Вместо этого требуется использовать @code{advice-add} и
  @code{advice-remove}.  Это отдельный набор функций для манипулирования
  рекомендациями, применяемый к именованным функциям, предоставляет следующие
  дополнительные возможности по сравнению с @code{add-function}: работают с
  макросами и автозагружаемыми функциями, позволяют @code{describe-function}
  сохранить первоначальную строку документации, а также документации
  добавляемых рекомедаций, позволяют добавлять и удалять рекомендации, прежде
  чем функция даже определена.

  @code{advice-add} может быть полезным для изменения поведения вызова
  существующих функции без необходимости переопределения всей
  функции.  Тем не менее, это может быть источником ошибок, так как
  существующее использование функции может предполагать старое поведение, и
  работать неправильно, когда поведение функции изменяется рекомендацией.
  Рекомендация также может вызвать путаницу в отладке, если человек делает
  отладку не замечает или не помнит, что функция была изменена рекомендацией.

  По этим причинам, рекомендации нужно использовать в тех случаях, когда нет
  возможности изменить поведение функции любым другим способом.  Если это
  можно сделать с помощью ловушки, это является предпочтительным
  (@pxref{Hooks}).  Если вы просто хотите, изменить конкретное сочетание
  клавиш вызова команды, то может быть лучше, написать новую команду, и
  переназначить набор управляющих клавиши на новый
  (@pxref{Remapping Commands}).  В частности, исходные файлы Emacs не должны
  содержать в функциях рекомендации к функциям Emacs. (Есть в настоящее время
  несколько исключений из этого соглашения, но мы стремимся, исправить это.)

  Специальные формы (@pxref{Special Forms}) не могут включать рекомендации,
  однако макросы это поддерживают, во многом таким же образом, как и функции.
  Конечно, это не повлияет на код, который был уже расширен макросом, так что
  вам нужно, убедиться, что рекомендация установлена до того, как макрос
  расширяется.

  Можно посоветовать примитив (@pxref{What Is a Function}), но обычно этого
  @emph{не} требуется делать по двум причинам.  Во-первых, некоторые
  примитивы используются механизмом рекомендация и рекомендация к ним, может
  привести к бесконечной рекурсии.  Во-вторых, многие примитивы вызываются
  непосредственно из C, и такие вызовы, игнорируют рекомендации;
  следовательно, складывается запутанная ситуация, когда некоторые вызовы
  (происходящие из Lisp кода) подчиняются рекомендациям а другие вызовы (из
  кода C) нет.

@defmac define-advice symbol (where lambda-list &optional name depth) &rest body
Макрос определяет рекомендацию и добавляет её к функции с именем
@var{symbol}.  Рекомендация является анонимной функцией, если @var{name}
установлено в @code{nil} или функцией с именем @code{symbol@@name}.  Смотреть
@code{advice-add} для объяснения других аргументов.
@end defmac

@defun advice-add symbol where function &optional props
Добавьте рекомендацию @var{function} к именованной функции @var{symbol}.
@var{where} и @var{props} имеют такое же значение, как и для
@code{add-function} (@pxref{Core Advising Primitives}).
@end defun

@defun advice-remove symbol function
Удаляет рекомендацию @var{function} у именованной функции @var{symbol}.
@var{function} также может быть именованной @code{name} рекомендацией.
@end defun

@defun advice-member-p function symbol
Возвращает не-@code{nil}, если рекомендацият @var{function} уже присутствует
в именованной функции @var{symbol}.  @var{function} также может быть
именованной @code{name} рекомендацией.
@end defun

@defun advice-mapc function symbol
Производит вызов каждой рекомендации @var{function} добавленной к именованной
функции @var{symbol}.  @var{function} вызывается с двумя аргументами: функция
рекомендация и её свойства.  (ВопросFunctions1830)
@end defun

@node Advice combinators
@subsection Способы Построения Рекомендаций

Вот различные возможные значения для @var{where} аргумента
@code{add-function} и @code{advice-add}, определяющие, как должна быть
построена обобобщённая функция, путём сопостовления рекомендации
@var{function} и оригинальной функции.

@table @code
@item :before
Вызов рекомендации @var{function} перед исходной функцией.  Обе функции
получают одни и те же аргументы а возвращаемое значение обобщённой функции -
это возвращаемое значение исходной функции.  Более конкретно, композиция двух
функций ведет себя, как:
@example
(lambda (&rest r) (apply @var{function} r) (apply @var{oldfun} r))
@end example
@code{(add-function :before @var{funvar} @var{function})} сравнимо как
однофункциональные ловушки с обычными ловушками.
@code{(add-hook '@var{hookvar} @var{function})} для обычных ловушек.
(ВопросFunctions1853)

@item :after
Вызов @var{function} после исходной функции.  Обе функции получают одни и те
же аргументы и итоговое возвращаемое значение, является значением исходной
функции.  Более конкретно, композиция двух функций ведет себя как:
@example
(lambda (&rest r) (prog1 (apply @var{oldfun} r) (apply @var{function} r)))
@end example
@code{(add-function :after @var{funvar} @var{function})} сравнима с
однофункциональными ловушками к обычным ловушкам
@code{(add-hook '@var{hookvar} @var{function} 'append)}.(ВопросFunctions1864)

@item :override
Это полностью заменяет исходную функцию новой.  Преждняя функция, конечно,
может быть снова восстановлена, если потом вызвать @code{remove-function}.

@item :around
Вызов @var{function} вместо исходной функции, но обеспечивает исходную
функцию в качестве дополнительного аргумента @var{function}.  Это наиболее
гибкое составление.  Например, это позволяет вызвать исходную функцию с
различными аргументами, или много раз, или в рамках let-связывания, или
можно иногда делегировать работу исходной функции, а иногда полностью
заменять её определение.  Более конкретно, композиция двух функций ведет
себя, как:
@example
(lambda (&rest r) (apply @var{function} @var{oldfun} r))
@end example

@item :before-while
Вызов @var{function} перед исходной функцией без её вызова, если
@var{function} возвращает @code{nil}.  Обе функции получают одни и те же
аргументы и возвращаемое значение композиции - возвращаемое значения исходной
функции.  Более конкретно, композиция двух функций ведет себя как:
@example
(lambda (&rest r) (and (apply @var{function} r) (apply @var{oldfun} r)))
@end example
@code{(add-function :before-while @var{funvar} @var{function})} сравнима по
отношению однофункциональных ловушек к
@code{(add-hook '@var{hookvar} @var{function})}, когда @var{hookvar}
запускается с помощью @code{run-hook-with-args-until-failure}.(ВопросFunctions1893)

@item :before-until
Вызов @var{function} перед исходной функцией и вызывает исходную функцию
только если, @var{function} возвращает @code{nil}.  Более конкретно,
композиция двух функций ведет себя как:
@example
(lambda (&rest r) (or (apply @var{function} r) (apply @var{oldfun} r)))
@end example
@code{(add-function :before-until @var{funvar} @var{function})} сравнима по
отношению однофункциональных ловушек к
@code{(add-hook '@var{hookvar} @var{function})}, когда @var{hookvar}
запускается с помощью @code{run-hook-with-args-until-success}.
(ВопросFunctions1906)

@item :after-while
Вызов @var{function} после исходной функции и только тогда, когда исходная
функция вернула не-@code{nil}.  Обе функции получают одни и те же аргументы
и возвращаемое значение композиции - это возвращаемое значение
@var{function}. Более конкретно, композиция двух функций ведет себя как:
@example
(lambda (&rest r) (and (apply @var{oldfun} r) (apply @var{function} r)))
@end example
@code{(add-function :after-while @var{funvar} @var{function})} сравнима с
однофункциональными ловушками
@code{(add-hook '@var{hookvar} @var{function} 'append)}, где @var{hookvar}
выполняются с помощью @code{run-hook-with-args-until-failure}.

@item :after-until
Вызов @var{function} после исходной функции и только тогда, когда исходная
функция вернёт @code{nil}.  Более конкретно, композиция двух функций ведет
себя как:
@example
(lambda (&rest r) (or  (apply @var{oldfun} r) (apply @var{function} r)))
@end example
@code{(add-function :after-until @var{funvar} @var{function})} сравнима с
однофункциональными ловушками с
@code{(add-hook '@var{hookvar} @var{function} 'append)}, когда @var{hookvar}
запускается с помощью @code{run-hook-with-args-until-success}.

@item :filter-args
Вначале производит вызов @var{function} и использует результат (который
должен быть списком) как новые аргументы для вызова с исходной функцией.
Более конкретно, композиция двух функций ведет себя как:
@example
(lambda (&rest r) (apply @var{oldfun} (funcall @var{function} r)))
@end example

@item :filter-return
Вызов первой исходной функции и передача результата в вызов @var{function}.
Более конкретно, композиция двух функций ведет себя как:
@example
(lambda (&rest r) (funcall @var{function} (apply @var{oldfun} r)))
@end example
@end table


@node Porting old advice
@subsection Адаптация Кода с Использованием Раннего defadvice
@cindex old advices, porting
@c NB: Следующие записи индекса сознательно избегают ``old'',
@c прилагательное, которое не приходит на ум для тех, кто вырос на
@c ‘defadvice’ и др. Для тех людей, что путь ``current''. Они
@c обнаруживают его ветхой чтение этого узла.
@cindex advices, porting from @code{defadvice}
@findex defadvice
@findex ad-activate

Много кода использует старый механизм @code{defadvice}, который в
значительной степени устарел вследствие появления нового @code{advice-add},
и реализация и семантика которого значительно проще.

Преждние рекомендации, такие как:

@example
(defadvice previous-line (before next-line-at-end
                                 (&optional arg try-vscroll))
  "Вставить пустую строку при движении вверх от верхней строки."
  (if (and next-line-add-newlines (= arg 1)
           (save-excursion (beginning-of-line) (bobp)))
      (progn
        (beginning-of-line)
        (newline))))
@end example

можно получить в новом механизме рекомендаций посредствам простой функции:

@example
(defun previous-line--next-line-at-end (&optional arg try-vscroll)
  "Вставить пустую строку при движении вверх от верхней строки."
  (if (and next-line-add-newlines (= arg 1)
           (save-excursion (beginning-of-line) (bobp)))
      (progn
        (beginning-of-line)
        (newline))))
@end example

Очевидно, это не меняет @code{previous-line}.  Для этого нужна
преждняя рекомендация:
@example
(ad-activate 'previous-line)
@end example
в то время как новый механизма рекомендаций требует:
@example
(advice-add 'previous-line :before #'previous-line--next-line-at-end)
@end example

Обратите внимание, что @code{ad-activate} имело глобальный эффект: оно
активировало все части рекомендаций включённые для этой заданной функции.
Если требуется только активировать или деактивировать определенные части,
необходимо @emph{включить} или @emph{отключить} его с помощью
@code{ad-enable-advice} и @code{ad-disable-advice}.  Новый механизм устраняет
это различие. (ВопросFunctions2005)

Рассмотрим рекомендации такие как:

@example
(defadvice foo (around foo-around)
  "Игнорировать регистр в `foo'."
  (let ((case-fold-search t))
    ad-do-it))
(ad-activate 'foo)
@end example

could translate into:

@example
(defun foo--foo-around (orig-fun &rest args)
  "Игнорировать регистр в `foo'."
  (let ((case-fold-search t))
    (apply orig-fun args)))
(advice-add 'foo :around #'foo--foo-around)
@end example

Что касается @emph{класса} в рекомендации, отмечается, что новый
@code{:before} не совсем соответствует старому @code{before}, потому что в
старой рекомендации можно было бы изменить аргументы функции (например, с
@code{ad-set-arg}), и это повлияло на значение аргументов исходной функции, в
то время как в новом @code{:before}, изменение аргумента через @code{setq} в
рекомендации не оказывает никакого влияния на аргументы, исходной функции.
При адаптации рекомендаций @code{before}, которые полагались на это
поведение, требуется превратить её в новую рекомендацию @code{:around} или
@code{:filter-args} вместо этого.

Точно так же старая рекомендация @code{after} может изменить возвращаемое
значение путём изменения @code{ad-return-value}, в то время как новая
рекомендация @code{:after} не может, поэтому при переводе такой старой
рекомендации @code{after}, требуется превратить её в новую рекомендацию
@code{:around} или @code{:filter-return} вместо этого.

@node Obsolete Functions
@section Объявление Функций Устаревшими
@cindex obsolete functions

  Можете отметить именованную функцию как @dfn{устаревшей}, что означает,
  она может быть удалена в какой-то момент в будущем.  Это заставляет Emacs
  предупреждать о том, что функция является устаревшей, всякий раз, когда она
  компилируется в байт-код, содержащего эту функцию, и всякий раз, когда
  отображается документацию для этой функции.  Во всех других отношениях,
  устаревшее функция ведет себя, как и любая другая функция.

  Самый простой способ отметить функцию как устаревшей, поместить форму
  @code{(declare (obsolete @dots{}))} в определении @code{defun} функции.
  @xref{Declare Form}.  Кроме того, можно использовать функцию
  @code{make-obsolete}, описанную ниже.

  Макрос (@pxref{Macros}) также может быть отмечен устаревшим с помощью
  @code{make-obsolete}; это имеет тот же эффект, как и для функции.
  Псевдоним для функции или макроса также могут быть помечены как устаревшие;
  это делает сам псевдоним устаревшим, но не функцию или макрос, которые
  расширяет псевдоним.

@defun make-obsolete obsolete-name current-name &optional when
Функция отмечает имя @var{obsolete-name} как устаревшее.  @var{obsolete-name}
должно быть именем символа именованной функции или макроса или псевдонимом
для функции или макроса.

Если @var{current-name} является именем символа, в предупреждающем сообщении
предлагается использовать @var{current-name} имя вместо @var{obsolete-name}.
@var{current-name} не должно быть обязательно псевдонимом для
@var{obsolete-name}; это может быть другая функция с аналогичной
функциональностью.  @var{current-name} также может быть строкой, которая
служит в качестве предупреждающего сообщения.  Сообщение должно начинаться в
нижнем регистре, а заканчиваться точкой.  Также может быть установлено в
@code{nil}, в этом случае предупреждение не содержит никаких дополнительных
деталей.

Аргумент условия @var{when}, должен быть строка, указывающая, когда функция
впервые была сделана устаревшей --- например, дату или номер выпуска.
@end defun

@defmac define-obsolete-function-alias obsolete-name current-name &optional when doc
Удобный макрос, отмечает функцию @var{obsolete-name} устаревшей, а также
определяет её в качестве псевдонима для функции @var{current-name}.  Это
эквивалентно следующему:

@example
(defalias @var{obsolete-name} @var{current-name} @var{doc})
(make-obsolete @var{obsolete-name} @var{current-name} @var{when})
@end example
@end defmac

In addition, you can mark a particular calling convention for a
function as obsolete:

@defun set-advertised-calling-convention function signature when
Функция определяет список аргументов @var{signature} как правильный способ
вызова функции @var{function}.  Это приводит к тому, байт-компилятор Emacs
выдаёт предупреждение каждый раз, когда в программе Emacs Lisp, вызов
функции @var{function}  происходит любым другим способом (однако, всё равно
будет позволять байт-коду скомпилироваться).  Условие @var{when} должно быть
строкой, указывающей, когда переменная впервые была сделана устаревшей (как
правило, строка номер версии).

Например, в старых версиях Emacs @code{sit-for} функция принимала три
аргумента, как здесь

@example
  (sit-for seconds milliseconds nodisp)
@end example

Однако, вызов @code{sit-for}, считается устаревшим (@pxref{Waiting}).  Раннее
соглашение о вызовах осуждается, как это:

@example
(set-advertised-calling-convention
  'sit-for '(seconds &optional nodisp) "22.1")
@end example
@end defun

@node Inline Functions
@section Встроенные Функции
@cindex inline functions

  @dfn{Встроенная функция} это функция, которая работает так же, как обычная
  функция, за исключением одной вещи: при байт-компиляции вызов функции
  (@pxref{Byte Compilation}) расширяет определение функции в вызывающей
  программе.  Для того, чтобы определить встроенную функцию, используется
  @code{defsubst} вместо @code{defun}. (ВопросFunctions2131)

@defmac defsubst name args [doc] [declare] [interactive] body@dots{}
Макрос определяет встроенную функцию.  Синтаксис точно такой же, как
у @code{defun} (@pxref{Defining Functions}).
@end defmac

  Создание встроенной функции часто позволяет выполнять вызов функции
  быстрее.  Это также имеет свои недостатки.  С одной стороны, это снижает
  гибкость; если изменить определение функции, встроенные вызовы используют
  раннее определение функции, пока не перекомпилировать снова определение.

  Другим недостатком является то, что создание большой встраиваемой функция
  может увеличить размер скомпилированного кода, как в файлах, так и в
  памяти.  Поскольку преимущество в скорости встроенных функций является
  наибольшим для малых функций, вообще не следует делать большие функции
  встроенными.

  Кроме того, встроенные функции не хорошо ведут себя в отношении отладки,
  трассировки и рекомендаций (@pxref{Advising Functions}).  Лёгкость отладки
  и гибкостью переопределения функций являются важными особенностями Emacs,
  не следует делать функцию втроенной, даже если она маленькая и если её
  скорость не очень важна. Перед тем как сделать функцию встроенной,
  требуется проанальзировать показатели выполнения кода с помощью
  @code{defun} и убедиться о наличии проблемы с производительностью.

  После того, как встроенная функция определена, её встроенное расширение
  может быть выполнено позже в том же файле, так же, как расширение макроса.

  Можно использовать определение макроса @code{defmacro} для расширения кода,
  который встроенная функция будет выполнять (@pxref{Macros}).  Но макрос
  будет ограничен прямым использованием в выражениях --- макрос не может быть
  вызван с @code{apply}, @code{mapcar} и так далее.  Кроме того, это
  добавляет определенную работу, чтобы превратить обычную функцию в макрос.
  Для того, чтобы преобразовать в встроенную функции легко; просто заменить
  @code{defun} на @code{defsubst}.  Так как каждый аргумент встроенной
  функции оценивается ровно один раз, вам не нужно беспокоиться о том,
  сколько раз тело использует аргументы, также как это делается для макросов.

  В качестве альтернативы @code{defsubst}, можно использовать
  @code{define-inline} для определения функций с помощью
  макроса компилятора.  @xref{Defining Functions, define-inline}.

@node Declare Form
@section Форма @code{declare}
@findex declare

  @code{declare} специальный макрос, который может быть использован для
  добавления мета-свойств функции или макроса: например, пометить его как
  устаревший, или добавить его формам специальное соглашение об отстуах
  @key{TAB} в Emacs Lisp режиме.

@anchor{Definition of declare}
@defmac declare specs@dots{}
Макрос игнорирует аргументы и возвращает значение @code{nil}; он не имеет
эффекта во время выполнения.  Тем не менее, когда форма @code{declare}
встречается в аргументе @var{declare} функции определения @code{defun} или
@code{defsubst} (@pxref{Defining Functions}) или при определении макроса
@code{defmacro} (@pxref{Defining Macros}), это добавляет свойства,
определенные спецификацией @var{specs} к функции или макросу.  Эта работа
выполняется специально @code{defun}, @code{defsubst}, и @code{defmacro}.

Каждый элемент @var{specs} должен иметь форму вида
@code{(@var{property} @var{args}@dots{})}, которая не должна цитироваться.
Имются следующие эффекты:

@table @code
@item (advertised-calling-convention @var{signature} @var{when})
Это действует как вызов @code{set-advertised-calling-convention}
(@pxref{Obsolete Functions}); @var{signature} указывает правильный список
аргументов для вызова функции или макроса и условие @var{when} должно быть
строкой, указывающей, когда старый список аргументов стал считаться
устаревшим.

@item (debug @var{edebug-form-spec})
Это справедливо только для макросов.  При выполнении по шагам макроса в
Edebug, используйте @var{edebug-form-spec}.
@xref{Instrumenting Macro Calls}.

@item (doc-string @var{n})
Это используется при определении функции или макроса, которые сами по себе
будет использоваться для определения объектов, таких как функции, макросы или
переменные.  Это указывает на то, что @var{n}ый аргумент, если таковой
имеется, следует рассматривать как строку документации.

@item (indent @var{indent-spec})
Задание отступов вызовы этой функции или макроса в соответствии с
@var{indent-spec}.  Это, как правило, используется для макросов, хотя это
также работает для функций тоже. @xref{Indenting Macros}.
(ВопросFunctions2219)

@item (interactive-only @var{value})
Установка @code{interactive-only} свойству функции значение @var{value}.
@xref{The interactive-only property}.

@item (obsolete @var{current-name} @var{when})
Отмечает функцию или макрос как устаревшую, похоже на вызов
@code{make-obsolete} (@pxref{Obsolete Functions}).  @var{current-name} должно
быть символом (в этом случае, в предупреждение указывается использовать
символ, вместо устаревшей функции), строкой (с указанием предупреждающего
сообщения) или @code{nil} (в этом случае предупреждение не дает никаких
дополнительных деталей).  Условие @var{when} должно быть строкой,
указывающей, когда функция или макрос впервые помечены устаревшими.

@item (compiler-macro @var{expander})
Это может быть использовано только для функций, и указывает компилятору
использовать в качестве функции оптимизации @var{expander}.  При встрече
компилятором вызов функции, вида @code{(@var{function} @var{args}@dots{})},
макрос расширитель будет вызывать @var{expander} с этой формой, а также с
@var{args}@dots{} и @var{expander} может либо вернуть новое выражение для
использования вместо вызова функции, или может вернуть только форму без
изменений, чтобы указать, что вызов функции следует оставить в покое.
@var{expander} может быть символом, или это может быть форма
@code{(lambda (@var{arg}) @var{body})} в этом случае @var{arg} будет
удерживать исходное выражение вызова функции, и (невычисленные) аргументы
функции можно получить с помощью формальных аргументов функции.

@item (gv-expander @var{expander})
Объявляет @var{expander} как функцию для обработки вызовов макроса (или
функции) в качестве обобщенной переменной, аналогично
@code{gv-define-expander}. @var{expander} может быть символом, или может
иметь форму @code{(lambda (@var{arg}) @var{body})} и в этом случае, функция
будет дополнительно иметь доступ к макросу (или функции) 'с аргументамиx.

@item (gv-setter @var{setter})
Объявляет функцию @var{setter} для обработки вызовов макроса (или функции) в
качестве обобщенной переменной.  @var{setter} может быть символом, в этом
случае он будет передан @code{gv-define-simple-setter}, или же может иметь
форму @code{(lambda (@var{arg}) @var{body})}, в этом случае, функция будет
дополнительно иметь доступ к макросу (или функции) 'с аргументами, и будет
передана @code{gv-define-setter}.

@end table

@end defmac

@node Declaring Functions
@section Сообщение Компилятору, что Функция Определена
@cindex function declaration
@cindex declaring functions
@findex declare-function

Байт-компиляция файла часто приводит к предупреждениям о функциях, которые
компилятор не знает (@pxref{Compiler Errors}).  Иногда это указывает на
реальную проблему, но, как правило, рассматриваемые функции определены в
других файлах, которые будут загружены, если этот код выполнится.  Так,
например, байт-компиляции файла @file{simple.el} выводит предупреждения:

@example
simple.el:8727:1:Warning: the function ‘shell-mode’ is not known to be
    defined.
@end example

На самом деле, @code{shell-mode} используется только в функции, которая
выполняет @code{(require 'shell)} перед вызовом @code{shell-mode}, поэтому
@code{shell-mode} будет определена правильно во время выполнения.  Когда
известно, что такое предупреждение не указывает на реальную проблему, его
можно подавить.  Это делает новые предупреждения, которые могут означать
реальные проблемы более заметными.  Делается это с @code{declare-function}.

Все, что вам нужно сделать, это добавить @code{declare-function} заявление
перед первым использованием функции в вопросе:

@example
(declare-function shell-mode "shell" ())
@end example

Это говорит о том, что @code{shell-mode} определяется в @file{shell.el}
(@samp{.el} можно опустить).  Компилятор принимает как само собой
разумеющееся, что этот файл действительно определяет функцию, и не проверяет.

  Необязательный третий аргумент задает список параметров @code{shell-mode}.
  Если опущен, тогда не принимается никаких аргументов (@code{nil} отличается
  от опущенного значения).  В других случаях это может быть что-то вроде
  @code{(file &optional overwrite)}.  Не нужно указывать список аргументов,
  но если это сделано байт-компилятор может проверить, соответствуют ли
  вызовы объявлению.

@defmac declare-function function file &optional arglist fileonly
Указание байт-компилятору считать, что @var{function} определяется в файле
@var{file}.  Необязательный третий аргумент @var{arglist} либо @code{t}, то
есть список аргументов не задан, или список формальных параметров, в том же
стиле, как в @code{defun}.  Пропущенной @var{arglist} по умолчанию @code{t},
не @code{nil}; это нетипичное поведение для опущенных аргументов, и это
означает, что поставить четвертый, но не третий аргумент нужно указав
заполнитель @code{t} для третьего аргумента, вместо обычного @code{nil}.
Необязательные четвертый аргумент @var{fileonly} не-@code{nil} означает
только проверить, что @var{file} существует, не то, что в нём на самом деле
существует определение функции @var{function}.
@end defmac

  Для того, чтобы убедиться, что эти функции действительно объявлены, на что
  указывает @code{declare-function}, используется @code{check-declare-file}
  для проверки всех вызовов @code{declare-function} в одном исходном файле,
  или использовать @code{check-declare-directory}, для проверки всех файлов
  при определенной директории.

  Эти команды находят файл, который должен содержать определение функции
  используя @code{locate-library}; если не находится этот файл, расширяется
  имя файла определения относительно директории файла, который содержит
  вызов @code{declare-function}.

  Также можно указать о том, что функция является примитивной, указав имя
  файла, заканчивающееся на @samp{.c} или @samp{.m}.  Это полезно только при
  вызове примитива, который определяется только на некоторых системах.
  Большинство примитивов всегда определены, поэтому никогда не будет
  предупреждение.

  Иногда файл может использовать функции из внешнего пакета.  Если префикс
  имени файла в операторе @code{declare-function} записан с @samp{ext:}, то
  будет проверено его наличие, в противном случае пропускается без ошибок.

  Есть некоторые определения функций, которые не понимает
  @samp{check-declare} (например, @code{defstruct} и некоторые другие
  макросы).  В таких случаях, вы можете передать не-@code{nil} @var{fileonly}
  аргумент @code{declare-function}, то есть только проверить, что файл
  существует, а не то, что он на самом деле определяет функцию.  Обратите
  внимание, чтобы это без указания списка аргументов, нужно установить
  @var{arglist} аргумент @code{t} (потому что @code{nil} означает пустой
  список аргументов, в отличие от незаданного).

@node Function Safety
@section Определение Безопасного Вызова Функции
@cindex function safety
@cindex safety of functions

Некоторые основные режимы, такие как SES, вызывают функции, которые хранятся
в пользовательских файлах.  (@inforef{Top, ,ses}, для детальной информации
о SES @.)   Пользовательские файлы иногда имеют не достоверные источники
получения --- может быть получена таблица от того, с кем-то только что
познакомились, или можно получить по электронной почте что-то, от того с кем
никогда не встречались.  Так что это рискованно - вызов функции, исходный код
которой хранится в файле пользователя, пока нет определения, что вызов этой
функции безопасен.

@defun unsafep form &optional unsafep-vars
Возвращает @code{nil}, если форма @var{form} это @dfn{безопасное} выражение
Lisp, или возвращает список, который описывает, почему это может быть
небезопасно.  Аргумент @var{unsafep-vars} представляет собой список символов,
которые имеют временные привязки в этой точке; это используется в основном
для внутренних рекурсивных вызовов.  Текущий буфер является неявным
аргументом, который содержит список буфера локальной привязки.
@end defun

Будучи простым и быстрым, @code{unsafep} делает очень легкий анализ и
отвергает многие выражения Lisp, которые на самом деле безопасны.  Нет
известных случаев, когда @code{unsafep} возвращается @code{nil} для
небезопасного выражения.  Однако, безопасное выражение Lisp может возвращать
строку со свойством @code{display}, содержащее связанное с ним выражение Lisp
которое должно быть выполнено после того, как строка будет вставлена в буфер.
Этим связаным выражением может быть вирус.  Для того, чтобы быть в
безопасности, требуется свойства всех строк, вычисленных с помощью кода
пользователя, прежде чем вставить их в буфер.

@ignore
Что такое безопасное выражение Lisp?  В основном, это выражение, вызывающее
только встроенные функции без побочных эффектов (или только безобидные из
 них).  Безобидные побочные эффекты включают в себя отображение сообщений и
 изменение безопасных локальных переменных буфера (но не глобальных
 переменных).

@table @dfn
@item Безопасные выражения
@itemize
@item
Атом или цитируемая форма.
@item
A call to a safe function (see below), if all its arguments are
safe expressions.
@item
Одно из специальных форм @code{and}, @code{catch}, @code{cond}, @code{if},
 @code{or}, @code{prog1}, @code{prog2}, @code{progn}, @code{while}, и
 @code{unwind-protect}], если все их аргументы являются безопасными.
@item
Формы, которые создают временные привязки (@code{condition-case},
@code{dolist}, @code{dotimes}, @code{lambda}, @code{let}, или
@code{let*}), если все аргументы являются безопасными и символы, которые
ими должны быть связаны известны как безопасные
(@pxref{File Local Variables}).
@item
Формы привязки, использующие @code{add-to-list}, @code{setq}, @code{push},
или @code{pop}, если все аргументы являются безопасными и символы, которые
должны быть назначен явно безопасные, и они уже имеют временные или
локальные привязки буфера.
@item
Один из [apply, mapc, mapcar, mapconcat], если первый аргумент является
явно безопасным лямбда а другие аргументы являются безопасными выражениями.
@end itemize

@item Безопасные Функции
@itemize
@item
Лямбда выражение, содержащее безопасные выражения.
@item
Символ добавлен пользователем в список @code{safe-functions}, что указывает
на то, что это безопасно.
@item
Символ со свойством не-@code{nil} @code{side-effect-free}.
@item
Символ со свойством не-@code{nil} @code{safe-function}.  Значение @code{t}
 обозначает функцию, которая является безопасной, но имеет безвредные
 побочные эффекты.  Другие значения будут когда-нибудь указывают на функции
 с классами побочных эффектов, которые не всегда безопасны.
@end itemize

Свойства @code{side-effect-free} и @code{safe-function} предусмотрены
встроенными функциями и функциями низкого уровня и макросами, определенными
в файле @file{subr.el}.  Можно задать эти свойства для функций, которые вы
 пишете.
@end table
@end ignore

@node Related Topics
@section Другие Темы, Связанные с Функциями

  Вот таблица из нескольких функций, которые выполняют действия, связанные с
  вызовом и определением функций.  Они задокументированы в другом месте
  руководства, но предлагаются перекрестные ссылки на них.

@table @code
@item apply
Смотреть @ref{Calling Functions}.

@item autoload
Смотреть @ref{Autoload}.

@item call-interactively
Смотреть @ref{Interactive Call}.

@item called-interactively-p
Смотреть @ref{Distinguish Interactive}.

@item commandp
Смотреть @ref{Interactive Call}.

@item documentation
Смотреть @ref{Accessing Documentation}.

@item eval
Смотреть @ref{Eval}.

@item funcall
Смотреть @ref{Calling Functions}.

@item function
Смотреть @ref{Anonymous Functions}.

@item ignore
Смотреть @ref{Calling Functions}.

@item indirect-function
Смотреть @ref{Function Indirection}.

@item interactive
Смотреть @ref{Using Interactive}.

@item interactive-p
Смотреть @ref{Distinguish Interactive}.

@item mapatoms
Смотреть @ref{Creating Symbols}.

@item mapcar
Смотреть @ref{Mapping Functions}.

@item map-char-table
Смотреть @ref{Char-Tables}.

@item mapconcat
Смотреть @ref{Mapping Functions}.

@item undefined
Смотреть @ref{Functions for Key Lookup}.
@end table
