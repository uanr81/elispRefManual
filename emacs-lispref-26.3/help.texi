@c -*- mode: texinfo; coding: utf-8 -*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2019 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Documentation
@chapter Документация
@cindex documentation strings

  GNU Emacs имеет удобные встроенные средства справки, большинство из
которых получают информацию из строк документации, связанных с функциями и
переменными.  В этой главе описывается, как получить доступ к строкам
документации в программах на Lispе.

  Содержимое строки документации должно соответствовать определенным
соглашениям.  В частности, первая строка должна быть полным предложением
(или двумя полными предложениями), в котором кратко описывается, что делает
функция или переменная.  @xref{Documentation Tips}, как писать хорошие
строки документации.

  Обратить внимание, что строки документации для Emacs - это не то же самое,
что и руководство по Emacs.  Руководства имеют свои собственные исходные
файлы, написанные на языке Texinfo; Строки документации указаны в
определениях функций и переменных, к которым они применяются.  Сбора строк
документации недостаточно в качестве руководства, потому что хорошее
руководство не организовано таким образом; оно организован по темам
обсуждения.

  Информацию о командах для отображения строк документации смотреть в
  разделе @ref{Help, , Help, emacs, The GNU Emacs Manual}.

@menu
* Documentation Basics::      Где строки документа определены и сохранены.
* Accessing Documentation::   Как программы на Lisp могут обращаться к
                                строкам документации.
* Keys in Documentation::     Замена текущих привязок ключей.
* Text Quoting Style::        Кавычки в строках документов и сообщениях.
* Describing Characters::     Создание печатных описаний непечатаемых
                                символов и последовательностей ключей.
* Help Functions::            Подпрограммы, используемые средствами
                                справки Emacs.
@end menu

@node Documentation Basics
@section Основы Документации
@cindex documentation conventions
@cindex writing a documentation string
@cindex string, writing a doc string

  Строка документации записывается с использованием синтаксиса Lisp для
строк с символами двойных кавычек, окружающими текст.  Фактически, это
настоящая строка Lisp.  Когда строка появляется в нужном месте в определении
функции или переменной, она служит документацией для функции или переменной.

@cindex @code{function-documentation} property
  В определении функции (форма @code{lambda} или @code{defun}) строка
документации указывается после списка аргументов и обычно сохраняется
непосредственно в объекте функции.  @xref{Function Documentation}.  Также
можно поместить документацию по функциям в свойство
@code{function-documentation} имени функции
(@pxref{Accessing Documentation}).

@cindex @code{variable-documentation} property
  В определении переменной (форма @code{defvar}) строка документации
указывается после начального значения.  @xref{Defining Variables}.  Строка
хранится в свойстве переменной @code{variable-documentation}.

@cindex @file{DOC} (documentation) file
  Иногда Emacs не хранит строки документации в памяти.  Таких обстоятельств
два.  Во-первых, для экономии памяти документация для предварительно
загруженных функций и переменных (включая примитивы) хранится в файле с
именем @file{DOC} в каталоге, заданном параметром @code{doc-directory}
(@pxref{Accessing Documentation}).  Во-вторых, когда функция или переменная
загружается из файла с байт компиляцией, Emacs избегает загрузки строки
документации (@pxref{Docs and Compilation}).  В обоих случаях Emacs ищет
строку документации из файла только при необходимости, например, когда
пользователь вызывает @kbd{C-h f} (@code{describe-function}) для функции.

  Строки документации могут содержать специальные
@dfn{замены ключевых последовательностей}, относящийся к привязкам ключей,
которые просматриваются только тогда, когда пользователь просматривает
документацию.  Это позволяет командам справки отображать правильные ключи,
даже если пользователь изменяет привязки ключей по умолчанию.
@xref{Keys in Documentation}.

  В строке документации автоматически загружаемой команды (@pxref{Autoload})
эти последовательности подстановки ключей имеют дополнительный специальный
эффект: они заставляют @kbd{C-h f} в команде запускать автозагрузку.  (Это
необходимо для правильной настройки гиперссылок в буфере @file{*Help*}.)

@node Accessing Documentation
@section Доступ к Строкам Документации
@cindex accessing documentation strings

@defun documentation-property symbol property &optional verbatim
Эта функция возвращает строку документации, записанную в списке свойств
@var{symbol} под свойством @var{property}.  Чаще всего используется для
поиска строк документации с переменными, для которых @var{property} равно
@code{variable-documentation}.  Однако его также можно использовать для
поиска других видов документации, например, для групп настройки (но для
документации по функциям используйте функцию @code{documentation} ниже).

Если значение свойства относится к строке документации, хранящейся в файле
@file{DOC} или в байтовом скомпилированном файле, эта функция ищет эту
строку и возвращает ее.

Если значение свойства не-@code{nil}, не является строкой и не ссылается на
текст в файле, то оно оценивается как выражение Lisp для получения строки.

Наконец, эта функция передает строку через @code{substitute-command-keys}
для замены привязки ключей (@pxref{Keys in Documentation}).  Этот шаг
пропускается, если @var{verbatim} равно не-@code{nil}.

@smallexample
@group
(documentation-property 'command-line-processed
   'variable-documentation)
     @result{} "не-nil после обработки командной строки"
@end group
@group
(symbol-plist 'command-line-processed)
     @result{} (variable-documentation 188902)
@end group
@group
(documentation-property 'emacs 'group-documentation)
     @result{} "Настройка One True Editor."
@end group
@end smallexample
@end defun

@defun documentation function &optional verbatim
Эта функция возвращает строку документации @var{function}.  Обрабатывает
макросы, именованные макросы клавиатуры и специальные формы, а также обычные
функции.

Если @var{function} является символом, эта функция сначала ищет свойство
@code{function-documentation} этого символа; если это имеет значение
не-@code{nil}, документация исходит из этого значения (если значение не
является строкой, оно оценивается).

Если @var{function} не является символом или у него нет свойства
@code{function-documentation}, тогда @code{documentation} извлекает строку
документации из фактического определения функции, считывая ее из файла, если
это необходимо.

Наконец, если @var{verbatim} не не-@code{nil}, эта функция вызывает
@code{substitute-command-keys}.  Результат - строка документации, которую
нужно вернуть.

Функция @code{documentation} сигнализирует об ошибке @code{void-function},
если @var{function} не имеет определения функции.  Однако это нормально,
если в определении функции нет строки документации.  В этом случае
@code{documentation} возвращает @code{nil}.
@end defun

@defun face-documentation face
Эта функция возвращает строку документации @var{face} как вид.
@end defun

Вот пример использования двух функций, @code{documentation} и
@code{documentation-property}, для отображения строк документации для
нескольких символов в буфере @file{*Help*}.

@anchor{describe-symbols example}
@smallexample
@group
(defun describe-symbols (pattern)
  "Опишите символы Emacs Lisp, соответствующие PATTERN.
Все символы, в названии которых есть PATTERN, описываются в буфере *Help*."
  (interactive "sОпишите соответствие символов: ")
  (let ((describe-func
         (function
          (lambda (s)
@end group
@group
            ;; @r{Распечатать описание символа.}
            (if (fboundp s)             ; @r{Это функция.}
                (princ
                 (format "%s\t%s\n%s\n\n" s
                   (if (commandp s)
                       (let ((keys (where-is-internal s)))
                         (if keys
                             (concat
                              "Keys: "
                              (mapconcat 'key-description
                                         keys " "))
                           "Keys: none"))
                     "Function")
@end group
@group
                   (or (documentation s)
                       "not documented"))))

            (if (boundp s)              ; @r{Это переменная.}
@end group
@group
                (princ
                 (format "%s\t%s\n%s\n\n" s
                   (if (custom-variable-p s)
                       "Option " "Variable")
@end group
@group
                   (or (documentation-property
                         s 'variable-documentation)
                       "not documented")))))))
        sym-list)
@end group

@group
    ;; @r{Составьте список символов, соответствующих шаблону.}
    (mapatoms (function
               (lambda (sym)
                 (if (string-match pattern (symbol-name sym))
                     (setq sym-list (cons sym sym-list))))))
@end group

@group
    ;; @r{Отобразите данные.}
    (help-setup-xref (list 'describe-symbols pattern) (interactive-p))
    (with-help-window (help-buffer)
      (mapcar describe-func (sort sym-list 'string<)))))
@end group
@end smallexample

  Функция @code{describe-symbols} работает так же, как @code{apropos}, но
предоставляет больше информации.

@smallexample
@group
(describe-symbols "goal")

---------- Buffer: *Help* ----------
goal-column     Option
Semipermanent goal column for vertical motion, as set by @dots{}
@end group
@c Не разрывайте и не заполняйте эти строки беспечно.
@c Это делает их неправильными.

@group
minibuffer-temporary-goal-position      Переменная
не задокументировано
@end group

@group
set-goal-column Keys: C-x C-n
Установить текущее положение по горизонтали как цель для C-n и C-p.
@end group
@c НЕ ставить здесь пустую строку! Это фактически неточно!
@group
Эти команды переместятся в это положение в перемещенной строке, вместо того,
чтобы пытаться сохранить то же положение по горизонтали. С аргументом не-nil
ARG очищает столбец цели, так что C-n и C-p возобновляет вертикальное
движение.  Столбец цели хранится в переменной ‘goal-column’.

(fn ARG)
@end group

@group
temporary-goal-column   Переменная
Столбец текущей цели для вертикального движения.  Это столбец, в котором
точка была в начале текущего выполнения команд вертикального перемещения.

При перемещении по визуальным линиям с помощью функции ‘line-move-visual’
это cons-ячейка (COL . HSCROLL), где COL - координата x в пикселях, деленная
на ширину столбца по умолчанию, а HSCROLL - количество столбцов, на которые
окно прокручивается от левого края.

Когда функция ‘track-eol’ выполняет свою работу, значение равно
‘most-positive-fixnum’..
---------- Buffer: *Help* ----------
@end group
@end smallexample

@anchor{Definition of Snarf-documentation}
@defun Snarf-documentation filename
Эта функция используется при сборке Emacs непосредственно перед сбросом
работающего Emacs.  Находит позиции строк документации, хранящихся в файле
@var{filename}, и записывает эти позиции в память в определениях функций и
списках свойств переменных.  @xref{Building Emacs}.

Emacs читает файл @var{filename} из каталога @file{emacs/etc}.  Когда позже
будет запущен выгруженный Emacs, этот же файл будет искать в каталоге
@code{doc-directory}.  Обычно @var{filename} - это @code{"DOC"}.
@end defun

@defvar doc-directory
Эта переменная содержит имя каталога, в котором должен находиться файл
@code{"DOC"}, содержащий строки документации для встроенных и предварительно
загруженных функций и переменных.

В большинстве случаев это то же самое, что и @code{data-directory}.  Могут
отличаться, когда запускается Emacs из каталога, в котором его создали, без
фактической установки.  @xref{Definition of data-directory}.
@end defvar

@node Keys in Documentation
@section Подстановка Привязок Клавиш в Документации
@cindex documentation, keys in
@cindex keys in documentation strings
@cindex substituting keys in documentation
@cindex key substitution sequence

  Когда строки документации относятся к последовательностям ключей, они
должны использовать текущие фактические привязки ключей.  Могут сделать это
с помощью определенных специальных текстовых последовательностей, описанных
ниже.  При доступе к строкам документации обычным способом эти специальные
последовательности заменяются текущей информацией о привязке ключей.  Это
работает путем вызова @code{substitute-command-keys}.  Также можно вызвать
эту функцию самостоятельно.

  Вот список специальных последовательностей и их значение:

@table @code
@item \[@var{command}]
означает последовательность ключей, которая будет вызывать @var{command}
или @samp{M-x @var{command}} если @var{command} не имеет привязки ключей.

@item \@{@var{mapvar}@}
обозначает сводку ключевой карты, которая является значением переменной
@var{mapvar}.  Сводка сделана с использованием @code{describe-bindings}.

@item \<@var{mapvar}>
означает отсутствие текста.  Используется только для побочного эффекта:
указывает значение @var{mapvar} в качестве таблицы ключей для любых
следующих последовательностей @samp{обр[@var{command}]} в этой строке
документации.

@item `
(серьезное ударение) означает левую цитату.  Это создает левую одинарную
кавычку, апостроф или серьезное ударение в зависимости от значения
@code{text-quoting-style}.  @xref{Text Quoting Style}.

@item '
(апостроф) означает правильную цитату.  Это создает правую одинарную кавычку
или апостроф в зависимости от значения @code{text-quoting-style}.

@item \=
заключает в кавычки следующий символ и отбрасывается; таким образом,
@samp{\=`} помещает @samp{`} в вывод, @samp{\=\[} помещает @samp{\[} в
вывод, а @samp{\=\=} помещает @samp{\=} в вывод.
@end table

@strong{Пожалуйста, обратить внимание:} Каждый @samp{\} должен быть удвоен
при записи в строку в Emacs Lisp.

@defopt text-quoting-style
@cindex curved quotes
@cindex curly quotes
Значение этой переменной - это символ, который определяет стиль, который
Emacs должен использовать для одинарных кавычек в формулировках справки и
сообщений.  Если значение переменной - @code{curve}, стиль - @t{‘like this’}
с изогнутыми одинарными кавычками.  Если значение равно @code{straight},
используется стиль @t{'like this'} с прямыми апострофами.  Если значение -
@code{grave}, кавычки не переводятся, а стиль - @t{`like this'} с серьезным
ударением и апострофом, стандартный стиль до версии Emacs 25.  Значение по
умолчанию @code{nil} действует как @code{curve}, если изогнутые одинарные
кавычки кажутся отображаемыми, и как @code{grave} в противном случае.

Эта опция полезна на платформах, у которых есть проблемы с изогнутыми
кавычками.  Можно свободно настроить в соответствии с личными
предпочтениями.
@end defopt

@defun substitute-command-keys string
Эта функция сканирует @var{string} на наличие указанных выше специальных
последовательностей и заменяет их тем, что они обозначают, возвращая
результат в виде строки.  Это позволяет отображать документацию, которая
точно относится к привязкам ключей, настроенным пользователем.

@cindex advertised binding
Если команда имеет несколько привязок, эта функция обычно использует первую
найденную.  Можно указать одну конкретную привязку ключей, присвоив команде
свойство символа @code{:advertised-binding}, например:

@smallexample
(put 'undo :advertised-binding [?\C-/])
@end smallexample

@noindent
Свойство @code{:advertised-binding} также влияет на привязку, отображаемую в
пунктах меню (@pxref{Menu Bar}).  Свойство игнорируется, если оно указывает
привязку ключей, которой фактически нет у команды.
@end defun

  Вот примеры специальных последовательностей:

@smallexample
@group
(substitute-command-keys
   "Чтобы прервать рекурсивное редактирование, введите `\\[abort-recursive-edit]'.")
@result{} "Чтобы прервать рекурсивное редактирование, введите ‘C-]’."
@end group

@group
(substitute-command-keys
   "Ключи, которые определены для минибуфера здесь:
  \\@{minibuffer-local-must-match-map@}")
@result{} "Ключи, которые определены для минибуфера здесь:
@end group

?               minibuffer-completion-help
SPC             minibuffer-complete-word
TAB             minibuffer-complete
C-j             minibuffer-complete-and-exit
RET             minibuffer-complete-and-exit
C-g             abort-recursive-edit
"

@group
(substitute-command-keys
   "Чтобы отменить рекурсивное редактирование из минибуфера, введите \
`\\<minibuffer-local-must-match-map>\\[abort-recursive-edit]'.")
@result{} "Чтобы отменить рекурсивное редактирование из минибуфера, введите ‘C-g’."
@end group
@end smallexample

  Существуют и другие специальные соглашения для текста в строках
документации - например, можно ссылаться на функции, переменные и разделы
этого руководства.  @xref{Documentation Tips}, для деталей.

@node Text Quoting Style
@section Text Стиль Цитирования

  Обычно серьезные акценты и апострофы обрабатываются специально в строках
документации и диагностических сообщениях и переводятся в соответствующие
одинарные кавычки (также называемые ``curved quotes'').  Например, строка
документации @t{"Псевдоним для `foo'."} и вызов функции
@code{(message "Псевдоним для `foo'.")} преобразуются в
@t{"Псевдоним для ‘foo’."}.  Реже Emacs отображает серьезные акценты и
апострофы как сами по себе, или только как апострофы (например,
@t{"Псевдоним для 'foo'."}).  Строки документации и форматы сообщений должны
быть написаны так, чтобы они хорошо отображались с любым из этих стилей.
Например, строка документации @t{"Псевдоним для 'foo'."}, вероятно, не то,
что нужно, поскольку она может отображаться как @t{"Псевдоним для ’foo’."},
необычный стиль на английском языке.

  Иногда может потребоваться использовать серьезное ударение или апостроф
без перевода, независимо от стиля цитирования текста.  В строке документации
можно сделать это с помощью escape-символов.  Например, в строке
документации @t{"\\=`(a ,(sin 0)) ==> (a 0.0)"} серьезный акцент
предназначен для обозначения кода Lisp, поэтому он экранирован и
отображается как сам, независимо от стиля цитирования.  При вызове
@code{message} или @code{error} можно избежать перевода, используя формат
@t{"%s"} с аргументом, который является вызовом @code{format}.  Например,
@code{(message "%s" (format "`(a ,(sin %S)) ==> (a %S)" x (sin x)))}
отображает сообщение, которое начинается с серьезного акцента независимо от
стиля цитирования текста.

@defopt text-quoting-style
@cindex curved quotes
@cindex curly quotes
Значение этой пользовательской опции - это символ, который указывает стиль,
который Emacs должен использовать для одинарных кавычек в формулировках
справки и сообщений.  Если значение параметра - @code{curve}, стиль -
@t{‘like this’} с изогнутыми одинарными кавычками.  Если значение -
@code{straight}, стиль - @t{'like this'} с прямыми апострофами.  Если
значение равно @code{grave}, кавычки не переводятся, а стиль -
@t{`like this'} с серьезным ударением и апострофом, стандартный стиль до
версии Emacs 25.  Значение по умолчанию @code{nil} действует как
@code{curve}, если изогнутые одинарные кавычки кажутся отображаемыми, и как
@code{grave} в противном случае.

Эта опция полезна на платформах, у которых есть проблемы с изогнутыми
кавычками.  Можно свободно настроить в соответствии с личными
предпочтениями.
@end defopt

@node Describing Characters
@section Описание Символов для Справочных Сообщений
@cindex describe characters and events

  Эти функции преобразуют события, последовательности ключей или символы в
текстовые описания.  Эти описания полезны для включения в сообщения
произвольных текстовых символов или последовательностей ключей, поскольку
они преобразуют непечатаемые символы и символы пробелов в последовательности
печатаемых символов.  Описание печатного символа без пробелов - это сам
символ. 

@defun key-description sequence &optional prefix
@cindex Emacs event standard notation
Эта функция возвращает строку, содержащую стандартную нотацию Emacs для
событий ввода в @var{sequence}.  Если @var{prefix} равен не-@code{nil}, это
последовательность входных событий, ведущих к @var{sequence}, и включается в
возвращаемое значение.  Оба аргумента могут быть строками, векторами или
списками.  @xref{Input Events}, для получения дополнительной информации о
действующих событиях.

@smallexample
@group
(key-description [?\M-3 delete])
     @result{} "M-3 <delete>"
@end group
@group
(key-description [delete] "\M-3")
     @result{} "M-3 <delete>"
@end group
@end smallexample

  Смотреть также примеры для @code{single-key-description} ниже.
@end defun

@defun single-key-description event &optional no-angles
@cindex event printing
@cindex character printing
@cindex control character printing
@cindex meta character printing
Эта функция возвращает строку, описывающую @var{event} в стандартной нотации
Emacs для ввода с клавиатуры.  Обычный печатный символ отображается сам по
себе, но управляющий символ превращается в строку, начинающуюся с @samp{C-},
метасимвол превращается в строку, начинающуюся с @samp{M-}, пробел,
табуляция и так далее, отображаются как @samp{SPC}, @samp{TAB} и так далее.
Функциональная клавиша внутри угловых скобок появляется символ
@samp{<@dots{}>}.  Событие, представляющее собой список, отображается как
имя символа в @sc{car} списка внутри угловых скобок.

Если необязательный аргумент @var{no-angles} - не-@code{nil}, угловые скобки
вокруг функциональных клавиш и символов событий опускаются; это сделано для
совместимости со старыми версиями Emacs, в которых скобки не использовались.

@smallexample
@group
(single-key-description ?\C-x)
     @result{} "C-x"
@end group
@group
(key-description "\C-x \M-y \n \t \r \f123")
     @result{} "C-x SPC M-y SPC C-j SPC TAB SPC RET SPC C-l 1 2 3"
@end group
@group
(single-key-description 'delete)
     @result{} "<delete>"
@end group
@group
(single-key-description 'C-mouse-1)
     @result{} "<C-mouse-1>"
@end group
@group
(single-key-description 'C-mouse-1 t)
     @result{} "C-mouse-1"
@end group
@end smallexample
@end defun

@defun text-char-description character
Эта функция возвращает строку, описывающую @var{character} в стандартной
нотации Emacs для символов, которые могут появляться в тексте --- аналогично
@code{single-key-description}, за исключением того, что аргумент должен быть
допустимым кодом символа, который проходит проверку @code{characterp}
(@pxref{Character Codes}).  Функция создает описания управляющих символов с
начальным знаком вставки (именно так Emacs обычно отображает управляющие
символы в буферах).  Символы с битами модификатора заставят эту функцию
сигнализировать об ошибке (символы @acronym{ASCII} с модификатором Control
являются исключением, они представлены как управляющие символы).

@smallexample
@group
(text-char-description ?\C-c)
     @result{} "^C"
@end group
@group
(text-char-description ?\M-m)
     @error{} Wrong type argument: characterp, 134217837
@end group
@end smallexample
@end defun

@deffn Command read-kbd-macro string &optional need-vector
Эта функция используется в основном для работы с макросами клавиатуры, но ее
также можно использовать как грубую инверсию для @code{key-description}.
Вызывается со строкой, содержащей описания ключей, разделенные пробелами;
возвращает строку или вектор, содержащий соответствующие события.  (Это
может быть или не быть единственной допустимой последовательностью ключей, в
зависимости от того, какие события используются; @pxref{Key Sequences}.)
Если @var{need-vector} - не-@code{nil}, возвращаемое значение всегда
является вектором.
@end deffn

@node Help Functions
@section Функции Помощи
@cindex help functions

  Emacs предоставляет множество встроенных функций справки, все из которых доступны пользователю как подкоманды с префиксом @kbd{C-h}.  Для получения дополнительной информации о них, смотреть
@ref{Help, , Help, emacs, The GNU Emacs Manual}.  Здесь описываются
некоторые интерфейсы программного уровня к той же информации.

@deffn Command apropos pattern &optional do-all
Эта функция находит все значимые символы, имена которых совпадают с шаблоном
apropos @var{pattern}.  Шаблон apropos - это либо слово для сопоставления,
список слов, разделенных пробелами, из которых не менее двух должны
совпадать, либо регулярное выражение (если встречаются какие-либо
специальные символы регулярного выражения).  Символ имеет значение, если он
имеет определение как функция, переменная или грань или имеет свойства.

Функция возвращает список элементов, которые выглядят так:

@example
(@var{symbol} @var{score} @var{function-doc} @var{variable-doc}
 @var{plist-doc} @var{widget-doc} @var{face-doc} @var{group-doc})
@end example

Здесь @var{score} - это целочисленная мера того, насколько важным символ
кажется совпадением.  Каждый из оставшихся элементов представляет собой
строку документации или @code{nil} для @var{symbol} как функции, переменной
и так далее.

Также отображает символы в буфере с именем @file{*Apropos*}, каждый с
однострочным описанием, взятым из начала его строки документации.

Если @var{do-all} - не-@code{nil} или пользовательская опция
@code{apropos-do-all} - не-@code{nil}, то @code{apropos} также показывает
привязки ключей для найденных функций; также показывает интернированные
символы @emph{all}, а не только значимые (и он также перечисляет их в
возвращаемом значении).
@end deffn

@defvar help-map
Значение этой переменной - это локальная карта для символов, следующих за
ключём справки @kbd{C-h}.
@end defvar

@deffn {Prefix Command} help-command
Этот символ не является функцией; его ячейка определения функции содержит
ключевую карту, известную как @code{help-map}.  Определяется в
@file{help.el} следующим образом:

@smallexample
@group
(define-key global-map (string help-char) 'help-command)
(fset 'help-command help-map)
@end group
@end smallexample
@end deffn

@defopt help-char
Значением этой переменной является символ справки - символ, который Emacs
распознает как означающий справку.  По умолчанию его значение равно 8, что
означает @kbd{C-h}.  Когда Emacs читает этот символ, если @code{help-form}
является выражением Lisp оцениваемый в не-@code{nil}, он вычисляет это
выражение и отображает результат в окне, если это строка.

Обычно значение @code{help-form} равно @code{nil}.  Тогда символ справки не
имеет особого значения на уровне ввода команды и становится частью
последовательности ключей обычным образом.  Стандартная привязка ключей
@kbd{C-h} - это префиксный ключ для нескольких функций справки общего
назначения.

Символ справки также является специальным после префиксных ключей.  Если у
него нет привязки в качестве подкоманды префиксного ключа, он запускает
@code{describe-prefix-bindings}, который отображает список всех подкоманд
префиксного ключа.
@end defopt

@defopt help-event-list
Значение этой переменной представляет собой список типов событий, которые
служат альтернативными символами справки.  Эти события обрабатываются так
же, как событие, указанное в @code{help-char}.
@end defopt

@defvar help-form
Если эта переменная - не-@code{nil}, ее значение - это форма для оценки при
чтении символа @code{help-char}.  Если при вычислении формы получается
строка, эта строка отображается.

Команда, вызывающая @code{read-event}, @code{read-char-choice} или
@code{read-char}, вероятно, должна связать @code{help-form} с выражением
не-@code{nil} во время ввода.  (Не следует этого делать, когда @kbd{C-h}
имеет другое значение.)  В результате вычисления этого выражения должна
получиться строка, объясняющая, для чего предназначен ввод и как его
правильно ввести.

Запись в минибуфер связывает эту переменную со значением
@code{minibuffer-help-form} (@pxref{Definition of minibuffer-help-form}).
@end defvar

@defvar prefix-help-command
Эта переменная содержит функцию для вывода справки по префиксному ключу.
Функция вызывается, когда пользователь вводит префиксную клавишу, за которой
следует символ справки, а символ справки не имеет привязки после этого
префикса.  Значение переменной по умолчанию @code{describe-prefix-bindings}.
@end defvar

@deffn Command describe-prefix-bindings
Эта функция вызывает @code{describe-bindings} для отображения списка всех
подкоманд префиксного ключа самой последней последовательности клавиш.
Описанный префикс состоит из всего, кроме последнего события этой
последовательности ключей.  (Последнее событие - предположительно
вспомогательный персонаж.)
@end deffn

  Следующие две функции предназначены для режимов, в которых требуется
помощь без отказа от управления, например для электрических режимов.  Их
имена начинаются с @samp{Helper}, чтобы отличать их от обычных функций
помощи.

@deffn Command Helper-describe-bindings
Эта команда открывает окно с буфером справки, содержащим список всех
привязок ключей как из локальной, так и из глобальной карты ключей.
Работает, вызывая @code{describe-bindings}.
@end deffn

@deffn Command Helper-help
Эта команда предоставляет справку для текущего режима.  Запрашивает
пользователя в минибуфере с сообщением
@samp{Help (Type ? for further options)}, а затем оказывает помощь в
выяснении того, какие привязки ключей и для чего предназначен режим.
Возвращает @code{nil}.

@vindex Helper-help-map
Это можно настроить, изменив карту @code{Helper-help-map}.
@end deffn

@defvar data-directory
@anchor{Definition of data-directory}
Эта переменная содержит имя каталога, в котором Emacs находит определенную
документацию и текстовые файлы, поставляемые с Emacs.
@end defvar

@defun help-buffer
Эта функция возвращает имя буфера помощи, обычно @file{*Help*}; если такой
буфер не существует, он сначала создается.
@end defun

@vindex help-window-select
@defmac with-help-window buffer-or-name body@dots{}
Этот макрос оценивает @var{body} как @code{with-output-to-temp-buffer}
(@pxref{Temporary Displays}), вставляя любой вывод, созданный его формами, в
буфер, указанный @var{buffer-or-name}, который может быть буфером или именем
буфера.  (Часто @var{buffer-or-name} - это значение, возвращаемое функцией
@code{help-buffer}.)  Этот макрос переводит указанный буфер в режим справки
и отображает сообщение, сообщающее пользователю, как выйти и прокрутить окно
справки.  Выбирает окно справки, если текущее значение пользовательской
опции @code{help-window-select} было установлено соответствующим образом.
Возвращает последнее значение в @var{body}.
@end defmac

@defun help-setup-xref item interactive-p
Эта функция обновляет данные перекрестных ссылок в буфере @file{*Help*},
который используется для восстановления справочной информации, когда
пользователь нажимает кнопки @samp{Back} или @samp{Forward}.  Большинство
команд, использующих буфер @file{*Help*}, должны вызывать эту функцию перед
очисткой буфера.  Аргумент @var{item} должен иметь вид
@code{(@var{function} . @var{args})}, где @var{function} - функция, которую
нужно вызвать со списком аргументов @var{args} для восстановления буфера
справки.  Аргумент @var{interactive-p} - не-@code{nil}, если вызывающая
команда вызывалась в интерактивном режиме; в этом случае очищается стопка
элементов для кнопок @samp{Back} буфера @file{*Help*}.
@end defun

@xref{describe-symbols example}, для примера использования
@code{help-buffer}, @code{with-help-window}, и @code{help-setup-xref}.

@defmac make-help-screen fname help-line help-text help-map
Этот макрос определяет команду справки с именем @var{fname}, которая
действует как префиксный ключ, отображающий список предлагаемых подкоманд.

При вызове @var{fname} отображает @var{help-text} в окне, затем читает и
выполняет последовательность ключей в соответствии с @var{help-map}.  Строка
@var{help-text} должна описывать привязки, доступные в @var{help-map}.

Команда @var{fname} определена для обработки нескольких событий сама путем
прокрутки отображения @var{help-text}.  Когда @var{fname} читает одно из
этих особых событий, выполняется прокрутка, а затем читается другое событие.
Когда читается событие, которое не входит в число этих немногих и имеет
привязку в @var{help-map}, выполняется привязка этого ключа и затем
возвращается.

Аргумент @var{help-line} должен быть однострочным резюме альтернатив в
@var{help-map}.  В текущей версии Emacs этот аргумент используется, только
если установить для параметра @code{three-step-help} значение @code{t}.

Этот макрос используется в команде @code{help-for-help}, которая является
привязкой @kbd{C-h C-h}.
@end defmac

@defopt three-step-help
Если эта переменная - не-@code{nil}, команды, определенные с помощью
@code{make-help-screen}, сначала отображают свои строки @var{help-line} в
эхо-области и отображают более длинные строки @var{help-text} только в том
случае, если пользователь снова набирает символ справки.
@end defopt
