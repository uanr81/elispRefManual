@c -*- mode: texinfo; coding: utf-8 -*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-2019 Free Software Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Display
@chapter Изображение в Emacs

  В этой главе описывается ряд особенностей, связанных с отображением,
  которое Emacs представляет пользователю.

@menu
* Refresh Screen::      Очистка экрана и перерисовка всего на нём.
* Forcing Redisplay::   Принудительное восстановление изображения.
* Truncation::          Соединение и перенос длинных текстовых строк.
* The Echo Area::       Отображение сообщений в нижней части экрана.
* Warnings::            Отображение предупреждений пользователю.
* Invisible Text::      Сокрытие части текста буфера.
* Selective Display::   Сокрытие части текста буфера (старый способ).
* Temporary Displays::  Автоматическое закрытие изображения.
* Overlays::            Использование наложений, чтобы выделить части буфера.
* Size of Displayed Text::  Размер отображаемого текста.
* Line Height::         Контроль высоты строк.
* Faces::               Определение графического стиля для текстовых
                        символов: шрифт, цвет и т.д.
* Fringes::             Управление оконного обрамления.
* Scroll Bars::         Управление полосой прокрутки.
* Window Dividers::     Визуальное разделение окна.
* Display Property::    Включение специальных функций вывода изображения.
* Images::              Отображение изображений в Emacs буфере.
* Xwidgets::            Отображение собственных виджетов Emacs в буферах.
* Buttons::             Добавление интерактивных кнопок Emacs в буферах.
* Abstract Display::    Emacs Коллекция Виджет Объектов.
* Blinking::            Как Emacs показывает парную открывающую скобку.
* Character Display::   Как Emacs отображает отдельные символы.
* Beeping::             Звуковой сигнал для пользователя.
* Window Systems::      Какое окно системы используется.
* Tooltips::            Отображение подсказки в Emacs.
* Bidirectional Display:: Отображение двунаправленных сценариев,
                          таких как арабский и фарси. (ВопросDisplay39)
@end menu

@node Refresh Screen
@section Обновление Экрана
@cindex refresh the screen
@cindex screen refresh

  В функции @code{redraw-frame} очищается и повторно отображатся все
  содержимое определённого кадра (@pxref{Frames}).  Это полезно, если
  вывод на экран испорчен.

@defun redraw-frame &optional frame
Функция очищает и вновь восстанавливает рамку @var{frame}.  Если @var{frame}
опущен или @code{nil}, он перерисовывает текущий кадр.  (ВопросDisplay53)
@end defun

  Еще более мощным средством является @code{redraw-display}:

@deffn Command redraw-display
Функция очищает и вновь восстанавливает все видимые рамки.
@end deffn

  В Emacs обработка пользовательского ввода имеет приоритет над перерисовкой.
  При вызове этих функций при доступном пользовательском вводе, повторное
  отображение не сразу происходит, а только после обработки всего доступного
  ввода пользователя.

  На текстовых терминалах, приостановка и возобновление Emacs обычно также
  обновляет экран.  Некоторые эмуляторы терминала записывают отдельно
  это содержимое программ, ориентированных на отображение, таких как Emacs, и
  для обычного последовательного отображения.  Если используется такой
  терминал, можно препятствовать перерисовки при возобновлении.

@defopt no-redraw-on-reenter
@cindex suspend (cf. @code{no-redraw-on-reenter})
@cindex resume (cf. @code{no-redraw-on-reenter})
Эта переменная управляет перерисовкой Emacs всего экрана после того, как была
приостановка и возобновление.   Установка в не-@code{nil} указвает на то, что
нет необходимости перерисовывать, установка в @code{nil} требует перерисовки.
По умолчанию установлено в @code{nil}.
@end defopt

@node Forcing Redisplay
@section Принудительное Повторное Отображение
@cindex forcing redisplay

  Emacs обычно пытается повторно отобразить экран всякий раз, когда
ожидает ввода.  С помощью следующей функции можно запросить
немедленную попытку повторного отображения в середине кода Lisp,
фактически не дожидаясь ввода.

@defun redisplay &optional force
Функция пытается немедленно возобновить отображение.
Необязательный аргумент @var{force}, если не-@code{nil},
заставляет выполнить повторное отображение вместо
вытеснения, если ввод ожидает.

Функция возвращает @code{t}, если она действительно
пыталась повторно отобразить, и @code{nil} в противном
случае.  Значение @code{t} не означает, что повторное
отображение завершено; это могло быть вытеснено вновь
поступившими данными.
@end defun

  Хотя @code{повторное отображение} пытается немедленно повторно
отобразить, это не меняет того, как Emacs решает, какие части его
кадра(ов) отображать повторно.  В отличие от этого, следующая
функция добавляет определенные окна к отложенной работе
повторного отображения (как если бы их содержимое полностью
изменилось), но не пытается немедленно выполнить повторное
отображение.

@defun force-window-update &optional object
Функция принудительно обновляет некоторые или все окна при следующем
повторном отображении Emacs.  Если @var{object} - это окно, это окно
должно быть обновлено.  Если @var{object} - это буфер или имя буфера,
все окна, отображающие этот буфер, должны быть обновлены.  Если
@var{object} равен @code{nil} (или опущен), все окна должны быть
обновлены.

Функция не выполняет повторное отображение немедленно; Emacs делает
это во время ожидания ввода или при вызове функции @code{redisplay}.
@end defun

@defvar pre-redisplay-function
Функция запускается непосредственно перед повторным отображением.
Вызывается с одним аргументом - набором окон, которые нужно повторно
отобразить.  Набор может быть @code{nil}, что означает только выбранное
окно, или @code{t}, что означает все окна.
@end defvar

@defvar pre-redisplay-functions
Этот перехватчик запускается непосредственно перед повторным отображением.
Вызывается один раз в каждом окне, которое должно быть повторно отображено,
с @code{current-buffer}, установленным для буфера, отображаемого в этом окне.
@end defvar

@node Truncation
@section Усечение
@cindex line wrapping
@cindex line truncation
@cindex continuation lines
@cindex @samp{$} in display
@cindex @samp{\} in display

  Когда строка текста выходит за правый край окна, Emacs может
@dfn{продолжить} эту строку (заставить ее переноситься на следующую
строку экрана) или @dfn{обрезать} строку (ограничить ее одной строкой экрана).
Дополнительные строки экрана, используемые для отображения длинной текстовой
строки, называются строками @dfn{продолжения}.  Продолжение - это не то же
самое, что заполнение; продолжение происходит только на экране, а не в
содержимом буфера, и разбивает строку точно по правому краю, а не по границе
слова.  @xref{Filling}.

   На графическом дисплее крошечные изображения стрелок на краях окон
обозначают усеченные и продолженные линии (@pxref{Fringes}).  На текстовом
терминале @samp{$} в крайнем правом столбце окна указывает на усечение;
@samp{\} в крайнем правом столбце указывает строку, которая переносится.
(В таблице отображения можно указать альтернативные символы, которые будут
использоваться для этого; @pxref{Display Tables}).

@defopt truncate-lines
Если эта локальная в буфере переменная - не-@code{nil}, строки, выходящие
за правый край окна, усекаются; в противном случае они продолжаются.  В
качестве особого исключения переменная @code{truncate-partial-width-windows}
имеет приоритет в окнах @dfn{partial-width} (то есть окнах, которые не занимают
всю ширину кадра).
@end defopt

@defopt truncate-partial-width-windows
@cindex partial-width windows
Переменная управляет усечением строки в окнах @dfn{частичной шириной}.
Окно неполной ширины - это окно, которое не занимает всю ширину кадра
(@pxref{Splitting Windows}).  Если значение равно @code{nil}, усечение
строки определяется переменной @code{truncate-lines} (смотреть выше).
Если значение является целым числом @var{n}, строки обрезаются, если в
окне с неполной шириной меньше столбцов, чем @var{n}, независимо от
значения @code{truncate-lines}; если окно с неполной шириной имеет @var{n}
или более столбцов, усечение строки определяется @code{truncate-lines}.
Для любого другого значения не-@code{nil} строки обрезаются в каждом окне
с частичной шириной, независимо от значения @code{truncate-lines}.
@end defopt

  Когда в окне используется горизонтальная прокрутка
(@pxref{Horizontal Scrolling}), это вызывает усечение.

@defvar wrap-prefix
Если эта локальная в буфере переменная - не-@code{nil}, она определяет
@dfn{префикс переноса}, который Emacs отображает в начале каждой строки
продолжения.  (Если строки усечены, @code{wrap-prefix} никогда не
используется.)  Его значением может быть строка или изображение
(@pxref{Other Display Specs}), или отрезок пробелов, например, указанный
в свойствах отображения @code{:width} или @code{:align-to}
(@pxref{Specified Space}).  Значение интерпретируется так же, как текстовое
свойство @code{display}.  @xref{Display Property}.

Префикс переноса также может быть указан для областей текста с помощью свойства
@code{wrap-prefix} text или overlay.  Это имеет приоритет перед переменной
@code{wrap-prefix}.  @xref{Special Properties}.
@end defvar

@defvar line-prefix
Если эта локальная в буфере переменная - не-@code{nil}, она определяет
@dfn{префикс строки}, который Emacs отображает в начале каждой строки,
не являющейся продолжением.  Её значением может быть строка или изображение
(@pxref{Other Display Specs}), или отрезок пробелов, например, указанный в
свойствах отображения @code{:width} или @code{:align-to}
(@pxref{Specified Space}).  Значение интерпретируется так же, как текстовое
свойство @code{display}.  @xref{Display Property}.

Префикс строки также может быть указан для областей текста с помощью свойства
@code{line-prefix} text или overlay.  Это имеет приоритет перед переменной
@code{line-prefix}.  @xref{Special Properties}.
@end defvar

@ignore
  Если ваш буфер содержит только очень короткие строки, можно посчитать
целесообразным установить @code{cache-long-scans} в @code{nil}.

@defvar cache-long-scans
Если эта переменная - не-@code{nil} (по умолчанию), различные функции
отступа и движения и повторное отображение Emacs кэшируют результаты
сканирования буфера и обращаются к кешу, чтобы избежать повторного
 сканирования областей буфера, если они не были изменены.

Отключение кеша несколько ускоряет обработку коротких строк.

Эта переменная автоматически является локальной в каждом буфере.
@end defvar
@end ignore

@node The Echo Area
@section Эхо Область
@cindex error display
@cindex echo area

@c FIXME: Почему бы не использовать @xref{Minibuffers} напрямую?  --xfq
  @dfn{Эхо область} используется для отображения сообщений об ошибках
(@pxref{Errors}), сообщений, созданных с помощью примитива @code{message},
и для отражения нажатий клавиш.  Это не то же самое, что минибуфер, несмотря
на то, что минибуфер появляется (когда он активен) в том же месте на экране,
что и эхо-область.  @xref{Minibuffer,, The Minibuffer, emacs, The GNU Emacs Manual}.

  Помимо функций, описанных в этом разделе, можно печатать объекты Lisp в
эхо-области, указав @code{t} в качестве выходного потока.  @xref{Output Streams}.

@menu
* Displaying Messages:: Явное отображение текста в эхо-области.
* Progress::            Информирование пользователя о ходе длительной операции.
* Logging Messages::    Сообщения эхо-области регистрируются для пользователя.
* Echo Area Customization:: Контроль эхо-области.
@end menu

@node Displaying Messages
@subsection Отображение Сообщений в Эхо-Области
@cindex display message in echo area

  В этом разделе описаны стандартные функции для отображения сообщений в
эхо-области.

@defun message format-string &rest arguments
Функция отображает сообщение в эхо-области.  @var{format-string} - это
строка формата, а @var{arguments} - это объекты для ее спецификаций
формата, как в функции @code{format-message} (@pxref{Formatting Strings}).
Результирующая отформатированная строка отображается в эхо-области; если она
содержит свойства текста @code{face}, она отображается с указанными гранями
(@pxref{Faces}).  Строка также добавляется в буфер @file{*Messages*}, но без
текстовых свойств (@pxref{Logging Messages}).

Обычно серьезный акцент и апостроф в формате переводятся в совпадающие
изогнутые кавычки, например, @t{"Missing `%s'"} может привести к
@t{"Missing ‘foo’"}.  @xref{Text Quoting Style}, о том, как повлиять или
запретить этот перевод.

В пакетном режиме сообщение выводится в стандартный поток ошибок, за которым
следует новая строка.

Когда @code{inhibit-message} равно не-@code{nil}, сообщение не будет
отображаться в эхо-области, оно будет записано только в @samp{*Messages*}.

Если @var{format-string} - это @code{nil} или пустая строка, @code{message}
очищает эхо-область; если эхо-область была расширена автоматически, это
возвращает ее к нормальному размеру.  Если минибуфер активен, это немедленно
возвращает содержимое минибуфера на экран.

@example
@group
(message "Reverting `%s'..." (buffer-name))
 @print{} Reverting ‘subr.el’...
@result{} "Reverting ‘subr.el’..."
@end group

@group
---------- Echo Area ----------
Reverting ‘subr.el’...
---------- Echo Area ----------
@end group
@end example

Для автоматического отображения сообщения в эхо-области или во всплывающем
буфере, в зависимости от его размера, использовать
@code{display-message-or-buffer} (смотреть ниже).

@strong{Предупреждение:} Если требуется использовать свою собственную строку
в качестве дословного сообщения, не пишется просто @code{(message @var{string})}.
Если @var{string} содержит @samp{%}, @samp{`} или @samp{'}, оно может быть
переформатирован с нежелательными результатами.  Вместо этого использовать
@code{(message "%s" @var{string})}.
@end defun

@defvar inhibit-message
Если переменная - не-@code{nil}, @code{message} и связанные функции не будут
использовать область эха для отображения сообщений.
@end defvar

@defmac with-temp-message message &rest body
Конструкция временно отображает сообщение в эхо-области во время выполнения
@var{body}.  Отображается @var{message}, выполняется @var{body}, затем
возвращается значение последней формы тела, восстанавливая предыдущее
содержимое эхо-области.
@end defmac

@defun message-or-box format-string &rest arguments
Функция отображает сообщение типа @code{message}, но может отображать его
в диалоговом окне вместо эхо-области.  Если эта функция вызывается в команде,
которая была вызвана с помощью мыши - точнее, если @code{last-nonmenu-event}
(@pxref{Command Loop Info}) является либо @code{nil}, либо списком, - тогда
она использует диалоговое окно или всплывающее меню для отображения сообщения.
В противном случае используется эхо-область.  (Это тот же критерий, который
@code{y-or-n-p} использует для принятия аналогичного решения; смотреть
@ref{Yes-or-No Queries}.)

Можно принудительно использовать мышь или эхо-область, привязав
@code{last-nonmenu-event} к подходящему значению вокруг вызова.
@end defun

@defun message-box format-string &rest arguments
@anchor{message-box}
Функция отображает сообщение типа @code{message}, но по возможности использует
диалоговое окно (или всплывающее меню).  Если невозможно использовать диалоговое
окно или всплывающее меню, потому что терминал их не поддерживает, то
@code{message-box} использует эхо-область, как @code{message}.
@end defun

@defun display-message-or-buffer message &optional buffer-name action frame
Функция отображает сообщение @var{message}, которое может быть строкой или
буфером.  Если это короче максимальной высоты эхо-области, определенной
@code{max-mini-window-height}, отображается в эхо-области с помощью
@code{message}.  В противном случае используется @code{display-buffer},
чтобы показать его во всплывающем буфере.

Возвращает либо строку, показанную в эхо-области, либо, когда используется
всплывающий буфер, окно, используемое для его отображения.

Если @var{message} - строка, то необязательный аргумент @var{buffer-name} -
это имя буфера, используемого для его отображения при использовании
всплывающего буфера, по умолчанию @file{*Message*}.  В случае, когда
@var{message} является строкой и отображается в эхо-области, не указывается,
вставлено ли содержимое в буфер в любом случае.

Необязательные аргументы @var{action} и @var{frame} такие же, как для
@code{display-buffer}, и используются только в том случае, если
отображается буфер.
@end defun

@defun current-message
Функция возвращает сообщение, которое в данный момент отображается в
эхо-области, или @code{nil}, если его нет.
@end defun

@node Progress
@subsection Отчетность о Ходе Операции
@cindex progress reporting

  Если для завершения операции может потребоваться некоторое время, потребуется
сообщить пользователю о ходе ее выполнения.  Таким образом, пользователь может
оценить оставшееся время и ясно увидеть, что Emacs занят работой, а не завис.
Удобный способ сделать это - использовать файл @dfn{ход процесса}.

  Вот рабочий пример, который не делает ничего полезного:

@smallexample
(let ((progress-reporter
       (make-progress-reporter "Сбор маны для Emacs..."
                               0  500)))
  (dotimes (k 500)
    (sit-for 0.01)
    (progress-reporter-update progress-reporter k))
  (progress-reporter-done progress-reporter))
@end smallexample

@defun make-progress-reporter message &optional min-value max-value current-value min-change min-time
Функция создает и возвращает объект показателя прогресса, который используется в качестве
аргумента для других функций, перечисленных ниже.  Идея состоит в том, чтобы
предварительно вычислить как можно больше данных, чтобы сделать отчеты о ходе работы
очень быстрыми.

При последующем использовании этого показателя прогресса в эхо-области будет отображаться
@var{message}, за которым следует процент выполнения.  @var{message} рассматривается как
простая строка.  Например, если требуется, чтобы была зависимость от имени файла,
использовать @code{format-message} перед вызовом этой функции.

Аргументы @var{min-value} и @var{max-value} должны быть числами, обозначающими начальное и
конечное состояния операции.  Например, операция, которая просматривает буфер, должна
установить для них результаты @code{point-min} и @code{point-max} соответственно.
@var{max-value} должно быть больше @var{min-value}.

В качестве альтернативы можно установить @var{min-value} и @var{max-value} в @code{nil}.
В этом случае отчет о ходе выполнения не сообщает проценты процесса; вместо этого отображается
``спиннер'', который меняет метку каждый раз, когда обновляется отчет о прогрессе.

Если @var{min-value} и @var{max-value} - числа, можно дать аргументу @var{current-value}
числовое значение, указывающее начальный прогресс; если опущено, по умолчанию используется
@var{min-value}.

Остальные аргументы управляют скоростью обновления эхо-области.  Показатель прогресса будет
ждать, по крайней мере, еще @var{min-change} процентов операции, которая будет завершена,
прежде чем печатать следующее сообщение; по умолчанию - один процент.  @var{min-time} задает
минимальное время в секундах для перехода между последовательными отпечатками; по умолчанию -
0,2 секунды.  (В некоторых операционных системах показатель прогресса может обрабатывать доли
секунды с разной точностью).

Функция вызывает @code{progress-reporter-update}, поэтому первое сообщение печатается
немедленно.
@end defun

@defun progress-reporter-update reporter &optional value
Функция выполняет основную работу по отчетности о ходе вашей операции.  Отображает сообщение
@var{reporter}, за которым следует процент выполнения, определяемый @var{value}.  Если процент
равен нулю или достаточно близок в соответствии с аргументами @var{min-change} и @var{min-time},
то он исключается из вывода.

@var{reporter} должен быть результатом вызова @code{make-progress-reporter}.  @var{value}
указывает текущее состояние вашей операции и должно быть между @var{min-value} и @var{max-value}
(включительно), как передано в @code{make-progress-reporter}.  Например, если сканируется буфер,
то @var{value} должен быть результатом вызова @code{point}.

Функция учитывает @var{min-change} и @var{min-time} как переданный в @code{make-progress-reporter}
и поэтому не выводит новые сообщения при каждом вызове.  Таким образом, это очень быстро, и обычно
вам не следует пытаться уменьшить количество обращений к нему: возникающие накладные расходы,
скорее всего, сведут на нет ваши усилия.
@end defun

@defun progress-reporter-force-update reporter &optional value new-message
Функция похожа на @code{progress-reporter-update}, за исключением того, что она безоговорочно
печатает сообщение в эхо-области.

Первые два аргумента имеют то же значение, что и для @code{progress-reporter-update}.
Необязательный @var{new-message} позволяет изменить сообщение @var{reporter}. Поскольку
эта функция всегда обновляет эхо-область, такое изменение будет немедленно представлено
пользователю.
@end defun

@defun progress-reporter-done reporter
Функция должна вызываться после завершения операции.  Печатает сообщение @var{reporter}, за
которым следует слово @samp{done} в эхо-области.

Потребуется всегда вызывать эту функцию и не надеяться, что @code{progress-reporter-update}
напечатает @samp{100%}.  Во-первых, возможно никогда не распечатает его, для этого есть много
веских причин.  Во-вторых, @samp{done} более явно.
@end defun

@defmac dotimes-with-progress-reporter (var count [result]) message body@dots{}
Это удобный макрос, который работает так же, как @code{dotimes}, но также сообщает о ходе цикла
с помощью функций, описанных выше.  Это позволяет сэкономить время на вводе текста.

Можно переписать пример в начале этой ноды, используя этот макрос следующим образом:

@example
(dotimes-with-progress-reporter
    (k 500)
    "Сбор маны для Emacs..."
  (sit-for 0.01))
@end example
@end defmac

@node Logging Messages
@subsection Регистрация Сообщений в @file{*Messages*}
@cindex logging echo-area messages

  Почти все сообщения, отображаемые в эхо-области, также записываются в буфер @file{*Messages*},
чтобы пользователь мог вернуться к ним.  Сюда входят все сообщения, выводимые с помощью
@code{message}.  По умолчанию этот буфер доступен только для чтения и использует основной режим
@code{messages-buffer-mode}.  Ничто не мешает пользователю убить буфер @file{*Messages*}, но
следующее отображение сообщения воссоздает его.  Любой код Lisp, которому нужен прямой доступ к
буферу @file{*Messages*} и который хочет убедиться, что он существует, должен использовать
функцию @code{messages-buffer}.

@defun messages-buffer
Функция возвращает буфер @file{*Messages*}. Если он не существует, он его создает и переключает
на @code{messages-buffer-mode}.
@end defun

@defopt message-log-max
Переменная определяет, сколько строк хранить в буфере @file{*Messages*}.  Значение @code{t}
означает, что ограничений на количество строк нет.  Значение @code{nil} полностью отключает
ведение журнала сообщений.  Вот как отобразить сообщение и предотвратить его регистрацию:

@example
(let (message-log-max)
  (message @dots{}))
@end example
@end defopt

  Чтобы сделать @file{*Messages*} более удобным для пользователя, средство ведения журнала
объединяет последовательные идентичные сообщения.  Также объединяет последовательные связанные
сообщения для двух случаев: вопрос, за которым следует ответ, и серия сообщений о ходе выполнения.

  Вопрос, за которым следует ответ, содержит два сообщения, как и сообщения, созданные
@code{y-or-n-p}:: первое - @samp{@var{question}}, второе - @samp{@var{question}...@var{answer}}.
Первое сообщение не несет никакой дополнительной информации, кроме информации, содержащейся во
втором, поэтому при регистрации второго сообщения первое из журнала удаляется.

  Ряд сообщений о ходе выполнения имеет последовательные сообщения, подобные сообщениям,
создаваемым @code{make-progress-reporter}.  Они имеют вид @samp{@var{base}...@var{how-far}},
где @var{base} каждый раз одно и то же, а @var{how-far} меняется.  При регистрации каждого
сообщения в серии предыдущее удаляется при условии, что они являются последовательными.

  Функции @code{make-progress-reporter} и @code{y-or-n-p} не должны делать ничего особенного,
чтобы активировать функцию комбинирования журнала сообщений.  Работают всякий раз, когда
регистрируются два последовательных сообщения с общим префиксом, оканчивающимся на @samp{...}.

@node Echo Area Customization
@subsection Настройка Эхо-Области
@cindex echo area customization

  Эти переменные контролируют детали того, как работает эхо-область.

@defvar cursor-in-echo-area
Переменная определяет, где будет отображаться курсор при отображении сообщения в эхо-области.
Если установленно в не-@code{nil}, то курсор появляется в конце сообщения.  В противном случае
курсор появится в точке - вообще не в эхо-области.

Обычно это значение @code{nil}; Программы на Лиспе привязывают его к @code{t} на короткие
промежутки времени.
@end defvar

@defvar echo-area-clear-hook
Нормальный перехватчик запускается всякий раз, когда очищается эхо-область --- либо с помощью
@code{(message nil)}, либо по любой другой причине.
@end defvar

@defopt echo-keystrokes
Переменная определяет, сколько времени должно пройти до вывода командных символов.  Её значение
должно быть числом и указывает количество секунд ожидания перед эхом.  Если пользователь вводит
префиксный ключ (например, @kbd{C-x}), а затем задерживает это количество секунд перед
продолжением, префиксный ключ отображается эхом в эхо-области) (как только эхо начинается в
ключевой последовательности, все последующие символы в той же ключевой последовательности
отражаются немедленно.)

Если значение равно нулю, то ввод команды не отображается.
@end defopt

@defvar message-truncate-lines
Обычно при отображении длинного сообщения размер эхо-области изменяется для отображения всего
сообщения.  Но если переменная @code{message-truncate-lines} равна не-@code{nil}, размер
эхо-области не изменяется, и сообщение обрезается, чтобы соответствовать ему.
@end defvar

  Переменная @code{max-mini-window-height}, которая определяет максимальную высоту для изменения
размера окон минибуфера, также применяется к эхо-области (которая на самом деле является
специальным использованием окна минибуфера; @pxref{Minibuffer Windows}).

@node Warnings
@section Сообщения о Предупреждениях
@cindex warnings

  @dfn{Предупреждения} - это средство, с помощью которого программа сообщает пользователю о
возможной проблеме, но продолжает работу.

@menu
* Warning Basics::      Концепции предупреждений и функции для их сообщения.
* Warning Variables::   Связывание программы и переменных, чтобы настроить предупреждения.
* Warning Options::     Пользователи устанавливают переменные для управления отображением
                           предупреждений.
* Delayed Warnings::    Отложить предупреждение до конца команды.
@end menu

@node Warning Basics
@subsection Основы Предупреждений
@cindex severity level

  Каждое предупреждение содержит текстовое сообщение, объясняющее проблему для пользователя, и
@dfn{уровень опасности}, которым является символом.  Вот возможные уровни серьезности в порядке
убывания серьезности и их значения:

@table @code
@item :emergency
Проблема, которая вскоре серьезно ухудшит работу Emacs, если не решить ее вовремя.
@item :error
Сообщение о данных или обстоятельствах, которые по своей сути неверны.
@item :warning
Сообщение с данными или обстоятельствами, которые не являются ошибочными по своей сути, но
вызывают подозрение на возможную проблему.
@item :debug
Отчет с информацией, которая может быть полезна при отладке.
@end table

  Когда программа встречает недопустимые входные данные, она может либо сигнализировать об ошибке
Lisp, вызывая @code{error} или @code{signal}, либо сообщать предупреждение с серьезностью
@code{:error}.  Сигнализировать об ошибке Lisp проще всего, но это означает, что программа не
может продолжить обработку.  Если потребуется реализовать способ продолжения обработки, несмотря
на неверные данные, то сообщение с предупреждением о серьезности @code{:error} - это правильный
способ сообщить пользователю о проблеме.  Например, байт-компилятор Emacs Lisp может таким образом
сообщить об ошибке и продолжить компиляцию других функций.  (Если программа сигнализирует об ошибке
Lisp, а затем обрабатывает ее с помощью @code{condition-case}, пользователь не увидит сообщение об
ошибке; она может показать сообщение пользователю, сообщив о нем как о предупреждении.)

@c FIXME: Зачем использовать здесь "(bytecomp)" вместо "'bytecomp" или просто
@c "bytecomp"?  Квадраты являются частью warning-type-format, но
@c не входят в тип предупреждения. --xfq
@cindex warning type
  У каждого предупреждения есть @dfn{тип предупреждения} для его классификации.  Тип - это список
символов.  Первым символом должна быть настраиваемая группа, которая используется для
пользовательских опций программы.  Например, предупреждения байт-компилятора используют тип
предупреждения @code{(bytecomp)}.  Также можно разделить предупреждения на подкатегории, если
требуется, используя больше символов в списке.

@defun display-warning type message &optional level buffer-name
Функция сообщает о предупреждении, используя @var{message} в качестве сообщения и @var{type} в
качестве типа предупреждения.  @var{level} должен быть уровнем серьезности, по умолчанию
@code{:warning}.

@var{buffer-name}, если не-@code{nil}, указывает имя буфера для записи предупреждения.  По умолчанию
это @file{*Warnings*}.
@end defun

@defun lwarn type level message &rest args
Функция сообщает о предупреждении, используя значение
@code{(format-message @var{message} @var{args}...)} в качестве сообщения в буфере @file{*Warnings*}.
В остальном это эквивалентено @code{display-warning}.
@end defun

@defun warn message &rest args
Функция сообщает о предупреждении, используя значение
@code{(format-message @var{message} @var{args}...)} в качестве сообщения, @code{(emacs)} в
качестве типа и @code{:warning} в качестве уровня серьезности.  Существует только для совместимости;
Рекомендуется не использовать, потому что потребуется указать конкретный тип предупреждения.
@end defun

@node Warning Variables
@subsection Переменные Предупреждений
@cindex warning variables

  Программы могут настраивать отображение своих предупреждений путем привязки переменных, описанных
в этом разделе.

@defvar warning-levels
Этот список определяет значение и порядок уровней серьезности предупреждений.  Каждый элемент
определяет один уровень серьезности, и они расположены в порядке убывания серьезности.

Каждый элемент имеет форму @code{(@var{level} @var{string} @var{function})}, где @var{level} - это
уровень серьезности, который определяется.  @var{string} задает текстовое описание этого уровня.
@var{string} следует использовать @samp{%s}, чтобы указать, где разместить информацию о типе
предупреждения, или можно опустить @samp{%s}, чтобы не включать эту информацию.

Необязательный элемент @var{function}, если не-@code{nil}, - это функция, вызываемая без аргументов,
чтобы привлечь внимание пользователя.

Обычно не требуется изменять значение этой переменной.
@end defvar

@defvar warning-prefix-function
Если не-@code{nil}, значение - это функция для генерации префиксного текста для предупреждений.
Программы могут привязать переменную к подходящей функции. @code{display-warning} вызывает эту
функцию с текущим буфером предупреждений, и функция может вставлять в него текст.  Этот текст
становится началом предупреждающего сообщения.

Функция вызывается с двумя аргументами: уровнем серьезности и записью в @code{warning-levels}.
Возвращает список для использования в качестве записи (это значение не обязательно должно быть
фактическим членом @code{warning-levels}).  Создав это значение, функция может изменить серьезность
предупреждения или указать другую обработку для заданного уровня серьезности.

Если значение переменной - @code{nil}, функция для вызова отсутствует.
@end defvar

@defvar warning-series
Программы могут привязать эту переменную к @code{t}, чтобы сказать, что следующее предупреждение
должно начать серию.  Когда несколько предупреждений образуют серию, это означает, что точка
остается на первом предупреждении в серии, а не перемещается для каждого предупреждения, чтобы
отображаться на последнем.  Серия заканчивается, когда нет локальной привязки и
@code{warning-series} снова становится @code{nil}.

Значение также может быть символом с определением функции.  Это эквивалентно @code{t}, за
исключением того, что следующее предупреждение также вызовет функцию без аргументов с текущим
буфером предупреждений.  Функция может вставлять текст, который будет служить заголовком для серии
предупреждений.

После начала серии значение представляет собой маркер, который указывает на позицию буфера в буфере
предупреждений начала серии.

Нормальное значение переменной - @code{nil}, что означает обработку каждого предупреждения
отдельно.
@end defvar

@defvar warning-fill-prefix
Когда эта переменная - не-@code{nil}, определяется префикс заполнения, который будет использоваться
для заполнения текста каждого предупреждения.
@end defvar

@defvar warning-type-format
Переменная определяет формат отображения типа предупреждения в предупреждающем сообщении.
Результат форматирования типа таким образом включается в сообщение под контролем строки в записи
в @code{warning-levels}.  Значение по умолчанию - @code{" (%s)"}.  Если привязать его к @code{""},
то тип предупреждения вообще не появится.
@end defvar

@node Warning Options
@subsection Параметры Предупреждений
@cindex warning options

  Эти переменные используются пользователями для управления тем, что происходит, когда программа
на Lisp сообщает о предупреждении.

@defopt warning-minimum-level
Пользовательский параметр указывает минимальный уровень серьезности, который должен быть немедленно
показан пользователю.  По умолчанию используется @code{:warning}, что означает немедленное
отображение всех предупреждений, кроме предупреждений @code{:debug}.
@end defopt

@defopt warning-minimum-log-level
Пользовательский параметр указывает минимальный уровень серьезности, который должен регистрироваться
в буфере предупреждений.  По умолчанию используется @code{:warning}, что означает регистрацию всех
предупреждений, кроме предупреждений @code{:debug}.
@end defopt

@defopt warning-suppress-types
В списке указано, какие типы предупреждений отображаться сразу для пользователя.  Каждый
элемент списка должен быть списком символов. Если его элементы совпадают с первыми элементами в
типе предупреждения, это предупреждение не отображается сразу.
@end defopt

@defopt warning-suppress-log-types
Список указывает, какие типы предупреждений не должны регистрироваться в буфере предупреждений.
Каждый элемент списка должен быть списком символов.  Если соответствует нескольким первым элементам
в типе предупреждения, это предупреждение не регистрируется.
@end defopt

@node Delayed Warnings
@subsection Отложенные Предупреждения
@cindex delayed warnings

Иногда потребуется не показывать предупреждение во время выполнения команды и показывать его
только после окончания команды.  Для этого возможно использовать переменную
@code{delayed-warnings-list}.

@defvar delayed-warnings-list
Значение переменной представляет собой список предупреждений, которые будут отображаться после
завершения текущей команды.  Каждый элемент должен быть списком

@smallexample
(@var{type} @var{message} [@var{level} [@var{buffer-name}]])
@end smallexample

@noindent
с той же формой и тем же значением, что и список аргументов @code{display-warning}
(@pxref{Warning Basics}).  Сразу после запуска @code{post-command-hook} (@pxref{Command Overview})
командный цикл Emacs отображает все предупреждения, указанные в этой переменной, а затем
сбрасывает её в @code{nil}.
@end defvar

  Программы, которым необходимо дополнительно настроить механизм отложенных предупреждений, могут
изменить переменную @code{delayed-warnings-hook}:

@defvar delayed-warnings-hook
Обычная ловушка, которая запускается командным циклом Emacs после @code{post-command-hook} для
обработки и отображения отложенных предупреждений.

Её значение по умолчанию - это список из двух функций:

@smallexample
(collapse-delayed-warnings display-delayed-warnings)
@end smallexample

@findex collapse-delayed-warnings
@findex display-delayed-warnings
@noindent
Функция @code{collapse-delayed-warnings} удаляет повторяющиеся записи из
@code{delayed-warnings-list}.  Функция @code{display-delayed-warnings} по очереди вызывает
@code{display-warning} для каждой записи в @code{delayed-warnings-list}, а затем устанавливает
@code{delayed-warnings-list} в @code{nil}.
@end defvar

@node Invisible Text
@section Невидимый Текст

@cindex invisible text
Есть возможность сделать символы @dfn{невидимыми}, чтобы они не появлялись на экране, с помощью
свойства @code{invisible}.  Это может быть текстовое свойство (@pxref{Text Properties}) или
свойство наложения (@pxref{Overlays}).  Движение курсора также частично игнорирует эти символы;
если цикл команд обнаруживает, что эта точка находится внутри диапазона невидимого текста после
команды, он перемещает точку на другую сторону текста.

В простейшем случае любое свойство не-@code{nil} @code{invisible} делает символ невидимым.  Это
случай по умолчанию - если не изменяется значение по умолчанию @code{buffer-invisibility-spec}, вот
как работает свойство @code{invisible}.  Обычно требуется использовать @code{t} в качестве значения
свойства @code{invisible}, если не планируется устанавливать @code{buffer-invisibility-spec}
самостоятельно.

В более общем плане можно использовать переменную @code{buffer-invisibility-spec}, чтобы
контролировать, какие значения свойства @code{invisible} делают текст невидимым.  Это позволяет
заранее классифицировать текст на разные подмножества, задавая им разные значения @code{invisible},
и впоследствии делать различные подмножества видимыми или невидимыми, изменяя значение
@code{buffer-invisibility-spec}.

Управление видимостью с помощью @code{buffer-invisibility-spec} особенно полезно в программе для
отображения списка записей в базе данных.  Это позволяет реализовать удобные команды фильтрации для
просмотра только части записей в базе данных.  Установка этой переменной выполняется очень быстро,
намного быстрее, чем сканирование всего текста в буфере в поисках свойств, которые нужно изменить.

@defvar buffer-invisibility-spec
Переменная определяет, какие свойства @code{invisible} фактически делают символ невидимым.
Установка этой переменной делает ее локальной для буфера.

@table @asis
@item @code{t}
Символ невидим, если его свойство @code{invisible} равно не-@code{nil}.  Это значение по умолчанию.

@item a list
Каждый элемент списка определяет критерий невидимости; если свойство @code{invisible} символа
соответствует любому из этих критериев, символ невидим.  Список может иметь два типа элементов:

@table @code
@item @var{atom}
Символ невидим, если значение его свойства @code{invisible} равно @var{atom} или если это список
с @var{atom} в качестве члена; сравнение производится с помощью @code{eq}.

@item (@var{atom} . t)
Символ невидим, если значение его свойства @code{invisible} равно @var{atom} или если это список
с @var{atom} в качестве члена; сравнение производится с помощью @code{eq}.  Более того,
последовательность таких символов отображается в виде многоточия.
@end table
@end table
@end defvar

  Две функции специально предусмотрены для добавления элементов в @code{buffer-invisibility-spec}
и удаления элементов из него.

@defun add-to-invisibility-spec element
Функция добавляет элемент @var{element} в @code{buffer-invisibility-spec}.  Если
@code{buffer-invisibility-spec} был @code{t}, изменится на список @code{(t)}, так что текст,
свойство @code{invisible} которого равно @code{t}, останется невидимым.
@end defun

@defun remove-from-invisibility-spec element
Удаляет элемент @var{element} из @code{buffer-invisibility-spec}.  Это ничего не происходит, если
@var{element} отсутствует в списке.
@end defun

  Соглашение об использовании @code{buffer-invisibility-spec} заключается в том, что основной
режим должен использовать собственное имя режима как элемент @code{buffer-invisibility-spec} и как
значение свойства @code{invisible}:

@example
;; @r{Если требуется отобразить многоточие:}
(add-to-invisibility-spec '(my-symbol . t))
;; @r{Если не требуется многоточие:}
(add-to-invisibility-spec 'my-symbol)

(overlay-put (make-overlay beginning end)
             'invisible 'my-symbol)

;; @r{Когда закончено с невидимостью:}
(remove-from-invisibility-spec '(my-symbol . t))
;; @r{Или соответственно:}
(remove-from-invisibility-spec 'my-symbol)
@end example

  Проверить невидимость можно с помощью следующей функции:

@defun invisible-p pos-or-prop
Если @var{pos-or-prop} - маркер или число, функция возвращает значение не-@code{nil},
если текст в этой позиции в настоящее время невидим.

Если @var{pos-or-prop} - это любой другой объект Lisp, это означает возможное значение свойства
@code{invisible} текста или наложения.  В этом случае эта функция возвращает значение не-@code{nil},
если это значение приведет к тому, что текст станет невидимым, на основе текущего значения
@code{buffer-invisibility-spec}.

Возвращаемое значение функции - @code{t}, если текст будет полностью скрыт при отображении, или
значение не-@code{nil}, не-@code{t}, если текст будет заменен многоточием.
@end defun

@vindex line-move-ignore-invisible
  Обычно функции, которые работают с текстом или перемещают точку, не заботятся о том, является
ли текст невидимым, они обрабатывают как невидимые, так и видимые символы.  Команды перемещения
строки на уровне пользователя, такие как @code{next-line}, @code{previous-line}, игнорируют
невидимые символы новой строки, если @code{line-move-ignore-invisible} имеет значение не-@code{nil}
(по умолчанию), то есть ведут себя так, как будто эти невидимые символы новой строки не существуют
в буфере, но только потому, что они явно так запрограммированы на выполнение.

  Если команда заканчивается точкой внутри или на границе невидимого текста, основной цикл
редактирования перемещает точку на один из двух концов невидимого текста.  Emacs выбирает
направление перемещения так, чтобы оно совпадало с общим направлением перемещения команды; в случае
сомнений предпочитается позиция, в которой вставленный символ не наследует свойство
@code{invisible}.  Кроме того, если текст не заменен многоточием и команда перемещается только
внутри невидимого текста, то точка перемещается на один дополнительный символ, чтобы попытаться
отразить перемещение команды видимым перемещением курсора.

  Таким образом, если команда перемещает точку обратно в невидимый диапазон
(с обычным закреплением), Emacs перемещает точку обратно в начало этого диапазона.  Если команда
перемещает точку вперед в невидимый диапазон, Emacs перемещает точку вперед к первому видимому
символу, который следует за невидимым текстом, а затем вперед еще на один символ.

  Эти точки @dfn{корректировки}, которые оказались в середине невидимого текста, можно отключить,
установив для @code{disable-point-adjustment} значение не-@code{nil}.  @xref{Adjusting Point}.

  Пошаговый поиск может сделать невидимые наложения видимыми временно и/или постоянно, если
совпадение включает невидимый текст.  Для этого наложение имеет установленное свойство 
@code{isearch-open-invisible} в не-@code{nil}.  Значением свойства выступает функция, которая
вызываться с наложением в качестве аргумента.  Функция постоянно делает наложение видимым;
используется, когда совпадение перекрывает наложение при выходе из поиска.

  Во время поиска такие наложения становятся временно видимыми путем временного изменения их
невидимых и нематериальных свойств.  Если требуется, чтобы это было сделано по-другому для
определенного наложения, присваивается ему свойство @code{isearch-open-invisible-temporary},
которое является функцией.  Функция вызывается с двумя аргументами: первый - это наложение, а
второй - @code{nil}, чтобы сделать наложение видимым, или @code{t}, чтобы снова сделать его
невидимым.

@node Selective Display
@section Выборочное Отображение
@c @cindex выборочное отображение Дубликаты выборочного отображения

  @dfn{Выборочное отображение} относится к паре связанных функций для скрытия определенных строк
на экране.

@cindex explicit selective display
  Первый вариант, явное избирательное отображение, был разработан для использования в программе на
Lisp: он контролирует, какие строки скрываются, изменяя текст.  Этот вид сокрытия сейчас устарел;
вместо этого можно получить тот же эффект с помощью свойства @code{invisible}
(@pxref{Invisible Text}).

  Во втором варианте выбор строк для скрытия производится автоматически по отступу.  Этот вариант
предназначен для использования на уровне пользователя.

  Можно управлять явным выборочным отображением, заменяя символ новой строки (control-j) на возврат
каретки (control-m).  Текст, который раньше был строкой после этой новой строки, теперь становиться
скрытым.  Строго говоря, это временно больше не строка, так как только символы новой строки могут
разделять строки; теперь это часть предыдущей строки.

  Выборочное отображение не влияет напрямую на команды редактирования.  Например, @kbd{C-f}
(@code{forward-char}) без колебаний перемещает точку в скрытый текст.  Однако замена символов новой
строки на символы возврата каретки влияет на некоторые команды редактирования.  Например,
@code{next-line} пропускает скрытые строки, так как ищет только новые строки.  Режимы, использующие
выборочное отображение, также могут определять команды, которые учитывают символы новой строки или
управляют тем, какие части текста скрываются.

  Когда записывается в файл выборочно отображаемый буфер, все control-m-ы выводятся как символы
новой строки.  Это означает, что при следующем чтении файла он выглядит нормально, ничего не скрыто.
Эффект выборочного отображения виден только в Emacs.

@defvar selective-display
Локальная в буфере переменная обеспечивает выборочное отображение.  Это означает, что строки или
их части могут быть скрыты.

@itemize @bullet
@item
Если значение @code{selective-display} равно @code{t}, то символ control-m отмечает начало
скрытого текста; Control-m и остальная часть следующей за ним строки не отображаются.  Это явный
выборочный показ.

@item
Если значение @code{selective-display} является положительным целым числом, то строки, начинающиеся
с большего количества столбцов с отступом, не отображаются.
@end itemize

Когда какая-то часть буфера скрыта, команды вертикального перемещения действуют так, как если бы
эта часть не существовала, позволяя одной команде @code{next-line} пропустить любое количество
скрытых строк.  Однако команды перемещения символов (например, @code{forward-char}) не пропускают
скрытую часть, и можно (если это сложно) вставить или удалить текст в скрытой части.

В приведенных ниже примерах показывается @emph{внешний вид отображения} буфера @code{foo}, который
изменяется со значением @code{selective-display}.  @emph{содержание} буфера не меняется.

@example
@group
(setq selective-display nil)
     @result{} nil

---------- Buffer: foo ----------
1 on this column
 2on this column
  3n this column
  3n this column
 2on this column
1 on this column
---------- Buffer: foo ----------
@end group

@group
(setq selective-display 2)
     @result{} 2

---------- Buffer: foo ----------
1 on this column
 2on this column
 2on this column
1 on this column
---------- Buffer: foo ----------
@end group
@end example
@end defvar

@defopt selective-display-ellipses
Если эта локальная в буфере переменная - не-@code{nil}, то Emacs отображает @samp{@dots{}} в
конце строки, за которой следует скрытый текст.  Этот пример является продолжением предыдущего.

@example
@group
(setq selective-display-ellipses t)
     @result{} t

---------- Buffer: foo ----------
1 on this column
 2on this column ...
 2on this column
1 on this column
---------- Buffer: foo ----------
@end group
@end example

Можно использовать таблицу отображения, чтобы заменить многоточие (@samp{@dots{}}) другим текстом.
@xref{Display Tables}.
@end defopt

@node Temporary Displays
@section Временное Отображение
@cindex temporary display
@cindex temporary buffer display

  Временное отображение используются программами на Lisp, чтобы поместить вывод в буфер и затем
представить его пользователю для прочтения, а не для редактирования.  Многие команды справки
используют эту функцию.

@defmac with-output-to-temp-buffer buffer-name body@dots{}
Функция выполняет формы в @var{body}, одновременно организуя вставку любого вывода, который они
печатают, в буфер с именем @var{buffer-name}, который сначала создается, если необходимо, и
переводится в режим справки.  (смотреть аналогичную форму @code{with-temp-buffer-window} ниже.)
Наконец, буфер отображается в каком-то окне, но это окно не выбрано.

Если формы в @var{body} не изменяют основной режим в выходном буфере, так что он все еще остается
режимом справки в конце их выполнения, тогда @code{with-output-to-temp-buffer} в конце делает этот
буфер доступным только для чтения, а также сканирует его на наличие имен функций и переменных,
чтобы превратить их в интерактивные перекрестные ссылки.
@xref{Docstring hyperlinks, , Tips for Documentation Strings}, в частности пункт о гиперссылках в
строках документации, для более подробной информации.

Строка @var{buffer-name} указывает временный буфер, который может не существовать.  Аргумент должен
быть строкой, а не буфером.  Изначально буфер стирается (без вопросов) и помечается как неизмененный
после выхода из @code{with-output-to-temp-buffer}.

@code{with-output-to-temp-buffer} связывает @code{standard-output} с временным буфером, затем
оценивает формы в @var{body}.  Вывод с использованием функций вывода Lisp в @var{body} по умолчанию
переходит в этот буфер (но отображение экрана и сообщения в эхо-области, хотя они и выводятся в
общем смысле слова, не затрагиваются).  @xref{Output Functions}.

Доступно несколько перехватчиков для настройки поведения этой конструкции; они перечислены ниже.

Возвращается значение последней формы в @var{body}.

@example
@group
---------- Buffer: foo ----------
 This is the contents of foo.
---------- Buffer: foo ----------
@end group

@group
(with-output-to-temp-buffer "foo"
    (print 20)
    (print standard-output))
@result{} #<buffer foo>

---------- Buffer: foo ----------

20

#<buffer foo>

---------- Buffer: foo ----------
@end group
@end example
@end defmac

@defopt temp-buffer-show-function
Если переменная - не-@code{nil}, @code{with-output-to-temp-buffer} вызывает ее как функцию для
отображения справочного буфера.  Функция получает один аргумент - буфер, который она должна
отображать.

Хорошая идея, чтобы функция запускала @code{temp-buffer-show-hook} так же, как обычно
@code{with-output-to-temp-buffer}, внутри @code{save-selected-window} и с выбранным окном и
выбранным буфером.
@end defopt

@defvar temp-buffer-setup-hook
Нормальная ловушка запускается @code{with-output-to-temp-buffer} перед вычислением @var{body}.
Когда ловушка запускается, временный буфер является текущим.  Этот перехватчик обычно настраивается
с функцией, переводящей буфер в режим справки.
@end defvar

@defvar temp-buffer-show-hook
Обычная ловушка запускается @code{with-output-to-temp-buffer} после отображения временного буфера.
Когда ловушка запускается, временный буфер является текущим, и выбирается окно, в котором он
отображался.
@end defvar

@defmac with-temp-buffer-window buffer-or-name action quit-function body@dots{}
Макрос похож на @code{with-output-to-temp-buffer}.  Подобно этой конструкции, выполняет @var{body},
а также вставляет любой вывод, который печатается, в буфер с именем @var{buffer-or-name} и
отображает этот буфер в каком-то окне.  Однако, в отличие от @code{with-output-to-temp-buffer},
не переключается этот буфер автоматически в режим справки.

Аргумент @var{buffer-or-name} указывает временный буфер.  Это может быть либо буфер, который уже
должен существовать, либо строка, и в этом случае при необходимости создается буфер с таким именем.
При выходе из @code{with-temp-buffer-window} буфер помечается как немодифицированный и доступный
только для чтения.

Макрос не вызывает @code{temp-buffer-show-function}.  Вместо этого передает аргумент @var{action}
в @code{display-buffer} (@pxref{Choosing Window}), чтобы отобразить буфер.

Возвращается значение последней формы в @var{body}, если не указан аргумент @var{quit-function}.
В этом случае вызывается с двумя аргументами: окном, показывающим буфер, и результатом @var{body}.
Окончательное возвращаемое значение - это то, что возвращает @var{quit-function}.

@vindex temp-buffer-window-setup-hook
@vindex temp-buffer-window-show-hook
Макрос использует обычные перехватчики @code{temp-buffer-window-setup-hook} и
@code{temp-buffer-window-show-hook} вместо аналогичных ловушек, запускаемых
@code{with-output-to-temp-buffer}.
@end defmac

Две описанные ниже конструкции в основном идентичны @code{with-temp-buffer-window}, но
отличаются указанным ниже образом:

@defmac with-current-buffer-window buffer-or-name action quit-function &rest body
Макрос похож на @code{with-temp-buffer-window}, но в отличие от него делает буфер, указанный
@var{buffer-or-name}, текущим для запуска @var{body}.
@end defmac

@defmac with-displayed-buffer-window buffer-or-name action quit-function &rest body
Макрос похож на @code{with-current-buffer-window}, но в отличие от него отображает буфер,
указанный @var{buffer-or-name} @emph{перед} выполнением @var{body}.
@end defmac

Окно, показывающее временный буфер, можно подогнать под размер этого буфера, используя следующий
режим:

@defopt temp-buffer-resize-mode
Когда этот второстепенный режим включен, окна, показывающие временный буфер, автоматически изменяют
размер, чтобы соответствовать содержимому их буфера.

Размер окна изменяется тогда и только тогда, когда оно было специально создано для буфера.  В
частности, окна, в которых раньше отображался другой буфер, не изменяются.  По умолчанию в этом
режиме для изменения размера используется @code{fit-window-to-buffer} (@pxref{Resizing Windows}).
Можно указать другую функцию, настроив параметры @code{temp-buffer-max-height} и
@code{temp-buffer-max-width} ниже.
@end defopt

@defopt temp-buffer-max-height
This option specifies the maximum height (in lines) of a window
displaying a temporary buffer when @code{temp-buffer-resize-mode} is
enabled.  It can also be a function to be called to choose the height
for such a buffer.  It gets one argument, the buffer, and should return
a positive integer.  At the time the function is called, the window to
be resized is selected.
@end defopt

@defopt temp-buffer-max-width
This option specifies the maximum width of a window (in columns)
displaying a temporary buffer when @code{temp-buffer-resize-mode} is
enabled.  It can also be a function to be called to choose the width for
such a buffer.  It gets one argument, the buffer, and should return a
positive integer.  At the time the function is called, the window to be
resized is selected.
@end defopt

The following function uses the current buffer for temporary display:

@defun momentary-string-display string position &optional char message
This function momentarily displays @var{string} in the current buffer at
@var{position}.  It has no effect on the undo list or on the buffer's
modification status.

The momentary display remains until the next input event.  If the next
input event is @var{char}, @code{momentary-string-display} ignores it
and returns.  Otherwise, that event remains buffered for subsequent use
as input.  Thus, typing @var{char} will simply remove the string from
the display, while typing (say) @kbd{C-f} will remove the string from
the display and later (presumably) move point forward.  The argument
@var{char} is a space by default.

The return value of @code{momentary-string-display} is not meaningful.

If the string @var{string} does not contain control characters, you can
do the same job in a more general way by creating (and then subsequently
deleting) an overlay with a @code{before-string} property.
@xref{Overlay Properties}.

If @var{message} is не-@code{nil}, it is displayed in the echo area
while @var{string} is displayed in the buffer.  If it is @code{nil}, a
default message says to type @var{char} to continue.

In this example, point is initially located at the beginning of the
second line:

@example
@group
---------- Buffer: foo ----------
This is the contents of foo.
@point{}Second line.
---------- Buffer: foo ----------
@end group

@group
(momentary-string-display
  "**** Important Message! ****"
  (point) ?\r
  "Type RET when done reading")
@result{} t
@end group

@group
---------- Buffer: foo ----------
This is the contents of foo.
**** Important Message! ****Second line.
---------- Buffer: foo ----------

---------- Echo Area ----------
Type RET when done reading
---------- Echo Area ----------
@end group
@end example
@end defun

@node Overlays
@section Наложение
@cindex overlays
@c FIXME: упомянуть интервалы в этом разделе?

Можно использовать @dfn{наложение}, чтобы изменить внешний вид текста буфера
на экране в целях презентации.  Наложение - это объект, который принадлежит
определенному буферу и имеет указанное начало и конец.  У него также есть
свойства, которые можно исследовать и устанавливать; они влияют на
отображение текста в наложении.

@cindex scalability of overlays
@cindex overlays, scalability
Визуальный эффект наложения такой же, как и у соответствующего текстового
свойства (@pxref{Text Properties}).  Однако из-за другой реализации
наложения обычно плохо масштабируются (многие операции занимают время,
пропорциональное количеству наложений в буфере).  Если нужно повлиять на
внешний вид многих частей в буфере, рекомендуется использовать свойства
текста.

Наложение использует маркеры для записи его начала и конца; таким образом,
редактирование текста в буфере корректирует начало и конец каждого наложения
так, чтобы оно оставалось с текстом.  При создании наложения можно указать,
должен ли текст, вставленный в начале, находиться внутри наложения или
снаружи, а также в конце наложения.

@menu
* Managing Overlays::   Создание и перемещение наложений.
* Overlay Properties::  Как читать и устанавливать свойства.
                          Какие свойства влияют на отображение на экране.
* Finding Overlays::    Поиск наложений.
@end menu

@node Managing Overlays
@subsection Управление Наложениями
@cindex managing overlays
@cindex overlays, managing

  В этом разделе описаны функции для создания, удаления и перемещения
наложений, а также для проверки их содержимого.  Изменения наложения не
записываются в список отмены буфера, поскольку наложения не являются частью
содержимого буфера.

@defun overlayp object
Функция возвращает @code{t}, если @var{object} является наложением.
@end defun

@defun make-overlay start end &optional buffer front-advance rear-advance
Функция создает и возвращает наложение, которое принадлежит @var{buffer} и
находится в диапазоне от @var{start} до @var{end}.  И @var{start}, и
@var{end} должны указывать позиции буфера; они могут быть целыми числами или
маркерами.  Если @var{buffer} не указан, наложение создается в текущем
буфере.

@cindex empty overlay
@cindex overlay, empty
Наложение, у которого @var{start} и @var{end} задают одну и ту же позицию в
буфере, называется @dfn{пустым}.  Непустое наложение может стать пустым,
если удалить текст между его @var{start} и @var{end}.  Когда это происходит,
наложение по умолчанию не удаляется, но можно вызвать его удаление, задав
ему свойство @samp{evaporate}
(@pxref{Overlay Properties, evaporate property}).

Аргументы @var{front-advance} и @var{rear-advance} определяют тип вставки
маркера для начала и для конца наложения соответственно.
@xref{Marker Insertion Types}.  Если они оба имеют значение по умолчанию
@code{nil}, то наложение расширяется, чтобы включить любой текст,
вставленный в начале, но не текст, вставленный в конец.  Если
@var{front-advance} равен не-@code{nil}, текст, вставленный в начале
наложения, исключается из наложения.  Если @var{rear-advance} равен
не-@code{nil}, текст, вставленный в конце наложения, включается в наложение.
@end defun

@defun overlay-start overlay
Функция возвращает позицию, с которой начинается @var{overlay}, в виде
целого числа.
@end defun

@defun overlay-end overlay
Функция возвращает позицию, в которой заканчивается @var{overlay}, в виде
целого числа.
@end defun

@defun overlay-buffer overlay
Функция возвращает буфер, которому принадлежит @var{overlay}.  Возвращается
@code{nil}, если @var{overlay} был удален.
@end defun

@defun delete-overlay overlay
Функция удаляет @var{overlay}.  Наложение продолжает существовать как объект
Lisp, и его список свойств не изменяется, но он перестает быть привязанным к
буферу, которому он принадлежал, и перестает оказывать какое-либо влияние на
отображение.

Удаленное наложение не отключается навсегда.  Можно снова присвоить ему
позицию в буфере, вызовом @code{move-overlay}.
@end defun

@defun move-overlay overlay start end &optional buffer
Функция перемещает @var{overlay} в @var{buffer} и помещает его границы в
@var{start} и @var{end}.  Оба аргумента @var{start} и @var{end} должны
указывать позиции буфера; они могут быть целыми числами или маркерами.

Если @var{buffer} опущено, @var{overlay} остается в том же буфере, с которым
оно уже был связано; если @var{overlay} было удалено, оно попадает в текущий
буфер.

Возвращаемое значение - @var{overlay}.

Это единственный допустимый способ изменить конечные точки наложения.  Не
пытаться изменять маркеры в наложении вручную, так как это не приведет к
обновлению других жизненно важных структур данных и может привести к
потере некоторых наложений.
@end defun

@defun remove-overlays &optional start end name value
Функция удаляет все перекрытия между @var{start} и @var{end}, свойство
@var{name} которых имеет значение @var{value}.  Может перемещать конечные
точки наложений в регионе или разделять их.

Если @var{name} не указано или @code{nil}, это означает удаление всех
наложений в указанном регионе.  Если @var{start} и/или @var{end} опущено или
@code{nil}, это означает начало и конец буфера соответственно.
Следовательно, @code{(remove-overlays)} удаляет все наложения в текущем
буфере.
@end defun

@defun copy-overlay overlay
Функция возвращает копию @var{overlay}.  Копия имеет те же конечные точки и
свойства, что и @var{overlay}.  Однако для типа вставки маркера для начала и
для конца наложения установлены значения по умолчанию
(@pxref{Marker Insertion Types}).
@end defun

  Вот несколько примеров:

@example
;; @r{Создать наложение.}
(setq foo (make-overlay 1 10))
     @result{} #<overlay from 1 to 10 in display.texi>
(overlay-start foo)
     @result{} 1
(overlay-end foo)
     @result{} 10
(overlay-buffer foo)
     @result{} #<buffer display.texi>
;; @r{Задать ему собственность, которую можно проверить позже.}
(overlay-put foo 'happy t)
     @result{} t
;; @r{Убедиться, что собственность присутствует.}
(overlay-get foo 'happy)
     @result{} t
;; @r{Переместить наложение.}
(move-overlay foo 5 20)
     @result{} #<overlay from 5 to 20 in display.texi>
(overlay-start foo)
     @result{} 5
(overlay-end foo)
     @result{} 20
;; @r{Удалите наложение.}
(delete-overlay foo)
     @result{} nil
;; @r{Убедиться, что оно удалено.}
foo
     @result{} #<overlay in no buffer>
;; @r{Удаленное наложение не имеет позиции.}
(overlay-start foo)
     @result{} nil
(overlay-end foo)
     @result{} nil
(overlay-buffer foo)
     @result{} nil
;; @r{Отменить удаление наложения.}
(move-overlay foo 1 20)
     @result{} #<overlay from 1 to 20 in display.texi>
;; @r{Проверить результаты.}
(overlay-start foo)
     @result{} 1
(overlay-end foo)
     @result{} 20
(overlay-buffer foo)
     @result{} #<buffer display.texi>
;; @r{Перемещение и удаление наложения не меняют его свойств.}
(overlay-get foo 'happy)
     @result{} t
@end example

  Emacs хранит наложения каждого буфера в двух списках, разделенных вокруг
произвольной центральной позиции.  Один список простирается назад через
буфер из этого центрального положения, а другой - вперед из этого
центрального положения.  Центральное положение может быть где угодно в
буфере.

@defun overlay-recenter pos
Функция повторно центрирует наложение текущего буфера вокруг позиции
@var{pos}.  Это ускоряет поиск наложения для позиций около @var{pos}, но
замедляет для позиций далеко от @var{pos}.
@end defun

  Цикл, который просматривает буфер вперед, создавая наложения, может
работать быстрее, если сначала выполнить
@code{(overlay-recenter (point-max))}.

@node Overlay Properties
@subsection Overlay Properties
@cindex overlay properties

  Overlay properties are like text properties in that the properties that
alter how a character is displayed can come from either source.  But in
most respects they are different.  @xref{Text Properties}, for comparison.

  Свойства текста считаются частью текста; наложения и их свойства не считаются
частью текста.  Таким образом, копирование текста между различными буферами и
строками сохраняет свойства текста, но не пытается сохранить наложения.  Изменение
текстовых свойств буфера помечает буфер как измененный, в то время как перемещение
наложения или изменение его свойств - нет.  В отличие от изменений свойств текста,
изменения свойств наложения не записываются в список отмены буфера.

  Поскольку несколько наложений могут указывать значение свойства для одного и того
же символа, Emacs позволяет определять значение приоритета для каждого наложения.
Значение приоритета используется, чтобы решить, какое из перекрывающихся наложений
будет ``выигрывать''.

  Эти функции читают и устанавливают свойства наложения:

@defun overlay-get overlay prop
Функция возвращает значение свойства @var{prop}, записанное в @var{overlay}, если
оно есть.  Если @var{overlay} не записывает никакого значения для этого свойства,
но имеет свойство @code{category}, которое является символом, используется свойство
@var{prop} этого символа.  В противном случае значение @code{nil}.
@end defun

@defun overlay-put overlay prop value
Функция устанавливает значение свойства @var{prop}, записанное в @var{overlay},
на @var{value}.  Возвращает @var{value}.
@end defun

@defun overlay-properties overlay
Это возвращает копию списка свойств @var{overlay}.
@end defun

  Смотреть также функцию @code{get-char-property}, которая проверяет свойства
наложения и свойства текста для данного символа.  @xref{Examining Properties}.

  Многие свойства наложения имеют особое значение; вот их таблица:

@table @code
@item priority
@kindex priority @r{(overlay property)}
Значение этого свойства определяет приоритет наложения.  Если требуется указать
значение приоритета, использовать либо @code{nil} (или ноль), либо положительное
целое число.  Любое другое значение имеет неопределенное поведение.

Приоритет имеет значение, когда два или более наложения покрывают один и тот же
символ и оба определяют одно и то же свойство; тот, у которого значение
@code{priority} больше, перекрывает другое.  (Для свойства @code{face} значение
наложения с более высоким приоритетом не полностью перекрывает другое значение;
вместо этого его атрибуты вида отображения переопределяют атрибуты вида отображения
свойства @code{face} с более низким приоритетом.)  Если два наложения имеют
одинаковое значение приоритета, а один вложен в другой, тогда внутренний будет
преобладать над внешним.  Если ни один из них не вложен в другой, не следует делать
предположений о том, какое наложение будет преобладать.

В настоящее время все наложения имеют приоритет над свойствами текста.

Обратить внимание, что Emacs иногда использует нечисловые значения приоритета для
некоторых своих внутренних наложений, поэтому не пытаться выполнять арифметические
операции с приоритетом наложения (если только оно не создано отдельно).  В частности,
наложение, используемое для отображения области, использует значение приоритета в
форме @w{@code{(@var{primary} . @var{secondary})}}, где значение @var{primary}
используется, как описано выше, а @var{secondary} - это резервное значение,
используемое, когда @var{primary} и соображения вложенности не могут решить приоритет
между наложениями.  Однако не рекомендуется разрабатывать программы на Lisp,
основанные на этой детали реализации; если нужно расположить наложения в порядке
приоритета, использовать аргумент @var{sorted} для @code{overlays-at}.
@xref{Finding Overlays}.

@item window
@kindex window @r{(overlay property)}
Если свойство @code{window} - не-@code{nil}, то наложение применяется только к
этому окну.

@item category
@kindex category @r{(overlay property)}
Если наложение имеет свойство @code{category}, называется оно @dfn{категорией}
наложения.  Это должно быть символом.  Свойства символа служат значениями по
умолчанию для свойств наложения.

@item face
@kindex face @r{(overlay property)}
Свойство управляет внешним видом текста (@pxref{Faces}).  Оценка результата
может быть следующей:

@itemize @bullet
@item
Имя вида отображения (символ или строка).

@item
Анонимный вид отображения: список свойств в форме
@code{(@var{keyword} @var{value} @dots{})}, где каждое @var{keyword} - это имя
атрибута лица, а @var{value} - значение этого атрибута.

@item
Список видов отображения.  Каждый элемент списка должен быть либо именем вида, либо
анонимным видом отображения.  Это определяет вид, который является совокупностью
атрибутов каждого из перечисленных видов отображения.  Виды, встречающиеся раньше в
списке, имеют более высокий приоритет.

@item
Конс-ячейка вида @code{(foreground-color . @var{color-name})} или
@code{(background-color . @var{color-name})}.  Определяет цвет переднего плана
или фона, аналогично @code{(:foreground @var{color-name})} или
@code{(:background @var{color-name})}.  Эта форма поддерживается только для
обратной совместимости, и ее следует избегать.
@end itemize

@item mouse-face
@kindex mouse-face @r{(overlay property)}
Свойство используется вместо @code{face}, когда мышь находится в пределах диапазона
наложения.  Однако Emacs игнорирует все атрибуты вида отображения из этого свойства,
которые изменяют размер текста (например, @code{:height}, @code{:weight} и
@code{:slant}).  Эти атрибуты всегда такие же, как в невыделенном тексте.

@item display
@kindex display @r{(overlay property)}
Свойство активирует различные функции, которые изменяют способ отображения текста.
Например, может сделать текст выше или короче, выше или ниже, шире или уже или
замениться изображением.  @xref{Display Property}.

@item help-echo
@kindex help-echo @r{(overlay property)}
Если наложение имеет свойство @code{help-echo}, то, когда наводится указатель мыши
на текст наложения, Emacs отображает строку справки в эхо-области или в окне
всплывающей подсказки.  Подробности смотреть @ref{Text help-echo}.

@item field
@kindex field @r{(overlay property)}
@c Скопировано из Special Properties.
Последовательные символы с одним и тем же свойством @code{field} составляют
@emph{поле}.  Некоторые функции движения, включая @code{forward-word} и
@code{beginning-of-line}, перестают двигаться на границе поля.
@xref{Fields}.

@item modification-hooks
@kindex modification-hooks @r{(overlay property)}
Значение этого свойства представляет собой список функций, которые должны быть
вызваны, если какой-либо символ в наложении изменяется или если текст вставляется
строго внутри наложения.

Функции ловушки вызываются как до, так и после каждого изменения.  Если функции
сохраняют информацию, которую они получают, и сравнивают примечания между вызовами,
они могут точно определить, какое изменение было внесено в текст буфера.

При вызове перед изменением каждая функция получает четыре аргумента: наложение,
@code{nil}, а также начало и конец изменяемого текстового диапазона.

При вызове после изменения каждая функция получает пять аргументов: наложение,
@code{t}, начало и конец только что измененного текстового диапазона и длину текста
до изменения, замененного этим диапазоном.  (Для вставки длина до изменения равна
нулю; для удаления эта длина равна количеству удаленных символов, а начало и конец
после изменения равны.)

Если эти функции модифицируют буфер, они должны привязать
@code{inhibit-modification-hooks} к @code{t} вокруг этого, чтобы избежать путаницы
во внутреннем механизме, вызывающем эти хуки.

Свойства текста также поддерживают свойство @code{modification-hooks}, но детали
несколько отличаются от (@pxref{Special Properties}).

@item insert-in-front-hooks
@kindex insert-in-front-hooks @r{(свойства наложения)}
Значение этого свойства представляет собой список функций, которые должны быть
вызваны до и после вставки текста в самом начале наложения.  Соглашения о вызовах
такие же, как для функций @code{modification-hooks}.

@item insert-behind-hooks
@kindex insert-behind-hooks @r{(свойства наложения)}
Значение этого свойства представляет собой список функций, которые должны быть
вызваны до и после вставки текста прямо в конце наложения.  Соглашения о вызовах
такие же, как для функций @code{modification-hooks}.

@item invisible
@kindex invisible @r{(свойства наложения)}
Свойство @code{invisible} может сделать текст в наложении невидимым, что означает,
что он не отображается на экране.  @xref{Invisible Text}, для подробностей.

@item intangible
@kindex intangible @r{(свойства наложения)}
Свойство @code{intangible} наложения работает так же, как текстовое свойство
@code{intangible}.  Это устарело.  @xref{Special Properties}, для подробностей.

@item isearch-open-invisible
Свойство сообщает инкрементному поиску, как сделать невидимое наложение видимым
навсегда, если последнее совпадение перекрывает его.  @xref{Invisible Text}.

@item isearch-open-invisible-temporary
Свойство сообщает инкрементному поиску, как временно сделать невидимое наложение
видимым во время поиска.  @xref{Invisible Text}.

@item before-string
@kindex before-string @r{(свойства наложения)}
Значение свойства представляет собой строку, добавляемую к отображению в начале
наложения.  Строка ни в каком смысле не появляется в буфере - только на экране.

@item after-string
@kindex after-string @r{(свойства наложения)}
Значение свойства представляет собой строку, добавляемую к отображению в конце
наложения.  Строка ни в каком смысле не появляется в буфере - только на экране.

@item line-prefix
Свойство указывает спецификацию отображения, добавляемую к каждой непродолжительной
строке во время отображения.  @xref{Truncation}.

@item wrap-prefix
Свойство указывает спецификацию отображения, добавляемую к каждой строке
продолжения во время отображения.  @xref{Truncation}.

@item evaporate
@kindex evaporate @r{(свойства наложения)}
Если свойство - не-@code{nil}, наложение удаляется автоматически, если оно становится
пустым (то есть если его длина становится равной нулю).  Если дать пустому наложению
(@pxref{Managing Overlays, empty overlay}) свойство не-@code{nil} @code{evaporate},
оно немедленно удалит его.  Обратить внимание: если наложение не имеет этого свойства,
оно не будет удалено, когда текст между его начальной и конечной позициями будет
удален из буфера.

@item keymap
@cindex keymap of character (and overlays)
@kindex keymap @r{(свойства наложения)}
Если свойство - не-@code{nil}, оно определяет ключевую карту для части текста.
Эта карта используется, когда символ после точки находится внутри наложения, и имеет
приоритет над большинством других карт.  @xref{Active Keymaps}.

@item local-map
@kindex local-map @r{(свойства наложения)}
Свойство @code{local-map} похоже на @code{keymap}, но заменяет локальную карту
буфера, а не увеличивает существующие ключевые карты.  Это также означает, что у
него более низкий приоритет, чем у карт вспомогательных режимов.
@end table

Свойства @code{keymap} и @code{local-map} не влияют на строку, отображаемую
свойствами @code{before-string}, @code{after-string} или @code{display}.  Это
актуально только для щелчков мыши и других событий мыши, которые попадают в строку,
поскольку точка никогда не находится в строке.  Чтобы привязать к строке специальные
события мыши, присвойте ей текстовое свойство @code{keymap} или @code{local-map}.
@xref{Special Properties}.

@node Finding Overlays
@subsection Поиск Наложений
@cindex searching for overlays
@cindex overlays, searching for

@defun overlays-at pos &optional sorted
Функция возвращает список всех наложений, которые покрывают символ в позиции
@var{pos} в текущем буфере.  Если @var{sorted} равно не-@code{nil}, список находится
в порядке убывания приоритета, в противном случае - без определенного порядка.
Наложение содержит позицию @var{pos}, если оно начинается с @var{pos} или до него,
и заканчивается после @var{pos}.

Чтобы проиллюстрировать использование, вот функция Lisp, которая возвращает список
наложений, которые определяют свойство @var{prop} для символа в точке:

@smallexample
(defun find-overlays-specifying (prop)
  (let ((overlays (overlays-at (point)))
        found)
    (while overlays
      (let ((overlay (car overlays)))
        (if (overlay-get overlay prop)
            (setq found (cons overlay found))))
      (setq overlays (cdr overlays)))
    found))
@end smallexample
@end defun

@defun overlays-in beg end
Функция возвращает список наложений, перекрывающих области от @var{beg} до @var{end}.
Наложение перекрывается с областью, если оно содержит один или несколько символов в
области; пустые наложения (@pxref{Managing Overlays, empty overlay}) перекрываются,
если они находятся в @var{beg}, строго между @var{beg} и @var{end} или в @var{end},
когда @var{end} обозначает позицию в конце буфера.
@end defun

@defun next-overlay-change pos
Функция возвращает позицию в буфере следующего начала или конца наложения после
@var{pos}.  Если его нет, возвращается @code{(point-max)}.
@end defun

@defun previous-overlay-change pos
Функция возвращает позицию в буфере предыдущего начала или конца наложения до
@var{pos}.  Если его нет, возвращается @code{(point-min)}.
@end defun

  В качестве примера приведем упрощенную (и неэффективную) версию примитивной
функции @code{next-single-char-property-change} (@pxref{Property Search}).  Она
ищет вперед от позиции @var{pos} до следующей позиции, где изменяется значение
данного свойства @code{prop}, полученное из наложений или свойств текста.

@smallexample
(defun next-single-char-property-change (position prop)
  (save-excursion
    (goto-char position)
    (let ((propval (get-char-property (point) prop)))
      (while (and (not (eobp))
                  (eq (get-char-property (point) prop) propval))
        (goto-char (min (next-overlay-change (point))
                        (next-single-property-change (point) prop)))))
    (point)))
@end smallexample

@node Size of Displayed Text
@section Размер Отображаемого Текста
@cindex size of text on display
@cindex character width on display

Поскольку не все символы имеют одинаковую ширину, эти функции позволяют проверить
ширину символа.  @xref{Primitive Indent} и @ref{Screen Lines}, для связанных функций.

@defun char-width char
Функция возвращает ширину в столбцах символа @var{char}, если он отображался в
текущем буфере (то есть с учетом таблицы отображения буфера, если таковая имеется;
@pxref{Display Tables}).  Ширина символа табуляции обычно составляет
@code{tab-width} (@pxref{Usual Display}).
@end defun

@defun string-width string
Функция возвращает ширину в столбцах строки @var{string}, если она отображалась
в текущем буфере и выбранном окне.
@end defun

@defun truncate-string-to-width string width &optional start-column padding ellipsis
Функция возвращает часть @var{string}, которая помещается в столбцы @var{width}, в
виде новой строки.

Если @var{string} не достигает @var{width}, результат заканчивается там, где
заканчивается @var{string}.  Если один многостолбцовый символ в @var{string}
проходит через столбец @var{width}, этот символ не включается в результат.  Таким
образом, результат может не соответствовать @var{width}, но не выходить за
его пределы.

Необязательный аргумент @var{start-column} указывает начальный столбец.  Если это
не-@code{nil}, то первые столбцы @var{start-column} строки не включаются в значение.
Если один многостолбцовый символ в @var{string} проходит через столбец
@var{start-column}, этот символ не включается.

Необязательный аргумент @var{padding}, если не-@code{nil}, является символом
заполнения, добавляемым в начало и конец строки результата, чтобы расширить его до
столбцов @var{width}.  Символ заполнения используется в конце результата, если он
не соответствует @var{width}.  Также используется в начале результата, если один
многостолбцовый символ в @var{string} проходит через столбец @var{start-column}.

@vindex truncate-string-ellipsis
Если @var{ellipsis} равно не-@code{nil}, это должно быть строкой, которая заменит
конец @var{string} (включая любые отступы), если выходит за пределы @var{width}, за
исключением случаев, когда ширина отображения @var{string} равна или меньше ширины
отображения @var{ellipsis}.  Если @var{ellipsis} - это не-@code{nil}, а не строка,
это означает значение переменной @code{truncate-string-ellipsis}.

@example
(truncate-string-to-width "\tab\t" 12 4)
     @result{} "ab"
(truncate-string-to-width "\tab\t" 12 4 ?\s)
     @result{} "    ab  "
@end example
@end defun

Следующая функция возвращает размер текста в пикселях, как если бы он отображался
в данном окне.  Функция используется @code{fit-window-to-buffer} и
@code{fit-frame-to-buffer} (@pxref{Resizing Windows}), чтобы сделать окно точно
таким же большим, как и текст, который в нем содержится.

@defun window-text-pixel-size &optional window from to x-limit y-limit mode-and-header-line
Функция возвращает размер текста буфера @var{window}'s в пикселях.  @var{window}
должно быть активным окном и по умолчанию устанавливаться выбранным.  Возвращаемое
значение является cons-ячейкой максимальной ширины в пикселях любой текстовой строки
и максимальной высоты в пикселях всех текстовых строк.

Необязательный аргумент @var{from}, если не-@code{nil}, указывает первую позицию
текста для рассмотрения и по умолчанию используется минимальная доступная позиция
буфера.  Если @var{from} установленно в @code{t}, используется минимально доступная
позиция, которая не является символом новой строки.  Необязательный аргумент @var{to},
если не-@code{nil}, указывает последнюю позицию текста для рассмотрения и по умолчанию
используется максимально доступная позиция буфера.  Если @var{to} равно @code{t},
используется максимально доступная позиция, которая не является символом новой строки.

Необязательный аргумент @var{x-limit}, если не-@code{nil}, указывает максимальную
ширину в пикселях, которая может быть возвращена.  @var{x-limit} установлено в
@code{nil} или опущено, означает использовать пиксельную ширину тела @var{window}
(@pxref{Window Sizes}); это полезно, когда вызывающий не намеревается изменять ширину
@var{window}.  В противном случае вызывающий должен указать здесь максимальную ширину,
которую может принимать тело @var{window}.  Текст, координата x которого находится за
пределами @var{x-limit}, игнорируется.  Поскольку вычисление ширины длинных строк
может занять некоторое время, всегда рекомендуется делать этот аргумент настолько
маленьким, насколько это необходимо; в частности, если буфер может содержать длинные
строки, которые в любом случае будут усечены.

Необязательный аргумент @var{y-limit}, если не-@code{nil}, указывает максимальную
высоту в пикселях, которая может быть возвращена.  Строки текста, координата Y которых
выходит за пределы @var{y-limit}, игнорируются.  Поскольку вычисление высоты в
пикселях большого буфера может занять некоторое время, имеет смысл указать этот
аргумент; в частности, если вызывающий не знает размер буфера.

Необязательный аргумент @var{mode-and-header-line} установленный в @code{nil} или
опущен означает, что в возвращаемое значение не включается высота строки режима или
заголовка @var{window}.  Если это символ @code{mode-line} или @code{header-line},
включить в возвращаемое значение только высоту этой строки, если она есть.  Если это
@code{t}, включить высоту обоих, если есть, в возвращаемое значение.
@end defun

@code{window-text-pixel-size} обрабатывает текст, отображаемый в окне, как единое
целое и не заботится о размере отдельных строк.  Следующая функция это выполняет.

@defun window-lines-pixel-dimensions &optional window first last body inverse left
Функция вычисляет размеры в пикселях каждой строки, отображаемой в указанном
@var{window}.  Это делается путем обхода текущей матрицы глифов @var{window}'s -
матрицы, хранящей глиф (@pxref{Glyphs}) каждого символа буфера, отображаемого в
настоящее время в @var{window}.  В случае успеха возвращается список cons пар,
представляющих x- и y-координаты нижнего правого угла последнего символа каждой
строки.  Координаты измеряются в пикселях от начала координат (0, 0) в верхнем левом
углу @var{window}.  @var{window} должно быть активным окном и по умолчанию
установленным выбранным.

Если необязательный аргумент @var{first} является целым числом, обозначается
индекс (начиная с 0) первой строки возвращаемой матрицы глифов @var{window}.
Обратить внимание, что если @var{window} имеет строку заголовка, строка с индексом
0 является этой строкой заголовка.  Если @var{first} - @code{nil}, первая
рассматриваемая строка определяется значением необязательного аргумента @var{body}:
если @var{body} - не-@code{nil}, это означает, что нужно начинать с первой строки
тела @var{window}, пропуская любую строку заголовка, если таковая имеется.  В
противном случае функция будет начинаться с первой строки матрицы глифов
@var{window}, возможно, строк заголовка.

Если необязательный аргумент @var{last} является целым числом, обозначается
индекс последней строки матрицы глифов @var{window}, которая должна быть возвращена.
Если @var{last} равно @code{nil}, последняя строка, которая должна быть рассмотрена,
определяется значением @var{body}: Если @var{body} равно не-@code{nil}, это означает
использование последней строки тела @var{window}, опуская строку режима
@var{window}, если она есть.  В противном случае это означает использование последней
строки @var{window}, которая может быть строкой режима.

Необязательный аргумент @var{inverse}, если @code{nil}, означает, что значение
y-пикселя, возвращаемое для любой строки, указывает расстояние в пикселях от левого
края (край тела, если @var{body} - не-@code{nil}) @var{window} до правого края
последнего глифа этой строки.  @var{inverse} в не-@code{nil} означает, что значение
y-пикселя, возвращаемое для любой строки, определяет расстояние в пикселях от правого
края последнего глифа этой строки до правого края (край тела, если @var{body} равно
не-@code{nil}) @var{window}.  Это полезно для определения количества свободного
места в конце каждой строки.

Необязательный аргумент @var{left}, если не-@code{nil} означает возвращение x- и
y-координат нижнего левого угла самого левого символа в каждой строке.  Это значение
следует использовать для окон, которые в основном отображают текст справа налево.

Если @var{left} - не-@code{nil}, а @var{inverse} - @code{nil}, это означает, что
значение y-пикселя, возвращаемое для любой строки, определяет расстояние в пикселях
от левого края последнего (крайнего левого) глифа этой строки до правого края (края
тела, если @var{body} имеет значение не-@code{nil}) из @var{window}.  Если
@var{left} и @var{inverse} оба являются не-@code{nil}, значение y-пикселя,
возвращаемое для любой строки, указывает расстояние в пикселях от левого края (край
тела, если @var{body} - не-@code{nil}) @var{window} до левого края последнего
(крайнего левого) глифа этой строки .

Функция возвращает @code{nil}, если текущая матрица глифов @var{window} устарела,
что обычно происходит, когда Emacs занят, например, при обработке команды.  Однако
значение должно быть получено, когда эта функция запускается из таймера простоя с
задержкой в ноль секунд.
@end defun

@defun line-pixel-height
Функция возвращает высоту в пикселях линии в точке в выбранном окне.  Значение
включает межстрочный интервал между строками (@pxref{Line Height}).
@end defun

Когда буфер отображается с номерами строк
(@pxref{Display Custom,,, emacs, The GNU Emacs Manual}), иногда полезно знать ширину,
используемую для отображения номеров строк.  Следующая функция предназначена для
программ на Lisp, которым эта информация нужна для расчетов компоновки.

@defun line-number-display-width &optional pixelwise
Функция возвращает ширину, используемую для отображения номеров строк в выбранном
окне.  Если необязательный аргумент @var{pixelwise} - это символ @code{columns},
возвращаемое значение - число с плавающей запятой канонических столбцов фрейма; если
@var{pixelwise} равно @code{t} или любому другому значению не-@code{nil}, значение
является целым числом и измеряется в пикселях.  Если @var{pixelwise} опущено или
@code{nil}, значение представляет собой целое число столбцов шрифта, определенного
для вида отображения @code{line-number}, и не включает 2 столбца, используемые для
заполнения отображаемых чисел.  Если номера строк не отображаются в выбранном окне,
значение равно нулю независимо от значения @var{pixelwise}.  Использовать
@code{with-selected-window} (@pxref{Selecting Windows}), если требуется эта
информация о другом окне.
@end defun


@node Line Height
@section Высота Строки
@cindex line height
@cindex height of a line

  Общая высота отображения строки состоит из высоты содержимого строки плюс
необязательный дополнительный вертикальный интервал между строками выше или ниже
отображения строки.

  Высота содержимого строки - это максимальная высота любого символа или изображения
в этой строке отображения, включая последнюю новую строку, если таковая имеется.
(Продолжающееся отображение строки не включает последний символ новой строки.)  Это
высота строки по умолчанию, если не сделать ничего, чтобы указать большую высоту.
(В наиболее частом случае это равно высоте шрифта по умолчанию для соответствующего
фрейма, смотреть @ref{Frame Font}.)

  Существует несколько способов явно указать большую высоту строки, указав абсолютную
высоту отображения строки или указав вертикальный интервал.  Однако, что бы ни
указать, фактическая высота строки никогда не может быть меньше значения по умолчанию.

@kindex line-height @r{(свойства текста)}
  Новая строка может иметь текст @code{line-height} или свойство наложения, которое
управляет общей высотой отображаемой строки, заканчивающейся этой новой строкой.

  Если значение свойства - @code{t}, символ новой строки не влияет на отображаемую
высоту строки - только видимое содержимое определяет высоту.  Свойство
@code{line-spacing}, описанное ниже, в этом случае также игнорируется.  Это полезно
для мозаики небольших изображений (или фрагментов изображений) без добавления пустых
областей между изображениями.

  Если значением свойства является список вида @code{(@var{height} @var{total})},
@emph{ниже} добавляется дополнительное пространство в отображении строки.  Сначала
Emacs использует @var{height} в качестве спецификации высоты для управления лишним
пространством @emph{выше} строки; затем он добавляет в строку достаточно места, чтобы
общая высота строки увеличилась до @var{total}.  В этом случае игнорируется любое
значение свойства @code{line-spacing} для новой строки.

@cindex height spec
  Любой другой тип значения свойства - это спецификация высоты, которая переводится
в число - указывающее высоту строки.  Есть несколько способов написать спецификацию
высоты; вот как каждая из них переводится в число:

@table @code
@item @var{integer}
Если спецификация высоты является положительным целым числом, значение высоты -
это целое число.
@item @var{float}
Если спецификация высоты является плавающей, @var{float}, числовое значение высоты
равно @var{float}, умноженное на высоту строки фрейма по умолчанию.
@item (@var{face} . @var{ratio})
Если спецификация высоты является cons-ячейкой показанного формата, числовая высота
в @var{ratio} умножена на высоту вида отображения @var{face}.  @var{ratio} может быть
числом любого типа или @code{nil}, что означает коэффициент 1.  Если @var{face} равно
@code{t}, это относится к текущему виду отображения.
@item (nil . @var{ratio})
Если спецификация высоты является cons-ячейкой показанного формата, числовая высота
в @var{ratio} раз больше высоты содержимого строки.
@end table

  Таким образом, любая допустимая спецификация высоты так или иначе определяет высоту
в пикселях.  Если высота содержимого строки меньше этой, Emacs добавляет
дополнительное вертикальное пространство над строкой для достижения указанной общей
высоты.

  Если не указано свойство @code{line-height}, высота строки будет складываться из
высоты содержимого плюс межстрочный интервал.  Есть несколько способов указать
межстрочный интервал для разных частей текста Emacs.

  В графических терминалах можно указать межстрочный интервал для всех строк в фрейме,
используя параметр фрейма @code{line-spacing} (@pxref{Layout Parameters}).  Однако,
если значение @code{line-spacing} по умолчанию - не-@code{nil}, оно переопределяет
параметр фрейма @code{line-spacing}.  Целое число определяет количество пикселей,
помещаемых под строками.  Число с плавающей запятой определяет интервал относительно
высоты строки фрейма по умолчанию.

@vindex line-spacing
  Можно указать межстрочный интервал для всех строк в буфере через локальную в буфере
переменную @code{line-spacing}.  Целое число определяет количество пикселей,
помещаемых под строками.  Число с плавающей запятой указывает интервал относительно
высоты строки фрейма по умолчанию.  Это отменяет межстрочный интервал, указанный
для фрейма.

@kindex line-spacing @r{(text property)}
  Наконец, новая строка может иметь текст @code{line-spacing} или свойство наложения,
которое может увеличивать межстрочный интервал между фреймами по умолчанию или
локальная переменная @code{line-spacing} в буфере: со значением больше, чем
значение по умолчанию для буфера или фрейма, вместо этого используется большее
значение для отображение строки, заканчивающейся этой новой строкой.

  Так или иначе, эти механизмы определяют значение Lisp для интервала каждой строки.
Значение является спецификацией высоты и переводится в значение Lisp, как описано
выше.  Однако в этом случае числовое значение высоты указывает межстрочный интервал,
а не высоту строки.

  На текстовых терминалах нельзя изменить межстрочный интервал.

@node Faces
@section Виды Отображения
@cindex faces

  @dfn{Вид отображения} - это набор графических атрибутов для отображения текста:
шрифт, цвет переднего плана, цвет фона, необязательное подчеркивание и так далее.
Виды управляют тем, как Emacs отображает текст в буферах, а также другие части фрейма,
такие как строка режима.

@cindex anonymous face
  Один из способов представить вид - это список свойств атрибутов, например
@code{(:foreground "red" :weight bold)}.  Такой список называется
@dfn{анонимный вид отображения}.  Например, можно назначить анонимный вид в качестве
значения текстового свойства @code{face}, и Emacs отобразит базовый текст с
указанными атрибутами.  @xref{Special Properties}.

@cindex face name
  Чаще вид отображения упоминается через @dfn{имя вида отображения}: символ Lisp,
связанный с набором атрибутов вида@footnote{Для обратной совместимости также можно
использовать строку для указания имени вида; это эквивалентно Lisp символу с тем же
именем.}.  Именованные виды пределяются с помощью макроса @code{defface}
(@pxref{Defining Faces}).  Emacs имеет несколько стандартных именованных видов
(@pxref{Basic Faces}).

  Многие части Emacs требуют именованные виды и не принимают анонимные виды.  К ним
относятся функции, описанные в @ref{Attribute Functions}, и переменная
@code{font-lock-keywords} (@pxref{Search-based Fontification}).  Если не указано иное,
будет использоваться термин @dfn{face} для обозначения только именнованных видов
отображения.

@defun facep object
Функция возвращает значение не-@code{nil}, если @var{object} является именованным
видом: символ Lisp или строка, которая служит именем вида.  В противном случае
возвращает @code{nil}.
@end defun

@menu
* Face Attributes::     Что в виде отображения?
* Defining Faces::      Как определить вид отображения.
* Attribute Functions::  Функции для проверки и установки атрибутов вида отображения.
* Displaying Faces::     Как Emacs комбинирует виды, указанные для символа.
* Face Remapping::      Переназначение видов на альтернативные определения.
* Face Functions::      Как определять и исследовать виды отображения.
* Auto Faces::          Перехватчик для автоматического назначения видов отображений.
* Basic Faces::         Виды отображений, определенные по умолчанию.
* Font Selection::      Поиск лучшего доступного шрифта для вида отображения.
* Font Lookup::         Поиск названий доступных шрифтов и информации о них.
* Fontsets::            Набор шрифтов - это набор шрифтов, которые обрабатывают
                            диапазон наборов символов.
* Low-Level Font::      Lisp представление для шрифтов отображения символов.
@end menu

@node Face Attributes
@subsection Атрибуты Видов Отображения
@cindex face attributes

  @dfn{Атрибуты вида отображения} определяют внешний вид отображения.  В следующей
таблице перечислены все атрибуты вида, их возможные значения и их эффекты.

  Помимо значений, указанных ниже, каждый атрибут вида может иметь значение
@code{unspecified}.  Это специальное значение означает, что вид не указывает этот
атрибут напрямую.  Атрибут @code{unspecified} указывает Emacs вместо этого ссылаться
на родительский вид (смотреть описание атрибута @code{:inherit} ниже); или, в
противном случае, на нижележащий вид (@pxref{Displaying Faces}).  В виде
@code{default} должны быть указаны все атрибуты.

  Некоторые из этих атрибутов имеют значение только на определенных типах дисплеев.
Если дисплей не может обрабатывать определенный атрибут, атрибут игнорируется.

@table @code
@item :family
Название семейства шрифтов (строка).  @xref{Fonts,,, emacs, The GNU Emacs Manual},
для получения дополнительной информации о семействах шрифтов.  Функция
@code{font-family-list} (смотреть ниже) возвращает список доступных семейств.

@item :foundry
Имя @dfn{font foundry} для семейства шрифтов, заданное атрибутом
@code{:family} (строка).  @xref{Fonts,,, emacs, The GNU Emacs Manual}.

@item :width
Относительная ширина символа.  Это должен быть один из символов
@code{ultra-condensed}, @code{extra-condensed}, @code{condensed},
@code{semi-condensed}, @code{normal}, @code{semi-expanded},
@code{expanded}, @code{extra-expanded} или @code{ultra-expanded}.

@item :height
Высота шрифта.  В простейшем случае это целое число в единицах 1/10 пункта.

Значение также может быть числом с плавающей запятой или функцией, которая определяет
высоту относительно @dfn{underlying face} (@pxref{Displaying Faces}).  Значение с
плавающей запятой указывает величину, на которую можно масштабировать высоту
нижележащего вида.  Значение функции вызывается с одним аргументом, высотой
нижележащего вида, и возвращает высоту нового вида.  Если функции передается
целочисленный аргумент, она должна возвращать целое число.

Высота вида по умолчанию должна быть указана с использованием целого числа; значения
с плавающей запятой и функции не допускаются.

@item :weight
Толщина шрифта --- один из символов (от самого плотного до самого тусклого)
@code{ultra-bold}, @code{extra-bold}, @code{bold}, @code{semi-bold}, @code{normal},
@code{semi-light}, @code{light}, @code{extra-light} или @code{ultra-light}.  На
текстовых терминалах, поддерживающих текст с переменной яркостью, любое значение,
превышающее нормальный, отображается как очень яркий, а любое, меньшее, чем
нормальный, отображается как полужирный.

@cindex italic text
@item :slant
Наклон шрифта --- один из символов @code{italic}, @code{oblique}, @code{normal},
@code{reverse-italic} или @code{reverse-oblique}.  На текстовых терминалах,
поддерживающих текст с переменной яркостью, наклонный текст отображается наполовину
ярким.

@item :foreground
Цвет переднего плана, строка.  Значение может быть системным именем цвета или
шестнадцатеричной спецификацией цвета.  @xref{Color Names}.  На черно-белых
дисплеях определенные оттенки серого отображаются с помощью точечных рисунков.

@item :distant-foreground
Альтернативный цвет переднего плана - строка.  Это похоже на @code{:foreground}, но
цвет используется как передний план только тогда, когда цвет фона близок к переднему
плану, который мог бы использоваться.  Это полезно, например, при маркировке текста
(то есть вида области).  Если текст имеет передний план, который виден лицевой
стороной области, используется этот передний план.  Если передний план находится
рядом с фоном лица области, вместо него используется @code{:distant-foreground},
чтобы текст был читабельным.

@item :background
Цвет фона, строка.  Значение может быть системным именем цвета или шестнадцатеричной
спецификацией цвета.  @xref{Color Names}.

@cindex underlined text
@item :underline
Следует ли подчеркивать символы и каким образом.  Возможные значения атрибута
@code{:underline}:

@table @asis
@item @code{nil}
Не подчеркивать.

@item @code{t}
Подчеркнуть вид цветом переднего плана.

@item @var{color}
Подчеркнуть цветом @var{color}, строка, определяющая цвет.

@item @code{(:color @var{color} :style @var{style})}
@var{color} - это либо строка, либо символ @code{foreground-color}, означающий цвет
переднего плана вида.  Отсутствие атрибута @code{:color} означает использование цвета
переднего плана вида.  @var{style} должен быть символом @code{line} или @code{wave},
означающим использование прямой или волнистой линии.  Отсутствие атрибута
@code{:style} означает использование прямой линии.
@end table

@cindex overlined text
@item :overline
Должны ли символы быть подчеркнуты и какого цвета.  Если значение равно @code{t},
при наложении используется цвет переднего плана вида.  Если значение является строкой,
при наложении используется этот цвет.  Значение @code{nil} означает, что не
подчеркивать.

@cindex strike-through text
@item :strike-through
Должны ли символы быть перечеркнутыми и какого цвета.  Значение используется
аналогично @code{:overline}.

@cindex 2D box
@cindex 3D box
@item :box
Следует ли рисовать рамку вокруг символов, его цвет, ширину линий прямоугольника и
трехмерный вид.  Вот возможные значения атрибута @code{:box} и их значение:

@table @asis
@item @code{nil}
Не рисовать рамку.

@item @code{t}
Нарисовать прямоугольник с линиями шириной 1 цветом переднего плана.

@item @var{color}
Нарисовать прямоугольник с линиями шириной 1, цветом @var{color}.

@item @code{(:line-width @var{width} :color @var{color} :style @var{style})}
Таким образом можно явно указать все аспекты рамки.  Значение @var{width} определяет
ширину линий для рисования; по умолчанию равно 1.  Отрицательная ширина
@minus{}@var{n} означает рисование линии шириной @var{n}, верхняя и нижняя части
которой занимают пространство нижележащего текста, таким образом избегая увеличения
высоты символа.

Значение @var{color} определяет цвет для рисования.  По умолчанию используется цвет
переднего плана вида для простых блоков и цвет фона вида для трехмерных блоков.

Значение @var{style} указывает, нужно ли рисовать 3D-блок.  Если это
@code{released-button}, поле выглядит как 3D-кнопка, которую не нажимают.  Если это
@code{pressed-button}, поле выглядит как нажатая 3D-кнопка.  Если равно
@code{nil} или опущено, используется простой 2D-блок.
@end table

@item :inverse-video
Должны ли символы отображаться в инверсном видео.  Значение должно быть
@code{t} (да) или @code{nil} (нет).

@item :stipple
Фон точечный, растровый.

Значение может быть строкой; это должно быть имя файла, содержащего данные
растрового Х изображения внешнего формата.  Файл находится в каталогах, перечисленных
в переменной @code{x-bitmap-file-path}.

В качестве альтернативы значение может указывать растровое изображение напрямую со
списком в форме @code{(@var{width} @var{height} @var{data})}.  Здесь @var{width} и
@var{height} указывает размер в пикселях, а @var{data} - это строка, содержащая
необработанные биты битовой карты, строка за строкой.  Каждая строка занимает в
строке @math{(@var{width} + 7) / 8} последовательных байта (для достижения наилучших
результатов она должна быть однобайтной).  Это означает, что каждая строка всегда
занимает не менее одного целого байта.

Если значение равно @code{nil}, это означает, что штриховой узор не используется.

Обычно не нужно устанавливать атрибут штриховки, потому что он используется
автоматически для обработки определенных оттенков серого.

@item :font
Шрифт, используемый для отображения вида.  Его значение должно быть объектом шрифта
или набором шрифтов.  @xref{Low-Level Font}, для получения информации об объектах
шрифтов, спецификациях шрифтов и объектах шрифтов.  @xref{Fontsets}, для получения
информации о наборах шрифтов.

При указании этого атрибута с помощью @code{set-face-attribute}
(@pxref{Attribute Functions}) также можно указать спецификацию шрифта, объект шрифта
или строку.  Emacs преобразует такие значения в соответствующий объект шрифта и
сохраняет этот объект шрифта как фактическое значение атрибута.  Если указываеть
строку, ее содержимым должно быть имя шрифта
(@pxref{Fonts,,, emacs, The GNU Emacs Manual}); если имя шрифта - XLFD, содержащий
подстановочные знаки, Emacs выбирает первый шрифт, соответствующий этим
подстановочным знакам.  Указание этого атрибута также изменяет значения атрибутов
@code{:family}, @code{:foundry}, @code{:width}, @code{:height}, @code{:weight} и
@code{:slant}.

@cindex inheritance, for faces
@item :inherit
Имя вида, от которого наследуются атрибуты, или список имен видов.  Атрибуты
унаследованных видов объединяются в вид, как это было бы с нижележащим видом, с
более высоким приоритетом, чем нижележащие виды (@pxref{Displaying Faces}).  Если
вид, от которого наследуется @code{unspecified}, обрабатывается так же, как
@code{nil}, поскольку Emacs никогда не объединяет атрибуты @code{:inherit}.  Если
используется список видов, атрибуты видов, представленных ранее в списке,
переопределяют атрибуты видов более поздних видов.
@end table

@defun font-family-list &optional frame
Функция возвращает список доступных имён семейств шрифтов.  Необязательный аргумент
@var{frame} указывает фрейм, в котором должен отображаться текст; если @code{nil},
используется выбранный фрейм.
@end defun

@defopt underline-minimum-offset
Переменная определяет минимальное расстояние между базовой строкой и подчеркиванием в
пикселях при отображении подчеркнутого текста.
@end defopt

@defopt x-bitmap-file-path
Переменная определяет список каталогов для поиска файлов растровых изображений для
атрибута @code{:stipple}.
@end defopt

@defun bitmap-spec-p object
Возвращает @code{t}, если @var{object} - допустимая спецификация растрового
изображения, подходящая для использования с @code{:stipple} (смотреть выше).  В
противном случае возвращается @code{nil}.
@end defun

@node Defining Faces
@subsection Определение Видов Отображения
@cindex defining faces

@cindex face spec
  Обычный способ определить вид отображения - использовать макрос @code{defface}.
Этот макрос связывает имя вида (символ) со @dfn{спецификацией вида отображения} по
умолчанию.  Спецификация вида - это конструкция, которая определяет, какие атрибуты
видадолжен иметь на любом данном терминале; например, спецификация вида может
указывать один цвет переднего плана на высокоцветных терминалах и другой цвет
переднего плана на низкоцветных терминалах.

  Иногда возникает соблазн создать переменную, значением которой является имя вида.
В подавляющем большинстве случаев в этом нет необходимости; обычная процедура -
определить вид с помощью @code{defface}, а затем напрямую использовать его имя.

@cindex face (non-removability of)
Обратить внимание, что после того, как определён вид (обычно с помощью
@code{defface}), не выйдет впоследствии безопасно отменить определение этого вида,
кроме как перезапустив Emacs.

@defmac defface face spec doc [keyword value]@dots{}
Этот макрос объявляет @var{face} как именованный вид, спецификация вида которого по
умолчанию задается @var{spec}.  Не требуется заключать в кавычки символ @var{face},
и он не должен заканчиваться на @samp{-face} (это будет лишним).  Аргумент @var{doc} -
это строка документации вида.  Дополнительные аргументы @var{keyword} имеют то же
значение, что и в @code{defgroup} и @code{defcustom} (@pxref{Common Keywords}).

Если @var{face} уже имеет спецификацию вида по умолчанию, этот макрос ничего не
делает.

Спецификация вида по умолчанию определяет внешний вид @var{face}, когда никакие
настройки не действуют.  (@pxref{Customization}).  Если @var{face} уже был настроен
(с помощью пользовательских тем или настроек, считанных из файла инициализации), его
внешний вид определяется спецификациями пользовательского вида, которые переопределяют
спецификацию вида по умолчанию @var{spec}.  Однако, если впоследствии настройки будут
удалены, внешний вид @var{face} снова будет определяться его спецификацией вида по
умолчанию.

@cindex @code{eval-defun}, and @code{defface} forms
В качестве исключения, если оценить форму @code{defface} с помощью @kbd{C-M-x}
(@code{eval-defun}) в режиме  Emacs Lisp, специальная функция @code{eval-defun}
отменяет любые пользовательские спецификации вида в виде, заставляя вид точно
отражать то, что указывает @code{defface}.

Аргумент @var{spec} - это @dfn{спецификация вида}, которая указывает, как вид должен
отображаться на разных типах терминалов.  Это должен быть список, каждый элемент
которого имеет вид

@example
(@var{display} . @var{plist})
@end example

@noindent
@var{display} определяет класс терминалов (смотреть ниже).  @var{plist} - это список
свойств атрибутов вида и их значений, определяющих, как вид отображается на таких
терминалах.  Для обратной совместимости также можно написать элемент как
@code{(@var{display} @var{plist})}.

Часть @var{display} элемента @var{spec} определяет, каким терминалам соответствует
элемент.  Если более одного элемента @var{spec} соответствует данному терминалу,
первый соответствующий элемент - это тот, который используется для этого терминала.
Для @var{display} есть три варианта:

@table @asis
@item @code{default}
Этот элемент @var{spec} не соответствует ни одному терминалу; вместо этого он
определяет значения по умолчанию, которые применяются ко всем терминалам.  Этот
элемент, если он используется, должен быть первым элементом @var{spec}.  Каждый из
следующих элементов может отменять любые или все эти значения по умолчанию.

@item @code{t}
Этот элемент @var{spec} соответствует всем терминалам.  Следовательно, любые
последующие элементы @var{spec} никогда не используются.  Обычно @code{t}
используется в последнем (или единственном) элементе @var{spec}.

@item a list
Если @var{display} - список, каждый элемент должен иметь форму
@code{(@var{characteristic} @var{value}@dots{})}.  Здесь @var{characteristic}
указывает способ классификации терминалов, а @var{value}s - возможные классификации,
к которым должен применяться @var{display}.  Вот возможные значения
@var{characteristic}:

@table @code
@item type
Тип оконной системы, которую использует терминал: @code{graphic} (любой графический
дисплей), @code{x}, @code{pc} (для консоли MS-DOS), @code{w32} (для MS Windows
9X/NT/2K/XP) или @code{tty} (не -графический дисплей).
@xref{Window Systems, window-system}.

@item class
Какие цвета поддерживает терминал - @code{color}, @code{grayscale} или @code{mono}.

@item background
Тип фона --- @code{light} или @code{dark}.

@item min-colors
Целое число, представляющее минимальное количество цветов, которое должен
поддерживать терминал.  Это соответствует терминалу, если его значение
@code{display-color-cells} не меньше указанного целого числа.

@item supports
Может ли терминал отображать атрибуты вида, указанные в @var{value}@dots{}
(@pxref{Face Attributes}).  @xref{Display Face Attribute Testing}, для получения
дополнительной информации о том, как именно проводится это тестирование.
@end table

Если элемент @var{display} указывает более одного @var{value} для данного
@var{characteristic}, любое из этих значений приемлемо.  Если @var{display} имеет
более одного элемента, каждый элемент должен указывать свой @var{characteristic};
то @emph{каждая} характеристика терминала должна соответствовать одному из
@var{value}s, указанных для него в @var{display}.
@end table
@end defmac

  Например, вот определение стандартного вида @code{highlight}:

@example
(defface highlight
  '((((class color) (min-colors 88) (background light))
     :background "darkseagreen2")
    (((class color) (min-colors 88) (background dark))
     :background "darkolivegreen")
    (((class color) (min-colors 16) (background light))
     :background "darkseagreen2")
    (((class color) (min-colors 16) (background dark))
     :background "darkolivegreen")
    (((class color) (min-colors 8))
     :background "green" :foreground "black")
    (t :inverse-video t))
  "Базовое вид для мелирования."
  :group 'basic-faces)
@end example

  Внутри Emacs хранит спецификацию каждого вида по умолчанию в свойстве символа
@code{face-defface-spec} (@pxref{Symbol Properties}).  Свойство @code{saved-face}
хранит любую спецификацию вида, сохраненную пользователем с помощью буфера настройки;
свойство @code{customized-face} хранит спецификацию вида, настроенную для текущего
сеанса, но не сохраненную; а свойство @code{theme-face} хранит список, связывающий
активные параметры настройки и пользовательские темы со спецификациями вида для этого
вида.  Строка документации вида хранится в свойстве @code{face-documentation}.

  Обычно вид объявляется только один раз с использованием @code{defface}, и любые
дальнейшие изменения его внешнего вида применяются с использованием инфраструктуры
настройки (например, через пользовательский интерфейс настройки или с помощью функции
@code{custom-set-faces}; @pxref{Applying Customizations}) или путем переназначения
вида (@pxref{Face Remapping}).  В редких случаях, когда требуется изменить
спецификацию вида прямо из Lisp, можно использовать функцию @code{face-spec-set}.

@defun face-spec-set face spec &optional spec-type
Функция применяет @var{spec} как спецификацию вида для @code{face}.  @var{spec}
должно быть спецификацией вида, как описано в вышеупомянутой документации для
@code{defface}.

Функция также определяет @var{face} как допустимое имя вида, если оно еще не указано,
и (повторно) вычисляет его атрибуты на существующих фреймах.

@cindex override spec @r{(for a face)}
Необязательный аргумент @var{spec-type} определяет, какую спецификацию установить.
Если он опущен или @code{nil} или @code{face-override-spec}, эта функция устанавливает
@dfn{переопределение спецификации}, которой переопределяет характеристики вида для
@var{face} всех других типов, упомянутых ниже.  Это полезно при вызове этой функции
вне пользовательского кода.  Если @var{spec-type} равно @code{customized-face} или
@code{saved-face}, эта функция устанавливает индивидуальную спецификацию или
сохраненную пользовательскую спецификацию соответственно.  Если это
@code{face-defface-spec}, эта функция устанавливает спецификацию вида по умолчанию
(ту же, что и @code{defface}).  Если это @code{reset}, эта функция очищает все
спецификации настройки и переопределяет спецификации из @var{face} (в этом случае
значение @var{spec} игнорируется).  Влияние любого другого значения @var{spec-type} на
характеристики вида зарезервировано для внутреннего использования, но функция
по-прежнему сама определяет @var{face} и пересчитывает его атрибуты, как описано выше.
@end defun

@node Attribute Functions
@subsection Функции Атрибутов Вида Отображения
@cindex face attributes, access and modification

  В этом разделе описаны функции для прямого доступа и изменения атрибутов
именованного вида.

@defun face-attribute face attribute &optional frame inherit
Функция возвращает значение атрибута @var{attribute} для @var{face} на @var{frame}.

Если @var{frame} опущено или @code{nil}, это означает выбранный фрейм
(@pxref{Input Focus}).  Если @var{frame} - @code{t}, эта функция возвращает значение
указанного атрибута для вновь созданных фреймов (обычно это @code{unspecified}, если
не указано какое-либо значение с помощью @code{set-face-attribute}; смотреть ниже).

Если @var{inherit} равно @code{nil}, учитываются только атрибуты, непосредственно
определенные @var{face}, поэтому возвращаемое значение может быть @code{unspecified}
или относительным значением.  Если @var{inherit} равно не-@code{nil}, определение
@var{face} @var{attribute} объединяется с видами, указанными в его атрибуте
@code{:inherit}; однако возвращаемое значение может по-прежнему быть
@code{unspecified} или относительным.  Если @var{inherit} - это вид или список видов,
тогда результат объединяется с этим видом (или видами), пока не станет определенным
и абсолютным.

Чтобы гарантировать, что возвращаемое значение всегда указано и является абсолютным,
используется значение @code{default} для @var{inherit}; это разрешит любые неуказанные
или относительные значения путем слияния с видом @code{default} (которое всегда
полностью указано).

Например,

@example
(face-attribute 'bold :weight)
     @result{} bold
@end example
@end defun

@c FIXME: Добавить индекс для относительного  --xfq
@defun face-attribute-relative-p attribute value
Функция возвращает не-@code{nil}, если @var{value} при использовании в качестве
значения атрибута вида @var{attribute} является относительным.  Это означает, что
будет изменяться, а не полностью переопределять любое значение, которое поступает от
следующего вида в списке видов или унаследовано от другого вида.

@code{unspecified} - относительное значение для всех атрибутов.  Для @code{:height}
значения числа с плавающей запятой и функцией также являются относительными.

Например:

@example
(face-attribute-relative-p :height 2.0)
     @result{} t
@end example
@end defun

@defun face-all-attributes face &optional frame
Эта функция возвращает список атрибутов @var{face}.  Элементами результата являются
пары имя-значение в форме @w{@code{(@var{attr-name} . @var{attr-value})}}.
Необязательный аргумент @var{frame} указывает фрейм, определение @var{face} которого
нужно вернуть; если опущено или @code{nil}, возвращаемое значение описывает атрибуты
@var{face} по умолчанию для вновь созданных фреймов.
@end defun

@defun merge-face-attribute attribute value1 value2
Если @var{value1} - относительное значение для атрибута @var{attribute} вида,
возвращается его объединенное с базовым значением @var{value2}; в противном случае,
если @var{value1} является абсолютным значением атрибута @var{attribute} вида,
возвращается @var{value1} без изменений.
@end defun

  Обычно Emacs использует характеристики каждого вида для автоматического вычисления
его атрибутов для каждого фрейма (@pxref{Defining Faces}).  Функция
@code{set-face-attribute} может переопределить это вычисление, напрямую назначая
атрибуты виду, либо в конкретном фрейме, либо для всех фреймов.  Эта функция в
основном предназначена для внутреннего использования.

@defun set-face-attribute face frame &rest arguments
Функция устанавливает один или несколько атрибутов @var{face} для @var{frame}.
Атрибуты таким образом переопределяют переопределение спецификаций вида,
принадлежащих @var{face}.

Дополнительные аргументы @var{arguments} определяют атрибуты, которые нужно
установить, и значения для них.  Они должны состоять из чередующихся имен атрибутов
(например, @code{:family} или @code{:underline}) и значений.  Таким образом,

@example
(set-face-attribute 'foo nil :weight 'bold :slant 'italic)
@end example

@noindent
устанавливает для атрибута @code{:weight} значение @code{bold}, а для атрибута
@code{:slant} - значение @code{italic}.


Если @var{frame} равно @code{t}, эта функция устанавливает атрибуты по умолчанию для
вновь созданных фреймов.  Если @var{frame} равно @code{nil}, эта функция устанавливает
атрибуты для всех существующих фреймов, а также для вновь созданных фреймов.
@end defun

  Следующие ниже команды и функции в основном обеспечивают совместимость со старыми
версиями Emacs.  Они работают, вызывая @code{set-face-attribute}.  Значения @code{t}
и @code{nil} (или опущены) для их аргумента @var{frame} обрабатываются так же, как
@code{set-face-attribute} и @code{face-attribute}.  Команды считывают свои аргументы
с помощью минибуфера, если они вызываются в интерактивном режиме.

@deffn Command set-face-foreground face color &optional frame
@deffnx Command set-face-background face color &optional frame
Устанавливают атрибут @code{:foreground} (или атрибут @code{:background}
соответственно) @var{face} в @var{color}.
@end deffn

@deffn Command set-face-stipple face pattern &optional frame
Устанавливает для атрибута @code{:stipple} объекта @var{face} значение @var{pattern}.
@end deffn

@deffn Command set-face-font face font &optional frame
Устанавливает для атрибута @code{:font} объекта @var{face} значение @var{font}.
@end deffn

@defun set-face-bold face bold-p &optional frame
Устанавливает для атрибута @code{:weight} объекта @var{face} значение @var{normal},
если @var{bold-p} равно @code{nil}, и значение @var{bold} в противном случае.
@end defun

@defun set-face-italic face italic-p &optional frame
Устанавливает для атрибута @code{:slant} объекта @var{face} значение @var{normal},
если @var{italic-p} равно @code{nil}, и значение @var{italic} в противном случае.
@end defun

@deffn Command set-face-underline face underline &optional frame
Устанавливает для атрибута @code{:underline} объекта @var{face} значение
@var{underline}.
@end deffn

@deffn Command set-face-inverse-video face inverse-video-p &optional frame
Устанавливает для атрибута @code{:inverse-video} объекта @var{face} значение
@var{inverse-video-p}.
@end deffn

@deffn Command invert-face face &optional frame
Меняет местами цвета переднего плана и фона вида @var{face}.
@end deffn

  Следующие функции проверяют атрибуты вида.  В основном они обеспечивают
совместимость со старыми версиями Emacs.  Если не указано @var{frame}, они будут
ссылаться на выбранный фрейм; @code{t} относится к данным по умолчанию для новых
фреймов.  Возвращается @code{unspecified}, если вид не определяет никакого значения
для этого атрибута.  Если @var{inherit} равно @code{nil}, возвращается только атрибут,
непосредственно определенный видом.  Если @var{inherit} равно не-@code{nil}, то также
рассматриваются любые виды, указанные в его атрибуте @code{:inherit}, а если
@var{inherit} - это вид или список видов, то они также учитываются, пока не будет
найден указанный атрибут.  Чтобы гарантировать, что возвращаемое значение всегда
указано, использовать значение @code{default} для @var{inherit}.

@defun face-font face &optional frame character
Функция возвращает имя шрифта вида @var{face}.

Если указан необязательный аргумент @var{frame}, возвращается имя шрифта @var{face}
для этого фрейма.  Если @var{frame} не указано или @code{nil}, используется выбранный
фрейм.  И в этом случае, если указан необязательный третий аргумент @var{character},
возвращается имя шрифта, используемое для @var{character}.
@end defun

@defun face-foreground face &optional frame inherit
@defunx face-background face &optional frame inherit
Функции возвращают цвет переднего плана (или цвет фона, соответственно) вида
@var{face} в виде строки.  Если цвет не указан, возвращается @code{nil}.
@end defun

@defun face-stipple face &optional frame inherit
Функция возвращает имя точечного рисунка фона вида @var{face} или @code{nil}, если
его нет.
@end defun

@defun face-bold-p face &optional frame inherit
Функция возвращает значение не-@code{nil}, если атрибут @code{:weight} для @var{face}
более жирный, чем обычно (например, один из @code{semi-bold}, @code{bold},
@code{extra-bold} или @code{ultra-bold}).  В противном случае возвращается @code{nil}.
@end defun

@defun face-italic-p face &optional frame inherit
Функция возвращает значение не-@code{nil}, если атрибут @code{:slant} для @var{face}
имеет значение @code{italic} или @code{oblique}, и @code{nil} в противном случае.
@end defun

@defun face-underline-p face &optional frame inherit
Функция возвращает не-@code{nil}, если вид @var{face} указывает атрибут
@code{:underline} установленный в не-@code{nil}.
@end defun

@defun face-inverse-video-p face &optional frame inherit
Функция возвращает не-@code{nil}, если вид @var{face} указывает атрибут  @code{:inverse-video} установленный в не-@code{nil}.
@end defun

@node Displaying Faces
@subsection Отображение Видов Отображения
@cindex displaying faces
@cindex face merging

  Когда Emacs отображает заданный фрагмент текста, внешний вид текста может
определяться видами, взятыми из разных источников.  Если эти различные источники
вместе определяют более одного вида для определенного символа, Emacs объединяет
атрибуты различных видов.  Вот порядок, в котором Emacs объединяет виды, от
наивысшего до самого низкого приоритета:

@itemize @bullet
@item
Если текст состоит из специального глифа, этот глиф может указывать на конкретный
вид.  @xref{Glyphs}.

@item
Если текст находится внутри активной области, Emacs выделяет его с помощью вида
@code{region}.  @xref{Standard Faces,,, emacs, The GNU Emacs Manual}.

@item
Если текст находится внутри наложения со свойством @code{face} установленным в
не-@code{nil}, Emacs применяет виды, указанные этим свойством.  Если наложение имеет
свойство @code{mouse-face} и указатель мыши находится достаточно близко к наложению,
Emacs вместо этого применяет атрибуты вида или вид, указанные в свойстве
@code{mouse-face}.  @xref{Overlay Properties}.

Когда несколько наложений покрывают один символ, наложение с более высоким
приоритетом заменяет наложения с более низким приоритетом.  @xref{Overlays}.

@item
Если текст содержит свойство @code{face} или @code{mouse-face}, Emacs применяет
указанные виды и атрибуты видов.  @xref{Special Properties}.  (Вот как применяются
начертания в режиме Font Lock.  @xref{Font Lock Mode}.)

@item
Если текст находится в строке режима выбранного окна, Emacs применяет вид
@code{mode-line}.  Для строки режима невыбранного окна Emacs применяет вид
@code{mode-line-inactive}.  Для строки заголовка Emacs применяет вид
@code{header-line}.

@item
Если текст строки поступает из наложения через свойства @code{before-string} или
@code{after-string} (@pxref{Overlay Properties}) или из отображаемой строки
(@pxref{Other Display Specs}), и строка не содержит свойства @code{face} или
@code{mouse-face}, но текст буфера, на который влияет свойство наложения/отображения,
действительно определяет вид, Emacs применяет атрибуты вида нижележащего 'буферного'
текста.  Обратить внимание, что это так, даже если наложение или отображаемая строка
отображаются на полях отображения (@pxref{Display Margins}).

@item
Если какой-либо атрибут не был указан на предыдущих шагах, Emacs применяет атрибут
вида @code{default}.
@end itemize

  На каждом этапе, если вид имеет допустимый атрибут @code{:inherit}, Emacs
обрабатывает любой атрибут со значением @code{unspecified} как имеющий соответствующее
значение, полученное из родительского вида (-ов).  @pxref{Face Attributes}.  Обратить
внимание, что родительские виды также могут оставить атрибут неуказанным; в этом
случае атрибут остается неопределенным на следующем уровне слияния видов.

@node Face Remapping
@subsection Переназначение Вида
@cindex face remapping

  Переменная @code{face-remapping-alist} используется для локальных или глобальных
изменений внешнего вида вида отображения в буфере.  Например, используется для
реализации команды @code{text-scale-adjust}
(@pxref{Text Scale,,, emacs, The GNU Emacs Manual}).

@defvar face-remapping-alist
Значением этой переменной является список, элементы которого имеют вид
@code{(@var{face} . @var{remapping})}.  Это заставляет Emacs отображать любой текст
с видом @var{face} и @var{remapping} вместо обычного определения @var{face}.

@var{remapping} может быть любой спецификацией вида, подходить для текстового свойства
@code{face}: либо видом (то есть именем вида или списком свойств пар
атрибут/значение), либо списком видов.  Подробнее смотреть описание текстового
свойства @code{face} в файле @ref{Special Properties}.  @var{remapping} служит полной
спецификацией для переназначенного вида - заменяется обычное определение @var{face},
а не модифицирует его.

Если @code{face-remapping-alist} является локальным буфера, его локальное значение
действует только в этом буфере.

Примечание: переназначение видов нерекурсивно.  Если @var{remapping} ссылается на
одно и то же имя вида @var{face} либо напрямую, либо через атрибут @code{:inherit}
некоторого другого вида в @var{remapping}, эта ссылка использует обычное определение
@var{face}.  Например, если вид @code{mode-line} переназначен с использованием этой
записи в @code{face-remapping-alist}:

@example
(mode-line italic mode-line)
@end example

@noindent
тогда новое определение вида @code{mode-line} наследуется от вида @code{italic}, а
@emph{нормальное} определение @code{mode-line} вида (без переназначения).
@end defvar

@cindex relative remapping, faces
@cindex base remapping, faces
  Следующие функции реализуют интерфейс более высокого уровня для
@code{face-remapping-alist}.  Большая часть кода на Lisp должна использовать эти
функции вместо непосредственной установки @code{face-remapping-alist}, чтобы избежать
нарушения переназначений, применяемых где-либо еще.  Функции предназначены для
переназначения локального буфера, поэтому все делают @code{face-remapping-alist}
локальным для буфера в качестве побочного эффекта.  Управляют записями
@code{face-remapping-alist} формы

@example
  (@var{face} @var{relative-spec-1} @var{relative-spec-2} @var{...} @var{base-spec})
@end example

@noindent
где, как объяснено выше, каждый из @var{relative-spec-N} и @var{base-spec} является
либо именем вида, либо списком свойств пар атрибут/значение.  Каждая из записей
@dfn{относительного переназначение}, @var{relative-spec-N}, управляется функциями
@code{face-remap-add-relative} и @code{face-remap-remove-relative}; предназначаются
для простых модификаций, таких как изменение размера текста.  Запись
@dfn{базового переназначение}, @var{base-spec}, имеет самый низкий приоритет и
управляется функциями @code{face-remap-set-base} и @code{face-remap-reset-base};
предназначается для основных режимов для переназначения видов в буферах, которыми
они управляют.

@defun face-remap-add-relative face &rest specs
Функция добавляет спецификацию вида в @var{specs} в качестве относительного
переназначения вида @var{face} в текущий буфер.  Остальные аргументы, @var{specs},
должны формировать либо список имен вида, либо список свойств пар атрибут/значение.

Возвращаемое значение - это объект Lisp, который служит файлом cookie; можно
передать этот объект в качестве аргумента @code{face-remap-remove-relative}, если
понадобится удалить переназначение позже.

@example
;; Преобразовать вид 'escape-glyph' в комбинацию ;; видов 'highlight' и 'italic':
(face-remap-add-relative 'escape-glyph 'highlight 'italic)

;; Увеличить размер вида 'default' на 50%:
(face-remap-add-relative 'default :height 1.5)
@end example
@end defun

@defun face-remap-remove-relative cookie
Функция удаляет относительное переназначение, ранее добавленное
@code{face-remap-add-relative}.  @var{cookie} должно быть объектом Lisp, возвращаемым
@code{face-remap-add-relative} при добавлении переназначения.
@end defun

@defun face-remap-set-base face &rest specs
Функция устанавливает базовое переназначение @var{face} в текущем буфере на
@var{specs}.  Если @var{specs} пусто, восстанавливается базовое переназначение по
умолчанию, аналогично вызову @code{face-remap-reset-base} (смотреть ниже); обратить
внимание, что это отличается от @var{specs}, содержащего одно значение @code{nil},
которое дает противоположный результат (глобальное определение @var{face}
игнорируется).

Перезаписывается @var{base-spec} по умолчанию, которое наследует глобальное
определение вида, поэтому вызывающая сторона может добавить такое наследование, если
это необходимо.
@end defun

@defun face-remap-reset-base face
Функция устанавливает базовое переназначение @var{face} на значение по умолчанию,
которое наследуется от глобального определения @var{face}.
@end defun

@node Face Functions
@subsection Функции для Работы с Видами Отображения

  Вот дополнительные функции для создания видов и работы с ними.

@defun face-list
Функция возвращает список всех определенных имен лиц.
@end defun

@cindex face number
@cindex face property of face symbols
@defun face-id face
Функция возвращает @dfn{номер вида} вида @var{face}.  Это номер, который однозначно
идентифицирует вид представления на нижних уровнях Emacs.  Редко бывает необходимо
называть вид по его номеру.  Однако функции, которые управляют глифами, такие как
@code{make-glyph-code} и @code{glyph-face} (@pxref{Glyphs}), обращаются к номерам
видов изнутри.  Обратить внимание, что номер вида хранится как значение свойства
@code{face} символа вида, поэтому не рекомендуется устанавливать для этого свойства
вида какое-либо собственное значение.
@end defun

@defun face-documentation face
Функция возвращает строку документации для вида @var{face} или @code{nil}, если для
него ничего не было указано.
@end defun

@defun face-equal face1 face2 &optional frame
Возвращает @code{t}, если виды представления @var{face1} и @var{face2} имеют
одинаковые атрибуты для отображения.
@end defun

@defun face-differs-from-default-p face &optional frame
Возвращает не-@code{nil}, если вид @var{face} отображается иначе, чем вид по
умолчанию.
@end defun

@cindex face alias
@cindex alias, for faces
@dfn{Псевдоним вида} предоставляет эквивалентное имя для вида.  Можно определить
псевдоним вида, присвоив символу псевдонима свойство @code{face-alias} со значением
имени целевого вида.  В следующем примере @code{modeline} становится псевдонимом для
вида @code{mode-line}.

@example
(put 'modeline 'face-alias 'mode-line)
@end example

@defmac define-obsolete-face-alias obsolete-face current-face when
Макрос определяет @code{obsolete-face} как псевдоним для @var{current-face}, а
также отмечает его как устаревший, указывая, что может быть удален в будущем.
@var{when} должен быть строкой, указывающей, когда @code{obsolete-face} стал
устаревшим (обычно это строка с номером версии).
@end defmac

@node Auto Faces
@subsection Автоматическое Присвоение Видов Представления
@cindex automatic face assignment
@cindex faces, automatic choice

  Перехватчик используется для автоматического присвоения видов предствления тексту
в буфере.  Это часть реализации режима Jit-Lock, используемого Font-Lock.

@defvar fontification-functions
Переменная содержит список функций, которые Emacs вызывает повторное отображение по
мере необходимости, непосредственно перед повторным отображением.  Вызываются, только
если режим блокировки шрифта не включен.  Когда включен режим блокировки шрифта, эта
переменная обычно содержит только одну функцию, @code{jit-lock-function}.

Функции вызываются в указанном порядке с одним аргументом, буферной позицией
@var{pos}.  Вместе должны попытаться назначить виды представления тексту в текущем
буфере, начиная с @var{pos}.

Функции должны записывать виды предствления, которые назначаются, устанавив свойство
@code{face}.  Также следует добавить свойство @code{fontified} указывающее в
не-@code{nil}  ко всему тексту, которому они назначили виды.  Это свойство сообщает
redisplay, что виды уже были назначены этому тексту.

Вероятно, это хорошая идея, чтобы функции ничего не делали, если символ после
@var{pos} уже имеет свойство @code{fontified} установленное в не-@code{nil} , но это
не требуется.  Если одна функция переопределяет назначения, сделанные предыдущей,
свойства после завершения последней функции - это те, которые действительно имеют
значение.

Для повышения эффективности рекомендуется писать эти функции так, чтобы они обычно
присваивали видам от 400 до 600 символов при каждом вызове.
@end defvar

@node Basic Faces
@subsection Основные Виды
@cindex basic faces

Если вашей программе Emacs Lisp необходимо присвоить тексту некоторые виды, часто
бывает хорошей идеей использовать определенные существующие виды или наследовать от
них, а не определять совершенно новые виды.  Таким образом, если другие пользователи
настроили основные виды представления, чтобы придать Emacs определенный вид, программа
впишется без дополнительной настройки.

  Некоторые из основных видов, определенных в Emacs, перечислены ниже.  В дополнение к
этому, можно захотеть использовать виды Font Lock для синтаксического выделения, если
выделение еще не обрабатывается в режиме Font Lock или если некоторые шрифты Font Lock
не используются.  @xref{Faces for Font Lock}.

@table @code
@item default
Вид по умолчанию, все атрибуты которого указаны.  Все остальные виды неявно
наследуются от него: для любого неуказанного атрибута по умолчанию используется
атрибут этого вида (@pxref{Face Attributes}).

@item bold
@itemx italic
@itemx bold-italic
@itemx underline
@itemx fixed-pitch
@itemx fixed-pitch-serif
@itemx variable-pitch
У них есть атрибуты, обозначенные их именами (например, @code{bold} имеет атрибут
@code{:weight} жирным шрифтом), а все остальные атрибуты не указаны (и поэтому
задаются @code{default}).

@item shadow
Для затемненного текста. Например, используется для игнорируемой части имени файла в
минибуфере.
(@pxref{Minibuffer File,, Minibuffers for File Names, emacs, The GNU Emacs Manual}).

@item link
@itemx link-visited
Для интерактивных текстовых кнопок, которые отправляют пользователя в другой буфер
или другое место.

@item highlight
Для фрагментов текста, которые должны временно выделяться.  Например, это обычно
присваивается свойству @code{mouse-face} для выделения курсора
(@pxref{Special Properties}).

@item match
@itemx isearch
@itemx lazy-highlight
Для сопоставления текста (соответственно) постоянных совпадений поиска, совпадений
интерактивного поиска и ленивого выделения других совпадений, кроме текущего
интерактивного.

@item error
@itemx warning
@itemx success
Для текста об ошибках, предупреждениях или успехах.  Например, это используются для
сообщений в буферах @file{*Compilation*}.
@end table

@node Font Selection
@subsection Выбор Шрифта
@cindex font selection
@cindex selecting a font

  Прежде чем Emacs сможет нарисовать символ на графическом дисплее, он должен выбрать
@dfn{шрифт} для этого символа @footnote{В этом контексте термин @dfn{шрифт} не имеет
ничего общего с Font Lock.  (@pxref{Font Lock Mode}).}.
@xref{Fonts,,, emacs, The GNU Emacs Manual}.  Обычно Emacs автоматически выбирает
шрифт на основе видов представлений, назначенных этому символу, в частности, атрибутов
вида @code{:family}, @code{:weight}, @code{:slant} и @code{:width}
(@pxref{Face Attributes}).  Выбор шрифта также зависит от отображаемого символа;
некоторые шрифты могут отображать только ограниченный набор символов.  Если ни один
из доступных шрифтов не соответствует требованиям, Emacs ищет
@dfn{ближайший подходящий шрифт}.  Переменные в этом разделе управляют тем, как Emacs
делает этот выбор.

@defopt face-font-family-alternatives
Если данное семейство указано, но не существует, эта переменная указывает
альтернативные семейства шрифтов, которые следует попробовать.  Каждый элемент должен
иметь такую форму:

@example
(@var{family} @var{alternate-families}@dots{})
@end example

Если @var{family} указано, но недоступно, Emacs будет пробовать другие семейства,
указанные в @var{alternate-families}, одно за другим, пока не найдет существующее
семейство.
@end defopt

@defopt face-font-selection-order
Если нет шрифта, который точно соответствует всем желаемым атрибутам вида
(@code{:width}, @code{:height}, @code{:weight} и @code{:slant}), переменная
определяет порядок, в котором эти атрибуты должны учитываться при выборе наиболее
подходящего шрифта.  Значение должно быть списком, содержащим эти четыре символа
атрибутов в порядке убывания важности.  По умолчанию
@code{(:width :height :weight :slant)}.

При выбора шрифта сначала находится наиболее подходящие совпадения для первого
атрибута в списке; затем среди шрифтов, которые лучше всего подходят в этом отношении,
ищется наилучшие совпадения по второму атрибуту и так далее.

Атрибуты @code{:weight} и @code{:width} имеют символические значения в диапазоне
вокруг @code{normal}.  Более экстремальные совпадения (дальше от @code{normal}) в
некоторой степени предпочтительнее менее экстремальных (ближе к @code{normal}); это
сделано для того, чтобы нестандартные виды представления контрастировали с
нормальными, когда это возможно.

Один из примеров того, когда эта переменная имеет значение, - это когда шрифт по
умолчанию не имеет курсивного эквивалента.  С порядком по умолчанию для вида
@code{italic} будет использоваться не курсивный шрифт, аналогичный шрифту по
умолчанию.  Но если поставить @code{:slant} перед @code{:height}, начертание
@code{italic} будет использовать курсив, даже если его высота не совсем правильная.
@end defopt

@defopt face-font-registry-alternatives
Переменная позволяет указать альтернативные реестры шрифтов, которые можно
попробовать, если данный реестр указан и не существует.  Каждый элемент должен
иметь такую форму:

@example
(@var{registry} @var{alternate-registries}@dots{})
@end example

Если @var{registry} указано, но недоступно, Emacs будет пробовать другие реестры,
указанные в @var{alternate-registries}, один за другим, пока не найдет реестр,
который действительно существует.
@end defopt

@cindex scalable fonts
  Emacs может использовать масштабируемые шрифты, но по умолчанию не использует их.

@defopt scalable-fonts-allowed
Переменная определяет, какие масштабируемые шрифты использовать.  Значение по
умолчанию @code{nil} означает, что масштабируемые шрифты не используются.  @code{t}
означает использование любого масштабируемого шрифта, который кажется подходящим для
текста.

В противном случае значение должно быть списком регулярных выражений.  Затем можно
использовать масштабируемый шрифт, если его имя соответствует любому регулярному
выражению в списке. Например,

@example
(setq scalable-fonts-allowed '("iso10646-1$"))
@end example

@noindent
позволяет использовать масштабируемые шрифты с реестром @code{iso10646-1}.
@end defopt

@defvar face-font-rescale-alist
Переменная определяет масштабирование для определенных видов.  Её значением должен
быть список элементов формы

@example
(@var{fontname-regexp} . @var{scale-factor})
@end example

Если @var{fontname-regexp} совпадает с именем шрифта, который будет использоваться,
это говорит о том, что следует выбрать более крупный аналогичный шрифт в соответствии
с коэффициентом @var{scale-factor}.  Можно использовать эту функцию для нормализации
размера шрифта, если некоторые шрифты больше или меньше, чем предполагают их
номинальная высота и ширина.
@end defvar

@node Font Lookup
@subsection Поиск Шрифтов
@cindex font lookup
@cindex looking up fonts

@defun x-list-fonts name &optional reference-face frame maximum width
Функция возвращает список доступных имен шрифтов, соответствующих @var{name}.
@var{name} должно быть строкой, содержащей имя шрифта в формате Fontconfig, GTK+ или
XLFD (@pxref{Fonts,,, emacs, The GNU Emacs Manual}).  В строке XLFD могут
использоваться подстановочные знаки: символ @samp{*} соответствует любой подстроке,
а символ @samp{?} соответствует любому одиночному символу.  При сопоставлении имен
шрифтов регистр игнорируется.

Если указаны необязательные аргументы @var{reference-face} и @var{frame},
возвращаемый список включает только шрифты того же размера, что и @var{reference-face}
(имя вида), которое в данный момент находится в фрейме @var{frame}.

Необязательный аргумент @var{maximum} устанавливает ограничение на количество
возвращаемых шрифтов.  Если это не-@code{nil}, то возвращаемое значение обрезается
после первых @var{maximum} совпадающих шрифтов.  Указание небольшого значения для
@var{maximum} может значительно ускорить эту функцию в тех случаях, когда многие
шрифты соответствуют шаблону.

Необязательный аргумент @var{width} указывает желаемую ширину шрифта.  Если это
не-@code{nil}, функция возвращает только те шрифты, символы которых (в среднем) в
@var{width} раза шире, чем @var{reference-face}.
@end defun

@defun x-family-fonts &optional family frame
Функция возвращает список с описанием доступных шрифтов для семейства @var{family}
в @var{frame}.  Если @var{family} опущено или @code{nil}, этот список применяется ко
всем семействам и, следовательно, содержит все доступные шрифты.  В противном
случае @var{family} должно быть строкой; может содержать подстановочные знаки
@samp{?} и @samp{*}.

Список описывает дисплей, на котором включен @var{frame}; если @var{frame} опущено
или @code{nil}, применяется к отображению выбранного фрейма (@pxref{Input Focus}).

Каждый элемент в списке представляет собой вектор следующего вида:

@example
[@var{family} @var{width} @var{point-size} @var{weight} @var{slant}
 @var{fixed-p} @var{full} @var{registry-and-encoding}]
@end example

Первые пять элементов соответствуют атрибутам вида; если указать эти атрибуты для
вида, оно будет использовать этот шрифт.

Последние три элемента предоставляют дополнительную информацию о шрифте.
@var{fixed-p} равен не-@code{nil}, если шрифт фиксированный.  @var{full} - это полное
имя шрифта, а @var{registry-and-encoding} - строка, содержащая реестр и кодировку
шрифта.
@end defun

@node Fontsets
@subsection Наборы Шрифтов
@cindex fontset

  @dfn{Набор шрифтов} - это список шрифтов, каждому из которых назначен диапазон
кодов символов.  Отдельный шрифт не может отображать весь диапазон символов,
поддерживаемых Emacs, но набор шрифтов может.  Наборы шрифтов имеют имена, как и
шрифты, и можно использовать имя набора шрифтов вместо имени шрифта, когда указывается
шрифт для вида или вид.  Вот информация об определении набора шрифтов под управлением
программы Lisp.

@defun create-fontset-from-fontset-spec fontset-spec &optional style-variant-p noerror
Функция определяет новый набор шрифтов в соответствии со строкой спецификации
@var{fontset-spec}.  Строка должна иметь следующий формат:

@smallexample
@var{fontpattern}, @r{[}@var{charset}:@var{font}@r{]@dots{}}
@end smallexample

@noindent
Пробелы до и после запятых игнорируются.

Первая часть строки, @var{fontpattern}, должна иметь форму стандартного имени шрифта
X, за исключением того, что последние два поля должны быть @samp{fontset-@var{alias}}.

У нового набора шрифтов есть два имени, одно длинное и одно короткое.  Полное имя -
@var{fontpattern}.  Краткое имя @samp{fontset-@var{alias}}.  Можно ссылаться на набор
шрифтов по любому имени.  Если набор шрифтов с таким именем уже существует, выдается
сообщение об ошибке, если @var{noerror} не не-@code{nil}, и в этом случае эта функция
ничего не делает.

Если необязательный аргумент @var{style-variant-p} - не-@code{nil}, это означает, что
нужно также создавать полужирные, курсивные и полужирные варианты набора шрифтов.  Эти
варианты наборов шрифтов не имеют короткого имени, а только длинного, которое
получается путем изменения @var{fontpattern} для обозначения полужирного и/или
курсивного статуса.

В строке спецификации также указано, какие шрифты использовать в наборе шрифтов.
Смотреть подробности ниже.
@end defun

  Конструкция @samp{@var{charset}:@var{font}} указывает, какой шрифт использовать
(в этом наборе шрифтов) для одного конкретного набора символов.  Здесь @var{charset} -
это имя набора символов, а @var{font} - шрифт, который следует использовать для этого
набора символов.  Можно использовать эту конструкцию любое количество раз в строке
спецификации.

  Для остальных наборов символов, которые не указываются явно, Emacs выбирает шрифт
на основе @var{fontpattern}: заменяется @samp{fontset-@var{alias}} значением, которое
именует один набор символов.  Для набора символов @acronym{ASCII}
@samp{fontset-@var{alias}} заменяется на @samp{ISO8859-1}.

  Вдобавок, когда несколько последовательных полей являются подстановочными знаками,
Emacs сворачивает их в один подстановочный знак.  Это сделано для предотвращения
использования шрифтов с автоматическим масштабированием.  Шрифты, созданные путем
масштабирования более крупных шрифтов, нельзя использовать для редактирования, а
масштабирование меньшего шрифта бесполезно, потому что лучше использовать меньший
шрифт в собственном размере, что и делает Emacs.

  Таким образом, если @var{fontpattern} это,

@example
-*-fixed-medium-r-normal-*-24-*-*-*-*-*-fontset-24
@end example

@noindent
спецификация шрифта для символов @acronym{ASCII} будет следующей:

@example
-*-fixed-medium-r-normal-*-24-*-ISO8859-1
@end example

@noindent
а спецификация шрифта для китайских символов GB2312 будет такой:

@example
-*-fixed-medium-r-normal-*-24-*-gb2312*-*
@end example

  Может не быть китайского шрифта, соответствующего указанной выше спецификации
шрифта.  Большинство дистрибутивов X включают только китайские шрифты, у которых есть
@samp{song ti} или @samp{fangsong ti} в поле @var{family}.  В таком случае
@samp{Fontset-@var{n}} можно указать следующим образом:

@smallexample
Emacs.Fontset-0: -*-fixed-medium-r-normal-*-24-*-*-*-*-*-fontset-24,\
        chinese-gb2312:-*-*-medium-r-normal-*-24-*-gb2312*-*
@end smallexample

@noindent
Затем в спецификациях шрифтов для всех символов, кроме китайских символов GB2312,
есть @samp{fixed} в поле @var{family}, а в спецификации шрифтов для китайских
символов GB2312 есть подстановочный знак @samp{*} в поле @var{family}.

@defun set-fontset-font name character font-spec &optional frame add
Функция изменяет существующий набор шрифтов @var{name} для использования шрифта,
совпадающего с @var{font-spec} для указанного @var{character}.

Если @var{name} равно @code{nil}, функция изменяет набор шрифтов выбранного фрейма
@var{frame}, если @var{frame} не @code{nil}.

Если @var{name} - @code{t}, функция изменяет набор шрифтов по умолчанию, короткое имя
которого - @samp{fontset-default}.

Помимо указания единственной кодовой точки, @var{character} может быть cons-ячейкой
@code{(@var{from} . @var{to})}, где @var{from} и @var{to} - это кодовые точки символа.
В этом случае использовать @var{font-spec} для всех символов в диапазоне от @var{from}
до @var{to} (включительно).

@var{character} может быть кодировкой (@pxref{Character Sets}).  В этом случае
используется @var{font-spec} для всех символов в кодировке.

@var{character} может быть именем сценария (@pxref{Character Properties}).  В этом
случае использовать @var{font-spec} для всех символов, принадлежащих скрипту.

@var{character} может быть @code{nil}, что означает использовать @var{font-spec}
для любого символа, для которого не указан шрифт.

@var{font-spec} может быть объектом спецификации шрифта, созданным функцией
@code{font-spec} (@pxref{Low-Level Font}).

@var{font-spec} может быть cons-ячейкой: @code{(@var{family} . @var{registry})}, где
@var{family} - это семейное имя шрифта (возможно, включая название литейной в начале),
@var{registry} - это имя шрифта в реестре (возможно, включая имя кодировки в конце).

@var{font-spec} может быть именем шрифта, строкой.

@var{font-spec} может быть @code{nil}, что явно указывает на отсутствие шрифта для
указанного @var{character}.  Это полезно, например, чтобы избежать дорогостоящего
общесистемного поиска шрифтов для символов, не имеющих глифов, например, из области
частного использования Unicode (PUA).



Необязательный аргумент @var{add}, если не-@code{nil}, указывает, как добавить
@var{font-spec} к ранее установленным спецификациям шрифта.  Если это @code{prepend},
добавляется @var{font-spec}.  Если это @code{append}, добавляется @var{font-spec}.
По умолчанию @var{font-spec} отменяет предыдущие настройки.

Например, это изменяет набор шрифтов по умолчанию, чтобы использовать шрифт с именем
семейства @samp{Kochi Gothic} для всех символов, принадлежащих кодировке
@code{japanese-jisx0208}.

@smallexample
(set-fontset-font t 'japanese-jisx0208
                  (font-spec :family "Kochi Gothic"))
@end smallexample
@end defun

@defun char-displayable-p char
Функция возвращает @code{t}, если Emacs должен иметь возможность отображать
@var{char}.  Точнее, если в наборе шрифтов выбранного фрейма есть шрифт для
отображения набора символов, которому принадлежит @var{char}.

Наборы шрифтов могут указывать шрифт для каждого символа; когда набор шрифтов делает
это, значение этой функции может быть неточным.
@end defun

@node Low-Level Font
@subsection Низкоуровневое Представление Шрифтов
@cindex font property

  Обычно нет необходимости напрямую манипулировать шрифтами.  Если требуется это
сделать, в этом разделе объясняется, как это сделать.

  В Emacs Lisp шрифты представлены с использованием трех разных типов объектов Lisp:
@dfn{объект шрифта}, @dfn{спецификация шрифта} и @dfn{объект шрифта}.

@defun fontp object &optional type
Вернуть @code{t}, если @var{object} - объект шрифта, спецификация шрифта или объект
шрифта.  В противном случае верните @code{nil}.

Необязательный аргумент @var{type}, если не-@code{nil}, определяет точный тип объекта
Lisp для проверки.  В этом случае @var{type} должен быть одним из @code{font-object},
@code{font-spec} или @code{font-entity}.
@end defun

@cindex font object
  Объект шрифта - это объект Lisp, представляющий шрифт, имеющийся в Emacs
@dfn{открытый}.  В Lisp нельзя изменить объекты шрифта, но их можно проверить.

@defun font-at position &optional window string
Вернуть объект шрифта, который используется для отображения символа в позиции
@var{position} в окне @var{window}.  Если @var{window} равно @code{nil}, по умолчанию
используется выбранное окно.  Если @var{string} - @code{nil}, @var{position} указывает
позицию в текущем буфере; в противном случае @var{string} должно быть строкой, а
@var{position} указывает позицию в этой строке.
@end defun

@cindex font spec
  Спецификация шрифта - это объект Lisp, который содержит набор спецификаций, которые
можно использовать для поиска шрифта.  Более чем один шрифт может соответствовать
спецификациям в спецификации шрифта.

@defun font-spec &rest arguments
Вернуть новую спецификацию шрифта, используя спецификации в @var{arguments}, что
должно быть парами @code{property}-@code{value}.  Возможные технические
характеристики:

@table @code
@item :name
Имя шрифта (строка) в формате XLFD, Fontconfig или GTK +.
@xref{Fonts,,, emacs, The GNU Emacs Manual}.

@item :family
@itemx :foundry
@itemx :weight
@itemx :slant
@itemx :width
Они имеют то же значение, что и одноименные атрибуты вида.
@xref{Face Attributes}.

@item :size
Размер шрифта - либо неотрицательное целое число, указывающее размер в пикселях, либо
число с плавающей запятой, определяющее размер точки.

@item :adstyle
Дополнительная информация о типографском стиле шрифта, например @samp{sans}.
Значение должно быть строкой или символом.

@cindex font registry
@item :registry
Реестр кодировок и кодировка шрифта, например @samp{iso8859-1}.  Значение должно быть
строкой или символом.

@item :script
Скрипт, который должен поддерживать шрифт (символ).

@item :lang
Язык, который должен поддерживать шрифт.  Значение должно быть символом, имя которого
представляет собой двухбуквенное название языка ISO-639.  На X значение сопоставляется
с полем ``Дополнительный стиль'' имени XLFD шрифта, если оно не пустое.  В MS-Windows
шрифты, соответствующие спецификации, необходимы для поддержки кодовых страниц,
необходимых для языка.  В настоящее время с этим свойством поддерживается только
небольшой набор языков CJK: @samp{ja}, @samp{ko} и @samp{zh}.

@item :otf
@cindex OpenType font
Шрифт должен быть шрифтом OpenType, который поддерживает эти возможности OpenType,
при условии, что Emacs скомпилирован с библиотекой, такой как @samp{libotf} в
GNU/Linux, которая поддерживает сложную разметку текста для скриптов, которые в
этом нуждаются.  Значение должно быть списком в форме

@smallexample
@code{(@var{script-tag} @var{langsys-tag} @var{gsub} @var{gpos})}
@end smallexample

где @var{script-tag} - символ тега скрипта OpenType; @var{langsys-tag} - это символ
системного тега языка OpenType или @code{nil} для использования языковой системы по
умолчанию; @code{gsub} - это список символов тегов функций OpenType GSUB или
@code{nil}, если они не требуются; и @code{gpos} - это список символов тегов функций
OpenType GPOS или @code{nil}, если они не требуются.  Если @code{gsub} или @code{gpos}
- это список, элемент @code{nil} в этом списке означает, что шрифт не должен
соответствовать ни одному из оставшихся символов тега.  Элемент @code{gpos} можно
опустить.
@end table
@end defun

@defun font-put font-spec property value
Установить свойство шрифта спец-шрифт @var{font-spec} @var{property} в значение
@var{value}.
@end defun

@cindex font entity
  Сущность шрифта - это ссылка на шрифт, который не нужно открывать.  Его свойства
занимают промежуточное положение между объектом шрифта и спецификацией шрифта:
подобно объекту шрифта и, в отличие от спецификации шрифта, он относится к одному
конкретному шрифту.  В отличие от объекта шрифта, создание объекта шрифта не
загружает содержимое этого шрифта в память компьютера.  Emacs может открывать
несколько объектов шрифтов разного размера из одного объекта шрифта, относящегося к
масштабируемому шрифту.

@defun find-font font-spec &optional frame
Функция возвращает объект шрифта, который лучше всего соответствует спецификации
шрифта @var{font-spec} в кадре @var{frame}.  Если @var{frame} равно @code{nil}, по
умолчанию используется выбранный фрейм.
@end defun

@defun list-fonts font-spec &optional frame num prefer
Функция возвращает список всех шрифтов, соответствующих спецификации шрифта
@var{font-spec}.

Необязательный аргумент @var{frame}, если не-@code{nil}, указывает фрейм, в котором
должны отображаться шрифты.  Необязательный аргумент @var{num}, если не-@code{nil},
должен быть целым числом, указывающим максимальную длину возвращаемого списка.
Необязательный аргумент @var{prefer}, если не-@code{nil}, должен быть другой
спецификацией шрифта, которая используется для управления порядком возвращаемого
списка; возвращенные объекты шрифта сортируются в порядке уменьшения близости к
спецификации этого шрифта.
@end defun

  Если вызывается @code{set-face-attribute} и передается спецификация шрифта, объект
шрифта или строка имени шрифта в качестве значения атрибута @code{:font}, Emacs
откроет наиболее подходящий шрифт, доступный для отображения.  Затем сохраняется
соответствующий объект шрифта как фактическое значение атрибута @code{:font} для
этого вида представления.

  Следующие функции можно использовать для получения информации о шрифте.  Для этих
функций аргумент @var{font} может быть объектом шрифта, объектом шрифта или
спецификацией шрифта.

@defun font-get font property
Функция возвращает значение свойства шрифта @var{property} для @var{font}.

Если @var{font} - это спецификация шрифта, а спецификация шрифта не определяет
@var{property}, возвращаемое значение - @code{nil}.  Если @var{font} - это объект
шрифта или объект шрифта, значение свойства @var{:script} может быть списком
скриптов, поддерживаемых шрифтом.
@end defun

@defun font-face-attributes font &optional frame
Функция возвращает список атрибутов видов отображения, соответствующих @var{font}.
Необязательный аргумент @var{frame} указывает фрейм, в котором должен отображаться
шрифт.  Если это @code{nil}, используется выбранный фрейм.  Возвращаемое значение
имеет вид

@smallexample
(:family @var{family} :height @var{height} :weight @var{weight}
   :slant @var{slant} :width @var{width})
@end smallexample

где значения @var{family}, @var{height}, @var{weight}, @var{slant} и @var{width} -
это значения атрибутов вида.  Некоторые из этих пар ключ-атрибут могут быть
исключены из списка, если они не указаны в @var{font}.
@end defun

@defun font-xlfd-name font &optional fold-wildcards
Функция возвращает XLFD (дескриптор логического шрифта X), строку, соответствующую
@var{font}. @xref{Fonts,,, emacs, The GNU Emacs Manual}, для получения информации о
XLFD.  Если имя слишком длинное для XLFD (которое может содержать не более 255
символов), функция возвращает @code{nil}.

Если необязательный аргумент @var{fold-wildcards} - не-@code{nil}, последовательные
подстановочные знаки в XLFD объединяются в один.
@end defun

Следующие две функции возвращают важную информацию о шрифте.

@defun font-info name &optional frame
Функция возвращает информацию о шрифте, заданном его строкой @var{name}, как она
используется в @var{frame}.  Если @var{frame} опущен или @code{nil}, по умолчанию
используется выбранный фрейм.

Значение, возвращаемое функцией, является вектором формы
@code{[@var{opened-name} @var{full-name} @var{size} @var{height}
@var{baseline-offset} @var{relative-compose} @var{default-ascent}
@var{max-width} @var{ascent} @var{descent} @var{space-width}
@var{average-width} @var{filename} @var{capability}]}.  Вот описание каждого
компонента этого вектора:

@table @var
@item opened-name
Имя, используемое для открытия шрифта, строка.

@item full-name
Полное название шрифта, строка.

@item size
Размер шрифта в пикселях.

@item height
Высота шрифта в пикселях.

@item baseline-offset
Смещение в пикселях от базовой строки @acronym{ASCII}, положительное значение вверх.

@item relative-compose
@itemx default-ascent
Числа, управляющие составлением символов.

@item ascent
@itemx descent
Появление и исчезновение этого шрифта.  Сумма этих двух чисел должна быть равна
значению выше @var{height}.

@item space-width
Ширина в пикселях символа пробела шрифта.

@item average-width
Средняя ширина символов шрифта.  Если равно нулю, Emacs вместо этого использует
значение @var{space-width} при вычислении макета текста на дисплее.

@item filename
Имя файла шрифта в виде строки.  Это может быть @code{nil}, если серверная часть
шрифта не позволяет узнать имя файла шрифта.

@item capability
Список, первым элементом которого является символ, представляющий тип шрифта, один из
@code{x}, @code{opentype}, @code{truetype}, @code{type1}, @code{pcf} или @code{bdf}.
Для шрифтов OpenType список включает 2 дополнительных элемента, описывающих функции
@sc{gsub} и @sc{gpos}, поддерживаемые шрифтом.  Каждый из этих элементов представляет
собой список вида
@code{((@var{script} (@var{langsys} @var{feature} @dots{}) @dots{}) @dots{})}, где
@var{script} - это символ, представляющий тег скрипта OpenType, @var{langsys} - это
символ, представляющий тег OpenType langsys (или @code{nil}, который обозначает
langsys по умолчанию), а каждый @var{feature} - символ представляющий тег функции
OpenType.
@end table
@end defun

@defun query-font font-object
Функция возвращает информацию о @var{font-object}.  (В этом отличие от
@code{font-info}, которая принимает в качестве аргумента имя шрифта, строку.)

Значение, возвращаемое функцией, является вектором формы
@code{[@var{name} @var{filename} @var{pixel-size} @var{max-width}
@var{ascent} @var{descent} @var{space-width} @var{average-width}
@var{capability}]}.  Вот описание каждого компонента этого вектора:

@table @var
@item name
Название шрифта, строка.

@item filename
Имя файла шрифта в виде строки.  Это может быть @code{nil}, если серверная часть
шрифта не позволяет узнать имя файла шрифта.

@item pixel-size
Размер шрифта в пикселях, используемый для открытия шрифта.

@item max-width
Максимальная ширина продвижения шрифта.

@item ascent
@itemx descent
Возникновение и спуск этого шрифта.  Сумма этих двух чисел дает высоту шрифта.

@item space-width
Ширина в пикселях символа пробела шрифта.

@item average-width
Средняя ширина символов шрифта.  Если равно нулю, Emacs вместо этого использует
значение @var{space-width} при вычислении макета текста на дисплее.

@item capability
Список, первым элементом которого является символ, представляющий тип шрифта, один из
@code{x}, @code{opentype}, @code{truetype}, @code{type1}, @code{pcf} или @code{bdf}.
Для шрифтов OpenType список включает 2 дополнительных элемента, описывающих функции
@sc{gsub} и @sc{gpos}, поддерживаемые шрифтом.  Каждый из этих элементов представляет
собой список вида
@code{((@var{script} (@var{langsys} @var{feature} @dots{}) @dots{}) @dots{})}, где
@var{script} - это символ, представляющий тег скрипта OpenType, @var{langsys} - это
символ, представляющий тег OpenType langsys (или @code{nil}, который обозначает
langsys по умолчанию), а каждый @var{feature} - символ представляющий тег функции
OpenType.
@end table
@end defun

@cindex font information for layout
Следующие четыре функции возвращают информацию о размере шрифтов, используемых
различными начертаниями, что позволяет учитывать различные аспекты компоновки в
программах на Lisp.  Эти функции принимают во внимание переназначение вида
представления, возвращая информацию о переназначенном виде, если рассматриваемый
вид был переназначен.  @xref{Face Remapping}.

@defun default-font-width
Функция возвращает среднюю ширину шрифта, используемого по умолчанию для текущего
буфера, в пикселях.
@end defun

@defun default-font-height
Функция возвращает высоту в пикселях шрифта, используемого по умолчанию для текущего
буфера.
@end defun

@defun window-font-width &optional window face
Функция возвращает среднюю ширину в пикселях для шрифта, используемого @var{face} в
@var{window}.  Указанное @var{window} должно быть активным окном.  Если @code{nil}
или опущено, @var{window} по умолчанию соответствует выбранному окну, а @var{face} по
умолчанию использует вид по умолчанию в @var{window}.
@end defun

@defun window-font-height &optional window face
Функция возвращает высоту в пикселях для шрифта, используемого @var{face} в
@var{window}.  Указанное @var{window} должно быть активным окном.  Если @code{nil}
или опущено, @var{window} по умолчанию соответствует выбранному окну, а @var{face} по
умолчанию использует вид по умолчанию в @var{window}.
@end defun

@node Fringes
@section Оконтовка
@cindex fringes

  На графических дисплеях Emacs рисует @dfn{оконтовку} рядом с каждым окном: тонкие
вертикальные полосы по сторонам, которые могут отображать растровые изображения,
указывающие на усечение, продолжение, горизонтальную прокрутку и так далее.

@menu
* Fringe Size/Pos::     Уточняется, куда ставить оконные оконтовки.
* Fringe Indicators::   Отображение значков индикаторов на краях окон.
* Fringe Cursors::      Отображение курсоров в правой части.
* Fringe Bitmaps::      Указание растровых изображений для индикаторов краев.
* Customizing Bitmaps:: Указание собственных растровых изображений для использования
                            на краях.
* Overlay Arrow::       Отображение стрелки для указания положения.
@end menu

@node Fringe Size/Pos
@subsection Размер и Положение Оконтовок

  Следующие локальные переменные буфера управляют положением и шириной полос в окнах,
отображающих этот буфер.

@defvar fringes-outside-margins
Полосы обычно появляются между полями отображения и текстом окна.  Если значение
равно не-@code{nil}, они появляются за пределами полей дисплея.
@xref{Display Margins}.
@end defvar

@defvar left-fringe-width
Переменная, если не-@code{nil}, определяет ширину левой границы в пикселях.  Значение
@code{nil} означает использование ширины левого края рамки окна.
@end defvar

@defvar right-fringe-width
Переменная, если не-@code{nil}, определяет ширину правой границы в пикселях.  Значение
@code{nil} означает использование ширины правой границы рамки окна.
@end defvar

  Любой буфер, в котором не указаны значения для этих переменных, использует значения,
указанные в параметрах фрейма @code{left-fringe} и @code{right-fringe}.
(@pxref{Layout Parameters}).

  Вышеупомянутые переменные фактически вступают в силу через функцию
@code{set-window-buffer} (@pxref{Buffers and Windows}), которая вызывает
@code{set-window-fringes} как подпрограмму.  Если вы изменить одну из этих переменных,
отображение оконтовки не будет обновлено в существующих окнах, показывающих буфер,
если не вызвать @code{set-window-buffer} снова в каждом затронутом окне.  Также можно
использовать @code{set-window-fringes} для управления отображением оконтовки в
отдельных окнах.

@defun set-window-fringes window left &optional right outside-margins
Функция устанавливает ширину края окна @var{window}.  Если @var{window} равно
@code{nil}, используется выбранное окно.

Аргумент @var{left} определяет ширину в пикселях левой полосы, а также @var{right}
для правой полосы.  Значение @code{nil} для любого из них означает ширину по
умолчанию.  Если @var{outside-margins} - не-@code{nil}, это указывает, что полосы
должны появляться за пределами полей дисплея.

Если @var{window} недостаточно велико для размещения полос желаемой ширины, это
оставляет края @var{window} без изменений.

Значения, указанные здесь, могут быть позже переопределены путем вызова
@code{set-window-buffer} (@pxref{Buffers and Windows}) для @var{window} с его
аргументом @var{keep-margins} установленным в @code{nil} или опущеным.
@end defun

@defun window-fringes &optional window
Функция возвращает информацию о краях окна @var{window}.  Если @var{window} не указано
или @code{nil}, используется выбранное окно.  Значение имеет вид
@code{(@var{left-width} @var{right-width} @var{outside-margins})}.
@end defun


@node Fringe Indicators
@subsection Индикаторы Оконтовки
@cindex fringe indicators
@cindex indicators, fringe

  @dfn{Индикаторы оконтовки} - это крошечные значки, отображаемые на краю окна для
обозначения усеченных или продолженных строк, границ буфера и так далее.

@defopt indicate-empty-lines
@cindex fringes, and empty line indication
@cindex empty lines, indicating
Когда это не-@code{nil}, Emacs отображает специальный глиф на краю каждой пустой
строки в конце буфера на графических дисплеях.  @xref{Fringes}.  Переменная
автоматически является локальной в каждом буфере.
@end defopt

@defopt indicate-buffer-boundaries
@cindex buffer boundaries, indicating
Локальная в буфере переменная определяет, как границы буфера и прокрутка окна
отображаются на краях окна.

Emacs может указывать границы буфера - то есть первую и последнюю строку в буфере - с
помощью значков угла, когда они появляются на экране.  Кроме того, Emacs может
отображать стрелку вверх на краю, чтобы показать, что над экраном есть текст, и
стрелку вниз, чтобы показать, что есть текст под экраном.

Есть три вида основных значений:

@table @asis
@item @code{nil}
Не отображать ни один из этих значков оконтовки.
@item @code{left}
Отображать значки углов и стрелки в левой части экрана.
@item @code{right}
Отображать значки углов и стрелки в правом краю.
@item any non-alist
Отображать значки углов в левой части экрана и не отображать стрелки.
@end table

В противном случае значение должно быть списком, которое указывает, какие индикаторы
краев отображать и где.  Каждый элемент списка должен иметь вид
@code{(@var{indicator} . @var{position})}.  Здесь @var{indicator} - это один из
@code{top}, @code{bottom}, @code{up}, @code{down} и @code{t} (что покрывает все еще
не указанные значки), а @var{position} - один из @code{left}, @code{right} и
@code{nil}.

Например, @code{((top . left) (t . right))} помещает растровое изображение верхнего
угла в левую полосу, а растровое изображение нижнего угла, а также оба растровых
изображения стрелок в правую полосу.  Чтобы отображать растровые изображения углов в
левой части и не отображать растровые изображения со стрелками, использовать
@code{((top .  left) (bottom . left))}.
@end defopt

@defvar fringe-indicator-alist
Локальная в буфере переменная определяет отображение логических индикаторов краев на
фактические растровые изображения, отображаемые в краях окна.  Значение представляет
собой список элементов @code{(@var{indicator} . @var{bitmaps})}, где @var{indicator}
указывает тип логического индикатора, а @var{bitmaps} указывает растровые изображения
границ, которые будут использоваться для этого индикатора.

  Каждый @var{indicator} должен быть одним из следующих символов:

@table @asis
@item @code{truncation}, @code{continuation}.
Использовать для строк усечения и продолжения.

@item @code{up}, @code{down}, @code{top}, @code{bottom}, @code{top-bottom}
Использовать, когда @code{indicate-buffer-boundaries} равно не-@code{nil}: @code{up}
и @code{down} указывает границу буфера, лежащую выше или ниже края окна; @code{top}
и @code{bottom} обозначают самую верхнюю и самую нижнюю текстовую строку буфера; а
@code{top-bottom} указывает, где в буфере есть только одна строка текста.

@item @code{empty-line}
Использовать для обозначения пустых строк, когда @code{indicate-empty-lines} равно
не-@code{nil}.

@item @code{overlay-arrow}
Использоватьб для наложения стрелок (@pxref{Overlay Arrow}).
@c Это где-нибудь используется?
@c @item Неизвестный индикатор растрового изображения:
@c @code{unknown}.
@end table

  Каждое значение @var{bitmaps} может быть списком символов
@code{(@var{left} @var{right} [@var{left1} @var{right1}])}.  Символы @var{left} и
@var{right} определяют точечные рисунки, отображаемые слева и/или справа для
конкретного индикатора.  @var{left1} и @var{right1} специфичны для индикаторов
@code{bottom} и @code{top-bottom} и используются, чтобы указать, что последняя
текстовая строка не имеет последней строки новой строки.  В качестве альтернативы
@var{bitmaps} может быть единственным символом, который используется как в левой,
так и в правой полосе.

  @xref{Fringe Bitmaps}, чтобы узнать о списке стандартных растровых символов и о том,
как определить свои собственные.  Кроме того, @code{nil} представляет собой пустой
битовый массив (то есть индикатор, который не показан).

  Когда @code{fringe-indicator-alist} имеет значение, локальное в буфере, и для
логического индикатора не определено растровое изображение, или растровое изображение
- @code{t}, используется соответствующее значение из значения по умолчанию
@code{fringe-indicator-alist}.
@end defvar

@node Fringe Cursors
@subsection Курсоры Оконтовки
@cindex fringe cursors
@cindex cursor, fringe

  Когда ширина строки равна ширине окна, Emacs отображает курсор в правом краю вместо
использования двух строк.  В зависимости от типа курсора текущего буфера используются
разные растровые изображения для представления курсора на границе.

@defopt overflow-newline-into-fringe
Если это не-@code{nil}, строки шириной, равной ширине окна (не считая последнего
символа новой строки), не продолжаются.  Вместо этого, когда точка находится в конце
строки, курсор появляется справа.
@end defopt

@defvar fringe-cursor-alist
Переменная определяет сопоставление типа логического курсора с фактическими растровыми
изображениями границ, отображаемыми справа.  Значение представляет собой список, в
котором каждый элемент имеет форму @code{(@var{cursor-type} . @var{bitmap})}, что
означает использование граничного растрового изображения @var{bitmap} для отображения
курсоров типа @var{cursor-type}.

Каждый @var{cursor-type} должен быть одним из @code{box}, @code{hollow}, @code{bar},
@code{hbar} или @code{hollow-small}.  Первые четыре имеют то же значение, что и в
параметре фрейма @code{cursor-type} (@pxref{Cursor Parameters}).  Тип
@code{hollow-small} используется вместо @code{hollow}, когда обычное растровое
изображение @code{hollow-rectangle} слишком велико, чтобы поместиться на определенной
строке дисплея.

Каждый @var{bitmap} должно быть символом, определяющим растровое изображение края,
которое будет отображаться для этого типа логического курсора.
@iftex
Смотреть подробности в следующем подразделе.
@end iftex
@ifnottex
@xref{Fringe Bitmaps}.
@end ifnottex

@c FIXME: Не могу найти переменную fringes-indicator-alist. Может
@c это должно быть fringe-indicator-alist или fringe-cursor-alist?  --xfq
Когда @code{fringe-cursor-alist} имеет значение, локальное для буфера, и для типа
курсора не определено растровое изображение, используется соответствующее значение из
значения по умолчанию @code{fringes-indicator-alist}.
@end defvar

@node Fringe Bitmaps
@subsection Растровые Изображения в Оконтовке
@cindex fringe bitmaps
@cindex bitmaps, fringe

  @dfn{Растровые изображения оконтовки} - это фактические растровые изображения,
которые представляют собой индикаторы логической границы для усеченных или
продолженных строк, границ буфера, стрелок наложения и так далее.  Каждое растовое
изображение представлено символом.
@iftex
Символы называются переменными @code{fringe-indicator-alist} и
@code{fringe-cursor-alist}, описанными в предыдущих подразделах.
@end iftex
@ifnottex
На эти символы ссылаются переменная @code{fringe-indicator-alist}, которая отображает
индикаторы краев на растровые изображения (@pxref{Fringe Indicators}), и переменная
@code{fringe-cursor-alist}, которая отображает краевые курсоры в растовые изображения
(@pxref{Fringe Cursors}).
@end ifnottex

  Программы на Lisp могут также напрямую отображать растровое изображение в левой или
правой части, используя свойство @code{display} для одного из символов, появляющихся
в строке.  (@pxref{Other Display Specs}).  Такая спецификация отображения имеет вид:

@example
(@var{fringe} @var{bitmap} [@var{face}])
@end example

@noindent
@var{fringe} - это либо символ @code{left-fringe} или @code{right-fringe}.
@var{bitmap} - это символ, определяющий отображаемое растровое изображение.
Необязательный @var{face} называет вид, цвет переднего плана которого используется для
отображения растрового изображения; этот вид автоматически объединяется с
оконтовкой @code{fringe}.

  Вот список стандартных растровых изображений, определенных в Emacs, и то, как они
в настоящее время используются в Emacs.  (по средствам
@code{fringe-indicator-alist} и @code{fringe-cursor-alist}):

@table @asis
@item @code{left-arrow}, @code{right-arrow}
Используется для обозначения усеченных строк.

@item @code{left-curly-arrow}, @code{right-curly-arrow}
Используется для обозначения продолжающихся строк.

@item @code{right-triangle}, @code{left-triangle}
Первый используется стрелками наложения.  Последний не используется.

@item @code{up-arrow}, @code{down-arrow}, @code{top-left-angle} @code{top-right-angle}
@itemx @code{bottom-left-angle}, @code{bottom-right-angle}
@itemx @code{top-right-angle}, @code{top-left-angle}
@itemx @code{left-bracket}, @code{right-bracket}, @code{top-right-angle}, @code{top-left-angle}
Используется для обозначения границ буфера.

@item @code{filled-rectangle}, @code{hollow-rectangle}
@itemx @code{filled-square}, @code{hollow-square}
@itemx @code{vertical-bar}, @code{horizontal-bar}
Используется для разных типов курсоров с оконтовкой.

@item @code{empty-line}, @code{exclamation-mark}, @code{question-mark}, @code{exclamation-mark}
Не используется основными функциями Emacs.
@end table

@noindent
В следующем подразделе описывается, как определять собственные растровые
изображения оконтовки.

@defun fringe-bitmaps-at-pos &optional pos window
Функция возвращает растровые изображения краев строки отображения, содержащей позицию
@var{pos} в окне @var{window}.  Возвращаемое значение имеет вид
@code{(@var{left} @var{right} @var{ov})}, где @var{left} - это символ растрового
изображения края в левой части (или @code{nil}, если растровое изображение
отсутствует), @var{right} аналогично для правой границы, а @var{ov} - это
не-@code{nil}, если слева есть стрелка наложения оконтовки.

Значение @code{nil}, если @var{pos} не отображается в @var{window}.  Если @var{window}
- @code{nil}, это означает выбранное окно.  Если @var{pos} равно @code{nil}, это
означает значение точки в @var{window}.
@end defun

@node Customizing Bitmaps
@subsection Настройка Растровых Изображений Оконтовки
@cindex fringe bitmaps, customizing

@defun define-fringe-bitmap bitmap bits &optional height width align
Функция определяет символ @var{bitmap} как новое побочное растровое изображение или
заменяет существующее растровое изображение с этим именем.

Аргумент @var{bits} указывает изображение для использования.  Это должна быть строка
или вектор целых чисел, где каждый элемент (целое число) соответствует одной строке
растрового изображения.  Каждый бит целого числа соответствует одному пикселю
растрового изображения, где младший бит соответствует крайнему правому пикселю
растрового изображения.

Высота обычно равна длине @var{bits}.  Однако можно указать другую высоту с помощью
@var{height} установленным в не-@code{nil}.  Ширина обычно равна 8, но можно указать
другую ширину с помощью @var{width} установленым в не-@code{nil}.  Ширина должна быть
целым числом от 1 до 16.

Аргумент @var{align} определяет расположение растрового изображения относительно
диапазона строк, в котором оно используется; по умолчанию растровое изображение
центрируется.  Допустимые значения: @code{top}, @code{center}, или @code{bottom}.

Аргумент @var{align} также может быть списком @code{(@var{align} @var{periodic})},
где @var{align} интерпретируется, как описано выше.  Если @var{periodic} -
не-@code{nil}, указывается, что строки в @code{bits} должны повторяться столько раз,
чтобы достичь указанной высоты.
@end defun

@defun destroy-fringe-bitmap bitmap
Функция уничтожает растровое изображение краев, идентифицированное @var{bitmap}.
Если @var{bitmap} идентифицирует стандартное растровое изображение оконтовки,
фактически восстанавливается стандартное определение этого растрового изображения, а
не полностью устраняется оно.
@end defun

@defun set-fringe-bitmap-face bitmap &optional face
Устанавливается грань для растрового изображения края @var{bitmap} на @var{face}.
Если @var{face} равно @code{nil}, выбирается грань @code{fringe}.  Вид растрового
изображения контролирует цвет для его рисования.

@var{face} объединяется с гранью @code{fringe}, поэтому обычно @var{face} должно
указывать только цвет переднего плана.
@end defun

@node Overlay Arrow
@subsection Стрелки Наложения
@c @cindex стрелка наложения Дублирует имена переменных

  @dfn{Стрелки наложения} полезны для привлечения внимания пользователя к определенной
строке в буфере.  Например, в режимах, используемых для взаимодействия с отладчиками,
стрелка наложения указывает строку кода, которая должна быть выполнена.  Эта функция
не имеет ничего общего с @dfn{наложениями} (@pxref{Overlays}).

@defvar overlay-arrow-string
Переменная содержит строку, отображаемую для привлечения внимания к определенной
строке, или @code{nil}, если функция стрелки не используется.  На графическом дисплее
содержимое строки игнорируется; вместо этого в периферийной области слева от области
отображения отображается глиф.
@end defvar

@defvar overlay-arrow-position
Переменная содержит маркер, указывающий, где отображать стрелку в наложении.  Должно
указываться на начало строки.  На неграфическом дисплее текст стрелки появляется в
начале этой строки, перекрывая любой текст, который в противном случае появился бы.
Поскольку стрелка обычно короткая, а строка обычно начинается с отступа, обычно
ничего значительного не перезаписывается.

Строка стрелки наложения отображается в любом заданном буфере, если значение
@code{overlay-arrow-position} в этом буфере указывает на этот буфер.  Таким образом,
можно отображать несколько строк со стрелками в наложении, создавая привязки
@code{overlay-arrow-position} к локальному буферу.  Однако обычно для достижения
этого результата лучше использовать @code{overlay-arrow-variable-list}.
@c !!! overlay-arrow-position: но строка наложения может оставаться в отображаемом
@c некоторого другого буфера до тех пор, пока не потребуется обновление.
@c Теперь это должно быть исправлено. Это?
@end defvar

  Можно проделать аналогичную работу, создав наложение со свойством
@code{before-string}.  @xref{Overlay Properties}.

  Можно определить несколько стрелок наложения с помощью переменной
@code{overlay-arrow-variable-list}.

@defvar overlay-arrow-variable-list
Значение этой переменной представляет собой список переменных, каждая из которых
определяет положение стрелки наложения.  Переменная @code{overlay-arrow-position}
имеет свое обычное значение, потому что она находится в этом списке.
@end defvar

Каждая переменная в этом списке может иметь свойства @code{overlay-arrow-string} и
@code{overlay-arrow-bitmap}, которые определяют строку стрелки наложения (для
текстовых терминалов) или края растрового изображения (для графических терминалов)
для отображения в соответствующей позиции стрелки наложения.  Если какое-либо
свойство не установлено, используется индикатор оконтовки @code{overlay-arrow-string}
или @code{overlay-arrow} по умолчанию.


@node Scroll Bars
@section Полосы Прокрутки
@cindex scroll bars

Обычно параметр фрейма @code{vertical-scroll-bars} определяет, есть ли у окон во
фрейме вертикальные полосы прокрутки и находятся ли они слева или справа.  Параметр
фрейма @code{scroll-bar-width} указывает их ширину (@code{nil} означает значение по
умолчанию).

   Параметр фрейма @code{horizontal-scroll-bars} определяет, есть ли у окон во фрейме
горизонтальные полосы прокрутки.  Параметр фрейма @code{scroll-bar-height} указывает,
насколько они высоки (@code{nil} означает значение по умолчанию).
@xref{Layout Parameters}.

@vindex horizontal-scroll-bars-available-p
   Горизонтальные полосы прокрутки доступны не на всех платформах.  Функция
@code{horizontal-scroll-bars-available-p}, которая не принимает аргументов,
возвращает не-@code{nil}, если они доступны в вашей системе.

   Следующие три функции принимают в качестве аргумента живой фрейм, по умолчанию
выбранный.

@defun frame-current-scroll-bars &optional frame
Функция сообщает о типах полосы прокрутки для фрейма @var{frame}.  Значение - это
cons-ячейка @code{(@var{vertical-type} .@: @var{horizontal-type})}, где
@var{vertical-type} - это либо @code{left}, либо @code{right}, либо @code{nil} (что
означает отсутствие вертикальной полосы прокрутки).  @var{horizontal-type} - это либо
@code{bottom}, либо @code{nil} (что означает отсутствие горизонтальной полосы
прокрутки).
@end defun

@defun frame-scroll-bar-width &optional frame
Функция возвращает ширину вертикальных полос прокрутки @var{frame} в пикселях.
@end defun

@defun frame-scroll-bar-height &optional frame
Функция возвращает высоту горизонтальных полос прокрутки @var{frame} в пикселях.
@end defun

Можно переопределить настройки отдельных фреймов для отдельных окон, используя
следующую функцию:

@defun set-window-scroll-bars window &optional width vertical-type height horizontal-type
Функция устанавливает ширину и/или высоту и типы полос прокрутки для окна
@var{window}.  Если @var{window} равно @code{nil}, используется выбранное окно.

@var{width} определяет ширину вертикальной полосы прокрутки в пикселях (@code{nil}
означает использование ширины, указанной для фрейма).  @var{vertical-type} указывает,
нужна ли вертикальная полоса прокрутки, и если да, то где.  Возможные значения:
@code{left}, @code{right}, @code{t}, что означает использование фрейма по умолчанию,
и @code{nil}, если вертикальная полоса прокрутки отсутствует.

@var{height} определяет высоту горизонтальной полосы прокрутки в пикселях (@code{nil}
означает использование высоты, указанной для фрейма).  @var{horizontal-type}
указывает, нужна ли горизонтальная полоса прокрутки.  Возможные значения:
@code{bottom}, @code{t}, что означает использование фрейма по умолчанию, и @code{nil},
если горизонтальная полоса прокрутки отсутствует.

Если @var{window} недостаточно велико для размещения полосы прокрутки желаемого
размера, это оставляет соответствующую полосу прокрутки без изменений.

Значения, указанные здесь, могут быть позже переопределены путем вызова
@code{set-window-buffer} (@pxref{Buffers and Windows}) для окна @var{window} с его
аргументом @var{keep-margins} установленным в @code{nil} или опущеным.
@end defun

Следующие четыре функции принимают в качестве аргумента активное окно, значение
которого по умолчанию выбрано.

@defun window-scroll-bars &optional window
Эта функция возвращает список в форме @code{(@var{width}
@var{columns} @var{vertical-type} @var{height} @var{lines}
@var{horizontal-type})}.

Значение @var{width} - это значение, указанное для ширины вертикальной полосы
прокрутки (которое может быть @code{nil}); @var{columns} - это (возможно, округленное)
количество столбцов, которые фактически занимает вертикальная полоса прокрутки.

Значение @var{height} - это значение, указанное для высоты горизонтальной полосы
прокрутки (которое может быть @code{nil}); @var{lines} - это (возможно, округленное)
количество строк, которые фактически занимает горизонтальная полоса прокрутки.
@end defun

@defun window-current-scroll-bars &optional window
Эта функция сообщает тип полосы прокрутки для окна @var{window}.  Значение - это
cons-ячейка @code{(@var{vertical-type} .@: @var{horizontal-type})}.  В отличие от
@code{window-scroll-bars}, сообщается о фактически используемом типе полосы прокрутки
с учетом настроек фрейма по умолчанию и @code{scroll-bar-mode}.
@end defun

@defun window-scroll-bar-width &optional window
Функция возвращает ширину в пикселях вертикальной полосы прокрутки @var{window}.
@end defun

@defun window-scroll-bar-height &optional window
Функция возвращает высоту в пикселях горизонтальной полосы прокрутки @var{window}.
@end defun

Если не указать эти значения для окна с @code{set-window-scroll-bars}, локальные в
буфере переменные @code{vertical-scroll-bar}, @code{horizontal-scroll-bar},
@code{scroll-bar-width} и @code{scroll-bar-height} в отображаемом буфере управляют
полосами прокрутки окна.  Функция @code{set-window-buffer} проверяет эти переменные.
Если изменить их в буфере, который уже виден в окне, можно заставить окно принимать
к сведению новые значения, вызовом @code{set-window-buffer}, указав тот же буфер,
который уже отображается.

Можно управлять появлением полос прокрутки для определенного буфера, задав следующие
переменные, которые автоматически становятся локальными для буфера при установке.

@defvar vertical-scroll-bar
Переменная определяет расположение вертикальной полосы прокрутки.  Возможные значения:
@code{left}, @code{right}, @code{t}, что означает использование фрейма по умолчанию,
и @code{nil}, если полоса прокрутки отсутствует.
@end defvar

@defvar horizontal-scroll-bar
Переменная определяет расположение горизонтальной полосы прокрутки.  Возможные
значения: @code{bottom}, @code{t}, что означает использование фрейма по умолчанию,
и @code{nil}, если полоса прокрутки отсутствует.
@end defvar

@defvar scroll-bar-width
Переменная определяет ширину вертикальных полос прокрутки буфера, измеряемую в
пикселях.  Значение @code{nil} означает использование значения, указанного во фрейме.
@end defvar

@defvar scroll-bar-height
Переменная определяет высоту горизонтальной полосы прокрутки буфера, измеряемую в
пикселях.  Значение @code{nil} означает использование значения, указанного во фрейме.
@end defvar

Наконец, можно переключить отображение полос прокрутки на всех фреймах, настроив
переменные @code{scroll-bar-mode} и @code{horizontal-scroll-bar-mode}.

@defopt scroll-bar-mode
Переменная определяет, следует ли и где размещать вертикальные полосы прокрутки во
всех фреймах.  Возможные значения: @code{nil} для отсутствия полос прокрутки,
@code{left} для размещения полос прокрутки слева и @code{right} для размещения полос
прокрутки справа.
@end defopt

@defopt horizontal-scroll-bar-mode
Переменная определяет, отображать ли горизонтальные полосы прокрутки на всех фреймах.
@end defopt


@node Window Dividers
@section Оконные Разделители
@cindex window dividers
@cindex right dividers
@cindex bottom dividers

Оконные разделители - это перегородки, нарисованные между окнами фрейма.  Правый
разделитель рисуется между окном и любыми соседними окнами справа.  Его ширина
(толщина) задается параметром рамки @code{right-divider-width}.  Нижний разделитель
рисуется между окном и соседними окнами внизу или в эхо-области.  Его ширина задается
параметром рамки @code{bottom-divider-width}.  В любом случае указание нулевой ширины
означает, что такие разделители не отображаются.  @xref{Layout Parameters}.

   Технически правый разделитель принадлежит окну слева, что означает, что его ширина
составляет общую ширину этого окна.  Нижний разделитель принадлежит окну над ним, что
означает, что его ширина составляет общую высоту этого окна.  @xref{Window Sizes}.
Когда в окне есть и правый, и нижний разделители, преобладает нижний разделитель.  Это
означает, что нижний разделитель рисуется по всей ширине своего окна, в то время как
правый разделитель заканчивается над нижним разделителем.

   Разделители можно перетаскивать с помощью мыши, поэтому они полезны для регулировки
размеров соседних окон с помощью мыши.  Они также служат для визуального разделения
соседних окон, когда нет полос прокрутки или строк режима.  Следующие три вида
позволяют настраивать внешний вид разделителей:

@table @code
@item window-divider
Когда разделитель имеет ширину менее трех пикселей, он рисуется сплошным образом с
передним планом этого вида.  Для больших разделителей этот вид используется только
для внутренней части, за исключением первого и последнего пикселя.

@item window-divider-first-pixel
Вид, используемый для рисования первого пикселя разделителя шириной не менее трех
пикселей.  Чтобы получить сплошной внешний вид, установить то же значение, что и для
@code{window-divider} вида.

@item window-divider-last-pixel
Вид, используемый для рисования последнего пикселя разделителя шириной не менее трех
пикселей.  Чтобы получить сплошной внешний вид, установите то же значение, что и для
@code{window-divider} вида.
@end table

Можно получить размеры разделителей конкретного окна с помощью следующих двух функций.

@defun window-right-divider-width &optional window
Вернуть ширину (толщину) в пикселях правого разделителя @var{window}.  @var{window}
должно быть активным окном и по умолчанию быть выбранным.  Для крайнего правого окна
возвращаемое значение всегда равно нулю.
@end defun

@defun window-bottom-divider-width &optional window
Вернуть ширину (толщину) в пикселях нижнего разделителя @var{window}.  @var{window}
должно быть активным окном и по умолчанию быть выбранным.  Возвращаемое значение равно
нулю для окна минибуфера или самого нижнего окна во фрейме без минибуфера.
@end defun


@node Display Property
@section Настройки @code{отображения}
@cindex display specification
@kindex display @r{(text property)}

  Свойство текста @code{отображение} (или свойство наложения) используется для вставки
изображений в текст и для управления другими аспектами отображения текста.  Значение
свойства @code{display} должно быть спецификацией отображения, списком или вектором,
содержащим несколько спецификаций отображения.  Спецификации отображения в одном и
том же значении свойства @code{display} обычно применяются параллельно с охватываемым
ими текстом.

  Если несколько источников (наложение и/или текстовое свойство) задают значения для
свойства @code{display}, только одно из значений вступает в силу в соответствии с
правилами @code{get-char-property}.  @xref{Examining Properties}.

@cindex display property, unsafe evaluation
@cindex security, and display specifications
  Некоторые спецификации отображения позволяют включать формы Lisp, которые
оцениваются во время отображения.  Это может быть небезопасно в определенных
ситуациях, например, когда спецификация отображения была сгенерирована какой-либо
внешней программой/агентом.  Заключение спецификации отображения в список, который
начинается со специального символа @code{disable-eval}, как в
@w{@code{('disable-eval @var{spec})}}, отключит оценку любого @var{spec} Lisp, при
этом поддерживая все другие функции свойств отображения.

  Остальная часть этого раздела описывает несколько видов спецификаций отображения
и их значение.

@menu
* Replacing Specs::      Показать спецификации, заменяющие текст.
* Specified Space::      Отображение одного пробела с указанной шириной.
* Pixel Specification::  Указание ширины или высоты пробела в пикселях.
* Other Display Specs::     Отображение изображения; регулировка высоты,
                                интервала и других свойств текста.
* Display Margins::     Отображение текста или изображений сбоку от основного текста.
@end menu

@node Replacing Specs
@subsection Характеристики Отображения, Заменяющие Текст
@cindex replacing display specs

  Некоторые виды спецификаций отображения указывают что-то для отображения вместо
текста, имеющего свойство.  Это так называемые спецификации @dfn{замены} отображения.
Emacs не позволяет пользователю интерактивно перемещать точку в середину текста
буфера, который заменяется таким образом.

  Если список спецификаций отображения включает более одной заменяющей спецификации
отображения, первая имеет приоритет над остальными.  Замена технических характеристик
отображения делает большинство других характеристик отображения неактуальными,
поскольку они не относятся к замене.

  Для замены спецификаций отображения @dfn{текста, имеющего свойства} означает, что
все следующие друг за другом символы имеют тот же объект Lisp, что и их свойство
@code{display}; эти символы заменяются как единое целое.  Если два символа имеют
разные объекты Lisp в качестве своих свойств @code{display} (то есть объекты, не
являющиеся @code{eq}), они обрабатываются отдельно.

  Вот пример, иллюстрирующий эту точку зрения.  Строка служит заменяющей
спецификацией отображения, которая заменяет текст, имеющий свойство, указанной
строкой.  (@pxref{Other Display Specs}).  Рассмотрим следующую функцию:

@smallexample
(defun foo ()
  (dotimes (i 5)
    (let ((string (concat "A"))
          (start (+ i i (point-min))))
      (put-text-property start (1+ start) 'display string)
      (put-text-property start (+ 2 start) 'display string))))
@end smallexample

@noindent
Функция дает каждому из первых десяти символов в буфере свойство @code{display},
которое является строкой @code{"A"}, но не все они получают один и тот же строковый
объект.  Первые два символа получают один и тот же строковый объект, поэтому они
заменяются одним @samp{A}; тот факт, что свойство display было присвоено
@code{put-text-property} двумя отдельными вызовами, не имеет значения.  Точно так же
следующие два символа получают вторую строку (@code{concat} создает новый строковый
объект), поэтому они заменяются одним @samp{A}; и так далее.  Таким образом, десять
знаков отображаются как пять А.

@node Specified Space
@subsection Указывание Пробелов
@cindex spaces, specified height or width
@cindex variable-width spaces

  Чтобы отобразить пробел указанной ширины и/или высоты, использовать спецификацию
отображения в форме @code{(space . @var{props})}, где @var{props} - это список свойств
(список чередующихся свойств и значений).  Можно добавить это свойство к одному или
нескольким последовательным символам; пробел указанной высоты и ширины отображается
вместо @emph{всех} этих символов.  Вот свойства, которые можно использовать в
@var{props}, чтобы указать вес пробела:

@table @code
@item :width @var{width}
Если @var{width} - число, оно указывает, что ширина пробела должна быть в
@var{width} раз больше нормальной ширины символа.  @var{width} также может быть
спецификацией @dfn{ширины пикселя} (@pxref{Pixel Specification}).

@item :relative-width @var{factor}
Указывает, что ширина пробела должна вычисляться от первого символа в группе
последовательных символов, которые имеют одно и то же свойство @code{display}.  Ширина
пробела - это ширина этого символа в пикселях, умноженная на @var{factor}.  (На
терминалах с текстовым режимом ``ширина пикселя'' символа обычно равно 1, но может
быть больше для TAB и символов CJK двойной ширины.)

@item :align-to @var{hpos}
Указывает, что пробел должен быть достаточно широким, чтобы достичь @var{hpos}.
Если @var{hpos} - это число, оно измеряется в единицах нормальной ширины символа.
@var{hpos} также может быть спецификацией @dfn{ширина пикселя}
(@pxref{Pixel Specification}).
@end table

  Потребуется использовать одно и только одно из перечисленных выше свойств.  Также
можно указать высоту пробела с помощью следующих свойств:

@table @code
@item :height @var{height}
Задает высоту пробела.  Если @var{height} - это число, оно указывает, что высота
пробела должна быть в @var{height} раз больше нормальной высоты символа.
@var{height} также может быть спецификацией @dfn{высота пикселя}
(@pxref{Pixel Specification}).

@item :relative-height @var{factor}
Задает высоту пробела, умножая обычную высоту текста, имеющего эту спецификацию
отображения, на @var{factor}.

@item :ascent @var{ascent}
Если значение @var{ascent} является неотрицательным числом, не превышающим 100, оно
указывает, что @var{ascent} процентов высоты пробела следует рассматривать как
подъем пробела, то есть часть над базовой линией.  Подъем также может быть указан в
пиксельных единицах со спецификацией @dfn{пиксельный подъем}
(@pxref{Pixel Specification}).

@end table

  Не использовать оба @code{:height} и @code{:relative-height} вместе.

  Свойства @code{:width} и @code{:align-to} поддерживаются на неграфических
терминалах, но другие свойства пробелов в этом разделе - нет.

  Обратить внимание, что свойства пробелов обрабатываются как разделители абзацев с
целью переупорядочения двунаправленного текста для отображения.
@xref{Bidirectional Display}, для деталей.

@node Pixel Specification
@subsection Спецификация Пикселей для Пробелов
@cindex spaces, pixel specification

  Значение свойств @code{:width}, @code{:align-to}, @code{:height} и @code{:ascent}
может быть выражением особого вида, которое вычисляется во время повторного
отображения.  Результат оценки используется как абсолютное количество пикселей.

  Поддерживаются следующие выражения:

@smallexample
@group
  @var{expr} ::= @var{num} | (@var{num}) | @var{unit} | @var{elem} | @var{pos} | @var{image} | @var{xwidget} | @var{form}
  @var{num}  ::= @var{integer} | @var{float} | @var{symbol}
  @var{unit} ::= in | mm | cm | width | height
@end group
@group
  @var{elem} ::= left-fringe | right-fringe | left-margin | right-margin
        |  scroll-bar | text
  @var{pos}  ::= left | center | right
  @var{form} ::= (@var{num} . @var{expr}) | (@var{op} @var{expr} ...)
  @var{op}   ::= + | -
@end group
@end smallexample

  Форма @var{num} определяет долю высоты или ширины шрифта по умолчанию.  Форма
@code{(@var{num})} указывает абсолютное количество пикселей.  Если @var{num} является
символом, @var{symbol}, используется привязка его локальной переменной к буферу;
эта привязка может быть числом или cons-ячейкой форм, показанных выше (включая еще
одну cons-ячейку, @code{car} которой является символом, имеющим локальную привязку
к буферу).

  В единицах @code{in}, @code{mm} и @code{cm} указывается количество пикселей на дюйм,
миллиметр и сантиметр соответственно.  Единицы @code{width} и @code{height}
соответствуют ширине и высоте по умолчанию текущего вида.  Спецификация изображения в
форме @w{@code{(image . @var{props})}} (@pxref{Image Descriptors}) соответствует
ширине или высоте указанного изображения.  Точно так же спецификация xwidget в форме
@w{@code{(xwidget . @var{props})}} обозначает ширину или высоту указанного xwidget.
@xref{Xwidgets}.

  Элементы @code{left-fringe}, @code{right-fringe}, @code{left-margin},
@code{right-margin}, @code{scroll-bar} и @code{text} определяют ширину соответствующей
области окна.  Когда в окне отображаются номера строк
(@pxref{Size of Displayed Text}), ширина области @code{text} уменьшается на экранное
пространство, занимаемое отображением номеров строк.

  Позиции @code{left}, @code{center} и @code{right} можно использовать с
@code{:align-to}, чтобы указать положение относительно левого края, центра или правого
края текстовой области.  Когда в окне отображаются номера строк, позиции @code{left}
и @code{center} смещаются, чтобы учесть пространство экрана, занимаемое отображением
номера строки.

  Любой из вышеперечисленных оконных элементов (кроме @code{text}) также может
использоваться с @code{:align-to}, чтобы указать, что позиция находится относительно
левого края данной области.  После того, как базовое смещение для относительного
положения было установлено (по первому появлению одного из этих символов), дальнейшие
появления этих символов интерпретируются как ширина указанной области.  Например,
чтобы выровнять по центру левого поля, использовать

@example
:align-to (+ left-margin (0.5 . left-margin))
@end example

  Если для выравнивания не задано конкретное базовое смещение, оно всегда выполняется
относительно левого края текстовой области.  Например, @samp{:align-to 0} в строке
заголовка выравнивается по первому текстовому столбцу в текстовой области.  Когда в
окне отображаются номера строк, считается, что текст начинается там, где
заканчивается пространство, используемое для отображения номеров строк.

  Значение вида @code{(@var{num} . @var{expr})} обозначает произведение значений
@var{num} и @var{expr}.  Например, @code{(2 . in)} задает ширину 2 дюйма, а
@code{(0.5 . @var{image})} указывает половину ширины (или высоты) указанного
@var{image} (которая должна быть задана спецификацией изображения).

  Форма @code{(+ @var{expr} ...)} суммирует значения выражений.  Форма
@code{(- @var{expr} ...)} отрицает или вычитает значение выражений.

@node Other Display Specs
@subsection Другие Характеристики Отображения

  Вот другие виды спецификаций отображения, которые можно использовать в текстовом
свойстве @code{display}.

@table @code
@item @var{string}
Отображать @var{string} вместо текста с этим свойством.

Спецификации рекурсивного отображения не поддерживаются---свойства @var{string}
@code{display}, если таковые имеются, не используются.

@item (image . @var{image-props})
Этот вид спецификации отображения представляет собой дескриптор изображения
(@pxref{Images}).  При использовании в качестве спецификации отображения это означает
отображение изображения вместо текста, который имеет спецификацию отображения.

@item (slice @var{x} @var{y} @var{width} @var{height})
Эта спецификация вместе с @code{image} определяет @dfn{slice} (частичную область)
изображения для отображения.  Элементы @var{y} и @var{x} определяют верхний левый
угол фрагмента внутри изображения; @var{width} и @var{height} указывают ширину и
высоту среза.  Целые числа - это количество пикселей.  Число с плавающей точкой в
диапазоне 0,0--1,0 обозначает часть ширины или высоты всего изображения.

@item ((margin nil) @var{string})
Спецификация отображения этой формы означает отображение @var{string} вместо текста,
имеющего спецификацию отображения, в той же позиции, что и этот текст.  Это
эквивалентно использованию только @var{string}, но это частный случай отображения
на полях (@pxref{Display Margins}).

@item (left-fringe @var{bitmap} @r{[}@var{face}@r{]})
@itemx (right-fringe @var{bitmap} @r{[}@var{face}@r{]})
Спецификация отображения на любом символе строки текста приводит к тому, что
указанный @var{bitmap} отображается в левой или правой полосе для этой строки вместо
символов, которые имеют спецификацию отображения.  Необязательный @var{face}
определяет цвета, которые будут использоваться для растрового изображения.
@xref{Fringe Bitmaps}, для подробностей.

@item (space-width @var{factor})
Спецификация отображения влияет на все символы пробела в тексте, имеющем спецификацию.
Отображаются все эти пробелы в размер в 0 раз больше, чем обычно.  Элемент
@var{factor} должен быть целым числом или с плавающей точкой.  Символы, отличные от
пробелов, не затрагиваются; в частности, это не влияет на символы табуляции.

@item (height @var{height})
Спецификация отображения делает текст выше или короче.  Вот возможности @var{height}:

@table @asis
@item @code{(+ @var{n})}
@c FIXME: Добавить индекс для шага?  --xfq
Означает использование шрифта, который на @var{n} шагов больше.  @dfn{step}
определяется набором доступных шрифтов - в частности, тех, которые соответствуют тому,
что было иначе указано для этого текста, во всех атрибутах, кроме высоты.  Каждый
размер, для которого доступен подходящий шрифт, считается еще одним шагом.  @var{n}
должно быть целым числом.

@item @code{(- @var{n})}
Означает использование шрифта, который на @var{n} шагов меньше.

@item a number, @var{factor}
Число @var{factor} означает использование шрифта, высота которого в @var{factor} раз
превышает высоту шрифта по умолчанию.

@item a symbol, @var{function}
Символ - это функция для вычисления высоты. Он вызывается с текущей высотой в
качестве аргумента и должен возвращать новую высоту для использования.

@item anything else, @var{form}
Если значение @var{height} не соответствует предыдущим возможностям, вступает в силу
это форма.  Emacs оценивает её, чтобы получить новую высоту с символом @code{height},
привязанным к текущей указанной высоте шрифта.
@end table

@item (raise @var{factor})
Вид спецификации отображения увеличивает или уменьшает текст, к которому он
применяется, относительно базовой линии строки.  В основном предназначается для
поддержки отображения нижних и верхних индексов.

@var{factor} должно быть числом, которое интерпретируется как кратное высоте
затронутого текста.  Если положительно, это означает отображение поднятых символов.
Если отрицательно, означает, что они будут отображаться ниже.

Обратить внимание, что если текст также имеет спецификацию отображения @code{height},
которая была указана ранее (например, @: слева от) @code{raise}, последнее повлияет на
величину увеличения или уменьшения в пикселях, потому что это зависит от высоты
поднятия текста.  Поэтому, если требуется отобразить дополнительный или верхний
индекс, который меньше нормальной высоты текста, подумать о том, чтобы указать
@code{raise} перед @code{height}.
@end table

@c Помещается всё '@code{(when ...)}' в одну строку, чтобы стимулировать эвристику
@c конца предложения makeinfo для DTRT.  Раньше точка находилась на eol;
@c файл инфо оказался с двумя пробелами после него.
  Любую спецификацию отображения можно сделать условной.  Для этого упаковать её в
другой список вида @code{(when @var{condition} . @var{spec})}.  Тогда спецификация
@var{spec} применяется только тогда, когда @var{condition} оценивается как значение
не-@code{nil}.  Во время оценки @code{object} привязывается к строке или буферу,
имеющему условное свойство @code{display}.  @code{position} и @code{buffer-position}
привязаны к позиции внутри @code{object} и позиции в буфере, где было найдено свойство
@code{display}, соответственно.  Обе позиции могут быть разными, если @code{object} -
строка.

Обратить внимание, что @var{condition} будет оцениваться только тогда, когда redisplay
исследует текст, в котором находится эта спецификация отображения, поэтому эта функция
лучше всего подходит для условий, которые являются относительно стабильными, то есть
@: yield, для каждой конкретной позиции буфера, одинаковые результаты при каждой
оценке.  Если результаты меняются для одного и того же места текста, например, если
результат зависит от положения точки, тогда условная спецификация может не делать то,
что от неё требуется, потому что при повторном отображении исследуются только те части
текста буфера, где есть основания предполагать, что что-то изменилось с момента
последнего цикла отображения.

@node Display Margins
@subsection Отображение на Полях
@cindex display margins
@cindex margins, display

  Слева и справа в буфере могут быть пустые области, называемые
@dfn{полями отображения}.  Обычный текст никогда не появляется в этих областях, но
возможно поместить элементы на поля отображения с помощью свойства @code{display}.
В настоящее время нет возможности сделать текст или изображения на полях
чувствительными к мыши.

  Способ отобразить что-либо на полях - указать это в спецификации отображения полей
в свойстве @code{display} некоторого текста.  Это заменяющая спецификация отображения,
означающая, что текст, на который она помещена, не отображается; отображается поле,
а этот текст - нет.

  Спецификация отображения полей выглядит как
@code{((margin right-margin) @var{spec})} или
@code{((margin left-margin) @var{spec})}.  Здесь @var{spec} - это еще одна
спецификация отображения, в которой указано, что отображать на полях.  Обычно это
строка текста для отображения или дескриптор изображения.

  Чтобы отобразить что-либо в определенном тексте буфера поля @emph{в связи с}, не
изменяя и не препятствуя отображению этого текста, помещается свойство
@code{before-string} в текст и помещается спецификация отображения полей до
содержимого строки.

  Обратить внимание, что если строка, отображаемая на поле, не определяет вид, ее
вид определяется с использованием тех же правил и приоритетов, что и для строк,
отображаемых в текстовой области (@pxref{Displaying Faces}).  Если это приводит к
нежелательной ``утечки'' вида в поле, убедиться, что для строки указан явно вид
отображения.

  Прежде чем на полях отображения можно будет что-либо отобразить, потребуется задать
им ненулевую ширину.  Обычный способ сделать это - установить следующие переменные:

@defvar left-margin-width
Переменная определяет ширину левого поля в единицах символьной ячейки (также
известной как @: ``column'').  Является локальной для всех буферов.  Значение
@code{nil} означает отсутствие левой маргинальной области.
@end defvar

@defvar right-margin-width
Переменная определяет ширину правого поля в единицах символьных ячеек.  Является
локальной для всех буферов.  Значение @code{nil} означает отсутствие правой
маргинальной области.
@end defvar

  Установка этих переменных не влияет сразу на окно.  Переменные проверяются, когда
в окне отображается новый буфер.  Таким образом, можно заставить изменения вступить
в силу, вызовом @code{set-window-buffer}.

  Также возможно сразу установить ширину полей.

@defun set-window-margins window left &optional right
Функция определяет ширину полей для окна @var{window} в единицах символьных ячеек.
Аргумент @var{left} контролирует левое поле, а @var{right} контролирует правое поле
(по умолчанию @code{0}).

Если @var{window} недостаточно велико для размещения полей желаемой ширины, это
оставляет поля @var{window} без изменений.

Значения, указанные здесь, могут быть позже переопределены вызовом
@code{set-window-buffer} (@pxref{Buffers and Windows}) для @var{window} с его
аргументом @var{keep-margins} установленныи в @code{nil} или опущеным.
@end defun

@defun window-margins &optional window
Функция возвращает ширину левого и правого полей @var{window} в качестве cons-ячейки
формы @w{@code{(@var{left} . @var{right})}}.  Если одна из двух маргинальных областей
не существует, ее ширина возвращается как @code{nil}; если ни одно из двух полей не
существует, функция возвращает @code{(nil)}.  Если @var{window} - @code{nil},
используется выбранное окно.
@end defun

@node Images
@section Изображения
@cindex images in buffers

  Чтобы отобразить изображение в буфере Emacs, потребуется сначала создать дескриптор
изображения, а затем использовать его как спецификатор отображения в свойстве
@code{display} текста, который отображается (@pxref{Display Property}).

  Emacs обычно может отображать изображения при запуске на графическом терминале.
Изображения не могут отображаться в текстовом терминале, на некоторых графических
терминалах, которые не поддерживают это, или если Emacs скомпилирован без поддержки
изображений.  Возможно использовать функцию @code{display-images-p}, чтобы определить,
могут ли изображения в принципе отображаться (@pxref{Display Feature Testing}).

@menu
* Image Formats::       Поддерживаемые форматы изображений.
* Image Descriptors::   Как указать изображение для использования в @code{:display}.
* XBM Images::          Специальные возможности для формата XBM.
* XPM Images::          Специальные возможности для формата XPM.
* ImageMagick Images::  Специальные функции, доступные через ImageMagick.
* SVG Images::          Создание и управление изображениями SVG.
* Other Image Types::   Поддерживаются различные другие форматы.
* Defining Images::     Удобные способы определения изображения для
                            последующего использования.
* Showing Images::      Удобные способы отображения изображения после его определения.
* Multi-Frame Images::  Некоторые изображения содержат более одного фрейма.
* Image Cache::         Внутренние механизмы отображения изображения.
@end menu

@node Image Formats
@subsection Форматы Изображений
@cindex image formats
@cindex image types

  Emacs может отображать множество различных форматов изображений.  Некоторые из этих
форматов изображений поддерживаются, только если установлены определенные библиотеки
поддержки.  На некоторых платформах Emacs может загружать библиотеки поддержки по
запросу; в таком случае переменную @code{dynamic-library-alist} можно использовать
для изменения набора известных имен этих динамических библиотек.
@xref{Dynamic Libraries}.

  Поддерживаемые форматы изображений (и необходимые библиотеки поддержки) включают
PBM и XBM (которые не зависят от библиотек поддержки и всегда доступны), XPM
(@code{libXpm}), GIF (@code{libgif} или @code{libungif}), JPEG (@code{libjpeg}),
TIFF (@code{libtiff}), PNG (@code{libpng}) и SVG (@code{librsvg}).

  Каждый из этих форматов изображений связан с файлом @dfn{символа типа изображения}.
Символы для вышеперечисленных форматов - соответственно @code{pbm}, @code{xbm},
@code{xpm}, @code{gif}, @code{jpeg}, @code{tiff}, @code{png} и @code{svg}.

  Более того, если собирается Emacs с поддержкой ImageMagick (@code{libMagickWand}),
Emacs может отображать любой формат изображения, который может ImageMagick.
@xref{ImageMagick Images}.  Все изображения, отображаемые через ImageMagick, имеют
символ типа @code{imagemagick}.

@defvar image-types
Переменная содержит список символов типов для форматов изображений, которые
потенциально поддерживаются в текущей конфигурации.

``Потенциально'' означает, что Emacs знает о типах изображений, не обязательно, что
они могут быть использованы (например, они могут зависеть от недоступных динамических
библиотек).  Чтобы узнать, какие типы изображений действительно доступны, использовать
@code{image-type-available-p}.
@end defvar

@defun image-type-available-p type
Функция возвращает не-@code{nil}, если изображения типа @var{type} могут быть
загружены и отображены.  @var{type} должно быть символом типа изображения.

Для типов изображений, библиотеки поддержки которых статически связаны, эта функция
всегда возвращает @code{t}.  Для типов изображений, библиотеки поддержки которых
загружаются динамически, возвращается @code{t}, если библиотека может быть загружена,
и @code{nil} в противном случае.
@end defun

@node Image Descriptors
@subsection Дескрипторы Изображений
@cindex image descriptor

  @dfn{Дескриптор изображения} - это список, который определяет базовые данные для
изображения и способы их отображения.  Обычно используется значение наложения
@code{display} или текстовое свойство (@pxref{Other Display Specs}); но
@xref{Showing Images}, удобные вспомогательные функции вставки изображений в буферы.

  Каждый дескриптор изображения имеет форму @code{(image . @var{props})}, где
@var{props} - это список свойств, состоящий из чередующихся символов и значений
ключевых слов, включая по крайней мере пару @code{:type @var{type}}, которая
определяет тип изображения.

  Ниже приводится список свойств, которые имеют значение для всех типов изображений
(есть также свойства, которые имеют значение только для определенных типов
изображений, как описано в следующих подразделах):

@table @code
@item :type @var{type}
Тип изображения.
@ifnottex
@xref{Image Formats}.
@end ifnottex
Каждый дескриптор изображения должен включать это свойство.

@item :file @var{file}
Указывает о загрузке изображения из файла @var{file}.  Если @var{file} не является
абсолютным именем файла, оно раскрывается относительно подкаталога @file{images} в
@code{data-directory}, а в противном случае - относительно каталогов, перечисленных
@code{x-bitmap-file-path}.  (@pxref{Face Attributes}).

@item :data @var{data}
Определяет необработанные данные изображения.  Каждый дескриптор изображения должен
иметь либо @code{:data} или @code{:file}, но не оба сразу.

Для большинства типов изображений значение свойства @code{:data} должно быть строкой,
содержащей данные изображения.  Некоторые типы изображений не поддерживают
@code{:data}; для некоторых других одного @code{:data} недостаточно, поэтому требуется
использовать другие свойства изображения вместе с @code{:data}.  Смотреть подробности
в следующих подразделах.

@item :margin @var{margin}
Указывает, сколько пикселей добавить в качестве дополнительного поля вокруг
изображения.  Значение @var{margin} должно быть неотрицательным числом или парой таких
чисел @code{(@var{x} . @var{y})}.  Если это пара, @var{x} указывает, сколько пикселей
добавить по горизонтали, а @var{y} указывает, сколько пикселей добавить по вертикали.
Если @code{:margin} не указано, значение по умолчанию равно нулю.

@item :ascent @var{ascent}
Определяет величину высоты изображения, используемую для его подъема, то есть часть
выше базовой линии.  Значение @var{ascent} должно быть числом в диапазоне от 0 до 100
или символом @code{center}.

Если @var{ascent} - число, этот процент от высоты изображения используется для его
подъема.

Если @var{ascent} - @code{center}, изображение центрируется по вертикали вокруг
центральной линии, которая будет вертикальной центральной линией текста,
нарисованного в позиции изображения, способом, указанным в свойствах текста и
наложениях, которые применяются к изображению.

Если это свойство опущено, по умолчанию используется значение 50.

@item :relief @var{relief}
Добавляет теневой прямоугольник вокруг изображения.  Значение @var{relief} определяет
ширину линий тени в пикселях.  Если @var{relief} отрицательно, тени рисуются так, что
изображение выглядит как нажатая кнопка; в противном случае она отображается как
нажатая кнопка.

@item :conversion @var{algorithm}
Определяет алгоритм преобразования, который следует применить к изображению перед его
отображением; значение @var{algorithm} указывает, какой алгоритм.

@table @code
@item laplace
@itemx emboss
Задает алгоритм обнаружения края Лапласа, который размывает небольшие различия в
цвете и выделяет более крупные различия.  Иногда люди считают это полезным для
отображения изображения отключенной кнопки.

@item (edge-detection :matrix @var{matrix} :color-adjust @var{adjust})
@cindex edge detection, images
Задает общий алгоритм обнаружения оконтовки.  @var{matrix} должен быть либо списком
из девяти элементов, либо вектором чисел из девяти элементов.  Пиксель в позиции
@math{x/y} в преобразованном изображении вычисляется из исходных пикселей вокруг этой
позиции.  @var{matrix} определяет для каждого пикселя в окрестности @math{x/y} фактор,
с которым этот пиксель будет влиять на преобразованный пиксель; element @math{0}
определяет коэффициент для пикселя в @math{x-1/y-1}, element @math{1} - коэффициент
для пикселя в @math{x/y-1} и так далее, как показано ниже:
@iftex
@tex
$$\pmatrix{x-1/y-1 & x/y-1  & x+1/y-1 \cr
   x-1/y  &   x/y &    x+1/y \cr
   x-1/y+1&   x/y+1 &  x+1/y+1 \cr}$$
@end tex
@end iftex
@ifnottex
@display
  (x-1/y-1  x/y-1  x+1/y-1
   x-1/y    x/y    x+1/y
   x-1/y+1  x/y+1  x+1/y+1)
@end display
@end ifnottex

Результирующий пиксель вычисляется из интенсивности цвета, полученной в результате
суммирования значений RGB окружающих пикселей, умножения на указанные коэффициенты и
деления этой суммы на сумму абсолютных значений факторов.

Обнаружение края Лапласа в настоящее время использует матрицу
@iftex
@tex
$$\pmatrix{1 & 0 & 0 \cr
   0&  0 &  0 \cr
   0 & 0 & -1 \cr}$$
@end tex
@end iftex
@ifnottex
@display
  (1  0  0
   0  0  0
   0  0 -1)
@end display
@end ifnottex

Обнаружение края тиснения использует матрицу
@iftex
@tex
$$\pmatrix{ 2 & -1 &  0 \cr
   -1 &  0 &  1 \cr
    0  & 1 & -2 \cr}$$
@end tex
@end iftex
@ifnottex
@display
  ( 2 -1  0
   -1  0  1
    0  1 -2)
@end display
@end ifnottex

@item disabled
Задает преобразование изображения так, чтобы оно выглядело отключенным.
@end table

@item :mask @var{mask}
Если @var{mask} равно @code{heuristic} или @code{(heuristic @var{bg})}, создать
обтравочную маску для изображения, чтобы фон фрейма был виден позади изображения.
Если @var{bg} не указано или @var{bg} равно @code{t}, определить цвет фона
изображения, посмотрев на четыре угла изображения, предполагая, что наиболее часто
встречающийся цвет в углах - это цвет фона изображения.  В противном случае @var{bg}
должно быть списком @code{(@var{red} @var{green} @var{blue})}, определяющим цвет фона
изображения.

Если @var{mask} равно @code{nil}, удалить маску с изображения, если она есть.
Изображения в некоторых форматах содержат маску, которую можно удалить, указав
@code{:mask nil}.

@item :pointer @var{shape}
Определяет форму указателя, когда указатель мыши находится над этим изображением.
@xref{Pointer Shape}, доступные формы указателя.

@item :map @var{map}
@cindex image maps
Связывает ключевую карту изображения @dfn{горячих точек} с этим изображением.

Ключевая карта изображений - это список, в котором каждый элемент имеет формат
@code{(@var{area} @var{id} @var{plist})}.  @var{area} задается как прямоугольник,
круг или многоугольник.

Прямоугольник - это cons-ячейка
@code{(rect . ((@var{x0} . @var{y0}) . (@var{x1} . @var{y1})))}
которая определяет пиксельные координаты левого верхнего и правого нижнего углов
прямоугольной области.

Круг - это cons-ячейка
@code{(circle . ((@var{x0} . @var{y0}) . @var{r}))}
которая указывает центр и радиус круга; @var{r} может быть числом с плавающей
запятой или целым числом.

Многоугольник - это cons-ячейка
@code{(poly . [@var{x0} @var{y0} @var{x1} @var{y1} ...])}
где каждая пара в векторе описывает один угол многоугольника.

Когда указатель мыши находится на активной области изображения, проверяется
@var{plist} этой горячей точки; если содержится свойство @code{help-echo}, которое
определяет всплывающую подсказку для активной точки, и если оно содержит свойство
@code{pointer}, которое определяет форму курсора мыши, когда находится в горячей
точке.  @xref{Pointer Shape}, для доступных форм указателя.

Когда щелкается мышью и когда указатель мыши находится над горячей точкой, событие
составляется путем объединения @var{id} горячей точки с событием мыши; например,
@code{[area4 mouse-1]}, если @var{id} горячей точки - @code{area4}.
@end table

@defun image-mask-p spec &optional frame
Функция возвращает @code{t}, если изображение @var{spec} имеет растровую маску.
@var{frame} - это фрейм, на котором будет отображаться изображение.  @var{frame}
указывающий на @code{nil} или опущенный означает использовать выбранный фрейм
(@pxref{Input Focus}).
@end defun

@node XBM Images
@subsection XBM Изображения
@cindex XBM

  Чтобы использовать формат XBM, указать @code{xbm} в качестве типа изображения.
Этот формат изображения не требует внешней библиотеки, поэтому изображения этого типа
всегда поддерживаются.

  Дополнительные свойства изображения, поддерживаемые для типа изображения @code{xbm}:

@table @code
@item :foreground @var{foreground}
Значение @var{foreground} должно быть строкой, определяющей цвет переднего плана
изображения, или @code{nil} для цвета по умолчанию.  Этот цвет используется для
каждого пикселя в XBM, который равен 1.  По умолчанию используется цвет переднего
плана фрейма.

@item :background @var{background}
Значение @var{background} должно быть строкой, определяющей цвет фона изображения,
или @code{nil} для цвета по умолчанию.  Этот цвет используется для каждого пикселя в
XBM, который равен 0.  По умолчанию используется цвет фона фрейма.
@end table

  Если указать изображение XBM с использованием данных внутри Emacs вместо внешнего
файла, использовать следующие три свойства:

@table @code
@item :data @var{data}
Значение @var{data} определяет содержимое изображения.  Для @var{data} можно
использовать три формата:

@itemize @bullet
@item
Вектор строк или логических векторов, каждый из которых определяет одну строку
изображения.  Указать @code{:height} и @code{:width}.

@item
Строка, содержащая ту же последовательность байтов, что и файл XBM.  В этом случае
потребуется указывать @code{:height} и @code{:width}, потому что их отсутствие
указывает на то, что данные имеют формат файла XBM.  В содержимом файла указывается
высота и ширина изображения.

@item
Строка или логический вектор, содержащий биты изображения (плюс, возможно, некоторые
дополнительные биты в конце, которые не будут использоваться).  Должно содержаться как
минимум @var{width} * @code{height} бит.  В этом случае потребуется указать
@code{:height} и @code{:width}, чтобы утвердить, что строка содержит только биты, а не
весь файл XBM, и задать размер изображения.
@end itemize

@item :width @var{width}
Значение @var{width} указывает ширину изображения в пикселях.

@item :height @var{height}
Значение @var{height} указывает высоту изображения в пикселях.
@end table

@node XPM Images
@subsection Изображения XPM
@cindex XPM

  Чтобы использовать формат XPM, указать @code{xpm} в качестве типа изображения.
Дополнительное свойство изображения @code{:color-symbols} также имеет значение для
типа изображения @code{xpm}:

@table @code
@item :color-symbols @var{symbols}
Значение @var{symbols} должно быть списком, элементы которого имеют вид
@code{(@var{name} . @var{color})}.  В каждом элементе @var{name} - это имя цвета,
отображаемое в файле изображения, а @var{color} указывает фактический цвет,
используемый для отображения этого имени.
@end table

@node ImageMagick Images
@subsection ImageMagick Изображения
@cindex ImageMagick images
@cindex images, support for more formats

  Если сборка Emacs поддерживает ImageMagick, можно использовать библиотеку
ImageMagick для загрузки многих форматов изображений
(@pxref{File Conveniences,,, emacs, The GNU Emacs Manual}).  Символ типа изображения
для изображений, загружаемых через ImageMagick, - @code{imagemagick}, независимо от
фактического основного формата изображения.

Чтобы проверить поддержку ImageMagick, использовать следующее:

@lisp
(image-type-available-p 'imagemagick)
@end lisp

@defun imagemagick-types
Функция возвращает список расширений файлов изображений, поддерживаемых текущей
установкой ImageMagick.  Каждый элемент списка представляет собой символ,
представляющий внутреннее имя ImageMagick для типа изображения, например @code{BMP}
для изображений @file{.bmp}.
@end defun

@defopt imagemagick-enabled-types
Значение этой переменной представляет собой список типов изображений ImageMagick,
которые Emacs может попытаться визуализировать с помощью ImageMagick.  Каждый элемент
списка должен быть одним из символов в списке, возвращаемом @code{imagemagick-types},
или эквивалентной строкой.  В качестве альтернативы значение @code{t} включает
ImageMagick для всех возможных типов изображений.  Независимо от значения этой
переменной @code{imagemagick-types-inhibit} (смотреть ниже) имеет приоритет.
@end defopt

@defopt imagemagick-types-inhibit
Значение этой переменной перечисляет типы изображений ImageMagick, которые никогда
не должны отображаться с использованием ImageMagick, независимо от значения
@code{imagemagick-enabled-types}.  Значение @code{t} полностью отключает ImageMagick.
@end defopt

@defvar image-format-suffixes
Переменная представляет собой список типов изображений, отображающих расширения имен
файлов.  Emacs использует это вместе со свойством изображения @code{:format}
(смотреть ниже), чтобы дать библиотеке ImageMagick подсказку относительно типа
изображения.  Каждый элемент имеет форму @code{(@var{type} @var{extension})}, где
@var{type} - это символ, определяющий тип содержимого изображения, а @var{extension} -
это строка, определяющая расширение имени связанного файла.
@end defvar

  Изображения, загруженные с помощью ImageMagick, поддерживают следующие
дополнительные свойства дескриптора изображения:

@table @code
@item :background @var{background}
@var{background}, если не-@code{nil}, должно быть строкой, определяющей цвет, который
используется в качестве цвета фона изображения, если изображение поддерживает
прозрачность.  Если значение - @code{nil}, по умолчанию используется цвет фона
оконтовки.

@item :width @var{width}, :height @var{height}
Ключевые слова @code{:width} и @code{:height} используются для масштабирования
изображения.  Если указано только одно из них, другое будет рассчитано с сохранением
соотношения сторон.  Если указаны оба параметра, соотношение сторон может не
сохраниться.

@item :max-width @var{max-width}, :max-height @var{max-height}
Ключевые слова @code{:max-width} и @code{:max-height} используются для
масштабирования, если размер изображения изображения превышает эти значения.  Если
установлено @code{:width}, оно будет иметь приоритет над @code{max-width}, а если
установлено @code{:height}, оно будет иметь приоритет над @code{max-height}, но в
противном случае потребуется смешивать эти ключевые слова по своему усмотрению.
@code{:max-width} и @code{:max-height} всегда сохраняет соотношение сторон.

Если оба @code{:width} и @code{:max-height} было установлено (но @code{:height} не
было установлено), тогда @code{:max-height} будет иметь приоритет.  То же самое и с
противоположной комбинацией: ключевое слово ``max'' имеет приоритет.  То есть, если
есть изображение размером 200x100 и указано, что @code{:width} должно быть 400, а
@code{:max-height} должно быть 150, получится изображение размером 300x150: с
сохранением соотношения сторон и без превышения параметра ``max''.  Эта комбинация
параметров - удобный способ сказать ``отображать это изображение как можно больше,
но не больше доступной области отображения''.

@item :scale @var{scale}
Должно быть число, где значение больше 1 означает увеличение размера, а меньшее -
уменьшение размера.  Например, значение 0,25 сделает изображение размером в четверть
от первоначального.  Если масштабирование делает изображение больше, чем указано в
@code{:max-width} или @code{:max-height}, результирующий размер не будет превышать
эти два значения.  Если указаны оба @code{:scale} и @code{:height}/@code{:width},
высота/ширина будут скорректированы с указанным коэффициентом масштабирования.

@item :format @var{type}
Значение @var{type} должно быть символом, определяющим тип данных изображения, как
указано в @code{image-format-suffixes}.  Это используется, когда изображение не имеет
связанного имени файла, предоставляя ImageMagick подсказку, чтобы помочь ему
определить тип изображения.

@item :rotation @var{angle}
Задает угол поворота в градусах.

@item :index @var{frame}
@xref{Multi-Frame Images}.
@end table

@node SVG Images
@subsection SVG Изображения
@cindex SVG images

SVG (масштабируемая векторная графика) - это формат XML для определения изображений.
Если ваша сборка Emacs поддерживает SVG, можно создавать эти изображения и управлять
ими с помощью следующих функций из библиотеки @file{svg.el}.

@defun svg-create width height &rest args
Создать новое пустое изображение SVG с указанными размерами.  @var{args} - это список
аргументов, в котором можно указать следующее:

@table @code
@item :stroke-width
Ширина по умолчанию (в пикселях) всех созданных линий.

@item :stroke
Цвет обводки по умолчанию для любых созданных линий.
@end table

@cindex SVG object
Функция возвращает @dfn{SVG объект}, структуру данных Lisp, которая определяет
изображение SVG, и все следующие функции работают с этой структурой.  Аргумент
@var{svg} в следующих функциях определяет такой объект SVG.
@end defun

@defun svg-gradient svg id type stops
Создать градиент в @var{svg} с идентификатором @var{id}.  @var{type} указывает тип
градиента и может иметь значением @code{linear} или @code{radial}.  @var{stops} - это
список пар процент/цвет.

Следующее создаст линейный градиент, который идет от красного в начале до зеленого на
25% пути и до синего в конце:

@lisp
(svg-gradient svg "gradient1" 'linear
              '((0 . "red") (25 . "green") (100 . "blue")))
@end lisp

Созданный градиент (и вставленный в объект SVG) впоследствии может использоваться
всеми функциями, создающими фигуры.
@end defun

Все следующие функции принимают необязательный список параметров ключевого слова,
которые изменяют различные атрибуты их значений по умолчанию.  Допустимые атрибуты
включают:

@table @code
@item :stroke-width
Ширина (в пикселях) нарисованных линий и контуров вокруг твердых фигур.

@item :stroke-color
Цвет нарисованных линий и контуров вокруг твердых фигур.

@item :fill-color
Цвет, используемый для твердых форм.

@item :id
Идентифицирование формы.

@item :gradient
Если задано, это должен быть идентификатор ранее определенного объекта градиента.
@end table

@defun svg-rectangle svg x y width height &rest args
Добавить в @var{svg} прямоугольник, левый верхний угол которого находится в позиции
@var{x}/@var{y}, а размер - @var{width}/@var{height}.

@lisp
(svg-rectangle svg 100 100 500 500 :gradient "gradient1")
@end lisp
@end defun

@defun svg-circle svg x y radius &rest args
Добавить в @var{svg} круг с центром в @var{x}/@var{y} и радиусом @var{radius}.
@end defun

@defun svg-ellipse svg x y x-radius y-radius &rest args
Добавить к @var{svg} эллипс с центром в @var{x}/@var{y}, горизонтальным радиусом
@var{x-radius} и вертикальным радиусом @var{y-radius}.
@end defun

@defun svg-line svg x1 y1 x2 y2 &rest args
Добавить в @var{svg} строку, которая начинается с @var{x1}/@var{y1} и продолжается
до @var{x2}/@var{y2}.
@end defun

@defun svg-polyline svg points &rest args
Добавить в @var{svg} многосегментную линию (также известную как @: ``ломаная линия''),
которая проходит через @var{points}, которая представляет собой список пар
позиций X/Y.

@lisp
(svg-polyline svg '((200 . 100) (500 . 450) (80 . 100))
              :stroke-color "green")
@end lisp
@end defun

@defun svg-polygon svg points &rest args
Добавить многоугольник в @var{svg}, где @var{points} - это список пар X/Y, которые
описывают внешнюю окружность многоугольника.

@lisp
(svg-polygon svg '((100 . 100) (200 . 150) (150 . 90))
             :stroke-color "blue" :fill-color "red")
@end lisp
@end defun

@defun svg-text svg text &rest args
Добавить указанный @var{text} в @var{svg}.

@lisp
(svg-text
 svg "Это текст"
 :font-size "40"
 :font-weight "bold"
 :stroke "black"
 :fill "white"
 :font-family "impact"
 :letter-spacing "4pt"
 :x 300
 :y 400
 :stroke-width 1)
@end lisp
@end defun

@defun svg-embed svg image image-type datap &rest args
Добавить внедренное (растровое) изображение в @var{svg}.  Если @var{datap} -
@code{nil}, @var{image} должно быть именем файла; в противном случае это должна быть
строка, содержащая данные изображения в виде необработанных байтов.  @var{image-type}
должно иметь тип изображения @acronym{MIME}, например @code{"image/jpeg"}.

@lisp
(svg-embed svg "~/rms.jpg" "image/jpeg" nil
           :width "100px" :height "100px"
           :x "50px" :y "75px")
@end lisp
@end defun

@defun svg-remove svg id
Удалить элемент с идентификатором @code{id} из файла @code{svg}.
@end defun

@defun svg-image svg
Наконец, @code{svg-image} принимает объект SVG в качестве аргумента и возвращает
объект изображения, пригодный для использования в таких функциях, как
@code{insert-image}.
@end defun

Вот полный пример, который создает и вставляет изображение с кругом:

@lisp
(let ((svg (svg-create 400 400 :stroke-width 10)))
  (svg-gradient svg "gradient1" 'linear '((0 . "red") (100 . "blue")))
  (svg-circle svg 200 200 100 :gradient "gradient1"
                  :stroke-color "green")
  (insert-image (svg-image svg)))
@end lisp


@node Other Image Types
@subsection Другие Типы Изображений
@cindex PBM

  Для изображений PBM указать тип изображения @code{pbm}.  Поддерживаются цветные,
полутоновые и монохромные изображения.  Для моно-изображений PBM поддерживаются два
дополнительных свойства изображения.

@table @code
@item :foreground @var{foreground}
Значение @var{foreground} должно быть строкой, определяющей цвет переднего плана
изображения, или @code{nil} для цвета по умолчанию.  Этот цвет используется для
каждого пикселя в PBM, равного 1.  По умолчанию используется цвет переднего плана
фрейма.

@item :background @var{background}
Значение @var{background} должно быть строкой, определяющей цвет фона изображения,
или @code{nil} для цвета по умолчанию.  Этот цвет используется для каждого пикселя в
PBM, который равен 0.  По умолчанию используется цвет фона фрейма.
@end table

@noindent
Остальные типы изображений, которые может поддерживаться Emacs:

@table @asis
@item GIF
Тип изображения @code{gif}.
Поддерживается свойство @code{:index}.  @xref{Multi-Frame Images}.

@item JPEG
Тип изображения @code{jpeg}.

@item PNG
Тип изображения @code{png}.

@item TIFF
Тип изображения @code{tiff}.
Поддерживается свойство @code{:index}.  @xref{Multi-Frame Images}.
@end table

@node Defining Images
@subsection Определение Изображений
@cindex define image

  Функции @code{create-image}, @code{defimage} и @code{find-image} предоставляют
удобные способы создания дескрипторов изображений.

@defun create-image file-or-data &optional type data-p &rest props
Функция создает и возвращает дескриптор изображения, который использует данные из
@var{file-or-data}.  @var{file-or-data} может быть именем файла или строкой,
содержащей данные изображения; @var{data-p} должно быть @code{nil} в первом случае,
не-@code{nil} во втором.

Необязательный аргумент @var{type} - это символ, определяющий тип изображения.  Если
@var{type} опущен или @code{nil}, @code{create-image} пытается определить тип
изображения по первым нескольким байтам файла или по имени файла.

Остальные аргументы, @var{props}, определяют дополнительные свойства изображения
--- например,

@c ':heuristic-mask' не документировано?
@example
(create-image "foo.xpm" 'xpm nil :heuristic-mask t)
@end example

Функция возвращает @code{nil}, если изображения этого типа не поддерживаются.  В
противном случае возвращается дескриптор изображения.
@end defun

@defmac defimage symbol specs &optional doc
Макрос определяет @var{symbol} как имя изображения.  Аргументы @var{specs} - это
список, который указывает, как отображать изображение.  Третий аргумент, @var{doc},
является необязательной строкой документации.

Каждый аргумент в @var{specs} имеет форму списка свойств, и каждый должен указывать
по крайней мере свойство @code{:type}, либо свойство @code{:file}, либо свойство
@code{:data}.  Значение @code{:type} должно быть символом, определяющим тип
изображения, значение @code{:file} - это файл, из которого загружается изображение,
а значение @code{:data} - это строка, содержащая фактические данные изображения.  Вот
пример:

@example
(defimage test-image
  ((:type xpm :file "~/test1.xpm")
   (:type xbm :file "~/test1.xbm")))
@end example

@code{defimage} проверяет каждый аргумент один за другим, чтобы увидеть, можно ли
его использовать - то есть, поддерживается ли тип и существует ли файл.  Первый
используемый аргумент используется для создания дескриптора изображения, который
хранится в @var{symbol}.

Если ни одна из альтернатив не работает, то @var{symbol} определяется как @code{nil}.
@end defmac

@defun image-property image property
Вернуть значение @var{property} в @var{image}.  Свойства могут быть установлены с
помощью @code{setf}.  Установка для свойства значения @code{nil} удалит это свойство
из изображения.
@end defun

@defun find-image specs
Функция предоставляет удобный способ найти изображение, удовлетворяющее одному из
списка спецификаций изображения @var{specs}.

Каждая спецификация в @var{specs} - это список свойств, содержимое которого зависит
от типа изображения.  Все спецификации должны как минимум содержать свойства
@code{:type @var{type}} и @w{@code{:file @var{file}}} или @w{@code{:data @var{data}}},
где @var{type} - это символ, определяющий тип изображения, например, @code{xbm},
@var{file} - это файл, из которого загружается изображение, а @var{data} - строка,
содержащая фактические данные изображения.  Первая спецификация в списке, у которой
@var{type} поддерживается, а @var{file} существует, используется для создания
возвращаемой спецификации изображения.  Если спецификация не удовлетворена,
возвращается @code{nil}.

Изображение ищется в @code{image-load-path}.
@end defun

@defopt image-load-path
Значение этой переменной представляет собой список мест, в которых следует искать
файлы изображений.  Если элемент является строкой или символом переменной, значение
которого является строкой, строка считается именем каталога для поиска.  Если элемент
представляет собой символ переменной, значение которой является списком, это
считается списком каталогов для поиска.

По умолчанию поиск выполняется в подкаталоге каталога @file{images}, заданном
параметром @code{data-directory}, затем в каталоге, указанном параметром
@code{data-directory}, и, наконец, в каталогах в @code{load-path}.  Подкаталоги не
включаются в поиск автоматически, поэтому, если помещается файл изображения в
подкаталог, потребуется явно указать подкаталог.  Например, чтобы найти изображение
@file{images/foo/bar.xpm} в @code{data-directory}, указывается изображение следующим
образом:

@example
(defimage foo-image '((:type xpm :file "foo/bar.xpm")))
@end example
@end defopt

@defun image-load-path-for-library library image &optional path no-error
Функция возвращает подходящий путь поиска изображений, используемых пакетом Lisp
@var{library}.

Функция ищет @var{image} сначала с помощью @code{image-load-path}, исключая
@file{@code{data-directory}/images}, а затем в @code{load-path}, за которым следует
путь, подходящий для @var{library}, который включает @file{../../etc/images} и
@file{../etc/images} относительно самого файла библиотеки, и, наконец, в
файле @file{@code{data-directory}/images}.

Затем функция возвращает список каталогов, который сначала содержит каталог, в
котором было найдено @var{image}, а затем значение @code{load-path}.  Если задано
@var{path}, оно используется вместо @code{load-path}.

Если @var{no-error} равено не-@code{nil} и подходящий путь не может быть найден, не
сигнализируйте об ошибке.  Вместо этого возвращается список каталогов, как и раньше,
за исключением того, что вместо каталога изображений отображается @code{nil}.

Вот пример использования @code{image-load-path-for-library}:

@example
(defvar image-load-path) ; shush compiler
(let* ((load-path (image-load-path-for-library
                    "mh-e" "mh-logo.xpm"))
       (image-load-path (cons (car load-path)
                              image-load-path)))
  (mh-tool-bar-folder-buttons-init))
@end example
@end defun

@vindex image-scaling-factor
Изображения автоматически масштабируются при создании на основе переменной
@code{image-scaling-factor}.  Значение представляет собой либо число с плавающей
запятой (где числа больше 1 означают увеличение размера, а меньшее - уменьшение
размера), либо символ @code{auto}, который вычисляет коэффициент масштабирования на
основе размера пикселя шрифта.

@node Showing Images
@subsection Показ Изображений
@cindex show image

  Можно использовать дескриптор изображения, настроив свойство @code{display}
самостоятельно, но проще использовать функции из этого раздела.

@defun insert-image image &optional string area slice
Функция вставляет @var{image} в текущий буфер в точке.  Значение @var{image} должно
быть дескриптором изображения; это может быть значение, возвращаемое
@code{create-image}, или значение символа, определенного с помощью @code{defimage}.
Аргумент @var{string} указывает текст, помещаемый в буфер для хранения изображения.
Если не указан или @code{nil}, @code{insert-image} по умолчанию использует @code{" "}.

Аргумент @var{area} указывает, помещать ли изображение на поле.  Если это
@code{left-margin}, изображение появляется в левом поле; @code{right-margin}
указывает правое поле.  Если @var{area} имеет значение @code{nil} или опущено,
изображение отображается в точке внутри текста буфера.

Аргумент @var{slice} указывает фрагмент изображения для вставки.  Если @var{slice}
равно @code{nil} или не указано, вставляется все изображение.  В противном случае
@var{slice} - это список @code{(@var{x} @var{y} @var{width} @var{height})}, который
указывает позиции @var{x} и @var{y} и @var{width} и @var{height} области изображения
для вставки.  Целочисленные значения выражаются в пикселях.  Число с плавающей запятой
в диапазоне 0,0--1,0 обозначает часть ширины или высоты всего изображения.

Внутренне функция вставляет @var{string} в буфер и дает ему свойство @code{display},
которое указывает @var{image}.  @xref{Display Property}.
@end defun

@cindex slice, image
@cindex image slice
@defun insert-sliced-image image &optional string area rows cols
Функция вставляет @var{image} в текущий буфер в точке, как @code{insert-image}, но
разбивает изображение на @var{rows}x@var{cols} срезы одинакового размера.

Emacs отображает каждый фрагмент как отдельное изображение и обеспечивает более
интуитивную прокрутку вверх/вниз вместо прыжков вверх/вниз по всему изображению при
перелистывании буфера, который отображает (большие) изображения.
@end defun

@defun put-image image pos &optional string area
Функция помещает изображение @var{image} перед @var{pos} в текущем буфере.  Аргумент
@var{pos} должно быть целым числом или маркером.  Определяет позицию буфера, в
которой должно появиться изображение.  Аргумент @var{string} указывает текст,
который должен содержать изображение в качестве альтернативы по умолчанию.

Аргумент @var{image} должен быть дескриптором изображения, возможно, возвращенным
@code{create-image} или сохраненным @code{defimage}.

Аргумент @var{area} указывает, помещать ли изображение на поле.  Если это
@code{left-margin}, изображение появляется в левом поле; @code{right-margin} указывает
правое поле.  Если @var{area} имеет значение @code{nil} или опущено, изображение
отображается в точке внутри текста буфера.

Внутри эта функция создает наложение и предоставляет ему свойство
@code{before-string}, содержащее текст, имеющий свойство @code{display}, значением
которого является изображение.  (Уф!)
@end defun

@defun remove-images start end &optional buffer
Функция удаляет изображения в @var{buffer} между позициями @var{start} and @var{end}.
Если @var{buffer} не указано или @code{nil}, изображения удаляются из текущего буфера.

При этом удаляются только изображения, которые были помещены в @var{buffer}, как это
делает @code{put-image}, а не изображения, которые были вставлены с помощью
@code{insert-image} или другими способами.
@end defun

@defun image-size spec &optional pixels frame
@cindex size of image
Функция возвращает размер изображения в виде пары
@w{@code{(@var{width} . @var{height})}}. @var{spec} - это спецификация изображения.
@var{pixels} установленное в не-@code{nil} означает возвращаемые размеры, измеренные
в пикселях, в противном случае возвращаемые размеры, измеренные в размере символа по
умолчанию @var{frame} (@pxref{Frame Font}).  @var{frame} - это фрейм, на котором
будет отображаться изображение.  @var{frame} указывающий на @code{nil} или опущенный
означает использовать выбранный фрейм (@pxref{Input Focus}).
@end defun

@defvar max-image-size
Переменная используется для определения максимального размера изображения, которое
будет загружать Emacs.  Emacs откажется загружать (и отображать) любое изображение,
размер которого превышает этот предел.

Если значение является целым числом, оно напрямую определяет максимальную высоту и
ширину изображения, измеряемую в пикселях.  Если это число с плавающей запятой, оно
определяет максимальную высоту и ширину изображения как отношение к высоте и ширине
фрейма.  Если значение не является числовым, нет явного ограничения на размер
изображений.

Назначение этой переменной - предотвратить случайную загрузку в Emacs неоправданно
больших изображений.  Вступает в силу только при первой загрузке изображения.  Как
только изображение помещается в кэш изображений, его всегда можно отобразить, даже
если значение @code{max-image-size} впоследствии будет изменено (@pxref{Image Cache}).
@end defvar

Изображения, вставленные с помощью указанных выше функций вставки, также получают
локальную ключевую карту, установленную в свойствах текста (или наложениях), которые
охватывают отображаемое изображение.  Эта карта определяет следующие команды:

@table @kbd
@item +
Увеличить размер изображения (@code{image-increase-size}).  Значение префикса
@samp{4} означает увеличение размера на 40%.  По умолчанию 20%.

@item -
Уменьшить размер изображения (@code{image-increase-size}).  Значение префикса
@samp {4} означает уменьшение размера на 40%.  По умолчанию 20%.

@item r
Повернуть изображение на 90 градусов (@code{image-rotate}).

@item o
Сохранить изображение в файл (@code{image-save}).
@end table

@node Multi-Frame Images
@subsection Много Фреймовые Изображения
@cindex multi-frame images

@cindex animation
@cindex image animation
@cindex image frames
Некоторые файлы изображений могут содержать более одного изображения.  Говорится, что
на изображении есть несколько ``frames''.  В настоящее время Emacs поддерживает
многофреймовые изображения для GIF, TIFF и некоторых форматов ImageMagick, таких как
DJVM@.

Фреймы могут использоваться либо для представления нескольких страниц (обычно это
бывает с многофреймовыми файлами TIFF, например), либо для создания анимации (обычно
в случае с многофреймовыми файлами GIF).

Многофреймовое изображение имеет свойство @code{:index}, значение которого является
целым числом (считая от 0), указывающим, какой фрейм отображается.

@defun image-multi-frame-p image
Функция возвращает не-@code{nil}, если @var{image} содержит более одного фрейма.
Фактическое возвращаемое значение - cons-ячейка @code{(@var{nimages} . @var{delay})},
где @var{nimages} - количество фреймов, а @var{delay} - задержка в секундах между
ними, или @code{nil}, если изображение не указывает задержку.  Изображения, которые
предназначены для анимации, обычно указывают задержку фрейма, тогда как изображения,
которые предназначены для обработки нескольких страниц, не имеют.
@end defun

@defun image-current-frame image
Функция возвращает индекс текущего номера фрейма для @var{image}, начиная с 0.
@end defun

@defun image-show-frame image n &optional nocheck
Функция переключает @var{image} на номер @var{n} фрейма.  Заменяется номер фрейма за
пределами допустимого диапазона на номер конца диапазона, если только @var{nocheck} не
не-@code{nil}.  Если в @var{image} нет фрейма с указанным номером, изображение
отображается в виде пустого поля.
@end defun

@defun image-animate image &optional index limit
Функция анимирует @var{image}.  Необязательное целое число @var{index} указывает
фрейм, с которого следует начать (по умолчанию 0).  Необязательный аргумент
@var{limit} управляет продолжительностью анимации.  Если опущено или @code{nil},
изображение анимируется только один раз; если @code{t}, зацикливается навсегда; если
числовая анимация останавливается через много секунд.
@end defun

@vindex image-minimum-frame-delay
@vindex image-default-frame-delay
@noindent Анимация работает с помощью таймера.  Обратить внимание, что Emacs
устанавливает минимальную задержку фрейма 0,01 (@code{image-minimum-frame-delay})
секунд.  Если в самом изображении задержка не указана, Emacs использует
@code{image-default-frame-delay}.

@defun image-animate-timer image
Функция возвращает таймер, отвечающий за анимацию @var{image}, если он есть.
@end defun


@node Image Cache
@subsection Кэш Изображений
@cindex image cache

  Emacs кэширует изображения, чтобы отображать их снова более эффективно.  Когда
Emacs отображает изображение, ищется в кэше изображений существующая спецификация
изображения @code{equal} в соответствии с желаемой спецификацией.  Если совпадение
найдено, изображение отображается из кеша.  В противном случае Emacs загружает
изображение обычным образом.

@defun image-flush spec &optional frame
Функция удаляет изображение со спецификацией @var{spec} из кеша изображений фрейма
@var{frame}.  Характеристики изображений сравниваются с помощью @code{equal}.  Если
@var{frame} равно @code{nil}, по умолчанию используется выбранный фрейм.  Если
@var{frame} равно @code{t}, изображение стирается на всех существующих фреймах.

В текущей реализации Emacs каждый графический терминал имеет кэш изображений, который
используется всеми фреймами на этом терминале (@pxref{Multiple Terminals}).  Таким
образом, обновление изображения в одном фрейме также обновляет его во всех других
фреймах на том же терминале.
@end defun

  Одно из применений @code{image-flush} - сообщить Emacs об изменении файла
изображения.  Если спецификация изображения содержит свойство @code{:file},
изображение кэшируется на основе содержимого файла при первом отображении изображения.
Даже если файл впоследствии изменится, Emacs продолжает отображать старую версию
изображения.  Вызов @code{image-flush} очищает изображение из кеша, заставляя Emacs
перечитать файл в следующий раз, когда ему потребуется отобразить это изображение.

  Другое использование @code{image-flush} - сохранение памяти.  Если программа на
Lisp создает большое количество временных изображений за период, намного меньший, чем
@code{image-cache-eviction-delay} (смотреть ниже), можно выбрать очистку
неиспользуемых изображений самостоятельно, вместо того, чтобы ждать, пока Emacs
сделает это автоматически.

@defun clear-image-cache &optional filter
Функция очищает кеш изображений, удаляя все изображения, хранящиеся в нем.  Если
@var{filter} не указано или @code{nil}, очищается кеш для выбранного фрейма.  Если
@var{filter} - это фрейм, очищается кеш для этого фрейма.  Если @var{filter} равно
@code{t}, все кеши изображений очищаются.  В противном случае @var{filter}
принимается как имя файла, и все изображения, связанные с этим именем файла,
удаляются из всех кешей изображений.
@end defun

Если изображение в кэше изображений не отображалось в течение определенного периода
времени, Emacs удаляет его из кеша и освобождает связанную с ним память.

@defvar image-cache-eviction-delay
Переменная определяет количество секунд, в течение которых изображение может
оставаться в кеше без отображения.  Когда изображение не отображается в течение этого
времени, Emacs удаляет его из кеша изображений.

В некоторых случаях, если количество изображений в кэше становится слишком большим,
фактическая задержка удаления может быть меньше этого значения.

Если значение равно @code{nil}, Emacs не удаляет изображения из кеша, кроме случаев,
когда явно очищается он.  Этот режим может быть полезен для отладки.
@end defvar

@node Xwidgets
@section Встроенные Собственные Виджеты
@cindex xwidget
@cindex embedded widgets
@cindex webkit browser widget

  Emacs может отображать собственные виджеты, такие как виджеты GTK+ WebKit, в
буферах Emacs, когда был построен с необходимыми библиотеками поддержки и запущен на
графическом терминале.  Чтобы проверить, поддерживает ли Emacs отображение встроенных
виджетов, проверить, доступна ли функция @code{xwidget-internal}
(@pxref{Named Features}).

  Чтобы отобразить встроенный виджет в буфере, необходимо сначала создать объект
xwidget, а затем использовать этот объект в качестве спецификатора отображения в
тексте @code{display} или свойстве наложения (@pxref{Display Property}).

@defun make-xwidget type title width height arguments &optional buffer
Это создает и возвращает объект xwidget.  Если @var{buffer} опущено или @code{nil},
по умолчанию используется текущий буфер.  Если @var{buffer} указывает буфер, которого
не существует, он будет создан.  @var{type} определяет тип компонента xwidget, он
может быть одним из следующих:

@table @code
@item webkit
Компонент WebKit.
@end table

Аргументы @var{width} и @var{height} определяют размер виджета в пикселях, а строка
@var{title} определяет его заголовок.
@end defun

@defun xwidgetp object
Функция возвращает @code{t}, если @var{object} является xwidget, и @code{nil} в
противном случае.
@end defun

@defun xwidget-plist xwidget
Функция возвращает список свойств @var{xwidget}.
@end defun

@defun set-xwidget-plist xwidget plist
Функция заменяет список свойств @var{xwidget} новым списком свойств, заданным
@var{plist}.
@end defun

@defun xwidget-buffer xwidget
Функция возвращает буфер @var{xwidget}.
@end defun

@defun get-buffer-xwidgets buffer
Функция возвращает список объектов xwidget, связанных с @var{buffer}, который может
быть указан как буферный объект или имя существующего буфера, строка.  Значение
@code{nil}, если @var{buffer} не содержит xwidgets.
@end defun

@defun xwidget-webkit-goto-uri xwidget uri
Функция просматривает указанный @var{uri} в данном @var{xwidget}.  @var{uri} - это
строка, определяющая имя файла или URL-адрес.
@c FIXME: Что еще может указывать URI в этом контексте?
@end defun

@defun xwidget-webkit-execute-script xwidget script
Функция заставляет виджет браузера, указанный в @var{xwidget}, выполнять указанный
JavaScript @code{script}.
@end defun

@defun xwidget-webkit-execute-script-rv xwidget script &optional default
Функция выполняет указанный @var{script}, как и @code{xwidget-webkit-execute-script},
но также возвращает возвращаемое значение скрипта в виде строки.  Если @var{script}
не возвращает значение, эта функция возвращает @var{default} или @code{nil}, если
@var{default} было опущено.
@end defun

@defun xwidget-webkit-get-title xwidget
Функция возвращает заголовок @var{xwidget} в виде строки.
@end defun

@defun xwidget-resize xwidget width height
Функция изменяет размер указанного @var{xwidget} до размера
@var{width}x@var{height} пикселей.
@end defun

@defun xwidget-size-request xwidget
Функция возвращает требуемый размер @var{xwidget} в виде списка вида
@code{(@var{width} @var{height})}.  Размеры указываются в пикселях.
@end defun

@defun xwidget-info xwidget
Функция возвращает атрибуты @var{xwidget} как вектор вида
@code{[@var{type} @var{title} @var{width} @var{height}]}.  Атрибуты обычно
определяются @code{make-xwidget} при создании xwidget.
@end defun

@defun set-xwidget-query-on-exit-flag xwidget flag
Функция позволяет настроить, чтобы Emacs запрашивал у пользователя подтверждение
перед выходом или перед уничтожением буфера, с которым связан @var{xwidget}.  Если
@var{flag} равен не-@code{nil}, Emacs запросит пользователя, в противном случае - нет.
@end defun

@defun xwidget-query-on-exit-flag xwidget
Функция возвращает текущее значение флага запроса при выходе @var{xwidget}, либо
@code{t} или @code{nil}.
@end defun

@node Buttons
@section Кнопки
@cindex buttons in buffers
@cindex clickable buttons in buffers

  Пакет Button определяет функции для вставки @dfn{кнопки} и управления им, которые
можно активировать с помощью мыши или с помощью команд клавиатуры.  Эти кнопки обычно
используются для различных типов гиперссылок.

  Кнопка - это, по сути, набор свойств текста или наложения, прикрепленный к
фрагменту текста в буфере.  Эти свойства называются @dfn{свойстваи кнопки}.  Одно из
этих свойств, @dfn{свойство действия}, определяет функцию, которая вызывается, когда
пользователь нажимает кнопку с помощью клавиатуры или мыши.  Функция действия может
исследовать кнопку и использовать другие ее свойства по желанию.

  В некотором смысле пакет Button дублирует функциональность пакета Widget.
@xref{Top, , Introduction, widget, The Emacs Widget Library}.  Преимущество пакета
Button в том, что он быстрее, меньше по размеру и проще в программировании.  С точки
зрения пользователя интерфейсы, создаваемые двумя пакетами, очень похожи.

@menu
* Button Properties::      Свойства кнопки со специальным значением.
* Button Types::           Определение общих свойств для классов кнопок.
* Making Buttons::         Добавление кнопок в буферы Emacs.
* Manipulating Buttons::   Получение и установка свойств кнопок.
* Button Buffer Commands:: Команды для всего буфера и привязки для кнопок.
@end menu

@node Button Properties
@subsection Свойства Кнопки
@cindex button properties

  Каждая кнопка имеет связанный список свойств, определяющих ее внешний вид и
поведение, а другие произвольные свойства могут использоваться для конкретных целей
приложения.  Следующие свойства имеют особое значение для пакета Button:

@table @code
@item action
@kindex action @r{(свойство кнопки)}
Функция, вызываемая, когда пользователь нажимает кнопку, которой передается
единственный аргумент @var{button}.  По умолчанию это @code{ignore}, который ничего
не делает.

@item mouse-action
@kindex mouse-action @r{(свойство кнопки)}
Похоже на @code{action}, и когда присутствует, будет использоваться вместо
@code{action} для вызовов кнопок в результате щелчков мышью (вместо того, чтобы
пользователь нажимал @key{RET}).  Если этого нет, вместо щелчка мышью используется
@code{action}.

@item face
@kindex face @r{(свойство кнопки)}
Вид отображения Emacs, управляющее отображением кнопок этого типа; по умолчанию этот
вид @code{button}.

@item mouse-face
@kindex mouse-face @r{(свойство кнопки)}
Это дополнительный вид, который контролирует внешний вид при наведении курсора мыши
(объединенное с обычным видом кнопки); по умолчанию это обычный вид Emacs
@code{highlight}.

@item keymap
@kindex keymap @r{(свойство кнопки)}
Ключевая карта кнопки, определяющая привязки, активные в области кнопки.  По умолчанию
это обычная карта области кнопок, хранящаяся в переменной @code{button-map}, которая
определяет @key{RET} и @key{mouse-2} для вызова кнопкой.

@item type
@kindex type @r{(свойство кнопки)}
Тип кнопки.  @xref{Button Types}.

@item help-echo
@kindex help-index @r{(свойство кнопки)}
Строка, отображения справочной системой всплывающих подсказок Emacs; по умолчанию
@code{"mouse-2, RET: Push this button"}.

@item follow-link
@kindex follow-link @r{(свойство кнопки)}
Свойство follow-link, определяющее, как щелчок @key{mouse-1} ведет себя на этой
кнопке, @xref{Clickable Text}.

@item button
@kindex button @r{(свойство кнопки)}
Все кнопки имеют свойство @code{button} установленное в не-@code{nil}, которое может
быть полезно при поиске областей текста, содержащих кнопки (что и делают стандартные
функции кнопок).
@end table

  Существуют и другие свойства, определенные для областей текста в кнопке, но они
обычно не интересны для типичного использования.

@node Button Types
@subsection Типы Кнопок
@cindex button types

  У каждой кнопки есть @dfn{тип кнопки}, который определяет значения по умолчанию для
свойств кнопки.  Типы кнопок организованы в иерархию со специализированными типами,
унаследованными от более общих типов, что позволяет легко определять специальные типы
кнопок для конкретных задач.

@defun define-button-type name &rest properties
Определить тип кнопки с именем @var{name} (символ).  Остальные аргументы образуют
последовательность пар @var{property value}, определяющих значения свойств по
умолчанию для кнопок с этим типом (тип кнопки можно установить, задав ей свойство
@code{type} при создании кнопки, используя аргумент ключевого слова @code{:type}).

Кроме того, аргумент ключевого слова @code{:supertype} может использоваться для
указания типа кнопки, от которого @var{name} наследует значения свойств по умолчанию.
Обратить внимание, что это наследование происходит только тогда, когда определено
@var{name}; последующие изменения супертипа не отражаются на его подтипах.
@end defun

  Использование @code{define-button-type} для определения свойств по умолчанию для
кнопок не является обязательным - кнопки без какого-либо указанного типа используют
встроенный тип кнопки @code{button} - но это приветствуется, поскольку это обычно
делает результирующий код более ясным и эффективным.

@node Making Buttons
@subsection Создание Кнопок
@cindex making buttons

  Кнопки связаны с областью текста с использованием наложения или свойств текста для
хранения информации, относящейся к кнопкам, каждая из которых инициализируется типом
кнопки (по умолчанию используется встроенный тип кнопки @code{button}).  Как и весь
текст Emacs, внешний вид кнопки определяется свойством @code{face}; по умолчанию
(через свойство @code{face}, унаследованное от типа кнопки @code{button}) это простое
подчеркивание, как обычная ссылка на веб-страницу.

  Для удобства существует два типа функций создания кнопок: те, которые добавляют
свойства кнопки в существующую область буфера, называемую @code{make-...button}, и те,
которые также вставляют текст кнопки, называемые @code{insert-...button}.

  Все функции создания кнопки принимают аргумент @code{&rest} @var{properties},
который должен быть последовательностью пар @var{property value}, определяющих
свойства для добавления к кнопке; смотреть @ref{Button Properties}.  Кроме того,
ключевое слово аргумент @code{:type} может использоваться для указания типа кнопки,
от которой наследуются другие свойства; смотреть @ref{Button Types}.  Любые свойства,
не указанные явно при создании, будут унаследованы от типа кнопки (если тип
определяет такое свойство).

  Следующие функции добавляют кнопку с помощью наложения (@pxref{Overlays}) для
хранения свойств кнопки:

@defun make-button beg end &rest properties
Делает кнопку от @var{beg} до @var{end} в текущем буфере и возвращает ее.
@end defun

@defun insert-button label &rest properties
Вставляет кнопку с меткой @var{label} в точке и возвращает ее.
@end defun

  Следующие функции аналогичны, но используют текстовые свойства
(@pxref{Text Properties}) для хранения свойств кнопки.  Такие кнопки не добавляют
маркеры в буфер, поэтому редактирование в буфере не замедляется при очень большом
количестве кнопок.  Однако, если в тексте есть свойство вид текста (например, вид
отображения, назначенный режимом блокировки шрифта), вид кнопки может быть не
отобразиться.  Обе эти функции возвращают начальную позицию новой кнопки.

@defun make-text-button beg end &rest properties
Создаётся кнопка от @var{beg} до @var{end} в текущем буфере, используя свойства
текста.
@end defun

@defun insert-text-button label &rest properties
Вставляется кнопка с меткой @var{label} в точке, используя свойства текста.
@end defun

@node Manipulating Buttons
@subsection Управление Кнопками
@cindex manipulating buttons

Функции для получения и настройки свойств кнопок.  Часто используются функцией вызова
кнопки, чтобы определить, что делать.

Если указан параметр @var{button}, это означает объект, ссылающийся на определенную
кнопку, либо наложение (для кнопок наложения), либо на позицию в буфере или маркер
(для кнопок свойств текста).  Такой объект передается в качестве первого аргумента
функции вызова кнопки при ее вызове.

@defun button-start button
Возврат позиции, с которой начинается @var{button}.
@end defun

@defun button-end button
Возвращается позиция, в которой заканчивается @var{button}.
@end defun

@defun button-get button prop
Получить свойство кнопки @var{button} с именем @var{prop}.
@end defun

@defun button-put button prop val
Установить для @var{button} свойства @var{prop} значение @var{val}.
@end defun

@defun button-activate button &optional use-mouse-action
Вызвать для @var{button} свойство @code{action} (то есть вызвать функцию, которая
является значением этого свойства, передав ей единственный аргумент @var{button}).
Если @var{use-mouse-action} - не-@code{nil}, попробовать вызвать свойство кнопки
@code{mouse-action} вместо @code{action}; если у кнопки нет свойства
@code{mouse-action}, использовать @code{action} как обычно.
@end defun

@defun button-label button
Вернуть текстовую метку @var{button}.
@end defun

@defun button-type button
Вернуть @var{button} button-type.
@end defun

@defun button-has-type-p button type
Вернуть @code{t}, если @var{button} имеет кнопочный @var{type} или один из подтипов
@var{type}.
@end defun

@defun button-at pos
Вернуть позицию кнопки @var{pos} в текущем буфере или @code{nil}.  Если кнопка в
@var{pos} является кнопкой с текстовым свойством, возвращаемое значение - это маркер,
указывающий на @var{pos}.
@end defun

@defun button-type-put type prop val
Задать для типа кнопки @var{type} свойства @var{prop} значение @var{val}.
@end defun

@defun button-type-get type prop
Получить для типа кнопки @var{type} свойство с именем @var{prop}.
@end defun

@defun button-type-subtype-p type supertype
Вернуть @code{t}, если тип кнопки @var{type} является подтипом @var{supertype}.
@end defun

@node Button Buffer Commands
@subsection Команды Кнопок Буфера
@cindex button buffer commands

Это команды и функции для поиска и работы с кнопками в буфере Emacs.

@code{push-button} - это команда, которую пользователь использует для фактического
нажатия кнопки, и по умолчанию в самой кнопке она привязана к @key{RET} и
@key{mouse-2} с использованием локальной ключевой карты в наложении кнопки или в
свойствах текста.  Команды, которые полезны вне самих кнопок, такие как
@code{forward-button} и @code{backward-button}, дополнительно доступны в ключевой
карте, хранящейся в @code{button-buffer-map}; режим, который используют кнопки, может
начать использовать @code{button-buffer-map} в качестве родительской карты для
своей карты.

Если кнопка имеет свойство @code{follow-link} установленное в не-@code{nil} и
установлено @code{mouse-1-click-follows-link}, быстрое нажатие на @key{mouse-1} также
активирует команду @code{push-button}.  @xref{Clickable Text}.

@deffn Command push-button &optional pos use-mouse-action
Выполнить действие, указанное кнопкой в расположении @var{pos}.  @var{pos} может быть
либо положением в буфере, либо событием мыши.  Если @var{use-mouse-action} -
не-@code{nil}, или @var{pos} - это (@pxref{Mouse Events}), вызванное событием мыши,
попытка вызвать свойство кнопки @code{mouse-action} вместо @code{action}; если кнопка
не имеет свойства @code{mouse-action}, использовать @code{action} как обычно.
@var{pos} по умолчанию указывает на точку, за исключением случаев, когда
@code{push-button} вызывается интерактивно в результате события мыши, и в этом случае
используется позиция события мыши.  Если в @var{pos} нет кнопки, ничего не делать и
вернуть @code{nil}, иначе вернуть @code{t}.
@end deffn

@deffn Command forward-button n &optional wrap display-message
Переход к кнопке @var{n} next или @var{n} previous, если @var{n} отрицательно.  Если
@var{n} равно нулю, перейти к началу любой кнопки в точке.  Если @var{wrap} равно
не-@code{nil}, движение за любой конец буфера продолжается с другого конца.  Если
@var{display-message} равно не-@code{nil}, отображается строка help-echo кнопки.
Любая кнопка со свойством @code{skip} установленным в не-@code{nil} пропускается.
Возвращает найденную кнопку.
@end deffn

@deffn Command backward-button n &optional wrap display-message
Переход к предыдущей @var{n} кнопке или следующей @var{n} кнопки, если @var{n}
отрицательно.  Если @var{n} равно нулю, перейти к началу любой кнопки в точке.  Если
@var{wrap} равно не-@code{nil}, движение за любой конец буфера продолжается с другого
конца.  Если @var{display-message} равно не-@code{nil}, отображается строка help-echo
кнопки.  Любая кнопка со свойством @code{skip} установленным в не-@code{nil}
пропускается.  Возвращается найденная кнопка.
@end deffn

@defun next-button pos &optional count-current
@defunx previous-button pos &optional count-current
Вернуть следующую кнопку после (для @code{next-button}) или до (для
@code{previous-button}) позиции @var{pos} в текущем буфере.  Если @var{count-current}
- не-@code{nil}, считать любую кнопку в @var{pos} в поиске, вместо того, чтобы
начинать со следующей кнопки.
@end defun

@node Abstract Display
@section Абстрактное Отображение
@cindex ewoc
@cindex display, abstract
@cindex display, arbitrary objects
@cindex model/view/controller
@cindex view part, model/view/controller

  Пакет Ewoc создает текст буфера, который представляет структуру объектов Lisp, и
обновляет текст, чтобы следовать изменениям в этой структуре.  Это похоже на компонент
``Посмотреть'' в парадигме дизайна ``model--view--controller''.  Ewoc means
``Виджет Emacs для коллекций объектов''.

  @dfn{Ewoc} - это структура, которая организует информацию, необходимую для создания
текста буфера, представляющего определенные данные Lisp.  Буферный текст ewoc состоит
из трех частей по порядку: первая, фиксированный текст @dfn{заголовок}; затем
текстовые описания серии элементов данных (объектов Lisp, которые указаны); и,
наконец, исправлен текст @dfn{нижний колонтитул}.  В частности, ewoc содержит
информацию о:

@itemize @bullet
@item
Буфер, в котором создается его текст.

@item
Начальная позиция текста в буфере.

@item
Строки верхнего и нижнего колонтитула.

@item
@cindex node, ewoc
@c or "@cindex узел, абстрактное отображение"?
Двусвязная цепочка @dfn{nodes}, каждая из которых содержит:

@itemize
@item
@dfn{data element}, единственный объект Lisp.

@item
Ссылки на предыдущие и последующие узлы в цепочке.
@end itemize

@item
@dfn{pretty-printer} функция, которая отвечает за вставку текстового представления
значения элемента данных в текущий буфер.
@end itemize

  Как правило, определяется ewoc с помощью @code{ewoc-create}, а затем передаётся
полученная структура ewoc другим функциям в пакете Ewoc, чтобы создать в ней узлы и
отобразить их в буфере.  Как только отображается в буфере, другие функции определяют
соответствие между позициями буфера и узлами, перемещают точку из текстового
представления одного узла в другое и так далее.  @xref{Abstract Display Functions}.

@cindex encapsulation, ewoc
@c or "@cindex инкапсуляция, абстрактное отображение"?
  Узел @dfn{инкапсулирует} - это элемент данных, во многом аналогично тому, как
переменная хранит значение.  Обычно инкапсуляция происходит как часть добавления узла
в ewoc.  Можно получить значение элемента данных и поместить на его место новое
значение, например:

@lisp
(ewoc-data @var{node})
@result{} значение

(ewoc-set-data @var{node} @var{new-value})
@result{} @var{new-value}
@end lisp

@noindent
Также можно использовать в качестве значения элемента данных объект Lisp (список или
вектор), который является контейнером для реального значения, или индекс в какой-либо
другой структуре.  В примере (@pxref{Abstract Display Example}) используется второй
подход.

  Когда данные изменятся, захочется обновить текст в буфере.  Можно обновить все узлы,
вызвав @code{ewoc-refresh}, или только определенные узлы, используя
@code{ewoc-invalidate}, или все узлы, удовлетворяющие предикату, используя
@code{ewoc-map}.  В качестве альтернативы можно удалить недопустимые узлы с помощью
@code{ewoc-delete} или @code{ewoc-filter} и добавить на их место новые узлы.  При
удалении узла из ewoc также удаляется связанное с ним текстовое описание из буфера.

@menu
* Abstract Display Functions::  Функции в пакете Ewoc.
* Abstract Display Example::    Пример использования Ewoc.
@end menu

@node Abstract Display Functions
@subsection Функции Абстрактного Отображения

  В этом подразделе @var{ewoc} и @var{node} обозначает структуры, описанные выше,
(@pxref{Abstract Display}), а @var{data} обозначает произвольный объект Lisp,
используемый в качестве элемента данных.

@defun ewoc-create pretty-printer &optional header footer nosep
Создает и возвращает новый ewoc без узлов (и, следовательно, без элементов данных).
@var{pretty-printer} должно быть функцией, которая принимает один аргумент, элемент
данных того типа, который планируется использовать в этом ewoc, и вставляет его
текстовое описание в точку, используя @code{insert} (и никогда не
@code{insert-before-markers}, потому что это будет мешать внутренним механизмам
пакета Ewoc).

Обычно новая строка автоматически вставляется после заголовка, нижнего колонтитула и
текстового описания каждого узла.  Если @var{nosep} - не-@code{nil}, новая строка не
вставляется.  Это может быть полезно, например, для отображения всего ewoc в одной
строке или для того, чтобы сделать узлы невидимыми, настроив @var{pretty-printer},
чтобы ничего не делать для этих узлов.

EWOC сохраняет свой текст в буфере, который является текущим при его создании,
поэтому переключитесь на предполагаемый буфер перед вызовом @code{ewoc-create}.
@end defun

@defun ewoc-buffer ewoc
Возвращается буфер, в котором @var{ewoc} хранит свой текст.
@end defun

@defun ewoc-get-hf ewoc
Возвращается cons-ячейка @code{(@var{header} . @var{footer})}, созданную из верхнего
и нижнего колонтитула @var{ewoc}.
@end defun

@defun ewoc-set-hf ewoc header footer
Устанавливается верхний и нижний колонтитулы @var{ewoc} в строки @var{header} и
@var{footer} соответственно.
@end defun

@defun ewoc-enter-first ewoc data
@defunx ewoc-enter-last ewoc data
Добавляется новый узел, инкапсулирующий @var{data}, помещается, соответственно, в
начало или конец цепочки узлов @var{ewoc}.
@end defun

@defun ewoc-enter-before ewoc node data
@defunx ewoc-enter-after ewoc node data
Добавляется новый узел, инкапсулирующий @var{data}, добавляется в @var{ewoc} до
или после @var{node} соответственно.
@end defun

@defun ewoc-prev ewoc node
@defunx ewoc-next ewoc node
Возвращается, соответственно, предыдущий узел и следующий узел @var{node} в
@var{ewoc}.
@end defun

@defun ewoc-nth ewoc n
Возвращается узел в @var{ewoc}, найденный с отсчитываемым от нуля индексом @var{n}.
Отрицательное @var{n} означает отсчет с конца.  @code{ewoc-nth} возвращается
@code{nil}, если @var{n} выходит за пределы допустимого диапазона.
@end defun

@defun ewoc-data node
Извлекает данные, инкапсулированные @var{node}, и возвращает их.
@end defun

@defun ewoc-set-data node data
Устанавливает данные, инкапсулированные @var{node}, в @var{data}.
@end defun

@defun ewoc-locate ewoc &optional pos guess
Определяет узел в @var{ewoc}, который содержит точку (или @var{pos}, если указано), и
возвращает этот узел.  Если @var{ewoc} не имеет узлов, возвращается @code{nil}.  Если
@var{pos} находится перед первым узлом, возвращается первый узел; если @var{pos}
находится после последнего узла, возвращается последний узел.  Необязательный третий
аргумент @var{guess} должен быть узлом, который, вероятно, находится рядом с
@var{pos}; это не меняет результат, но заставляет функцию работать быстрее.
@end defun

@defun ewoc-location node
Возвращает начальную позицию @var{node}.
@end defun

@defun ewoc-goto-prev ewoc arg
@defunx ewoc-goto-next ewoc arg
Перемещается точка на предыдущий или следующий узел, соответственно, @var{arg} в
@var{ewoc}.  @code{ewoc-goto-prev} не перемещается, если уже находится на первом узле
или если @var{ewoc} пусто, тогда как @code{ewoc-goto-next} перемещается за последний
узел, возвращая @code{nil}.  За исключением этого особого случая, эти функции
возвращают перемещенный узел.
@end defun

@defun ewoc-goto-node ewoc node
Перемещает точку в начало @var{node} в @var{ewoc}.
@end defun

@defun ewoc-refresh ewoc
Функция восстанавливает текст @var{ewoc}.  Работает, удаляя текст между верхним и
нижним колонтитулами, то есть все представления элементов данных, а затем вызывает
функцию pretty-printer для каждого узла, один за другим, по порядку.
@end defun

@defun ewoc-invalidate ewoc &rest nodes
Похоже на @code{ewoc-refresh}, за исключением того, что обновляется только
@var{nodes} в @var{ewoc}, а не весь набор.
@end defun

@defun ewoc-delete ewoc &rest nodes
Удаляет каждый узел в @var{nodes} из @var{ewoc}.
@end defun

@defun ewoc-filter ewoc predicate &rest args
Вызывается @var{predicate} для каждого элемента данных в @var{ewoc} и удаляются те
узлы, для которых @var{predicate} возвращает @code{nil}.  Любые @var{args} передаются
в @var{predicate}.
@end defun

@defun ewoc-collect ewoc predicate &rest args
Вызывается @var{predicate} для каждого элемента данных в @var{ewoc} и возвращается
список тех элементов, для которых @var{predicate} возвращает не-@code{nil}.  Элементы
в списке упорядочены как в буфере.  Любые @var{args} передаются в @var{predicate}.
@end defun

@defun ewoc-map map-function ewoc &rest args
Вызывается @var{map-function} для каждого элемента данных в @var{ewoc} и обновляются
те узлы, для которых @var{map-function} возвращает не-@code{nil}.  Любые @var{args}
передаются в @var{map-function}.
@end defun

@node Abstract Display Example
@subsection Пример Абстрактного Отображения

  Вот простой пример использования функций пакета ewoc для реализации отображения
@dfn{компонентов цвета}, области в буфере, которая представляет собой вектор из трех
целых чисел (который сам представляет 24-битное значение RGB) различными способами.

@example
(setq colorcomp-ewoc nil
      colorcomp-data nil
      colorcomp-mode-map nil
      colorcomp-labels ["Red" "Green" "Blue"])

(defun colorcomp-pp (data)
  (if data
      (let ((comp (aref colorcomp-data data)))
        (insert (aref colorcomp-labels data) "\t: #x"
                (format "%02X" comp) " "
                (make-string (ash comp -2) ?#) "\n"))
    (let ((cstr (format "#%02X%02X%02X"
                        (aref colorcomp-data 0)
                        (aref colorcomp-data 1)
                        (aref colorcomp-data 2)))
          (samp " (sample text) "))
      (insert "Color\t: "
              (propertize samp 'face
                          `(foreground-color . ,cstr))
              (propertize samp 'face
                          `(background-color . ,cstr))
              "\n"))))

(defun colorcomp (color)
  "Разрешить возиться с ЦВЕТОМ в новом буфере.
Буфер находится в режиме «Компоненты цвета»."
  (interactive "sColor (name or #RGB or #RRGGBB): ")
  (when (string= "" color)
    (setq color "green"))
  (unless (color-values color)
    (error "No such color: %S" color))
  (switch-to-buffer
   (generate-new-buffer (format "originally: %s" color)))
  (kill-all-local-variables)
  (setq major-mode 'colorcomp-mode
        mode-name "Color Components")
  (use-local-map colorcomp-mode-map)
  (erase-buffer)
  (buffer-disable-undo)
  (let ((data (apply 'vector (mapcar (lambda (n) (ash n -8))
                                     (color-values color))))
        (ewoc (ewoc-create 'colorcomp-pp
                           "\nColor Components\n\n"
                           (substitute-command-keys
                            "\n\\@{colorcomp-mode-map@}"))))
    (set (make-local-variable 'colorcomp-data) data)
    (set (make-local-variable 'colorcomp-ewoc) ewoc)
    (ewoc-enter-last ewoc 0)
    (ewoc-enter-last ewoc 1)
    (ewoc-enter-last ewoc 2)
    (ewoc-enter-last ewoc nil)))
@end example

@cindex controller part, model/view/controller
  Пример может быть расширен до виджета выбора цвета (другими словами, ``controller''
часть парадигмы дизайна ``model--view--controller''), определяя команды для изменения
@code{colorcomp-data} и завершения процесса выбора, а также ключевую карту, чтобы
удобно связать все это вместе.

@smallexample
(defun colorcomp-mod (index limit delta)
  (let ((cur (aref colorcomp-data index)))
    (unless (= limit cur)
      (aset colorcomp-data index (+ cur delta)))
    (ewoc-invalidate
     colorcomp-ewoc
     (ewoc-nth colorcomp-ewoc index)
     (ewoc-nth colorcomp-ewoc -1))))

(defun colorcomp-R-more () (interactive) (colorcomp-mod 0 255 1))
(defun colorcomp-G-more () (interactive) (colorcomp-mod 1 255 1))
(defun colorcomp-B-more () (interactive) (colorcomp-mod 2 255 1))
(defun colorcomp-R-less () (interactive) (colorcomp-mod 0 0 -1))
(defun colorcomp-G-less () (interactive) (colorcomp-mod 1 0 -1))
(defun colorcomp-B-less () (interactive) (colorcomp-mod 2 0 -1))

(defun colorcomp-copy-as-kill-and-exit ()
  "Скопировать компоненты цвета в список уничтожения и уничтожить.
Строка имеет формат #RRGGBB (хеш, за которым следуют шесть шестнадцатеричных цифр)."
  (interactive)
  (kill-new (format "#%02X%02X%02X"
                    (aref colorcomp-data 0)
                    (aref colorcomp-data 1)
                    (aref colorcomp-data 2)))
  (kill-buffer nil))

(setq colorcomp-mode-map
      (let ((m (make-sparse-keymap)))
        (suppress-keymap m)
        (define-key m "i" 'colorcomp-R-less)
        (define-key m "o" 'colorcomp-R-more)
        (define-key m "k" 'colorcomp-G-less)
        (define-key m "l" 'colorcomp-G-more)
        (define-key m "," 'colorcomp-B-less)
        (define-key m "." 'colorcomp-B-more)
        (define-key m " " 'colorcomp-copy-as-kill-and-exit)
        m))
@end smallexample

Обратить внимание, что никогда не изменяются данные в каждом узле, что фиксируется
при создании ewoc как @code{nil} или как индекс в векторе @code{colorcomp-data},
фактических компонентах цвета.

@node Blinking
@section Мигающие Круглые Скобки
@cindex parenthesis matching
@cindex blinking parentheses
@cindex balancing parentheses

  В этом разделе описывается механизм, с помощью которого Emacs показывает
соответствующую открытую скобку, когда пользователь вставляет закрывающую скобку.

@defvar blink-paren-function
Значением этой переменной должна быть функция (без аргументов), вызываемая всякий раз,
когда вставляется символ с синтаксисом закрывающих скобок.  Значение
@code{blink-paren-function} может быть @code{nil}, и в этом случае ничего не делается.
@end defvar

@defopt blink-matching-paren
Если эта переменная - @code{nil}, то @code{blink-matching-open} ничего не делает.
@end defopt

@defopt blink-matching-paren-distance
Переменная определяет максимальное расстояние для поиска подходящей круглой скобки,
прежде чем отказаться от поиска.
@end defopt

@defopt blink-matching-delay
Переменная определяет количество секунд, в течение которых следует указывать
соответствующую круглую скобку.  Доля секунды часто дает хорошие результаты, но по
умолчанию установлено значение 1, которое работает во всех системах.
@end defopt

@deffn Command blink-matching-open
Функция является значением по умолчанию @code{blink-paren-function}.  Предполагается,
что точка следует за символом с синтаксисом закрывающих скобок и мгновенно применяет
соответствующий эффект к соответствующему открывающему символу.  Если этого символа
еще нет на экране, отображается контекст символа в эхо-области.  Чтобы избежать
длительных задержек, эта функция не ищет дальше, чем символы
@code{blink-matching-paren-distance}.

Вот пример явного вызова этой функции.

@smallexample
@group
(defun interactive-blink-matching-open ()
  "Указать на мгновение начало заключенного в скобки sexp перед точкой."
  (interactive)
@end group
@group
  (let ((blink-matching-paren-distance
         (buffer-size))
        (blink-matching-paren t))
    (blink-matching-open)))
@end group
@end smallexample
@end deffn

@node Character Display
@section Отображение Символов

  В этом разделе описывается, как на самом деле символы отображаются в Emacs.  Обычно
символ отображается как @dfn{глиф} (графический символ, занимающий одну позицию
символа на экране), внешний вид которого соответствует самому символу.  Например,
символ @samp{a} (код символа 97) отображается как @samp{a}.  Однако некоторые символы
отображаются особым образом.  Например, символ перевода страницы (код символа 12)
обычно отображается как последовательность из двух глифов, @samp{^L}, а символ новой
строки (код символа 10) запускает новую строку экрана.

  Можно изменить способ отображения каждого символа, определив
@dfn{таблицу отображения}, которая отображает код каждого символа в последовательность
глифов.  @xref{Display Tables}.

@menu
* Usual Display::       Обычные соглашения для отображения символов.
* Display Tables::      Из чего состоит таблица отображения.
* Active Display Table::  Как Emacs выбирает отображаемую таблицу для использования.
* Glyphs::              Как определить глиф и что это означает.
* Glyphless Chars::     Как нарисованы символы без символов.
@end menu

@node Usual Display
@subsection Обычные Условные Обозначения при Отображении

  Вот соглашения для отображения кода каждого символа (при отсутствии таблицы
отображения, которая может переопределить эти
@iftex
условности).
@end iftex
@ifnottex
условности; @pxref{Display Tables}).
@end ifnottex

@cindex печатные символы ASCII
@itemize @bullet
@item
@dfn{Печатные @acronym{ASCII} символы}, коды символов с 32 по 126 (состоящие из цифр,
английских букв и символов, таких как @samp{#}) отображаются буквально.

@item
Символ табуляции (код символа 9) отображается как пробел, растягивающийся до
следующего столбца табуляции.  @xref{Text Display,,, emacs, The GNU Emacs Manual}.
Переменная @code{tab-width} контролирует количество пробелов на позицию табуляции
(смотреть ниже).

@item
Символ новой строки (код символа 10) имеет особый эффект: завершает предыдущую строку
и начинает новую строку.

@cindex ASCII управляющие символы
@item
Непечатаемые управляющие символы @dfn{@acronym{ASCII}} --- коды символов от 0 до 31,
а также символ @key{DEL} (код символа 127) --- отображаются одним из двух способов в
соответствии с переменной @code{ctl-arrow}.  Если эта переменная - не-@code{nil} (по
умолчанию), эти символы отображаются как последовательности двух глифов, где первый
глиф - @samp{^} (таблица отображения может указывать глиф для использования вместо
@samp{^}); например, символ @key{DEL} отображается как @samp{^?}.

Если @code{ctl-arrow} равно @code{nil}, эти символы отображаются как восьмеричные
escape-символы (смотреть ниже).

Это правило также применяется к возврату каретки (код символа 13), если этот символ
появляется в буфере.  Но возврат каретки обычно не появляется в тексте буфера;
удаляются как часть преобразования конца строки (@pxref{Coding System Basics}).

@cindex восьмеричные escap последовательности
@item
@dfn{Необработанные байты} - это символы не-@acronym{ASCII} с кодами от 128 до 255
(@pxref{Text Representations}).  Эти символы отображаются как
@dfn{восьмеричные escape последовательности}: последовательности из четырех глифов,
где первый глиф - это код @acronym{ASCII} для @samp{\}, а остальные - это цифровые
символы, представляющие код символа в восьмеричном формате. (В таблице отображения
можно указать глиф, который будет использоваться вместо @samp{\}.)

@item
Каждый символ не-@acronym{ASCII} с кодом выше 255 отображается буквально, если
терминал его поддерживает.  Если терминал его не поддерживает, символ называется
@dfn{glyphless} и обычно отображается с помощью глифа-заполнителя.  Например, если
графический терминал не имеет шрифта для символа, Emacs обычно отображает поле,
содержащее код символа в шестнадцатеричном формате.  @xref{Glyphless Chars}.
@end itemize

  Вышеупомянутые соглашения об отображении применяются даже при наличии таблицы
отображения для любого символа, запись которого в активной таблице отображения -
@code{nil}.  Таким образом, когда настраивается таблица отображения, нужно только
указать символы, для которых требуется особое поведение.

  Следующие переменные влияют на то, как определенные символы отображаются на экране.
Поскольку они изменяют количество столбцов, которые занимают символы, они также влияют
на функции отступа.  Они также влияют на то, как отображается строка режима; если
требуется принудительно повторно отобразить строку режима с новыми значениями,
вызвать функцию @code{force-mode-line-update} (@pxref{Mode Line Format}).

@defopt ctl-arrow
@cindex отображение управляющих символов
Локальная в буфере переменная определяет, как отображаются управляющие символы.  Если
установленна в не-@code{nil}, символы отображаются в виде символа вставки, за которым
следует символ: @samp{^A}.  Если установленна в @code{nil}, отображаются как
восьмеричные escape-символы: обратная косая черта, за которой следуют три восьмеричные
цифры, как в @samp{\001}.
@end defopt

@defopt tab-width
Значение этой локальной переменной буфера - это интервал между позициями табуляции,
используемый для отображения символов табуляции в буферах Emacs.  Значение указывается
в столбцах, по умолчанию - 8.  Обратить внимание, что эта функция полностью не зависит
от настраиваемых пользователем позиций табуляции, используемых командой
@code{tab-to-tab-stop}.  @xref{Indent Tabs}.
@end defopt

@node Display Tables
@subsection Таблицы Отображения

@cindex display table
  Таблица отображения - это специальная таблица символов (@pxref{Char-Tables}) с
@code{display-table} в качестве подтипа, которая используется для переопределения
обычных соглашений по отображению символов.  В этом разделе описывается, как
создавать, проверять и назначать элементы объекту таблицы отображения.

@defun make-display-table
Создает и возвращает таблицу отображения.  Таблица изначально имеет @code{nil} во
всех элементах.
@end defun

  Обычные элементы таблицы отображения индексируются кодами символов; элемент с
индексом @var{c} говорит, как отобразить код символа @var{c}.  Значение должно быть
@code{nil} (что означает отображение символа @var{c} в соответствии с обычными
соглашениями об отображении; @pxref{Usual Display}) или вектор кодов глифов (что
означает отображение символа @var{c} как этих глифов; @pxref{Glyphs}).

  @strong{Предупреждение:} если используется таблица отображения для изменения
отображения символов новой строки, весь буфер будет отображаться как одна длинная
строка.

  В таблице отображения также есть шесть @dfn{дополнительных слотов}, которые служат
для специальных целей.  Вот таблица их значений; @code{nil} в любом слоте означает
использование значения по умолчанию для этого слота, как указано ниже.

@table @asis
@item 0
Глиф конца усеченной строки экрана (по умолчанию @samp{$}).  @xref{Glyphs}.
На графических терминалах Emacs по умолчанию использует стрелки на краях для
обозначения усечения, поэтому таблица отображения не имеет никакого эффекта, если
не отключены стрелки.
(@pxref{Fringes,, Window Fringes, emacs, the GNU Emacs Manual}).

@item 1
Символ конца продолжающейся строки (по умолчанию @samp{\}).  На графических
терминалах Emacs по умолчанию использует изогнутые стрелки на краях для обозначения
продолжения, поэтому таблица отображения не имеет никакого эффекта, если не
отключены эти стрелки.

@item 2
Глиф для обозначения символа, отображаемого как восьмеричный код символа (по
умолчанию @samp{\}).

@item 3
Глиф для обозначения управляющего символа (по умолчанию @samp{^}).

@item 4
Вектор глифов для индикации наличия невидимых линий (по умолчанию @samp{...}).
@xref{Selective Display}.

@item 5
Глиф, используемый для рисования границы между соседними окнами (по умолчанию
@samp{|}).  @xref{Splitting Windows}.  В настоящее время это действует только на
текстовые терминалы; на графических терминалах, если вертикальные полосы прокрутки
поддерживаются и используются, полоса прокрутки разделяет два окна, а если нет
вертикальных полос прокрутки и разделителей (@pxref{Window Dividers}), Emacs
использует тонкую линию для обозначения границы.
@end table

  Например, вот как создать таблицу отображения, которая имитирует эффект установки
@code{ctl-arrow} в значение не-@code{nil} (@pxref{Glyphs}, для функции
@code{make-glyph-code}):

@example
(setq disptab (make-display-table))
(dotimes (i 32)
  (or (= i ?\t)
      (= i ?\n)
      (aset disptab i
            (vector (make-glyph-code ?^ 'escape-glyph)
                    (make-glyph-code (+ i 64) 'escape-glyph)))))
(aset disptab 127
      (vector (make-glyph-code ?^ 'escape-glyph)
              (make-glyph-code ?? 'escape-glyph)))))
@end example

@defun display-table-slot display-table slot
Функция возвращает значение дополнительного слота @var{slot} для @var{display-table}.
Аргумент @var{slot} может быть числом от 0 до 5 включительно или именем слота
(символом).  Допустимые символы: @code{truncation}, @code{wrap}, @code{escape},
@code{control}, @code{selective-display} и @code{vertical-border}.
@end defun

@defun set-display-table-slot display-table slot value
Функция сохраняет @var{value} в дополнительном слоте @var{slot} объекта
@var{display-table}.  Аргумент @var{slot} может быть числом от 0 до 5 включительно
или именем слота (символом).  Допустимые символы: @code{truncation}, @code{wrap},
@code{escape}, @code{control}, @code{selective-display} и @code{vertical-border}.
@end defun

@defun describe-display-table display-table
Функция отображает описание таблицы отображения @var{display-table} в буфере справки.
@end defun

@deffn Command describe-current-display-table
Команда отображает описание текущей отображаемой таблицы в буфере справки.
@end deffn

@node Active Display Table
@subsection Таблица Активного Отображения
@cindex active display table

  Каждое окно может указывать таблицу отображения, как и каждый буфер.  Таблица
отображения окна, если таковая имеется, имеет приоритет над таблицей отображения
буфера.  Если ничего не существует, Emacs пытается использовать стандартную таблицу
отображения; если это @code{nil}, Emacs использует обычные соглашения об отображении
символов (@pxref{Usual Display}).

  Обратить внимание, что таблицы отображения влияют на способ отображения строки
режима, поэтому, если требуется принудительно повторно отобразить строку режима с
помощью новой таблицы отображения, вызвать @code{force-mode-line-update}
(@pxref{Mode Line Format}).

@defun window-display-table &optional window
Функция возвращает таблицу отображения @var{window} или @code{nil}, если ее нет.
По умолчанию для @var{window} выступает выбрано окно.
@end defun

@defun set-window-display-table window table
Функция устанавливает для таблицы отображения @var{window} значение @var{table}.
Аргумент @var{table} должен быть либо таблицей отображения, либо @code{nil}.
@end defun

@defvar buffer-display-table
Переменная автоматически является локальной для всех буферов; её значение определяет
таблицу отображения буфера.  Если это @code{nil}, таблица отображения буфера
отсутствует.
@end defvar

@defvar standard-display-table
Значением этой переменной является стандартная таблица отображения, которая
используется, когда Emacs отображает буфер в окне, в котором не определены ни таблица
отображения окна, ни таблица отображения буфера, или когда Emacs выводит текст в
стандартный поток вывода или потоки ошибок.  Хотя её значение по умолчанию обычно
@code{nil}, в интерактивном сеансе, если терминал не может отображать изогнутые
котировки, его значение по умолчанию сопоставляет изогнутые кавычки с приближением
ASCII.  @xref{Text Quoting Style}.
@end defvar

Библиотека @file{disp-table} определяет несколько функций для изменения стандартной
таблицы отображения.

@node Glyphs
@subsection Глифы
@cindex glyph

@cindex glyph code
  @dfn{Глиф} - это графический символ, который занимает позицию одного символа на
экране.  Каждый глиф представлен в Lisp как @dfn{код глифа}, который определяет
символ и, необязательно, вид отображения, чтобы отобразить его в (@pxref{Faces}).
В основном коды глифов используются в качестве записей в таблицах отображения
(@pxref{Display Tables}).  Следующие функции используются для управления кодами
глифов:

@defun make-glyph-code char &optional face
Функция возвращает код глифа, представляющий символ @var{char} с видом @var{face}.
Если @var{face} опущено или @code{nil}, глиф использует начертание по умолчанию; в
этом случае код глифа является целым числом.  Если @var{face} равно не-@code{nil},
код глифа не обязательно является целочисленным объектом.
@end defun

@defun glyph-char glyph
Функция возвращает символ кода глифа @var{glyph}.
@end defun

@defun glyph-face glyph
Функция возвращает вид кода глифа @var{glyph} или @code{nil}, если @var{glyph}
использует вид по умолчанию.
@end defun

@ifnottex
  Можно настроить @dfn{таблицу глифов}, чтобы изменить способ отображения кодов
глифов на текстовых терминалах.  Эта функция частично устарела; использовать
@code{glyphless-char-display} вместо (@pxref{Glyphless Chars}).

@defvar glyph-table
Значение этой переменной, если не-@code{nil}, является текущей таблицей глифов.  Это
действует только на символьные терминалы; на графических дисплеях все глифы
отображаются буквально.  Таблица глифов должна быть вектором, элемент @var{g}
которого указывает, как отображать код глифа @var{g}, где @var{g} - это код глифа
для глифа, вид отображения которого не указан.  Каждый элемент должен быть одним
из следующих:

@table @asis
@item @code{nil}
Отобразить этот глиф буквально.

@item a string
Отобразить этот глиф, отправив указанную строку на терминал.

@item a glyph code
Вместо этого отобразить указанный код глифа.
@end table

Любой целочисленный код глифа, больший или равный длине таблицы глифов, отображается
буквально.
@end defvar
@end ifnottex

@node Glyphless Chars
@subsection Отображение Символов без Символов
@cindex glyphless characters

  @dfn{Символы без символов} - это символы, которые отображаются особым образом,
например, как поле, содержащее шестнадцатеричный код, вместо того, чтобы отображаться
буквально.  К ним относятся символы, которые явно определены как не содержащие глифов,
а также символы, для которых нет доступного шрифта (на графическом дисплее), и
символы, которые не могут быть закодированы системой кодирования терминала (на
текстовом терминале).

@defvar glyphless-char-display
Значением этой переменной является таблица символов, которая определяет символы без
глифов и способ их отображения.  Каждая запись должна быть одним из следующих
способов отображения:

@table @asis
@item @code{nil}
Отобразить символ обычным способом.

@item @code{zero-width}
Не отображать символ.

@item @code{thin-space}
Отобразить тонкое пространство шириной 1 пиксель на графических дисплеях или шириной 1
символ на текстовых терминалах.

@item @code{empty-box}
Display an empty box.

@item @code{hex-code}
Отобразить поле, содержащее кодовую точку Unicode символа в шестнадцатеричной системе
счисления.

@item an @acronym{ASCII} string
Отобразить поле, содержащее эту строку.  Строка должна содержать не более 6
символов @acronym{ASCII}.

@item a cons cell @code{(@var{graphical} . @var{text})}
Отображение с @var{graphical} на графических дисплеях и с @var{text} на текстовых
терминалах.  Оба @var{graphical} и @var{text} должны быть одним из методов
отображения, описанных выше.
@end table

@noindent
Методы отображения строки @code{thin-space}, @code{empty-box}, @code{hex-code} и
@acronym{ASCII} рисуются видами @code{glyphless-char}.  На текстовых терминалах поле
эмулируется квадратными скобками, @samp{[]}.

Таблица символов имеет один дополнительный слот, который определяет, как отображать
любой символ, который не может быть отображен ни одним доступным шрифтом или не может
быть закодирован системой кодирования терминала.  Её значение должно быть одним из
указанных выше методов отображения, кроме @code{zero-width} или cons-ячейки.

Если у символа есть запись не-@code{nil} в активной таблице отображения, таблица
отображения вступает в силу; в этом случае Emacs вообще не обращается к
@code{glyphless-char-display}.
@end defvar

@defopt glyphless-char-display-control
Пользовательская опция предоставляет удобный способ установить
@code{glyphless-char-display} для групп похожих символов.  Не устанавливать её
значение непосредственно из кода Lisp; значение вступает в силу только через
специальную функцию @code{:set} (@pxref{Variable Definitions}), которая обновляет
@code{glyphless-char-display}.

Её значение должно быть списком элементов @code{(@var{group} . @var{method})}, где
@var{group} - символ, определяющий группу символов, а @var{method} - символ,
определяющий, как их отображать.

@var{group} должно быть одним из следующих:

@table @code
@item c0-control
@acronym{ASCII} управляющие символы от @code{U+0000} до @code{U+001F}, исключая
символы новой строки и табуляции (обычно отображаются как escape-последовательности,
такие как @samp{^A};
@pxref{Text Display,, How Text Is Displayed, emacs, The GNU Emacs Manual}).

@item c1-control
Не-@acronym{ASCII}, непечатаемые символы от @code{U+0080} до @code{U+009F} (обычно
отображаются как восьмеричные escape-последовательности, так как @samp{\230}).

@item format-control
Символы общей категории Unicode [Cf], например U+200E @sc{left-to-right mark}, но
исключая символы с графическими изображениями, например U+00AD @sc{soft hyphen}.

@item no-font
Символы, для которых нет подходящего шрифта или которые не могут быть закодированы
системой кодирования терминала.
@end table

@c FIXME: это также может быть 'acronym', но в настоящее время
@c реализовано не полностью; это применяется только к группе
@c управления форматом и работает только в том случае, если
@c аббревиатура находится в 'char-acronym-table'.
Символ @var{method} должен быть одним из символов @code{zero-width},
@code{thin-space}, @code{empty-box} или @code{hex-code}.  Имеют то же значение, что
и в @code{glyphless-char-display} смотреть выше.
@end defopt

@node Beeping
@section Писк
@cindex bell

  В этом разделе описывается, как заставить Emacs звонить в звонок (или мигать
экраном), чтобы привлечь внимание пользователя.  Быть осторожным в отношении того,
как часто это делается; частые звонки могут вызывать раздражение.  Также быть
осторожным, чтобы не использовать просто звуковой сигнал, когда сигнал об ошибке
более уместен.  (@pxref{Errors}).

@defun ding &optional do-not-terminate
@cindex keyboard macro termination
Функция подает звуковой сигнал или мигает экраном (смотреть @code{visible-bell} ниже).
Также завершает выполнение любого макроса клавиатуры, если только
@var{do-not-terminate} не не-@code{nil}.
@end defun

@defun beep &optional do-not-terminate
Синоним @code{ding}.
@end defun

@defopt visible-bell
Переменная определяет, должен ли Emacs мигать на экране, представляя колокольчик.
Не-@code{nil} означает да, @code{nil} означает нет.  Это эффективно на графических
дисплеях и на текстовых терминалах при условии, что запись Termcap терминала
определяет возможность видимого звонка (@samp{vb}).
@end defopt

@defopt ring-bell-function
Если не-@code{nil}, указывается, как Emacs должен звонить в колокол.  Значение должно
быть функцией без аргументов.  Если это не-@code{nil}, имеется приоритет перед
переменной @code{visible-bell}.
@end defopt

@node Window Systems
@section Оконные Системы

  Emacs работает с несколькими оконными системами, в первую очередь с X Window System.
И Emacs, и X используют термин ``окно'', но по-разному.  Что касается X, фрейм Emacs -
это одно окно; отдельные окна Emacs вообще не известны X.

@defvar window-system
Локальная для терминала переменная сообщает программам Lisp, какую оконную систему
Emacs использует для отображения фрейма.  Возможные значения:

@table @code
@item x
@cindex X Окрнная Система
Emacs отображает фрейм, используя X.
@item w32
Emacs отображает фрейм, используя собственный графический интерфейс MS-Windows.
@item ns
Emacs отображает фрейм с помощью интерфейса Nextstep (используется в GNUstep и macOS).
@item pc
Emacs отображает фрейм, используя прямую запись на экране MS-DOS.
@item nil
Emacs отображает фрейм на символьном терминале.
@end table
@end defvar

@defvar initial-window-system
Переменная содержит значение @code{window-system}, используемое для первого фрейма,
созданного Emacs во время запуска.  (Когда Emacs вызывается как демон, он не создает
никаких начальных фреймов, поэтому @code{initial-window-system} - это @code{nil},
за исключением MS-Windows, где он по-прежнему @code{w32}.
@xref{Initial Options, daemon,, emacs, The GNU Emacs Manual}.)
@end defvar

@defun window-system &optional frame
Функция возвращает символ, имя которого сообщает, какая оконная система используется
для отображения @var{frame} (по умолчанию используется текущий выбранный фрейм).
Список возможных символов, которые возвращаются, тот же, что задокументирован для
переменной @code{window-system} выше.
@end defun

  @emph{Не} использовать @code{window-system} и @code{initial-window-system} в
качестве предикатов или переменных логического флага, если требуется написать код,
который по-разному работает на текстовых терминалах и графических дисплеях.  Это
потому, что @code{window-system} не является хорошим индикатором возможностей Emacs
для данного типа отображения.  Вместо этого использовать @code{display-graphic-p} или
любой другой предикат @code{display-*-p}, описанный в @ref{Display Feature Testing}.

@node Tooltips
@section Всплывающие Подсказки
@cindex tooltips
@dfn{Всплывающие подсказки} - это специальные фреймы (@pxref{Frames}), которые
используются для отображения полезных подсказок (также известных как@: ``tips''),
связанных с текущим положением указателя мыши.  Emacs использует всплывающие подсказки
для отображения строк справки об активных частях текста (@pxref{Special Properties})
и о различных элементах пользовательского интерфейса, таких как пункты меню
(@pxref{Extended Menu Items}) и кнопки панели инструментов (@pxref{Tool Bar}).

@defun tooltip-mode
Режим всплывающих подсказок - это второстепенный режим, который позволяет отображать
всплывающие подсказки.  Отключение этого режима вызывает отображение всплывающих
подсказок в эхо-области.  Во фреймах текстового режима (он же@: ``TTY'') всплывающие
подсказки всегда отображаются в эхо-области.
@end defun

@vindex x-gtk-use-system-tooltips
Когда Emacs построен с поддержкой GTK+, по умолчанию отображает всплывающие подсказки
с использованием функций GTK+, а внешний вид всплывающих подсказок затем управляется
настройками GTK+.  Всплывающие подсказки GTK+ можно отключить, изменив значение
переменной @code{x-gtk-use-system-tooltips} на @code{nil}.  Остальная часть этого
подраздела описывает, как управлять всплывающими подсказками, не относящимися к GTK+,
которые предоставляются самим Emacs.

@cindex tooltip frames
Всплывающие подсказки отображаются в специальных фреймах, называемых фреймами
всплывающих подсказок, которые имеют собственные параметры фрейма
(@pxref{Frame Parameters}).  В отличие от других фреймов, параметры по умолчанию для
фреймов всплывающих подсказок хранятся в специальной переменной.

@defopt tooltip-frame-parameters
Настраиваемый параметр содержит параметры фрейма по умолчанию, используемые для
отображения всплывающих подсказок.  Любые параметры шрифта и цвета игнорируются, и
вместо них используются соответствующие атрибуты вида @code{tooltip}.  Если включены
параметры @code{left} или @code{top}, они используются как абсолютные координаты
относительно фрейма, в которых должна отображаться всплывающая подсказка.  (Положение
всплывающей подсказки относительно мыши можно настроить с помощью переменных,
описанных в @ref{Tooltips,,, emacs, The GNU Emacs Manual}.)  Обратить внимание, что
параметры @code{left} и @code{top}, если присутствуют, переопределяют значения
смещений относительно мыши.
@end defopt

@vindex tooltip@r{ вид отображения}
@code{tooltip} вид определяет внешний вид текста, отображаемого во всплывающих
подсказках.  Как правило, следует использовать шрифт с переменным шагом, размер
которого предпочтительно меньше, чем шрифт фрейма по умолчанию.

@findex tooltip-help-tips
@defvar tooltip-functions
Этот ненормальный перехватчик представляет собой список функций, которые нужно
вызывать, когда Emacs должен показать всплывающую подсказку.  Каждая функция
вызывается с одним аргументом @var{event}, который является копией последнего события
движения мыши.  Если функция в этом списке действительно отображает всплывающую
подсказку, она должна вернуть не-@code{nil}, и тогда остальные функции не будут
вызываться.  Значение по умолчанию этой переменной - одна функция
@code{tooltip-help-tips}.
@end defvar

Если пишется собственная функция, которая будет помещена в список
@code{tooltip-functions}, может потребоваться знать буфер события мыши, вызвавшего
отображение всплывающей подсказки.  Эту информацию предоставляет следующая функция.

@defun tooltip-event-buffer event
Функция возвращает буфер, в котором произошло @var{event}.  Вызвать его с аргументом
функции из @code{tooltip-functions}, чтобы получить буфер, текст которого вызвал
всплывающую подсказку.  Обратить внимание, что событие может произойти не в буфере
(например, на панели инструментов), и в этом случае эта функция вернет @code{nil}.
@end defun

Другие аспекты отображения всплывающей подсказки контролируются несколькими
настраиваемыми параметрами.; смотреть @ref{Tooltips,,, emacs, The GNU Emacs Manual}.

@node Bidirectional Display
@section Двунаправленное Отображение
@cindex bidirectional display
@cindex right-to-left text

  Emacs может отображать текст, написанный сценариями, такими как арабский, фарси и
иврит, чей естественный порядок для горизонтального отображения текста выполняется
справа налево.  Кроме того, сегменты латинского алфавита и цифры, встроенные в текст
с письмом справа налево, отображаются слева направо, а сегменты сценария с письмом
справа налево, встроенные в текст с письмом слева направо (например, текст на
арабском языке или иврите в комментариях или строки в исходном файле программы)
соответственно отображаются справа налево.  Называются такие сочетания текста с
написанием слева направо и справа налево @dfn{двунаправленный текст}.  В этом разделе
описаны возможности и параметры для редактирования и отображения двунаправленного
текста.

@cindex logical order
@cindex reading order
@cindex visual order
@cindex unicode bidirectional algorithm
@cindex UBA
@cindex bidirectional reordering
@cindex reordering, of bidirectional text
  Текст хранится в буферах и строках Emacs в @dfn{логичном} порядке
(или @dfn{чтения}), то есть в порядке, в котором человек прочитал бы каждый символ.
В тексте справа налево и в двунаправленном тексте порядок, в котором символы
отображаются на экране (называемом @dfn{визуальный порядок}) - это не то же самое,
что логический порядок; положение символов на экране не увеличивается монотонно с
положением строки или буфера.  Выполняя это @dfn{двунаправленное переупорядочивание},
Emacs следует двунаправленному алгоритму Unicode (он же@: @acronym{UBA}), который
описан в приложении № 9 к стандарту Unicode
(@url{http://www.unicode.org/reports/tr9/}).  Emacs обеспечивает реализацию
@acronym{UBA} класса «Полная двунаправленность» в соответствии с требованиями
стандарта Unicode v9.0.  Обратить внимание, однако, что способ, которым Emacs
отображает строки продолжения, когда направление текста противоположно основному
направлению абзаца, отклоняется от UBA, который требует выполнения переноса строк
перед изменением порядка текста для отображения.

@defvar bidi-display-reordering
Если значение этой локальной переменной буфера - не-@code{nil} (по умолчанию), Emacs
выполняет двунаправленное переупорядочение для отображения.  Переупорядочение влияет
на текст буфера, а также на отображаемые строки и строки наложения из текста и
свойств наложения в буфере (@pxref{Overlay Properties} и @pxref{Display Property}).
Если значение равно @code{nil}, Emacs не выполняет двунаправленное переупорядочение
в буфере.

Значение по умолчанию @code{bidi-display-reordering} управляет переупорядочиванием
строк, которые напрямую не поставляются буфером, включая текст, отображаемый в
строках режима (@pxref{Mode Line Format}) и строках заголовков (@pxref{Header Lines}).
@end defvar

@cindex unibyte buffers, and bidi reordering
  Emacs никогда не изменяет порядок текста в однобайтовом буфере, даже если
@code{bidi-display-reordering} равно не-@code{nil} в буфере.  Это связано с тем, что
однобайтовые буферы содержат необработанные байты, а не символы, и, следовательно,
не имеют свойств направленности, необходимых для переупорядочения.  Следовательно,
чтобы проверить, будет ли текст в буфере переупорядочен для отображения, недостаточно
проверить значение только @code{bidi-display-reordering}.  Правильный тест такой:

@example
 (if (and enable-multibyte-characters
          bidi-display-reordering)
     ;; Буфер переупорядочивается для отображения
   )
@end example

  Однако строки отображения и наложения unibyte @emph{находят} переупорядочивание,
если их родительский буфер переупорядочивается.  Это потому, что строки
plain-@sc{ascii} хранятся в Emacs как однобайтовые строки.  Если однобайтная
отображаемая или строка с наложением включает символы не-@sc{ascii}, предполагается,
что эти символы имеют направление слева направо.

@cindex display properties, and bidi reordering of text
  Text covered by @code{display} text properties, by overlays with
@code{display} properties whose value is a string, and by any other
properties that replace buffer text, is treated as a single unit when
it is reordered for display.  That is, the entire chunk of text
covered by these properties is reordered together.  Moreover, the
bidirectional properties of the characters in such a chunk of text are
ignored, and Emacs reorders them as if they were replaced with a
single character @code{U+FFFC}, known as the @dfn{Object Replacement
Character}.  This means that placing a display property over a portion
of text may change the way that the surrounding text is reordered for
display.  To prevent this unexpected effect, always place such
properties on text whose directionality is identical with text that
surrounds it.

@cindex base direction of a paragraph
  Each paragraph of bidirectional text has a @dfn{base direction},
either right-to-left or left-to-right.  Left-to-right paragraphs are
displayed beginning at the left margin of the window, and are
truncated or continued when the text reaches the right margin.
Right-to-left paragraphs are displayed beginning at the right margin,
and are continued or truncated at the left margin.

@cindex paragraph-start, and bidirectional display
@cindex paragraph-separate, and bidirectional display
  Where exactly paragraphs start and end, for the purpose of the Emacs
@acronym{UBA} implementation, is determined by the following two
buffer-local variables (note that @code{paragraph-start} and
@code{paragraph-separate} have no influence on this).  By default both
of these variables are @code{nil}, and paragraphs are bounded by empty
lines, i.e., lines that consist entirely of zero or more whitespace
characters followed by a newline.

@defvar bidi-paragraph-start-re
If не-@code{nil}, this variable's value should be a regular
expression matching a line that starts or separates two paragraphs.
The regular expression is always matched after a newline, so it is
best to anchor it, i.e., begin it with a @code{"^"}.
@end defvar

@defvar bidi-paragraph-separate-re
If не-@code{nil}, this variable's value should be a regular
expression matching a line separates two paragraphs.  The regular
expression is always matched after a newline, so it is best to anchor
it, i.e., begin it with a @code{"^"}.
@end defvar

  If you modify any of these two variables, you should normally modify
both, to make sure they describe paragraphs consistently.  For
example, to have each new line start a new paragraph for
bidi-reordering purposes, set both variables to @code{"^"}.

  By default, Emacs determines the base direction of each paragraph by
looking at the text at its beginning.  The precise method of
determining the base direction is specified by the @acronym{UBA}; in a
nutshell, the first character in a paragraph that has an explicit
directionality determines the base direction of the paragraph.
However, sometimes a buffer may need to force a certain base direction
for its paragraphs.  For example, buffers containing program source
code should force all paragraphs to be displayed left-to-right.  You
can use following variable to do this:

@defopt bidi-paragraph-direction
If the value of this buffer-local variable is the symbol
@code{right-to-left} or @code{left-to-right}, all paragraphs in the
buffer are assumed to have that specified direction.  Any other value
is equivalent to @code{nil} (the default), which means to determine
the base direction of each paragraph from its contents.

@cindex @code{prog-mode}, and @code{bidi-paragraph-direction}
Modes for program source code should set this to @code{left-to-right}.
Prog mode does this by default, so modes derived from Prog mode do not
need to set this explicitly (@pxref{Basic Major Modes}).
@end defopt

@defun current-bidi-paragraph-direction &optional buffer
This function returns the paragraph direction at point in the named
@var{buffer}.  The returned value is a symbol, either
@code{left-to-right} or @code{right-to-left}.  If @var{buffer} is
omitted or @code{nil}, it defaults to the current buffer.  If the
buffer-local value of the variable @code{bidi-paragraph-direction} is
не-@code{nil}, the returned value will be identical to that value;
otherwise, the returned value reflects the paragraph direction
determined dynamically by Emacs.  For buffers whose value of
@code{bidi-display-reordering} is @code{nil} as well as unibyte
buffers, this function always returns @code{left-to-right}.
@end defun

@cindex visual-order cursor motion
  Sometimes there's a need to move point in strict visual order,
either to the left or to the right of its current screen position.
Emacs provides a primitive to do that.

@defun move-point-visually direction
This function moves point of the currently selected window to the
buffer position that appears immediately to the right or to the left
of point on the screen.  If @var{direction} is positive, point will
move one screen position to the right, otherwise it will move one
screen position to the left.  Note that, depending on the surrounding
bidirectional context, this could potentially move point many buffer
positions away.  If invoked at the end of a screen line, the function
moves point to the rightmost or leftmost screen position of the next
or previous screen line, as appropriate for the value of
@var{direction}.

The function returns the new buffer position as its value.
@end defun

@cindex layout on display, and bidirectional text
@cindex jumbled display of bidirectional text
@cindex concatenating bidirectional strings
  Bidirectional reordering can have surprising and unpleasant effects
when two strings with bidirectional content are juxtaposed in a
buffer, or otherwise programmatically concatenated into a string of
text.  A typical problematic case is when a buffer consists of
sequences of text fields separated by whitespace or punctuation
characters, like Buffer Menu mode or Rmail Summary Mode.  Because the
punctuation characters used as separators have @dfn{weak
directionality}, they take on the directionality of surrounding text.
As result, a numeric field that follows a field with bidirectional
content can be displayed @emph{to the left} of the preceding field,
messing up the expected layout.  There are several ways to avoid this
problem:

@itemize @minus
@item
Append the special character U+200E @sc{left-to-right mark}, or
@acronym{LRM}, to the end of each field that may have bidirectional
content, or prepend it to the beginning of the following field.  The
function @code{bidi-string-mark-left-to-right}, described below, comes
in handy for this purpose.  (In a right-to-left paragraph, use
U+200F @sc{right-to-left mark}, or @acronym{RLM}, instead.)  This
is one of the solutions recommended by the UBA.

@item
Include the tab character in the field separator.  The tab character
plays the role of @dfn{segment separator} in bidirectional reordering,
causing the text on either side to be reordered separately.

@cindex @code{space} display spec, and bidirectional text
@item
Separate fields with a @code{display} property or overlay with a
property value of the form @code{(space . PROPS)} (@pxref{Specified
Space}).  Emacs treats this display specification as a @dfn{paragraph
separator}, and reorders the text on either side separately.
@end itemize

@defun bidi-string-mark-left-to-right string
This function returns its argument @var{string}, possibly modified,
such that the result can be safely concatenated with another string,
or juxtaposed with another string in a buffer, without disrupting the
relative layout of this string and the next one on display.  If the
string returned by this function is displayed as part of a
left-to-right paragraph, it will always appear on display to the left
of the text that follows it.  The function works by examining the
characters of its argument, and if any of those characters could cause
reordering on display, the function appends the @acronym{LRM}
character to the string.  The appended @acronym{LRM} character is made
invisible by giving it an @code{invisible} text property of @code{t}
(@pxref{Invisible Text}).
@end defun

  The reordering algorithm uses the bidirectional properties of the
characters stored as their @code{bidi-class} property
(@pxref{Character Properties}).  Lisp programs can change these
properties by calling the @code{put-char-code-property} function.
However, doing this requires a thorough understanding of the
@acronym{UBA}, and is therefore not recommended.  Any changes to the
bidirectional properties of a character have global effect: they
affect all Emacs frames and windows.

  Similarly, the @code{mirroring} property is used to display the
appropriate mirrored character in the reordered text.  Lisp programs
can affect the mirrored display by changing this property.  Again, any
such changes affect all of Emacs display.

@cindex overriding bidirectional properties
@cindex directional overrides
@cindex LRO
@cindex RLO
  The bidirectional properties of characters can be overridden by
inserting into the text special directional control characters,
LEFT-TO-RIGHT OVERRIDE (@acronym{LRO}) and RIGHT-TO-LEFT OVERRIDE
(@acronym{RLO}).  Any characters between a @acronym{RLO} and the
following newline or POP DIRECTIONAL FORMATTING (@acronym{PDF})
control character, whichever comes first, will be displayed as if they
were strong right-to-left characters, i.e.@: they will be reversed on
display.  Similarly, any characters between @acronym{LRO} and
@acronym{PDF} or newline will display as if they were strong
left-to-right, and will @emph{not} be reversed even if they are strong
right-to-left characters.

@cindex phishing using directional overrides
@cindex malicious use of directional overrides
  These overrides are useful when you want to make some text
unaffected by the reordering algorithm, and instead directly control
the display order.  But they can also be used for malicious purposes,
known as @dfn{phishing}.  Specifically, a URL on a Web page or a link
in an email message can be manipulated to make its visual appearance
unrecognizable, or similar to some popular benign location, while the
real location, interpreted by a browser in the logical order, is very
different.

  Emacs provides a primitive that applications can use to detect
instances of text whose bidirectional properties were overridden so as
to make a left-to-right character display as if it were a
right-to-left character, or vise versa.

@defun bidi-find-overridden-directionality from to &optional object
This function looks at the text of the specified @var{object} between
positions @var{from} (inclusive) and @var{to} (exclusive), and returns
the first position where it finds a strong left-to-right character
whose directional properties were forced to display the character as
right-to-left, or for a strong right-to-left character that was forced
to display as left-to-right.  If it finds no such characters in the
specified region of text, it returns @code{nil}.

The optional argument @var{object} specifies which text to search, and
defaults to the current buffer.  If @var{object} is не-@code{nil}, it
can be some other buffer, or it can be a string or a window.  If it is
a string, the function searches that string.  If it is a window, the
function searches the buffer displayed in that window.  If a buffer
whose text you want to examine is displayed in some window, we
recommend to specify it by that window, rather than pass the buffer to
the function.  This is because telling the function about the window
allows it to correctly account for window-specific overlays, which
might change the result of the function if some text in the buffer is
covered by overlays.
@end defun

@cindex copying bidirectional text, preserve visual order
@cindex visual order, preserve when copying bidirectional text
  When text that includes mixed right-to-left and left-to-right
characters and bidirectional controls is copied into a different
location, it can change its visual appearance, and also can affect the
visual appearance of the surrounding text at destination.  This is
because reordering of bidirectional text specified by the
@acronym{UBA} has non-trivial context-dependent effects both on the
copied text and on the text at copy destination that will surround it.

  Sometimes, a Lisp program may need to preserve the exact visual
appearance of the copied text at destination, and of the text that
surrounds the copy.  Lisp programs can use the following function to
achieve that effect.

@defun buffer-substring-with-bidi-context start end &optional no-properties
This function works similar to @code{buffer-substring} (@pxref{Buffer
Contents}), but it prepends and appends to the copied text bidi
directional control characters necessary to preserve the visual
appearance of the text when it is inserted at another place.  Optional
argument @var{no-properties}, if не-@code{nil}, means remove the text
properties from the copy of the text.
@end defun
