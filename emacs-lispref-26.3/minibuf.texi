@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2019 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Minibuffers
@chapter Минибуферы
@cindex arguments, reading
@cindex complex arguments
@cindex minibuffer

  @dfn{Минибуфер} - это специальный буфер, который команды Emacs используют
для чтения аргументов, более сложных, чем аргумент с одним числовым
префиксом.  Эти аргументы включают имена файлов, имена буферов и имена
команд (как в @kbd{M-x}).  Минибуфер отображается в нижней строке кадра в
том же месте, что и эхо-область (@pxref{The Echo Area}), но только пока он
используется для чтения аргумента.

@menu
* Intro to Minibuffers::      Основная информация о минибуферах.
* Text from Minibuffer::      Как читать прямую текстовую строку.
* Object from Minibuffer::    Как читать объект или выражение Lisp.
* Minibuffer History::        Запись предыдущих входов минибуфера, чтобы
                              пользователь мог их повторно использовать.
* Initial Input::             Определение начального содержимого минибуфера.
* Completion::                Как вызвать и настроить завершение.
* Yes-or-No Queries::         Задать вопрос с простым ответом.
* Multiple Queries::          Задать сложные вопросы.
* Reading a Password::        Считывание пароля с терминала.
* Minibuffer Commands::       Команды, используемые как привязки ключей
                                в минибуферах.
* Minibuffer Windows::        Работа со специальными окнами минибуфера.
* Minibuffer Contents::       Как такие команды получают доступ к тексту
                                минибуфера.
* Recursive Mini::            Разрешен ли рекурсивный вход в минибуфер.
* Minibuffer Misc::           Различные ловушки и переменные настройки.
@end menu

@node Intro to Minibuffers
@section Введение в Минибуферы

  В большинстве случаев минибуфер - это обычный буфер Emacs.  Большинство
операций @emph{в пределах} буфера, такие как команды редактирования,
нормально работают в минибуфере.  Однако многие операции по управлению
буферами не относятся к минибуферам.  Имя минибуфера всегда имеет вид
@w{@samp{ *Minibuf-@var{number}*}}, и его нельзя изменить.  Минибуферы
отображаются только в специальных окнах, используемых только для
минибуферов; эти окна всегда появляются внизу фрейма.  (Иногда фреймы не
имеют окна минибуфера, а иногда фрейм особого типа не содержит ничего, кроме
окна минибуфера; смотреть @ref{Minibuffers and Frames}.)

  Текст в минибуфере всегда начинается с @dfn{строкой приглашения}, текста,
который был указан программой, использующей минибуфер, чтобы сообщить
пользователю что требуется вводить.  Этот текст помечен как доступный только
для чтения, поэтому случайно не удалится или не изменится.  Также помечен
как поле (@pxref{Fields}), так что некоторые функции движения, включая
@code{beginning-of-line}, @code{forward-word}, @code{forward-sentence}, и
@code{forward-paragraph}, останавливаются на границе между подсказкой и
фактическим текстом.

@c See https://debbugs.gnu.org/11276
  Окно минибуфера обычно представляет собой одну строку; увеличивается
автоматически, если для содержимого требуется больше места.  Пока минибуфер
активен, можно временно изменить размер его окна с помощью команд изменения
размера окна; при выходе из минибуфера окно возвращается к своему
нормальному размеру.  Когда минибуфер не активен, можно постоянно изменять
размер его окна, используя команды изменения размера окна в другом окне
фрейма или перетаскивая строку режима с помощью мыши.  (Из-за деталей
текущей реализации, чтобы это работало, @code{resize-mini-windows} должен
быть @code{nil}.)  Если фрейм содержит только окно минибуфера, можно
изменить его размер, изменив размер фрейма.

  Использование минибуфера считывает входные события, и это изменяет
значения таких переменных, как @code{this-command} и @code{last-command}
(@pxref{Command Loop Info}).  Программа должна связать их вокруг кода,
который использует минибуфер, если не требуется, чтобы это их меняло.

  При некоторых обстоятельствах команда может использовать минибуфер, даже
если есть активный минибуфер; такой минибуфер называется
@dfn{рекурсивным минибуфером}.  Первый минибуфер называется
@w{@samp{ *Minibuf-1*}}.  Рекурсивные минибуферы именуются путем увеличения
значения числа в конце имени.  (Имена начинаются с пробела, чтобы они не
отображались в обычных списках буферов.)  Из нескольких рекурсивных
минибуферов самым внутренним (или введенным последним) является активный
минибуфер.  Обычно он и называется минибуфером.  Можно разрешить или
запретить рекурсивные минибуферы, установив переменную
@code{enable-recursive-minibuffers} или поместив свойства этого имени в
символы команд (@xref{Recursive Mini}.).

  Как и другие буферы, минибуфер использует локальную карту ключей
(@pxref{Keymaps}) для определения специальных привязок ключей.  Функция,
вызывающая минибуфер, также устанавливает свою локальную карту в
соответствии с выполняемой работой.  @xref{Text from Minibuffer}, для
неполных локальных отображений минибуфера.  @xref{Completion Commands}, для
локальных карт завершения минибуфера.

@cindex inactive minibuffer
  Когда минибуфер неактивен, его основной режим -
@code{minibuffer-inactive-mode}, с ключевой картой
@code{minibuffer-inactive-mode-map}.  Это действительно полезно, только если
минибуфер находится в отдельном кадре.  @xref{Minibuffers and Frames}.

  Когда Emacs работает в пакетном режиме, любой запрос на чтение из
минибуфера фактически считывает строку из стандартного дескриптора ввода,
который был предоставлен при запуске Emacs.  Это поддерживает только базовый
ввод: ни одна из специальных функций минибуфера (история, завершение и
т. д.) @: Недоступна в пакетном режиме.

@node Text from Minibuffer
@section Чтение Текстовых Строк с Помощью Минибуфера
@cindex minibuffer input, reading text strings

  Самый простой примитив для ввода в минибуфер - это
@code{read-from-minibuffer}, который можно использовать для чтения строки
или объекта Lisp в текстовой форме.  Функция @code{read-regexp} используется
для чтения регулярных выражений (@pxref{Regular Expressions}), которые
представляют собой особый вид строк.  Также есть специализированные функции
для чтения команд, переменных, имен файлов и т. Д.@: (@pxref{Completion}).

  В большинстве случаев не требуется вызывать функции ввода минибуфера в
середине функции Lisp.  Вместо этого выполняется весь ввод минибуфера как
часть чтения аргументов команды в спецификации @code{interactive}.
@xref{Defining Commands}.

@defun read-from-minibuffer prompt &optional initial keymap read history default inherit-input-method
Эта функция - наиболее общий способ получить ввод из минибуфера.  По
умолчанию она принимает произвольный текст и возвращает его в виде строки;
однако, если @var{read} не-@code{nil}, то он использует @code{read} для
преобразования текста в объект Lisp (@pxref{Input Functions}).

Первое, что делает эта функция, - это активирует минибуфер и отображает его
с @var{prompt} (которая должна быть строкой) в качестве приглашения.  Затем
пользователь может редактировать текст в минибуфере.

Когда пользователь вводит команду для выхода из минибуфера,
@code{read-from-minibuffer} создает возвращаемое значение из текста в
минибуфере.  Обычно возвращается строка, содержащую этот текст.  Однако,
если @var{read} равен не-@code{nil}, @code{read-from-minibuffer}, считывает
текст и возвращает полученный объект Lisp, без оценки.
(@xref{Input Functions}, для информации о чтении.)

Аргумент @var{default} указывает значения по умолчанию, которые будут
доступны через команды истории.  Это должна быть строка, список строк или
@code{nil}.  Строка или строки становятся ``будущей историей'' минибуфера,
доступной пользователю с @kbd{M-n}.

Если @var{read} равен не-@code{nil}, тогда @var{default} также используется
как вход для @code{read}, если пользователь вводит пустой ввод.  Если
@var{default} - это список строк, первая строка используется в качестве
входных.  Если @var{default} равен @code{nil}, пустой ввод приводит к ошибке
@code{end-of-file}.
Однако в обычном случае (где @var{read} - @code{nil})
@code{read-from-minibuffer} игнорирует @var{default}, когда пользователь
вводит пустой ввод и возвращает пустую строку @code{""}.  В этом отношении
он отличается от всех других функций ввода минибуфера в этой главе.

Если @var{keymap} не-@code{nil}, эта ключевая карта является локальной
картой для использования в минибуфере.  Если @var{keymap} опущен или
@code{nil}, значение @code{minibuffer-local-map} используется как карта.
Указание карты - самый важный способ настроить минибуфер для различных
приложений, таких как завершение.

Аргумент @var{history} указывает переменную списка истории, используемую для
сохранения ввода и команд истории, используемых в минибуфере.  По умолчанию
используется @code{minibuffer-history}.  При желании также можно указать
начальную позицию в списке истории.  @xref{Minibuffer History}.

Если переменная @code{minibuffer-allow-text-properties} - не-@code{nil}, то
возвращаемая строка включает все текстовые свойства, которые присутствовали
в минибуфере.  В противном случае все свойства текста удаляются при возврате
значения.

@vindex minibuffer-prompt-properties
Свойства текста в @code{minibuffer-prompt-properties} применяются к
подсказке.  По умолчанию этот список свойств определяет отображение,
используемое для приглашения.  Если оно есть, применяется к концу списка
отображения и объединяется перед отображением.

Если пользователь хочет полностью контролировать внешний вид подсказки,
наиболее удобный способ сделать это - указать отображение @code{default} в
конце всех списков отображений.  Например:

@lisp
(read-from-minibuffer
 (concat
  (propertize "Bold" 'face '(bold default))
  (propertize " and normal: " 'face '(default))))
@end lisp

Если аргумент @var{inherit-input-method} не-@code{nil}, то минибуфер
наследует текущий метод ввода (@pxref{Input Methods}) и настройку
@code{enable-multibyte-characters} (@pxref{Text Representations}) от того,
какой буфер был текущим до входа в минибуфер.

Использование @var{initial} в основном не рекомендуется; рекомендуется
использовать значение не-@code{nil} только вместе с указанием cons-ячейки
для @var{history}.  @xref{Initial Input}.
@end defun

@defun read-string prompt &optional initial history default inherit-input-method
Эта функция считывает строку из минибуфера и возвращает ее.  Аргументы
@var{prompt}, @var{initial}, @var{history} и @var{inherit-input-method}
используются как в @code{read-from-minibuffer}.  Используемая карта
@code{minibuffer-local-map}.

Необязательный аргумент @var{default} используется так же, как в
@code{read-from-minibuffer}, за исключением того, что, если установлено
не-@code{nil}, также указывает значение по умолчанию, возвращаемое, если
пользователь отказался от ввода.  Как и в @code{read-from-minibuffer}, это
должна быть строка, список строк или @code{nil}, что эквивалентно пустой
строке.  Когда @var{default} является строкой, эта строка является значением
по умолчанию.  Когда это список строк, первая строка является значением по
умолчанию.  (Все эти строки доступны пользователю в файле
``будущая история минибуфера''.)

Эта функция работает путем вызова функции @code{read-from-minibuffer}:

@smallexample
@group
(read-string @var{prompt} @var{initial} @var{history} @var{default} @var{inherit})
@equiv{}
(let ((value
       (read-from-minibuffer @var{prompt} @var{initial} nil nil
                             @var{history} @var{default} @var{inherit})))
  (if (and (equal value "") @var{default})
      (if (consp @var{default}) (car @var{default}) @var{default})
    value))
@end group
@end smallexample
@end defun

@defun read-regexp prompt &optional defaults history
Эта функция считывает регулярное выражение в виде строки из минибуфера и
возвращает ее.  Если строка приглашения минибуфера @var{prompt} не
заканчивается на @samp{:} (за которым следует необязательный пробел),
функция добавляет @samp{: } в конец, которому предшествует возвращаемое
значение по умолчанию (смотреть ниже), если оно не пустое.

Необязательный аргумент @var{defaults} управляет значением по умолчанию,
возвращаемым, если пользователь отказался от ввода, и должен быть одним из
следующих: строка; @code{nil}, что эквивалентно пустой строке; список строк;
или символ.

Если @var{defaults} является символом, @code{read-regexp} обращается к
значению переменной @code{read-regexp-defaults-function} (смотреть ниже), а
если это не-@code{nil}, использует его вместо @var{defaults}.  Значение в
этом случае должно быть либо:

@itemize @minus
@item
@code{regexp-history-last}, что означает использование первого элемента
соответствующего списка истории минибуфера (смотреть ниже).

@item
Функция без аргументов, возвращаемое значение которой (которое должно быть
@code{nil}, строкой или списком строк) становится значением @var{defaults}.
@end itemize

@code{read-regexp} теперь гарантирует, что результатом обработки
@var{defaults} является список (т.е. если значение - @code{nil} или строка,
преобразует его в список из одного элемента).  Затем к этому списку
@code{read-regexp} добавляет несколько потенциально полезных кандидатов для
ввода.  Это:

@itemize @minus
@item
Слово или символ в точке.
@item
Последнее регулярное выражение, использованное в инкрементальном поиске.
@item
Последняя строка, используемая в инкрементальном поиске.
@item
Последняя строка или шаблон, использованный в командах замены запроса.
@end itemize

Теперь у функции есть список регулярных выражений, которые она передает
@code{read-from-minibuffer} для получения пользовательского ввода.  Первый
элемент списка - результат по умолчанию в случае пустого ввода.  Все
элементы списка доступны пользователю в виде списка ``будущая история
минибуфера'' (@pxref{Minibuffer History, future list,,
emacs, The GNU Emacs Manual}).

Необязательный аргумент @var{history}, если не-@code{nil}, является
символом, определяющим список истории минибуфера для использования
(@pxref{Minibuffer History}).  Если опущен или @code{nil}, список истории
по умолчанию будет @code{regexp-history}.
@end defun

@defopt read-regexp-defaults-function
Функция @code{read-regexp} может использовать значение этой переменной для
определения своего списка регулярных выражений по умолчанию.  Если
не-@code{nil}, значение этой переменной должно быть либо:

@itemize @minus
@item
Символ @code{regexp-history-last}.

@item
Функция без аргументов, возвращающая @code{nil}, строку или список строк.
@end itemize

@noindent
Смотреть @code{read-regexp} выше, чтобы узнать, как эти значения
используются.
@end defopt

@defvar minibuffer-allow-text-properties
Если эта переменная - @code{nil}, то @code{read-from-minibuffer} и
@code{read-string} удаляют все текстовые свойства из ввода минибуфера перед
его возвратом.  Однако @code{read-no-blanks-input} (смотреть ниже), а также
@code{read-minibuffer} и связанные функции (@pxref {Object from Minibuffer ,, Reading Lisp Objects With the Minibuffer}) и все функции, которые
выполняют ввод минибуфера с завершением, безоговорочно отбрасывают свойства
текста, независимо от значение этой переменной.
@end defvar

@defvar minibuffer-local-map
Это @anchor{Definition of minibuffer-local-map}
@c избегать разрыва страницы при привязке; работать с дефицитом Texinfo
является локальной картой по умолчанию для чтения из минибуфера.  По
умолчанию делает следующие привязки:

@table @asis
@item @kbd{C-j}
@code{exit-minibuffer}

@item @key{RET}
@code{exit-minibuffer}

@item @kbd{C-g}
@code{abort-recursive-edit}

@item @kbd{M-n}
@itemx @key{DOWN}
@code{next-history-element}

@item @kbd{M-p}
@itemx @key{UP}
@code{previous-history-element}

@item @kbd{M-s}
@code{next-matching-history-element}

@item @kbd{M-r}
@code{previous-matching-history-element}

@ignore
@c Does not seem worth/appropriate mentioning.
@item @kbd{C-@key{TAB}}
@code{file-cache-minibuffer-complete}
@end ignore
@end table
@end defvar

@c In version 18, initial is required
@c Emacs 19 feature
@defun read-no-blanks-input prompt &optional initial inherit-input-method
Эта функция считывает строку из минибуфера, но не позволяет использовать
пробельные символы как часть ввода: вместо этого эти символы завершают ввод.
Аргументы @var{prompt}, @var{initial} и @var{inherit-input-method}
используются как в @code{read-from-minibuffer}.

Это упрощенный интерфейс для функции @code{read-from-minibuffer}, который
передает значение карты ключей @code{minibuffer-local-ns-map} в качестве
аргумента @var{keymap} для этой функции.  Поскольку карта
@code{minibuffer-local-ns-map} не выполняет повторное связывание @kbd{C-q},
в @emph{is} можно поместить пробел в строку, заключив ее в кавычки.

Эта функция отбрасывает текстовые свойства независимо от значения
@code{minibuffer-allow-text-properties}.

@smallexample
@group
(read-no-blanks-input @var{prompt} @var{initial})
@equiv{}
(let (minibuffer-allow-text-properties)
  (read-from-minibuffer @var{prompt} @var{initial} minibuffer-local-ns-map))
@end group
@end smallexample
@end defun

@c Slightly unfortunate name, suggesting it might be related to the
@c Nextstep port...
@defvar minibuffer-local-ns-map
Эта встроенная переменная - ключевая карта, используемая в качестве
локальной карты минибуфера в функции @code{read-no-blanks-input}.  По
умолчанию делает следующие привязки в дополнение к привязкам
@code{minibuffer-local-map}:

@table @asis
@item @key{SPC}
@cindex @key{SPC} in minibuffer
@code{exit-minibuffer}

@item @key{TAB}
@cindex @key{TAB} in minibuffer
@code{exit-minibuffer}

@item @kbd{?}
@cindex @kbd{?} in minibuffer
@code{self-insert-and-exit}
@end table
@end defvar

@node Object from Minibuffer
@section Чтение Объектов Lisp с Помощью Минибуфера
@cindex minibuffer input, reading lisp objects

  В этом разделе описаны функции для чтения объектов Lisp с помощью
минибуфера.

@defun read-minibuffer prompt &optional initial
Эта функция читает объект Lisp с помощью минибуфера и возвращает его без
оценки.  Аргументы @var{prompt} и @var{initial} используются как в
@code{read-from-minibuffer}.

Это упрощенный интерфейс к функции @code{read-from-minibuffer}:

@smallexample
@group
(read-minibuffer @var{prompt} @var{initial})
@equiv{}
(let (minibuffer-allow-text-properties)
  (read-from-minibuffer @var{prompt} @var{initial} nil t))
@end group
@end smallexample

Вот пример, в котором предоставляется строка @code{"(testing)"} в качестве
начального ввода:

@smallexample
@group
(read-minibuffer
 "Enter an expression: " (format "%s" '(testing)))

;; @r{Вот как отображается минибуфер:}
@end group

@group
---------- Buffer: Minibuffer ----------
Enter an expression: (testing)@point{}
---------- Buffer: Minibuffer ----------
@end group
@end smallexample

@noindent
Пользователь может сразу ввести @key{RET}, чтобы использовать исходный ввод
по умолчанию, или может отредактировать ввод.
@end defun

@defun eval-minibuffer prompt &optional initial
Эта функция читает выражение Lisp с помощью минибуфера, оценивает его, а
затем возвращает результат.  Аргументы @var{prompt} и @var{initial}
используются как в @code{read-from-minibuffer}.

Эта функция просто оценивает результат вызова @code{read-minibuffer}:

@smallexample
@group
(eval-minibuffer @var{prompt} @var{initial})
@equiv{}
(eval (read-minibuffer @var{prompt} @var{initial}))
@end group
@end smallexample
@end defun

@defun edit-and-eval-command prompt form
Эта функция читает выражение Лиспа в минибуфере, оценивает его, а затем
возвращает результат.  Разница между этой командой и @code{eval-minibuffer}
состоит в том, что здесь начальный @var{form} не является необязательным и
рассматривается как объект Lisp, который должен быть преобразован в печатное
представление, а не как строка текста.  Он печатается с @code{prin1},
поэтому, если это строка, в исходном тексте появляются двойные кавычки
(@samp{"}).  @xref{Output Functions}.

В следующем примере предлагается пользователю выражение с исходным текстом,
которое уже является допустимой формой.:

@smallexample
@group
(edit-and-eval-command "Please edit: " '(forward-word 1))

;; @r{После вычисления предыдущего выражения}
;;   @r{в минибуфере появляется следующее:}
@end group

@group
---------- Buffer: Minibuffer ----------
Please edit: (forward-word 1)@point{}
---------- Buffer: Minibuffer ----------
@end group
@end smallexample

@noindent
Сразу же набор @key{RET}, выведет из минибуфера и оценит выражение, тем
самым переместив точку на одно слово вперед.
@end defun

@node Minibuffer History
@section История Минибуфера
@cindex minibuffer history
@cindex history list

  @dfn{История Минибуфера} записывает предыдущие входные данные минибуфера,
чтобы пользователь мог использовать их повторно.  Это переменная, значение
которой представляет собой список строк (предыдущие входные данные), начиная
с самых последних.

  Есть много отдельных списков истории минибуфера, используемых для разных
типов входных данных.  Задача программиста на Lisp - указать правильный
список истории для каждого использования минибуфера.

  Указывается список истории минибуфера с необязательным аргументом
@var{history} для @code{read-from-minibuffer} или @code{completing-read}.
Вот возможные значения:

@table @asis
@item @var{variable}
Использовать @var{variable} (символ) в качестве списка истории.

@item (@var{variable} . @var{startpos})
Использовать @var{variable} (символ) в качестве списка истории и
предположить, что начальная позиция истории - @var{startpos}
(неотрицательное целое число).

Указание 0 для @var{startpos} эквивалентно простому указанию символа
@var{variable}.  @code{previous-history-element} отобразит самый последний
элемент списка истории в минибуфере.  Если указано положительное значение
@var{startpos}, функции истории минибуфера будут вести себя так, как если бы
@code{(elt @var{variable} (1- @var{startpos}))} был элементом истории,
отображаемым в минибуфере в данный момент.

Для согласованности также потребуется указать этот элемент истории в
качестве начального содержимого минибуфера, используя аргумент @var{initial}
для входной функции минибуфера (@pxref{Initial Input}).
@end table

  Если указать @var{history}, будет использоваться список истории по
умолчанию @code{minibuffer-history}.  Другие стандартные списки истории
смотреть ниже.  Также можно создать свою собственную переменную списка
истории; просто инициализировать её как @code{nil} перед первым
использованием.

  Как @code{read-from-minibuffer} так и @code{completing-read} автоматически
добавляют новые элементы в список истории и предоставляют команды,
позволяющие пользователю повторно использовать элементы списка.
Единственное, что нужно сделать программе для использования списка истории,
- это инициализировать его и передать его имя входным функциям, когда
потребуется.  Но можно безопасно изменять список вручную, когда функции
ввода минибуфера его не используют.

  Функции Emacs, которые добавляют новый элемент в список истории, также
могут удалять старые элементы, если список становится слишком длинным.
Переменная @code{history-length} определяет максимальную длину для
большинства списков истории.  Чтобы указать другую максимальную длину для
конкретного списка истории, помещается длина в свойство
@code{history-length} символа списка истории.  Переменная
@code{history-delete-duplicates} указывает, нужно ли удалять дубликаты в
истории.

@defun add-to-history history-var newelt &optional maxelt keep-all
Эта функция добавляет новый элемент @var{newelt}, если это не пустая строка,
к списку истории, хранящемуся в переменной @var{history-var}, и возвращает
обновленный список истории.  Ограничивает длину списка значением
@var{maxelt} (если не-@code{nil}) или @code{history-length} (описано ниже).
Возможные значения @var{maxelt} имеют то же значение, что и значения
@code{history-length}.

Обычно @code{add-to-history} удаляет повторяющиеся элементы из списка
истории, если @code{history-delete-duplicates} равен не-@code{nil}.  Однако,
если @var{keep-all} имеет значение не-@code{nil}, это говорит о том, что не
следует удалять дубликаты и добавлять @var{newelt} в список, даже если он
пустой.
@end defun

@defvar history-add-new-input
Если значение этой переменной - @code{nil}, стандартные функции, считывающие
из минибуфера, не добавляют новые элементы в список истории.  Это позволяет
программам на Lisp явно управлять историей ввода с помощью
@code{add-to-history}.  Значение по умолчанию - @code{t}.
@end defvar

@defopt history-length
Значение этой переменной определяет максимальную длину для всех списков
истории, которые не указывают свои собственные максимальные длины.  Если
значение равно @code{t}, это означает, что максимума нет (не удалять старые
элементы).  Если символ переменной списка истории имеет свойство
не-@code{nil} @code{history-length}, он переопределяет эту переменную для
этого конкретного списка истории.
@end defopt

@defopt history-delete-duplicates
Если значение этой переменной - @code{t}, это означает, что при добавлении
нового элемента истории все предыдущие идентичные элементы удаляются.
@end defopt

  Вот некоторые из стандартных переменных списка истории минибуфера:

@defvar minibuffer-history
Список истории по умолчанию для ввода истории минибуфера.
@end defvar

@defvar query-replace-history
Список истории аргументов для @code{query-replace} (и подобных аргументов
для других команд).
@end defvar

@defvar file-name-history
Список истории для аргументов имени файла.
@end defvar

@defvar buffer-name-history
Список истории для аргументов имени буфера.
@end defvar

@defvar regexp-history
Список истории аргументов регулярного выражения.
@end defvar

@defvar extended-command-history
Список истории аргументов, которые являются именами расширенных команд.
@end defvar

@defvar shell-command-history
Список истории аргументов, которые являются командами оболочки.
@end defvar

@defvar read-expression-history
Список истории аргументов, которые нужно оценить выражениями Lisp.
@end defvar

@defvar face-name-history
Список истории аргументов, которые являются фейсами.
@end defvar

@c Less common: coding-system-history, input-method-history,
@c command-history, grep-history, grep-find-history,
@c read-envvar-name-history, setenv-history, yes-or-no-p-history.

@node Initial Input
@section Initial Input

Некоторые функции для ввода минибуфера имеют аргумент @var{initial}.  Это в
основном устаревшая функция для указания, что минибуфер должен начинаться с
определенного текста, а не с пустого, как обычно.

Если @var{initial} является строкой, минибуфер начинает содержать текст
строки с точкой в конце, когда пользователь начинает редактировать текст.
Если пользователь просто набирает @key{RET} для выхода из минибуфера, он
будет использовать начальную входную строку для определения возвращаемого
значения.

@strong{Не рекомендуем использовать значение не-@code{nil} для @var{initial}}, потому что первоначальный ввод - это навязчивый интерфейс.  Списки
истории и значения по умолчанию предоставляют гораздо более удобный способ
предложить пользователю полезные данные по умолчанию.

Есть только одна ситуация, когда потребуется указать строку для аргумента
@var{initial}.  Это когда указывается cons-ячейка для аргумента
@var{history}.  @xref{Minibuffer History}.

@var{initial} также может быть cons-ячейкой вида
@code{(@var{string} . @var{position})}. Это означает вставить @var{string} в
минибуфер, но поставить точку на @var{position} в тексте строки.

Как историческая случайность, @var{position} было реализовано в разных
функциях непоследовательно.  В @code{completing-read} значение
@var{position} интерпретируется как нулевое начало; то есть значение 0
означает начало строки, 1 означает следующий после первого символа и т.д.  В
@code{read-minibuffer} и других незавершенных функциях ввода минибуфера,
которые поддерживают этот аргумент, 1 означает начало строки, 2 означает
следующий после первого символа и т. д.

Использование cons-ячейки в качестве значения аргументов @var{initial} не
рекомендуется.

@node Completion
@section Завершение
@cindex completion

  @dfn{Завершение} - это функция, которая заполняет оставшуюся часть имени,
начиная с его аббревиатуры.  Завершение работает путем сравнения ввода
пользователя со списком допустимых имен и определения того, какая часть
имени определяется однозначно тем, что пользователь ввел.  Например, когда
набирается @kbd{C-x b} (@code{switch-to-buffer}), а затем
@c "Это тот английский язык, с которым я не буду."
набирается первых несколько букв имени буфера, на который требуется
переключиться, а затем набирается @key{TAB} (@code{minibuffer-complete}),
Emacs расширяет имя, насколько это возможно.

  Стандартные команды Emacs предлагают завершение имен символов, файлов,
буферов и процессов; с помощью функций в этом разделе вы можете реализовать
завершение для других типов имен.

  Функция @code{try-completion} является основным примитивом для завершения:
возвращает наиболее длинное определенное завершение данной начальной строки
с заданным набором строк для сопоставления.

  Функция @code{completing-read} предоставляет интерфейс более высокого
уровня для завершения.  Вызов @code{completing-read} указывает, как
определить список допустимых имен.  Затем функция активирует минибуфер с
локальной ключевой картой, которая связывает несколько ключей с командами,
полезными для завершения.  Другие функции предоставляют удобные простые
интерфейсы для чтения определенных видов имен с завершением.

@menu
* Basic Completion::       Низкоуровневые функции для завершения строк.
* Minibuffer Completion::  Вызов минибуфера с завершением.
* Completion Commands::    Команды минибуфера, выполняющие завершение.
* High-Level Completion::  Удобные частные случаи завершения
                             (чтение имен буферов, имен переменных и т. д.).
* Reading File Names::     Использование завершения для чтения имен файлов
                             и команд оболочки.
* Completion Variables::   Переменные, контролирующие поведение завершения.
* Programmed Completion::  Написание собственной функции завершения.
* Completion in Buffers::  Завершение текста в обычных буферах.
@end menu

@node Basic Completion
@subsection Basic Completion Functions

  Следующие функции завершения сами по себе не имеют ничего общего с
минибуферами.  Описываются здесь, чтобы оставатся рядом с функциями
завершения более высокого уровня, которые действительно используют
минибуфер.

@defun try-completion string collection &optional predicate
Эта функция возвращает самую длинную общую подстроку из всех возможных
завершений @var{string} в @var{collection}.

@cindex completion table
@var{collection} называется @dfn{таблицей завершения}.  Её значение должно
быть списком строк или cons-ячеек, obarray, хэш-таблицей или функцией
завершения.

@code{try-completion} сравнивает @var{string} с каждым из допустимых
завершений, указанных в таблице завершения.  Если допустимых завершений не
найдено, возвращается @code{nil}.  Если есть только одно совпадающее
завершение, и совпадение точное, возвращается @code{t}.  В противном случае
возвращается самая длинная начальную последовательность, общая для всех
возможных совпадений.

Если @var{collection} является списком, допустимые завершения определяются
элементами списка, каждый из которых должен быть либо строкой, либо
cons-ячейкой, @sc{car} которой является либо строкой, либо символом (символ
преобразуется в строку с помощью @code{symbol-name} ).  Если список содержит
элементы любого другого типа, они игнорируются.

@cindex obarray in completion
Если @var{collection} является obarray (@pxref{Creating Symbols}), имена
всех символов в obarray образуют набор допустимых дополнений.

Если @var{collection} - хеш-таблица, то ключи, которые являются строками или
символами, являются возможными дополнениями.  Остальные ключи игнорируются.

Также можно использовать функцию как @var{collection}.  Тогда функция несет
полную ответственность за выполнение; @code{try-completion} возвращает то,
что возвращает эта функция.  Функция вызывается с тремя аргументами:
@var{string}, @var{predicate} и @code{nil} (третий аргумент предназначен для
того, чтобы одну и ту же функцию можно было использовать в
@code{all-completions} и выполнять соответствующие действия в любом случае).
@xref{Programmed Completion}.

Если аргумент @var{predicate} - не-@code{nil}, он должен быть функцией
одного аргумента, если @var{collection} не является хеш-таблицей, и в этом
случае он должен быть функцией двух аргументов.  Он используется для
проверки каждого возможного совпадения, и совпадение принимается только в
том случае, если @var{predicate} возвращает не-@code{nil}.  Аргумент,
передаваемый @var{predicate}, является либо строкой, либо cons-ячейкой
(@sc{car} которой является строкой) из списка, либо символом (@emph{не} имя
символа) из obarray.  Если @var{collection} является хеш-таблицей,
@var{predicate} вызывается с двумя аргументами: строковым ключом и связанным
с ним значением.

Кроме того, чтобы быть приемлемым, завершение также должно соответствовать
всем регулярным выражениям в @code{completion-regexp-list}.  (Если
@var{collection} не является функцией, в этом случае эта функция должна
сама обрабатывать @code{completion-regexp-list}.)

В первом из следующих примеров строке @samp{foo} соответствуют три из alist
@sc{car}.  Все совпадения начинаются с символов @samp{fooba}, то это
результат.  Во втором примере есть только одно возможное совпадение, и оно
точное, поэтому возвращаемое значение - @code{t}.

@smallexample
@group
(try-completion
 "foo"
 '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4)))
     @result{} "fooba"
@end group

@group
(try-completion "foo" '(("barfoo" 2) ("foo" 3)))
     @result{} t
@end group
@end smallexample

В следующем примере многие символы начинаются с символов @samp{forw}, и все
они начинаются со слова @samp{forward}.  В большинстве символов после этого
следует @samp{-}, но не во всех, поэтому можно заполнить не более
@samp{forward}.

@smallexample
@group
(try-completion "forw" obarray)
     @result{} "forward"
@end group
@end smallexample

Наконец, в следующем примере только два из трех возможных совпадений
передают предикат @code{test} (строка @samp{foobaz} слишком короткая).  Оба
они начинаются со строки @samp{foobar}.

@smallexample
@group
(defun test (s)
  (> (length (car s)) 6))
     @result{} test
@end group
@group
(try-completion
 "foo"
 '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4))
 'test)
     @result{} "foobar"
@end group
@end smallexample
@end defun

@c Удален устаревший аргумент nospace.
@defun all-completions string collection &optional predicate
Эта функция возвращает список всех возможных завершений @var{string}.
Аргументы этой функции
@c (Помимо @var{nospace})
такие же, как и у @code{try-completion}, и она использует
@code{completion-regexp-list} так же, как @code{try-completion}.

@ignore
Необязательный аргумент @var{nospace} устарел.  Если это не-@code{nil},
завершения, начинающиеся с пробела, игнорируются, если @var{string} не
начинается с пробела..
@end ignore

Если @var{collection} - функция, она вызывается с тремя аргументами:
@var{string}, @var{predicate} и @code{t}; тогда @code{all-completions}
возвращает то, что возвращает функция.  @xref{Programmed Completion}.

Вот пример использования функции @code{test}, показанной в примере для
@code{try-completion}:

@smallexample
@group
(defun test (s)
  (> (length (car s)) 6))
     @result{} test
@end group

@group
(all-completions
 "foo"
 '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4))
 'test)
     @result{} ("foobar1" "foobar2")
@end group
@end smallexample
@end defun

@defun test-completion string collection &optional predicate
@anchor{Definition of test-completion}
Эта функция возвращает не-@code{nil}, если @var{string} - допустимая
альтернатива завершения, заданная @var{collection} и @var{predicate}.
Аргументы такие же, как и в @code{try-completion}.  Например, если
@var{collection} - это список строк, это верно, если @var{string} появляется
в списке и @var{predicate} удовлетворяется.

Эта функция использует @code{completion-regexp-list} так же, как
@code{try-completion}.

Если @var{predicate} равен не-@code{nil} и @var{collection} содержит
несколько строк, которые равны друг другу, как определено
@code{compare-strings} в соответствии с @code{completion-ignore-case}, тогда
@var{predicate} должен принимать либо все, либо ни одну из них.  В противном
случае возвращаемое значение @code{test-completion} по существу
непредсказуемо.

Если @var{collection} - функция, она вызывается с тремя аргументами,
значениями @var{string}, @var{predicate} и @code{lambda}; что бы ни
вернулось, возвращается @code{test-completion}.
@end defun

@defun completion-boundaries string collection predicate suffix
Эта функция возвращает границы поля, в котором будет работать
@var{collection}, при условии, что @var{string} содержит текст до точки, а
@var{suffix} содержит текст после точки.

Обычно завершение выполняется для всей строки, поэтому для всех обычных
коллекций всегда будет возвращаться @code{(0 . (length @var{suffix}))}.  Но
более сложное завершение, такое как завершение файлов, выполняется по одному
полю за раз.  Например, завершение @code{"/usr/sh"} будет включать
@code{"/usr/share/"}, но не @code{"/usr/share/doc"}, даже если
@code{"/usr/share/doc"} существует.  Также @code{all-completions} на
@code{"/usr/sh"} не будет включать @code{"/usr/share/"}, а только
@code{"share/"}.  Таким образом, если @var{string} является @code{"/usr/sh"}
и @var{suffix} это @code{"e/doc"}, @code{completion-boundaries} вернет
@code{(5 . 1)}, который говорит, что @var{collection} будет возвращать
только информацию о завершении, которая относится к области после
@code{"/usr/"} и до @code{"/doc"}.
@end defun

Если хранится список завершения в переменной, потребкется пометить эту
переменную как опасную, присвоив ей свойство не-@code{nil} в
@code{risky-local-variable}.  @xref{File Local Variables}.

@defvar completion-ignore-case
Если значение этой переменной - не-@code{nil}, не учитывать регистр при
завершении.  В @code{read-file-name} эта переменная заменяется
@code{read-file-name-completion-ignore-case} (@pxref{Reading File Names});
внутри @code{read-buffer} заменяется на
@code{read-buffer-completion-ignore-case} (@pxref{High-Level Completion}).
@end defvar

@defvar completion-regexp-list
Это список регулярных выражений.  Функции завершения считают завершение
приемлемым, только если оно соответствует всем регулярным выражениям этого
списка, при этом @code{case-fold-search} (@pxref{Searching and Case})
привязан к значению @code{completion-ignore-case}.
@end defvar

@defmac lazy-completion-table var fun
Этот макрос предоставляет способ инициализировать переменную @var{var} как
коллекцию для ленивого завершения, не вычисляя ее фактическое содержимое,
пока оно не понадобится.  Используется этот макрос для создания значения,
которое сохраняется в @var{var}.  Фактическое вычисление правильного
значения выполняется в первый раз, когда выполняется завершение с помощью
@var{var}.  Это делается путем вызова @var{fun} без аргументов.
Возвращаемое значение @var{fun} становится постоянным значением @var{var}.

Вот пример:

@smallexample
(defvar foo (lazy-completion-table foo make-my-alist))
@end smallexample
@end defmac

@c FIXME?  completion-table-with-context?
@findex completion-table-case-fold
@findex completion-table-in-turn
@findex completion-table-merge
@findex completion-table-subvert
@findex completion-table-with-quoting
@findex completion-table-with-predicate
@findex completion-table-with-terminator
@cindex completion table, modifying
@cindex completion tables, combining
Есть несколько функций, которые берут существующую таблицу завершения и
возвращают измененную версию.  @code{completion-table-case-fold} возвращает
таблицу без учета регистра.  @code{completion-table-in-turn} и
@code{completion-table-merge} объединяет несколько таблиц ввода по-разному.
@code{completion-table-subvert} изменяет таблицу, чтобы использовать другой
начальный префикс.  @code{completion-table-with-quoting} возвращает таблицу,
подходящую для работы с цитируемым текстом.
@code{completion-table-with-predicate} фильтрует таблицу с помощью функции
предиката.  @code{completion-table-with-terminator} добавляет завершающую
строку.


@node Minibuffer Completion
@subsection Завершение и Минибуфер
@cindex minibuffer completion
@cindex reading from minibuffer with completion

  В этом разделе описывается базовый интерфейс для чтения из минибуфера с
  завершением.

@defun completing-read prompt collection &optional predicate require-match initial history default inherit-input-method
Эта функция считывает строку в минибуфере, помогая пользователю обеспечивать
завершение.  Активирует минибуфер с приглашением @var{prompt}, которое
должно быть строкой.

Фактическое завершение выполняется путем передачи таблицы завершения
@var{collection} и предиката завершения @var{predicate} в функцию
@code{try-completion} (@pxref{Basic Completion}).  Это происходит в
некоторых командах, привязанных к локальным ключевым картам, используемым
для завершения.  Некоторые из этих команд также вызывают
@code{test-completion}.  Таким образом, если @var{predicate} равен
не-@code{nil}, это должно быть совместимо с @var{collection} и
@code{completion-ignore-case}.
@xref{Definition of test-completion}.

@xref{Programmed Completion}, для подробных требований, когда
@var{collection} является функцией.

Значение необязательного аргумента @var{require-match} определяет, как
пользователю можно выйти из минибуфера:

@itemize @bullet
@item
Если @code{nil}, обычные команды выхода из минибуфера работают независимо
от ввода в минибуфер.

@item
Если @code{t}, обычные команды выхода из минибуфера не завершатся, пока ввод
не завершится до элемента @var{collection}.

@item
Если @code{confirm}, пользователь может выйти с любым вводом, но
запрашивается подтверждение, если ввод не является элементом
@var{collection}.

@item
Если @code{confirm-after-completion}, пользователь может выйти с любым
вводом, но запрашивается подтверждение, была ли предыдущая команда командой
завершения (то есть одна из команд в @code{minibuffer-confirm-exit-commands}
) и полученный ввод не является элементом @var{collection}.  @xref{Completion Commands}.

@item
Любое другое значение @var{require-match} ведет себя как @code{t}, за
исключением того, что команды выхода не завершаются, если выполняется
завершение.
@end itemize

Однако пустой ввод всегда разрешен, независимо от значения
@var{require-match}; в этом случае @code{completing-read} возвращает первый
элемент @var{default}, если это список; @code{""}, если @var{default} -
@code{nil}; или @var{default}.  Строка или строки в @var{default} также
доступны пользователю через команды истории.

Функция @code{completing-read} использует
@code{minibuffer-local-completion-map} в качестве ключевой карты, если
@var{require-match} равно @code{nil}, и использует
@code{minibuffer-local-must-match-map}, если @var{require-match} равно
не-@code{nil}.  @xref{Completion Commands}.

Аргумент @var{history} указывает, какую переменную списка истории
использовать для сохранения ввода и для команд истории минибуфера.  По
умолчанию используется @code{minibuffer-history}.
@xref{Minibuffer History}.

Аргумент @var{initial} в основном устарел; рекомендуется использовать
значение не-@code{nil} только вместе с указанием cons-ячейки для
@var{history}.  @xref{Initial Input}.  Для ввода по умолчанию используется
вместо этого @var{default}.

Если аргумент @var{inherit-input-method} - не-@code{nil}, то минибуфер
наследует текущий метод ввода (@pxref{Input Methods}) и настройку
@code{enable-multibyte-characters} (@pxref{Text Representations}) от того
буфера, который был текущим до входа в минибуфер.

Если переменная @code{completion-ignore-case} - не-@code{nil}, завершение
игнорирует регистр при сравнении ввода с возможными совпадениями.
@xref{Basic Completion}.  В этом режиме работы @var{predicate} также должен
игнорировать регистр, иначе получатся неожиданные результаты.

Вот пример использования @code{completing-read}:

@smallexample
@group
(completing-read
 "Complete a foo: "
 '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4))
 nil t "fo")
@end group

@group
;; @r{После вычисления предыдущего выражения в минибуфере}
;;   @r{ появляется следующее:}

---------- Buffer: Minibuffer ----------
Complete a foo: fo@point{}
---------- Buffer: Minibuffer ----------
@end group
@end smallexample

@noindent
Если пользователь затем набирает @kbd{@key{DEL} @key{DEL} b @key{RET}},
@code{completing-read} возвращает @code{barfoo}.

Функция @code{completing-read} связывает переменные для передачи информации
командам, которые фактически выполняют завершение.  Они описаны в следующем
разделе.
@end defun

@defvar completing-read-function
Значением этой переменной должна быть функция, которая вызывается
@code{completing-read} для выполнения своей работы.  Должны приниматься те
же аргументы, что и @code{completing-read}.  Это может быть связано с другой
функцией, чтобы полностью переопределить нормальное поведение
@code{completing-read}.
@end defvar

@node Completion Commands
@subsection Команды Минибуфера, Выполняющие Завершение

  В этом разделе описываются ключевые карты, команды и параметры
пользователя, используемые в минибуфере для завершения.

@defvar minibuffer-completion-table
Значение этой переменной - таблица завершения (@pxref{Basic Completion}),
используемая для завершения в минибуфере.  Это глобальная переменная,
которая содержит то, что @code{completing-read} передает в
@code{try-completion}.  Это используется командами завершения минибуфера,
такими как @code{minibuffer-complete-word}.
@end defvar

@defvar minibuffer-completion-predicate
Значение этой переменной - это предикат, который @code{completing-read}
передает @code{try-completion}.  Переменная также используется другими
функциями завершения минибуфера.
@end defvar

@defvar minibuffer-completion-confirm
Эта переменная определяет, запрашивает ли Emacs подтверждение перед выходом
из минибуфера; @code{completing-read} связывает эту переменную, а функция
@code{minibuffer-complete-and-exit} проверяет значение перед выходом.  Если
значение равно @code{nil}, подтверждение не требуется.  Если значение равно
@code{confirm}, пользователь может выйти с вводом, который не является
допустимой альтернативой завершения, но Emacs запросит подтверждение.  Если
значение равно @code{confirm-after-completion}, пользователь может выйти с
вводом, который не является допустимой альтернативой завершения, но Emacs
запрашивает подтверждение, отправил ли пользователь ввод сразу после любой
из команд завершения в @code{minibuffer-confirm-exit-commands}.
@end defvar

@defvar minibuffer-confirm-exit-commands
Эта переменная содержит список команд, которые заставляют Emacs запрашивать
подтверждение перед выходом из минибуфера, если аргумент @var{require-match}
для @code{completing-read} равен @code{confirm-after-completion}.
Подтверждение запрашивается, если пользователь пытается выйти из минибуфера
сразу после вызова любой команды из этого списка.
@end defvar

@deffn Command minibuffer-complete-word
Эта функция дополняет содержимое минибуфера максимум одним словом.  Даже
если содержимое минибуфера имеет только одно завершение,
@code{minibuffer-complete-word} не добавляет никаких символов, кроме первого
символа, который не является составной частью слова.  @xref{Syntax Tables}.
@end deffn

@deffn Command minibuffer-complete
Эта функция дополняет содержимое минибуфера, насколько это возможно.
@end deffn

@deffn Command minibuffer-complete-and-exit
Эта функция завершает содержимое минибуфера и завершает работу, если
подтверждение не требуется, например, если
@code{minibuffer-completion-confirm} равен @code{nil}.  Если требуетсяп
@emph{этому} подтверждение, оно дается путем немедленного повторения этой
команды - команда запрограммирована на работу без подтверждения при
выполнении её дважды подряд.
@end deffn

@deffn Command minibuffer-completion-help
Эта функция создает список возможных завершений текущего содержимого
минибуфера.  Работает, вызывая @code{all-completions} с использованием
значения переменной @code{minibuffer-completion-table} в качестве аргумента
@var{collection} и значения @code{minibuffer-completion-predicate} в
качестве аргумента @var{predicate}.  Список завершений отображается в виде
текста в буфере с именем @file{*Completions*}.
@end deffn

@defun display-completion-list completions
Эта функция отображает @var{completions} в поток в @code{standard-output},
обычно это буфер.  (@xref{Read and Print}, для получения дополнительной
информации о потоках.)  Аргумент @var{completions} обычно представляет собой
список завершений, только что возвращенный @code{all-completions}, но это не
обязательно.  Каждый элемент может быть символом или строкой, любой из
которых просто печатается.  Это также может быть список из двух строк,
который печатается так, как если бы строки были объединены.  Первая из двух
строк - это фактическое завершение, вторая строка служит аннотацией.

Эта функция вызывается @code{minibuffer-completion-help}.  Обычно это можно
использовать вместе с @code{with-output-to-temp-buffer}, например:

@example
(with-output-to-temp-buffer "*Completions*"
  (display-completion-list
    (all-completions (buffer-string) my-alist)))
@end example
@end defun

@defopt completion-auto-help
Если эта переменная - не-@code{nil}, команды завершения автоматически
отображают список возможных завершений всякий раз, когда ничего не может
быть завершено, потому что следующий символ не определен однозначно.
@end defopt

@defvar minibuffer-local-completion-map
@code{completing-read} использует это значение как локальную карту ключей,
когда точное совпадение одного из завершений не требуется.  По умолчанию эта
карта делает следующие привязки:

@table @asis
@item @kbd{?}
@code{minibuffer-completion-help}

@item @key{SPC}
@code{minibuffer-complete-word}

@item @key{TAB}
@code{minibuffer-complete}
@end table

@noindent
и использует @code{minibuffer-local-map} в качестве родительской карты
(@pxref{Definition of minibuffer-local-map}).
@end defvar

@defvar minibuffer-local-must-match-map
@code{completing-read} использует это значение как локальную ключевую карту,
когда требуется точное совпадение одного из завершений.  Следовательно,
никакие ключи не привязаны к @code{exit-minibuffer}, команде, которая
безоговорочно выходит из минибуфера.  По умолчанию эта карта имеет следующие
привязки:

@table @asis
@item @kbd{C-j}
@code{minibuffer-complete-and-exit}

@item @key{RET}
@code{minibuffer-complete-and-exit}
@end table

@noindent
и использует @code{minibuffer-local-completion-map} в качестве родительской
карты.
@end defvar

@defvar minibuffer-local-filename-completion-map
Это разреженная ключевая карта, которая просто отключает @key{SPC}; потому
что имена файлов могут содержать пробелы.  Функция @code{read-file-name}
объединяет эту карту с @code{minibuffer-local-completion-map} или
@code{minibuffer-local-must-match-map}.
@end defvar


@node High-Level Completion
@subsection Функции Завершения Высокого Уровня

  В этом разделе описаны вспомогательные функции более высокого уровня для
чтения определенных типов имен с завершением.

  В большинстве случаев не требуется вызывать эти функции в середине функции
Lisp.  По возможности, вводится весь минибуфер как часть чтения аргументов
команды в спецификации @code{interactive}.  @xref{Defining Commands}.

@defun read-buffer prompt &optional default require-match predicate
Эта функция считывает имя буфера и возвращает его в виде строки.
Запрашивается @var{prompt}.  Аргумент @var{default} - это имя по умолчанию
для использования, значение, которое возвращается, если пользователь выходит
с пустым минибуфером.  Если не-@code{nil}, это должна быть строка, список
строк или буфер.  Если это список, значением по умолчанию является первый
элемент этого списка.  Он упоминается в приглашении, но не вставляется в
минибуфер в качестве начального ввода.

Аргумент @var{prompt} должен быть строкой, оканчивающейся двоеточием и
пробелом.  Если @var{default} равен не-@code{nil}, функция вставляет его в
@var{prompt} перед двоеточием, чтобы следовать соглашению о чтении из
минибуфера со значением по умолчанию (@pxref{Programming Tips}).

Необязательный аргумент @var{require-match} имеет то же значение, что и в
@code{completing-read}.  @xref{Minibuffer Completion}.

Необязательный аргумент @var{predicate}, если не-@code{nil}, указывает
функцию для фильтрации буферов, которые следует учитывать: функция будет
вызываться с каждым потенциальным кандидатом в качестве аргумента и должна
возвращать @code{nil}, чтобы отклонить кандидата, не-@code{nil}, чтобы
принять его.

В следующем примере пользователь вводит @samp{minibuffer.t}, а затем
набирает @key{RET}.  Аргумент @var{require-match} - @code{t}, и единственное
имя буфера, начинающееся с данного ввода, - @samp{minibuffer.texi}, так что
имя является значением.

@example
(read-buffer "Buffer name: " "foo" t)
@group
;; @r{После вычисления предыдущего выражения}
;;   @r{появляется следующая подсказка,}
;;   @r{с пустым минибуфером:}
@end group

@group
---------- Buffer: Minibuffer ----------
Buffer name (default foo): @point{}
---------- Buffer: Minibuffer ----------
@end group

@group
;; @r{Ввод пользователя @kbd{minibuffer.t @key{RET}}.}
     @result{} "minibuffer.texi"
@end group
@end example
@end defun

@defopt read-buffer-function
Эта переменная, если не-@code{nil}, определяет функцию для чтения имен
буферов.  @code{read-buffer} вызывает эту функцию вместо того, чтобы
выполнять свою обычную работу, с теми же аргументами, переданными в
@code{read-buffer}.
@end defopt

@defopt read-buffer-completion-ignore-case
Если эта переменная - не-@code{nil}, @code{read-buffer} игнорирует регистр
при выполнении завершения при чтении имени буфера.
@end defopt

@defun read-command prompt &optional default
Эта функция считывает имя команды и возвращает его как символ Lisp.
Аргумент @var{prompt} используется так же, как в
@code{read-from-minibuffer}.  Напомним, что команда - это все, для чего
@code{commandp} возвращает @code{t}, а имя команды - это символ, для
которого @code{commandp} возвращает @code{t}.  @xref{Interactive Call}.

Аргумент @var{default} указывает, что возвращать, если пользователь вводит
пустой ввод.  Это может быть символ, строка или список строк.  Если это
строка, @code{read-command} обрабатывает ее перед возвратом.  Если это
список, @code{read-command} обрабатывает первый элемент этого списка.
Если @var{default} равен @code{nil}, это означает, что значение по умолчанию
не задано; тогда, если пользователь вводит пустой ввод, возвращаемое
значение - @code{(intern "")}, то есть символ, имя которого - пустая строка,
а печатное представление - @code{##} (@pxref{Symbol Type}).

@example
(read-command "Command name? ")

@group
;; @r{После вычисления предыдущего выражения появляется}
;;   @r{следующая подсказка с пустым минибуфером:}
@end group

@group
---------- Buffer: Minibuffer ----------
Command name?
---------- Buffer: Minibuffer ----------
@end group
@end example

@noindent
Если пользователь вводит @kbd{forward-c @key{RET}}, эта функция возвращает
@code{forward-char}.

Функция @code{read-command} - это упрощенный интерфейс для
@code{completing-read}.  Использует переменную @code{obarray}, чтобы
завершить набор существующих символов Lisp, и использует предикат
@code{commandp}, чтобы принимать только имена команд:

@cindex @code{commandp} пример
@example
@group
(read-command @var{prompt})
@equiv{}
(intern (completing-read @var{prompt} obarray
                         'commandp t nil))
@end group
@end example
@end defun

@defun read-variable prompt &optional default
@anchor{Definition of read-variable}
Эта функция считывает имя настраиваемой переменной и возвращает её в виде
символа.  Его аргументы имеют тот же вид, что и аргументы
@code{read-command}.  Ведет себя так же, как @code{read-command}, за
исключением того, что использует предикат @code{custom-variable-p} вместо
@code{commandp}.
@end defun

@deffn Command read-color &optional prompt convert allow-empty display
Эта функция считывает строку, которая является спецификацией цвета, либо
именем цвета, либо шестнадцатеричным значением RGB, например
@code{#RRRGGGBBB}.  Запрашивает @var{prompt} (по умолчанию:
@code{"Цвет (имя или триплет #RGB):"}) и обеспечивает завершение для
названий цветов, но не для шестнадцатеричных значений RGB.  В дополнение к
названиям стандартных цветов кандидаты завершения включают в себя цвета
переднего плана и фона в точке.

Описание действительных значений RGB в @ref{Color Names}.

Возвращаемое значение функции - строка, введенная пользователем в минибуфер.
Однако при интерактивном вызове или если необязательный аргумент
@var{convert} равен не-@code{nil}, преобразует любое имя входного цвета в
соответствующую строку значения RGB и это возвращает.  Функция требует ввода
действительной спецификации цвета.  Пустые имена цветов разрешены, когда
@var{allow-empty} равен не-@code{nil} и пользователь вводит пустой ввод.

В интерактивном режиме или когда @var{display} равен не-@code{nil},
возвращаемое значение также отображается в эхо-области.
@end deffn

  Смотреть также функции @code{read-coding-system} и
@code{read-non-nil-coding-system}, в @ref{User-Chosen Coding Systems},
и @code{read-input-method-name}, в @ref{Input Methods}.

@node Reading File Names
@subsection Чтение Имен Файлов
@cindex read file names
@cindex prompt for file name

  Функции завершения высокого уровня @code{read-file-name},
@code{read-directory-name} и @code{read-shell-command} предназначены для
чтения имен файлов, имен каталогов и команд оболочки соответственно.  Они
предоставляют специальные функции, включая автоматическую вставку каталога
по умолчанию.

@defun read-file-name prompt &optional directory default require-match initial predicate
Эта функция считывает имя файла, запрашивая @var{prompt} и обеспечивая
завершение.

В качестве исключения эта функция считывает имя файла с использованием
графического диалогового окна файла вместо минибуфера, если выполняются все
следующие условия:

@enumerate
@item
Вызывается с помощью команды мыши.

@item
Выбранный фрейм отображается на графическом дисплее, поддерживающем такие
диалоги.

@item
Переменная @code{use-dialog-box} - не-@code{nil}.
@xref{Dialog Boxes,, Dialog Boxes, emacs, The GNU Emacs Manual}.

@item
Аргумент @var{directory}, описанный ниже, не указывает удаленный файл.
@xref{Remote Files,, Remote Files, emacs, The GNU Emacs Manual}.
@end enumerate

@noindent
Точное поведение при использовании диалогового окна с графическим файлом
зависит от платформы.  Здесь просто документируется поведение при
использовании минибуфера.

@code{read-file-name} не расширяет автоматически возвращаемое имя файла.
Можно вызвать @code{expand-file-name} самостоятельно, если требуется
абсолютное имя файла.

Необязательный аргумент @var{require-match} имеет то же значение, что и в
@code{completing-read}.  @xref{Minibuffer Completion}.

Аргумент @var{directory} указывает каталог, используемый для завершения
относительных имен файлов.  Это должно быть абсолютное имя каталога.  Если
переменная @code{insert-default-directory} - не-@code{nil}, @var{directory}
также вставляется в минибуфер в качестве начального ввода.  По умолчанию
используется текущее значение буфера @code{default-directory}.

Если указано @var{initial}, это начальное имя файла для вставки в буфер
(после @var{directory}, если вставлено).  В этом случае точка стоит в начале
@var{initial}.  По умолчанию для @var{initial} установлено значение
@code{nil}---не вставлять никаких имен файлов.  Чтобы увидеть, что делает
@var{initial}, пробуется команда @kbd{C-x C-v} в буфере, обращающуюся к
файлу.  @strong{Пожалуйста, обратить внимание:} в большинстве случаев
рекомендуется использовать @var{default}, а не @var{initial}.

Если @var{default} равен не-@code{nil}, функция возвращает @var{default},
если пользователь выходит из минибуфера с тем же непустым содержимым,
которое изначально было вставлено @code{read-file-name}.  Первоначальное
содержимое минибуфера всегда непусто, если @code{insert-default-directory}
имеет значение не-@code{nil}, как и по умолчанию.  @var{default} не
проверяется на валидность, независимо от значения @var{require-match}.
Однако, если @var{require-match} равен не-@code{nil}, исходным содержимым
минибуфера должно быть допустимое имя файла (или каталога).  В противном
случае @code{read-file-name} пытается завершить, если пользователь выходит
без редактирования, и не возвращает @var{default}.  @var{default} также
доступен через команды истории.

Если @var{default} - @code{nil}, @code{read-file-name} пытается найти замену
вместо использования по умолчанию, так что он обрабатывает точно так же, как
если бы он был указан явно.  Если @var{default} - @code{nil}, а
@var{initial} - не-@code{nil}, то по умолчанию используется абсолютное имя
файла, полученное из @var{directory} и @var{initial}.  Если оба
@var{default} и @var{initial} - @code{nil} и буфер обращается к файлу,
@code{read-file-name} использует абсолютное имя этого файла по умолчанию.
Если буфер не обращается к файлу, значит, нет по умолчанию.  В том случае,
если пользователь набирает @key{RET} без какого-либо редактирования,
@code{read-file-name} просто возвращает предварительно вставленное
содержимое минибуфера.

Если пользователь набирает @key{RET} в пустом минибуфере, эта функция
возвращает пустую строку, независимо от значения @var{require-match}.  Это,
например, как пользователь может заставить текущий буфер не посещать файл с
помощью @kbd{M-x set-visited-file-name}.

Если @var{predicate} равен не-@code{nil}, он определяет функцию одного
аргумента, которая определяет, какие имена файлов являются приемлемыми
альтернативами завершения.  Имя файла является допустимым значением, если
@var{predicate} возвращает для него не-@code{nil}.

Вот пример использования @code{read-file-name}:

@example
@group
(read-file-name "The file is ")

;; @r{После вычисления предыдущего выражения}
;;   @r{в минибуфере появляется следующее:}
@end group

@group
---------- Buffer: Minibuffer ----------
The file is /gp/gnu/elisp/@point{}
---------- Buffer: Minibuffer ----------
@end group
@end example

@noindent
Ввод @kbd{manual @key{TAB}} приводит к следующему:

@example
@group
---------- Buffer: Minibuffer ----------
The file is /gp/gnu/elisp/manual.texi@point{}
---------- Buffer: Minibuffer ----------
@end group
@end example

@c Многословный, чтобы избежать переполнения бокса в режиме маленькой книги.
@noindent
Если пользователь вводит @key{RET}, @code{read-file-name}, возвращает имя
файла в виде строки @code{"/gp/gnu/elisp/manual.texi"}.
@end defun

@defvar read-file-name-function
Если не-@code{nil}, это должна быть функция, которая принимает те же
аргументы, что и @code{read-file-name}.  Когда вызывается
@code{read-file-name}, он вызывает эту функцию с предоставленными
аргументами вместо того, чтобы выполнять свою обычную работу.
@end defvar

@defopt read-file-name-completion-ignore-case
Если эта переменная - не-@code{nil}, @code{read-file-name}, при завершении
игнорируется регистр.
@end defopt

@defun read-directory-name prompt &optional directory default require-match initial
Эта функция похожа на @code{read-file-name}, но позволяет использовать
только имена каталогов в качестве альтернативы завершения.

Если @var{default} - @code{nil}, а @var{initial} - не-@code{nil},
@code{read-directory-name}, создает замену по умолчанию, комбинируя
@var{directory} (или каталог текущего буфера по умолчанию, если
@var{directory} равен @code{nil}) и @var{initial}.  Если @var{default} и
@var{initial} имеют значение @code{nil}, эта функция использует
@var{directory} в качестве замены по умолчанию или каталог текущего буфера
по умолчанию, если @var{directory} имеет значение @code{nil}.
@end defun

@defopt insert-default-directory
Эта переменная используется @code{read-file-name} и, таким образом,
косвенно, большинством команд, читающих имена файлов.  (Это включает все
команды, которые используют кодовые буквы @samp{f} или @samp{F} в своей
интерактивной форме.
@xref{Interactive Codes,, Code Characters for interactive}.)  Её значение
определяет, запускается ли @code{read-file-name}, помещая имя каталога по
умолчанию в минибуфер плюс имя исходного файла, если оно есть.  Если
значение этой переменной - @code{nil}, то @code{read-file-name} не помещает
начальный ввод в минибуфер (если не указан начальный ввод с аргументом
@var{initial}).  В этом случае каталог по умолчанию по-прежнему используется
для завершения относительных имен файлов, но не отображается.

Если эта переменная - @code{nil}, а исходное содержимое минибуфера пусто,
пользователю может потребоваться явным образом выбрать следующий элемент
истории, чтобы получить доступ к значению по умолчанию.  Если переменная -
не-@code{nil}, исходное содержимое минибуфера всегда непусто, и пользователь
всегда может запросить значение по умолчанию, немедленно набрав @key{RET} в
неотредактированном минибуфере. (См. Выше.)

Например:

@example
@group
;; @r{Здесь минибуфер начинается с каталога по умолчанию.}
(let ((insert-default-directory t))
  (read-file-name "The file is "))
@end group

@group
---------- Buffer: Minibuffer ----------
The file is ~lewis/manual/@point{}
---------- Buffer: Minibuffer ----------
@end group

@group
;; @r{Здесь минибуфер пуст и в его строке}
;;   @r{появляется только подсказка.}
(let ((insert-default-directory nil))
  (read-file-name "The file is "))
@end group

@group
---------- Buffer: Minibuffer ----------
The file is @point{}
---------- Buffer: Minibuffer ----------
@end group
@end example
@end defopt

@defun read-shell-command prompt &optional initial history &rest args
Эта функция считывает команду оболочки из минибуфера, запрашивая
@var{prompt} и обеспечивая интеллектуальное завершение.  Завершает первое
слово команды, используя кандидатов, которые подходят для имен команд, а
остальные слова команды в качестве имен файлов.

Эта функция использует @code{minibuffer-local-shell-command-map} в качестве
карты для ввода в минибуфер.  Аргумент @var{history} указывает список
истории для использования; если опущено или @code{nil}, по умолчанию
используется @code{shell-command-history}
(@pxref{Minibuffer History, shell-command-history}).  Необязательный
аргумент @var{initial} указывает начальное содержимое минибуфера
(@pxref{Initial Input}).  Остальные @var{args}, если они есть, используются
как аргументы @var{default} и @var{inherit-input-method} в
@code{read-from-minibuffer} (@pxref{Text from Minibuffer}).
@end defun

@defvar minibuffer-local-shell-command-map
Эта карта используется @code{read-shell-command} для завершения имен команд
и файлов, которые являются частью команды оболочки.  Использует
@code{minibuffer-local-map} в качестве родительской ключевой карты и
связывает @key{TAB} с @code{completion-at-point}.
@end defvar

@node Completion Variables
@subsection Переменные Завершения

  Вот несколько переменных, которые можно использовать для изменения
поведения завершения по умолчанию.

@cindex completion styles
@defopt completion-styles
Значение этой переменной представляет собой список стилей завершения
(символов), используемых для выполнения завершения.  @dfn{Стиль завершения}
- это набор правил для генерации завершений.  Каждый символ, встречающийся в
этом списке, должен иметь соответствующую запись в
@code{completion-styles-alist}.
@end defopt

@defvar completion-styles-alist
В этой переменной хранится список доступных стилей завершения.  Каждый
элемент в списке имеет форму

@example
(@var{style} @var{try-completion} @var{all-completions} @var{doc})
@end example

@noindent
Здесь @var{style} - это имя стиля завершения (символ), которое может
использоваться в переменной @code{completion-styles} для ссылки на этот
стиль; @var{try-completion} - функция, выполняющая завершение;
@var{all-completions} - это функция, которая выводит список завершений;
@var{doc} - строка, описывающая стиль завершения.

Каждая функция @var{try-completion} и @var{all-completions} должна принимать
четыре аргумента: @var{string}, @var{collection}, @var{predicate}, и
@var{point}.  Аргументы @var{string}, @var{collection} и @var{predicate}
имеют то же значение, что и аргумент @code{try-completion}
(@pxref{Basic Completion}) и @var{point} - позиция точки внутри
@var{string}.  Каждая функция должна возвращать значение не-@code{nil}, если
она выполнила свою работу, и @code{nil}, если нет (например, если нет
возможности завершить @var{string} в соответствии со стилем завершения).

Когда пользователь вызывает команду завершения, например
@code{minibuffer-complete} (@pxref{Completion Commands}), Emacs ищет первый
стиль, указанный в @code{completion-styles}, и вызывает его функцию
@var{try-completion}.  Если эта функция возвращает @code{nil}, Emacs
переходит к следующему перечисленному стилю завершения и вызывает свою
функцию @var{try-completion}, и так далее, пока одна из функций
@var{try-completion} не выполнит успешно завершение и не вернет значение
не-@code{nil}.  Аналогичная процедура используется для перечисления
дополнений с помощью функций @var{all-completions}.

@xref{Completion Styles,,, emacs, The GNU Emacs Manual}, для описания
доступных стилей завершения.
@end defvar

@defopt completion-category-overrides
Эта переменная определяет специальные стили завершения и другое поведение
завершения, используемое при завершении определенных типов текста.  Её
значение должно быть списком с элементами вида
@code{(@var{category} . @var{alist})}. @var{category} - символ, описывающий,
что выполняется; в настоящее время определены категории @code{buffer},
@code{file} и @code{unicode-name}, но другие могут быть определены с помощью
специализированных функций завершения (@pxref{Programmed Completion}).
@var{alist} - это список ассоциаций, описывающий, как завершение должно
вести себя для соответствующей категории.  Поддерживаются следующие ключи
списка:

@table @code
@item styles
Значение должно быть списком стилей завершения (символов).

@item cycle
Значение должно быть значением @code{completion-cycle-threshold}
(@pxref{Completion Options,,, emacs, The GNU Emacs Manual})
для этой категории.
@end table

@noindent
Дополнительные записи списка могут быть определены в будущем.
@end defopt

@defvar completion-extra-properties
Эта переменная используется для указания дополнительных свойств текущей
команды завершения.  Она предназначен для связывания с помощью специальных
команд завершения.  Её значение должно быть списком пар свойств и значений.
Поддерживаются следующие свойства:

@table @code
@item :annotation-function
Значение должно быть функцией для завершения аннотаций в буфер завершений.
Эта функция должна принимать один аргумент, завершение, и должна либо
возвращать @code{nil}, либо строку, которая будет отображаться рядом с
завершением.

@item :exit-function
Значение должно быть функцией, запускаемой после выполнения.  Функция должна
принимать два аргумента, @var{string} и @var{status}, где @var{string} - это
текст, которым было заполнено поле, а @var{status} указывает, какая операция
произошла: @code{finished}, если текст теперь завершен, @code{sole}, если
текст не может быть завершен, но завершение выполняется.  Не завершено, или
@code{exact}, если текст является допустимым завершением, но может быть
завершен в дальнейшем.
@end table
@end defvar

@node Programmed Completion
@subsection Программное Завершение
@cindex programmed completion

  Иногда невозможно или невозможно заранее создать список или массив,
содержащий все предполагаемые возможные завершения.  В таком случае можно
предоставить собственную функцию для вычисления завершения данной строки.
Это называется @dfn{программное завершение}.  Emacs использует программное
завершение при завершении имен файлов (@pxref{File Name Completion}),
среди многих других случаев.

  Чтобы использовать эту функцию, передайте функцию @code{completing-read}
в качестве аргумента @var{collection}.  Функция @code{completing-read}
передает вашу функцию завершения вместе с @code{try-completion},
@code{all-completions} и другими базовыми функциями завершения, которые
затем позволяют вашей функции выполнять всю работу.

  Функция завершения должна принимать три аргумента:

@itemize @bullet
@item
Строка, которую нужно заполнить.

@item
Функция предиката для фильтрации возможных совпадений или @code{nil}, если
их нет.  Функция должна вызывать предикат для каждого возможного совпадения
и игнорировать совпадение, если предикат возвращает @code{nil}.

@item
Флаг, определяющий тип выполняемой операции завершения; смотреть
@ref{Basic Completion}, чтобы узнать подробности об этих операциях.  Этот
флаг может иметь одно из следующих значений.

@table @code
@item nil
Это определяет операцию @code{try-completion}.  Функция должна вернуть
@code{nil}, если совпадений нет; должна вернуть @code{t}, если указанная
строка является уникальным и точным соответствием; и в противном случае она
должна возвращать самую длинную подстроку общего префикса из всех
совпадений.

@item t
Это определяет операцию @code{all-completions}.  Функция должна вернуть
список всех возможных завершений указанной строки.

@item lambda
Это определяет операцию @code{test-completion}.  Функция должна возвращать
@code{t}, если указанная строка является точным совпадением для некоторой
альтернативы завершения; @code{nil} иначе.

@item (boundaries . @var{suffix})
Это определяет операцию @code{completion-boundaries}.  Функция должна
возвращать @code{(boundaries @var{start} . @var{end})}, где @var{start} -
позиция начальной границы в указанной строке, а @var{end} - позиция конечной
границы в @var{suffix}.

@item metadata
Это определяет запрос информации о состоянии текущего завершения.
Возвращаемое значение должно иметь вид @code{(metadata . @var{alist})}, где
@var{alist} - это список, элементы которого описаны ниже.
@end table

@noindent
Если флаг имеет любое другое значение, функция завершения должна вернуть
@code{nil}.
@end itemize

Ниже приведен список записей метаданных, которые функция завершения может
вернуть в ответ на аргумент флага @code{metadata}:

@table @code
@item category
Значение должно быть символом, описывающим, какой текст пытается завершить
функция завершения.  Если символ соответствует одному из ключей в
@code{completion-category-overrides}, обычное завершение отменяется.
@xref{Completion Variables}.

@item annotation-function
Значение должно быть функцией для завершений @dfn{анотаций}.  Функция должна
принимать один аргумент @var{string}, который является возможным
завершением.  Должна вернуть строку, которая отображается после завершения
@var{string} в буфере @file{*Completions*}.

@item display-sort-function
Значение должно быть функцией для сортировки завершений.  Функция должна
принимать один аргумент, список строк завершения и возвращать
отсортированный список строк завершения.  Допускается деструктивное
изменение входного списка.

@item cycle-sort-function
Значение должно быть функцией для сортировки завершений, когда
@code{completion-cycle-threshold} имеет значение не-@code{nil} и
пользователь циклически перебирает варианты завершения.
@xref{Completion Options,,, emacs, The GNU Emacs Manual}.  Список аргументов
и возвращаемое значение такие же, как у @code{display-sort-function}.
@end table

@defun completion-table-dynamic function &optional switch-buffer
Эта функция - удобный способ написать функцию, которая может действовать как
запрограммированная функция завершения.  Аргумент @var{function} должен быть
функцией, которая принимает один аргумент, строку и возвращает таблицу
завершения (@pxref{Basic Completion}), содержащую все возможные завершения.
Таблица, возвращаемая @var{function}, также может включать элементы, не
соответствующие строковому аргументу; они автоматически отфильтровываются
@code{completion-table-dynamic}.  В частности, @var{function} может
игнорировать свой аргумент и возвращать полный список всех возможных
завершений.  Можно рассматривать @code{completion-table-dynamic} как
преобразователь между @var{function} и интерфейсом для запрограммированных
функций завершения.

Если необязательный аргумент @var{switch-buffer} - не-@code{nil} и
завершение выполняется в минибуфере, @var{function} будет вызываться с
текущим буфером, установленным на буфер, из которого был введен минибуфер.

Возвращаемое значение @code{completion-table-dynamic} - это функция,
которую можно использовать как 2-й аргумент для @code{try-completion} и
@code{all-completions}.  Обратить внимание, что эта функция всегда будет
возвращать пустые метаданные и тривиальные границы.
(@pxref{Programmed Completion}).
@end defun

@defun completion-table-with-cache function &optional ignore-case
Это оболочка для @code{completion-table-dynamic}, которая сохраняет
последнюю пару аргумент-результат.  Это означает, что несколько запросов с
одним и тем же аргументом должны вызывать @var{function} только один раз.
Это может быть полезно, когда задействована медленная операция, например,
вызов внешнего процесса.
@end defun

@node Completion in Buffers
@subsection Завершение в Обычных Буферах
@cindex inline completion

@findex completion-at-point
  Хотя завершение обычно выполняется в минибуфере, средство завершения также
можно использовать для текста в обычных буферах Emacs.  Во многих основных
режимах завершение в буфере выполняется командой @kbd{C-M-i} или
@kbd{M-@key{TAB}}, привязанной к @code{completion-at-point}.
@xref{Symbol Completion,,, emacs, The GNU Emacs Manual}.  Эта команда
использует ненормальную переменную ловушки
@code{completion-at-point-functions}:

@defvar completion-at-point-functions
Значением этой ненормальной ловушки должен быть список функций, который
используются для вычисления таблицы завершения (@pxref{Basic Completion})
для завершения текста в точке.  Может использоваться основными режимами для
предоставления таблиц завершения конкретных режимов
(@pxref{Major Mode Conventions}).

Когда команда @code{completion-at-point} запускается, вызывает функции в
списке одну за другой без каких-либо аргументов.  Каждая функция должна
возвращать @code{nil}, если она не может и не хочет брать на себя
ответственность за данные завершения для текста в точке.  В противном случае
она должена вернуть список следующего вида:

@example
(@var{start} @var{end} @var{collection} . @var{props})
@end example

@noindent
@var{start} и @var{end} ограничивают текст до завершения (который должен
заключать точку).  @var{collection} - таблица завершения для завершения
этого текста в форме, пригодная для передачи в качестве второго аргумента в
@code{try-completion} (@pxref{Basic Completion});  Альтернативы завершения
будут сгенерированы из этой таблицы завершения обычным способом с помощью
стилей завершения, определенных в @code{completion-styles}
(@pxref{Completion Variables}).  @var{props} - список свойств для
дополнительной информации; любое из свойств в
@code{completion-extra-properties} распознается
(@pxref{Completion Variables}), а также есть следующие дополнительные:

@table @code
@item :predicate
Значение должно быть предикатом, которому должны удовлетворять кандидаты на
завершение.

@item :exclusive
Если значение равно @code{no}, то, если таблица завершения не соответствует
тексту в точке, @code{completion-at-point} переходит к следующей функции в
@code{completion-at-point-functions} вместо сообщения об ошибке завершения.
@end table

Функции на этой ловушке обычно должны возвращаться быстро, поскольку они
могут вызываться очень часто (например, из @code{post-command-hook}).
Настоятельно рекомендуется использовать функцию для @var{collection}, если
создание списка завершений - дорогостоящая операция.  Emacs может вызывать
функции внутри @code{completion-at-point-functions} много раз, но заботится
о значении @var{collection} только для некоторых из этих вызовов.
Предоставляя функцию для @var{collection}, Emacs может отложить создание
завершений до тех пор, пока это необходимо.  Можно использовать
@code{completion-table-dynamic} для создания функции-оболочки:

@smallexample
;; Избегайте этого шаблона.
(let ((beg ...) (end ...) (my-completions (my-make-completions)))
  (list beg end my-completions))

;; Используйте вместо это.
(let ((beg ...) (end ...))
  (list beg
        end
        (completion-table-dynamic
          (lambda (_)
            (my-make-completions)))))
@end smallexample

Кроме того, @var{collection} обычно не следует предварительно фильтровать
на основе текущего текста между @var{start} и @var{end}, потому что это
задача вызывающего @code{completion-at-point-functions} в соответствии со
стилями завершения, которые решает использовать.

Функция в @code{completion-at-point-functions} может также возвращать
функцию вместо списка, как описано выше.  В этом случае эта возвращенная
функция вызывается без аргументов, и она полностью отвечает за выполнение
завершения.  Не рекомендуется такое использование; предназначено только для
преобразования старого кода в использование @code{completion-at-point}.

Первая функция в @code{completion-at-point-functions}, возвращающая значение
не-@code{nil}, используется @code{completion-at-point}.  Остальные функции
не вызываются.  Исключение составляют случаи, когда существует спецификация
@code{:exclusive}, как описано выше.
@end defvar

  Следующая функция предоставляет удобный способ выполнить завершение
произвольного фрагмента текста в буфере Emacs:

@defun completion-in-region start end collection &optional predicate
Эта функция завершает текст в текущем буфере между позициями @var{start} и
@var{end}, используя @var{collection}.  Аргумент @var{collection} имеет то
же значение, что и аргумент @code{try-completion}
(@pxref{Basic Completion}).

Эта функция вставляет текст завершения непосредственно в текущий буфер.  В
отличие от @code{completing-read} (@pxref{Minibuffer Completion}), он не
активирует минибуфер.

Чтобы эта функция работала, точка должна находиться где-то между @var{start}
и @var{end}.
@end defun


@node Yes-or-No Queries
@section Вопросы Да или Нет
@cindex asking the user questions
@cindex querying the user
@cindex yes-or-no questions

  В этом разделе описаны функции, используемые для того, чтобы задать
пользователю вопрос типа «да» или «нет».  На функцию @code{y-or-n-p} можно
ответить одним символом; это полезно для вопросов, на которые
непреднамеренный неправильный ответ не приведет к серьезным последствиям.
@code{yes-or-no-p} подходит для более важных вопросов, поскольку для ответа
требуется три или четыре символа.

   Если какая-либо из этих функций вызывается в команде, которая была
вызвана с помощью мыши - точнее, если @code{last-nonmenu-event}
(@pxref{Command Loop Info}) является либо @code{nil}, либо списком, - тогда
используется диалоговое окно или всплывающее меню, чтобы задать вопрос.  В
противном случае используется ввод с клавиатуры.  Можно принудительно
использовать либо мышь, либо ввод с клавиатуры, привязав
@code{last-nonmenu-event} к подходящему значению вокруг вызова.

  Строго говоря, @code{yes-or-no-p} использует минибуфер, а @code{y-or-n-p}
- нет; но, кажется, лучше всего описывать их вместе.

@defun y-or-n-p prompt
Эта функция задает пользователю вопрос, ожидая ввода в эхо-области.  Она
возвращает @code{t}, если пользователь вводит @kbd{y}, @code{nil}, если
пользователь вводит @kbd{n}.  Эта функция также принимает @key{SPC} для
обозначения да и @key{DEL} для обозначения нет.  Она принимает @kbd{C-]} для
выхода, как @kbd{C-g}, потому что вопрос может выглядеть как минибуфер, и
по этой причине пользователь может попытаться использовать @kbd{C-]} для
выхода.  Ответ - один символ, @key{RET}, без необходимого для его
завершения.  Верхний и нижний регистр эквивалентны.

``Задавая вопрос'' означает вывод @var{prompt} в эхо-области, за которым
следует строка @w{@samp{(y or n) }}.  Если вход не является одним из
ожидаемых ответов (@kbd{y}, @kbd{n}, @kbd{@key{SPC}}, @kbd{@key{DEL}} или
что-то, что требует завершения), функция отвечает
@samp{Please answer y or n.} и повторяет запрос.

This function does not actually use the minibuffer, since it does not
allow editing of the answer.  It actually uses the echo area (@pxref{The
Echo Area}), which uses the same screen space as the minibuffer.  The
cursor moves to the echo area while the question is being asked.

The answers and their meanings, even @samp{y} and @samp{n}, are not
hardwired, and are specified by the keymap @code{query-replace-map}
(@pxref{Search and Replace}).  In particular, if the user enters the
special responses @code{recenter}, @code{scroll-up},
@code{scroll-down}, @code{scroll-other-window}, or
@code{scroll-other-window-down} (respectively bound to @kbd{C-l},
@kbd{C-v}, @kbd{M-v}, @kbd{C-M-v} and @kbd{C-M-S-v} in
@code{query-replace-map}), this function performs the specified window
recentering or scrolling operation, and poses the question again.

@noindent
We show successive lines of echo area messages, but only one actually
appears on the screen at a time.
@end defun

@defun y-or-n-p-with-timeout prompt seconds default
Like @code{y-or-n-p}, except that if the user fails to answer within
@var{seconds} seconds, this function stops waiting and returns
@var{default}.  It works by setting up a timer; see @ref{Timers}.
The argument @var{seconds} should be a number.
@end defun

@defun yes-or-no-p prompt
This function asks the user a question, expecting input in the
minibuffer.  It returns @code{t} if the user enters @samp{yes},
@code{nil} if the user types @samp{no}.  The user must type @key{RET} to
finalize the response.  Upper and lower case are equivalent.

@code{yes-or-no-p} starts by displaying @var{prompt} in the echo area,
followed by @w{@samp{(yes or no) }}.  The user must type one of the
expected responses; otherwise, the function responds @samp{Please answer
yes or no.}, waits about two seconds and repeats the request.

@code{yes-or-no-p} requires more work from the user than
@code{y-or-n-p} and is appropriate for more crucial decisions.

Here is an example:

@smallexample
@group
(yes-or-no-p "Do you really want to remove everything? ")

;; @r{After evaluation of the preceding expression,}
;;   @r{the following prompt appears,}
;;   @r{with an empty minibuffer:}
@end group

@group
---------- Buffer: minibuffer ----------
Do you really want to remove everything? (yes or no)
---------- Buffer: minibuffer ----------
@end group
@end smallexample

@noindent
If the user first types @kbd{y @key{RET}}, which is invalid because this
function demands the entire word @samp{yes}, it responds by displaying
these prompts, with a brief pause between them:

@smallexample
@group
---------- Buffer: minibuffer ----------
Please answer yes or no.
Do you really want to remove everything? (yes or no)
---------- Buffer: minibuffer ----------
@end group
@end smallexample
@end defun

@node Multiple Queries
@section Asking Multiple-Choice Questions

  This section describes facilities for asking the user more complex
questions or several similar questions.

@cindex multiple yes-or-no questions
  When you have a series of similar questions to ask, such as ``Do you
want to save this buffer?'' for each buffer in turn, you should use
@code{map-y-or-n-p} to ask the collection of questions, rather than
asking each question individually.  This gives the user certain
convenient facilities such as the ability to answer the whole series at
once.

@defun map-y-or-n-p prompter actor list &optional help action-alist no-cursor-in-echo-area
This function asks the user a series of questions, reading a
single-character answer in the echo area for each one.

The value of @var{list} specifies the objects to ask questions about.
It should be either a list of objects or a generator function.  If it is
a function, it should expect no arguments, and should return either the
next object to ask about, or @code{nil}, meaning to stop asking questions.

The argument @var{prompter} specifies how to ask each question.  If
@var{prompter} is a string, the question text is computed like this:

@example
(format @var{prompter} @var{object})
@end example

@noindent
where @var{object} is the next object to ask about (as obtained from
@var{list}).

If not a string, @var{prompter} should be a function of one argument
(the next object to ask about) and should return the question text.  If
the value is a string, that is the question to ask the user.  The
function can also return @code{t}, meaning do act on this object (and
don't ask the user), or @code{nil}, meaning ignore this object (and don't
ask the user).

The argument @var{actor} says how to act on the answers that the user
gives.  It should be a function of one argument, and it is called with
each object that the user says yes for.  Its argument is always an
object obtained from @var{list}.

If the argument @var{help} is given, it should be a list of this form:

@example
(@var{singular} @var{plural} @var{action})
@end example

@noindent
where @var{singular} is a string containing a singular noun that
describes the objects conceptually being acted on, @var{plural} is the
corresponding plural noun, and @var{action} is a transitive verb
describing what @var{actor} does.

If you don't specify @var{help}, the default is @code{("object"
"objects" "act on")}.

Each time a question is asked, the user may enter @kbd{y}, @kbd{Y}, or
@key{SPC} to act on that object; @kbd{n}, @kbd{N}, or @key{DEL} to skip
that object; @kbd{!} to act on all following objects; @key{ESC} or
@kbd{q} to exit (skip all following objects); @kbd{.} (period) to act on
the current object and then exit; or @kbd{C-h} to get help.  These are
the same answers that @code{query-replace} accepts.  The keymap
@code{query-replace-map} defines their meaning for @code{map-y-or-n-p}
as well as for @code{query-replace}; see @ref{Search and Replace}.

You can use @var{action-alist} to specify additional possible answers
and what they mean.  It is an alist of elements of the form
@code{(@var{char} @var{function} @var{help})}, each of which defines one
additional answer.  In this element, @var{char} is a character (the
answer); @var{function} is a function of one argument (an object from
@var{list}); @var{help} is a string.

When the user responds with @var{char}, @code{map-y-or-n-p} calls
@var{function}.  If it returns non-@code{nil}, the object is considered
acted upon, and @code{map-y-or-n-p} advances to the next object in
@var{list}.  If it returns @code{nil}, the prompt is repeated for the
same object.

Normally, @code{map-y-or-n-p} binds @code{cursor-in-echo-area} while
prompting.  But if @var{no-cursor-in-echo-area} is non-@code{nil}, it
does not do that.

If @code{map-y-or-n-p} is called in a command that was invoked using the
mouse---more precisely, if @code{last-nonmenu-event} (@pxref{Command
Loop Info}) is either @code{nil} or a list---then it uses a dialog box
or pop-up menu to ask the question.  In this case, it does not use
keyboard input or the echo area.  You can force use either of the mouse or
of keyboard input by binding @code{last-nonmenu-event} to a suitable
value around the call.

The return value of @code{map-y-or-n-p} is the number of objects acted on.
@end defun
@c FIXME  An example of this would be more useful than all the
@c preceding examples of simple things.

If you need to ask the user a question that might have more than just
2 answers, use @code{read-answer}.

@defun read-answer question answers
@vindex read-answer-short
This function prompts the user with text in @var{question}, which
should end in the @samp{SPC} character.  The function includes in the
prompt the possible responses in @var{answers} by appending them to
the end of @var{question}.  The possible responses are provided in
@var{answers} as an alist whose elements are of the following form:

@lisp
(@var{long-answer} @var{short-answer} @var{help-message})
@end lisp

@noindent
where @var{long-answer} is the complete text of the user response, a
string; @var{short-answer} is a short form of the same response, a
single character; and @var{help-message} is the text that describes
the meaning of the answer.  If the variable @code{read-answer-short}
is non-@code{nil}, the prompt will show the short variants of the
possible answers and the user is expected to type the single
characters shown in the prompt; otherwise the prompt will show the
long variants of the answers, and the user is expected to type the
full text of one of the answers and end by pressing @key{RET}.  If
@code{use-dialog-box} is non-@code{nil}, and this function was invoked
by mouse events, the question and the answers will be displayed in a
GUI dialog box.

The function returns the text of the @var{long-answer} selected by the
user, regardless of whether long or short answers were shown in the
prompt and typed by the user.

Here is an example of using this function:

@lisp
(let ((read-answer-short t))
  (read-answer "Foo "
     '(("yes"  ?y "perform the action")
       ("no"   ?n "skip to the next")
       ("all"  ?! "perform for the rest without more questions")
       ("help" ?h "show help")
       ("quit" ?q "exit"))))
@end lisp
@end defun

@node Reading a Password
@section Reading a Password
@cindex passwords, reading

  To read a password to pass to another program, you can use the
function @code{read-passwd}.

@vindex read-hide-char
@defun read-passwd prompt &optional confirm default
This function reads a password, prompting with @var{prompt}.  It does
not echo the password as the user types it; instead, it echoes
@samp{.}  for each character in the password.  If you want to apply
another character to hide the password, let-bind the variable
@code{read-hide-char} with that character.

The optional argument @var{confirm}, if non-@code{nil}, says to read the
password twice and insist it must be the same both times.  If it isn't
the same, the user has to type it over and over until the last two
times match.

The optional argument @var{default} specifies the default password to
return if the user enters empty input.  If @var{default} is @code{nil},
then @code{read-passwd} returns the null string in that case.
@end defun

@node Minibuffer Commands
@section Minibuffer Commands

  This section describes some commands meant for use in the
minibuffer.

@deffn Command exit-minibuffer
This command exits the active minibuffer.  It is normally bound to
keys in minibuffer local keymaps.
@end deffn

@deffn Command self-insert-and-exit
This command exits the active minibuffer after inserting the last
character typed on the keyboard (found in @code{last-command-event};
@pxref{Command Loop Info}).
@end deffn

@deffn Command previous-history-element n
This command replaces the minibuffer contents with the value of the
@var{n}th previous (older) history element.
@end deffn

@deffn Command next-history-element n
This command replaces the minibuffer contents with the value of the
@var{n}th more recent history element.
@end deffn

@deffn Command previous-matching-history-element pattern n
This command replaces the minibuffer contents with the value of the
@var{n}th previous (older) history element that matches @var{pattern} (a
regular expression).
@end deffn

@deffn Command next-matching-history-element pattern n
This command replaces the minibuffer contents with the value of the
@var{n}th next (newer) history element that matches @var{pattern} (a
regular expression).
@end deffn

@deffn Command previous-complete-history-element n
This command replaces the minibuffer contents with the value of the
@var{n}th previous (older) history element that completes the current
contents of the minibuffer before the point.
@end deffn

@deffn Command next-complete-history-element n
This command replaces the minibuffer contents with the value of the
@var{n}th next (newer) history element that completes the current
contents of the minibuffer before the point.
@end deffn


@node Minibuffer Windows
@section Minibuffer Windows
@cindex minibuffer windows

These functions access and select minibuffer windows, test whether they
are active and control how they get resized.

@defun minibuffer-window &optional frame
@anchor{Definition of minibuffer-window}
This function returns the minibuffer window used for frame @var{frame}.
If @var{frame} is @code{nil}, that stands for the selected frame.

Note that the minibuffer window used by a frame need not be part of that
frame---a frame that has no minibuffer of its own necessarily uses some
other frame's minibuffer window.  The minibuffer window of a
minibuffer-less frame can be changed by setting that frame's
@code{minibuffer} frame parameter (@pxref{Buffer Parameters}).
@end defun

@defun set-minibuffer-window window
This function specifies @var{window} as the minibuffer window to use.
This affects where the minibuffer is displayed if you put text in it
without invoking the usual minibuffer commands.  It has no effect on the
usual minibuffer input functions because they all start by choosing the
minibuffer window according to the selected frame.
@end defun

@c Emacs 19 feature
@defun window-minibuffer-p &optional window
This function returns non-@code{nil} if @var{window} is a minibuffer
window.  @var{window} defaults to the selected window.
@end defun

The following function returns the window showing the currently active
minibuffer.

@defun active-minibuffer-window
This function returns the window of the currently active minibuffer, or
@code{nil} if there is no active minibuffer.
@end defun

It is not sufficient to determine whether a given window shows the
currently active minibuffer by comparing it with the result of
@code{(minibuffer-window)}, because there can be more than one
minibuffer window if there is more than one frame.

@defun minibuffer-window-active-p window
This function returns non-@code{nil} if @var{window} shows the currently
active minibuffer.
@end defun

The following two options control whether minibuffer windows are resized
automatically and how large they can get in the process.

@defopt resize-mini-windows
This option specifies whether minibuffer windows are resized
automatically.  The default value is @code{grow-only}, which means that
a minibuffer window by default expands automatically to accommodate the
text it displays and shrinks back to one line as soon as the minibuffer
gets empty.  If the value is @code{t}, Emacs will always try to fit the
height of a minibuffer window to the text it displays (with a minimum of
one line).  If the value is @code{nil}, a minibuffer window never
changes size automatically.  In that case the window resizing commands
(@pxref{Resizing Windows}) can be used to adjust its height.
@end defopt

@defopt max-mini-window-height
This option provides a maximum height for resizing minibuffer windows
automatically.  A floating-point number specifies a fraction of the
frame's height; an integer specifies the maximum number of lines.  The
default value is 0.25.
@end defopt

Note that the values of the above two variables take effect at display
time, so let-binding them around code which produces echo-area messages
will not work.  If you want to prevent resizing of minibuffer windows
when displaying long messages, bind the @code{message-truncate-lines}
variable instead (@pxref{Echo Area Customization}).


@node Minibuffer Contents
@section Minibuffer Contents
@cindex access minibuffer contents
@cindex minibuffer contents, accessing

  These functions access the minibuffer prompt and contents.

@defun minibuffer-prompt
This function returns the prompt string of the currently active
minibuffer.  If no minibuffer is active, it returns @code{nil}.
@end defun

@defun minibuffer-prompt-end
This function returns the current
position of the end of the minibuffer prompt, if a minibuffer is
current.  Otherwise, it returns the minimum valid buffer position.
@end defun

@defun minibuffer-prompt-width
This function returns the current display-width of the minibuffer
prompt, if a minibuffer is current.  Otherwise, it returns zero.
@end defun

@defun minibuffer-contents
This function returns the editable
contents of the minibuffer (that is, everything except the prompt) as
a string, if a minibuffer is current.  Otherwise, it returns the
entire contents of the current buffer.
@end defun

@defun minibuffer-contents-no-properties
This is like @code{minibuffer-contents}, except that it does not copy text
properties, just the characters themselves.  @xref{Text Properties}.
@end defun

@deffn Command delete-minibuffer-contents
This command erases the editable contents of the minibuffer (that is,
everything except the prompt), if a minibuffer is current.  Otherwise,
it erases the entire current buffer.
@end deffn

@node Recursive Mini
@section Recursive Minibuffers
@cindex recursive minibuffers

  These functions and variables deal with recursive minibuffers
(@pxref{Recursive Editing}):

@defun minibuffer-depth
This function returns the current depth of activations of the
minibuffer, a nonnegative integer.  If no minibuffers are active, it
returns zero.
@end defun

@defopt enable-recursive-minibuffers
If this variable is non-@code{nil}, you can invoke commands (such as
@code{find-file}) that use minibuffers even while the minibuffer is
active.  Such invocation produces a recursive editing level for a new
minibuffer.  The outer-level minibuffer is invisible while you are
editing the inner one.

If this variable is @code{nil}, you cannot invoke minibuffer commands
when the minibuffer is active, not even if you switch to another window
to do it.
@end defopt

@c Emacs 19 feature
If a command name has a property @code{enable-recursive-minibuffers}
that is non-@code{nil}, then the command can use the minibuffer to read
arguments even if it is invoked from the minibuffer.  A command can
also achieve this by binding @code{enable-recursive-minibuffers}
to @code{t} in the interactive declaration (@pxref{Using Interactive}).
The minibuffer command @code{next-matching-history-element} (normally
@kbd{M-s} in the minibuffer) does the latter.

@node Minibuffer Misc
@section Minibuffer Miscellany

@defun minibufferp &optional buffer-or-name
This function returns non-@code{nil} if @var{buffer-or-name} is a
minibuffer.  If @var{buffer-or-name} is omitted, it tests the current
buffer.
@end defun

@defvar minibuffer-setup-hook
This is a normal hook that is run whenever the minibuffer is entered.
@xref{Hooks}.
@end defvar

@defmac minibuffer-with-setup-hook function &rest body
This macro executes @var{body} after arranging for the specified
@var{function} to be called via @code{minibuffer-setup-hook}.  By
default, @var{function} is called before the other functions in the
@code{minibuffer-setup-hook} list, but if @var{function} is of the
form @w{@code{(:append @var{func})}}, @var{func} will be called
@emph{after} the other hook functions.

The @var{body} forms should not use the minibuffer more than once.  If
the minibuffer is re-entered recursively, @var{function} will only be
called once, for the outermost use of the minibuffer.
@end defmac

@defvar minibuffer-exit-hook
This is a normal hook that is run whenever the minibuffer is exited.
@xref{Hooks}.
@end defvar

@defvar minibuffer-help-form
@anchor{Definition of minibuffer-help-form}
The current value of this variable is used to rebind @code{help-form}
locally inside the minibuffer (@pxref{Help Functions}).
@end defvar

@defvar minibuffer-scroll-window
@anchor{Definition of minibuffer-scroll-window}
If the value of this variable is non-@code{nil}, it should be a window
object.  When the function @code{scroll-other-window} is called in the
minibuffer, it scrolls this window.
@end defvar

@defun minibuffer-selected-window
This function returns the window that was selected just before the
minibuffer window was selected.  If the selected window is not a
minibuffer window, it returns @code{nil}.
@end defun

@vindex minibuffer-message-timeout
@defun minibuffer-message string &rest args
This function displays @var{string} temporarily at the end of the
minibuffer text, for a few seconds, or until the next input event
arrives, whichever comes first.  The variable
@code{minibuffer-message-timeout} specifies the number of seconds to
wait in the absence of input.  It defaults to 2.  If @var{args} is
non-@code{nil}, the actual message is obtained by passing @var{string}
and @var{args} through @code{format-message}.  @xref{Formatting Strings}.
@end defun

@deffn Command minibuffer-inactive-mode
This is the major mode used in inactive minibuffers.  It uses
keymap @code{minibuffer-inactive-mode-map}.  This can be useful
if the minibuffer is in a separate frame.  @xref{Minibuffers and Frames}.
@end deffn
