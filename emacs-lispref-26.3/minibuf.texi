@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2019 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Minibuffers
@chapter Минибуферы
@cindex arguments, reading
@cindex complex arguments
@cindex minibuffer

  @dfn{Минибуфер} - это специальный буфер, который команды Emacs используют
для чтения аргументов, более сложных, чем аргумент с одним числовым
префиксом.  Эти аргументы включают имена файлов, имена буферов и имена
команд (как в @kbd{M-x}).  Минибуфер отображается в нижней строке кадра в
том же месте, что и эхо-область (@pxref{The Echo Area}), но только пока он
используется для чтения аргумента.

@menu
* Intro to Minibuffers::      Основная информация о минибуферах.
* Text from Minibuffer::      Как читать прямую текстовую строку.
* Object from Minibuffer::    Как читать объект или выражение Lisp.
* Minibuffer History::        Запись предыдущих входов минибуфера, чтобы
                              пользователь мог их повторно использовать.
* Initial Input::             Определение начального содержимого минибуфера.
* Completion::                Как вызвать и настроить завершение.
* Yes-or-No Queries::         Задать вопрос с простым ответом.
* Multiple Queries::          Задать сложные вопросы.
* Reading a Password::        Считывание пароля с терминала.
* Minibuffer Commands::       Команды, используемые как привязки ключей
                                в минибуферах.
* Minibuffer Windows::        Работа со специальными окнами минибуфера.
* Minibuffer Contents::       Как такие команды получают доступ к тексту
                                минибуфера.
* Recursive Mini::            Разрешен ли рекурсивный вход в минибуфер.
* Minibuffer Misc::           Различные ловушки и переменные настройки.
@end menu

@node Intro to Minibuffers
@section Введение в Минибуферы

  В большинстве случаев минибуфер - это обычный буфер Emacs.  Большинство
операций @emph{в пределах} буфера, такие как команды редактирования,
нормально работают в минибуфере.  Однако многие операции по управлению
буферами не относятся к минибуферам.  Имя минибуфера всегда имеет вид
@w{@samp{ *Minibuf-@var{number}*}}, и его нельзя изменить.  Минибуферы
отображаются только в специальных окнах, используемых только для
минибуферов; эти окна всегда появляются внизу фрейма.  (Иногда фреймы не
имеют окна минибуфера, а иногда фрейм особого типа не содержит ничего, кроме
окна минибуфера; смотреть @ref{Minibuffers and Frames}.)

  Текст в минибуфере всегда начинается с @dfn{строкой приглашения}, текста,
который был указан программой, использующей минибуфер, чтобы сообщить
пользователю что требуется вводить.  Этот текст помечен как доступный только
для чтения, поэтому случайно не удалится или не изменится.  Также помечен
как поле (@pxref{Fields}), так что некоторые функции движения, включая
@code{beginning-of-line}, @code{forward-word}, @code{forward-sentence}, и
@code{forward-paragraph}, останавливаются на границе между подсказкой и
фактическим текстом.

@c See https://debbugs.gnu.org/11276
  Окно минибуфера обычно представляет собой одну строку; увеличивается
автоматически, если для содержимого требуется больше места.  Пока минибуфер
активен, можно временно изменить размер его окна с помощью команд изменения
размера окна; при выходе из минибуфера окно возвращается к своему
нормальному размеру.  Когда минибуфер не активен, можно постоянно изменять
размер его окна, используя команды изменения размера окна в другом окне
фрейма или перетаскивая строку режима с помощью мыши.  (Из-за деталей
текущей реализации, чтобы это работало, @code{resize-mini-windows} должен
быть @code{nil}.)  Если фрейм содержит только окно минибуфера, можно
изменить его размер, изменив размер фрейма.

  Использование минибуфера считывает входные события, и это изменяет
значения таких переменных, как @code{this-command} и @code{last-command}
(@pxref{Command Loop Info}).  Программа должна связать их вокруг кода,
который использует минибуфер, если не требуется, чтобы это их меняло.

  При некоторых обстоятельствах команда может использовать минибуфер, даже
если есть активный минибуфер; такой минибуфер называется
@dfn{рекурсивным минибуфером}.  Первый минибуфер называется
@w{@samp{ *Minibuf-1*}}.  Рекурсивные минибуферы именуются путем увеличения
значения числа в конце имени.  (Имена начинаются с пробела, чтобы они не
отображались в обычных списках буферов.)  Из нескольких рекурсивных
минибуферов самым внутренним (или введенным последним) является активный
минибуфер.  Обычно он и называется минибуфером.  Можно разрешить или
запретить рекурсивные минибуферы, установив переменную
@code{enable-recursive-minibuffers} или поместив свойства этого имени в
символы команд (@xref{Recursive Mini}.).

  Как и другие буферы, минибуфер использует локальную карту ключей
(@pxref{Keymaps}) для определения специальных привязок ключей.  Функция,
вызывающая минибуфер, также устанавливает свою локальную карту в
соответствии с выполняемой работой.  @xref{Text from Minibuffer}, для
неполных локальных отображений минибуфера.  @xref{Completion Commands}, для
локальных карт завершения минибуфера.

@cindex inactive minibuffer
  Когда минибуфер неактивен, его основной режим -
@code{minibuffer-inactive-mode}, с ключевой картой
@code{minibuffer-inactive-mode-map}.  Это действительно полезно, только если
минибуфер находится в отдельном кадре.  @xref{Minibuffers and Frames}.

  Когда Emacs работает в пакетном режиме, любой запрос на чтение из
минибуфера фактически считывает строку из стандартного дескриптора ввода,
который был предоставлен при запуске Emacs.  Это поддерживает только базовый
ввод: ни одна из специальных функций минибуфера (история, завершение и
т. д.) @: Недоступна в пакетном режиме.

@node Text from Minibuffer
@section Чтение Текстовых Строк с Помощью Минибуфера
@cindex minibuffer input, reading text strings

  Самый простой примитив для ввода в минибуфер - это
@code{read-from-minibuffer}, который можно использовать для чтения строки
или объекта Lisp в текстовой форме.  Функция @code{read-regexp} используется
для чтения регулярных выражений (@pxref{Regular Expressions}), которые
представляют собой особый вид строк.  Также есть специализированные функции
для чтения команд, переменных, имен файлов и т. Д.@: (@pxref{Completion}).

  В большинстве случаев не требуется вызывать функции ввода минибуфера в
середине функции Lisp.  Вместо этого выполняется весь ввод минибуфера как
часть чтения аргументов команды в спецификации @code{interactive}.
@xref{Defining Commands}.

@defun read-from-minibuffer prompt &optional initial keymap read history default inherit-input-method
Эта функция - наиболее общий способ получить ввод из минибуфера.  По
умолчанию она принимает произвольный текст и возвращает его в виде строки;
однако, если @var{read} не-@code{nil}, то он использует @code{read} для
преобразования текста в объект Lisp (@pxref{Input Functions}).

Первое, что делает эта функция, - это активирует минибуфер и отображает его
с @var{prompt} (которая должна быть строкой) в качестве приглашения.  Затем
пользователь может редактировать текст в минибуфере.

Когда пользователь вводит команду для выхода из минибуфера,
@code{read-from-minibuffer} создает возвращаемое значение из текста в
минибуфере.  Обычно возвращается строка, содержащую этот текст.  Однако,
если @var{read} равен не-@code{nil}, @code{read-from-minibuffer}, считывает
текст и возвращает полученный объект Lisp, без оценки.
(@xref{Input Functions}, для информации о чтении.)

Аргумент @var{default} указывает значения по умолчанию, которые будут
доступны через команды истории.  Это должна быть строка, список строк или
@code{nil}.  Строка или строки становятся ``будущей историей'' минибуфера,
доступной пользователю с @kbd{M-n}.

Если @var{read} равен не-@code{nil}, тогда @var{default} также используется
как вход для @code{read}, если пользователь вводит пустой ввод.  Если
@var{default} - это список строк, первая строка используется в качестве
входных.  Если @var{default} равен @code{nil}, пустой ввод приводит к ошибке
@code{end-of-file}.
Однако в обычном случае (где @var{read} - @code{nil})
@code{read-from-minibuffer} игнорирует @var{default}, когда пользователь
вводит пустой ввод и возвращает пустую строку @code{""}.  В этом отношении
он отличается от всех других функций ввода минибуфера в этой главе.

Если @var{keymap} не-@code{nil}, эта ключевая карта является локальной
картой для использования в минибуфере.  Если @var{keymap} опущен или
@code{nil}, значение @code{minibuffer-local-map} используется как карта.
Указание карты - самый важный способ настроить минибуфер для различных
приложений, таких как завершение.

Аргумент @var{history} указывает переменную списка истории, используемую для
сохранения ввода и команд истории, используемых в минибуфере.  По умолчанию
используется @code{minibuffer-history}.  При желании также можно указать
начальную позицию в списке истории.  @xref{Minibuffer History}.

Если переменная @code{minibuffer-allow-text-properties} - не-@code{nil}, то
возвращаемая строка включает все текстовые свойства, которые присутствовали
в минибуфере.  В противном случае все свойства текста удаляются при возврате
значения.

@vindex minibuffer-prompt-properties
Свойства текста в @code{minibuffer-prompt-properties} применяются к
подсказке.  По умолчанию этот список свойств определяет отображение,
используемое для приглашения.  Если оно есть, применяется к концу списка
отображения и объединяется перед отображением.

Если пользователь хочет полностью контролировать внешний вид подсказки,
наиболее удобный способ сделать это - указать отображение @code{default} в
конце всех списков отображений.  Например:

@lisp
(read-from-minibuffer
 (concat
  (propertize "Bold" 'face '(bold default))
  (propertize " and normal: " 'face '(default))))
@end lisp

Если аргумент @var{inherit-input-method} не-@code{nil}, то минибуфер
наследует текущий метод ввода (@pxref{Input Methods}) и настройку
@code{enable-multibyte-characters} (@pxref{Text Representations}) от того,
какой буфер был текущим до входа в минибуфер.

Использование @var{initial} в основном не рекомендуется; рекомендуется
использовать значение не-@code{nil} только вместе с указанием cons-ячейки
для @var{history}.  @xref{Initial Input}.
@end defun

@defun read-string prompt &optional initial history default inherit-input-method
Эта функция считывает строку из минибуфера и возвращает ее.  Аргументы
@var{prompt}, @var{initial}, @var{history} и @var{inherit-input-method}
используются как в @code{read-from-minibuffer}.  Используемая карта
@code{minibuffer-local-map}.

Необязательный аргумент @var{default} используется так же, как в
@code{read-from-minibuffer}, за исключением того, что, если установлено
не-@code{nil}, также указывает значение по умолчанию, возвращаемое, если
пользователь отказался от ввода.  Как и в @code{read-from-minibuffer}, это
должна быть строка, список строк или @code{nil}, что эквивалентно пустой
строке.  Когда @var{default} является строкой, эта строка является значением
по умолчанию.  Когда это список строк, первая строка является значением по
умолчанию.  (Все эти строки доступны пользователю в файле
``будущая история минибуфера''.)

Эта функция работает путем вызова функции @code{read-from-minibuffer}:

@smallexample
@group
(read-string @var{prompt} @var{initial} @var{history} @var{default} @var{inherit})
@equiv{}
(let ((value
       (read-from-minibuffer @var{prompt} @var{initial} nil nil
                             @var{history} @var{default} @var{inherit})))
  (if (and (equal value "") @var{default})
      (if (consp @var{default}) (car @var{default}) @var{default})
    value))
@end group
@end smallexample
@end defun

@defun read-regexp prompt &optional defaults history
Эта функция считывает регулярное выражение в виде строки из минибуфера и
возвращает ее.  Если строка приглашения минибуфера @var{prompt} не
заканчивается на @samp{:} (за которым следует необязательный пробел),
функция добавляет @samp{: } в конец, которому предшествует возвращаемое
значение по умолчанию (смотреть ниже), если оно не пустое.

Необязательный аргумент @var{defaults} управляет значением по умолчанию,
возвращаемым, если пользователь отказался от ввода, и должен быть одним из
следующих: строка; @code{nil}, что эквивалентно пустой строке; список строк;
или символ.

Если @var{defaults} является символом, @code{read-regexp} обращается к
значению переменной @code{read-regexp-defaults-function} (смотреть ниже), а
если это не-@code{nil}, использует его вместо @var{defaults}.  Значение в
этом случае должно быть либо:

@itemize @minus
@item
@code{regexp-history-last}, что означает использование первого элемента
соответствующего списка истории минибуфера (смотреть ниже).

@item
Функция без аргументов, возвращаемое значение которой (которое должно быть
@code{nil}, строкой или списком строк) становится значением @var{defaults}.
@end itemize

@code{read-regexp} теперь гарантирует, что результатом обработки
@var{defaults} является список (т.е. если значение - @code{nil} или строка,
преобразует его в список из одного элемента).  Затем к этому списку
@code{read-regexp} добавляет несколько потенциально полезных кандидатов для
ввода.  Это:

@itemize @minus
@item
Слово или символ в точке.
@item
Последнее регулярное выражение, использованное в инкрементальном поиске.
@item
Последняя строка, используемая в инкрементальном поиске.
@item
Последняя строка или шаблон, использованный в командах замены запроса.
@end itemize

Теперь у функции есть список регулярных выражений, которые она передает
@code{read-from-minibuffer} для получения пользовательского ввода.  Первый
элемент списка - результат по умолчанию в случае пустого ввода.  Все
элементы списка доступны пользователю в виде списка ``будущая история
минибуфера'' (@pxref{Minibuffer History, future list,,
emacs, The GNU Emacs Manual}).

Необязательный аргумент @var{history}, если не-@code{nil}, является
символом, определяющим список истории минибуфера для использования
(@pxref{Minibuffer History}).  Если опущен или @code{nil}, список истории
по умолчанию будет @code{regexp-history}.
@end defun

@defopt read-regexp-defaults-function
Функция @code{read-regexp} может использовать значение этой переменной для
определения своего списка регулярных выражений по умолчанию.  Если
не-@code{nil}, значение этой переменной должно быть либо:

@itemize @minus
@item
Символ @code{regexp-history-last}.

@item
Функция без аргументов, возвращающая @code{nil}, строку или список строк.
@end itemize

@noindent
Смотреть @code{read-regexp} выше, чтобы узнать, как эти значения
используются.
@end defopt

@defvar minibuffer-allow-text-properties
Если эта переменная - @code{nil}, то @code{read-from-minibuffer} и
@code{read-string} удаляют все текстовые свойства из ввода минибуфера перед
его возвратом.  Однако @code{read-no-blanks-input} (смотреть ниже), а также
@code{read-minibuffer} и связанные функции (@pxref {Object from Minibuffer ,, Reading Lisp Objects With the Minibuffer}) и все функции, которые
выполняют ввод минибуфера с завершением, безоговорочно отбрасывают свойства
текста, независимо от значение этой переменной.
@end defvar

@defvar minibuffer-local-map
Это @anchor{Definition of minibuffer-local-map}
@c избегать разрыва страницы при привязке; работать с дефицитом Texinfo
является локальной картой по умолчанию для чтения из минибуфера.  По
умолчанию делает следующие привязки:

@table @asis
@item @kbd{C-j}
@code{exit-minibuffer}

@item @key{RET}
@code{exit-minibuffer}

@item @kbd{C-g}
@code{abort-recursive-edit}

@item @kbd{M-n}
@itemx @key{DOWN}
@code{next-history-element}

@item @kbd{M-p}
@itemx @key{UP}
@code{previous-history-element}

@item @kbd{M-s}
@code{next-matching-history-element}

@item @kbd{M-r}
@code{previous-matching-history-element}

@ignore
@c Does not seem worth/appropriate mentioning.
@item @kbd{C-@key{TAB}}
@code{file-cache-minibuffer-complete}
@end ignore
@end table
@end defvar

@c In version 18, initial is required
@c Emacs 19 feature
@defun read-no-blanks-input prompt &optional initial inherit-input-method
Эта функция считывает строку из минибуфера, но не позволяет использовать
пробельные символы как часть ввода: вместо этого эти символы завершают ввод.
Аргументы @var{prompt}, @var{initial} и @var{inherit-input-method}
используются как в @code{read-from-minibuffer}.

Это упрощенный интерфейс для функции @code{read-from-minibuffer}, который
передает значение карты ключей @code{minibuffer-local-ns-map} в качестве
аргумента @var{keymap} для этой функции.  Поскольку карта
@code{minibuffer-local-ns-map} не выполняет повторное связывание @kbd{C-q},
в @emph{is} можно поместить пробел в строку, заключив ее в кавычки.

Эта функция отбрасывает текстовые свойства независимо от значения
@code{minibuffer-allow-text-properties}.

@smallexample
@group
(read-no-blanks-input @var{prompt} @var{initial})
@equiv{}
(let (minibuffer-allow-text-properties)
  (read-from-minibuffer @var{prompt} @var{initial} minibuffer-local-ns-map))
@end group
@end smallexample
@end defun

@c Slightly unfortunate name, suggesting it might be related to the
@c Nextstep port...
@defvar minibuffer-local-ns-map
Эта встроенная переменная - ключевая карта, используемая в качестве
локальной карты минибуфера в функции @code{read-no-blanks-input}.  По
умолчанию делает следующие привязки в дополнение к привязкам
@code{minibuffer-local-map}:

@table @asis
@item @key{SPC}
@cindex @key{SPC} in minibuffer
@code{exit-minibuffer}

@item @key{TAB}
@cindex @key{TAB} in minibuffer
@code{exit-minibuffer}

@item @kbd{?}
@cindex @kbd{?} in minibuffer
@code{self-insert-and-exit}
@end table
@end defvar

@node Object from Minibuffer
@section Чтение Объектов Lisp с Помощью Минибуфера
@cindex minibuffer input, reading lisp objects

  В этом разделе описаны функции для чтения объектов Lisp с помощью
минибуфера.

@defun read-minibuffer prompt &optional initial
Эта функция читает объект Lisp с помощью минибуфера и возвращает его без
оценки.  Аргументы @var{prompt} и @var{initial} используются как в
@code{read-from-minibuffer}.

Это упрощенный интерфейс к функции @code{read-from-minibuffer}:

@smallexample
@group
(read-minibuffer @var{prompt} @var{initial})
@equiv{}
(let (minibuffer-allow-text-properties)
  (read-from-minibuffer @var{prompt} @var{initial} nil t))
@end group
@end smallexample

Вот пример, в котором предоставляется строка @code{"(testing)"} в качестве
начального ввода:

@smallexample
@group
(read-minibuffer
 "Enter an expression: " (format "%s" '(testing)))

;; @r{Вот как отображается минибуфер:}
@end group

@group
---------- Buffer: Minibuffer ----------
Enter an expression: (testing)@point{}
---------- Buffer: Minibuffer ----------
@end group
@end smallexample

@noindent
Пользователь может сразу ввести @key{RET}, чтобы использовать исходный ввод
по умолчанию, или может отредактировать ввод.
@end defun

@defun eval-minibuffer prompt &optional initial
Эта функция читает выражение Lisp с помощью минибуфера, оценивает его, а
затем возвращает результат.  Аргументы @var{prompt} и @var{initial}
используются как в @code{read-from-minibuffer}.

Эта функция просто оценивает результат вызова @code{read-minibuffer}:

@smallexample
@group
(eval-minibuffer @var{prompt} @var{initial})
@equiv{}
(eval (read-minibuffer @var{prompt} @var{initial}))
@end group
@end smallexample
@end defun

@defun edit-and-eval-command prompt form
Эта функция читает выражение Лиспа в минибуфере, оценивает его, а затем
возвращает результат.  Разница между этой командой и @code{eval-minibuffer}
состоит в том, что здесь начальный @var{form} не является необязательным и
рассматривается как объект Lisp, который должен быть преобразован в печатное
представление, а не как строка текста.  Он печатается с @code{prin1},
поэтому, если это строка, в исходном тексте появляются двойные кавычки
(@samp{"}).  @xref{Output Functions}.

В следующем примере предлагается пользователю выражение с исходным текстом,
которое уже является допустимой формой.:

@smallexample
@group
(edit-and-eval-command "Please edit: " '(forward-word 1))

;; @r{После вычисления предыдущего выражения}
;;   @r{в минибуфере появляется следующее:}
@end group

@group
---------- Buffer: Minibuffer ----------
Please edit: (forward-word 1)@point{}
---------- Buffer: Minibuffer ----------
@end group
@end smallexample

@noindent
Сразу же набор @key{RET}, выведет из минибуфера и оценит выражение, тем
самым переместив точку на одно слово вперед.
@end defun

@node Minibuffer History
@section История Минибуфера
@cindex minibuffer history
@cindex history list

  @dfn{История Минибуфера} записывает предыдущие входные данные минибуфера,
чтобы пользователь мог использовать их повторно.  Это переменная, значение
которой представляет собой список строк (предыдущие входные данные), начиная
с самых последних.

  Есть много отдельных списков истории минибуфера, используемых для разных
типов входных данных.  Задача программиста на Lisp - указать правильный
список истории для каждого использования минибуфера.

  Указывается список истории минибуфера с необязательным аргументом
@var{history} для @code{read-from-minibuffer} или @code{completing-read}.
Вот возможные значения:

@table @asis
@item @var{variable}
Использовать @var{variable} (символ) в качестве списка истории.

@item (@var{variable} . @var{startpos})
Использовать @var{variable} (символ) в качестве списка истории и
предположить, что начальная позиция истории - @var{startpos}
(неотрицательное целое число).

Указание 0 для @var{startpos} эквивалентно простому указанию символа
@var{variable}.  @code{previous-history-element} отобразит самый последний
элемент списка истории в минибуфере.  Если указано положительное значение
@var{startpos}, функции истории минибуфера будут вести себя так, как если бы
@code{(elt @var{variable} (1- @var{startpos}))} был элементом истории,
отображаемым в минибуфере в данный момент.

Для согласованности также потребуется указать этот элемент истории в
качестве начального содержимого минибуфера, используя аргумент @var{initial}
для входной функции минибуфера (@pxref{Initial Input}).
@end table

  Если указать @var{history}, будет использоваться список истории по
умолчанию @code{minibuffer-history}.  Другие стандартные списки истории
смотреть ниже.  Также можно создать свою собственную переменную списка
истории; просто инициализировать её как @code{nil} перед первым
использованием.

  Как @code{read-from-minibuffer} так и @code{completing-read} автоматически
добавляют новые элементы в список истории и предоставляют команды,
позволяющие пользователю повторно использовать элементы списка.
Единственное, что нужно сделать программе для использования списка истории,
- это инициализировать его и передать его имя входным функциям, когда
потребуется.  Но можно безопасно изменять список вручную, когда функции
ввода минибуфера его не используют.

  Функции Emacs, которые добавляют новый элемент в список истории, также
могут удалять старые элементы, если список становится слишком длинным.
Переменная @code{history-length} определяет максимальную длину для
большинства списков истории.  Чтобы указать другую максимальную длину для
конкретного списка истории, помещается длина в свойство
@code{history-length} символа списка истории.  Переменная
@code{history-delete-duplicates} указывает, нужно ли удалять дубликаты в
истории.

@defun add-to-history history-var newelt &optional maxelt keep-all
Эта функция добавляет новый элемент @var{newelt}, если это не пустая строка,
к списку истории, хранящемуся в переменной @var{history-var}, и возвращает
обновленный список истории.  Ограничивает длину списка значением
@var{maxelt} (если не-@code{nil}) или @code{history-length} (описано ниже).
Возможные значения @var{maxelt} имеют то же значение, что и значения
@code{history-length}.

Обычно @code{add-to-history} удаляет повторяющиеся элементы из списка
истории, если @code{history-delete-duplicates} равен не-@code{nil}.  Однако,
если @var{keep-all} имеет значение не-@code{nil}, это говорит о том, что не
следует удалять дубликаты и добавлять @var{newelt} в список, даже если он
пустой.
@end defun

@defvar history-add-new-input
Если значение этой переменной - @code{nil}, стандартные функции, считывающие
из минибуфера, не добавляют новые элементы в список истории.  Это позволяет
программам на Lisp явно управлять историей ввода с помощью
@code{add-to-history}.  Значение по умолчанию - @code{t}.
@end defvar

@defopt history-length
Значение этой переменной определяет максимальную длину для всех списков
истории, которые не указывают свои собственные максимальные длины.  Если
значение равно @code{t}, это означает, что максимума нет (не удалять старые
элементы).  Если символ переменной списка истории имеет свойство
не-@code{nil} @code{history-length}, он переопределяет эту переменную для
этого конкретного списка истории.
@end defopt

@defopt history-delete-duplicates
Если значение этой переменной - @code{t}, это означает, что при добавлении
нового элемента истории все предыдущие идентичные элементы удаляются.
@end defopt

  Вот некоторые из стандартных переменных списка истории минибуфера:

@defvar minibuffer-history
Список истории по умолчанию для ввода истории минибуфера.
@end defvar

@defvar query-replace-history
Список истории аргументов для @code{query-replace} (и подобных аргументов
для других команд).
@end defvar

@defvar file-name-history
Список истории для аргументов имени файла.
@end defvar

@defvar buffer-name-history
Список истории для аргументов имени буфера.
@end defvar

@defvar regexp-history
Список истории аргументов регулярного выражения.
@end defvar

@defvar extended-command-history
Список истории аргументов, которые являются именами расширенных команд.
@end defvar

@defvar shell-command-history
Список истории аргументов, которые являются командами оболочки.
@end defvar

@defvar read-expression-history
Список истории аргументов, которые нужно оценить выражениями Lisp.
@end defvar

@defvar face-name-history
Список истории аргументов, которые являются фейсами.
@end defvar

@c Less common: coding-system-history, input-method-history,
@c command-history, grep-history, grep-find-history,
@c read-envvar-name-history, setenv-history, yes-or-no-p-history.

@node Initial Input
@section Initial Input

Некоторые функции для ввода минибуфера имеют аргумент @var{initial}.  Это в
основном устаревшая функция для указания, что минибуфер должен начинаться с
определенного текста, а не с пустого, как обычно.

Если @var{initial} является строкой, минибуфер начинает содержать текст
строки с точкой в конце, когда пользователь начинает редактировать текст.
Если пользователь просто набирает @key{RET} для выхода из минибуфера, он
будет использовать начальную входную строку для определения возвращаемого
значения.

@strong{Не рекомендуем использовать значение не-@code{nil} для @var{initial}}, потому что первоначальный ввод - это навязчивый интерфейс.  Списки
истории и значения по умолчанию предоставляют гораздо более удобный способ
предложить пользователю полезные данные по умолчанию.

Есть только одна ситуация, когда потребуется указать строку для аргумента
@var{initial}.  Это когда указывается cons-ячейка для аргумента
@var{history}.  @xref{Minibuffer History}.

@var{initial} также может быть cons-ячейкой вида
@code{(@var{string} . @var{position})}. Это означает вставить @var{string} в
минибуфер, но поставить точку на @var{position} в тексте строки.

Как историческая случайность, @var{position} было реализовано в разных
функциях непоследовательно.  В @code{completing-read} значение
@var{position} интерпретируется как нулевое начало; то есть значение 0
означает начало строки, 1 означает следующий после первого символа и т.д.  В
@code{read-minibuffer} и других незавершенных функциях ввода минибуфера,
которые поддерживают этот аргумент, 1 означает начало строки, 2 означает
следующий после первого символа и т. д.

Использование cons-ячейки в качестве значения аргументов @var{initial} не
рекомендуется.

@node Completion
@section Завершение
@cindex completion

  @dfn{Завершение} - это функция, которая заполняет оставшуюся часть имени,
начиная с его аббревиатуры.  Завершение работает путем сравнения ввода
пользователя со списком допустимых имен и определения того, какая часть
имени определяется однозначно тем, что пользователь ввел.  Например, когда
набирается @kbd{C-x b} (@code{switch-to-buffer}), а затем
@c "Это тот английский язык, с которым я не буду."
набирается первых несколько букв имени буфера, на который требуется
переключиться, а затем набирается @key{TAB} (@code{minibuffer-complete}),
Emacs расширяет имя, насколько это возможно.

  Стандартные команды Emacs предлагают завершение имен символов, файлов,
буферов и процессов; с помощью функций в этом разделе вы можете реализовать
завершение для других типов имен.

  Функция @code{try-completion} является основным примитивом для завершения:
возвращает наиболее длинное определенное завершение данной начальной строки
с заданным набором строк для сопоставления.

  Функция @code{completing-read} предоставляет интерфейс более высокого
уровня для завершения.  Вызов @code{completing-read} указывает, как
определить список допустимых имен.  Затем функция активирует минибуфер с
локальной ключевой картой, которая связывает несколько ключей с командами,
полезными для завершения.  Другие функции предоставляют удобные простые
интерфейсы для чтения определенных видов имен с завершением.

@menu
* Basic Completion::       Низкоуровневые функции для завершения строк.
* Minibuffer Completion::  Вызов минибуфера с завершением.
* Completion Commands::    Команды минибуфера, выполняющие завершение.
* High-Level Completion::  Удобные частные случаи завершения
                             (чтение имен буферов, имен переменных и т. д.).
* Reading File Names::     Использование завершения для чтения имен файлов
                             и команд оболочки.
* Completion Variables::   Переменные, контролирующие поведение завершения.
* Programmed Completion::  Написание собственной функции завершения.
* Completion in Buffers::  Завершение текста в обычных буферах.
@end menu

@node Basic Completion
@subsection Basic Completion Functions

  Следующие функции завершения сами по себе не имеют ничего общего с
минибуферами.  Описываются здесь, чтобы оставатся рядом с функциями
завершения более высокого уровня, которые действительно используют
минибуфер.

@defun try-completion string collection &optional predicate
Эта функция возвращает самую длинную общую подстроку из всех возможных
завершений @var{string} в @var{collection}.

@cindex completion table
@var{collection} называется @dfn{таблицей завершения}.  Её значение должно
быть списком строк или cons-ячеек, obarray, хэш-таблицей или функцией
завершения.

@code{try-completion} сравнивает @var{string} с каждым из допустимых
завершений, указанных в таблице завершения.  Если допустимых завершений не
найдено, возвращается @code{nil}.  Если есть только одно совпадающее
завершение, и совпадение точное, возвращается @code{t}.  В противном случае
возвращается самая длинная начальную последовательность, общая для всех
возможных совпадений.

Если @var{collection} является списком, допустимые завершения определяются
элементами списка, каждый из которых должен быть либо строкой, либо
cons-ячейкой, @sc{car} которой является либо строкой, либо символом (символ
преобразуется в строку с помощью @code{symbol-name} ).  Если список содержит
элементы любого другого типа, они игнорируются.

@cindex obarray in completion
Если @var{collection} является obarray (@pxref{Creating Symbols}), имена
всех символов в obarray образуют набор допустимых дополнений.

Если @var{collection} - хеш-таблица, то ключи, которые являются строками или
символами, являются возможными дополнениями.  Остальные ключи игнорируются.

Также можно использовать функцию как @var{collection}.  Тогда функция несет
полную ответственность за выполнение; @code{try-completion} возвращает то,
что возвращает эта функция.  Функция вызывается с тремя аргументами:
@var{string}, @var{predicate} и @code{nil} (третий аргумент предназначен для
того, чтобы одну и ту же функцию можно было использовать в
@code{all-completions} и выполнять соответствующие действия в любом случае).
@xref{Programmed Completion}.

Если аргумент @var{predicate} - не-@code{nil}, он должен быть функцией
одного аргумента, если @var{collection} не является хеш-таблицей, и в этом
случае он должен быть функцией двух аргументов.  Он используется для
проверки каждого возможного совпадения, и совпадение принимается только в
том случае, если @var{predicate} возвращает не-@code{nil}.  Аргумент,
передаваемый @var{predicate}, является либо строкой, либо cons-ячейкой
(@sc{car} которой является строкой) из списка, либо символом (@emph{не} имя
символа) из obarray.  Если @var{collection} является хеш-таблицей,
@var{predicate} вызывается с двумя аргументами: строковым ключом и связанным
с ним значением.

Кроме того, чтобы быть приемлемым, завершение также должно соответствовать
всем регулярным выражениям в @code{completion-regexp-list}.  (Если
@var{collection} не является функцией, в этом случае эта функция должна
сама обрабатывать @code{completion-regexp-list}.)

В первом из следующих примеров строке @samp{foo} соответствуют три из alist
@sc{car}.  Все совпадения начинаются с символов @samp{fooba}, то это
результат.  Во втором примере есть только одно возможное совпадение, и оно
точное, поэтому возвращаемое значение - @code{t}.

@smallexample
@group
(try-completion
 "foo"
 '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4)))
     @result{} "fooba"
@end group

@group
(try-completion "foo" '(("barfoo" 2) ("foo" 3)))
     @result{} t
@end group
@end smallexample

В следующем примере многие символы начинаются с символов @samp{forw}, и все
они начинаются со слова @samp{forward}.  В большинстве символов после этого
следует @samp{-}, но не во всех, поэтому можно заполнить не более
@samp{forward}.

@smallexample
@group
(try-completion "forw" obarray)
     @result{} "forward"
@end group
@end smallexample

Наконец, в следующем примере только два из трех возможных совпадений
передают предикат @code{test} (строка @samp{foobaz} слишком короткая).  Оба
они начинаются со строки @samp{foobar}.

@smallexample
@group
(defun test (s)
  (> (length (car s)) 6))
     @result{} test
@end group
@group
(try-completion
 "foo"
 '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4))
 'test)
     @result{} "foobar"
@end group
@end smallexample
@end defun

@c Удален устаревший аргумент nospace.
@defun all-completions string collection &optional predicate
Эта функция возвращает список всех возможных завершений @var{string}.
Аргументы этой функции
@c (Помимо @var{nospace})
такие же, как и у @code{try-completion}, и она использует
@code{completion-regexp-list} так же, как @code{try-completion}.

@ignore
Необязательный аргумент @var{nospace} устарел.  Если это не-@code{nil},
завершения, начинающиеся с пробела, игнорируются, если @var{string} не
начинается с пробела..
@end ignore

Если @var{collection} - функция, она вызывается с тремя аргументами:
@var{string}, @var{predicate} и @code{t}; тогда @code{all-completions}
возвращает то, что возвращает функция.  @xref{Programmed Completion}.

Вот пример использования функции @code{test}, показанной в примере для
@code{try-completion}:

@smallexample
@group
(defun test (s)
  (> (length (car s)) 6))
     @result{} test
@end group

@group
(all-completions
 "foo"
 '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4))
 'test)
     @result{} ("foobar1" "foobar2")
@end group
@end smallexample
@end defun

@defun test-completion string collection &optional predicate
@anchor{Definition of test-completion}
Эта функция возвращает не-@code{nil}, если @var{string} - допустимая
альтернатива завершения, заданная @var{collection} и @var{predicate}.
Аргументы такие же, как и в @code{try-completion}.  Например, если
@var{collection} - это список строк, это верно, если @var{string} появляется
в списке и @var{predicate} удовлетворяется.

Эта функция использует @code{completion-regexp-list} так же, как
@code{try-completion}.

Если @var{predicate} равен не-@code{nil} и @var{collection} содержит
несколько строк, которые равны друг другу, как определено
@code{compare-strings} в соответствии с @code{completion-ignore-case}, тогда
@var{predicate} должен принимать либо все, либо ни одну из них.  В противном
случае возвращаемое значение @code{test-completion} по существу
непредсказуемо.

Если @var{collection} - функция, она вызывается с тремя аргументами,
значениями @var{string}, @var{predicate} и @code{lambda}; что бы ни
вернулось, возвращается @code{test-completion}.
@end defun

@defun completion-boundaries string collection predicate suffix
Эта функция возвращает границы поля, в котором будет работать
@var{collection}, при условии, что @var{string} содержит текст до точки, а
@var{suffix} содержит текст после точки.

Обычно завершение выполняется для всей строки, поэтому для всех обычных
коллекций всегда будет возвращаться @code{(0 . (length @var{suffix}))}.  Но
более сложное завершение, такое как завершение файлов, выполняется по одному
полю за раз.  Например, завершение @code{"/usr/sh"} будет включать
@code{"/usr/share/"}, но не @code{"/usr/share/doc"}, даже если
@code{"/usr/share/doc"} существует.  Также @code{all-completions} на
@code{"/usr/sh"} не будет включать @code{"/usr/share/"}, а только
@code{"share/"}.  Таким образом, если @var{string} является @code{"/usr/sh"}
и @var{suffix} это @code{"e/doc"}, @code{completion-boundaries} вернет
@code{(5 . 1)}, который говорит, что @var{collection} будет возвращать
только информацию о завершении, которая относится к области после
@code{"/usr/"} и до @code{"/doc"}.
@end defun

Если хранится список завершения в переменной, потребкется пометить эту
переменную как опасную, присвоив ей свойство не-@code{nil} в
@code{risky-local-variable}.  @xref{File Local Variables}.

@defvar completion-ignore-case
Если значение этой переменной - не-@code{nil}, не учитывать регистр при
завершении.  В @code{read-file-name} эта переменная заменяется
@code{read-file-name-completion-ignore-case} (@pxref{Reading File Names});
внутри @code{read-buffer} заменяется на
@code{read-buffer-completion-ignore-case} (@pxref{High-Level Completion}).
@end defvar

@defvar completion-regexp-list
Это список регулярных выражений.  Функции завершения считают завершение
приемлемым, только если оно соответствует всем регулярным выражениям этого
списка, при этом @code{case-fold-search} (@pxref{Searching and Case})
привязан к значению @code{completion-ignore-case}.
@end defvar

@defmac lazy-completion-table var fun
Этот макрос предоставляет способ инициализировать переменную @var{var} как
коллекцию для ленивого завершения, не вычисляя ее фактическое содержимое,
пока оно не понадобится.  Используется этот макрос для создания значения,
которое сохраняется в @var{var}.  Фактическое вычисление правильного
значения выполняется в первый раз, когда выполняется завершение с помощью
@var{var}.  Это делается путем вызова @var{fun} без аргументов.
Возвращаемое значение @var{fun} становится постоянным значением @var{var}.

Вот пример:

@smallexample
(defvar foo (lazy-completion-table foo make-my-alist))
@end smallexample
@end defmac

@c FIXME?  completion-table-with-context?
@findex completion-table-case-fold
@findex completion-table-in-turn
@findex completion-table-merge
@findex completion-table-subvert
@findex completion-table-with-quoting
@findex completion-table-with-predicate
@findex completion-table-with-terminator
@cindex completion table, modifying
@cindex completion tables, combining
Есть несколько функций, которые берут существующую таблицу завершения и
возвращают измененную версию.  @code{completion-table-case-fold} возвращает
таблицу без учета регистра.  @code{completion-table-in-turn} и
@code{completion-table-merge} объединяет несколько таблиц ввода по-разному.
@code{completion-table-subvert} изменяет таблицу, чтобы использовать другой
начальный префикс.  @code{completion-table-with-quoting} возвращает таблицу,
подходящую для работы с цитируемым текстом.
@code{completion-table-with-predicate} фильтрует таблицу с помощью функции
предиката.  @code{completion-table-with-terminator} добавляет завершающую
строку.


@node Minibuffer Completion
@subsection Завершение и Минибуфер
@cindex minibuffer completion
@cindex reading from minibuffer with completion

  В этом разделе описывается базовый интерфейс для чтения из минибуфера с
  завершением.

@defun completing-read prompt collection &optional predicate require-match initial history default inherit-input-method
Эта функция считывает строку в минибуфере, помогая пользователю обеспечивать
завершение.  Активирует минибуфер с приглашением @var{prompt}, которое
должно быть строкой.

Фактическое завершение выполняется путем передачи таблицы завершения
@var{collection} и предиката завершения @var{predicate} в функцию
@code{try-completion} (@pxref{Basic Completion}).  Это происходит в
некоторых командах, привязанных к локальным ключевым картам, используемым
для завершения.  Некоторые из этих команд также вызывают
@code{test-completion}.  Таким образом, если @var{predicate} равен
не-@code{nil}, это должно быть совместимо с @var{collection} и
@code{completion-ignore-case}.
@xref{Definition of test-completion}.

@xref{Programmed Completion}, для подробных требований, когда
@var{collection} является функцией.

Значение необязательного аргумента @var{require-match} определяет, как
пользователю можно выйти из минибуфера:

@itemize @bullet
@item
Если @code{nil}, обычные команды выхода из минибуфера работают независимо
от ввода в минибуфер.

@item
Если @code{t}, обычные команды выхода из минибуфера не завершатся, пока ввод
не завершится до элемента @var{collection}.

@item
Если @code{confirm}, пользователь может выйти с любым вводом, но
запрашивается подтверждение, если ввод не является элементом
@var{collection}.

@item
Если @code{confirm-after-completion}, пользователь может выйти с любым
вводом, но запрашивается подтверждение, была ли предыдущая команда командой
завершения (то есть одна из команд в @code{minibuffer-confirm-exit-commands}
) и полученный ввод не является элементом @var{collection}.  @xref{Completion Commands}.

@item
Любое другое значение @var{require-match} ведет себя как @code{t}, за
исключением того, что команды выхода не завершаются, если выполняется
завершение.
@end itemize

Однако пустой ввод всегда разрешен, независимо от значения
@var{require-match}; в этом случае @code{completing-read} возвращает первый
элемент @var{default}, если это список; @code{""}, если @var{default} -
@code{nil}; или @var{default}.  Строка или строки в @var{default} также
доступны пользователю через команды истории.

Функция @code{completing-read} использует
@code{minibuffer-local-completion-map} в качестве ключевой карты, если
@var{require-match} равно @code{nil}, и использует
@code{minibuffer-local-must-match-map}, если @var{require-match} равно
не-@code{nil}.  @xref{Completion Commands}.

Аргумент @var{history} указывает, какую переменную списка истории
использовать для сохранения ввода и для команд истории минибуфера.  По
умолчанию используется @code{minibuffer-history}.
@xref{Minibuffer History}.

Аргумент @var{initial} в основном устарел; рекомендуется использовать
значение не-@code{nil} только вместе с указанием cons-ячейки для
@var{history}.  @xref{Initial Input}.  Для ввода по умолчанию используется
вместо этого @var{default}.

Если аргумент @var{inherit-input-method} - не-@code{nil}, то минибуфер
наследует текущий метод ввода (@pxref{Input Methods}) и настройку
@code{enable-multibyte-characters} (@pxref{Text Representations}) от того
буфера, который был текущим до входа в минибуфер.

Если переменная @code{completion-ignore-case} - не-@code{nil}, завершение
игнорирует регистр при сравнении ввода с возможными совпадениями.
@xref{Basic Completion}.  В этом режиме работы @var{predicate} также должен
игнорировать регистр, иначе получатся неожиданные результаты.

Вот пример использования @code{completing-read}:

@smallexample
@group
(completing-read
 "Complete a foo: "
 '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4))
 nil t "fo")
@end group

@group
;; @r{После вычисления предыдущего выражения в минибуфере}
;;   @r{ появляется следующее:}

---------- Buffer: Minibuffer ----------
Complete a foo: fo@point{}
---------- Buffer: Minibuffer ----------
@end group
@end smallexample

@noindent
Если пользователь затем набирает @kbd{@key{DEL} @key{DEL} b @key{RET}},
@code{completing-read} возвращает @code{barfoo}.

Функция @code{completing-read} связывает переменные для передачи информации
командам, которые фактически выполняют завершение.  Они описаны в следующем
разделе.
@end defun

@defvar completing-read-function
Значением этой переменной должна быть функция, которая вызывается
@code{completing-read} для выполнения своей работы.  Должны приниматься те
же аргументы, что и @code{completing-read}.  Это может быть связано с другой
функцией, чтобы полностью переопределить нормальное поведение
@code{completing-read}.
@end defvar

@node Completion Commands
@subsection Команды Минибуфера, Выполняющие Завершение

  В этом разделе описываются ключевые карты, команды и параметры
пользователя, используемые в минибуфере для завершения.

@defvar minibuffer-completion-table
Значение этой переменной - таблица завершения (@pxref{Basic Completion}),
используемая для завершения в минибуфере.  Это глобальная переменная,
которая содержит то, что @code{completing-read} передает в
@code{try-completion}.  Это используется командами завершения минибуфера,
такими как @code{minibuffer-complete-word}.
@end defvar

@defvar minibuffer-completion-predicate
Значение этой переменной - это предикат, который @code{completing-read}
передает @code{try-completion}.  Переменная также используется другими
функциями завершения минибуфера.
@end defvar

@defvar minibuffer-completion-confirm
Эта переменная определяет, запрашивает ли Emacs подтверждение перед выходом
из минибуфера; @code{completing-read} связывает эту переменную, а функция
@code{minibuffer-complete-and-exit} проверяет значение перед выходом.  Если
значение равно @code{nil}, подтверждение не требуется.  Если значение равно
@code{confirm}, пользователь может выйти с вводом, который не является
допустимой альтернативой завершения, но Emacs запросит подтверждение.  Если
значение равно @code{confirm-after-completion}, пользователь может выйти с
вводом, который не является допустимой альтернативой завершения, но Emacs
запрашивает подтверждение, отправил ли пользователь ввод сразу после любой
из команд завершения в @code{minibuffer-confirm-exit-commands}.
@end defvar

@defvar minibuffer-confirm-exit-commands
Эта переменная содержит список команд, которые заставляют Emacs запрашивать
подтверждение перед выходом из минибуфера, если аргумент @var{require-match}
для @code{completing-read} равен @code{confirm-after-completion}.
Подтверждение запрашивается, если пользователь пытается выйти из минибуфера
сразу после вызова любой команды из этого списка.
@end defvar

@deffn Command minibuffer-complete-word
Эта функция дополняет содержимое минибуфера максимум одним словом.  Даже
если содержимое минибуфера имеет только одно завершение,
@code{minibuffer-complete-word} не добавляет никаких символов, кроме первого
символа, который не является составной частью слова.  @xref{Syntax Tables}.
@end deffn

@deffn Command minibuffer-complete
Эта функция дополняет содержимое минибуфера, насколько это возможно.
@end deffn

@deffn Command minibuffer-complete-and-exit
Эта функция завершает содержимое минибуфера и завершает работу, если
подтверждение не требуется, например, если
@code{minibuffer-completion-confirm} равен @code{nil}.  Если требуетсяп
@emph{этому} подтверждение, оно дается путем немедленного повторения этой
команды - команда запрограммирована на работу без подтверждения при
выполнении её дважды подряд.
@end deffn

@deffn Command minibuffer-completion-help
Эта функция создает список возможных завершений текущего содержимого
минибуфера.  Работает, вызывая @code{all-completions} с использованием
значения переменной @code{minibuffer-completion-table} в качестве аргумента
@var{collection} и значения @code{minibuffer-completion-predicate} в
качестве аргумента @var{predicate}.  Список завершений отображается в виде
текста в буфере с именем @file{*Completions*}.
@end deffn

@defun display-completion-list completions
Эта функция отображает @var{completions} в поток в @code{standard-output},
обычно это буфер.  (@xref{Read and Print}, для получения дополнительной
информации о потоках.)  Аргумент @var{completions} обычно представляет собой
список завершений, только что возвращенный @code{all-completions}, но это не
обязательно.  Каждый элемент может быть символом или строкой, любой из
которых просто печатается.  Это также может быть список из двух строк,
который печатается так, как если бы строки были объединены.  Первая из двух
строк - это фактическое завершение, вторая строка служит аннотацией.

Эта функция вызывается @code{minibuffer-completion-help}.  Обычно это можно
использовать вместе с @code{with-output-to-temp-buffer}, например:

@example
(with-output-to-temp-buffer "*Completions*"
  (display-completion-list
    (all-completions (buffer-string) my-alist)))
@end example
@end defun

@defopt completion-auto-help
Если эта переменная - не-@code{nil}, команды завершения автоматически
отображают список возможных завершений всякий раз, когда ничего не может
быть завершено, потому что следующий символ не определен однозначно.
@end defopt

@defvar minibuffer-local-completion-map
@code{completing-read} использует это значение как локальную карту ключей,
когда точное совпадение одного из завершений не требуется.  По умолчанию эта
карта делает следующие привязки:

@table @asis
@item @kbd{?}
@code{minibuffer-completion-help}

@item @key{SPC}
@code{minibuffer-complete-word}

@item @key{TAB}
@code{minibuffer-complete}
@end table

@noindent
и использует @code{minibuffer-local-map} в качестве родительской карты
(@pxref{Definition of minibuffer-local-map}).
@end defvar

@defvar minibuffer-local-must-match-map
@code{completing-read} использует это значение как локальную ключевую карту,
когда требуется точное совпадение одного из завершений.  Следовательно,
никакие ключи не привязаны к @code{exit-minibuffer}, команде, которая
безоговорочно выходит из минибуфера.  По умолчанию эта карта имеет следующие
привязки:

@table @asis
@item @kbd{C-j}
@code{minibuffer-complete-and-exit}

@item @key{RET}
@code{minibuffer-complete-and-exit}
@end table

@noindent
и использует @code{minibuffer-local-completion-map} в качестве родительской
карты.
@end defvar

@defvar minibuffer-local-filename-completion-map
Это разреженная ключевая карта, которая просто отключает @key{SPC}; потому
что имена файлов могут содержать пробелы.  Функция @code{read-file-name}
объединяет эту карту с @code{minibuffer-local-completion-map} или
@code{minibuffer-local-must-match-map}.
@end defvar


@node High-Level Completion
@subsection Функции Завершения Высокого Уровня

  В этом разделе описаны вспомогательные функции более высокого уровня для
чтения определенных типов имен с завершением.

  В большинстве случаев не требуется вызывать эти функции в середине функции
Lisp.  По возможности, вводится весь минибуфер как часть чтения аргументов
команды в спецификации @code{interactive}.  @xref{Defining Commands}.

@defun read-buffer prompt &optional default require-match predicate
Эта функция считывает имя буфера и возвращает его в виде строки.
Запрашивается @var{prompt}.  Аргумент @var{default} - это имя по умолчанию
для использования, значение, которое возвращается, если пользователь выходит
с пустым минибуфером.  Если не-@code{nil}, это должна быть строка, список
строк или буфер.  Если это список, значением по умолчанию является первый
элемент этого списка.  Он упоминается в приглашении, но не вставляется в
минибуфер в качестве начального ввода.

Аргумент @var{prompt} должен быть строкой, оканчивающейся двоеточием и
пробелом.  Если @var{default} равен не-@code{nil}, функция вставляет его в
@var{prompt} перед двоеточием, чтобы следовать соглашению о чтении из
минибуфера со значением по умолчанию (@pxref{Programming Tips}).

Необязательный аргумент @var{require-match} имеет то же значение, что и в
@code{completing-read}.  @xref{Minibuffer Completion}.

Необязательный аргумент @var{predicate}, если не-@code{nil}, указывает
функцию для фильтрации буферов, которые следует учитывать: функция будет
вызываться с каждым потенциальным кандидатом в качестве аргумента и должна
возвращать @code{nil}, чтобы отклонить кандидата, не-@code{nil}, чтобы
принять его.

В следующем примере пользователь вводит @samp{minibuffer.t}, а затем
набирает @key{RET}.  Аргумент @var{require-match} - @code{t}, и единственное
имя буфера, начинающееся с данного ввода, - @samp{minibuffer.texi}, так что
имя является значением.

@example
(read-buffer "Buffer name: " "foo" t)
@group
;; @r{После вычисления предыдущего выражения}
;;   @r{появляется следующая подсказка,}
;;   @r{с пустым минибуфером:}
@end group

@group
---------- Buffer: Minibuffer ----------
Buffer name (default foo): @point{}
---------- Buffer: Minibuffer ----------
@end group

@group
;; @r{Ввод пользователя @kbd{minibuffer.t @key{RET}}.}
     @result{} "minibuffer.texi"
@end group
@end example
@end defun

@defopt read-buffer-function
Эта переменная, если не-@code{nil}, определяет функцию для чтения имен
буферов.  @code{read-buffer} вызывает эту функцию вместо того, чтобы
выполнять свою обычную работу, с теми же аргументами, переданными в
@code{read-buffer}.
@end defopt

@defopt read-buffer-completion-ignore-case
Если эта переменная - не-@code{nil}, @code{read-buffer} игнорирует регистр
при выполнении завершения при чтении имени буфера.
@end defopt

@defun read-command prompt &optional default
Эта функция считывает имя команды и возвращает его как символ Lisp.
Аргумент @var{prompt} используется так же, как в
@code{read-from-minibuffer}.  Напомним, что команда - это все, для чего
@code{commandp} возвращает @code{t}, а имя команды - это символ, для
которого @code{commandp} возвращает @code{t}.  @xref{Interactive Call}.

Аргумент @var{default} указывает, что возвращать, если пользователь вводит
пустой ввод.  Это может быть символ, строка или список строк.  Если это
строка, @code{read-command} обрабатывает ее перед возвратом.  Если это
список, @code{read-command} обрабатывает первый элемент этого списка.
Если @var{default} равен @code{nil}, это означает, что значение по умолчанию
не задано; тогда, если пользователь вводит пустой ввод, возвращаемое
значение - @code{(intern "")}, то есть символ, имя которого - пустая строка,
а печатное представление - @code{##} (@pxref{Symbol Type}).

@example
(read-command "Command name? ")

@group
;; @r{После вычисления предыдущего выражения появляется}
;;   @r{следующая подсказка с пустым минибуфером:}
@end group

@group
---------- Buffer: Minibuffer ----------
Command name?
---------- Buffer: Minibuffer ----------
@end group
@end example

@noindent
Если пользователь вводит @kbd{forward-c @key{RET}}, эта функция возвращает
@code{forward-char}.

Функция @code{read-command} - это упрощенный интерфейс для
@code{completing-read}.  Использует переменную @code{obarray}, чтобы
завершить набор существующих символов Lisp, и использует предикат
@code{commandp}, чтобы принимать только имена команд:

@cindex @code{commandp} пример
@example
@group
(read-command @var{prompt})
@equiv{}
(intern (completing-read @var{prompt} obarray
                         'commandp t nil))
@end group
@end example
@end defun

@defun read-variable prompt &optional default
@anchor{Definition of read-variable}
Эта функция считывает имя настраиваемой переменной и возвращает её в виде
символа.  Его аргументы имеют тот же вид, что и аргументы
@code{read-command}.  Ведет себя так же, как @code{read-command}, за
исключением того, что использует предикат @code{custom-variable-p} вместо
@code{commandp}.
@end defun

@deffn Command read-color &optional prompt convert allow-empty display
Эта функция считывает строку, которая является спецификацией цвета, либо
именем цвета, либо шестнадцатеричным значением RGB, например
@code{#RRRGGGBBB}.  Запрашивает @var{prompt} (по умолчанию:
@code{"Цвет (имя или триплет #RGB):"}) и обеспечивает завершение для
названий цветов, но не для шестнадцатеричных значений RGB.  В дополнение к
названиям стандартных цветов кандидаты завершения включают в себя цвета
переднего плана и фона в точке.

Описание действительных значений RGB в @ref{Color Names}.

Возвращаемое значение функции - строка, введенная пользователем в минибуфер.
Однако при интерактивном вызове или если необязательный аргумент
@var{convert} равен не-@code{nil}, преобразует любое имя входного цвета в
соответствующую строку значения RGB и это возвращает.  Функция требует ввода
действительной спецификации цвета.  Пустые имена цветов разрешены, когда
@var{allow-empty} равен не-@code{nil} и пользователь вводит пустой ввод.

В интерактивном режиме или когда @var{display} равен не-@code{nil},
возвращаемое значение также отображается в эхо-области.
@end deffn

  Смотреть также функции @code{read-coding-system} и
@code{read-non-nil-coding-system}, в @ref{User-Chosen Coding Systems},
и @code{read-input-method-name}, в @ref{Input Methods}.

@node Reading File Names
@subsection Чтение Имен Файлов
@cindex read file names
@cindex prompt for file name

  Функции завершения высокого уровня @code{read-file-name},
@code{read-directory-name} и @code{read-shell-command} предназначены для
чтения имен файлов, имен каталогов и команд оболочки соответственно.  Они
предоставляют специальные функции, включая автоматическую вставку каталога
по умолчанию.

@defun read-file-name prompt &optional directory default require-match initial predicate
Эта функция считывает имя файла, запрашивая @var{prompt} и обеспечивая
завершение.

В качестве исключения эта функция считывает имя файла с использованием
графического диалогового окна файла вместо минибуфера, если выполняются все
следующие условия:

@enumerate
@item
Вызывается с помощью команды мыши.

@item
Выбранный фрейм отображается на графическом дисплее, поддерживающем такие
диалоги.

@item
Переменная @code{use-dialog-box} - не-@code{nil}.
@xref{Dialog Boxes,, Dialog Boxes, emacs, The GNU Emacs Manual}.

@item
Аргумент @var{directory}, описанный ниже, не указывает удаленный файл.
@xref{Remote Files,, Remote Files, emacs, The GNU Emacs Manual}.
@end enumerate

@noindent
Точное поведение при использовании диалогового окна с графическим файлом
зависит от платформы.  Здесь просто документируется поведение при
использовании минибуфера.

@code{read-file-name} не расширяет автоматически возвращаемое имя файла.
Можно вызвать @code{expand-file-name} самостоятельно, если требуется
абсолютное имя файла.

Необязательный аргумент @var{require-match} имеет то же значение, что и в
@code{completing-read}.  @xref{Minibuffer Completion}.

Аргумент @var{directory} указывает каталог, используемый для завершения
относительных имен файлов.  Это должно быть абсолютное имя каталога.  Если
переменная @code{insert-default-directory} - не-@code{nil}, @var{directory}
также вставляется в минибуфер в качестве начального ввода.  По умолчанию
используется текущее значение буфера @code{default-directory}.

Если указано @var{initial}, это начальное имя файла для вставки в буфер
(после @var{directory}, если вставлено).  В этом случае точка стоит в начале
@var{initial}.  По умолчанию для @var{initial} установлено значение
@code{nil}---не вставлять никаких имен файлов.  Чтобы увидеть, что делает
@var{initial}, пробуется команда @kbd{C-x C-v} в буфере, обращающуюся к
файлу.  @strong{Пожалуйста, обратить внимание:} в большинстве случаев
рекомендуется использовать @var{default}, а не @var{initial}.

Если @var{default} равен не-@code{nil}, функция возвращает @var{default},
если пользователь выходит из минибуфера с тем же непустым содержимым,
которое изначально было вставлено @code{read-file-name}.  Первоначальное
содержимое минибуфера всегда непусто, если @code{insert-default-directory}
имеет значение не-@code{nil}, как и по умолчанию.  @var{default} не
проверяется на валидность, независимо от значения @var{require-match}.
Однако, если @var{require-match} равен не-@code{nil}, исходным содержимым
минибуфера должно быть допустимое имя файла (или каталога).  В противном
случае @code{read-file-name} пытается завершить, если пользователь выходит
без редактирования, и не возвращает @var{default}.  @var{default} также
доступен через команды истории.

Если @var{default} - @code{nil}, @code{read-file-name} пытается найти замену
вместо использования по умолчанию, так что он обрабатывает точно так же, как
если бы он был указан явно.  Если @var{default} - @code{nil}, а
@var{initial} - не-@code{nil}, то по умолчанию используется абсолютное имя
файла, полученное из @var{directory} и @var{initial}.  Если оба
@var{default} и @var{initial} - @code{nil} и буфер обращается к файлу,
@code{read-file-name} использует абсолютное имя этого файла по умолчанию.
Если буфер не обращается к файлу, значит, нет по умолчанию.  В том случае,
если пользователь набирает @key{RET} без какого-либо редактирования,
@code{read-file-name} просто возвращает предварительно вставленное
содержимое минибуфера.

Если пользователь набирает @key{RET} в пустом минибуфере, эта функция
возвращает пустую строку, независимо от значения @var{require-match}.  Это,
например, как пользователь может заставить текущий буфер не посещать файл с
помощью @kbd{M-x set-visited-file-name}.

Если @var{predicate} равен не-@code{nil}, он определяет функцию одного
аргумента, которая определяет, какие имена файлов являются приемлемыми
альтернативами завершения.  Имя файла является допустимым значением, если
@var{predicate} возвращает для него не-@code{nil}.

Вот пример использования @code{read-file-name}:

@example
@group
(read-file-name "The file is ")

;; @r{После вычисления предыдущего выражения}
;;   @r{в минибуфере появляется следующее:}
@end group

@group
---------- Buffer: Minibuffer ----------
The file is /gp/gnu/elisp/@point{}
---------- Buffer: Minibuffer ----------
@end group
@end example

@noindent
Ввод @kbd{manual @key{TAB}} приводит к следующему:

@example
@group
---------- Buffer: Minibuffer ----------
The file is /gp/gnu/elisp/manual.texi@point{}
---------- Buffer: Minibuffer ----------
@end group
@end example

@c Многословный, чтобы избежать переполнения бокса в режиме маленькой книги.
@noindent
Если пользователь вводит @key{RET}, @code{read-file-name}, возвращает имя
файла в виде строки @code{"/gp/gnu/elisp/manual.texi"}.
@end defun

@defvar read-file-name-function
Если не-@code{nil}, это должна быть функция, которая принимает те же
аргументы, что и @code{read-file-name}.  Когда вызывается
@code{read-file-name}, он вызывает эту функцию с предоставленными
аргументами вместо того, чтобы выполнять свою обычную работу.
@end defvar

@defopt read-file-name-completion-ignore-case
Если эта переменная - не-@code{nil}, @code{read-file-name}, при завершении
игнорируется регистр.
@end defopt

@defun read-directory-name prompt &optional directory default require-match initial
Эта функция похожа на @code{read-file-name}, но позволяет использовать
только имена каталогов в качестве альтернативы завершения.

Если @var{default} - @code{nil}, а @var{initial} - не-@code{nil},
@code{read-directory-name}, создает замену по умолчанию, комбинируя
@var{directory} (или каталог текущего буфера по умолчанию, если
@var{directory} равен @code{nil}) и @var{initial}.  Если @var{default} и
@var{initial} имеют значение @code{nil}, эта функция использует
@var{directory} в качестве замены по умолчанию или каталог текущего буфера
по умолчанию, если @var{directory} имеет значение @code{nil}.
@end defun

@defopt insert-default-directory
Эта переменная используется @code{read-file-name} и, таким образом,
косвенно, большинством команд, читающих имена файлов.  (Это включает все
команды, которые используют кодовые буквы @samp{f} или @samp{F} в своей
интерактивной форме.
@xref{Interactive Codes,, Code Characters for interactive}.)  Её значение
определяет, запускается ли @code{read-file-name}, помещая имя каталога по
умолчанию в минибуфер плюс имя исходного файла, если оно есть.  Если
значение этой переменной - @code{nil}, то @code{read-file-name} не помещает
начальный ввод в минибуфер (если не указан начальный ввод с аргументом
@var{initial}).  В этом случае каталог по умолчанию по-прежнему используется
для завершения относительных имен файлов, но не отображается.

Если эта переменная - @code{nil}, а исходное содержимое минибуфера пусто,
пользователю может потребоваться явным образом выбрать следующий элемент
истории, чтобы получить доступ к значению по умолчанию.  Если переменная -
не-@code{nil}, исходное содержимое минибуфера всегда непусто, и пользователь
всегда может запросить значение по умолчанию, немедленно набрав @key{RET} в
неотредактированном минибуфере. (См. Выше.)

Например:

@example
@group
;; @r{Здесь минибуфер начинается с каталога по умолчанию.}
(let ((insert-default-directory t))
  (read-file-name "The file is "))
@end group

@group
---------- Buffer: Minibuffer ----------
The file is ~lewis/manual/@point{}
---------- Buffer: Minibuffer ----------
@end group

@group
;; @r{Здесь минибуфер пуст и в его строке}
;;   @r{появляется только подсказка.}
(let ((insert-default-directory nil))
  (read-file-name "The file is "))
@end group

@group
---------- Buffer: Minibuffer ----------
The file is @point{}
---------- Buffer: Minibuffer ----------
@end group
@end example
@end defopt

@defun read-shell-command prompt &optional initial history &rest args
Эта функция считывает команду оболочки из минибуфера, запрашивая
@var{prompt} и обеспечивая интеллектуальное завершение.  Завершает первое
слово команды, используя кандидатов, которые подходят для имен команд, а
остальные слова команды в качестве имен файлов.

Эта функция использует @code{minibuffer-local-shell-command-map} в качестве
карты для ввода в минибуфер.  Аргумент @var{history} указывает список
истории для использования; если опущено или @code{nil}, по умолчанию
используется @code{shell-command-history}
(@pxref{Minibuffer History, shell-command-history}).  Необязательный
аргумент @var{initial} указывает начальное содержимое минибуфера
(@pxref{Initial Input}).  Остальные @var{args}, если они есть, используются
как аргументы @var{default} и @var{inherit-input-method} в
@code{read-from-minibuffer} (@pxref{Text from Minibuffer}).
@end defun

@defvar minibuffer-local-shell-command-map
Эта карта используется @code{read-shell-command} для завершения имен команд
и файлов, которые являются частью команды оболочки.  Использует
@code{minibuffer-local-map} в качестве родительской ключевой карты и
связывает @key{TAB} с @code{completion-at-point}.
@end defvar

@node Completion Variables
@subsection Переменные Завершения

  Вот несколько переменных, которые можно использовать для изменения
поведения завершения по умолчанию.

@cindex completion styles
@defopt completion-styles
Значение этой переменной представляет собой список стилей завершения
(символов), используемых для выполнения завершения.  @dfn{Стиль завершения}
- это набор правил для генерации завершений.  Каждый символ, встречающийся в
этом списке, должен иметь соответствующую запись в
@code{completion-styles-alist}.
@end defopt

@defvar completion-styles-alist
В этой переменной хранится список доступных стилей завершения.  Каждый
элемент в списке имеет форму

@example
(@var{style} @var{try-completion} @var{all-completions} @var{doc})
@end example

@noindent
Здесь @var{style} - это имя стиля завершения (символ), которое может
использоваться в переменной @code{completion-styles} для ссылки на этот
стиль; @var{try-completion} - функция, выполняющая завершение;
@var{all-completions} - это функция, которая выводит список завершений;
@var{doc} - строка, описывающая стиль завершения.

Каждая функция @var{try-completion} и @var{all-completions} должна принимать
четыре аргумента: @var{string}, @var{collection}, @var{predicate}, и
@var{point}.  Аргументы @var{string}, @var{collection} и @var{predicate}
имеют то же значение, что и аргумент @code{try-completion}
(@pxref{Basic Completion}) и @var{point} - позиция точки внутри
@var{string}.  Каждая функция должна возвращать значение не-@code{nil}, если
она выполнила свою работу, и @code{nil}, если нет (например, если нет
возможности завершить @var{string} в соответствии со стилем завершения).

Когда пользователь вызывает команду завершения, например
@code{minibuffer-complete} (@pxref{Completion Commands}), Emacs ищет первый
стиль, указанный в @code{completion-styles}, и вызывает его функцию
@var{try-completion}.  Если эта функция возвращает @code{nil}, Emacs
переходит к следующему перечисленному стилю завершения и вызывает свою
функцию @var{try-completion}, и так далее, пока одна из функций
@var{try-completion} не выполнит успешно завершение и не вернет значение
не-@code{nil}.  Аналогичная процедура используется для перечисления
дополнений с помощью функций @var{all-completions}.

@xref{Completion Styles,,, emacs, The GNU Emacs Manual}, для описания
доступных стилей завершения.
@end defvar

@defopt completion-category-overrides
Эта переменная определяет специальные стили завершения и другое поведение
завершения, используемое при завершении определенных типов текста.  Её
значение должно быть списком с элементами вида
@code{(@var{category} . @var{alist})}. @var{category} - символ, описывающий,
что выполняется; в настоящее время определены категории @code{buffer},
@code{file} и @code{unicode-name}, но другие могут быть определены с помощью
специализированных функций завершения (@pxref{Programmed Completion}).
@var{alist} - это список ассоциаций, описывающий, как завершение должно
вести себя для соответствующей категории.  Поддерживаются следующие ключи
списка:

@table @code
@item styles
Значение должно быть списком стилей завершения (символов).

@item cycle
Значение должно быть значением @code{completion-cycle-threshold}
(@pxref{Completion Options,,, emacs, The GNU Emacs Manual})
для этой категории.
@end table

@noindent
Дополнительные записи списка могут быть определены в будущем.
@end defopt

@defvar completion-extra-properties
Эта переменная используется для указания дополнительных свойств текущей
команды завершения.  Она предназначен для связывания с помощью специальных
команд завершения.  Её значение должно быть списком пар свойств и значений.
Поддерживаются следующие свойства:

@table @code
@item :annotation-function
Значение должно быть функцией для завершения аннотаций в буфер завершений.
Эта функция должна принимать один аргумент, завершение, и должна либо
возвращать @code{nil}, либо строку, которая будет отображаться рядом с
завершением.

@item :exit-function
Значение должно быть функцией, запускаемой после выполнения.  Функция должна
принимать два аргумента, @var{string} и @var{status}, где @var{string} - это
текст, которым было заполнено поле, а @var{status} указывает, какая операция
произошла: @code{finished}, если текст теперь завершен, @code{sole}, если
текст не может быть завершен, но завершение выполняется.  Не завершено, или
@code{exact}, если текст является допустимым завершением, но может быть
завершен в дальнейшем.
@end table
@end defvar

@node Programmed Completion
@subsection Программное Завершение
@cindex programmed completion

  Иногда невозможно или невозможно заранее создать список или массив,
содержащий все предполагаемые возможные завершения.  В таком случае можно
предоставить собственную функцию для вычисления завершения данной строки.
Это называется @dfn{программное завершение}.  Emacs использует программное
завершение при завершении имен файлов (@pxref{File Name Completion}),
среди многих других случаев.

  Чтобы использовать эту функцию, передайте функцию @code{completing-read}
в качестве аргумента @var{collection}.  Функция @code{completing-read}
передает вашу функцию завершения вместе с @code{try-completion},
@code{all-completions} и другими базовыми функциями завершения, которые
затем позволяют вашей функции выполнять всю работу.

  Функция завершения должна принимать три аргумента:

@itemize @bullet
@item
Строка, которую нужно заполнить.

@item
Функция предиката для фильтрации возможных совпадений или @code{nil}, если
их нет.  Функция должна вызывать предикат для каждого возможного совпадения
и игнорировать совпадение, если предикат возвращает @code{nil}.

@item
Флаг, определяющий тип выполняемой операции завершения; смотреть
@ref{Basic Completion}, чтобы узнать подробности об этих операциях.  Этот
флаг может иметь одно из следующих значений.

@table @code
@item nil
Это определяет операцию @code{try-completion}.  Функция должна вернуть
@code{nil}, если совпадений нет; должна вернуть @code{t}, если указанная
строка является уникальным и точным соответствием; и в противном случае она
должна возвращать самую длинную подстроку общего префикса из всех
совпадений.

@item t
Это определяет операцию @code{all-completions}.  Функция должна вернуть
список всех возможных завершений указанной строки.

@item lambda
Это определяет операцию @code{test-completion}.  Функция должна возвращать
@code{t}, если указанная строка является точным совпадением для некоторой
альтернативы завершения; @code{nil} иначе.

@item (boundaries . @var{suffix})
Это определяет операцию @code{completion-boundaries}.  Функция должна
возвращать @code{(boundaries @var{start} . @var{end})}, где @var{start} -
позиция начальной границы в указанной строке, а @var{end} - позиция конечной
границы в @var{suffix}.

@item metadata
Это определяет запрос информации о состоянии текущего завершения.
Возвращаемое значение должно иметь вид @code{(metadata . @var{alist})}, где
@var{alist} - это список, элементы которого описаны ниже.
@end table

@noindent
Если флаг имеет любое другое значение, функция завершения должна вернуть
@code{nil}.
@end itemize

Ниже приведен список записей метаданных, которые функция завершения может
вернуть в ответ на аргумент флага @code{metadata}:

@table @code
@item category
Значение должно быть символом, описывающим, какой текст пытается завершить
функция завершения.  Если символ соответствует одному из ключей в
@code{completion-category-overrides}, обычное завершение отменяется.
@xref{Completion Variables}.

@item annotation-function
Значение должно быть функцией для завершений @dfn{анотаций}.  Функция должна
принимать один аргумент @var{string}, который является возможным
завершением.  Должна вернуть строку, которая отображается после завершения
@var{string} в буфере @file{*Completions*}.

@item display-sort-function
Значение должно быть функцией для сортировки завершений.  Функция должна
принимать один аргумент, список строк завершения и возвращать
отсортированный список строк завершения.  Допускается деструктивное
изменение входного списка.

@item cycle-sort-function
Значение должно быть функцией для сортировки завершений, когда
@code{completion-cycle-threshold} имеет значение не-@code{nil} и
пользователь циклически перебирает варианты завершения.
@xref{Completion Options,,, emacs, The GNU Emacs Manual}.  Список аргументов
и возвращаемое значение такие же, как у @code{display-sort-function}.
@end table

@defun completion-table-dynamic function &optional switch-buffer
Эта функция - удобный способ написать функцию, которая может действовать как
запрограммированная функция завершения.  Аргумент @var{function} должен быть
функцией, которая принимает один аргумент, строку и возвращает таблицу
завершения (@pxref{Basic Completion}), содержащую все возможные завершения.
Таблица, возвращаемая @var{function}, также может включать элементы, не
соответствующие строковому аргументу; они автоматически отфильтровываются
@code{completion-table-dynamic}.  В частности, @var{function} может
игнорировать свой аргумент и возвращать полный список всех возможных
завершений.  Можно рассматривать @code{completion-table-dynamic} как
преобразователь между @var{function} и интерфейсом для запрограммированных
функций завершения.

Если необязательный аргумент @var{switch-buffer} - не-@code{nil} и
завершение выполняется в минибуфере, @var{function} будет вызываться с
текущим буфером, установленным на буфер, из которого был введен минибуфер.

Возвращаемое значение @code{completion-table-dynamic} - это функция,
которую можно использовать как 2-й аргумент для @code{try-completion} и
@code{all-completions}.  Обратить внимание, что эта функция всегда будет
возвращать пустые метаданные и тривиальные границы.
(@pxref{Programmed Completion}).
@end defun

@defun completion-table-with-cache function &optional ignore-case
Это оболочка для @code{completion-table-dynamic}, которая сохраняет
последнюю пару аргумент-результат.  Это означает, что несколько запросов с
одним и тем же аргументом должны вызывать @var{function} только один раз.
Это может быть полезно, когда задействована медленная операция, например,
вызов внешнего процесса.
@end defun

@node Completion in Buffers
@subsection Завершение в Обычных Буферах
@cindex inline completion

@findex completion-at-point
  Хотя завершение обычно выполняется в минибуфере, средство завершения также
можно использовать для текста в обычных буферах Emacs.  Во многих основных
режимах завершение в буфере выполняется командой @kbd{C-M-i} или
@kbd{M-@key{TAB}}, привязанной к @code{completion-at-point}.
@xref{Symbol Completion,,, emacs, The GNU Emacs Manual}.  Эта команда
использует ненормальную переменную ловушки
@code{completion-at-point-functions}:

@defvar completion-at-point-functions
Значением этой ненормальной ловушки должен быть список функций, который
используются для вычисления таблицы завершения (@pxref{Basic Completion})
для завершения текста в точке.  Может использоваться основными режимами для
предоставления таблиц завершения конкретных режимов
(@pxref{Major Mode Conventions}).

Когда команда @code{completion-at-point} запускается, вызывает функции в
списке одну за другой без каких-либо аргументов.  Каждая функция должна
возвращать @code{nil}, если она не может и не хочет брать на себя
ответственность за данные завершения для текста в точке.  В противном случае
она должена вернуть список следующего вида:

@example
(@var{start} @var{end} @var{collection} . @var{props})
@end example

@noindent
@var{start} и @var{end} ограничивают текст до завершения (который должен
заключать точку).  @var{collection} - таблица завершения для завершения
этого текста в форме, пригодная для передачи в качестве второго аргумента в
@code{try-completion} (@pxref{Basic Completion});  Альтернативы завершения
будут сгенерированы из этой таблицы завершения обычным способом с помощью
стилей завершения, определенных в @code{completion-styles}
(@pxref{Completion Variables}).  @var{props} - список свойств для
дополнительной информации; любое из свойств в
@code{completion-extra-properties} распознается
(@pxref{Completion Variables}), а также есть следующие дополнительные:

@table @code
@item :predicate
Значение должно быть предикатом, которому должны удовлетворять кандидаты на
завершение.

@item :exclusive
Если значение равно @code{no}, то, если таблица завершения не соответствует
тексту в точке, @code{completion-at-point} переходит к следующей функции в
@code{completion-at-point-functions} вместо сообщения об ошибке завершения.
@end table

Функции на этой ловушке обычно должны возвращаться быстро, поскольку они
могут вызываться очень часто (например, из @code{post-command-hook}).
Настоятельно рекомендуется использовать функцию для @var{collection}, если
создание списка завершений - дорогостоящая операция.  Emacs может вызывать
функции внутри @code{completion-at-point-functions} много раз, но заботится
о значении @var{collection} только для некоторых из этих вызовов.
Предоставляя функцию для @var{collection}, Emacs может отложить создание
завершений до тех пор, пока это необходимо.  Можно использовать
@code{completion-table-dynamic} для создания функции-оболочки:

@smallexample
;; Избегайте этого шаблона.
(let ((beg ...) (end ...) (my-completions (my-make-completions)))
  (list beg end my-completions))

;; Используйте вместо это.
(let ((beg ...) (end ...))
  (list beg
        end
        (completion-table-dynamic
          (lambda (_)
            (my-make-completions)))))
@end smallexample

Кроме того, @var{collection} обычно не следует предварительно фильтровать
на основе текущего текста между @var{start} и @var{end}, потому что это
задача вызывающего @code{completion-at-point-functions} в соответствии со
стилями завершения, которые решает использовать.

Функция в @code{completion-at-point-functions} может также возвращать
функцию вместо списка, как описано выше.  В этом случае эта возвращенная
функция вызывается без аргументов, и она полностью отвечает за выполнение
завершения.  Не рекомендуется такое использование; предназначено только для
преобразования старого кода в использование @code{completion-at-point}.

Первая функция в @code{completion-at-point-functions}, возвращающая значение
не-@code{nil}, используется @code{completion-at-point}.  Остальные функции
не вызываются.  Исключение составляют случаи, когда существует спецификация
@code{:exclusive}, как описано выше.
@end defvar

  Следующая функция предоставляет удобный способ выполнить завершение
произвольного фрагмента текста в буфере Emacs:

@defun completion-in-region start end collection &optional predicate
Эта функция завершает текст в текущем буфере между позициями @var{start} и
@var{end}, используя @var{collection}.  Аргумент @var{collection} имеет то
же значение, что и аргумент @code{try-completion}
(@pxref{Basic Completion}).

Эта функция вставляет текст завершения непосредственно в текущий буфер.  В
отличие от @code{completing-read} (@pxref{Minibuffer Completion}), он не
активирует минибуфер.

Чтобы эта функция работала, точка должна находиться где-то между @var{start}
и @var{end}.
@end defun


@node Yes-or-No Queries
@section Вопросы Да или Нет
@cindex asking the user questions
@cindex querying the user
@cindex yes-or-no questions

  В этом разделе описаны функции, используемые для того, чтобы задать
пользователю вопрос типа «да» или «нет».  На функцию @code{y-or-n-p} можно
ответить одним символом; это полезно для вопросов, на которые
непреднамеренный неправильный ответ не приведет к серьезным последствиям.
@code{yes-or-no-p} подходит для более важных вопросов, поскольку для ответа
требуется три или четыре символа.

   Если какая-либо из этих функций вызывается в команде, которая была
вызвана с помощью мыши - точнее, если @code{last-nonmenu-event}
(@pxref{Command Loop Info}) является либо @code{nil}, либо списком, - тогда
используется диалоговое окно или всплывающее меню, чтобы задать вопрос.  В
противном случае используется ввод с клавиатуры.  Можно принудительно
использовать либо мышь, либо ввод с клавиатуры, привязав
@code{last-nonmenu-event} к подходящему значению вокруг вызова.

  Строго говоря, @code{yes-or-no-p} использует минибуфер, а @code{y-or-n-p}
- нет; но, кажется, лучше всего описывать их вместе.

@defun y-or-n-p prompt
Эта функция задает пользователю вопрос, ожидая ввода в эхо-области.  Она
возвращает @code{t}, если пользователь вводит @kbd{y}, @code{nil}, если
пользователь вводит @kbd{n}.  Эта функция также принимает @key{SPC} для
обозначения да и @key{DEL} для обозначения нет.  Она принимает @kbd{C-]} для
выхода, как @kbd{C-g}, потому что вопрос может выглядеть как минибуфер, и
по этой причине пользователь может попытаться использовать @kbd{C-]} для
выхода.  Ответ - один символ, @key{RET}, без необходимого для его
завершения.  Верхний и нижний регистр эквивалентны.

``Задавая вопрос'' означает вывод @var{prompt} в эхо-области, за которым
следует строка @w{@samp{(y or n) }}.  Если вход не является одним из
ожидаемых ответов (@kbd{y}, @kbd{n}, @kbd{@key{SPC}}, @kbd{@key{DEL}} или
что-то, что требует завершения), функция отвечает
@samp{Please answer y or n.} и повторяет запрос.

Эта функция фактически не использует минибуфер, так как не позволяет
редактировать ответ.  Фактически использует эхо-область
(@pxref{The Echo Area}), которая использует то же пространство экрана, что
и минибуфер.  Курсор перемещается в эхо-область, пока задается вопрос.

Ответы и их значения, даже @samp{y} и @samp{n}, не зашиты, а задаются
картой @code{query-replace-map} (@pxref{Search and Replace}).  В частности,
если пользователь вводит специальные ответы @code{recenter},
@code{scroll-up}, @code{scroll-down}, @code{scroll-other-window}, или
@code{scroll-other-window-down} (соответственно привязанные к @kbd{C-l},
@kbd{C-v}, @kbd{M-v}, @kbd{C-M-v} и @kbd{C-M-S-v} в @code{query-replace-map}
), эта функция выполняет указанную операцию центрирования или прокрутки окна
и снова задает вопрос.

@noindent
Показываются последовательные строки сообщений эхо-области, но только одна
из них фактически появляется на экране за раз.
@end defun

@defun y-or-n-p-with-timeout prompt seconds default
Подобно @code{y-or-n-p}, за исключением того, что если пользователь не
отвечает в течение @var{seconds} секунд, эта функция прекращает ожидание и
возвращает @var{default}.  Работает путем установки таймера; смотреть
@ref{Timers}.  Аргумент @var{seconds} должен быть числом.
@end defun

@defun yes-or-no-p prompt
Эта функция задает пользователю вопрос, ожидая ввода в минибуфер.
Возвращает @code{t}, если пользователь вводит @samp{yes}, @code{nil}, если
пользователь вводит @samp{no}.  Пользователь должен ввести @key{RET}, чтобы
завершить ответ.  Верхний и нижний регистр эквивалентны.

@code{yes-or-no-p} начинается с отображения @var{prompt} в эхо-области, за
которым следует @w{@samp{(yes or no) }}.  Пользователь должен ввести один из
ожидаемых ответов; в противном случае функция отвечает
@samp{Please answer yes or no.}, ждет около двух секунд и повторяет запрос.

@code{yes-or-no-p} требует от пользователя больше работы, чем
@code{y-or-n-p}, и подходит для более важных решений.

Вот пример:

@smallexample
@group
(yes-or-no-p "Do you really want to remove everything? ")

;; @r{После вычисления предыдущего выражения}
;;   @r{появляется следующая подсказка,}
;;   @r{с пустым минибуфером:}
@end group

@group
---------- Buffer: minibuffer ----------
Do you really want to remove everything? (yes or no)
---------- Buffer: minibuffer ----------
@end group
@end smallexample

@noindent
Если пользователь сначала набирает @kbd{y @key{RET}}, что недопустимо,
потому что эта функция требует всего слова @samp{yes}, он отвечает,
отображая эти подсказки с короткой паузой между ними:

@smallexample
@group
---------- Buffer: minibuffer ----------
Please answer yes or no.
Do you really want to remove everything? (yes or no)
---------- Buffer: minibuffer ----------
@end group
@end smallexample
@end defun

@node Multiple Queries
@section Задать Вопросы с Множественным Выбором

  В этом разделе описаны возможности, позволяющие задать пользователю более
сложные вопросы или несколько похожих вопросов.

@cindex multiple yes-or-no questions
  Когда у вас есть ряд аналогичных вопросов, таких как ``Вы хотите сохранить
этот буфер?'' для каждого буфера по очереди, потребуется использовать
@code{map-y-or-n-p}, чтобы задать набор вопросов, а не задавать каждый
вопрос индивидуально.  Это дает пользователю определенные удобные
возможности, такие как возможность ответить сразу на всю серию.

@defun map-y-or-n-p prompter actor list &optional help action-alist no-cursor-in-echo-area
Эта функция задает пользователю серию вопросов, читая односимвольный ответ в
эхо-области для каждого из них.

Значение @var{list} определяет объекты, о которых нужно задать вопросы.  Это
должен быть либо список объектов, либо функция-генератор.  Если это функция,
она не должна ожидать аргументов и должна возвращать либо следующий объект,
о котором нужно спросить, либо @code{nil}, что означает прекращение задавать
вопросы.

Аргумент @var{prompter} указывает, как задать каждый вопрос.  Если
@var{prompter} - строка, текст вопроса вычисляется следующим образом:

@example
(format @var{prompter} @var{object})
@end example

@noindent
где @var{object} - следующий объект, о котором нужно спросить (получено из
@var{list}).

Если это не строка, @var{prompter} должен быть функцией одного аргумента
(следующего объекта, о котором нужно спросить) и должен возвращать текст
вопроса.  Если значение является строкой, это вопрос, который следует задать
пользователю.  Функция также может возвращать @code{t}, что означает
действовать на этот объект (и не спрашивать пользователя), или @code{nil},
что означает игнорировать этот объект (и не спрашивать пользователя).

Аргумент @var{actor} говорит, как действовать в соответствии с ответами,
которые дает пользователь.  Это должна быть функция одного аргумента, и она
вызывается для каждого объекта, для которого пользователь соглашается.  Её
аргумент всегда является объектом, полученным из @var{list}.

Если указан аргумент @var{help}, это должен быть списком такой формы:

@example
(@var{singular} @var{plural} @var{action})
@end example

@noindent
где @var{singular} - строка, содержащая существительное в единственном
числе, которое описывает объекты, над которыми концептуально действуют,
@var{plural} - соответствующее существительное во множественном числе, а
@var{action} - переходный глагол, описывающий, что делает @var{actor}.

Если указать @var{help}, по умолчанию будет
@code{("object" "objects" "act on")}.

Каждый раз, когда задается вопрос, пользователь может ввести @kbd{y},
@kbd{Y}, или @key{SPC}, чтобы действовать с этим объектом; @kbd{n}, @kbd{N}
или @key{DEL}, чтобы пропустить этот объект; @kbd{!} для воздействия на все
следующие объекты; @key{ESC} или @kbd{q} для выхода (пропустить все
следующие объекты); @kbd{.} (точка) для воздействия на текущий объект и
выхода; или @kbd{C-h}, чтобы получить помощь.  Это те же ответы, которые
принимает @code{query-replace}.  Карта @code{query-replace-map} определяет
их значение как для @code{map-y-or-n-p}, так и для @code{query-replace};
смотреть @ref{Search and Replace}.

Можно использовать @var{action-alist}, чтобы указать дополнительные
возможные ответы и их значение.  Это список элементов вида @code{(@var{char}
@var{function} @var{help})}, каждый из которых определяет один
дополнительный ответ.  В этом элементе @var{char} - символ (ответ);
@var{function} - это функция одного аргумента (объект из @var{list});
@var{help} - это строка.

Когда пользователь отвечает @var{char}, @code{map-y-or-n-p}, вызывает
@var{function}.  Если функция возвращает не-@code{nil}, объект считается
обработанным, и @code{map-y-or-n-p} переходит к следующему объекту в
@var{list}.  Если же возвращает @code{nil}, запрос повторяется для того же
объекта.

Обычно @code{map-y-or-n-p} связывает @code{cursor-in-echo-area} при запросе.
Но если @var{no-cursor-in-echo-area} равен не-@code{nil}, этого не
происходит.

Если @code{map-y-or-n-p} вызывается в команде, которая была вызвана с
помощью мыши - точнее, если @code{last-nonmenu-event}
(@pxref{Command Loop Info}) является либо @code{nil}, либо списком - тогда
используется диалоговое окно или всплывающее меню, чтобы задать вопрос.  В
этом случае не используется ввод с клавиатуры или эхо-область.  Можно
принудительно использовать либо мышь, либо ввод с клавиатуры, привязав
@code{last-nonmenu-event} к подходящему значению вокруг вызова.

Возвращаемое значение @code{map-y-or-n-p} - это количество объектов, над
которыми было выполнено действие.
@end defun
@c FIXME  Пример этого был бы более полезен, чем все предыдущие
@c примеры простых вещей.

Если нужно задать пользователю вопрос, на который может быть более двух
ответов, используется @code{read-answer}.

@defun read-answer question answers
@vindex read-answer-short
Эта функция предлагает пользователю ввести текст в формате @var{question},
который должен заканчиваться символом @samp{SPC}.  Функция включает в
подсказку возможные ответы в @var{answers}, добавляя их в конец
@var{question}.  Возможные ответы представлены в @var{answers} в виде
списка, элементы которого имеют следующую форму:

@lisp
(@var{long-answer} @var{short-answer} @var{help-message})
@end lisp

@noindent
где @var{long-answer} - полный текст ответа пользователя, строка;
@var{short-answer} - это краткая форма одного и того же ответа, одного
символа; а @var{help-message} - это текст, который описывает смысл ответа.
Если переменная @code{read-answer-short} - не-@code{nil}, в подсказке будут
показаны короткие варианты возможных ответов, и ожидается, что пользователь
наберет отдельные символы, показанные в подсказке; в противном случае в
приглашении будут показаны длинные варианты ответов, и ожидается, что
пользователь наберет полный текст одного из ответов и завершит его нажатием
@key{RET}.  Если @code{use-dialog-box} имеет значение не-@code{nil} и эта
функция была вызвана событиями мыши, вопрос и ответы будут отображаться в
диалоговом окне GUI.

Функция возвращает текст @var{long-answer}, выбранный пользователем,
независимо от того, были ли длинные или короткие ответы показаны в
подсказке и введены пользователем.

Вот пример использования этой функции:

@lisp
(let ((read-answer-short t))
  (read-answer "Foo "
     '(("yes"  ?y "perform the action")
       ("no"   ?n "skip to the next")
       ("all"  ?! "perform for the rest without more questions")
       ("help" ?h "show help")
       ("quit" ?q "exit"))))
@end lisp
@end defun

@node Reading a Password
@section Чтение Пароля
@cindex passwords, reading

  Чтобы прочитать пароль для перехода к другой программе, можно использовать
функцию @code{read-passwd}.

@vindex read-hide-char
@defun read-passwd prompt &optional confirm default
Эта функция считывает пароль, запрашивая @var{prompt}.  Пароль не
отображается по мере его ввода пользователем; вместо этого отображается
@samp{.} для каждого символа в пароле.  Если требуется применить другой
символ, чтобы скрыть пароль, связывается переменная @code{read-hide-char} с
этим символом.

Необязательный аргумент @var{confirm}, если не-@code{nil}, указывает, что
пароль нужно читать дважды, и настаивает на том, чтобы он был одинаковым
оба раза.  Если это не то же самое, пользователь должен вводить его снова и
снова, пока не совпадут два последних раза.

Необязательный аргумент @var{default} указывает пароль по умолчанию, который
будет возвращен, если пользователь вводит пустой ввод.  Если @var{default}
равен @code{nil}, то в этом случае @code{read-passwd} возвращает пустую
строку.
@end defun

@node Minibuffer Commands
@section Команды Минибуфера

  В этом разделе описаны некоторые команды, предназначенные для использования в минибуфере.

@deffn Command exit-minibuffer
Эта команда следует из активного минибуфера.  Обычно он привязан к ключам в
локальных картах ключей минибуфера.
@end deffn

@deffn Command self-insert-and-exit
Эта команда выходит из активного минибуфера после вставки последнего
символа, набранного на клавиатуре (находится в @code{last-command-event};
@pxref{Command Loop Info}).
@end deffn

@deffn Command previous-history-element n
Эта команда заменяет содержимое минибуфера значением предыдущего (более
старого) элемента истории @var{n}.
@end deffn

@deffn Command next-history-element n
Эта команда заменяет содержимое минибуфера значением более свежего элемента
истории @var{n}.
@end deffn

@deffn Command previous-matching-history-element pattern n
Эта команда заменяет содержимое минибуфера значением предыдущего (более
старого) элемента истории @var{n}, который соответствует @var{pattern}
(регулярное выражение).
@end deffn

@deffn Command next-matching-history-element pattern n
Эта команда заменяет содержимое минибуфера значением следующего (более
нового) элемента истории @var{n}, который соответствует @var{pattern}
(регулярное выражение).
@end deffn

@deffn Command previous-complete-history-element n
Эта команда заменяет содержимое минибуфера значением предыдущего (более
старого) элемента истории @var{n}, который завершает текущее содержимое
минибуфера перед точкой.
@end deffn

@deffn Command next-complete-history-element n
Эта команда заменяет содержимое минибуфера значением следующего (более
нового) элемента истории @var{n}, который завершает текущее содержимое
минибуфера перед точкой.
@end deffn


@node Minibuffer Windows
@section Окна Минибуфера
@cindex minibuffer windows

Эти функции получают доступ к окнам минибуфера и выбирают их, проверяют,
активны ли они, и управляют изменением их размера.

@defun minibuffer-window &optional frame
@anchor{Definition of minibuffer-window}
Эта функция возвращает окно минибуфера, используемое для кадра @var{frame}.
Если @var{frame} равен @code{nil}, это означает выбранный кадр.

Обратить внимание, что окно минибуфера, используемое кадром, не обязательно
должно быть частью этого кадра - кадр, не имеющий собственного минибуфера,
обязательно использует окно минибуфера какого-либо другого кадра.  Окно
минибуфера кадра без минибуфера можно изменить, установив параметр кадра
@code{minibuffer} этого кадра (@pxref{Buffer Parameters}).
@end defun

@defun set-minibuffer-window window
Эта функция указывает @var{window} в качестве окна минибуфера для
использования.  Это влияет на то, где отображается минибуфер, если
помещается в него текст, не вызывая обычные команды минибуфера.  Это не
влияет на обычные функции ввода минибуфера, потому что все они начинаются с
выбора окна минибуфера в соответствии с выбранным кадром.
@end defun

@c Emacs 19 feature
@defun window-minibuffer-p &optional window
Эта функция возвращает не-@code{nil}, если @var{window} является окном
минибуфера.  @var{window} по умолчанию используется в выбранном окне.
@end defun

Следующая функция возвращает окно, показывающее текущий активный минибуфер.

@defun active-minibuffer-window
Эта функция возвращает окно текущего активного минибуфера или @code{nil},
если нет активного минибуфера.
@end defun

Недостаточно определить, показывает ли данное окно текущий активный
минибуфер, сравнивая его с результатом @code{(minibuffer-window)}, потому
что может быть более одного окна минибуфера, если имеется более одного
кадра.

@defun minibuffer-window-active-p window
Эта функция возвращает не-@code{nil}, если @var{window} показывает текущий
активный минибуфер.
@end defun

Следующие два параметра определяют, будут ли окна минибуфера автоматически
изменяться и насколько они могут быть большими в процессе.

@defopt resize-mini-windows
Этот параметр определяет, будут ли окна минибуфера изменяться автоматически.
Значение по умолчанию - @code{grow-only}, что означает, что окно минибуфера
по умолчанию автоматически расширяется для размещения отображаемого текста и
сжимается до одной строки, как только минибуфер становится пустым.  Если
значение равно @code{t}, Emacs всегда будет пытаться подогнать высоту окна
минибуфера к отображаемому им тексту (минимум одной строкой).  Если значение
равно @code{nil}, окно минибуфера никогда не меняет размер автоматически.  В
этом случае можно использовать команды изменения размера окна
(@pxref{Resizing Windows}) для регулировки его высоты.
@end defopt

@defopt max-mini-window-height
Эта опция обеспечивает максимальную высоту для автоматического изменения
размеров окон минибуфера.  Число с плавающей запятой указывает часть высоты
кадра; целое число определяет максимальное количество строк.  Значение по
умолчанию - 0,25.
@end defopt

Обратить внимание, что значения двух вышеуказанных переменных вступают в
силу во время отображения, поэтому привязка их к коду, который создает
сообщения эхо-области, не будет работать.  Если потребуется предотвратить
изменение размера окон минибуфера при отображении длинных сообщений, вместо
этого привязывается переменная @code{message-truncate-lines}
(@pxref{Echo Area Customization}).


@node Minibuffer Contents
@section Содержимое Минибуфера
@cindex access minibuffer contents
@cindex minibuffer contents, accessing

  Эти функции обращаются к подсказке и содержимому минибуфера.

@defun minibuffer-prompt
Эта функция возвращает строку приглашения текущего активного минибуфера.
Если ни один минибуфер не активен, возвращается @code{nil}.
@end defun

@defun minibuffer-prompt-end
Эта функция возвращает текущую позицию конца подсказки минибуфера, если
минибуфер является текущим.  В противном случае возвращается минимальная
допустимая позицию в буфере.
@end defun

@defun minibuffer-prompt-width
Эта функция возвращает текущую ширину отображения подсказки минибуфера, если
минибуфер является текущим.  В противном случае возвращается ноль.
@end defun

@defun minibuffer-contents
Эта функция возвращает редактируемое содержимое минибуфера (то есть все,
кроме приглашения) в виде строки, если минибуфер является текущим.  В
противном случае возвращается все содержимое текущего буфера.
@end defun

@defun minibuffer-contents-no-properties
Это похоже на @code{minibuffer-contents}, за исключением того, что не
копируются свойства текста, а только сами символы.  @xref{Text Properties}.
@end defun

@deffn Command delete-minibuffer-contents
Эта команда стирает редактируемое содержимое минибуфера (то есть все, кроме
приглашения), если минибуфер текущий.  В противном случае стирается весь
текущий буфер.
@end deffn

@node Recursive Mini
@section Рекурсивные Минибуферы
@cindex recursive minibuffers

  Эти функции и переменные имеют дело с рекурсивными минибуферами.
(@pxref{Recursive Editing}):

@defun minibuffer-depth
Эта функция возвращает текущую глубину активаций минибуфера, неотрицательное
целое число.  Если ни один минибуфер не активен, возвращается ноль.
@end defun

@defopt enable-recursive-minibuffers
Если эта переменная - не-@code{nil}, можно вызывать команды (например,
@code{find-file}), которые используют минибуфер, даже когда минибуфер
активен.  Такой вызов создает рекурсивный уровень редактирования для нового
минибуфера.  Минибуфер внешнего уровня невидим, пока редактируется
внутренний.

Если эта переменная - @code{nil}, можно вызывать команды минибуфера, когда
минибуфер активен, даже если переключится для этого в другое окно.
@end defopt

@c Emacs 19 feature
Если имя команды имеет свойство @code{enable-recursive-minibuffers}, равное
не-@code{nil}, тогда команда может использовать минибуфер для чтения
аргументов, даже если вызывается из минибуфера.  Этого также можно добиться
с помощью привязки @code{enable-recursive-minibuffers} к @code{t} в
интерактивном объявлении (@pxref{Using Interactive}).  Последнее выполняет
команда минибуфера @code{next-matching-history-element} (обычно @kbd{M-s} в
минибуфере).

@node Minibuffer Misc
@section Минибуфер Разное

@defun minibufferp &optional buffer-or-name
Эта функция возвращает не-@code{nil}, если @var{buffer-or-name} - минибуфер.
Если @var{buffer-or-name} опущен, проверяется текущий буфер.
@end defun

@defvar minibuffer-setup-hook
Это нормальная ловушка, которая запускается всякий раз, когда вводится
минибуфер.  @xref{Hooks}.
@end defvar

@defmac minibuffer-with-setup-hook function &rest body
Этот макрос выполняет @var{body} после организации вызова указанного
@var{function} через @code{minibuffer-setup-hook}.  По умолчанию
@var{function} вызывается перед другими функциями в списке
@code{minibuffer-setup-hook}, но если @var{function} имеет форму
@w{@code{(:append @var{func})}}, @var{func}, @emph{после} будут вызываться 
другие функции ловушки.

Формы @var{body} не должны использовать минибуфер более одного раза.  Если
рекурсивно повторно войти в минибуфер, @var{function} будет вызываться
только один раз для внешнего использования минибуфера.
@end defmac

@defvar minibuffer-exit-hook
Это нормальная ловушка, которая запускается всякий раз, когда минибуфер
выходит из строя.  @xref{Hooks}.
@end defvar

@defvar minibuffer-help-form
@anchor{Definition of minibuffer-help-form}
Текущее значение этой переменной используется для переназначения
@code{help-form} локально внутри минибуфера (@pxref{Help Functions}).
@end defvar

@defvar minibuffer-scroll-window
@anchor{Definition of minibuffer-scroll-window}
Если значение этой переменной - не-@code{nil}, это должен быть объект окна.
Когда в минибуфере вызывается функция @code{scroll-other-window}, она
прокручивает это окно.
@end defvar

@defun minibuffer-selected-window
Эта функция возвращает окно, которое было выбрано непосредственно перед тем,
как было выбрано окно минибуфера.  Если выбранное окно не является окном
минибуфера, оно возвращает @code{nil}.
@end defun

@vindex minibuffer-message-timeout
@defun minibuffer-message string &rest args
Эта функция временно отображает @var{string} в конце текста минибуфера на
несколько секунд или до наступления следующего события ввода, в зависимости
от того, что наступит раньше.  Переменная @code{minibuffer-message-timeout}
указывает количество секунд ожидания при отсутствии ввода.  По умолчанию -
2.  Если @var{args} - не-@code{nil}, фактическое сообщение получается путем
передачи @var{string} и @var{args} через @code{format-message}.
@xref{Formatting Strings}.
@end defun

@deffn Command minibuffer-inactive-mode
Это основной режим, используемый в неактивных минибуферах.  Он использует
карту @code{minibuffer-inactive-mode-map}.  Это может быть полезно, если
минибуфер находится в отдельном кадре.   @xref{Minibuffers and Frames}.
@end deffn
