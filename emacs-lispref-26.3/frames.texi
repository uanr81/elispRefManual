@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2019 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Frames
@chapter Фреймы
@cindex frame

  @dfn{Фрейм} - экранный объект, содержащий одно или несколько окон Emacs
(@pxref{Windows}).  Это объект, который в терминологии графической среды
называется ``окно''; но здесь не получится назвать ``окном'', потому что
Emacs использует это слово для-другого.  В Emacs Lisp @dfn{объект фрейм} -
это объект Lisp, представляющий фрейм на экране.  @xref{Frame Type}.

  Фрейм изначально содержит одно главное окно и/или окно минибуфера; можно
разделить главное окно по вертикали или горизонтали на более мелкие окна.
@xref{Splitting Windows}.

@cindex terminal
  @dfn{Терминал} - это устройство отображения, способное отображать один или
несколько фреймов Emacs.  В Emacs Lisp @dfn{объект терминал} - это объект
Lisp, представляющий терминал.  @xref{Terminal Type}.

@cindex text terminal
@cindex graphical terminal
@cindex graphical display
  Есть два класса терминалов: @dfn{текстовые терминалы} и
@dfn{графические терминалы}.  Текстовые терминалы - это дисплеи без
поддержки графики, включая @command{xterm} и другие эмуляторы терминала.  В
текстовом терминале каждый фрейм Emacs занимает весь экран терминала; хотя
можно создавать дополнительные фреймы и переключаться между ними, терминал
показывает только фрейм за раз.  С другой стороны, графические терминалы
управляются системами графического отображения, такими как X Window System,
которые позволяют Emacs отображать несколько фреймов одновременно на одном и
том же дисплее.

  В системах GNU и Unix можно создавать дополнительные фреймы на любом
доступном терминале в рамках одного сеанса Emacs, независимо от того, был ли
Emacs запущен на текстовом или графическом терминале.  Emacs может
одновременно отображать как на графическом, так и на текстовом терминалах.
Это удобно, например, когда подключаться к одному сеансу из нескольких
удаленных мест.  @xref{Multiple Terminals}.

@defun framep object
Этот предикат возвращает значение не-@code{nil}, если @var{object} является
фреймом, и @code{nil} в противном случае.  Для фрейма значение указывает,
какой вид отображения используется в фрейме:

@table @code
@item t
Фрейм отображается на текстовом терминале.
@item x
Фрейм отображается на графическом терминале X.
@item w32
Фрейм отображается на графическом терминале MS-Windows.
@item ns
Фрейм отображается в графическом терминале GNUstep или Macintosh Cocoa.
@item pc
Фрейм отображается на терминале MS-DOS.
@end table
@end defun

@defun frame-terminal &optional frame
Функция возвращает объект терминала, который отображает @var{frame}.  Если
@var{frame} равен @code{nil} или не указан, по умолчанию используется
выбранный фрейм.
@end defun

@defun terminal-live-p object
Этот предикат возвращает значение не-@code{nil}, если @var{object} - это
активный терминал (то есть не удаленный), и @code{nil} в противном случае.
Для работающих терминалов возвращаемое значение указывает, какие фреймы
отображаются на этом терминале; список возможных значений такой же, как и
для @code{framep} выше.
@end defun

@cindex top-level frame
На графическом терминале различаются два типа фреймов: Обычный
@dfn{фрейм верхнего уровня} - это фрейм, окно оконной системы которого
является дочерним по отношению к корневому окну оконной системы для этого
терминала.  Дочерний фрейм - это фрейм, окно оконной системы которого
является дочерним по отношению к окну оконной системы другого фрейма Emacs.
@xref{Child Frames}.

@menu
* Creating Frames::             Создание дополнительных рамок.
* Multiple Terminals::         Отображение на нескольких разных устройствах.
* Frame Geometry::              Геометрические свойства фреймов.
* Frame Parameters::            Управление размером фрейма, положением,
                                   шрифтом и так далее.
* Terminal Parameters::         Параметры общие для всех фреймов
                                   на терминале.
* Frame Titles::               Автоматическое обновление заголовков фреймов.
* Deleting Frames::             Фреймы сохраняются до тех пор, пока не
                                   будут удалены явным образом.
* Finding All Frames::          Как изучить все существующие фреймы.
* Minibuffers and Frames::      Как фрейм находит используемый минибуфер.
* Input Focus::                 Указание выбранного кадра.
* Visibility of Frames::        Фреймы могут быть видимыми или невидимыми,
                                   а также значками.
* Raising and Lowering::        Подъем, опускание и перестановка фреймов.
* Frame Configurations::        Сохранение состояния всех кадров.
* Child Frames::                Делаем фрейм потомком для другого.
* Mouse Tracking::              Получение событий, которые говорят,
                                   когда движется мышь.
* Mouse Position::              Узнать положение мыши, перемещение мыши.
* Pop-Up Menus::                Отображение меню для выбора пользователем.
* Dialog Boxes::                Отображение поля, чтобы спросить да или нет.
* Pointer Shape::               Указание формы указателя мыши.
* Window System Selections::    Передача текста другим X-клиентам и от них.
* Drag and Drop::               Внутреннее устройство реализации
                                   Drag-and-Drop.
* Color Names::                 Получение определений названий цветов.
* Text Terminal Colors::        Определение цветов для текстовых терминалов.
* Resources::                   Получение значений ресурсов с сервера.
* Display Feature Testing::     Определение возможностей терминала.
@end menu


@node Creating Frames
@section Создание Фреймов
@cindex frame creation

Чтобы создать новый фрейм, вызывается функция @code{make-frame}.

@deffn Command make-frame &optional parameters
Функция создает и возвращает новый фрейм, отображающий текущий буфер.

Аргумент @var{parameters} - это список, который определяет параметры фрейма
для нового фрейма.  @xref{Frame Parameters}.  Если указан параметр
@code{terminal} в @var{parameters}, новый фрейм будет создан на этом
терминале.  В противном случае, если указан параметр фрейма
@code{window-system} в @var{parameters}, определяется, должен ли фрейм
отображаться на текстовом терминале или графическом терминале.
@xref{Window Systems}.  Если ни один из них не указан, новый фрейм создается
в том же терминале, что и выбранный фрейм.

Любые параметры, не упомянутые в @var{parameters}, по умолчанию равны
значениям в alist @code{default-frame-alist} (@pxref{Initial Parameters});
параметры, не указанные там, по умолчанию из ресурсов X или их эквивалента в
вашей операционной системе
(@pxref{X Resources,, X Resources, emacs, The GNU Emacs Manual}).  После
создания фрейма эта функция применяет любые параметры, указанные в
@code{frame-inherited-parameters} (смотреть ниже), которым еще не назначено,
беря значения из фрейма, который был выбран при вызове @code{make-frame}.

Обратить внимание, что на многомониторных дисплеях
(@pxref{Multiple Terminals}) оконный менеджер может позиционировать фрейм
иначе, чем указано в позиционных параметрах в @var{parameters}
(@pxref{Position Parameters}).  Например, у некоторых оконных менеджеров
есть политика отображения фрейма на мониторе, который содержит большую часть
окна (оно же @: монитор @dfn{доминирующий}).

Сама функция не делает новый фрейм выбранным. @xref{Input Focus}.  Ранее
выбранный фрейм остается выбранным.  Однако на графических терминалах
оконная система может выбрать новый фрейм по своим причинам.
@end deffn

@defvar before-make-frame-hook
Обычный обработчик, запускаемый @code{make-frame} перед созданием фрейма.
@end defvar

@defvar after-make-frame-functions
Аномальный перехватчик, запущенный @code{make-frame} после создания фрейма.
Каждая функция в @code{after-make-frame-functions} получает один аргумент -
только что созданный фрейм.
@end defvar

Обратить внимание, что любые функции, добавленные к этим перехватчикам вашим
начальным файлом, обычно не запускаются для начального фрейма, поскольку
Emacs читает начальный файл только после создания этого фрейма.  Однако,
если начальный фрейм задан для использования отдельного фрейма минибуфера
(@pxref{Minibuffers and Frames}), функции будут выполняться как для фрейма
без минибуфера, так и для фрейма минибуфера.

@defvar frame-inherited-parameters
Переменная определяет список параметров фрейма, которые вновь созданный
фрейм наследует от текущего выбранного фрейма.  Для каждого параметра
(символа), который является элементом в этом списке и не был назначен ранее
при обработке @code{make-frame}, функция устанавливает значение этого
параметра в созданном фрейме равным его значению в выбранном фрейме.
@end defvar


@node Multiple Terminals
@section Несколько Терминалов
@cindex multiple terminals
@cindex multi-tty
@cindex multiple X displays
@cindex displays, multiple

  Emacs представляет каждый терминал как тип данных @dfn{объект терминал}
(@pxref{Terminal Type}).  В системах GNU и Unix Emacs может использовать
несколько терминалов одновременно в каждом сеансе.  В других системах может
использовать только один терминал.  Каждый терминальный объект имеет
следующие атрибуты:

@itemize @bullet
@item
Название устройства, используемого терминалом. (такое как, @samp{:0.0} или
@file{/dev/tty}).

@item
Системы кодирования терминала и клавиатуры, используемые на терминале.
@xref{Terminal I/O Encoding}.

@item
Вид дисплея, связанный с терминалом.  Это символ, возвращаемый функцией
@code{terminal-live-p} (такое как, @code{x}, @code{t}, @code{w32},
@code{ns}, или @code{pc}).  @xref{Frames}.

@item
Список параметров терминала.  @xref{Terminal Parameters}.
@end itemize

  Примитива для создания терминальных объектов нет.  Emacs создает их по
мере необходимости, например, когда вызывается @code{make-frame-on-display}
(описано ниже).

@defun terminal-name &optional terminal
Функция возвращает имя файла устройства, используемого @var{terminal}.  Если
@var{terminal} опущен или @code{nil}, по умолчанию используется терминал
выбранного фрейма.  @var{terminal} также может быть фреймом, что означает
его терминал.
@end defun

@defun terminal-list
Функция возвращает список всех активных терминальных объектов.
@end defun

@defun get-device-terminal device
Функция возвращает терминал, имя устройства которого задано @var{device}.
Если @var{device} - строка, это может быть либо имя файла терминального
устройства, либо имя X-дисплея в форме
@samp{@var{host}:@var{server}.@var{screen}}.  Если @var{device} - это фрейм,
функция возвращает терминал этого фрейма; @code{nil} означает выбранный
фрейм.  Наконец, если @var{device} - это объект терминала, представляющий
работающий терминал, этот терминал возвращается.  Функция сигнализирует об
ошибке, если ее аргумент не соответствует ни одному из вышеперечисленных.
@end defun

@defun delete-terminal &optional terminal force
Функция удаляет все фреймы на @var{terminal} и освобождает используемые им
ресурсы.  Запускает ненормальную ловушку @code{delete-terminal-functions},
передавая @var{terminal} в качестве аргумента каждой функции.

Если @var{terminal} опущен или @code{nil}, по умолчанию используется
терминал выбранного фрейма.  @var{terminal} также может быть фреймом, что
означает его терминал.

Обычно функция сигнализирует об ошибке, если попытаться удалить единственный
активный терминал, но если @var{force} - не-@code{nil}, это можно сделать.
Emacs автоматически вызывает эту функцию, когда последний фрейм на терминале
удаляется (@pxref{Deleting Frames}).
@end defun

@defvar delete-terminal-functions
Ненормальная ловушка, запускаемая @code{delete-terminal}.  Каждая функция
получает один аргумент, аргумент @var{terminal} передается в
@code{delete-terminal}.  По техническим причинам функции могут вызываться
либо непосредственно перед удалением терминала, либо сразу после него.
@end defvar

@cindex terminal-local variables
  Несколько переменных Lisp: @dfn{terminal-local}; то есть у них есть
отдельная привязка для каждого терминала.  В любой момент действует привязка
для терминала, которому принадлежит текущий выбранный фрейм.  Эти переменные
включают @code{default-minibuffer-frame}, @code{defining-kbd-macro},
@code{last-kbd-macro} и @code{system-key-alist}.  Они всегда локальны для
терминала и никогда не могут быть локальными для буфера
(@pxref{Buffer-Local Variables}).

  В системах GNU и Unix каждый дисплей X представляет собой отдельный
графический терминал.  Когда Emacs запускается из оконной системы X, он
использует отображение X, заданное переменной среды @env{DISPLAY} или
параметром @samp{--display}
(@pxref{Initial Options,,, emacs, The GNU Emacs Manual}).  Emacs может
подключаться к другим дисплеям X с помощью команды
@code{make-frame-on-display}.  Каждый X-дисплей имеет свой собственный
выбранный фрейм и свои собственные окна минибуфера; однако только один из
этих фреймов является @emph{по настоящему} выбранным фреймом в любой момент
(@pxref{Input Focus}).  Emacs может даже подключаться к другим текстовым
терминалам, взаимодействуя с программой @command{emacsclient}.
@xref{Emacs Server,,, emacs, The GNU Emacs Manual}.

@cindex X display names
@cindex display name on X
  Один X-сервер может обрабатывать более одного дисплея.  Каждый дисплей X
имеет имя, состоящее из трех частей,
@samp{@var{hostname}:@var{displaynumber}.@var{screennumber}}.  Первая часть,
@var{hostname}, определяет имя машины, к которой физически подключен
дисплей.  Вторая часть, @var{displaynumber}, представляет собой
отсчитываемое от нуля число, которое идентифицирует один или несколько
мониторов, подключенных к этому компьютеру, которые имеют общую клавиатуру и
указывающее устройство (мышь, планшет и так далее).  Третья часть,
@var{screennumber}, определяет отсчитываемый от нуля номер экрана (отдельный
монитор), который является частью одной коллекции мониторов на этом
X-сервере.  Когда используется два или более экрана, принадлежащих одному
серверу, Emacs знает по схожести их имен, что они используют одну
ключевую карту.

  Системы, которые не используют систему X Window, такие как MS-Windows, не
поддерживают понятие X-дисплеев и имеют только один дисплей на каждом хосте.
Отображаемое имя в этих системах не соответствует указанному выше формату из
трех частей; например, отображаемое имя в системах MS-Windows представляет
собой постоянную строку @samp{w32} и существует для совместимости, чтобы
иметь возможность передавать ее функциям, ожидающим отображаемое имя.

@deffn Command make-frame-on-display display &optional parameters
Функция создает и возвращает новый фрейм на @var{display}, беря другие
параметры фрейма из alist @var{parameters}.  @var{display} должно быть
именем X-дисплея (строка).

Перед созданием фрейма эта функция гарантирует, что Emacs настроен для
отображения графики.  Например, если Emacs не обработал X-ресурсы (например,
если он был запущен на текстовом терминале), он делает это в это время.  В
остальном эта функция ведет себя как @code{make-frame}
(@pxref{Creating Frames}).
@end deffn

@defun x-display-list
Функция возвращает список, указывающий, к какому отображению X имеет
соединение Emacs.  Элементы списка представляют собой строки, и каждый из
них является отображаемым именем.
@end defun

@defun x-open-connection display &optional xrm-string must-succeed
Функция открывает соединение с X-дисплеем @var{display} без создания фрейма
на этом дисплее.  Обычно программы Emacs Lisp не нуждаются в вызове этой
функции, поскольку @code{make-frame-on-display} вызывает ее автоматически.
Единственная причина для его вызова - проверить, можно ли установить связь
с данным дисплеем X.

Необязательный аргумент @var{xrm-string}, если не @code{nil}, представляет
собой строку имен и значений ресурсов в том же формате, что и в файле
@file{.Xresources}.
@xref{X Resources,, X Resources, emacs, The GNU Emacs Manual}. Эти значения
применяются ко всем фреймам Emacs, созданным на этом дисплее, перекрывая
значения ресурсов, записанные на X-сервере.  Вот пример того, как может
выглядеть эта строка:

@example
"*BorderWidth: 3\n*InternalBorder: 2\n"
@end example

Если @var{must-succeed} равен не-@code{nil}, то при отказе от открытия
соединения Emacs завершается.  В противном случае это обычная ошибка Lisp.
@end defun

@defun x-close-connection display
Функция закрывает соединение для отображения @var{display}.  Прежде чем
можно это сделать, потребуется сначала удалить все фреймы, которые были
открыты на этом дисплее (@pxref{Deleting Frames}).
@end defun

@cindex multi-monitor
  В некоторых конфигурациях с несколькими мониторами один X-дисплей
выводится на несколько физических мониторов.  Можно использовать функции
@code{display-monitor-attributes-list} и @code{frame-monitor-attributes} для
получения информации о таких настройках.

@defun display-monitor-attributes-list &optional display
Функция возвращает список атрибутов физического монитора на @var{display},
который может быть отображаемым именем (строкой), терминалом или фреймом;
если опущено или @code{nil}, по умолчанию используется отображение
выбранного фрейма.  Каждый элемент списка представляет собой список
ассоциаций, представляющий атрибуты физического монитора.  Первый элемент
соответствует основному монитору.  Ключи и значения атрибутов::

@table @samp
@item geometry
Положение левого верхнего угла экрана монитора и его размер в пикселях как
@samp{(@var{x} @var{y} @var{width} @var{height})}.  Обратить внимание: если
монитор не является основным, некоторые координаты могут быть
отрицательными.

@item workarea
Положение левого верхнего угла и размер рабочей области (полезного
пространства) в пикселях формируется как
@samp{(@var{x} @var{y} @var{width} @var{height})}.  Это может отличаться от
@samp{geometry} тем, что пространство занято различными функциями оконного
менеджера (доки, панели задач и так далее)@: и может быть исключено из
рабочей зоны.  То, действительно ли такие функции удаляются из рабочей
области, зависит от платформы и среды.  Опять же, если монитор не является
основным монитором, некоторые координаты могут быть отрицательными.

@item mm-size
Ширина и высота в миллиметрах как @samp{(@var{width} @var{height})}

@item frames
Список фреймов, доминирующих на этом физическом мониторе (смотреть ниже).

@item name
Имя физического монитора @var{string}.

@item source
Источник мультимониторной информации как @var{string}; например,
@samp{XRandr} или @samp{Xinerama}.
@end table

@var{x}, @var{y}, @var{width} и @var{height} целые числа.
@samp{name} и @samp{source} могут отсутствовать.

Фрейм становится @dfn{доминирующим} на физическом мониторе, когда либо самая
большая область фрема находится на этом мониторе, либо (если кадр не
пересекает никакие физические мониторы) этот монитор является ближайшим к
фрейму.  В каждом (не всплывающем) фрейме (видимом или невидимом) на
графическом дисплее доминирует ровно один физический монитор за раз, хотя
фрейм может охватывать несколько (или ни одного) физических мониторов.

Вот пример данных, созданных этой функцией на дисплее с двумя мониторами:

@lisp
  (display-monitor-attributes-list)
  @result{}
  (((geometry 0 0 1920 1080) ;; @r{Левая основная панель задач monitor}
    (workarea 0 0 1920 1050) ;; @r{занимает часть высоты}
    (mm-size 677 381)
    (name . "DISPLAY1")
    (frames #<frame emacs@@host *Messages* 0x11578c0>
            #<frame emacs@@host *scratch* 0x114b838>))
   ((geometry 1920 0 1680 1050) ;; @r{Правый монитор }
    (workarea 1920 0 1680 1050) ;; @r{можно использовать весь экран}
    (mm-size 593 370)
    (name . "DISPLAY2")
    (frames)))
@end lisp

@end defun

@defun frame-monitor-attributes &optional frame
Функция возвращает атрибуты доминирующего физического монитора (смотреть
выше) @var{frame}, который по умолчанию соответствует выбранному фрейму.
@end defun


@node Frame Geometry
@section Геометрия Фрейма
@cindex frame geometry
@cindex frame position
@cindex position of frame
@cindex frame size
@cindex size of frame

Геометрия фрейма зависит от набора инструментов, который использовался для
создания этого экземпляра Emacs, и терминала, отображающего фрейм.  В этой
главе описаны эти зависимости и некоторые функции для их устранения.
Обратить внимание, что аргумент @var{frame} всех этих функций должен
указывать активный фрейм (@pxref{Deleting Frames}).  Если опущено или
@code{nil}, указывается выбранный фрейм (@pxref{Input Focus}).

@menu
* Frame Layout::            Базовая компоновка фреймов.
* Frame Font::              Шрифт фрейма по умолчанию и как его установить.
* Frame Position::          Положение фрейма на его дисплее.
* Frame Size::              Определение и получение размера фрейма.
* Implied Frame Resizing::  Подразумевается изменение размера фреймов и
                               как этого избежать.
@end menu


@node Frame Layout
@subsection Макет Фрейма
@cindex frame layout
@cindex layout of frame

Видимая фрейм занимает прямоугольную область на дисплее терминала.  Эта
область может содержать несколько вложенных прямоугольников, каждый из
которых служит своей цели.  На приведенном ниже рисунке схематично показано
расположение фрейма на графическом терминале.:
@smallexample
@group

        <------------ Outer Frame Width ----------->
        ____________________________________________
     ^(0)  ________ External/Outer Border _______   |
     | |  |_____________ Title Bar ______________|  |
     | | (1)_____________ Menu Bar ______________|  | ^
     | | (2)_____________ Tool Bar ______________|  | ^
     | | (3) _________ Internal Border ________  |  | ^
     | |  | |   ^                              | |  | |
     | |  | |   |                              | |  | |
Outer  |  | | Inner                            | |  | Native
Frame  |  | | Frame                            | |  | Frame
Height |  | | Height                           | |  | Height
     | |  | |   |                              | |  | |
     | |  | |<--+--- Inner Frame Width ------->| |  | |
     | |  | |   |                              | |  | |
     | |  | |___v______________________________| |  | |
     | |  |___________ Internal Border __________|  | v
     v |___________ External/Outer Border __________|
           <-------- Native Frame Width -------->

@end group
@end smallexample

На практике не все области, показанные на чертеже, будут или могут
присутствовать.  Значение этих областей описано ниже.

@table @asis
@item Outer Frame
@cindex outer frame
@cindex outer edges
@cindex outer width
@cindex outer height
@cindex outer size
@dfn{outer frame} - это прямоугольник, включающий все области, показанные на
чертеже.  Края этого прямоугольника называются @dfn{outer edges} фрейма.
Вместе @dfn{outer width} и @dfn{outer height} фрейма задают @dfn{outer size}
этого прямоугольника.

Знание внешнего размера фрейма полезно для размещения фрейма в рабочей
области его дисплея (@pxref{Multiple Terminals}) или для размещения двух
фреймов рядом друг с другом на экране.  Обычно внешний размер фрейма
доступен только после того, как фрейм был отображен (сделан видимым,
@pxref{Visibility of Frames}) хотя бы один раз.  Для начального фрейма или
фрейма, который еще не был создан, внешний размер может быть только оценен
или должен быть вычисляется из значений по умолчанию оконной системы или
оконного менеджера.  Один обходной путь состоит в том, чтобы получить
различия внешнего и собственного (смотреть ниже) размеров отображаемого
фрейма и использовать их для вычисления внешнего размера нового фрейма.

@cindex outer position
Положение верхнего левого угла внешнего фрейма (обозначено @samp{(0)} на
рисунке выше) - это @dfn{outer position} фрейма.  Внешнее положение
графического фрейма также называется ``позиция'' фрейма, потому что оно
обычно остается неизменным на его дисплее всякий раз, когда изменяется
размер фрейма или изменяется его макет.

Внешняя позиция определяется и может быть установлена через параметры фрейма
@code{left} и @code{top} (@pxref{Position Parameters}).  Для обычного фрейма
верхнего уровня эти параметры обычно представляют его абсолютное положение
(смотреть ниже) по отношению к исходной точке его отображения.  Для
дочернего фрейма (@pxref{Child Frames}) эти параметры представляют его
положение относительно исходного положения (смотреть ниже) его родительского
фрейма.  Для фреймов на текстовых терминалах значения этих параметров
бессмысленны и всегда равны нулю.

@item External Border
@cindex external border
@dfn{external border} - это часть декораций, предоставляемых оконным
менеджером.  Обычно используется для изменения размера фрейма с помощью мыши
и поэтому не отображается в ``fullboth'' и максимальных параметрах фрейма
(@pxref{Size Parameters}).  Его ширина определяется оконным менеджером и не
может быть изменена функциями Emacs.

На фреймах текстового терминала отсутствуют внешние границы.  Для
графических фреймов их отображение можно запретить, установив параметр
фрейма @code{override-redirect} или @code{undecorated}
(@pxref{Management Parameters}).

@item Outer Border
@cindex outer border
@dfn{outer border} - это отдельный фрейм рамка, ширину которого можно
указать с помощью параметра фрейма @code{border-width}
(@pxref{Layout Parameters}).  На практике отображается либо внешняя, либо
внешняя граница фрейма, но никогда обе одновременно.  Обычно внешняя граница
отображается только для специальных фреймов, которые не (полностью)
контролируются оконным менеджером, например фреймы всплывающих подсказок
(@pxref{Tooltips}), дочерние фреймы (@pxref{Child Frames}) и
@code{undecorated} или @code{override-redirect} фреймы
(@pxref{Management Parameters}).

Внешние границы никогда не отображаются на фреймах текстового терминала и
фреймах, сгенерированных подпрограммами GTK+.  В MS-Windows внешняя граница
эмулируется с помощью внешней границы шириной в один пиксель.
Не-инструментальные сборки на X позволяют изменять цвет внешней границы,
задав параметр фрейма @code{border-color} (@pxref{Layout Parameters}).

@item Title Bar
@cindex title bar
@cindex caption bar
@dfn{title bar}, он же @dfn{caption bar}, также является частью декораций
оконного менеджера и обычно отображает заголовок фрейма
(@pxref{Frame Titles}), а также кнопки для минимизации, развертывания и
удаления фрейма.  Его также можно использовать для перетаскивания фрейма
мышью.  Строка заголовка обычно не отображается для всех фреймов
(@pxref{Size Parameters}), всплывающих подсказок (@pxref{Tooltips}) и
дочерних фреймов (@pxref{Child Frames}) и не существует для оконечных
фреймов.  Отображение строки заголовка можно отключить, задав параметры
фрейма @code{override-redirect} или @code{undecorated}
(@pxref{Management Parameters}).

@item Menu Bar
@cindex internal menu bar
@cindex external menu bar
Строка меню (@pxref{Menu Bar}) может быть внутренней (нарисованной самим
Emacs) или внешней (нарисованной набором инструментов).  Большинство сборок
(GTK+, Lucid, Motif и MS-Windows) полагаются на внешнюю строку меню.  NS
также использует внешнюю строку меню, которая, однако, не является частью
внешнего фрейма.  Сборки без инструментов могут содержать внутреннюю строку
меню.  В фреймах текстового терминала строка меню является частью корневого
окна фрейма (@pxref{Windows and Frames}).  Как правило, в дочерних фреймах
(@pxref{Child Frames}) строки меню никогда не отображаются.  Отображение
строки меню можно отключить, установив параметр @code{menu-bar-lines}
(@pxref{Layout Parameters}) равным нулю.

Будет ли строка меню обернута или усечена, когда ее ширина становится
слишком большой, чтобы поместиться в ее фрейм, зависит от набора
инструментов.  Обычно только сборки Motif и MS-Windows могут обернуть строку
меню.  Когда они (отменяют) обёртывают строки меню, стараются сохранить
внешнюю высоту фрейма неизменной, поэтому вместо этого изменится собственная
высота фрейма (смотреть ниже).

@item Tool Bar
@cindex internal tool bar
@cindex external tool bar
Как и строка меню, панель инструментов (@pxref{Tool Bar}) может быть
внутренней (нарисованная самим Emacs) или внешней (нарисованная набором
инструментов).  В сборках GTK + и NS панель инструментов нарисована набором
инструментов.  В остальных сборках используются внутренние панели
инструментов.  С GTK+ панель инструментов может быть расположена с любой
стороны фрейма, сразу за внутренней границей, смотреть ниже.  Панели
инструментов обычно не отображаются для дочерних фреймов
(@pxref{Child Frames}).  Отображение панели инструментов можно отключить,
установив параметр @code{tool-bar-lines} (@pxref{Layout Parameters}) равным
нулю.

Если переменная @code{auto-resize-tool-bars} равна не-@code{nil}, Emacs
оборачивает внутреннюю панель инструментов, когда ее ширина становится
слишком большой для ее фрейма.  Если и когда Emacs (отменяет-) обертывает
внутреннюю панель инструментов, по умолчанию сохраняет внешнюю высоту фрейма
неизменной, поэтому вместо этого изменится собственная высота фрейма
(смотреть ниже). Emacs, созданный с помощью GTK +, с другой стороны, никогда
не оборачивает панель инструментов, но может автоматически увеличивать
внешнюю ширину фрейма, чтобы приспособить слишком длинную панель
инструментов.

@item Native Frame
@cindex native frame
@cindex native edges
@cindex native width
@cindex native height
@cindex native size
@dfn{native frame} - это прямоугольник, полностью расположенный внутри
внешнего фрейма.  Он исключает области, занятые внешней границей, строкой
заголовка и любым внешним меню или панелью инструментов.  Края родного
фрейма называются @dfn{native edges} фрейма.  Вместе @dfn{native width} и
@dfn{native height} фрейма определяют @dfn{native size} фрейма.

Собственный размер фрейма - это размер, который Emacs передает оконной
системе или оконному менеджеру при создании или изменении размера фрейма из
Emacs.  Это также размер, который Emacs получает от оконной системы или
оконного менеджера всякий раз, когда они изменяют размер окна оконной
системы фрейма, например, после максимизации фрейма путем нажатия
соответствующей кнопки в строке заголовка или при перетаскивании его внешней
границы мышью.

@cindex native position
Положение верхнего левого угла собственного фрейма определяет
@dfn{native position} фрейма.  (1) - (3) на рисунке выше указывают, что
положение для различных сборок:

@itemize @w{}
@item (1) не-toolkit и терминальные фреймы

@item (2) Lucid, Motif и MS-Windows фреймы

@item (3) GTK+ и NS фреймы
@end itemize

Соответственно, собственная высота фрейма может включать высоту панели
инструментов, но не высоту строки меню (Lucid, Motif, MS-Windows) или высоту
строки меню и панели инструментов (фреймы без инструментов и текстовые
терминалы).

Собственная позиция фрейма - это опорная позиция для функций, которые
устанавливают или возвращают текущую позицию мыши (@pxref{Mouse Position}),
а также для функций, работающих с положением окон, таких как
@code{window-edges}, @code{window-at} или @code{coordinates-in-window-p}
(@pxref{Coordinates and Windows}).  Также определяет (0, 0) источник для
поиска и позиционирования дочерних фреймов внутри этого фрейма
(@pxref{Child Frames}).

Также обратить внимание, что исходное положение фрейма обычно остается
неизменным на его дисплее при удалении или добавлении декораций оконного
менеджера путем изменения параметра фрейма @code{override-redirect} или
@code{undecorated} (@pxref{Management Parameters}).

@item Internal Border
Внутренняя граница - это граница, нарисованная Emacs вокруг внутреннего
фрейма (смотреть ниже).  Её ширина задается параметром фрейма
@code{internal-border-width} (@pxref{Layout Parameters}).  Её цвет
определяется фоном фрейма @code{internal-border}.

@item Inner Frame
@cindex inner frame
@cindex inner edges
@cindex inner width
@cindex inner height
@cindex inner size
@cindex display area
@dfn{inner frame} - это прямоугольник, зарезервированный для окон фрейма.
Заключен во внутренний фрейм, который, однако, не является частью
внутреннего фрейма.  Его края называются @dfn{inner edges} фрейма.
@dfn{inner width} и @dfn{inner height} указывают @dfn{inner size}
прямоугольника.  Внутренний фрейм иногда также называют @dfn{display area}
фрейма.

@cindex minibuffer-less frame
@cindex minibuffer-only frame
Как правило, внутренний фрейм подразделяется на корневое окно фрейма
(@pxref{Windows and Frames}) и окно минибуфера фрейма
(@pxref{Minibuffer Windows}).  Из этого правила есть два заметных
исключения: @dfn{minibuffer-less frame} содержит только корневое окно и не
содержит окно минибуфера.  @dfn{minibuffer-only frame} содержит только окно
минибуфера, которое также служит корневым окном этого фрейма.
@ref{Initial Parameters} о том, как создавать такие конфигурации фреймов.

@item Text Area
@cindex text area
@dfn{text area} фрейма - это несколько вымышленная область, которая может
быть встроена в исходный фрейм.  Её положение не указано.  Её ширину можно
получить, удалив из исходной ширины ширину внутренней границы, одной
вертикальной полосы прокрутки, а также одной левой и одной правой кромок,
если они указаны для этого фрейма, @ref{Layout Parameters}.  Её высоту можно
получить, удалив из исходной высоты ширину внутренней границы и высоту
внутреннего меню и панелей инструментов фрейма, а также одну горизонтальную
полосу прокрутки, если она указана для этого фрейма.
@end table

@cindex absolute position
@cindex absolute frame position
@cindex absolute edges
@cindex absolute frame edges
@cindex display origin
@cindex origin of display
@dfn{absolute position} кадра задается как пара (X, Y) горизонтальных и
вертикальных смещений пикселей относительно исходной точки (0, 0)
отображения фрейма.  Соответственно, @dfn{absolute edges} фрейма задаются
как пиксельные смещения от этого источника.

  Обратить внимание, что при использовании нескольких мониторов исходная
точка дисплея не обязательно совпадает с верхним левым углом всей
используемой области отображения терминала.  Следовательно, абсолютное
положение фрейма может быть отрицательным в такой среде, даже когда этот
фрейм полностью виден.

  По соглашению вертикальные смещения увеличивают ``downwards''.  Это
означает, что высота фрейма получается вычитанием смещения его верхнего края
из смещения его нижнего края.  Горизонтальные смещения увеличивают
``rightwards'', как и ожидалось, поэтому ширина фрейма рассчитывается путем
вычитания смещения его левого края из смещения его правого края.

  Для фрейма на графическом терминале следующая функция возвращает размеры
описанных выше областей.:

@defun frame-geometry &optional frame
Функция возвращает геометрические атрибуты @var{frame}.  Возвращаемое
значение - это список ассоциаций атрибутов, перечисленных ниже.  Все
значения координат, высоты и ширины являются целыми числами, считая пиксели.
Обратить внимание, что если @var{frame} еще не отображен,
(@pxref{Visibility of Frames}) некоторые из возвращаемых значений могут
представлять только приближения фактических значений - тех, которые можно
увидеть после отображения фрейма.

@table @code
@item outer-position
Cons-ячейка, представляющая абсолютную позицию внешнего @var{frame}
относительно начала координат в позиции (0, 0) отображения @var{frame}.

@item outer-size
Cons-ячейка внешней ширины и высоты @var{frame}.

@item external-border-size
Cons-ячейка горизонтальной и вертикальной ширины внешних границ @var{frame},
предоставляемых оконным менеджером.  Если оконный менеджер не предоставляет
эти значения, Emacs попытается угадать их по координатам внешнего и
внутреннего фрейма.

@item outer-border-width
Ширина внешней границы @var{frame}.  Значение имеет смысл только для сборок,
не относящихся к GTK+ и X.

@item title-bar-size
Cons-ячейки ширины и высоты строки заголовка @var{frame}, предоставляемые
оконным менеджером или операционной системой.  Если обе они равны нулю, у
фрейма нет строки заголовка.  Если только ширина равна нулю, Emacs не смог
получить информацию о ширине.

@item menu-bar-external
Если не-@code{nil}, это означает, что строка меню является внешней (не
является частью собственного фрейма @var{frame}).

@item menu-bar-size
Cons-ячейки ширины и высоты строки меню @var{frame}.

@item tool-bar-external
Если не-@code{nil}, это означает, что панель инструментов является внешней
(не является частью собственного фрейма @var{frame}).

@item tool-bar-position
Говорит о том, с какой стороны находится панель инструментов на @var{frame},
и может быть одним из @code{left}, @code{top}, @code{right} или
@code{bottom}.  Единственный инструментарий, который в настоящее время
поддерживает значение, отличное от @code{top} - это GTK+.

@item tool-bar-size
Cons-чейки ширины и высоты панели инструментов @var{frame}.

@item internal-border-width
Ширина внутренней границы @var{frame}.
@end table
@end defun

Следующая функция может использоваться для получения краев внешнего и
внутреннего фреймов.

@defun frame-edges &optional frame type
Функция возвращает абсолютные границы внешнего, собственного или внутреннего
фрейма @var{frame}.  @var{frame} должен быть активным фреймом и по умолчанию
быть выбранным.  Возвращенный список имеет вид
@w{@code{(@var{left} @var{top} @var{right} @var{bottom})}}, где все значения
указаны в пикселях относительно исходной точки отображения @var{frame}.  Для
терминальных фреймов значения, возвращаемые для @var{left} и @var{top},
всегда равны нулю.

Необязательный аргумент @var{type} указывает тип возвращаемых краёв:
@code{outer-edges} означает возвращать внешние края @var{frame},
@code{native-edges} (или @code{nil}) означает возвращать собственные края,
а @code{inner-edges} означает возвращать внутренние края.

По соглашению пиксели дисплея при значениях, возвращаемых для @var{left} и
@var{top}, считаются находящимися внутри (частью) @var{frame}.
Следовательно, если оба @var{left} и @var{top} равны нулю, пиксель в
исходной точке дисплея является частью @var{frame}.  С другой стороны,
пиксели в @var{bottom} и @var{right} считаются лежащими непосредственно за
пределами @var{frame}.  Это означает, что если есть, например, два соседних
фрейма, расположенных так, что правый внешний край фрейма слева равен левому
внешнему краю фрейма справа, пиксели на этом краю показывают часть фрейма
справа.
@end defun


@node Frame Font
@subsection Шрифт Фрейма
@cindex default font
@cindex default character size
@cindex default character width
@cindex default width of character
@cindex default character height
@cindex default height of character
У каждого фрейма есть @dfn{шрифт по умолчанию}, который определяет размер
символа по умолчанию для этого фрейма.  Этот размер подразумевается при
извлечении или изменении размера фрейма с точки зрения столбцов или строк
(@pxref{Size Parameters}).  Также используется при изменении размера
(@pxref{Window Sizes}) или разделении (@pxref{Splitting Windows}) окна.

@cindex line height
@cindex column width
@cindex canonical character height
@cindex canonical character width
Иногда вместо ``высота символа по умолчанию'' используются термины
@dfn{высота линии} и @dfn{каноническая высота символа}.  Точно так же
термины @dfn{ширина колонки} и @dfn{каноническая ширина символа}
используются вместо ``ширина символа по умолчанию''.

@defun frame-char-height &optional frame
@defunx frame-char-width &optional frame
Функции возвращают высоту и ширину символа в @var{frame} по умолчанию,
измеренную в пикселях.  Вместе эти значения определяют размер шрифта по
умолчанию на @var{frame}.  Значения зависят от выбора шрифта для
@var{frame}, смотреть @ref{Font and Color Parameters}.
@end defun

Шрифт по умолчанию также можно установить напрямую с помощью следующей
функции:

@deffn Command set-frame-font font &optional keep-size frames
This sets the default font to @var{font}.  When called interactively, it
prompts for the name of a font, and uses that font on the selected
frame.  When called from Lisp, @var{font} should be a font name (a
string), a font object, font entity, or a font spec.

If the optional argument @var{keep-size} is @code{nil}, this keeps the
number of frame lines and columns fixed.  (If не-@code{nil}, the option
@code{frame-inhibit-implied-resize} described in the next section will
override this.)  If @var{keep-size} is не-@code{nil} (or with a prefix
argument), it tries to keep the size of the display area of the current
frame fixed by adjusting the number of lines and columns.

If the optional argument @var{frames} is @code{nil}, this applies the
font to the selected frame only.  If @var{frames} is не-@code{nil}, it
should be a list of frames to act upon, or @code{t} meaning all existing
and all future graphical frames.
@end deffn


@node Frame Position
@subsection Frame Position
@cindex frame position
@cindex position of frame

On graphical systems, the position of a normal top-level frame is
specified as the absolute position of its outer frame (@pxref{Frame
Geometry}).  The position of a child frame (@pxref{Child Frames}) is
specified via pixel offsets of its outer edges relative to the native
position of its parent frame.

  You can access or change the position of a frame using the frame
parameters @code{left} and @code{top} (@pxref{Position Parameters}).
Here are two additional functions for working with the positions of an
existing, visible frame.  For both functions, the argument @var{frame}
must denote a live frame and defaults to the selected frame.

@defun frame-position &optional frame
For a normal, non-child frame this function returns a cons of the pixel
coordinates of its outer position (@pxref{Frame Layout}) with respect to
the origin @code{(0, 0)} of its display.  For a child frame
(@pxref{Child Frames}) this function returns the pixel coordinates of
its outer position with respect to an origin @code{(0, 0)} at the native
position of @var{frame}'s parent.

Negative values never indicate an offset from the right or bottom
edge of @var{frame}'s display or parent frame.  Rather, they mean that
@var{frame}'s outer position is on the left and/or above the origin of
its display or the native position of its parent frame.  This usually
means that @var{frame} is only partially visible (or completely
invisible).  However, on systems where the display's origin does not
coincide with its top-left corner, the frame may be visible on a
secondary monitor.

On a text terminal frame both values are zero.
@end defun

@defun set-frame-position frame x y
This function sets the outer frame position of @var{frame} to (@var{x},
@var{y}).  The latter arguments specify pixels and normally count from
the origin at the position (0, 0) of @var{frame}'s display.  For child
frames, they count from the native position of @var{frame}'s parent
frame.

Negative parameter values position the right edge of the outer frame by
@var{-x} pixels left from the right edge of the screen (or the parent
frame's native rectangle) and the bottom edge by @var{-y} pixels up from
the bottom edge of the screen (or the parent frame's native rectangle).

Note that negative values do not permit to align the right or bottom
edge of @var{frame} exactly at the right or bottom edge of its display
or parent frame.  Neither do they allow to specify a position that does
not lie within the edges of the display or parent frame.  The frame
parameters @code{left} and @code{top} (@pxref{Position Parameters})
allow to do that, but may still fail to provide good results for the
initial or a new frame.

This function has no effect on text terminal frames.
@end defun

@defvar move-frame-functions
@cindex frame position changes, a hook
This hook specifies the functions that are run when an Emacs frame is moved
(assigned a new position) by the window-system or window manager.  The
functions are run with one argument, the frame that moved.  For a child
frame (@pxref{Child Frames}), the functions are run only when the
position of the frame changes in relation to that of its parent frame.
@end defvar


@node Frame Size
@subsection Frame Size
@cindex frame size
@cindex text width of a frame
@cindex text height of a frame
@cindex text size of a frame
The canonical way to specify the @dfn{size of a frame} from within Emacs
is by specifying its @dfn{text size}---a tuple of the width and height
of the frame's text area (@pxref{Frame Layout}).  It can be measured
either in pixels or in terms of the frame's canonical character size
(@pxref{Frame Font}).

  For frames with an internal menu or tool bar, the frame's native
height cannot be told exactly before the frame has been actually drawn.
This means that in general you cannot use the native size to specify the
initial size of a frame.  As soon as you know the native size of a
visible frame, you can calculate its outer size (@pxref{Frame Layout})
by adding in the remaining components from the return value of
@code{frame-geometry}.  For invisible frames or for frames that have
yet to be created, however, the outer size can only be estimated.  This
also means that calculating an exact initial position of a frame
specified via offsets from the right or bottom edge of the screen
(@pxref{Frame Position}) is impossible.

  The text size of any frame can be set and retrieved with the help of
the @code{height} and @code{width} frame parameters (@pxref{Size
Parameters}).  The text size of the initial frame can be also set with
the help of an X-style geometry specification.  @xref{Emacs Invocation,,
Command Line Arguments for Emacs Invocation, emacs, The GNU Emacs
Manual}.  Below we list some functions to access and set the size of an
existing, visible frame, by default the selected one.

@defun frame-height &optional frame
@defunx frame-width &optional frame
These functions return the height and width of the text area of
@var{frame}, measured in units of the default font height and width of
@var{frame} (@pxref{Frame Font}).  These functions are plain shorthands
for writing @code{(frame-parameter frame 'height)} and
@code{(frame-parameter frame 'width)}.

If the text area of @var{frame} measured in pixels is not a multiple of
its default font size, the values returned by these functions are
rounded down to the number of characters of the default font that fully
fit into the text area.
@end defun

The functions following next return the pixel widths and heights of the
native, outer and inner frame and the text area (@pxref{Frame Layout})
of a given frame.  For a text terminal, the results are in characters
rather than pixels.

@defun frame-outer-width &optional frame
@defunx frame-outer-height &optional frame
These functions return the outer width and height of @var{frame} in
pixels.
@end defun

@defun frame-native-height &optional frame
@defunx frame-native-width &optional frame
These functions return the native width and height of @var{frame} in
pixels.
@end defun

@defun frame-inner-width &optional frame
@defunx frame-inner-height &optional frame
These functions return the inner width and height of @var{frame} in
pixels.
@end defun

@defun frame-text-width &optional frame
@defunx frame-text-height &optional frame
These functions return the width and height of the text area of
@var{frame} in pixels.
@end defun

On window systems that support it, Emacs tries by default to make the
text size of a frame measured in pixels a multiple of the frame's
character size.  This, however, usually means that a frame can be
resized only in character size increments when dragging its external
borders.  It also may break attempts to truly maximize the frame or
making it ``fullheight'' or ``fullwidth'' (@pxref{Size Parameters})
leaving some empty space below and/or on the right of the frame.  The
following option may help in that case.

@defopt frame-resize-pixelwise
If this option is @code{nil} (the default), a frame's text pixel size is
usually rounded to a multiple of the current values of that frame's
@code{frame-char-height} and @code{frame-char-width} whenever the frame
is resized.  If this is не-@code{nil}, no rounding occurs, hence frame
sizes can increase/decrease by one pixel.

Setting this variable usually causes the next resize operation to pass
the corresponding size hints to the window manager.  This means that
this variable should be set only in a user's initial file; applications
should never bind it temporarily.

The precise meaning of a value of @code{nil} for this option depends on
the toolkit used.  Dragging the external border with the mouse is done
character-wise provided the window manager is willing to process the
corresponding size hints.  Calling @code{set-frame-size} (see below)
with arguments that do not specify the frame size as an integer multiple
of its character size, however, may: be ignored, cause a rounding
(GTK+), or be accepted (Lucid, Motif, MS-Windows).

With some window managers you may have to set this to не-@code{nil} in
order to make a frame appear truly maximized or full-screen.
@end defopt

@defun set-frame-size frame width height &optional pixelwise
This function sets the size of the text area of @var{frame}, measured in
terms of the canonical height and width of a character on @var{frame}
(@pxref{Frame Font}).

The optional argument @var{pixelwise} не-@code{nil} means to measure
the new width and height in units of pixels instead.  Note that if
@code{frame-resize-pixelwise} is @code{nil}, some toolkits may refuse to
truly honor the request if it does not increase/decrease the frame size
to a multiple of its character size.
@end defun

@defun set-frame-height frame height &optional pretend pixelwise
This function resizes the text area of @var{frame} to a height of
@var{height} lines.  The sizes of existing windows in @var{frame} are
altered proportionally to fit.

If @var{pretend} is не-@code{nil}, then Emacs displays @var{height}
lines of output in @var{frame}, but does not change its value for the
actual height of the frame.  This is only useful on text terminals.
Using a smaller height than the terminal actually implements may be
useful to reproduce behavior observed on a smaller screen, or if the
terminal malfunctions when using its whole screen.  Setting the frame
height directly does not always work, because knowing the correct
actual size may be necessary for correct cursor positioning on
text terminals.

The optional fourth argument @var{pixelwise} не-@code{nil} means that
@var{frame} should be @var{height} pixels high.  Note that if
@code{frame-resize-pixelwise} is @code{nil}, some window managers may
refuse to truly honor the request if it does not increase/decrease the
frame height to a multiple of its character height.
@end defun

@defun set-frame-width frame width &optional pretend pixelwise
This function sets the width of the text area of @var{frame}, measured
in characters.  The argument @var{pretend} has the same meaning as in
@code{set-frame-height}.

The optional fourth argument @var{pixelwise} не-@code{nil} means that
@var{frame} should be @var{width} pixels wide.  Note that if
@code{frame-resize-pixelwise} is @code{nil}, some window managers may
refuse to fully honor the request if it does not increase/decrease the
frame width to a multiple of its character width.
@end defun

None of these three functions will make a frame smaller than needed to
display all of its windows together with their scroll bars, fringes,
margins, dividers, mode and header lines.  This contrasts with requests
by the window manager triggered, for example, by dragging the external
border of a frame with the mouse.  Such requests are always honored by
clipping, if necessary, portions that cannot be displayed at the right,
bottom corner of the frame.  The parameters @code{min-width} and
@code{min-height} (@pxref{Size Parameters}) can be used to obtain a
similar behavior when changing the frame size from within Emacs.

@cindex tracking frame size changes
  The abnormal hook @code{window-size-change-functions} (@pxref{Window
Hooks}) tracks all changes of the inner size of a frame including those
induced by request of the window-system or window manager.  To rule out
false positives that might occur when changing only the sizes of a
frame's windows without actually changing the size of the inner frame,
use the following function.

@defun frame-size-changed-p &optional frame
This function returns не-@code{nil} when the inner width or height of
@var{frame} has changed since @code{window-size-change-functions} was
run the last time for @var{frame}.  It always returns @code{nil}
immediately after running @code{window-size-change-functions} for
@var{frame}.
@end defun


@node Implied Frame Resizing
@subsection Implied Frame Resizing
@cindex implied frame resizing
@cindex implied resizing of frame

By default, Emacs tries to keep the number of lines and columns of a
frame's text area unaltered when, for example, adding or removing the
menu bar, changing the default font or setting the width of the frame's
scroll bars.  This means, however, that in such case Emacs must ask the
window manager to resize the outer frame in order to accommodate the
size change.  Note that wrapping a menu or tool bar usually does not
resize the frame's outer size, hence this will alter the number of
displayed lines.

  Occasionally, such @dfn{implied frame resizing} may be unwanted, for
example, when the frame is maximized or made full-screen (where it's
turned off by default).  In other cases you can disable implied resizing
with the following option:

@defopt frame-inhibit-implied-resize
If this option is @code{nil}, changing font, menu bar, tool bar,
internal borders, fringes or scroll bars of a specific frame may
implicitly resize the frame's display area in order to preserve the
number of columns or lines the frame displays.  If this option is
не-@code{nil}, no implied resizing is done.

The value of this option can be also a list of frame parameters.  In
that case, implied resizing is inhibited when changing a parameter that
appears in this list.  The frame parameters currently handled by this
option are: @code{font}, @code{font-backend},
@code{internal-border-width}, @code{menu-bar-lines} and
@code{tool-bar-lines}.

Changing any of the @code{scroll-bar-width}, @code{scroll-bar-height},
@code{vertical-scroll-bars}, @code{horizontal-scroll-bars},
@code{left-fringe} and @code{right-fringe} frame parameters is handled
as if the frame contained just one live window.  This means, for
example, that removing vertical scroll bars on a frame containing
several side by side windows will shrink the outer frame width by the
width of one scroll bar provided this option is @code{nil} and keep it
unchanged if this option is either @code{t} or a list containing
@code{vertical-scroll-bars}.

The default value is @code{'(tool-bar-lines)} for Lucid, Motif and
MS-Windows (which means that adding/removing a tool bar there does not
change the outer frame height), @code{nil} on all other window systems
including GTK+ (which means that changing any of the parameters listed
above may change the size of the outer frame), and @code{t} otherwise
(which means the outer frame size never changes implicitly when there's
no window system support).

Note that when a frame is not large enough to accommodate a change of
any of the parameters listed above, Emacs may try to enlarge the frame
even if this option is не-@code{nil}.
@end defopt


@node Frame Parameters
@section Frame Parameters
@cindex frame parameters

  A frame has many parameters that control its appearance and behavior.
Just what parameters a frame has depends on what display mechanism it
uses.

  Frame parameters exist mostly for the sake of graphical displays.
Most frame parameters have no effect when applied to a frame on a text
terminal; only the @code{height}, @code{width}, @code{name},
@code{title}, @code{menu-bar-lines}, @code{buffer-list} and
@code{buffer-predicate} parameters do something special.  If the
terminal supports colors, the parameters @code{foreground-color},
@code{background-color}, @code{background-mode} and
@code{display-type} are also meaningful.  If the terminal supports
frame transparency, the parameter @code{alpha} is also meaningful.

  By default, frame parameters are saved and restored by the desktop
library functions (@pxref{Desktop Save Mode}) when the variable
@code{desktop-restore-frames} is не-@code{nil}.  It's the
responsibility of applications that their parameters are included in
@code{frameset-persistent-filter-alist} to avoid that they get
meaningless or even harmful values in restored sessions.

@menu
* Parameter Access::       How to change a frame's parameters.
* Initial Parameters::     Specifying frame parameters when you make a frame.
* Window Frame Parameters:: List of frame parameters for window systems.
* Geometry::               Parsing geometry specifications.
@end menu

@node Parameter Access
@subsection Access to Frame Parameters

These functions let you read and change the parameter values of a
frame.

@defun frame-parameter frame parameter
This function returns the value of the parameter @var{parameter} (a
symbol) of @var{frame}.  If @var{frame} is @code{nil}, it returns the
selected frame's parameter.  If @var{frame} has no setting for
@var{parameter}, this function returns @code{nil}.
@end defun

@defun frame-parameters &optional frame
The function @code{frame-parameters} returns an alist listing all the
parameters of @var{frame} and their values.  If @var{frame} is
@code{nil} or omitted, this returns the selected frame's parameters
@end defun

@defun modify-frame-parameters frame alist
This function alters the frame @var{frame} based on the elements of
@var{alist}.  Each element of @var{alist} has the form
@code{(@var{parm} . @var{value})}, where @var{parm} is a symbol naming
a parameter.  If you don't mention a parameter in @var{alist}, its
value doesn't change.  If @var{frame} is @code{nil}, it defaults to
the selected frame.

Some parameters are only meaningful for frames on certain kinds of
display (@pxref{Frames}).  If @var{alist} includes parameters that are
not meaningful for the @var{frame}'s display, this function will
change its value in the frame's parameter list, but will otherwise
ignore it.

When @var{alist} specifies more than one parameter whose value can
affect the new size of @var{frame}, the final size of the frame may
differ according to the toolkit used.  For example, specifying that a
frame should from now on have a menu and/or tool bar instead of none and
simultaneously specifying the new height of the frame will inevitably
lead to a recalculation of the frame's height.  Conceptually, in such
case, this function will try to have the explicit height specification
prevail.  It cannot be excluded, however, that the addition (or removal)
of the menu or tool bar, when eventually performed by the toolkit, will
defeat this intention.

Sometimes, binding @code{frame-inhibit-implied-resize} (@pxref{Implied
Frame Resizing}) to a не-@code{nil} value around calls to this function
may fix the problem sketched here.  Sometimes, however, exactly such
binding may be hit by the problem.
@end defun

@defun set-frame-parameter frame parm value
This function sets the frame parameter @var{parm} to the specified
@var{value}.  If @var{frame} is @code{nil}, it defaults to the selected
frame.
@end defun

@defun modify-all-frames-parameters alist
This function alters the frame parameters of all existing frames
according to @var{alist}, then modifies @code{default-frame-alist}
(and, if necessary, @code{initial-frame-alist}) to apply the same
parameter values to frames that will be created henceforth.
@end defun

@node Initial Parameters
@subsection Initial Frame Parameters
@cindex parameters of initial frame

You can specify the parameters for the initial startup frame by
setting @code{initial-frame-alist} in your init file (@pxref{Init
File}).

@defopt initial-frame-alist
This variable's value is an alist of parameter values used when
creating the initial frame.  You can set this variable to specify the
appearance of the initial frame without altering subsequent frames.
Each element has the form:

@example
(@var{parameter} . @var{value})
@end example

Emacs creates the initial frame before it reads your init
file.  After reading that file, Emacs checks @code{initial-frame-alist},
and applies the parameter settings in the altered value to the already
created initial frame.

If these settings affect the frame geometry and appearance, you'll see
the frame appear with the wrong ones and then change to the specified
ones.  If that bothers you, you can specify the same geometry and
appearance with X resources; those do take effect before the frame is
created.  @xref{X Resources,, X Resources, emacs, The GNU Emacs Manual}.

X resource settings typically apply to all frames.  If you want to
specify some X resources solely for the sake of the initial frame, and
you don't want them to apply to subsequent frames, here's how to achieve
this.  Specify parameters in @code{default-frame-alist} to override the
X resources for subsequent frames; then, to prevent these from affecting
the initial frame, specify the same parameters in
@code{initial-frame-alist} with values that match the X resources.
@end defopt

@cindex minibuffer-only frame
If these parameters include @code{(minibuffer . nil)}, that indicates
that the initial frame should have no minibuffer.  In this case, Emacs
creates a separate @dfn{minibuffer-only frame} as well.

@defopt minibuffer-frame-alist
This variable's value is an alist of parameter values used when
creating an initial minibuffer-only frame (i.e., the minibuffer-only
frame that Emacs creates if @code{initial-frame-alist} specifies a
frame with no minibuffer).
@end defopt

@defopt default-frame-alist
This is an alist specifying default values of frame parameters for all
Emacs frames---the first frame, and subsequent frames.  When using the X
Window System, you can get the same results by means of X resources
in many cases.

Setting this variable does not affect existing frames.  Furthermore,
functions that display a buffer in a separate frame may override the
default parameters by supplying their own parameters.
@end defopt

If you invoke Emacs with command-line options that specify frame
appearance, those options take effect by adding elements to either
@code{initial-frame-alist} or @code{default-frame-alist}.  Options
which affect just the initial frame, such as @samp{--geometry} and
@samp{--maximized}, add to @code{initial-frame-alist}; the others add
to @code{default-frame-alist}.  @pxref{Emacs Invocation,, Command Line
Arguments for Emacs Invocation, emacs, The GNU Emacs Manual}.

@node Window Frame Parameters
@subsection Window Frame Parameters
@cindex frame parameters for windowed displays

  Just what parameters a frame has depends on what display mechanism
it uses.  This section describes the parameters that have special
meanings on some or all kinds of terminals.  Of these, @code{name},
@code{title}, @code{height}, @code{width}, @code{buffer-list} and
@code{buffer-predicate} provide meaningful information in terminal
frames, and @code{tty-color-mode} is meaningful only for frames on
text terminals.

@menu
* Basic Parameters::            Parameters that are fundamental.
* Position Parameters::         The position of the frame on the screen.
* Size Parameters::             Frame's size.
* Layout Parameters::           Size of parts of the frame, and
                                  enabling or disabling some parts.
* Buffer Parameters::           Which buffers have been or should be shown.
* Frame Interaction Parameters::  Parameters for interacting with other
                                  frames.
* Mouse Dragging Parameters::   Parameters for resizing and moving
                                  frames with the mouse.
* Management Parameters::       Communicating with the window manager.
* Cursor Parameters::           Controlling the cursor appearance.
* Font and Color Parameters::   Fonts and colors for the frame text.
@end menu

@node Basic Parameters
@subsubsection Basic Parameters

  These frame parameters give the most basic information about the
frame.  @code{title} and @code{name} are meaningful on all terminals.

@table @code
@vindex display@r{, a frame parameter}
@item display
The display on which to open this frame.  It should be a string of the
form @samp{@var{host}:@var{dpy}.@var{screen}}, just like the
@env{DISPLAY} environment variable.  @xref{Multiple Terminals}, for
more details about display names.

@vindex display-type@r{, a frame parameter}
@item display-type
This parameter describes the range of possible colors that can be used
in this frame.  Its value is @code{color}, @code{grayscale} or
@code{mono}.

@vindex title@r{, a frame parameter}
@item title
If a frame has a не-@code{nil} title, it appears in the window
system's title bar at the top of the frame, and also in the mode line
of windows in that frame if @code{mode-line-frame-identification} uses
@samp{%F} (@pxref{%-Constructs}).  This is normally the case when
Emacs is not using a window system, and can only display one frame at
a time.  @xref{Frame Titles}.

@vindex name@r{, a frame parameter}
@item name
The name of the frame.  The frame name serves as a default for the frame
title, if the @code{title} parameter is unspecified or @code{nil}.  If
you don't specify a name, Emacs sets the frame name automatically
(@pxref{Frame Titles}).

If you specify the frame name explicitly when you create the frame, the
name is also used (instead of the name of the Emacs executable) when
looking up X resources for the frame.

@vindex explicit-name@r{, a frame parameter}
@item explicit-name
If the frame name was specified explicitly when the frame was created,
this parameter will be that name.  If the frame wasn't explicitly
named, this parameter will be @code{nil}.
@end table


@node Position Parameters
@subsubsection Position Parameters
@cindex window position on display
@cindex frame position

Parameters describing the X- and Y-offsets of a frame are always
measured in pixels.  For a normal, non-child frame they specify the
frame's outer position (@pxref{Frame Geometry}) relative to its
display's origin.  For a child frame (@pxref{Child Frames}) they specify
the frame's outer position relative to the native position of the
frame's parent frame.  (Note that none of these parameters is meaningful
on TTY frames.)

@table @code
@vindex left@r{, a frame parameter}
@item left
The position, in pixels, of the left outer edge of the frame with
respect to the left edge of the frame's display or parent frame.  It can
be specified in one of the following ways.

@table @asis
@item an integer
A positive integer always relates the left edge of the frame to the left
edge of its display or parent frame.  A negative integer relates the
right frame edge to the right edge of the display or parent frame.

@item @code{(+ @var{pos})}
This specifies the position of the left frame edge relative to the left
edge of its display or parent frame.  The integer @var{pos} may be
positive or negative; a negative value specifies a position outside the
screen or parent frame or on a monitor other than the primary one (for
multi-monitor displays).

@item @code{(- @var{pos})}
This specifies the position of the right frame edge relative to the
right edge of the display or parent frame.  The integer @var{pos} may be
positive or negative; a negative value specifies a position outside the
screen or parent frame or on a monitor other than the primary one (for
multi-monitor displays).

@cindex left position ratio
@cindex top position ratio
@item a floating-point value
A floating-point value in the range 0.0 to 1.0 specifies the left edge's
offset via the @dfn{left position ratio} of the frame---the ratio of the
left edge of its outer frame to the width of the frame's workarea
(@pxref{Multiple Terminals}) or its parent's native frame (@pxref{Child
Frames}) minus the width of the outer frame.  Thus, a left position
ratio of 0.0 flushes a frame to the left, a ratio of 0.5 centers it and
a ratio of 1.0 flushes it to the right of its display or parent frame.
Similarly, the @dfn{top position ratio} of a frame is the ratio of the
frame's top position to the height of its workarea or parent frame minus
the height of the frame.

Emacs will try to keep the position ratios of a child frame unaltered if
that frame has a не-@code{nil} @code{keep-ratio} parameter
(@pxref{Frame Interaction Parameters}) and its parent frame is resized.

Since the outer size of a frame (@pxref{Frame Geometry}) is usually
unavailable before a frame has been made visible, it is generally not
advisable to use floating-point values when creating decorated frames.
Floating-point values are more suited for ensuring that an (undecorated)
child frame is positioned nicely within the area of its parent frame.
@end table

Some window managers ignore program-specified positions.  If you want to
be sure the position you specify is not ignored, specify a
не-@code{nil} value for the @code{user-position} parameter as in the
following example:

@example
(modify-frame-parameters
  nil '((user-position . t) (left . (+ -4))))
@end example

In general, it is not a good idea to position a frame relative to the
right or bottom edge of its display.  Positioning the initial or a new
frame is either not accurate (because the size of the outer frame is not
yet fully known before the frame has been made visible) or will cause
additional flicker (if the frame has to be repositioned after becoming
visible).

  Note also, that positions specified relative to the right/bottom edge
of a display, workarea or parent frame as well as floating-point offsets
are stored internally as integer offsets relative to the left/top edge
of the display, workarea or parent frame edge.  They are also returned
as such by functions like @code{frame-parameters} and restored as such
by the desktop saving routines.

@vindex top@r{, a frame parameter}
@item top
The screen position of the top (or bottom) edge, in pixels, with respect
to the top (or bottom) edge of the display or parent frame.  It works
just like @code{left}, except vertically instead of horizontally.

@vindex icon-left@r{, a frame parameter}
@item icon-left
The screen position of the left edge of the frame's icon, in pixels,
counting from the left edge of the screen.  This takes effect when the
frame is iconified, if the window manager supports this feature.  If
you specify a value for this parameter, then you must also specify a
value for @code{icon-top} and vice versa.

@vindex icon-top@r{, a frame parameter}
@item icon-top
The screen position of the top edge of the frame's icon, in pixels,
counting from the top edge of the screen.  This takes effect when the
frame is iconified, if the window manager supports this feature.

@vindex user-position@r{, a frame parameter}
@item user-position
When you create a frame and specify its screen position with the
@code{left} and @code{top} parameters, use this parameter to say whether
the specified position was user-specified (explicitly requested in some
way by a human user) or merely program-specified (chosen by a program).
A не-@code{nil} value says the position was user-specified.

@cindex window positions and window managers
Window managers generally heed user-specified positions, and some heed
program-specified positions too.  But many ignore program-specified
positions, placing the window in a default fashion or letting the user
place it with the mouse.  Some window managers, including @code{twm},
let the user specify whether to obey program-specified positions or
ignore them.

When you call @code{make-frame}, you should specify a не-@code{nil}
value for this parameter if the values of the @code{left} and @code{top}
parameters represent the user's stated preference; otherwise, use
@code{nil}.

@vindex z-group@r{, a frame parameter}
@item z-group
This parameter specifies a relative position of the frame's
window-system window in the stacking (Z-) order of the frame's display.

If this is @code{above}, the frame's window-system window is displayed
above all other window-system windows that do not have the @code{above}
property set.  If this is @code{nil}, the frame's window is displayed below all
windows that have the @code{above} property set and above all windows
that have the @code{below} property set.  If this is @code{below}, the
frame's window is displayed below all windows that do not have the
@code{below} property set.

To position the frame above or below a specific other frame use the
function @code{frame-restack} (@pxref{Raising and Lowering}).
@end table


@node Size Parameters
@subsubsection Size Parameters
@cindex window size on display

Frame parameters usually specify frame sizes in character units.  On
graphical displays, the @code{default} face determines the actual pixel
sizes of these character units (@pxref{Face Attributes}).

@table @code
@vindex width@r{, a frame parameter}
@item width
This parameter specifies the width of the frame.  It can be specified as
in the following ways:

@table @asis
@item an integer
A positive integer specifies the width of the frame's text area
(@pxref{Frame Geometry}) in characters.

@item a cons cell
If this is a cons cell with the symbol @code{text-pixels} in its
@sc{car}, the @sc{cdr} of that cell specifies the width of the frame's
text area in pixels.

@cindex frame width ratio
@cindex frame height ratio
@item a floating-point value
A floating-point number between 0.0 and 1.0 can be used to specify the
width of a frame via its @dfn{width ratio}---the ratio of its outer
width (@pxref{Frame Geometry}) to the width of the frame's workarea
(@pxref{Multiple Terminals}) or its parent frame's (@pxref{Child
Frames}) native frame.  Thus, a value of 0.5 makes the frame occupy half
of the width of its workarea or parent frame, a value of 1.0 the full
width.  Similarly, the @dfn{height ratio} of a frame is the ratio of its
outer height to the height of its workarea or its parent's native frame.

Emacs will try to keep the width and height ratio of a child frame
unaltered if that frame has a не-@code{nil} @code{keep-ratio} parameter
(@pxref{Frame Interaction Parameters}) and its parent frame is resized.

Since the outer size of a frame is usually unavailable before a frame
has been made visible, it is generally not advisable to use
floating-point values when creating decorated frames.  Floating-point
values are more suited to ensure that a child frame always fits within
the area of its parent frame as, for example, when customizing
@code{display-buffer-alist} (@pxref{Choosing Window}) via
@code{display-buffer-in-child-frame}.
@end table

Regardless of how this parameter was specified, functions reporting the
value of this parameter like @code{frame-parameters} always report the
width of the frame's text area in characters as an integer rounded, if
necessary, to a multiple of the frame's default character width.  That
value is also used by the desktop saving routines.

@vindex height@r{, a frame parameter}
@item height
This parameter specifies the height of the frame.  It works just like
@code{width}, except vertically instead of horizontally.

@vindex user-size@r{, a frame parameter}
@item user-size
This does for the size parameters @code{height} and @code{width} what
the @code{user-position} parameter (@pxref{Position Parameters,
user-position}) does for the position parameters @code{top} and
@code{left}.

@vindex min-width@r{, a frame parameter}
@item min-width
This parameter specifies the minimum native width (@pxref{Frame
Geometry}) of the frame, in characters.  Normally, the functions that
establish a frame's initial width or resize a frame horizontally make
sure that all the frame's windows, vertical scroll bars, fringes,
margins and vertical dividers can be displayed.  This parameter, if
не-@code{nil} allows to make a frame narrower than that with the
consequence that any components that do not fit will be clipped by the
window manager.

@vindex min-height@r{, a frame parameter}
@item min-height
This parameter specifies the minimum native height (@pxref{Frame
Geometry}) of the frame, in characters.  Normally, the functions that
establish a frame's initial size or resize a frame make sure that all
the frame's windows, horizontal scroll bars and dividers, mode and
header lines, the echo area and the internal menu and tool bar can be
displayed.  This parameter, if не-@code{nil} allows to make a frame
smaller than that with the consequence that any components that do not
fit will be clipped by the window manager.

@cindex fullboth frames
@cindex fullheight frames
@cindex fullwidth frames
@cindex maximized frames
@vindex fullscreen@r{, a frame parameter}
@item fullscreen
This parameter specifies whether to maximize the frame's width, height
or both.  Its value can be @code{fullwidth}, @code{fullheight},
@code{fullboth}, or @code{maximized}.  A @dfn{fullwidth} frame is as
wide as possible, a @dfn{fullheight} frame is as tall as possible, and
a @dfn{fullboth} frame is both as wide and as tall as possible.  A
@dfn{maximized} frame is like a ``fullboth'' frame, except that it usually
keeps its title bar and the buttons for resizing
and closing the frame.  Also, maximized frames typically avoid hiding
any task bar or panels displayed on the desktop.  A ``fullboth'' frame,
on the other hand, usually omits the title bar and occupies the entire
available screen space.

Full-height and full-width frames are more similar to maximized
frames in this regard.  However, these typically display an external
border which might be absent with maximized frames.  Hence the heights
of maximized and full-height frames and the widths of maximized and
full-width frames often differ by a few pixels.

With some window managers you may have to customize the variable
@code{frame-resize-pixelwise} (@pxref{Frame Size}) in order to make a
frame truly appear maximized or full-screen.  Moreover, some window
managers might not support smooth transition between the various
full-screen or maximization states.  Customizing the variable
@code{x-frame-normalize-before-maximize} can help to overcome that.

Full-screen on macOS hides both the tool-bar and the menu-bar, however
both will be displayed if the mouse pointer is moved to the top of the
screen.

@vindex fullscreen-restore@r{, a frame parameter}
@item fullscreen-restore
This parameter specifies the desired fullscreen state of the frame
after invoking the @code{toggle-frame-fullscreen} command (@pxref{Frame
Commands,,, emacs, The GNU Emacs Manual}) in the ``fullboth'' state.
Normally this parameter is installed automatically by that command when
toggling the state to fullboth.  If, however, you start Emacs in the
``fullboth'' state, you have to specify the desired behavior in your initial
file as, for example

@example
(setq default-frame-alist
    '((fullscreen . fullboth)
      (fullscreen-restore . fullheight)))
@end example

This will give a new frame full height after typing in it @key{F11} for
the first time.

@vindex fit-frame-to-buffer-margins@r{, a frame parameter}
@item fit-frame-to-buffer-margins
This parameter allows to override the value of the option
@code{fit-frame-to-buffer-margins} when fitting this frame to the buffer
of its root window with @code{fit-frame-to-buffer} (@pxref{Resizing
Windows}).

@vindex fit-frame-to-buffer-sizes@r{, a frame parameter}
@item fit-frame-to-buffer-sizes
This parameter allows to override the value of the option
@code{fit-frame-to-buffer-sizes} when fitting this frame to the buffer
of its root window with @code{fit-frame-to-buffer} (@pxref{Resizing
Windows}).
@end table


@node Layout Parameters
@subsubsection Layout Parameters
@cindex layout parameters of frames
@cindex frame layout parameters

  These frame parameters enable or disable various parts of the
frame, or control their sizes.

@table @code
@vindex border-width@r{, a frame parameter}
@item border-width
The width in pixels of the frame's outer border (@pxref{Frame Geometry}).

@vindex internal-border-width@r{, a frame parameter}
@item internal-border-width
The width in pixels of the frame's internal border (@pxref{Frame
Geometry}).

@vindex vertical-scroll-bars@r{, a frame parameter}
@item vertical-scroll-bars
Whether the frame has scroll bars (@pxref{Scroll Bars}) for vertical
scrolling, and which side of the frame they should be on.  The possible
values are @code{left}, @code{right}, and @code{nil} for no scroll bars.

@vindex horizontal-scroll-bars@r{, a frame parameter}
@item horizontal-scroll-bars
Whether the frame has scroll bars for horizontal scrolling (@code{t} and
@code{bottom} mean yes, @code{nil} means no).

@vindex scroll-bar-width@r{, a frame parameter}
@item scroll-bar-width
The width of vertical scroll bars, in pixels, or @code{nil} meaning to
use the default width.

@vindex scroll-bar-height@r{, a frame parameter}
@item scroll-bar-height
The height of horizontal scroll bars, in pixels, or @code{nil} meaning
to use the default height.

@vindex left-fringe@r{, a frame parameter}
@vindex right-fringe@r{, a frame parameter}
@item left-fringe
@itemx right-fringe
The default width of the left and right fringes of windows in this
frame (@pxref{Fringes}).  If either of these is zero, that effectively
removes the corresponding fringe.

When you use @code{frame-parameter} to query the value of either of
these two frame parameters, the return value is always an integer.
When using @code{set-frame-parameter}, passing a @code{nil} value
imposes an actual default value of 8 pixels.

@vindex right-divider-width@r{, a frame parameter}
@item right-divider-width
The width (thickness) reserved for the right divider (@pxref{Window
Dividers}) of any window on the frame, in pixels.  A value of zero means
to not draw right dividers.

@vindex bottom-divider-width@r{, a frame parameter}
@item bottom-divider-width
The width (thickness) reserved for the bottom divider (@pxref{Window
Dividers}) of any window on the frame, in pixels.  A value of zero means
to not draw bottom dividers.

@vindex menu-bar-lines@r{, a frame parameter}
@item menu-bar-lines
The number of lines to allocate at the top of the frame for a menu bar
(@pxref{Menu Bar}).  The default is one if Menu Bar mode is enabled and
zero otherwise.  @xref{Menu Bars,,,emacs, The GNU Emacs Manual}.  For an
external menu bar (@pxref{Frame Layout}), this value remains unchanged
even when the menu bar wraps to two or more lines.  In that case, the
@code{menu-bar-size} value returned by @code{frame-geometry}
(@pxref{Frame Geometry}) allows to derive whether the menu bar actually
occupies one or more lines.

@vindex tool-bar-lines@r{, a frame parameter}
@item tool-bar-lines
The number of lines to use for the tool bar (@pxref{Tool Bar}).  The
default is one if Tool Bar mode is enabled and zero otherwise.
@xref{Tool Bars,,,emacs, The GNU Emacs Manual}.  This value may change
whenever the tool bar wraps (@pxref{Frame Layout}).

@vindex tool-bar-position@r{, a frame parameter}
@item tool-bar-position
The position of the tool bar when Emacs was built with GTK+.  Its value
can be one of @code{top}, @code{bottom} @code{left}, @code{right}.  The
default is @code{top}.

@vindex line-spacing@r{, a frame parameter}
@item line-spacing
Additional space to leave below each text line, in pixels (a positive
integer).  @xref{Line Height}, for more information.

@vindex no-special-glyphs@r{, a frame parameter}
@item no-special-glyphs
If this is не-@code{nil}, it suppresses the display of any truncation
and continuation glyphs (@pxref{Truncation}) for all buffers displayed
by this frame.  This is useful to eliminate such glyphs when fitting a
frame to its buffer via @code{fit-frame-to-buffer} (@pxref{Resizing
Windows}).
@end table


@node Buffer Parameters
@subsubsection Buffer Parameters
@cindex frame, which buffers to display
@cindex buffers to display on frame

  These frame parameters, meaningful on all kinds of terminals, deal
with which buffers have been, or should, be displayed in the frame.

@table @code
@vindex minibuffer@r{, a frame parameter}
@item minibuffer
Whether this frame has its own minibuffer.  The value @code{t} means
yes, @code{nil} means no, @code{only} means this frame is just a
minibuffer.  If the value is a minibuffer window (in some other
frame), the frame uses that minibuffer.

This parameter takes effect when the frame is created.  If specified as
@code{nil}, Emacs will try to set it to the minibuffer window of
@code{default-minibuffer-frame} (@pxref{Minibuffers and Frames}).  For
an existing frame, this parameter can be used exclusively to specify
another minibuffer window.  It is not allowed to change it from a
minibuffer window to @code{t} and vice-versa, or from @code{t} to
@code{nil}.  If the parameter specifies a minibuffer window already,
setting it to @code{nil} has no effect.

@vindex buffer-predicate@r{, a frame parameter}
@item buffer-predicate
The buffer-predicate function for this frame.  The function
@code{other-buffer} uses this predicate (from the selected frame) to
decide which buffers it should consider, if the predicate is not
@code{nil}.  It calls the predicate with one argument, a buffer, once for
each buffer; if the predicate returns a не-@code{nil} value, it
considers that buffer.

@vindex buffer-list@r{, a frame parameter}
@item buffer-list
A list of buffers that have been selected in this frame, ordered
most-recently-selected first.

@vindex unsplittable@r{, a frame parameter}
@item unsplittable
If не-@code{nil}, this frame's window is never split automatically.
@end table


@node Frame Interaction Parameters
@subsubsection Frame Interaction Parameters
@cindex frame interaction parameters
@cindex interaction parameters between frames

These parameters supply forms of interactions between different frames.

@table @code
@vindex parent-frame@r{, a frame parameter}
@item parent-frame
If не-@code{nil}, this means that this frame is a child frame
(@pxref{Child Frames}), and this parameter specifies its parent frame.
If @code{nil}, this means that this frame is a normal, top-level frame.

@vindex delete-before@r{, a frame parameter}
@item delete-before
If не-@code{nil}, this parameter specifies another frame whose deletion
will automatically trigger the deletion of this frame.  @xref{Deleting
Frames}.

@vindex mouse-wheel-frame@r{, a frame parameter}
@item mouse-wheel-frame
If не-@code{nil}, this parameter specifies the frame whose windows will
be scrolled whenever the mouse wheel is scrolled with the mouse pointer
hovering over this frame, see @ref{Mouse Commands,,, emacs, The GNU
Emacs Manual}.

@vindex no-other-frame@r{, a frame parameter}
@item no-other-frame
If this is не-@code{nil}, then this frame is not eligible as candidate
for the functions @code{next-frame}, @code{previous-frame}
(@pxref{Finding All Frames}) and @code{other-frame}, see @ref{Frame
Commands,,, emacs, The GNU Emacs Manual}.

@vindex auto-hide-function@r{, a frame parameter}
@item auto-hide-function
When this parameter specifies a function, that function will be called
instead of the function specified by the variable
@code{frame-auto-hide-function} when quitting the frame's only window
(@pxref{Quitting Windows}) and there are other frames left.

@vindex minibuffer-exit@r{, a frame parameter}
@item minibuffer-exit
When this parameter is не-@code{nil}, Emacs will by default make this
frame invisible whenever the minibuffer (@pxref{Minibuffers}) is exited.
Alternatively, it can specify the functions @code{iconify-frame} and
@code{delete-frame}.  This parameter is useful to make a child frame
disappear automatically (similar to how Emacs deals with a window) when
exiting the minibuffer.

@vindex keep-ratio@r{, a frame parameter}
@item keep-ratio
This parameter is currently meaningful for child frames (@pxref{Child
Frames}) only.  If it is не-@code{nil}, then Emacs will try to keep the
frame's size (width and height) ratios (@pxref{Size Parameters}) as well
as its left and right position ratios (@pxref{Position Parameters})
unaltered whenever its parent frame is resized.

If the value of this parameter is @code{nil}, the frame's position and
size remain unaltered when the parent frame is resized, so the position
and size ratios may change.  If the value of this parameter is @code{t},
Emacs will try to preserve the frame's size and position ratios, hence
the frame's size and position relative to its parent frame may change.

More individual control is possible by using a cons cell: In that case
the frame's width ratio is preserved if the @sc{car} of the cell is
either @code{t} or @code{width-only}.  The height ratio is preserved if
the @sc{car} of the cell is either @code{t} or @code{height-only}.  The
left position ratio is preserved if the @sc{cdr} of the cell is either
@code{t} or @code{left-only}.  The top position ratio is preserved if
the @sc{cdr} of the cell is either @code{t} or @code{top-only}.
@end table


@node Mouse Dragging Parameters
@subsubsection Mouse Dragging Parameters
@cindex mouse dragging parameters
@cindex parameters for resizing frames with the mouse
@cindex parameters for moving frames with the mouse

The parameters described below provide support for resizing a frame by
dragging its internal borders with the mouse.  They also allow moving a
frame with the mouse by dragging the header line of its topmost or the
mode line of its bottommost window.

These parameters are mostly useful for child frames (@pxref{Child
Frames}) that come without window manager decorations.  If necessary,
they can be used for undecorated top-level frames as well.

@table @code
@vindex drag-internal-border@r{, a frame parameter}
@item drag-internal-border
If не-@code{nil}, the frame can be resized by dragging its internal
borders, if present, with the mouse.

@vindex drag-with-header-line@r{, a frame parameter}
@item drag-with-header-line
If не-@code{nil}, the frame can be moved with the mouse by dragging the
header line of its topmost window.

@vindex drag-with-mode-line@r{, a frame parameter}
@item drag-with-mode-line
If не-@code{nil}, the frame can be moved with the mouse by dragging the
mode line of its bottommost window.  Note that such a frame is not
allowed to have its own minibuffer window.

@vindex snap-width@r{, a frame parameter}
@item snap-width
A frame that is moved with the mouse will ``snap'' at the border(s) of
the display or its parent frame whenever it is dragged as near to such
an edge as the number of pixels specified by this parameter.

@vindex top-visible@r{, a frame parameter}
@item top-visible
If this parameter is a number, the top edge of the frame never appears
above the top edge of its display or parent frame.  Moreover, as many
pixels of the frame as specified by that number will remain visible when
the frame is moved against any of the remaining edges of its display or
parent frame.  Setting this parameter is useful to guard against
dragging a child frame with a не-@code{nil}
@code{drag-with-header-line} parameter completely out of the area
of its parent frame.

@vindex bottom-visible@r{, a frame parameter}
@item bottom-visible
If this parameter is a number, the bottom edge of the frame never
appears below the bottom edge of its display or parent frame.  Moreover,
as many pixels of the frame as specified by that number will remain
visible when the frame is moved against any of the remaining edges of
its display or parent frame.  Setting this parameter is useful to guard
against dragging a child frame with a не-@code{nil}
@code{drag-with-mode-line} parameter completely out of the area of
its parent frame.
@end table


@node Management Parameters
@subsubsection Window Management Parameters
@cindex window manager interaction, and frame parameters

  The following frame parameters control various aspects of the frame's
interaction with the window manager or window system.  They have no
effect on text terminals.

@table @code
@vindex visibility@r{, a frame parameter}
@item visibility
The state of visibility of the frame.  There are three possibilities:
@code{nil} for invisible, @code{t} for visible, and @code{icon} for
iconified.  @xref{Visibility of Frames}.

@vindex auto-raise@r{, a frame parameter}
@item auto-raise
If не-@code{nil}, Emacs automatically raises the frame when it is
selected.  Some window managers do not allow this.

@vindex auto-lower@r{, a frame parameter}
@item auto-lower
If не-@code{nil}, Emacs automatically lowers the frame when it is
deselected.  Some window managers do not allow this.

@vindex icon-type@r{, a frame parameter}
@item icon-type
The type of icon to use for this frame.  If the value is a string,
that specifies a file containing a bitmap to use; @code{nil} specifies
no icon (in which case the window manager decides what to show); any
other не-@code{nil} value specifies the default Emacs icon.

@vindex icon-name@r{, a frame parameter}
@item icon-name
The name to use in the icon for this frame, when and if the icon
appears.  If this is @code{nil}, the frame's title is used.

@vindex window-id@r{, a frame parameter}
@item window-id
The ID number which the graphical display uses for this frame.  Emacs
assigns this parameter when the frame is created; changing the
parameter has no effect on the actual ID number.

@vindex outer-window-id@r{, a frame parameter}
@item outer-window-id
The ID number of the outermost window-system window in which the frame
exists.  As with @code{window-id}, changing this parameter has no
actual effect.

@vindex wait-for-wm@r{, a frame parameter}
@item wait-for-wm
If не-@code{nil}, tell Xt to wait for the window manager to confirm
geometry changes.  Some window managers, including versions of Fvwm2
and KDE, fail to confirm, so Xt hangs.  Set this to @code{nil} to
prevent hanging with those window managers.

@vindex sticky@r{, a frame parameter}
@item sticky
If не-@code{nil}, the frame is visible on all virtual desktops on systems
with virtual desktops.

@vindex inhibit-double-buffering@r{, a frame parameter}
@item inhibit-double-buffering
If не-@code{nil}, the frame is drawn to the screen without double
buffering.  Emacs normally attempts to use double buffering, where
available, to reduce flicker.  Set this property if you experience
display bugs or pine for that retro, flicker-y feeling.

@vindex skip-taskbar@r{, a frame parameter}
@item skip-taskbar
If не-@code{nil}, this tells the window manager to remove the frame's
icon from the taskbar associated with the frame's display and inhibit
switching to the frame's window via the combination @kbd{Alt-@key{TAB}}.
On MS-Windows, iconifying such a frame will "roll in" its window-system
window at the bottom of the desktop.  Some window managers may not honor
this parameter.

@vindex no-focus-on-map@r{, a frame parameter}
@item no-focus-on-map
If не-@code{nil}, this means that the frame does not want to receive
input focus when it is mapped (@pxref{Visibility of Frames}).  Some
window managers may not honor this parameter.

@vindex no-accept-focus@r{, a frame parameter}
@item no-accept-focus
If не-@code{nil}, this means that the frame does not want to receive
input focus via explicit mouse clicks or when moving the mouse into it
either via @code{focus-follows-mouse} (@pxref{Input Focus}) or
@code{mouse-autoselect-window} (@pxref{Mouse Window Auto-selection}).
This may have the unwanted side-effect that a user cannot scroll a
non-selected frame with the mouse.  Some window managers may not honor
this parameter.

@vindex undecorated@r{, a frame parameter}
@item undecorated
If не-@code{nil}, this frame's window-system window is drawn without
decorations, like the title, minimize/maximize boxes and external
borders.  This usually means that the window cannot be dragged, resized,
iconified, maximized or deleted with the mouse.  If @code{nil}, the frame's
window is usually drawn with all the elements listed above unless their
display has been suspended via window manager settings.

Under X, Emacs uses the Motif window manager hints to turn off
decorations.  Some window managers may not honor these hints.

NS builds consider the tool bar to be a decoration, and therefore hide
it on an undecorated frame.

@vindex override-redirect@r{, a frame parameter}
@item override-redirect
@cindex override redirect frames
If не-@code{nil}, this means that this is an @dfn{override redirect}
frame---a frame not handled by window managers under X.  Override
redirect frames have no window manager decorations, can be positioned
and resized only via Emacs' positioning and resizing functions and are
usually drawn on top of all other frames.  Setting this parameter has
no effect on MS-Windows.

@ignore
@vindex parent-id@r{, a frame parameter}
@item parent-id
@c ??? Not yet working.
The X window number of the window that should be the parent of this one.
Specifying this lets you create an Emacs window inside some other
application's window.  (It is not certain this will be implemented; try
it and see if it works.)
@end ignore

@vindex ns-appearance@r{, a frame parameter}
@item ns-appearance
Only available on macOS, if set to @code{dark} draw this frame's
window-system window using the ``vibrant dark'' theme, otherwise use
the system default.  The ``vibrant dark'' theme can be used to set the
toolbar and scrollbars to a dark appearance when using an Emacs theme
with a dark background.

@vindex ns-transparent-titlebar@r{, a frame parameter}
@item ns-transparent-titlebar
Only available on macOS, if не-@code{nil}, set the titlebar and
toolbar to be transparent.  This effectively sets the background color
of both to match the Emacs background color.
@end table


@node Cursor Parameters
@subsubsection Cursor Parameters
@cindex cursor, and frame parameters

  This frame parameter controls the way the cursor looks.

@table @code
@vindex cursor-type@r{, a frame parameter}
@item cursor-type
How to display the cursor.  Legitimate values are:

@table @code
@item box
Display a filled box.  (This is the default.)
@item hollow
Display a hollow box.
@item nil
Don't display a cursor.
@item bar
Display a vertical bar between characters.
@item (bar . @var{width})
Display a vertical bar @var{width} pixels wide between characters.
@item hbar
Display a horizontal bar.
@item (hbar . @var{height})
Display a horizontal bar @var{height} pixels high.
@end table
@end table

@vindex cursor-type
The @code{cursor-type} frame parameter may be overridden by the
variables @code{cursor-type} and
@code{cursor-in-non-selected-windows}:

@defopt cursor-type
This buffer-local variable controls how the cursor looks in a selected
window showing the buffer.  If its value is @code{t}, that means to
use the cursor specified by the @code{cursor-type} frame parameter.
Otherwise, the value should be one of the cursor types listed above,
and it overrides the @code{cursor-type} frame parameter.
@end defopt

@defopt cursor-in-non-selected-windows
This buffer-local variable controls how the cursor looks in a window
that is not selected.  It supports the same values as the
@code{cursor-type} frame parameter; also, @code{nil} means don't
display a cursor in nonselected windows, and @code{t} (the default)
means use a standard modification of the usual cursor type (solid box
becomes hollow box, and bar becomes a narrower bar).
@end defopt

@defopt x-stretch-cursor
This variable controls the width of the block cursor displayed on
extra-wide glyphs such as a tab or a stretch of white space.  By
default, the block cursor is only as wide as the font's default
character, and will not cover all of the width of the glyph under it
if that glyph is extra-wide.  A не-@code{nil} value of this variable
means draw the block cursor as wide as the glyph under it.  The
default value is @code{nil}.

This variable has no effect on text-mode frames, since the text-mode
cursor is drawn by the terminal out of Emacs's control.
@end defopt

@defopt blink-cursor-alist
This variable specifies how to blink the cursor.  Each element has the
form @code{(@var{on-state} . @var{off-state})}.  Whenever the cursor
type equals @var{on-state} (comparing using @code{equal}), the
corresponding @var{off-state} specifies what the cursor looks like
when it blinks off.  Both @var{on-state} and @var{off-state}
should be suitable values for the @code{cursor-type} frame parameter.

There are various defaults for how to blink each type of cursor, if
the type is not mentioned as an @var{on-state} here.  Changes in this
variable do not take effect immediately, only when you specify the
@code{cursor-type} frame parameter.
@end defopt

@node Font and Color Parameters
@subsubsection Font and Color Parameters
@cindex font and color, frame parameters

  These frame parameters control the use of fonts and colors.

@table @code
@vindex font-backend@r{, a frame parameter}
@item font-backend
A list of symbols, specifying the @dfn{font backends} to use for
drawing fonts in the frame, in order of priority.  On X, there are
currently two available font backends: @code{x} (the X core font
driver) and @code{xft} (the Xft font driver).  On MS-Windows, there are
currently two available font backends: @code{gdi} and
@code{uniscribe} (@pxref{Windows Fonts,,, emacs, The GNU Emacs
Manual}).  On other systems, there is only one available font backend,
so it does not make sense to modify this frame parameter.

@vindex background-mode@r{, a frame parameter}
@item background-mode
This parameter is either @code{dark} or @code{light}, according
to whether the background color is a light one or a dark one.

@vindex tty-color-mode@r{, a frame parameter}
@item tty-color-mode
@cindex standard colors for character terminals
This parameter overrides the terminal's color support as given by the
system's terminal capabilities database in that this parameter's value
specifies the color mode to use on a text terminal.  The value can be
either a symbol or a number.  A number specifies the number of colors
to use (and, indirectly, what commands to issue to produce each
color).  For example, @code{(tty-color-mode . 8)} specifies use of the
ANSI escape sequences for 8 standard text colors.  A value of @minus{}1 turns
off color support.

If the parameter's value is a symbol, it specifies a number through
the value of @code{tty-color-mode-alist}, and the associated number is
used instead.

@vindex screen-gamma@r{, a frame parameter}
@item screen-gamma
@cindex gamma correction
If this is a number, Emacs performs gamma correction which adjusts
the brightness of all colors.  The value should be the screen gamma of
your display.

Usual PC monitors have a screen gamma of 2.2, so color values in
Emacs, and in X windows generally, are calibrated to display properly
on a monitor with that gamma value.  If you specify 2.2 for
@code{screen-gamma}, that means no correction is needed.  Other values
request correction, designed to make the corrected colors appear on
your screen the way they would have appeared without correction on an
ordinary monitor with a gamma value of 2.2.

If your monitor displays colors too light, you should specify a
@code{screen-gamma} value smaller than 2.2.  This requests correction
that makes colors darker.  A screen gamma value of 1.5 may give good
results for LCD color displays.

@vindex alpha@r{, a frame parameter}
@item alpha
@cindex opacity, frame
@cindex transparency, frame
@vindex frame-alpha-lower-limit
This parameter specifies the opacity of the frame, on graphical
displays that support variable opacity.  It should be an integer
between 0 and 100, where 0 means completely transparent and 100 means
completely opaque.  It can also have a @code{nil} value, which tells
Emacs not to set the frame opacity (leaving it to the window manager).

To prevent the frame from disappearing completely from view, the
variable @code{frame-alpha-lower-limit} defines a lower opacity limit.
If the value of the frame parameter is less than the value of this
variable, Emacs uses the latter.  By default,
@code{frame-alpha-lower-limit} is 20.

The @code{alpha} frame parameter can also be a cons cell
@code{(@var{active} . @var{inactive})}, where @var{active} is the
opacity of the frame when it is selected, and @var{inactive} is the
opacity when it is not selected.

Some window systems do not support the @code{alpha} parameter for child
frames (@pxref{Child Frames}).
@end table

The following frame parameters are semi-obsolete in that they are
automatically equivalent to particular face attributes of particular
faces (@pxref{Standard Faces,,, emacs, The Emacs Manual}):

@table @code
@vindex font@r{, a frame parameter}
@item font
The name of the font for displaying text in the frame.  This is a
string, either a valid font name for your system or the name of an Emacs
fontset (@pxref{Fontsets}).  It is equivalent to the @code{font}
attribute of the @code{default} face.

@vindex foreground-color@r{, a frame parameter}
@item foreground-color
The color to use for the image of a character.  It is equivalent to
the @code{:foreground} attribute of the @code{default} face.

@vindex background-color@r{, a frame parameter}
@item background-color
The color to use for the background of characters.  It is equivalent to
the @code{:background} attribute of the @code{default} face.

@vindex mouse-color@r{, a frame parameter}
@item mouse-color
The color for the mouse pointer.  It is equivalent to the @code{:background}
attribute of the @code{mouse} face.

@vindex cursor-color@r{, a frame parameter}
@item cursor-color
The color for the cursor that shows point.  It is equivalent to the
@code{:background} attribute of the @code{cursor} face.

@vindex border-color@r{, a frame parameter}
@item border-color
The color for the border of the frame.  It is equivalent to the
@code{:background} attribute of the @code{border} face.

@vindex scroll-bar-foreground@r{, a frame parameter}
@item scroll-bar-foreground
If не-@code{nil}, the color for the foreground of scroll bars.  It is
equivalent to the @code{:foreground} attribute of the
@code{scroll-bar} face.

@vindex scroll-bar-background@r{, a frame parameter}
@item scroll-bar-background
If не-@code{nil}, the color for the background of scroll bars.  It is
equivalent to the @code{:background} attribute of the
@code{scroll-bar} face.
@end table


@node Geometry
@subsection Geometry

  Here's how to examine the data in an X-style window geometry
specification:

@defun x-parse-geometry geom
@cindex geometry specification
The function @code{x-parse-geometry} converts a standard X window
geometry string to an alist that you can use as part of the argument to
@code{make-frame}.

The alist describes which parameters were specified in @var{geom}, and
gives the values specified for them.  Each element looks like
@code{(@var{parameter} . @var{value})}.  The possible @var{parameter}
values are @code{left}, @code{top}, @code{width}, and @code{height}.

For the size parameters, the value must be an integer.  The position
parameter names @code{left} and @code{top} are not totally accurate,
because some values indicate the position of the right or bottom edges
instead.  The @var{value} possibilities for the position parameters are:
an integer, a list @code{(+ @var{pos})}, or a list @code{(- @var{pos})};
as previously described (@pxref{Position Parameters}).

Here is an example:

@example
(x-parse-geometry "35x70+0-0")
     @result{} ((height . 70) (width . 35)
         (top - 0) (left . 0))
@end example
@end defun

@node Terminal Parameters
@section Terminal Parameters
@cindex terminal parameters

  Each terminal has a list of associated parameters.  These
@dfn{terminal parameters} are mostly a convenient way of storage for
terminal-local variables, but some terminal parameters have a special
meaning.

  This section describes functions to read and change the parameter values
of a terminal.  They all accept as their argument either a terminal or
a frame; the latter means use that frame's terminal.  An argument of
@code{nil} means the selected frame's terminal.

@defun terminal-parameters &optional terminal
This function returns an alist listing all the parameters of
@var{terminal} and their values.
@end defun

@defun terminal-parameter terminal parameter
This function returns the value of the parameter @var{parameter} (a
symbol) of @var{terminal}.  If @var{terminal} has no setting for
@var{parameter}, this function returns @code{nil}.
@end defun

@defun set-terminal-parameter terminal parameter value
This function sets the parameter @var{parameter} of @var{terminal} to the
specified @var{value}, and returns the previous value of that
parameter.
@end defun

Here's a list of a few terminal parameters that have a special
meaning:

@table @code
@item background-mode
The classification of the terminal's background color, either
@code{light} or @code{dark}.
@item normal-erase-is-backspace
Value is either 1 or 0, depending on whether
@code{normal-erase-is-backspace-mode} is turned on or off on this
terminal.  @xref{DEL Does Not Delete,,, emacs, The Emacs Manual}.
@item terminal-initted
After the terminal is initialized, this is set to the
terminal-specific initialization function.
@item tty-mode-set-strings
When present, a list of strings containing escape sequences that Emacs
will output while configuring a tty for rendering.  Emacs emits these
strings only when configuring a terminal: if you want to enable a mode
on a terminal that is already active (for example, while in
@code{tty-setup-hook}), explicitly output the necessary escape
sequence using @code{send-string-to-terminal} in addition to adding
the sequence to @code{tty-mode-set-strings}.
@item tty-mode-reset-strings
When present, a list of strings that undo the effects of the strings
in @code{tty-mode-set-strings}.  Emacs emits these strings when
exiting, deleting a terminal, or suspending itself.
@end table

@node Frame Titles
@section Frame Titles
@cindex frame title

  Every frame has a @code{name} parameter; this serves as the default
for the frame title which window systems typically display at the top of
the frame.  You can specify a name explicitly by setting the @code{name}
frame property.

  Normally you don't specify the name explicitly, and Emacs computes the
frame name automatically based on a template stored in the variable
@code{frame-title-format}.  Emacs recomputes the name each time the
frame is redisplayed.

@defvar frame-title-format
This variable specifies how to compute a name for a frame when you have
not explicitly specified one.  The variable's value is actually a mode
line construct, just like @code{mode-line-format}, except that the
@samp{%c}, @samp{%C}, and @samp{%l} constructs are ignored.  @xref{Mode Line
Data}.
@end defvar

@defvar icon-title-format
This variable specifies how to compute the name for an iconified frame,
when you have not explicitly specified the frame title.  This title
appears in the icon itself.
@end defvar

@defvar multiple-frames
This variable is set automatically by Emacs.  Its value is @code{t} when
there are two or more frames (not counting minibuffer-only frames or
invisible frames).  The default value of @code{frame-title-format} uses
@code{multiple-frames} so as to put the buffer name in the frame title
only when there is more than one frame.

The value of this variable is not guaranteed to be accurate except
while processing @code{frame-title-format} or
@code{icon-title-format}.
@end defvar

@node Deleting Frames
@section Deleting Frames
@cindex deleting frames

A @dfn{live frame} is one that has not been deleted.  When a frame is
deleted, it is removed from its terminal display, although it may
continue to exist as a Lisp object until there are no more references to
it.

@deffn Command delete-frame &optional frame force
@vindex delete-frame-functions
This function deletes the frame @var{frame}.  The argument @var{frame}
must specify a live frame (see below) and defaults to the selected
frame.

It first deletes any child frame of @var{frame} (@pxref{Child Frames})
and any frame whose @code{delete-before} frame parameter (@pxref{Frame
Interaction Parameters}) specifies @var{frame}.  All such deletions are
performed recursively; so this step makes sure that no other frames with
@var{frame} as their ancestor will exist.  Then, unless @var{frame}
specifies a tooltip, this function runs the hook
@code{delete-frame-functions} (each function getting one argument,
@var{frame}) before actually killing the frame.

Note that a frame cannot be deleted as long as its minibuffer serves as
surrogate minibuffer for another frame (@pxref{Minibuffers and Frames}).
Normally, you cannot delete a frame if all other frames are invisible,
but if @var{force} is не-@code{nil}, then you are allowed to do so.
@end deffn

@defun frame-live-p frame
This function returns не-@code{nil} if the frame @var{frame} has not
been deleted.  The possible не-@code{nil} return values are like those
of @code{framep}.  @xref{Frames}.
@end defun

  Some window managers provide a command to delete a window.  These work
by sending a special message to the program that operates the window.
When Emacs gets one of these commands, it generates a
@code{delete-frame} event, whose normal definition is a command that
calls the function @code{delete-frame}.  @xref{Misc Events}.

@deffn Command delete-other-frames &optional frame
This command deletes all frames on @var{frame}'s terminal, except
@var{frame}.  If @var{frame} uses another frame's minibuffer, that
minibuffer frame is left untouched.  The argument @var{frame} must
specify a live frame and defaults to the selected frame.  Internally,
this command works by calling @code{delete-frame} with @var{force}
@code{nil} for all frames that shall be deleted.

This function does not delete any of @var{frame}'s child frames
(@pxref{Child Frames}).  If @var{frame} is a child frame, it deletes
@var{frame}'s siblings only.
@end deffn


@node Finding All Frames
@section Finding All Frames
@cindex frames, scanning all

@defun frame-list
This function returns a list of all the live frames, i.e., those that
have not been deleted.  It is analogous to @code{buffer-list} for
buffers, and includes frames on all terminals.  The list that you get
is newly created, so modifying the list doesn't have any effect on the
internals of Emacs.
@end defun

@defun visible-frame-list
This function returns a list of just the currently visible frames.
@xref{Visibility of Frames}.  Frames on text terminals always count as
visible, even though only the selected one is actually displayed.
@end defun

@defun frame-list-z-order &optional display
This function returns a list of Emacs' frames, in Z (stacking) order
(@pxref{Raising and Lowering}).  The optional argument @var{display}
specifies which display to poll.  @var{display} should be either a frame
or a display name (a string).  If omitted or @code{nil}, that stands for
the selected frame's display.  It returns @code{nil} if @var{display}
contains no Emacs frame.

Frames are listed from topmost (first) to bottommost (last).  As a
special case, if @var{display} is не-@code{nil} and specifies a live
frame, it returns the child frames of that frame in Z (stacking) order.

This function is not meaningful on text terminals.
@end defun

@defun next-frame &optional frame minibuf
This function lets you cycle conveniently through all the frames on a
specific terminal from an arbitrary starting point.  It returns the
frame following @var{frame}, in the list of all live frames, on
@var{frame}'s terminal.  The argument @var{frame} must specify a live
frame and defaults to the selected frame.  It never returns a frame
whose @code{no-other-frame} parameter (@pxref{Frame Interaction
Parameters}) is не-@code{nil}.

The second argument, @var{minibuf}, says which frames to consider:

@table @asis
@item @code{nil}
Exclude minibuffer-only frames.
@item @code{visible}
Consider all visible frames.
@item 0
Consider all visible or iconified frames.
@item a window
Consider only the frames using that particular window as their
minibuffer.
@item anything else
Consider all frames.
@end table
@end defun

@defun previous-frame &optional frame minibuf
Like @code{next-frame}, but cycles through all frames in the opposite
direction.
@end defun

  See also @code{next-window} and @code{previous-window}, in @ref{Cyclic
Window Ordering}.

@node Minibuffers and Frames
@section Minibuffers and Frames

Normally, each frame has its own minibuffer window at the bottom, which
is used whenever that frame is selected.  You can get that window with
the function @code{minibuffer-window} (@pxref{Minibuffer Windows}).

@cindex frame without a minibuffer
@cindex surrogate minibuffer frame
However, you can also create a frame without a minibuffer.  Such a frame
must use the minibuffer window of some other frame.  That other frame
will serve as @dfn{surrogate minibuffer frame} for this frame and cannot
be deleted via @code{delete-frame} (@pxref{Deleting Frames}) as long as
this frame is live.

When you create the frame, you can explicitly specify its minibuffer
window (in some other frame) with the @code{minibuffer} frame parameter
(@pxref{Buffer Parameters}).  If you don't, then the minibuffer is found
in the frame which is the value of the variable
@code{default-minibuffer-frame}.  Its value should be a frame that does
have a minibuffer.

If you use a minibuffer-only frame, you might want that frame to raise
when you enter the minibuffer.  If so, set the variable
@code{minibuffer-auto-raise} to @code{t}.  @xref{Raising and Lowering}.

@defvar default-minibuffer-frame
This variable specifies the frame to use for the minibuffer window, by
default.  It does not affect existing frames.  It is always local to
the current terminal and cannot be buffer-local.  @xref{Multiple
Terminals}.
@end defvar


@node Input Focus
@section Input Focus
@cindex input focus
@cindex selected frame

At any time, one frame in Emacs is the @dfn{selected frame}.  The
selected window always resides on the selected frame.

When Emacs displays its frames on several terminals (@pxref{Multiple
Terminals}), each terminal has its own selected frame.  But only one
of these is @emph{the} selected frame: it's the frame that belongs
to the terminal from which the most recent input came.  That is, when
Emacs runs a command that came from a certain terminal, the selected
frame is the one of that terminal.  Since Emacs runs only a single
command at any given time, it needs to consider only one selected
frame at a time; this frame is what we call @dfn{the selected frame}
in this manual.  The display on which the selected frame is shown is
the @dfn{selected frame's display}.

@defun selected-frame
This function returns the selected frame.
@end defun

Some window systems and window managers direct keyboard input to the
window object that the mouse is in; others require explicit clicks or
commands to @dfn{shift the focus} to various window objects.  Either
way, Emacs automatically keeps track of which frame has the focus.  To
explicitly switch to a different frame from a Lisp function, call
@code{select-frame-set-input-focus}.

Lisp programs can also switch frames temporarily by calling the
function @code{select-frame}.  This does not alter the window system's
concept of focus; rather, it escapes from the window manager's control
until that control is somehow reasserted.

When using a text terminal, only one frame can be displayed at a time
on the terminal, so after a call to @code{select-frame}, the next
redisplay actually displays the newly selected frame.  This frame
remains selected until a subsequent call to @code{select-frame}.  Each
frame on a text terminal has a number which appears in the mode line
before the buffer name (@pxref{Mode Line Variables}).

@defun select-frame-set-input-focus frame &optional norecord
This function selects @var{frame}, raises it (should it happen to be
obscured by other frames) and tries to give it the X server's focus.
On a text terminal, the next redisplay displays the new frame on the
entire terminal screen.  The optional argument @var{norecord} has the
same meaning as for @code{select-frame} (see below).  The return value
of this function is not significant.
@end defun

Ideally, the function described next should focus a frame without also
raising it above other frames.  Unfortunately, many window-systems or
window managers may refuse to comply.

@defun x-focus-frame frame &optional noactivate
This function gives @var{frame} the focus of the X server without
necessarily raising it.  @var{frame} @code{nil} means use the selected
frame.  Under X, the optional argument @var{noactivate}, if
не-@code{nil}, means to avoid making @var{frame}'s window-system window
the ``active'' window which should insist a bit more on avoiding to
raise @var{frame} above other frames.

On MS-Windows the @var{noactivate} argument has no effect.  However, if
@var{frame} is a child frame (@pxref{Child Frames}), this function
usually focuses @var{frame} without raising it above other child
frames.

If there is no window system support, this function does nothing.
@end defun

@deffn Command select-frame frame &optional norecord
This function selects frame @var{frame}, temporarily disregarding the
focus of the X server if any.  The selection of @var{frame} lasts until
the next time the user does something to select a different frame, or
until the next time this function is called.  (If you are using a
window system, the previously selected frame may be restored as the
selected frame after return to the command loop, because it still may
have the window system's input focus.)

The specified @var{frame} becomes the selected frame, and its terminal
becomes the selected terminal.  This function then calls
@code{select-window} as a subroutine, passing the window selected
within @var{frame} as its first argument and @var{norecord} as its
second argument (hence, if @var{norecord} is не-@code{nil}, this
avoids changing the order of recently selected windows and the buffer
list).  @xref{Selecting Windows}.

This function returns @var{frame}, or @code{nil} if @var{frame} has
been deleted.

In general, you should never use @code{select-frame} in a way that
could switch to a different terminal without switching back when
you're done.
@end deffn

Emacs cooperates with the window system by arranging to select frames as
the server and window manager request.  It does so by generating a
special kind of input event, called a @dfn{focus} event, when
appropriate.  The command loop handles a focus event by calling
@code{handle-switch-frame}.  @xref{Focus Events}.

@deffn Command handle-switch-frame frame
This function handles a focus event by selecting frame @var{frame}.

Focus events normally do their job by invoking this command.
Don't call it for any other reason.
@end deffn

@defun redirect-frame-focus frame &optional focus-frame
This function redirects focus from @var{frame} to @var{focus-frame}.
This means that @var{focus-frame} will receive subsequent keystrokes and
events intended for @var{frame}.  After such an event, the value of
@code{last-event-frame} will be @var{focus-frame}.  Also, switch-frame
events specifying @var{frame} will instead select @var{focus-frame}.

If @var{focus-frame} is omitted or @code{nil}, that cancels any existing
redirection for @var{frame}, which therefore once again receives its own
events.

One use of focus redirection is for frames that don't have minibuffers.
These frames use minibuffers on other frames.  Activating a minibuffer
on another frame redirects focus to that frame.  This puts the focus on
the minibuffer's frame, where it belongs, even though the mouse remains
in the frame that activated the minibuffer.

Selecting a frame can also change focus redirections.  Selecting frame
@code{bar}, when @code{foo} had been selected, changes any redirections
pointing to @code{foo} so that they point to @code{bar} instead.  This
allows focus redirection to work properly when the user switches from
one frame to another using @code{select-window}.

This means that a frame whose focus is redirected to itself is treated
differently from a frame whose focus is not redirected.
@code{select-frame} affects the former but not the latter.

The redirection lasts until @code{redirect-frame-focus} is called to
change it.
@end defun

@defvar focus-in-hook
This is a normal hook run when an Emacs frame gains input focus.  The
frame gaining focus is selected when this hook is run.
@end defvar

@defvar focus-out-hook
This is a normal hook run when an Emacs frame has lost input focus and
no other Emacs frame has gained input focus instead.
@end defvar

@defopt focus-follows-mouse
This option informs Emacs whether and how the window manager transfers
focus when you move the mouse pointer into a frame.  It can have three
meaningful values:

@table @asis
@item @code{nil}
The default value @code{nil} should be used when your window manager
follows a ``click-to-focus'' policy where you have to click the mouse
inside of a frame in order for that frame to gain focus.

@item @code{t}
The value @code{t} should be used when your window manager has the focus
automatically follow the position of the mouse pointer but a frame that
gains focus is not raised automatically and may even remain occluded by
other window-system windows.

@item @code{auto-raise}
The value @code{auto-raise} should be used when your window manager has
the focus automatically follow the position of the mouse pointer and a
frame that gains focus is raised automatically.
@end table

If this option is не-@code{nil}, Emacs moves the mouse pointer to the
frame selected by @code{select-frame-set-input-focus}.  That function is
used by a number of commands like, for example, @code{other-frame} and
@code{pop-to-buffer}.

The distinction between the values @code{t} and @code{auto-raise} is not
needed for ``normal'' frames because the window manager usually takes
care of raising them.  It is useful to automatically raise child frames
via @code{mouse-autoselect-window} (@pxref{Mouse Window
Auto-selection}).

Note that this option does not distinguish ``sloppy'' focus (where the
frame that previously had focus retains focus as long as the mouse
pointer does not move into another window manager window) from
``strict'' focus (where a frame immediately loses focus when it's left
by the mouse pointer).  Neither does it recognize whether your window
manager supports delayed focusing or auto-raising where you can
explicitly specify the time until a new frame gets focus or is
auto-raised.

You can supply a ``focus follows mouse'' policy for individual Emacs
windows by customizing the variable @code{mouse-autoselect-window}
(@pxref{Mouse Window Auto-selection}).
@end defopt


@node Visibility of Frames
@section Visibility of Frames
@cindex visible frame
@cindex invisible frame
@cindex iconified frame
@cindex minimized frame
@cindex frame visibility

A frame on a graphical display may be @dfn{visible}, @dfn{invisible}, or
@dfn{iconified}.  If it is visible, its contents are displayed in the
usual manner.  If it is iconified, its contents are not displayed, but
there is a little icon somewhere to bring the frame back into view (some
window managers refer to this state as @dfn{minimized} rather than
@dfn{iconified}, but from Emacs' point of view they are the same thing).
If a frame is invisible, it is not displayed at all.

@cindex mapped frame
@cindex unmapped frame
  The concept of visibility is strongly related to that of (un-)mapped
frames.  A frame (or, more precisely, its window-system window) is and
becomes @dfn{mapped} when it is displayed for the first time and
whenever it changes its state of visibility from @code{iconified} or
@code{invisible} to @code{visible}.  Conversely, a frame is and becomes
@dfn{unmapped} whenever it changes its status from @code{visible} to
@code{iconified} or @code{invisible}.

  Visibility is meaningless on text terminals, since only the selected
frame is actually displayed in any case.

@defun frame-visible-p frame
This function returns the visibility status of frame @var{frame}.  The
value is @code{t} if @var{frame} is visible, @code{nil} if it is
invisible, and @code{icon} if it is iconified.

On a text terminal, all frames are considered visible for the
purposes of this function, even though only one frame is displayed.
@xref{Raising and Lowering}.
@end defun

@deffn Command iconify-frame &optional frame
This function iconifies frame @var{frame}.  If you omit @var{frame}, it
iconifies the selected frame.  This usually makes all child frames of
@var{frame} (and their descendants) invisible (@pxref{Child Frames}).
@end deffn

@deffn Command make-frame-visible &optional frame
This function makes frame @var{frame} visible.  If you omit @var{frame},
it makes the selected frame visible.  This does not raise the frame, but
you can do that with @code{raise-frame} if you wish (@pxref{Raising and
Lowering}).

Making a frame visible usually makes all its child frames (and their
descendants) visible as well (@pxref{Child Frames}).
@end deffn

@deffn Command make-frame-invisible &optional frame force
This function makes frame @var{frame} invisible.  If you omit
@var{frame}, it makes the selected frame invisible.  Usually, this makes
all child frames of @var{frame} (and their descendants) invisible too
(@pxref{Child Frames}).

Unless @var{force} is не-@code{nil}, this function refuses to make
@var{frame} invisible if all other frames are invisible.
@end deffn

  The visibility status of a frame is also available as a frame
parameter.  You can read or change it as such.  @xref{Management
Parameters}.  The user can also iconify and deiconify frames with the
window manager.  This happens below the level at which Emacs can exert
any control, but Emacs does provide events that you can use to keep
track of such changes.  @xref{Misc Events}.

@defun x-double-buffered-p &optional frame
This function returns не-@code{nil} if @var{frame} is currently
being rendered with double buffering.  @var{frame} defaults to the
selected frame.
@end defun


@node Raising and Lowering
@section Raising, Lowering and Restacking Frames

@cindex raising a frame
@cindex lowering a frame
@cindex restacking a frame
@cindex frame stacking order
@cindex frame Z-order
@cindex Z-order
  Most window systems use a desktop metaphor.  Part of this metaphor is
the idea that system-level windows (representing, e.g., Emacs frames)
are stacked in a notional third dimension perpendicular to the screen
surface.  The order induced by stacking is total and usually referred to
as stacking (or Z-) order.  Where the areas of two windows overlap, the
one higher up in that order will (partially) cover the one underneath.

  You can @dfn{raise} a frame to the top of that order or @dfn{lower} a
frame to its bottom by using the functions @code{raise-frame} and
@code{lower-frame}.  You can @dfn{restack} a frame directly above or
below another frame using the function @code{frame-restack}.

  Note that all functions described below will respect the adherence of
frames (and all other window-system windows) to their respective z-group
(@pxref{Position Parameters}).  For example, you usually cannot lower a
frame below that of the desktop window and you cannot raise a frame
whose @code{z-group} parameter is @code{nil} above the window-system's
taskbar or tooltip window.

@deffn Command raise-frame &optional frame
This function raises frame @var{frame} (default, the selected frame)
above all other frames belonging to the same or a lower z-group as
@var{frame}.  If @var{frame} is invisible or iconified, this makes it
visible.  If @var{frame} is a child frame (@pxref{Child Frames}), this
raises @var{frame} above all other child frames of its parent.
@end deffn

@deffn Command lower-frame &optional frame
This function lowers frame @var{frame} (default, the selected frame)
below all other frames belonging to the same or a higher z-group as
@var{frame}.  If @var{frame} is a child frame (@pxref{Child Frames}),
this lowers @var{frame} below all other child frames of its parent.
@end deffn

@defun frame-restack frame1 frame2 &optional above
This function restacks @var{frame1} below @var{frame2}.  This implies
that if both frames are visible and their display areas overlap,
@var{frame2} will (partially) obscure @var{frame1}.  If the optional
third argument @var{above} is не-@code{nil}, this function restacks
@var{frame1} above @var{frame2}.  This means that if both frames are
visible and their display areas overlap, @var{frame1} will (partially)
obscure @var{frame2}.

Technically, this function may be thought of as an atomic action
performed in two steps: The first step removes @var{frame1}'s
window-system window from the display.  The second step reinserts
@var{frame1}'s window into the display below (above if @var{above} is
true) that of @var{frame2}.  Hence the position of @var{frame2} in its
display's Z (stacking) order relative to all other frames excluding
@var{frame1} remains unaltered.

Some window managers may refuse to restack windows.
@end defun

Note that the effect of restacking will only hold as long as neither of
the involved frames is iconified or made invisible.  You can use the
@code{z-group} (@pxref{Position Parameters}) frame parameter to add a
frame to a group of frames permanently shown above or below other
frames.  As long as a frame belongs to one of these groups, restacking
it will only affect its relative stacking position within that group.
The effect of restacking frames belonging to different z-groups is
undefined.  You can list frames in their current stacking order with the
function @code{frame-list-z-order} (@pxref{Finding All Frames}).

@defopt minibuffer-auto-raise
If this is не-@code{nil}, activation of the minibuffer raises the frame
that the minibuffer window is in.
@end defopt

  On window systems, you can also enable auto-raising (on frame
selection) or auto-lowering (on frame deselection) using frame
parameters.  @xref{Management Parameters}.

@cindex top frame
  The concept of raising and lowering frames also applies to text
terminal frames.  On each text terminal, only the top frame is
displayed at any one time.

@defun tty-top-frame &optional terminal
This function returns the top frame on @var{terminal}.  @var{terminal}
should be a terminal object, a frame (meaning that frame's terminal),
or @code{nil} (meaning the selected frame's terminal).  If it does not
refer to a text terminal, the return value is @code{nil}.
@end defun


@node Frame Configurations
@section Frame Configurations
@cindex frame configuration

  A @dfn{frame configuration} records the current arrangement of frames,
all their properties, and the window configuration of each one.
(@xref{Window Configurations}.)

@defun current-frame-configuration
This function returns a frame configuration list that describes
the current arrangement of frames and their contents.
@end defun

@defun set-frame-configuration configuration &optional nodelete
This function restores the state of frames described in
@var{configuration}.  However, this function does not restore deleted
frames.

Ordinarily, this function deletes all existing frames not listed in
@var{configuration}.  But if @var{nodelete} is не-@code{nil}, the
unwanted frames are iconified instead.
@end defun


@node Child Frames
@section Child Frames
@cindex child frames
@cindex parent frames

Child frames are objects halfway between windows (@pxref{Windows}) and
``normal'' frames.  Like windows, they are attached to an owning frame.
Unlike windows, they may overlap each other---changing the size or
position of one child frame does not change the size or position of any
of its sibling child frames.

  By design, operations to make or modify child frames are implemented
with the help of frame parameters (@pxref{Frame Parameters}) without any
specialized functions or customizable variables.  Note that child frames
are meaningful on graphical terminals only.

  To create a new child frame or to convert a normal frame into a child
frame, set that frame's @code{parent-frame} parameter (@pxref{Frame
Interaction Parameters}) to that of an already existing frame.  The
frame specified by that parameter will then be the frame's parent frame
as long as the parameter is not changed or reset.  Technically, this
makes the child frame's window-system window a child window of the
parent frame's window-system window.

@cindex reparent frame
@cindex nest frame
  The @code{parent-frame} parameter can be changed at any time.  Setting
it to another frame @dfn{reparents} the child frame.  Setting it to
another child frame makes the frame a @dfn{nested} child frame.  Setting
it to @code{nil} restores the frame's status as a top-level frame---a
frame whose window-system window is a child of its display's root
window.

  Since child frames can be arbitrarily nested, a frame can be both a
child and a parent frame.  Also, the relative roles of child and parent
frame may be reversed at any time (though it's usually a good idea to
keep the size of a child frame sufficiently smaller than that of its
parent).  An error will be signaled for the attempt to make a frame an
ancestor of itself.

   Most window-systems clip a child frame at the native edges
(@pxref{Frame Geometry}) of its parent frame---everything outside these
edges is usually invisible.  A child frame's @code{left} and @code{top}
parameters specify a position relative to the top-left corner of its
parent's native frame.  When the parent frame is resized, this position
remains conceptually unaltered.

  NS builds do not clip child frames at the parent frame's edges,
allowing them to be positioned so they do not obscure the parent frame
while still being visible themselves.

  Usually, moving a parent frame moves along all its child frames and
their descendants as well, keeping their relative positions unaltered.
Note that the hook @code{move-frame-functions} (@pxref{Frame Position})
is run for a child frame only when the position of the child frame
relative to its parent frame changes.

  When a parent frame is resized, its child frames conceptually retain
their previous sizes and their positions relative to the left upper
corner of the parent.  This means that a child frame may become
(partially) invisible when its parent frame shrinks.  The parameter
@code{keep-ratio} (@pxref{Frame Interaction Parameters}) can be used to
resize and reposition a child frame proportionally whenever its parent
frame is resized.  This may avoid obscuring parts of a frame when its
parent frame is shrunk.

  A visible child frame always appears on top of its parent frame thus
obscuring parts of it, except on NS builds where it may be positioned
beneath the parent.  This is comparable to the window-system window of a
top-level frame which also always appears on top of its parent
window---the desktop's root window.  When a parent frame is iconified or
made invisible (@pxref{Visibility of Frames}), its child frames are made
invisible.  When a parent frame is deiconified or made visible, its
child frames are made visible.  When a parent frame is about to be
deleted (@pxref{Deleting Frames}), its child frames are recursively
deleted before it.

  Whether a child frame can have a menu or tool bar is window-system or
window manager dependent.  Most window-systems explicitly disallow menus
bars for child frames.  It seems advisable to disable both, menu and
tool bars, via the frame's initial parameters settings.

  Usually, child frames do not exhibit window manager decorations like a
title bar or external borders (@pxref{Frame Geometry}).  When the child
frame does not show a menu or tool bar, any other of the frame's borders
(@pxref{Layout Parameters}) can be used instead of the external borders.

  In particular, under X (but not when building with GTK+), the frame's
outer border can be used.  On MS-Windows, specifying a non-zero outer
border width will show a one-pixel wide external border.  Under all
window-systems, the internal border can be used.  In either case, it's
advisable to disable a child frame's window manager decorations with the
@code{undecorated} frame parameter (@pxref{Management Parameters}).

  To resize or move an undecorated child frame with the mouse, special
frame parameters (@pxref{Mouse Dragging Parameters}) have to be used.
The internal border of a child frame, if present, can be used to resize
the frame with the mouse, provided that frame has a не-@code{nil}
@code{drag-internal-border} parameter.  If set, the @code{snap-width}
parameter indicates the number of pixels where the frame @dfn{snaps} at
the respective edge or corner of its parent frame.

  There are two ways to drag an entire child frame with the mouse: The
@code{drag-with-mode-line} parameter, if не-@code{nil}, allows to drag
a frame without minibuffer window (@pxref{Minibuffer Windows}) via the
mode line area of its bottommost window.  The
@code{drag-with-header-line} parameter, if не-@code{nil}, allows to
drag the frame via the header line area of its topmost window.

  In order to give a child frame a draggable header or mode line, the
window parameters @code{mode-line-format} and @code{header-line-format}
are handy (@pxref{Window Parameters}).  These allow to remove an
unwanted mode line (when @code{drag-with-header-line} is chosen) and to
remove mouse-sensitive areas which might interfere with frame dragging.

  To avoid that dragging moves a frame completely out of its parent's
native frame, something which might happen when the mouse cursor
overshoots and makes the frame difficult to retrieve once the mouse
button has been released, it is advisable to set the frame's
@code{top-visible} or @code{bottom-visible} parameter correspondingly.

  The @code{top-visible} parameter specifies the number of pixels at the
top of the frame that always remain visible within the parent's native
frame during dragging and should be set when specifying a не-@code{nil}
@code{drag-with-header-line} parameter.  The @code{bottom-visible}
parameter specifies the number of pixels at the bottom of the frame that
always remain visible within the parent's native frame during dragging
and should be preferred when specifying a не-@code{nil}
@code{drag-with-mode-line} parameter.

  When a child frame is used for displaying a buffer via
@code{display-buffer-in-child-frame} (@pxref{Buffer Display Action
Functions}), the frame's @code{auto-hide-function} parameter
(@pxref{Frame Interaction Parameters}) can be set to a function, in
order to appropriately deal with the frame when the window displaying
the buffer shall be quit.

  When a child frame is used during minibuffer interaction, for example,
to display completions in a separate window, the @code{minibuffer-exit}
parameter (@pxref{Frame Interaction Parameters}) is useful in order to
deal with the frame when the minibuffer is exited.

  The behavior of child frames deviates from that of top-level frames in
a number of other ways as well.  Here we sketch a few of them:

@itemize @bullet
@item
The semantics of maximizing and iconifying child frames is highly
window-system dependent.  As a rule, applications should never invoke
these operations on child frames.  By default, invoking
@code{iconify-frame} on a child frame will try to iconify the top-level
frame corresponding to that child frame instead.  To obtain a different
behavior, users may customize the option @code{iconify-child-frame}
described below.

@item
Raising, lowering and restacking child frames (@pxref{Raising and
Lowering}) or changing the @code{z-group} (@pxref{Position Parameters})
of a child frame changes only the stacking order of child frames with
the same parent.

@item
Many window-systems are not able to change the opacity (@pxref{Font and
Color Parameters}) of child frames.

@item
Transferring focus from a child frame to an ancestor that is not its
parent by clicking with the mouse in a visible part of that ancestor's
window may fail with some window-systems.  You may have to click into
the direct parent's window-system window first.

@item
Window managers might not bother to extend their focus follows mouse
policy to child frames.  Customizing @code{mouse-autoselect-window} can
help in this regard (@pxref{Mouse Window Auto-selection}).

@item
Dropping (@pxref{Drag and Drop}) on child frames is not guaranteed to
work on all window-systems.  Some will drop the object on the parent
frame or on some ancestor instead.
@end itemize

  The following two functions can be useful when working with child and
parent frames:

@defun frame-parent &optional frame
This function returns the parent frame of @var{frame}.  The parent frame
of @var{frame} is the Emacs frame whose window-system window is the
parent window of @var{frame}'s window-system window.  If such a frame
exists, @var{frame} is considered a child frame of that frame.

This function returns @code{nil} if @var{frame} has no parent frame.
@end defun

@defun frame-ancestor-p ancestor descendant
This functions returns не-@code{nil} if @var{ancestor} is an ancestor
of @var{descendant}.  @var{ancestor} is an ancestor of @var{descendant}
when it is either @var{descendant}'s parent frame or it is an ancestor
of @var{descendant}'s parent frame.  Both, @var{ancestor} and
@var{descendant} must specify live frames.
@end defun

Note also the function @code{window-largest-empty-rectangle}
(@pxref{Coordinates and Windows}) which can be used to inscribe a child
frame in the largest empty area of an existing window.  This can be
useful to avoid that a child frame obscures any text shown in that
window.

Customizing the following option can be useful to tweak the behavior of
@code{iconify-frame} for child frames.

@defopt iconify-child-frame
This option tells Emacs how to proceed when it is asked to iconify a
child frame.  If it is @code{nil}, @code{iconify-frame} will do nothing
when invoked on a child frame.  If it is @code{iconify-top-level}, Emacs
will try to iconify the top-level frame that is the ancestor of this
child frame instead.  If it is @code{make-invisible}, Emacs will try to
make this child frame invisible instead of iconifying it.

Any other value means to try iconifying the child frame.  Since such an
attempt may not be honored by all window managers and can even lead to
making the child frame unresponsive to user actions, the default is to
iconify the top level frame instead.
@end defopt


@node Mouse Tracking
@section Mouse Tracking
@cindex mouse tracking
@c @cindex tracking the mouse   Duplicates track-mouse

  Sometimes it is useful to @dfn{track} the mouse, which means to display
something to indicate where the mouse is and move the indicator as the
mouse moves.  For efficient mouse tracking, you need a way to wait until
the mouse actually moves.

  The convenient way to track the mouse is to ask for events to represent
mouse motion.  Then you can wait for motion by waiting for an event.  In
addition, you can easily handle any other sorts of events that may
occur.  That is useful, because normally you don't want to track the
mouse forever---only until some other event, such as the release of a
button.

@defmac track-mouse body@dots{}
This macro executes @var{body}, with generation of mouse motion events
enabled.  Typically, @var{body} would use @code{read-event} to read
the motion events and modify the display accordingly.  @xref{Motion
Events}, for the format of mouse motion events.

The value of @code{track-mouse} is that of the last form in @var{body}.
You should design @var{body} to return when it sees the up-event that
indicates the release of the button, or whatever kind of event means
it is time to stop tracking.

The @code{track-mouse} form causes Emacs to generate mouse motion
events by binding the variable @code{track-mouse} to a
не-@code{nil} value.  If that variable has the special value
@code{dragging}, it additionally instructs the display engine to
refrain from changing the shape of the mouse pointer.  This is
desirable in Lisp programs that require mouse dragging across large
portions of Emacs display, which might otherwise cause the mouse
pointer to change its shape according to the display portion it hovers
on (@pxref{Pointer Shape}).  Therefore, Lisp programs that need the
mouse pointer to retain its original shape during dragging should bind
@code{track-mouse} to the value @code{dragging} at the beginning of
their @var{body}.
@end defmac

The usual purpose of tracking mouse motion is to indicate on the screen
the consequences of pushing or releasing a button at the current
position.

In many cases, you can avoid the need to track the mouse by using
the @code{mouse-face} text property (@pxref{Special Properties}).
That works at a much lower level and runs more smoothly than
Lisp-level mouse tracking.

@ignore
@c These are not implemented yet.

These functions change the screen appearance instantaneously.  The
effect is transient, only until the next ordinary Emacs redisplay.  That
is OK for mouse tracking, since it doesn't make sense for mouse tracking
to change the text, and the body of @code{track-mouse} normally reads
the events itself and does not do redisplay.

@defun x-contour-region window beg end
This function draws lines to make a box around the text from @var{beg}
to @var{end}, in window @var{window}.
@end defun

@defun x-uncontour-region window beg end
This function erases the lines that would make a box around the text
from @var{beg} to @var{end}, in window @var{window}.  Use it to remove
a contour that you previously made by calling @code{x-contour-region}.
@end defun

@defun x-draw-rectangle frame left top right bottom
This function draws a hollow rectangle on frame @var{frame} with the
specified edge coordinates, all measured in pixels from the inside top
left corner.  It uses the cursor color, the one used for indicating the
location of point.
@end defun

@defun x-erase-rectangle frame left top right bottom
This function erases a hollow rectangle on frame @var{frame} with the
specified edge coordinates, all measured in pixels from the inside top
left corner.  Erasure means redrawing the text and background that
normally belong in the specified rectangle.
@end defun
@end ignore

@node Mouse Position
@section Mouse Position
@cindex mouse position
@cindex position of mouse

  The functions @code{mouse-position} and @code{set-mouse-position}
give access to the current position of the mouse.

@defun mouse-position
This function returns a description of the position of the mouse.  The
value looks like @code{(@var{frame} @var{x} . @var{y})}, where @var{x}
and @var{y} are integers giving the (possibly rounded) position in
multiples of the default character size of @var{frame} (@pxref{Frame
Font}) relative to the native position of @var{frame} (@pxref{Frame
Geometry}).
@end defun

@defvar mouse-position-function
If не-@code{nil}, the value of this variable is a function for
@code{mouse-position} to call.  @code{mouse-position} calls this
function just before returning, with its normal return value as the
sole argument, and it returns whatever this function returns to it.

This abnormal hook exists for the benefit of packages like
@file{xt-mouse.el} that need to do mouse handling at the Lisp level.
@end defvar

@defun set-mouse-position frame x y
This function @dfn{warps the mouse} to position @var{x}, @var{y} in
frame @var{frame}.  The arguments @var{x} and @var{y} are integers,
giving the position in multiples of the default character size of
@var{frame} (@pxref{Frame Font}) relative to the native position of
@var{frame} (@pxref{Frame Geometry}).

The resulting mouse position is constrained to the native frame of
@var{frame}.  If @var{frame} is not visible, this function does nothing.
The return value is not significant.
@end defun

@defun mouse-pixel-position
This function is like @code{mouse-position} except that it returns
coordinates in units of pixels rather than units of characters.
@end defun

@defun set-mouse-pixel-position frame x y
This function warps the mouse like @code{set-mouse-position} except that
@var{x} and @var{y} are in units of pixels rather than units of
characters.

The resulting mouse position is not constrained to the native frame of
@var{frame}.  If @var{frame} is not visible, this function does nothing.
The return value is not significant.
@end defun

On a graphical terminal the following two functions allow the absolute
position of the mouse cursor to be retrieved and set.

@defun mouse-absolute-pixel-position
This function returns a cons cell (@var{x} . @var{y}) of the coordinates
of the mouse cursor position in pixels, relative to a position (0, 0) of
the selected frame's display.
@end defun

@defun set-mouse-absolute-pixel-position x y
This function moves the mouse cursor to the position (@var{x}, @var{y}).
The coordinates @var{x} and @var{y} are interpreted in pixels relative
to a position (0, 0) of the selected frame's display.
@end defun

The following function can tell whether the mouse cursor is currently
visible on a frame:

@defun frame-pointer-visible-p &optional frame
This predicate function returns не-@code{nil} if the mouse pointer
displayed on @var{frame} is visible; otherwise it returns @code{nil}.
@var{frame} omitted or @code{nil} means the selected frame.  This is
useful when @code{make-pointer-invisible} is set to @code{t}: it
allows you to know if the pointer has been hidden.
@xref{Mouse Avoidance,,,emacs, The Emacs Manual}.
@end defun

@need 3000

@node Pop-Up Menus
@section Pop-Up Menus
@cindex menus, popup

  A Lisp program can pop up a menu so that the user can choose an
alternative with the mouse.  On a text terminal, if the mouse is not
available, the user can choose an alternative using the keyboard
motion keys---@kbd{C-n}, @kbd{C-p}, or up- and down-arrow keys.

@defun x-popup-menu position menu
This function displays a pop-up menu and returns an indication of
what selection the user makes.

The argument @var{position} specifies where on the screen to put the
top left corner of the menu.  It can be either a mouse button event
(which says to put the menu where the user actuated the button) or a
list of this form:

@example
((@var{xoffset} @var{yoffset}) @var{window})
@end example

@noindent
where @var{xoffset} and @var{yoffset} are coordinates, measured in
pixels, counting from the top left corner of @var{window}.  @var{window}
may be a window or a frame.

If @var{position} is @code{t}, it means to use the current mouse
position (or the top-left corner of the frame if the mouse is not
available on a text terminal).  If @var{position} is @code{nil}, it
means to precompute the key binding equivalents for the keymaps
specified in @var{menu}, without actually displaying or popping up the
menu.

The argument @var{menu} says what to display in the menu.  It can be a
keymap or a list of keymaps (@pxref{Menu Keymaps}).  In this case, the
return value is the list of events corresponding to the user's choice.
This list has more than one element if the choice occurred in a
submenu.  (Note that @code{x-popup-menu} does not actually execute the
command bound to that sequence of events.)  On text terminals and
toolkits that support menu titles, the title is taken from the prompt
string of @var{menu} if @var{menu} is a keymap, or from the prompt
string of the first keymap in @var{menu} if it is a list of keymaps
(@pxref{Defining Menus}).

Alternatively, @var{menu} can have the following form:

@example
(@var{title} @var{pane1} @var{pane2}...)
@end example

@noindent
where each pane is a list of form

@example
(@var{title} @var{item1} @var{item2}...)
@end example

Each @var{item} should be a cons cell, @code{(@var{line} . @var{value})},
where @var{line} is a string and @var{value} is the value to return if
that @var{line} is chosen.  Unlike in a menu keymap, a @code{nil}
@var{value} does not make the menu item non-selectable.
Alternatively, each @var{item} can be a string rather than a cons
cell; this makes a non-selectable menu item.

If the user gets rid of the menu without making a valid choice, for
instance by clicking the mouse away from a valid choice or by typing
@kbd{C-g}, then this normally results in a quit and
@code{x-popup-menu} does not return.  But if @var{position} is a mouse
button event (indicating that the user invoked the menu with the
mouse) then no quit occurs and @code{x-popup-menu} returns @code{nil}.
@end defun

  @strong{Usage note:} Don't use @code{x-popup-menu} to display a menu
if you could do the job with a prefix key defined with a menu keymap.
If you use a menu keymap to implement a menu, @kbd{C-h c} and @kbd{C-h
a} can see the individual items in that menu and provide help for them.
If instead you implement the menu by defining a command that calls
@code{x-popup-menu}, the help facilities cannot know what happens inside
that command, so they cannot give any help for the menu's items.

  The menu bar mechanism, which lets you switch between submenus by
moving the mouse, cannot look within the definition of a command to see
that it calls @code{x-popup-menu}.  Therefore, if you try to implement a
submenu using @code{x-popup-menu}, it cannot work with the menu bar in
an integrated fashion.  This is why all menu bar submenus are
implemented with menu keymaps within the parent menu, and never with
@code{x-popup-menu}.  @xref{Menu Bar}.

  If you want a menu bar submenu to have contents that vary, you should
still use a menu keymap to implement it.  To make the contents vary, add
a hook function to @code{menu-bar-update-hook} to update the contents of
the menu keymap as necessary.

@node Dialog Boxes
@section Dialog Boxes
@cindex dialog boxes

  A dialog box is a variant of a pop-up menu---it looks a little
different, it always appears in the center of a frame, and it has just
one level and one or more buttons.  The main use of dialog boxes is
for asking questions that the user can answer with ``yes'', ``no'',
and a few other alternatives.  With a single button, they can also
force the user to acknowledge important information.  The functions
@code{y-or-n-p} and @code{yes-or-no-p} use dialog boxes instead of the
keyboard, when called from commands invoked by mouse clicks.

@defun x-popup-dialog position contents &optional header
This function displays a pop-up dialog box and returns an indication of
what selection the user makes.  The argument @var{contents} specifies
the alternatives to offer; it has this format:

@example
(@var{title} (@var{string} . @var{value})@dots{})
@end example

@noindent
which looks like the list that specifies a single pane for
@code{x-popup-menu}.

The return value is @var{value} from the chosen alternative.

As for @code{x-popup-menu}, an element of the list may be just a
string instead of a cons cell @code{(@var{string} . @var{value})}.
That makes a box that cannot be selected.

If @code{nil} appears in the list, it separates the left-hand items from
the right-hand items; items that precede the @code{nil} appear on the
left, and items that follow the @code{nil} appear on the right.  If you
don't include a @code{nil} in the list, then approximately half the
items appear on each side.

Dialog boxes always appear in the center of a frame; the argument
@var{position} specifies which frame.  The possible values are as in
@code{x-popup-menu}, but the precise coordinates or the individual
window don't matter; only the frame matters.

If @var{header} is не-@code{nil}, the frame title for the box is
@samp{Information}, otherwise it is @samp{Question}.  The former is used
for @code{message-box} (@pxref{message-box}).  (On text terminals, the
box title is not displayed.)

In some configurations, Emacs cannot display a real dialog box; so
instead it displays the same items in a pop-up menu in the center of the
frame.

If the user gets rid of the dialog box without making a valid choice,
for instance using the window manager, then this produces a quit and
@code{x-popup-dialog} does not return.
@end defun

@node Pointer Shape
@section Pointer Shape
@cindex pointer shape
@cindex mouse pointer shape

  You can specify the mouse pointer style for particular text or
images using the @code{pointer} text property, and for images with the
@code{:pointer} and @code{:map} image properties.  The values you can
use in these properties are @code{text} (or @code{nil}), @code{arrow},
@code{hand}, @code{vdrag}, @code{hdrag}, @code{modeline}, and
@code{hourglass}.  @code{text} stands for the usual mouse pointer
style used over text.

  Over void parts of the window (parts that do not correspond to any
of the buffer contents), the mouse pointer usually uses the
@code{arrow} style, but you can specify a different style (one of
those above) by setting @code{void-text-area-pointer}.

@defopt void-text-area-pointer
This variable specifies the mouse pointer style for void text areas.
These include the areas after the end of a line or below the last line
in the buffer.  The default is to use the @code{arrow} (non-text)
pointer style.
@end defopt

  When using X, you can specify what the @code{text} pointer style
really looks like by setting the variable @code{x-pointer-shape}.

@defvar x-pointer-shape
This variable specifies the pointer shape to use ordinarily in the
Emacs frame, for the @code{text} pointer style.
@end defvar

@defvar x-sensitive-text-pointer-shape
This variable specifies the pointer shape to use when the mouse
is over mouse-sensitive text.
@end defvar

  These variables affect newly created frames.  They do not normally
affect existing frames; however, if you set the mouse color of a
frame, that also installs the current value of those two variables.
@xref{Font and Color Parameters}.

  The values you can use, to specify either of these pointer shapes, are
defined in the file @file{lisp/term/x-win.el}.  Use @kbd{M-x apropos
@key{RET} x-pointer @key{RET}} to see a list of them.

@node Window System Selections
@section Window System Selections
@cindex selection (for window systems)
@cindex clipboard
@cindex primary selection
@cindex secondary selection

  In window systems, such as X, data can be transferred between
different applications by means of @dfn{selections}.  X defines an
arbitrary number of @dfn{selection types}, each of which can store its
own data; however, only three are commonly used: the @dfn{clipboard},
@dfn{primary selection}, and @dfn{secondary selection}.  Other window
systems support only the clipboard.  @xref{Cut and Paste,, Cut and
Paste, emacs, The GNU Emacs Manual}, for Emacs commands that make use
of these selections.  This section documents the low-level functions
for reading and setting window-system selections.

@deffn Command gui-set-selection type data
This function sets a window-system selection.  It takes two arguments:
a selection type @var{type}, and the value to assign to it, @var{data}.

@var{type} should be a symbol; it is usually one of @code{PRIMARY},
@code{SECONDARY} or @code{CLIPBOARD}.  These are symbols with
upper-case names, in accord with X Window System conventions.  If
@var{type} is @code{nil}, that stands for @code{PRIMARY}.

If @var{data} is @code{nil}, it means to clear out the selection.
Otherwise, @var{data} may be a string, a symbol, an integer (or a cons
of two integers or list of two integers), an overlay, or a cons of two
markers pointing to the same buffer.  An overlay or a pair of markers
stands for text in the overlay or between the markers.  The argument
@var{data} may also be a vector of valid non-vector selection values.

This function returns @var{data}.
@end deffn

@defun gui-get-selection &optional type data-type
This function accesses selections set up by Emacs or by other
programs.  It takes two optional arguments, @var{type} and
@var{data-type}.  The default for @var{type}, the selection type, is
@code{PRIMARY}.

The @var{data-type} argument specifies the form of data conversion to
use, to convert the raw data obtained from another program into Lisp
data.  Meaningful values include @code{TEXT}, @code{STRING},
@code{UTF8_STRING}, @code{TARGETS}, @code{LENGTH}, @code{DELETE},
@code{FILE_NAME}, @code{CHARACTER_POSITION}, @code{NAME},
@code{LINE_NUMBER}, @code{COLUMN_NUMBER}, @code{OWNER_OS},
@code{HOST_NAME}, @code{USER}, @code{CLASS}, @code{ATOM}, and
@code{INTEGER}.  (These are symbols with upper-case names in accord
with X conventions.)  The default for @var{data-type} is
@code{STRING}.  Window systems other than X usually support only a
small subset of these types, in addition to @code{STRING}.
@end defun

@defopt selection-coding-system
This variable specifies the coding system to use when reading and
writing selections or the clipboard.  @xref{Coding
Systems}.  The default is @code{compound-text-with-extensions}, which
converts to the text representation that X11 normally uses.
@end defopt

@cindex clipboard support (for MS-Windows)
When Emacs runs on MS-Windows, it does not implement X selections in
general, but it does support the clipboard.  @code{gui-get-selection}
and @code{gui-set-selection} on MS-Windows support the text data type
only; if the clipboard holds other types of data, Emacs treats the
clipboard as empty.  The supported data type is @code{STRING}.

For backward compatibility, there are obsolete aliases
@code{x-get-selection} and @code{x-set-selection}, which were the
names of @code{gui-get-selection} and @code{gui-set-selection} before
Emacs 25.1.

@node Drag and Drop
@section Drag and Drop
@cindex drag and drop

@vindex x-dnd-test-function
@vindex x-dnd-known-types
  When a user drags something from another application over Emacs, that other
application expects Emacs to tell it if Emacs can handle the data that is
dragged.  The variable @code{x-dnd-test-function} is used by Emacs to determine
what to reply.  The default value is @code{x-dnd-default-test-function}
which accepts drops if the type of the data to be dropped is present in
@code{x-dnd-known-types}.  You can customize @code{x-dnd-test-function} and/or
@code{x-dnd-known-types} if you want Emacs to accept or reject drops based
on some other criteria.

@vindex x-dnd-types-alist
  If you want to change the way Emacs handles drop of different types
or add a new type, customize @code{x-dnd-types-alist}.  This requires
detailed knowledge of what types other applications use for drag and
drop.

@vindex dnd-protocol-alist
  When an URL is dropped on Emacs it may be a file, but it may also be
another URL type (ftp, http, etc.).  Emacs first checks
@code{dnd-protocol-alist} to determine what to do with the URL@.  If
there is no match there and if @code{browse-url-browser-function} is
an alist, Emacs looks for a match there.  If no match is found the
text for the URL is inserted.  If you want to alter Emacs behavior,
you can customize these variables.

@node Color Names
@section Color Names

@cindex color names
@cindex specify color
@cindex numerical RGB color specification
  A color name is text (usually in a string) that specifies a color.
Symbolic names such as @samp{black}, @samp{white}, @samp{red}, etc.,
are allowed; use @kbd{M-x list-colors-display} to see a list of
defined names.  You can also specify colors numerically in forms such
as @samp{#@var{rgb}} and @samp{RGB:@var{r}/@var{g}/@var{b}}, where
@var{r} specifies the red level, @var{g} specifies the green level,
and @var{b} specifies the blue level.  You can use either one, two,
three, or four hex digits for @var{r}; then you must use the same
number of hex digits for all @var{g} and @var{b} as well, making
either 3, 6, 9 or 12 hex digits in all.  (See the documentation of the
X Window System for more details about numerical RGB specification of
colors.)

  These functions provide a way to determine which color names are
valid, and what they look like.  In some cases, the value depends on the
@dfn{selected frame}, as described below; see @ref{Input Focus}, for the
meaning of the term ``selected frame''.

  To read user input of color names with completion, use
@code{read-color} (@pxref{High-Level Completion, read-color}).

@defun color-defined-p color &optional frame
This function reports whether a color name is meaningful.  It returns
@code{t} if so; otherwise, @code{nil}.  The argument @var{frame} says
which frame's display to ask about; if @var{frame} is omitted or
@code{nil}, the selected frame is used.

Note that this does not tell you whether the display you are using
really supports that color.  When using X, you can ask for any defined
color on any kind of display, and you will get some result---typically,
the closest it can do.  To determine whether a frame can really display
a certain color, use @code{color-supported-p} (see below).

@findex x-color-defined-p
This function used to be called @code{x-color-defined-p},
and that name is still supported as an alias.
@end defun

@defun defined-colors &optional frame
This function returns a list of the color names that are defined
and supported on frame @var{frame} (default, the selected frame).
If @var{frame} does not support colors, the value is @code{nil}.

@findex x-defined-colors
This function used to be called @code{x-defined-colors},
and that name is still supported as an alias.
@end defun

@defun color-supported-p color &optional frame background-p
This returns @code{t} if @var{frame} can really display the color
@var{color} (or at least something close to it).  If @var{frame} is
omitted or @code{nil}, the question applies to the selected frame.

Some terminals support a different set of colors for foreground and
background.  If @var{background-p} is не-@code{nil}, that means you are
asking whether @var{color} can be used as a background; otherwise you
are asking whether it can be used as a foreground.

The argument @var{color} must be a valid color name.
@end defun

@defun color-gray-p color &optional frame
This returns @code{t} if @var{color} is a shade of gray, as defined on
@var{frame}'s display.  If @var{frame} is omitted or @code{nil}, the
question applies to the selected frame.  If @var{color} is not a valid
color name, this function returns @code{nil}.
@end defun

@defun color-values color &optional frame
@cindex rgb value
This function returns a value that describes what @var{color} should
ideally look like on @var{frame}.  If @var{color} is defined, the
value is a list of three integers, which give the amount of red, the
amount of green, and the amount of blue.  Each integer ranges in
principle from 0 to 65535, but some displays may not use the full
range.  This three-element list is called the @dfn{rgb values} of the
color.

If @var{color} is not defined, the value is @code{nil}.

@example
(color-values "black")
     @result{} (0 0 0)
(color-values "white")
     @result{} (65280 65280 65280)
(color-values "red")
     @result{} (65280 0 0)
(color-values "pink")
     @result{} (65280 49152 51968)
(color-values "hungry")
     @result{} nil
@end example

The color values are returned for @var{frame}'s display.  If
@var{frame} is omitted or @code{nil}, the information is returned for
the selected frame's display.  If the frame cannot display colors, the
value is @code{nil}.

@findex x-color-values
This function used to be called @code{x-color-values},
and that name is still supported as an alias.
@end defun

@node Text Terminal Colors
@section Text Terminal Colors
@cindex colors on text terminals

  Text terminals usually support only a small number of colors, and
the computer uses small integers to select colors on the terminal.
This means that the computer cannot reliably tell what the selected
color looks like; instead, you have to inform your application which
small integers correspond to which colors.  However, Emacs does know
the standard set of colors and will try to use them automatically.

  The functions described in this section control how terminal colors
are used by Emacs.

  Several of these functions use or return @dfn{rgb values}, described
in @ref{Color Names}.

  These functions accept a display (either a frame or the name of a
terminal) as an optional argument.  We hope in the future to make
Emacs support different colors on different text terminals; then this
argument will specify which terminal to operate on (the default being
the selected frame's terminal; @pxref{Input Focus}).  At present,
though, the @var{frame} argument has no effect.

@defun tty-color-define name number &optional rgb frame
This function associates the color name @var{name} with
color number @var{number} on the terminal.

The optional argument @var{rgb}, if specified, is an rgb value, a list
of three numbers that specify what the color actually looks like.
If you do not specify @var{rgb}, then this color cannot be used by
@code{tty-color-approximate} to approximate other colors, because
Emacs will not know what it looks like.
@end defun

@defun tty-color-clear &optional frame
This function clears the table of defined colors for a text terminal.
@end defun

@defun tty-color-alist &optional frame
This function returns an alist recording the known colors supported by
a text terminal.

Each element has the form @code{(@var{name} @var{number} . @var{rgb})}
or @code{(@var{name} @var{number})}.  Here, @var{name} is the color
name, @var{number} is the number used to specify it to the terminal.
If present, @var{rgb} is a list of three color values (for red, green,
and blue) that says what the color actually looks like.
@end defun

@defun tty-color-approximate rgb &optional frame
This function finds the closest color, among the known colors
supported for @var{display}, to that described by the rgb value
@var{rgb} (a list of color values).  The return value is an element of
@code{tty-color-alist}.
@end defun

@defun tty-color-translate color &optional frame
This function finds the closest color to @var{color} among the known
colors supported for @var{display} and returns its index (an integer).
If the name @var{color} is not defined, the value is @code{nil}.
@end defun

@node Resources
@section X Resources

This section describes some of the functions and variables for
querying and using X resources, or their equivalent on your operating
system.  @xref{X Resources,, X Resources, emacs, The GNU Emacs
Manual}, for more information about X resources.

@defun x-get-resource attribute class &optional component subclass
The function @code{x-get-resource} retrieves a resource value from the X
Window defaults database.

Resources are indexed by a combination of a @dfn{key} and a @dfn{class}.
This function searches using a key of the form
@samp{@var{instance}.@var{attribute}} (where @var{instance} is the name
under which Emacs was invoked), and using @samp{Emacs.@var{class}} as
the class.

The optional arguments @var{component} and @var{subclass} add to the key
and the class, respectively.  You must specify both of them or neither.
If you specify them, the key is
@samp{@var{instance}.@var{component}.@var{attribute}}, and the class is
@samp{Emacs.@var{class}.@var{subclass}}.
@end defun

@defvar x-resource-class
This variable specifies the application name that @code{x-get-resource}
should look up.  The default value is @code{"Emacs"}.  You can examine X
resources for other application names by binding this
variable to some other string, around a call to @code{x-get-resource}.
@end defvar

@defvar x-resource-name
This variable specifies the instance name that @code{x-get-resource}
should look up.  The default value is the name Emacs was invoked with,
or the value specified with the @samp{-name} or @samp{-rn} switches.
@end defvar

To illustrate some of the above, suppose that you have the line:

@example
xterm.vt100.background: yellow
@end example

@noindent
in your X resources file (whose name is usually @file{~/.Xdefaults}
or @file{~/.Xresources}).  Then:

@example
@group
(let ((x-resource-class "XTerm") (x-resource-name "xterm"))
  (x-get-resource "vt100.background" "VT100.Background"))
     @result{} "yellow"
@end group
@group
(let ((x-resource-class "XTerm") (x-resource-name "xterm"))
  (x-get-resource "background" "VT100" "vt100" "Background"))
     @result{} "yellow"
@end group
@end example

@defvar inhibit-x-resources
If this variable is не-@code{nil}, Emacs does not look up X
resources, and X resources do not have any effect when creating new
frames.
@end defvar

@node Display Feature Testing
@section Display Feature Testing
@cindex display feature testing

  The functions in this section describe the basic capabilities of a
particular display.  Lisp programs can use them to adapt their behavior
to what the display can do.  For example, a program that ordinarily uses
a popup menu could use the minibuffer if popup menus are not supported.

  The optional argument @var{display} in these functions specifies which
display to ask the question about.  It can be a display name, a frame
(which designates the display that frame is on), or @code{nil} (which
refers to the selected frame's display, @pxref{Input Focus}).

  @xref{Color Names}, @ref{Text Terminal Colors}, for other functions to
obtain information about displays.

@defun display-popup-menus-p &optional display
This function returns @code{t} if popup menus are supported on
@var{display}, @code{nil} if not.  Support for popup menus requires
that the mouse be available, since the menu is popped up by clicking
the mouse on some portion of the Emacs display.
@end defun

@defun display-graphic-p &optional display
This function returns @code{t} if @var{display} is a graphic display
capable of displaying several frames and several different fonts at
once.  This is true for displays that use a window system such as X,
and false for text terminals.
@end defun

@defun display-mouse-p &optional display
@cindex mouse, availability
This function returns @code{t} if @var{display} has a mouse available,
@code{nil} if not.
@end defun

@defun display-color-p &optional display
@findex x-display-color-p
This function returns @code{t} if the screen is a color screen.
It used to be called @code{x-display-color-p}, and that name
is still supported as an alias.
@end defun

@defun display-grayscale-p &optional display
This function returns @code{t} if the screen can display shades of gray.
(All color displays can do this.)
@end defun

@defun display-supports-face-attributes-p attributes &optional display
@anchor{Display Face Attribute Testing}
This function returns не-@code{nil} if all the face attributes in
@var{attributes} are supported (@pxref{Face Attributes}).

The definition of ``supported'' is somewhat heuristic, but basically
means that a face containing all the attributes in @var{attributes},
when merged with the default face for display, can be represented in a
way that's

@enumerate
@item
different in appearance than the default face, and

@item
close in spirit to what the attributes specify, if not exact.
@end enumerate

Point (2) implies that a @code{:weight black} attribute will be
satisfied by any display that can display bold, as will
@code{:foreground "yellow"} as long as some yellowish color can be
displayed, but @code{:slant italic} will @emph{not} be satisfied by
the tty display code's automatic substitution of a dim face for
italic.
@end defun

@defun display-selections-p &optional display
This function returns @code{t} if @var{display} supports selections.
Windowed displays normally support selections, but they may also be
supported in some other cases.
@end defun

@defun display-images-p &optional display
This function returns @code{t} if @var{display} can display images.
Windowed displays ought in principle to handle images, but some
systems lack the support for that.  On a display that does not support
images, Emacs cannot display a tool bar.
@end defun

@defun display-screens &optional display
This function returns the number of screens associated with the display.
@end defun

@defun display-pixel-height &optional display
This function returns the height of the screen in pixels.
On a character terminal, it gives the height in characters.

For graphical terminals, note that on multi-monitor setups this
refers to the pixel height for all physical monitors associated with
@var{display}.  @xref{Multiple Terminals}.
@end defun

@defun display-pixel-width &optional display
This function returns the width of the screen in pixels.
On a character terminal, it gives the width in characters.

For graphical terminals, note that on multi-monitor setups this
refers to the pixel width for all physical monitors associated with
@var{display}.  @xref{Multiple Terminals}.
@end defun

@defun display-mm-height &optional display
This function returns the height of the screen in millimeters,
or @code{nil} if Emacs cannot get that information.

For graphical terminals, note that on multi-monitor setups this
refers to the height for all physical monitors associated with
@var{display}.  @xref{Multiple Terminals}.
@end defun

@defun display-mm-width &optional display
This function returns the width of the screen in millimeters,
or @code{nil} if Emacs cannot get that information.

For graphical terminals, note that on multi-monitor setups this
refers to the width for all physical monitors associated with
@var{display}.  @xref{Multiple Terminals}.
@end defun

@defopt display-mm-dimensions-alist
This variable allows the user to specify the dimensions of graphical
displays returned by @code{display-mm-height} and
@code{display-mm-width} in case the system provides incorrect values.
@end defopt

@cindex backing store
@defun display-backing-store &optional display
This function returns the backing store capability of the display.
Backing store means recording the pixels of windows (and parts of
windows) that are not exposed, so that when exposed they can be
displayed very quickly.

Values can be the symbols @code{always}, @code{when-mapped}, or
@code{not-useful}.  The function can also return @code{nil}
when the question is inapplicable to a certain kind of display.
@end defun

@cindex SaveUnder feature
@defun display-save-under &optional display
This function returns не-@code{nil} if the display supports the
SaveUnder feature.  That feature is used by pop-up windows
to save the pixels they obscure, so that they can pop down
quickly.
@end defun

@defun display-planes &optional display
This function returns the number of planes the display supports.
This is typically the number of bits per pixel.
For a tty display, it is log to base two of the number of colors supported.
@end defun

@defun display-visual-class &optional display
This function returns the visual class for the screen.  The value is
one of the symbols @code{static-gray} (a limited, unchangeable number
of grays), @code{gray-scale} (a full range of grays),
@code{static-color} (a limited, unchangeable number of colors),
@code{pseudo-color} (a limited number of colors), @code{true-color} (a
full range of colors), and @code{direct-color} (a full range of
colors).
@end defun

@defun display-color-cells &optional display
This function returns the number of color cells the screen supports.
@end defun

  These functions obtain additional information about the window
system in use where Emacs shows the specified @var{display}.  (Their
names begin with @code{x-} for historical reasons.)

@defun x-server-version &optional display
This function returns the list of version numbers of the GUI window
system running on @var{display}, such as the X server on GNU and Unix
systems.  The value is a list of three integers: the major and minor
version numbers of the protocol, and the distributor-specific release
number of the window system software itself.  On GNU and Unix systems,
these are normally the version of the X protocol and the
distributor-specific release number of the X server software.  On
MS-Windows, this is the version of the Windows OS.
@end defun

@defun x-server-vendor &optional display
This function returns the vendor that provided the window system
software (as a string).  On GNU and Unix systems this really means
whoever distributes the X server.  On MS-Windows this is the vendor ID
string of the Windows OS (Microsoft).

When the developers of X labeled software distributors as
``vendors'', they showed their false assumption that no system could
ever be developed and distributed noncommercially.
@end defun

@ignore
@defvar x-no-window-manager
This variable's value is @code{t} if no X window manager is in use.
@end defvar
@end ignore
