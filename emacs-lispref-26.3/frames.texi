@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2019 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Frames
@chapter Фреймы
@cindex frame

  @dfn{Фрейм} - экранный объект, содержащий одно или несколько окон Emacs
(@pxref{Windows}).  Это объект, который в терминологии графической среды
называется ``окно''; но здесь не получится назвать ``окном'', потому что
Emacs использует это слово для-другого.  В Emacs Lisp @dfn{объект фрейм} -
это объект Lisp, представляющий фрейм на экране.  @xref{Frame Type}.

  Фрейм изначально содержит одно главное окно и/или окно минибуфера; можно
разделить главное окно по вертикали или горизонтали на более мелкие окна.
@xref{Splitting Windows}.

@cindex terminal
  @dfn{Терминал} - это устройство отображения, способное отображать один или
несколько фреймов Emacs.  В Emacs Lisp @dfn{объект терминал} - это объект
Lisp, представляющий терминал.  @xref{Terminal Type}.

@cindex text terminal
@cindex graphical terminal
@cindex graphical display
  Есть два класса терминалов: @dfn{текстовые терминалы} и
@dfn{графические терминалы}.  Текстовые терминалы - это дисплеи без
поддержки графики, включая @command{xterm} и другие эмуляторы терминала.  В
текстовом терминале каждый фрейм Emacs занимает весь экран терминала; хотя
можно создавать дополнительные фреймы и переключаться между ними, терминал
показывает только фрейм за раз.  С другой стороны, графические терминалы
управляются системами графического отображения, такими как X Window System,
которые позволяют Emacs отображать несколько фреймов одновременно на одном и
том же дисплее.

  В системах GNU и Unix можно создавать дополнительные фреймы на любом
доступном терминале в рамках одного сеанса Emacs, независимо от того, был ли
Emacs запущен на текстовом или графическом терминале.  Emacs может
одновременно отображать как на графическом, так и на текстовом терминалах.
Это удобно, например, когда подключаться к одному сеансу из нескольких
удаленных мест.  @xref{Multiple Terminals}.

@defun framep object
Этот предикат возвращает значение не-@code{nil}, если @var{object} является
фреймом, и @code{nil} в противном случае.  Для фрейма значение указывает,
какой вид отображения используется в фрейме:

@table @code
@item t
Фрейм отображается на текстовом терминале.
@item x
Фрейм отображается на графическом терминале X.
@item w32
Фрейм отображается на графическом терминале MS-Windows.
@item ns
Фрейм отображается в графическом терминале GNUstep или Macintosh Cocoa.
@item pc
Фрейм отображается на терминале MS-DOS.
@end table
@end defun

@defun frame-terminal &optional frame
Функция возвращает объект терминала, который отображает @var{frame}.  Если
@var{frame} равен @code{nil} или не указан, по умолчанию используется
выбранный фрейм.
@end defun

@defun terminal-live-p object
Этот предикат возвращает значение не-@code{nil}, если @var{object} - это
активный терминал (то есть не удаленный), и @code{nil} в противном случае.
Для работающих терминалов возвращаемое значение указывает, какие фреймы
отображаются на этом терминале; список возможных значений такой же, как и
для @code{framep} выше.
@end defun

@cindex top-level frame
На графическом терминале различаются два типа фреймов: Обычный
@dfn{фрейм верхнего уровня} - это фрейм, окно оконной системы которого
является дочерним по отношению к корневому окну оконной системы для этого
терминала.  Дочерний фрейм - это фрейм, окно оконной системы которого
является дочерним по отношению к окну оконной системы другого фрейма Emacs.
@xref{Child Frames}.

@menu
* Creating Frames::             Создание дополнительных рамок.
* Multiple Terminals::         Отображение на нескольких разных устройствах.
* Frame Geometry::              Геометрические свойства фреймов.
* Frame Parameters::            Управление размером фрейма, положением,
                                   шрифтом и так далее.
* Terminal Parameters::         Параметры общие для всех фреймов
                                   на терминале.
* Frame Titles::               Автоматическое обновление заголовков фреймов.
* Deleting Frames::             Фреймы сохраняются до тех пор, пока не
                                   будут удалены явным образом.
* Finding All Frames::          Как изучить все существующие фреймы.
* Minibuffers and Frames::      Как фрейм находит используемый минибуфер.
* Input Focus::                 Указание выбранного кадра.
* Visibility of Frames::        Фреймы могут быть видимыми или невидимыми,
                                   а также значками.
* Raising and Lowering::        Подъем, опускание и перестановка фреймов.
* Frame Configurations::        Сохранение состояния всех кадров.
* Child Frames::                Делаем фрейм потомком для другого.
* Mouse Tracking::              Получение событий, которые говорят,
                                   когда движется мышь.
* Mouse Position::              Узнать положение мыши, перемещение мыши.
* Pop-Up Menus::                Отображение меню для выбора пользователем.
* Dialog Boxes::                Отображение поля, чтобы спросить да или нет.
* Pointer Shape::               Указание формы указателя мыши.
* Window System Selections::    Передача текста другим X-клиентам и от них.
* Drag and Drop::               Внутреннее устройство реализации
                                   Drag-and-Drop.
* Color Names::                 Получение определений названий цветов.
* Text Terminal Colors::        Определение цветов для текстовых терминалов.
* Resources::                   Получение значений ресурсов с сервера.
* Display Feature Testing::     Определение возможностей терминала.
@end menu


@node Creating Frames
@section Создание Фреймов
@cindex frame creation

Чтобы создать новый фрейм, вызывается функция @code{make-frame}.

@deffn Command make-frame &optional parameters
Функция создает и возвращает новый фрейм, отображающий текущий буфер.

Аргумент @var{parameters} - это список, который определяет параметры фрейма
для нового фрейма.  @xref{Frame Parameters}.  Если указан параметр
@code{terminal} в @var{parameters}, новый фрейм будет создан на этом
терминале.  В противном случае, если указан параметр фрейма
@code{window-system} в @var{parameters}, определяется, должен ли фрейм
отображаться на текстовом терминале или графическом терминале.
@xref{Window Systems}.  Если ни один из них не указан, новый фрейм создается
в том же терминале, что и выбранный фрейм.

Любые параметры, не упомянутые в @var{parameters}, по умолчанию равны
значениям в alist @code{default-frame-alist} (@pxref{Initial Parameters});
параметры, не указанные там, по умолчанию из ресурсов X или их эквивалента в
вашей операционной системе
(@pxref{X Resources,, X Resources, emacs, The GNU Emacs Manual}).  После
создания фрейма эта функция применяет любые параметры, указанные в
@code{frame-inherited-parameters} (смотреть ниже), которым еще не назначено,
беря значения из фрейма, который был выбран при вызове @code{make-frame}.

Обратить внимание, что на многомониторных дисплеях
(@pxref{Multiple Terminals}) оконный менеджер может позиционировать фрейм
иначе, чем указано в позиционных параметрах в @var{parameters}
(@pxref{Position Parameters}).  Например, у некоторых оконных менеджеров
есть политика отображения фрейма на мониторе, который содержит большую часть
окна (оно же @: монитор @dfn{доминирующий}).

Сама функция не делает новый фрейм выбранным. @xref{Input Focus}.  Ранее
выбранный фрейм остается выбранным.  Однако на графических терминалах
оконная система может выбрать новый фрейм по своим причинам.
@end deffn

@defvar before-make-frame-hook
Обычный обработчик, запускаемый @code{make-frame} перед созданием фрейма.
@end defvar

@defvar after-make-frame-functions
Аномальный перехватчик, запущенный @code{make-frame} после создания фрейма.
Каждая функция в @code{after-make-frame-functions} получает один аргумент -
только что созданный фрейм.
@end defvar

Обратить внимание, что любые функции, добавленные к этим перехватчикам вашим
начальным файлом, обычно не запускаются для начального фрейма, поскольку
Emacs читает начальный файл только после создания этого фрейма.  Однако,
если начальный фрейм задан для использования отдельного фрейма минибуфера
(@pxref{Minibuffers and Frames}), функции будут выполняться как для фрейма
без минибуфера, так и для фрейма минибуфера.

@defvar frame-inherited-parameters
Переменная определяет список параметров фрейма, которые вновь созданный
фрейм наследует от текущего выбранного фрейма.  Для каждого параметра
(символа), который является элементом в этом списке и не был назначен ранее
при обработке @code{make-frame}, функция устанавливает значение этого
параметра в созданном фрейме равным его значению в выбранном фрейме.
@end defvar


@node Multiple Terminals
@section Несколько Терминалов
@cindex multiple terminals
@cindex multi-tty
@cindex multiple X displays
@cindex displays, multiple

  Emacs представляет каждый терминал как тип данных @dfn{объект терминал}
(@pxref{Terminal Type}).  В системах GNU и Unix Emacs может использовать
несколько терминалов одновременно в каждом сеансе.  В других системах может
использовать только один терминал.  Каждый терминальный объект имеет
следующие атрибуты:

@itemize @bullet
@item
Название устройства, используемого терминалом. (такое как, @samp{:0.0} или
@file{/dev/tty}).

@item
Системы кодирования терминала и клавиатуры, используемые на терминале.
@xref{Terminal I/O Encoding}.

@item
Вид дисплея, связанный с терминалом.  Это символ, возвращаемый функцией
@code{terminal-live-p} (такое как, @code{x}, @code{t}, @code{w32},
@code{ns}, или @code{pc}).  @xref{Frames}.

@item
Список параметров терминала.  @xref{Terminal Parameters}.
@end itemize

  Примитива для создания терминальных объектов нет.  Emacs создает их по
мере необходимости, например, когда вызывается @code{make-frame-on-display}
(описано ниже).

@defun terminal-name &optional terminal
Функция возвращает имя файла устройства, используемого @var{terminal}.  Если
@var{terminal} опущен или @code{nil}, по умолчанию используется терминал
выбранного фрейма.  @var{terminal} также может быть фреймом, что означает
его терминал.
@end defun

@defun terminal-list
Функция возвращает список всех активных терминальных объектов.
@end defun

@defun get-device-terminal device
Функция возвращает терминал, имя устройства которого задано @var{device}.
Если @var{device} - строка, это может быть либо имя файла терминального
устройства, либо имя X-дисплея в форме
@samp{@var{host}:@var{server}.@var{screen}}.  Если @var{device} - это фрейм,
функция возвращает терминал этого фрейма; @code{nil} означает выбранный
фрейм.  Наконец, если @var{device} - это объект терминала, представляющий
работающий терминал, этот терминал возвращается.  Функция сигнализирует об
ошибке, если ее аргумент не соответствует ни одному из вышеперечисленных.
@end defun

@defun delete-terminal &optional terminal force
Функция удаляет все фреймы на @var{terminal} и освобождает используемые им
ресурсы.  Запускает ненормальную ловушку @code{delete-terminal-functions},
передавая @var{terminal} в качестве аргумента каждой функции.

Если @var{terminal} опущен или @code{nil}, по умолчанию используется
терминал выбранного фрейма.  @var{terminal} также может быть фреймом, что
означает его терминал.

Обычно функция сигнализирует об ошибке, если попытаться удалить единственный
активный терминал, но если @var{force} - не-@code{nil}, это можно сделать.
Emacs автоматически вызывает эту функцию, когда последний фрейм на терминале
удаляется (@pxref{Deleting Frames}).
@end defun

@defvar delete-terminal-functions
Ненормальная ловушка, запускаемая @code{delete-terminal}.  Каждая функция
получает один аргумент, аргумент @var{terminal} передается в
@code{delete-terminal}.  По техническим причинам функции могут вызываться
либо непосредственно перед удалением терминала, либо сразу после него.
@end defvar

@cindex terminal-local variables
  Несколько переменных Lisp: @dfn{terminal-local}; то есть у них есть
отдельная привязка для каждого терминала.  В любой момент действует привязка
для терминала, которому принадлежит текущий выбранный фрейм.  Эти переменные
включают @code{default-minibuffer-frame}, @code{defining-kbd-macro},
@code{last-kbd-macro} и @code{system-key-alist}.  Они всегда локальны для
терминала и никогда не могут быть локальными для буфера
(@pxref{Buffer-Local Variables}).

  В системах GNU и Unix каждый дисплей X представляет собой отдельный
графический терминал.  Когда Emacs запускается из оконной системы X, он
использует отображение X, заданное переменной среды @env{DISPLAY} или
параметром @samp{--display}
(@pxref{Initial Options,,, emacs, The GNU Emacs Manual}).  Emacs может
подключаться к другим дисплеям X с помощью команды
@code{make-frame-on-display}.  Каждый X-дисплей имеет свой собственный
выбранный фрейм и свои собственные окна минибуфера; однако только один из
этих фреймов является @emph{по настоящему} выбранным фреймом в любой момент
(@pxref{Input Focus}).  Emacs может даже подключаться к другим текстовым
терминалам, взаимодействуя с программой @command{emacsclient}.
@xref{Emacs Server,,, emacs, The GNU Emacs Manual}.

@cindex X display names
@cindex display name on X
  Один X-сервер может обрабатывать более одного дисплея.  Каждый дисплей X
имеет имя, состоящее из трех частей,
@samp{@var{hostname}:@var{displaynumber}.@var{screennumber}}.  Первая часть,
@var{hostname}, определяет имя машины, к которой физически подключен
дисплей.  Вторая часть, @var{displaynumber}, представляет собой
отсчитываемое от нуля число, которое идентифицирует один или несколько
мониторов, подключенных к этому компьютеру, которые имеют общую клавиатуру и
указывающее устройство (мышь, планшет и так далее).  Третья часть,
@var{screennumber}, определяет отсчитываемый от нуля номер экрана (отдельный
монитор), который является частью одной коллекции мониторов на этом
X-сервере.  Когда используется два или более экрана, принадлежащих одному
серверу, Emacs знает по схожести их имен, что они используют одну
ключевую карту.

  Системы, которые не используют систему X Window, такие как MS-Windows, не
поддерживают понятие X-дисплеев и имеют только один дисплей на каждом хосте.
Отображаемое имя в этих системах не соответствует указанному выше формату из
трех частей; например, отображаемое имя в системах MS-Windows представляет
собой постоянную строку @samp{w32} и существует для совместимости, чтобы
иметь возможность передавать ее функциям, ожидающим отображаемое имя.

@deffn Command make-frame-on-display display &optional parameters
Функция создает и возвращает новый фрейм на @var{display}, беря другие
параметры фрейма из alist @var{parameters}.  @var{display} должно быть
именем X-дисплея (строка).

Перед созданием фрейма эта функция гарантирует, что Emacs настроен для
отображения графики.  Например, если Emacs не обработал X-ресурсы (например,
если он был запущен на текстовом терминале), он делает это в это время.  В
остальном эта функция ведет себя как @code{make-frame}
(@pxref{Creating Frames}).
@end deffn

@defun x-display-list
Функция возвращает список, указывающий, к какому отображению X имеет
соединение Emacs.  Элементы списка представляют собой строки, и каждый из
них является отображаемым именем.
@end defun

@defun x-open-connection display &optional xrm-string must-succeed
Функция открывает соединение с X-дисплеем @var{display} без создания фрейма
на этом дисплее.  Обычно программы Emacs Lisp не нуждаются в вызове этой
функции, поскольку @code{make-frame-on-display} вызывает ее автоматически.
Единственная причина для его вызова - проверить, можно ли установить связь
с данным дисплеем X.

Необязательный аргумент @var{xrm-string}, если не @code{nil}, представляет
собой строку имен и значений ресурсов в том же формате, что и в файле
@file{.Xresources}.
@xref{X Resources,, X Resources, emacs, The GNU Emacs Manual}. Эти значения
применяются ко всем фреймам Emacs, созданным на этом дисплее, перекрывая
значения ресурсов, записанные на X-сервере.  Вот пример того, как может
выглядеть эта строка:

@example
"*BorderWidth: 3\n*InternalBorder: 2\n"
@end example

Если @var{must-succeed} равен не-@code{nil}, то при отказе от открытия
соединения Emacs завершается.  В противном случае это обычная ошибка Lisp.
@end defun

@defun x-close-connection display
Функция закрывает соединение для отображения @var{display}.  Прежде чем
можно это сделать, потребуется сначала удалить все фреймы, которые были
открыты на этом дисплее (@pxref{Deleting Frames}).
@end defun

@cindex multi-monitor
  В некоторых конфигурациях с несколькими мониторами один X-дисплей
выводится на несколько физических мониторов.  Можно использовать функции
@code{display-monitor-attributes-list} и @code{frame-monitor-attributes} для
получения информации о таких настройках.

@defun display-monitor-attributes-list &optional display
Функция возвращает список атрибутов физического монитора на @var{display},
который может быть отображаемым именем (строкой), терминалом или фреймом;
если опущено или @code{nil}, по умолчанию используется отображение
выбранного фрейма.  Каждый элемент списка представляет собой список
ассоциаций, представляющий атрибуты физического монитора.  Первый элемент
соответствует основному монитору.  Ключи и значения атрибутов::

@table @samp
@item geometry
Положение левого верхнего угла экрана монитора и его размер в пикселях как
@samp{(@var{x} @var{y} @var{width} @var{height})}.  Обратить внимание: если
монитор не является основным, некоторые координаты могут быть
отрицательными.

@item workarea
Положение левого верхнего угла и размер рабочей области (полезного
пространства) в пикселях формируется как
@samp{(@var{x} @var{y} @var{width} @var{height})}.  Это может отличаться от
@samp{geometry} тем, что пространство занято различными функциями оконного
менеджера (доки, панели задач и так далее)@: и может быть исключено из
рабочей зоны.  То, действительно ли такие функции удаляются из рабочей
области, зависит от платформы и среды.  Опять же, если монитор не является
основным монитором, некоторые координаты могут быть отрицательными.

@item mm-size
Ширина и высота в миллиметрах как @samp{(@var{width} @var{height})}

@item frames
Список фреймов, доминирующих на этом физическом мониторе (смотреть ниже).

@item name
Имя физического монитора @var{string}.

@item source
Источник мультимониторной информации как @var{string}; например,
@samp{XRandr} или @samp{Xinerama}.
@end table

@var{x}, @var{y}, @var{width} и @var{height} целые числа.
@samp{name} и @samp{source} могут отсутствовать.

Фрейм становится @dfn{доминирующим} на физическом мониторе, когда либо самая
большая область фрема находится на этом мониторе, либо (если кадр не
пересекает никакие физические мониторы) этот монитор является ближайшим к
фрейму.  В каждом (не всплывающем) фрейме (видимом или невидимом) на
графическом дисплее доминирует ровно один физический монитор за раз, хотя
фрейм может охватывать несколько (или ни одного) физических мониторов.

Вот пример данных, созданных этой функцией на дисплее с двумя мониторами:

@lisp
  (display-monitor-attributes-list)
  @result{}
  (((geometry 0 0 1920 1080) ;; @r{Левая основная панель задач monitor}
    (workarea 0 0 1920 1050) ;; @r{занимает часть высоты}
    (mm-size 677 381)
    (name . "DISPLAY1")
    (frames #<frame emacs@@host *Messages* 0x11578c0>
            #<frame emacs@@host *scratch* 0x114b838>))
   ((geometry 1920 0 1680 1050) ;; @r{Правый монитор }
    (workarea 1920 0 1680 1050) ;; @r{можно использовать весь экран}
    (mm-size 593 370)
    (name . "DISPLAY2")
    (frames)))
@end lisp

@end defun

@defun frame-monitor-attributes &optional frame
Функция возвращает атрибуты доминирующего физического монитора (смотреть
выше) @var{frame}, который по умолчанию соответствует выбранному фрейму.
@end defun


@node Frame Geometry
@section Геометрия Фрейма
@cindex frame geometry
@cindex frame position
@cindex position of frame
@cindex frame size
@cindex size of frame

Геометрия фрейма зависит от набора инструментов, который использовался для
создания этого экземпляра Emacs, и терминала, отображающего фрейм.  В этой
главе описаны эти зависимости и некоторые функции для их устранения.
Обратить внимание, что аргумент @var{frame} всех этих функций должен
указывать активный фрейм (@pxref{Deleting Frames}).  Если опущено или
@code{nil}, указывается выбранный фрейм (@pxref{Input Focus}).

@menu
* Frame Layout::            Базовая компоновка фреймов.
* Frame Font::              Шрифт фрейма по умолчанию и как его установить.
* Frame Position::          Положение фрейма на его дисплее.
* Frame Size::              Определение и получение размера фрейма.
* Implied Frame Resizing::  Подразумевается изменение размера фреймов и
                               как этого избежать.
@end menu


@node Frame Layout
@subsection Макет Фрейма
@cindex frame layout
@cindex layout of frame

Видимая фрейм занимает прямоугольную область на дисплее терминала.  Эта
область может содержать несколько вложенных прямоугольников, каждый из
которых служит своей цели.  На приведенном ниже рисунке схематично показано
расположение фрейма на графическом терминале.:
@smallexample
@group

        <------------ Outer Frame Width ----------->
        ____________________________________________
     ^(0)  ________ External/Outer Border _______   |
     | |  |_____________ Title Bar ______________|  |
     | | (1)_____________ Menu Bar ______________|  | ^
     | | (2)_____________ Tool Bar ______________|  | ^
     | | (3) _________ Internal Border ________  |  | ^
     | |  | |   ^                              | |  | |
     | |  | |   |                              | |  | |
Outer  |  | | Inner                            | |  | Native
Frame  |  | | Frame                            | |  | Frame
Height |  | | Height                           | |  | Height
     | |  | |   |                              | |  | |
     | |  | |<--+--- Inner Frame Width ------->| |  | |
     | |  | |   |                              | |  | |
     | |  | |___v______________________________| |  | |
     | |  |___________ Internal Border __________|  | v
     v |___________ External/Outer Border __________|
           <-------- Native Frame Width -------->

@end group
@end smallexample

На практике не все области, показанные на чертеже, будут или могут
присутствовать.  Значение этих областей описано ниже.

@table @asis
@item Outer Frame
@cindex outer frame
@cindex outer edges
@cindex outer width
@cindex outer height
@cindex outer size
@dfn{outer frame} - это прямоугольник, включающий все области, показанные на
чертеже.  Края этого прямоугольника называются @dfn{outer edges} фрейма.
Вместе @dfn{outer width} и @dfn{outer height} фрейма задают @dfn{outer size}
этого прямоугольника.

Знание внешнего размера фрейма полезно для размещения фрейма в рабочей
области его дисплея (@pxref{Multiple Terminals}) или для размещения двух
фреймов рядом друг с другом на экране.  Обычно внешний размер фрейма
доступен только после того, как фрейм был отображен (сделан видимым,
@pxref{Visibility of Frames}) хотя бы один раз.  Для начального фрейма или
фрейма, который еще не был создан, внешний размер может быть только оценен
или должен быть вычисляется из значений по умолчанию оконной системы или
оконного менеджера.  Один обходной путь состоит в том, чтобы получить
различия внешнего и собственного (смотреть ниже) размеров отображаемого
фрейма и использовать их для вычисления внешнего размера нового фрейма.

@cindex outer position
Положение верхнего левого угла внешнего фрейма (обозначено @samp{(0)} на
рисунке выше) - это @dfn{outer position} фрейма.  Внешнее положение
графического фрейма также называется ``позиция'' фрейма, потому что оно
обычно остается неизменным на его дисплее всякий раз, когда изменяется
размер фрейма или изменяется его макет.

Внешняя позиция определяется и может быть установлена через параметры фрейма
@code{left} и @code{top} (@pxref{Position Parameters}).  Для обычного фрейма
верхнего уровня эти параметры обычно представляют его абсолютное положение
(смотреть ниже) по отношению к исходной точке его отображения.  Для
дочернего фрейма (@pxref{Child Frames}) эти параметры представляют его
положение относительно исходного положения (смотреть ниже) его родительского
фрейма.  Для фреймов на текстовых терминалах значения этих параметров
бессмысленны и всегда равны нулю.

@item External Border
@cindex external border
@dfn{external border} - это часть декораций, предоставляемых оконным
менеджером.  Обычно используется для изменения размера фрейма с помощью мыши
и поэтому не отображается в ``fullboth'' и максимальных параметрах фрейма
(@pxref{Size Parameters}).  Его ширина определяется оконным менеджером и не
может быть изменена функциями Emacs.

На фреймах текстового терминала отсутствуют внешние границы.  Для
графических фреймов их отображение можно запретить, установив параметр
фрейма @code{override-redirect} или @code{undecorated}
(@pxref{Management Parameters}).

@item Outer Border
@cindex outer border
@dfn{outer border} - это отдельный фрейм рамка, ширину которого можно
указать с помощью параметра фрейма @code{border-width}
(@pxref{Layout Parameters}).  На практике отображается либо внешняя, либо
внешняя граница фрейма, но никогда обе одновременно.  Обычно внешняя граница
отображается только для специальных фреймов, которые не (полностью)
контролируются оконным менеджером, например фреймы всплывающих подсказок
(@pxref{Tooltips}), дочерние фреймы (@pxref{Child Frames}) и
@code{undecorated} или @code{override-redirect} фреймы
(@pxref{Management Parameters}).

Внешние границы никогда не отображаются на фреймах текстового терминала и
фреймах, сгенерированных подпрограммами GTK+.  В MS-Windows внешняя граница
эмулируется с помощью внешней границы шириной в один пиксель.
Не-инструментальные сборки на X позволяют изменять цвет внешней границы,
задав параметр фрейма @code{border-color} (@pxref{Layout Parameters}).

@item Title Bar
@cindex title bar
@cindex caption bar
@dfn{title bar}, он же @dfn{caption bar}, также является частью декораций
оконного менеджера и обычно отображает заголовок фрейма
(@pxref{Frame Titles}), а также кнопки для минимизации, развертывания и
удаления фрейма.  Его также можно использовать для перетаскивания фрейма
мышью.  Строка заголовка обычно не отображается для всех фреймов
(@pxref{Size Parameters}), всплывающих подсказок (@pxref{Tooltips}) и
дочерних фреймов (@pxref{Child Frames}) и не существует для оконечных
фреймов.  Отображение строки заголовка можно отключить, задав параметры
фрейма @code{override-redirect} или @code{undecorated}
(@pxref{Management Parameters}).

@item Menu Bar
@cindex internal menu bar
@cindex external menu bar
Строка меню (@pxref{Menu Bar}) может быть внутренней (нарисованной самим
Emacs) или внешней (нарисованной набором инструментов).  Большинство сборок
(GTK+, Lucid, Motif и MS-Windows) полагаются на внешнюю строку меню.  NS
также использует внешнюю строку меню, которая, однако, не является частью
внешнего фрейма.  Сборки без инструментов могут содержать внутреннюю строку
меню.  В фреймах текстового терминала строка меню является частью корневого
окна фрейма (@pxref{Windows and Frames}).  Как правило, в дочерних фреймах
(@pxref{Child Frames}) строки меню никогда не отображаются.  Отображение
строки меню можно отключить, установив параметр @code{menu-bar-lines}
(@pxref{Layout Parameters}) равным нулю.

Будет ли строка меню обернута или усечена, когда ее ширина становится
слишком большой, чтобы поместиться в ее фрейм, зависит от набора
инструментов.  Обычно только сборки Motif и MS-Windows могут обернуть строку
меню.  Когда они (отменяют) обёртывают строки меню, стараются сохранить
внешнюю высоту фрейма неизменной, поэтому вместо этого изменится собственная
высота фрейма (смотреть ниже).

@item Tool Bar
@cindex internal tool bar
@cindex external tool bar
Как и строка меню, панель инструментов (@pxref{Tool Bar}) может быть
внутренней (нарисованная самим Emacs) или внешней (нарисованная набором
инструментов).  В сборках GTK + и NS панель инструментов нарисована набором
инструментов.  В остальных сборках используются внутренние панели
инструментов.  С GTK+ панель инструментов может быть расположена с любой
стороны фрейма, сразу за внутренней границей, смотреть ниже.  Панели
инструментов обычно не отображаются для дочерних фреймов
(@pxref{Child Frames}).  Отображение панели инструментов можно отключить,
установив параметр @code{tool-bar-lines} (@pxref{Layout Parameters}) равным
нулю.

Если переменная @code{auto-resize-tool-bars} равна не-@code{nil}, Emacs
оборачивает внутреннюю панель инструментов, когда ее ширина становится
слишком большой для ее фрейма.  Если и когда Emacs (отменяет-) обертывает
внутреннюю панель инструментов, по умолчанию сохраняет внешнюю высоту фрейма
неизменной, поэтому вместо этого изменится собственная высота фрейма
(смотреть ниже). Emacs, созданный с помощью GTK +, с другой стороны, никогда
не оборачивает панель инструментов, но может автоматически увеличивать
внешнюю ширину фрейма, чтобы приспособить слишком длинную панель
инструментов.

@item Native Frame
@cindex native frame
@cindex native edges
@cindex native width
@cindex native height
@cindex native size
@dfn{native frame} - это прямоугольник, полностью расположенный внутри
внешнего фрейма.  Он исключает области, занятые внешней границей, строкой
заголовка и любым внешним меню или панелью инструментов.  Края родного
фрейма называются @dfn{native edges} фрейма.  Вместе @dfn{native width} и
@dfn{native height} фрейма определяют @dfn{native size} фрейма.

Собственный размер фрейма - это размер, который Emacs передает оконной
системе или оконному менеджеру при создании или изменении размера фрейма из
Emacs.  Это также размер, который Emacs получает от оконной системы или
оконного менеджера всякий раз, когда они изменяют размер окна оконной
системы фрейма, например, после максимизации фрейма путем нажатия
соответствующей кнопки в строке заголовка или при перетаскивании его внешней
границы мышью.

@cindex native position
Положение верхнего левого угла собственного фрейма определяет
@dfn{native position} фрейма.  (1) - (3) на рисунке выше указывают, что
положение для различных сборок:

@itemize @w{}
@item (1) не-toolkit и терминальные фреймы

@item (2) Lucid, Motif и MS-Windows фреймы

@item (3) GTK+ и NS фреймы
@end itemize

Соответственно, собственная высота фрейма может включать высоту панели
инструментов, но не высоту строки меню (Lucid, Motif, MS-Windows) или высоту
строки меню и панели инструментов (фреймы без инструментов и текстовые
терминалы).

Собственная позиция фрейма - это опорная позиция для функций, которые
устанавливают или возвращают текущую позицию мыши (@pxref{Mouse Position}),
а также для функций, работающих с положением окон, таких как
@code{window-edges}, @code{window-at} или @code{coordinates-in-window-p}
(@pxref{Coordinates and Windows}).  Также определяет (0, 0) источник для
поиска и позиционирования дочерних фреймов внутри этого фрейма
(@pxref{Child Frames}).

Также обратить внимание, что исходное положение фрейма обычно остается
неизменным на его дисплее при удалении или добавлении декораций оконного
менеджера путем изменения параметра фрейма @code{override-redirect} или
@code{undecorated} (@pxref{Management Parameters}).

@item Internal Border
Внутренняя граница - это граница, нарисованная Emacs вокруг внутреннего
фрейма (смотреть ниже).  Её ширина задается параметром фрейма
@code{internal-border-width} (@pxref{Layout Parameters}).  Её цвет
определяется фоном фрейма @code{internal-border}.

@item Inner Frame
@cindex inner frame
@cindex inner edges
@cindex inner width
@cindex inner height
@cindex inner size
@cindex display area
@dfn{inner frame} - это прямоугольник, зарезервированный для окон фрейма.
Заключен во внутренний фрейм, который, однако, не является частью
внутреннего фрейма.  Его края называются @dfn{inner edges} фрейма.
@dfn{inner width} и @dfn{inner height} указывают @dfn{inner size}
прямоугольника.  Внутренний фрейм иногда также называют @dfn{display area}
фрейма.

@cindex minibuffer-less frame
@cindex minibuffer-only frame
Как правило, внутренний фрейм подразделяется на корневое окно фрейма
(@pxref{Windows and Frames}) и окно минибуфера фрейма
(@pxref{Minibuffer Windows}).  Из этого правила есть два заметных
исключения: @dfn{minibuffer-less frame} содержит только корневое окно и не
содержит окно минибуфера.  @dfn{minibuffer-only frame} содержит только окно
минибуфера, которое также служит корневым окном этого фрейма.
@ref{Initial Parameters} о том, как создавать такие конфигурации фреймов.

@item Text Area
@cindex text area
@dfn{text area} фрейма - это несколько вымышленная область, которая может
быть встроена в исходный фрейм.  Её положение не указано.  Её ширину можно
получить, удалив из исходной ширины ширину внутренней границы, одной
вертикальной полосы прокрутки, а также одной левой и одной правой кромок,
если они указаны для этого фрейма, @ref{Layout Parameters}.  Её высоту можно
получить, удалив из исходной высоты ширину внутренней границы и высоту
внутреннего меню и панелей инструментов фрейма, а также одну горизонтальную
полосу прокрутки, если она указана для этого фрейма.
@end table

@cindex absolute position
@cindex absolute frame position
@cindex absolute edges
@cindex absolute frame edges
@cindex display origin
@cindex origin of display
@dfn{absolute position} кадра задается как пара (X, Y) горизонтальных и
вертикальных смещений пикселей относительно исходной точки (0, 0)
отображения фрейма.  Соответственно, @dfn{absolute edges} фрейма задаются
как пиксельные смещения от этого источника.

  Обратить внимание, что при использовании нескольких мониторов исходная
точка дисплея не обязательно совпадает с верхним левым углом всей
используемой области отображения терминала.  Следовательно, абсолютное
положение фрейма может быть отрицательным в такой среде, даже когда этот
фрейм полностью виден.

  По соглашению вертикальные смещения увеличивают ``downwards''.  Это
означает, что высота фрейма получается вычитанием смещения его верхнего края
из смещения его нижнего края.  Горизонтальные смещения увеличивают
``rightwards'', как и ожидалось, поэтому ширина фрейма рассчитывается путем
вычитания смещения его левого края из смещения его правого края.

  Для фрейма на графическом терминале следующая функция возвращает размеры
описанных выше областей.:

@defun frame-geometry &optional frame
Функция возвращает геометрические атрибуты @var{frame}.  Возвращаемое
значение - это список ассоциаций атрибутов, перечисленных ниже.  Все
значения координат, высоты и ширины являются целыми числами, считая пиксели.
Обратить внимание, что если @var{frame} еще не отображен,
(@pxref{Visibility of Frames}) некоторые из возвращаемых значений могут
представлять только приближения фактических значений - тех, которые можно
увидеть после отображения фрейма.

@table @code
@item outer-position
Cons-ячейка, представляющая абсолютную позицию внешнего @var{frame}
относительно начала координат в позиции (0, 0) отображения @var{frame}.

@item outer-size
Cons-ячейка внешней ширины и высоты @var{frame}.

@item external-border-size
Cons-ячейка горизонтальной и вертикальной ширины внешних границ @var{frame},
предоставляемых оконным менеджером.  Если оконный менеджер не предоставляет
эти значения, Emacs попытается угадать их по координатам внешнего и
внутреннего фрейма.

@item outer-border-width
Ширина внешней границы @var{frame}.  Значение имеет смысл только для сборок,
не относящихся к GTK+ и X.

@item title-bar-size
Cons-ячейки ширины и высоты строки заголовка @var{frame}, предоставляемые
оконным менеджером или операционной системой.  Если обе они равны нулю, у
фрейма нет строки заголовка.  Если только ширина равна нулю, Emacs не смог
получить информацию о ширине.

@item menu-bar-external
Если не-@code{nil}, это означает, что строка меню является внешней (не
является частью собственного фрейма @var{frame}).

@item menu-bar-size
Cons-ячейки ширины и высоты строки меню @var{frame}.

@item tool-bar-external
Если не-@code{nil}, это означает, что панель инструментов является внешней
(не является частью собственного фрейма @var{frame}).

@item tool-bar-position
Говорит о том, с какой стороны находится панель инструментов на @var{frame},
и может быть одним из @code{left}, @code{top}, @code{right} или
@code{bottom}.  Единственный инструментарий, который в настоящее время
поддерживает значение, отличное от @code{top} - это GTK+.

@item tool-bar-size
Cons-чейки ширины и высоты панели инструментов @var{frame}.

@item internal-border-width
Ширина внутренней границы @var{frame}.
@end table
@end defun

Следующая функция может использоваться для получения краев внешнего и
внутреннего фреймов.

@defun frame-edges &optional frame type
Функция возвращает абсолютные границы внешнего, собственного или внутреннего
фрейма @var{frame}.  @var{frame} должен быть активным фреймом и по умолчанию
быть выбранным.  Возвращенный список имеет вид
@w{@code{(@var{left} @var{top} @var{right} @var{bottom})}}, где все значения
указаны в пикселях относительно исходной точки отображения @var{frame}.  Для
терминальных фреймов значения, возвращаемые для @var{left} и @var{top},
всегда равны нулю.

Необязательный аргумент @var{type} указывает тип возвращаемых краёв:
@code{outer-edges} означает возвращать внешние края @var{frame},
@code{native-edges} (или @code{nil}) означает возвращать собственные края,
а @code{inner-edges} означает возвращать внутренние края.

По соглашению пиксели дисплея при значениях, возвращаемых для @var{left} и
@var{top}, считаются находящимися внутри (частью) @var{frame}.
Следовательно, если оба @var{left} и @var{top} равны нулю, пиксель в
исходной точке дисплея является частью @var{frame}.  С другой стороны,
пиксели в @var{bottom} и @var{right} считаются лежащими непосредственно за
пределами @var{frame}.  Это означает, что если есть, например, два соседних
фрейма, расположенных так, что правый внешний край фрейма слева равен левому
внешнему краю фрейма справа, пиксели на этом краю показывают часть фрейма
справа.
@end defun


@node Frame Font
@subsection Шрифт Фрейма
@cindex default font
@cindex default character size
@cindex default character width
@cindex default width of character
@cindex default character height
@cindex default height of character
У каждого фрейма есть @dfn{шрифт по умолчанию}, который определяет размер
символа по умолчанию для этого фрейма.  Этот размер подразумевается при
извлечении или изменении размера фрейма с точки зрения столбцов или строк
(@pxref{Size Parameters}).  Также используется при изменении размера
(@pxref{Window Sizes}) или разделении (@pxref{Splitting Windows}) окна.

@cindex line height
@cindex column width
@cindex canonical character height
@cindex canonical character width
Иногда вместо ``высота символа по умолчанию'' используются термины
@dfn{высота линии} и @dfn{каноническая высота символа}.  Точно так же
термины @dfn{ширина колонки} и @dfn{каноническая ширина символа}
используются вместо ``ширина символа по умолчанию''.

@defun frame-char-height &optional frame
@defunx frame-char-width &optional frame
Функции возвращают высоту и ширину символа в @var{frame} по умолчанию,
измеренную в пикселях.  Вместе эти значения определяют размер шрифта по
умолчанию на @var{frame}.  Значения зависят от выбора шрифта для
@var{frame}, смотреть @ref{Font and Color Parameters}.
@end defun

Шрифт по умолчанию также можно установить напрямую с помощью следующей
функции:

@deffn Command set-frame-font font &optional keep-size frames
Устанавливает шрифт по умолчанию @var{font}.  При интерактивном вызове
запрашивает имя шрифта и использует этот шрифт в выбранном фрейме.  При
вызове из Lisp @var{font} должен быть именем шрифта (строка), объектом
шрифта, сущностью шрифта или спецификацией шрифта.

Если необязательный аргумент @var{keep-size} - @code{nil}, сохраняется
количество строк и столбцов фрейма фиксированным.  (Если не-@code{nil},
параметр @code{frame-inhibit-implied-resize}, описанный в следующем разделе,
переопределит это.)  Если @var{keep-size} равен не-@code{nil} (или с
аргументом префикса), пытается сохраниться размер области отображения
текущего фрейма фиксированным, регулируя количество строк и столбцы.

Если необязательный аргумент @var{frames} - @code{nil}, шрифт применяется
только к выбранному фрейму.  Если @var{frames} - это не-@code{nil}, это
должен быть список фреймов, над которыми нужно действовать, или @code{t},
означающий все существующие и все будущие графические фреймы.
@end deffn


@node Frame Position
@subsection Положение Фрейма
@cindex frame position
@cindex position of frame

В графических системах положение нормального фрейма верхнего уровня
определяется как абсолютное положение его внешнего фрейма
(@pxref{Frame Geometry}).  Положение дочернего фрейма (@pxref{Child Frames})
задается через пиксельные смещения его внешних краев относительно исходного
положения его родительского кадра.

  Можно получить доступ или изменить положение фрейма, используя параметры
фрейма @code{left} и @code{top} (@pxref{Position Parameters}).  Вот две
дополнительные функции для работы с позициями существующего видимого фрейма.
Для обеих функций аргумент @var{frame} должен обозначать активный фрейм и
по умолчанию использовать выбранный фрейм.

@defun frame-position &optional frame
Для нормального, не дочернего фрейма эта функция возвращает cons-координаты
пиксельных координат его внешнего положения (@pxref{Frame Layout})
относительно исходной точки @code{(0, 0)} его отображения.  Для дочернего
фрейма (@pxref{Child Frames}) эта функция возвращает пиксельные координаты
его внешней позиции относительно исходной точки @code{(0, 0)} в исходной
позиции родительского фрейма @var{frame}.

Отрицательные значения никогда не указывают на смещение от правого или
нижнего края дисплея @var{frame} или родительского фрейма.  Скорее, они
означают, что внешняя позиция @var{frame} находится слева и/или над исходной
точкой его отображения или исходной позицией его родительского фрейма.
Обычно это означает, что @var{frame} виден только частично (или полностью не
видим).  Однако в системах, где исходная точка дисплея не совпадает с его
верхним левым углом, рамка может быть видна на дополнительном мониторе.

В фрейме текстового терминала оба значения равны нулю.
@end defun

@defun set-frame-position frame x y
Функция устанавливает внешнюю позицию фрейма @var{frame} на (@var{x},
@var{y}).  Последние аргументы определяют пиксели и обычно отсчитывают от
начала координат в позиции (0, 0) дисплея @var{frame}.  Для дочерних фреймов
они отсчитываются от исходной позиции родительского фрейма @var{frame}.

Отрицательные значения параметров позиционируют правый край внешнего фрейма
на @var{-x} пикселей слева от правого края экрана (или собственного
прямоугольника родительского фрейма), а нижний край на @var{-y} пикселей
вверх от нижнего края экрана (или родительского фрейма) родного
прямоугольника.

Обратить внимание, что отрицательные значения не позволяют выровнять правый
или нижний край @var{frame} точно по правому или нижнему краю его дисплея
или родительского фрейма.  Также не позволяют указать позицию, которая не
находится в пределах краев дисплея или родительского фрейма.  Параметры
фрейма @code{left} и @code{top} (@pxref{Position Parameters}) позволяют это
сделать, но все же могут не дать хороших результатов для исходного или
нового фрейма.

Функция не влияет на фреймы текстового терминала.
@end defun

@defvar move-frame-functions
@cindex frame position changes, a hook
Этот перехватчик определяет функции, которые запускаются, когда фрейм Emacs
перемещается (ему назначается новая позиция) оконной системой или оконным
менеджером.  Функции запускаются с одним аргументом - перемещенным фреймом.
Для дочернего фрейма (@pxref{Child Frames}) функции запускаются только
тогда, когда положение фрейма изменяется по отношению к положению его
родительского фрейма.
@end defvar


@node Frame Size
@subsection Размер Фрейма
@cindex frame size
@cindex text width of a frame
@cindex text height of a frame
@cindex text size of a frame
Канонический способ указать @dfn{размер фрейма} из Emacs - это указать его
@dfn{размер текста} --- кортеж ширины и высоты текстовой области
(@pxref{Frame Layout}) фрейма.  Его можно измерить либо в пикселях, либо в
единицах канонического размера символа фрейма (@pxref{Frame Font}).

  Для фреймов с внутренним меню или панелью инструментов нельзя точно
определить собственную высоту фрейма до того, как фрейм будет фактически
нарисован.  Это означает, что, как правило, не получиться использовать
собственный размер для указания начального размера фрейми.  Как только
узнать собственный размер видимого фрейма, можно вычислить его внешний
размер (@pxref{Frame Layout}), добавив оставшиеся компоненты из
возвращаемого значения @code{frame-geometry}.  Однако для невидимых фреймов
или фреймов, которые еще предстоит создать, внешний размер можно только
оценить.  Это также означает, что вычисление точного начального положения
фрейма, указанного с помощью смещений от правого или нижнего края экрана
(@pxref{Frame Position}), невозможно.

  Размер текста любого фрейма можно установить и получить с помощью
параметров фрейма @code{height} и @code{width} (@pxref{Size Parameters}).
Размер текста исходного фрейма также можно установить с помощью спецификации
геометрии X-стиля.  @xref{Emacs Invocation,, Command Line Arguments for Emacs Invocation, emacs, The GNU Emacs Manual}.  Ниже перечислены некоторые
функции для доступа и устанавки размера существующего видимого фрейма, по
умолчанию выбранной.

@defun frame-height &optional frame
@defunx frame-width &optional frame
Функции возвращают высоту и ширину текстовой области @var{frame}, измеренные
в единицах высоты шрифта по умолчанию и ширины @var{frame}
(@pxref{Frame Font}).  Эти функции представляют собой простые сокращения для
записи @code{(frame-parameter frame 'height)} и
@code{(frame-parameter frame 'width)}.

Если текстовая область @var{frame}, измеренная в пикселях, не кратна размеру
шрифта по умолчанию, значения, возвращаемые этими функциями, округляются в
меньшую сторону до количества символов шрифта по умолчанию, которые
полностью помещаются в текстовую область.
@end defun

Следующие далее функции возвращают ширину и высоту в пикселях собственного,
внешнего и внутреннего фрейма и текстовой области (@pxref{Frame Layout})
данного фрейма.  Для текстового терминала результаты выражаются в символах,
а не в пикселях.

@defun frame-outer-width &optional frame
@defunx frame-outer-height &optional frame
Функции возвращают внешнюю ширину и высоту @var{frame} в пикселях.
@end defun

@defun frame-native-height &optional frame
@defunx frame-native-width &optional frame
Функции возвращают исходную ширину и высоту @var{frame} в пикселях.
@end defun

@defun frame-inner-width &optional frame
@defunx frame-inner-height &optional frame
Функции возвращают внутреннюю ширину и высоту @var{frame} в пикселях.
@end defun

@defun frame-text-width &optional frame
@defunx frame-text-height &optional frame
Функции возвращают ширину и высоту текстовой области @var{frame} в пикселях.
@end defun

В оконных системах, которые его поддерживают, Emacs по умолчанию пытается
сделать размер текста фрейма, измеренный в пикселях, кратным размеру символа
фрейма.  Это, однако, обычно означает, что размер фрейма можно изменять
только с приращением размера символа при перетаскивании его внешних границ.
Это также может нарушить попытки по-настоящему развернуть фрейм или сделать
его ``полной высотой'' или ``полной шириной'' (@pxref{Size Parameters}),
оставив некоторое пустое пространство ниже и/или справа от фрейма.  В этом
случае может помочь следующий вариант.

@defopt frame-resize-pixelwise
Если этот параметр - @code{nil} (по умолчанию), размер пикселя текста фрейма
обычно округляется до кратного числа текущих значений
@code{frame-char-height} и @code{frame-char-width} этого фрейма при
изменении размера фрейма.  Если не-@code{nil}, округления не происходит,
следовательно, размеры фрейма могут увеличиваться/уменьшаться на один
пиксель.

Установка этой переменной обычно приводит к тому, что следующая операция
изменения размера передает соответствующие подсказки размера диспетчеру
окон.  Это означает, что эта переменная должна быть установлена только в
исходном файле пользователя; приложения никогда не должны привязывать его
временно.

Точное значение @code{nil} для этой опции зависит от используемого
инструментария.  Перетаскивание внешней границы с помощью мыши выполняется
посимвольно, если оконный менеджер готов обрабатывать подсказки
соответствующего размера.  Однако вызов @code{set-frame-size} (смотреть
ниже) с аргументами, которые не определяют размер фрейма как целое число,
кратное его размеру символа, может: игнорироваться, вызывать округление
(GTK+) или быть принятым (Lucid, Motif, MS-Windows).

В некоторых оконных менеджерах может потребоваться установить для опции
значение не-@code{nil}, чтобы фрейм выглядел действительно развернутым или
полноэкранным.
@end defopt

@defun set-frame-size frame width height &optional pixelwise
Функция устанавливает размер текстовой области @var{frame}, измеренный в
терминах канонической высоты и ширины символа на @var{frame}
(@pxref{Frame Font}).

Необязательный аргумент @var{pixelwise} не-@code{nil} означает, что вместо
этого нужно измерять новую ширину и высоту в пикселях.  Обратить внимание,
что если @code{frame-resize-pixelwise} равен @code{nil}, некоторые наборы
инструментов могут отказываться действительно выполнять запрос, если не
увеличивается/не уменьшается размер фрейма до кратного размера его символа.
@end defun

@defun set-frame-height frame height &optional pretend pixelwise
Функция изменяет размер текстовой области @var{frame} до высоты @var{height}
строк.  Размеры существующих окон в @var{frame} изменяются пропорционально
подгонке.

Если @var{pretend} равен не-@code{nil}, то Emacs отображает строки вывода
@var{height} в @var{frame}, но не изменяет свое значение для фактической
высоты фрейма.  Это полезно только на текстовых терминалах.  Использование
меньшей высоты, чем на самом деле реализует терминал, может быть полезно для
воспроизведения поведения, наблюдаемого на меньшем экране, или в случае
неисправности терминала при использовании всего экрана.  Непосредственная
установка высоты фрейма не всегда работает, потому что знание правильного
фактического размера может быть необходимо для правильного позиционирования
курсора на текстовых терминалах.

Необязательный четвертый аргумент @var{pixelwise} не-@code{nil} означает,
что @var{frame} должен иметь высоту @var{height} пикселей.  Обратить
внимание, что если @code{frame-resize-pixelwise} равно @code{nil}, некоторые
оконные менеджеры могут отказываться действительно выполнять запрос, если
не увеличивается/не уменьшается высота фрейма до кратной высоты его символа.
@end defun

@defun set-frame-width frame width &optional pretend pixelwise
Функция устанавливает ширину текстовой области @var{frame}, измеряемую в
символах.  Аргумент @var{pretend} имеет то же значение, что и аргумент
@code{set-frame-height}.

Необязательный четвертый аргумент @var{pixelwise} не-@code{nil} означает,
что @var{frame} должен иметь ширину @var{width} пикселей.  Обратить
внимание, что если @code{frame-resize-pixelwise} равно @code{nil}, некоторые
оконные менеджеры могут отказываться полностью удовлетворить запрос, если
не увеличивается/не уменьшается ширина фрейма до кратной ширины его символа.
@end defun

Ни одна из этих трех функций не сделает фрейм меньше, чем необходимо для
отображения всех его окон вместе с их полосами прокрутки, полосами, полями,
разделителями, режимом и строками заголовка.  Это контрастирует с запросами
оконного менеджера, запускаемыми, например, путем перетаскивания внешней
границы фрейма с помощью мыши.  Такие запросы всегда выполняются путем
отсечения, если необходимо, частей, которые не могут быть отображены в
правом нижнем углу фрейма.  Параметры @code{min-width} и @code{min-height}
(@pxref{Size Parameters}) можно использовать для получения аналогичного
поведения при изменении размера фрейма из Emacs.

@cindex tracking frame size changes
  Не нормальная ловушка @code{window-size-change-functions}
(@pxref{Window Hooks}) отслеживает все изменения внутреннего размера фрейма,
в том числе вызванные запросом оконной системы или оконного менеджера.
Чтобы исключить ложные срабатывания, которые могут возникнуть при изменении
только размеров окон фрейма без фактического изменения размера внутреннего
фрейма, используется следующая функция.

@defun frame-size-changed-p &optional frame
Функция возвращает не-@code{nil}, когда внутренняя ширина или высота
@var{frame} изменилась с момента последнего запуска
@code{window-size-change-functions} для @var{frame}.  Всегда возвращается
@code{nil} сразу после запуска @code{window-size-change-functions} для
@var{frame}.
@end defun


@node Implied Frame Resizing
@subsection Подразумеваемое Изменение Размера Фрейма
@cindex implied frame resizing
@cindex implied resizing of frame

По умолчанию Emacs пытается сохранить неизменным количество строк и столбцов
в текстовой области фрейма, например, при добавлении или удалении строки
меню, изменении шрифта по умолчанию или установке ширины полос прокрутки
фрейма.  Однако это означает, что в таком случае Emacs должен попросить
диспетчер окон изменить размер внешнего фрейма, чтобы приспособиться к
изменению размера.  Обратить внимание, что обертывание меню или панели
инструментов обычно не изменяет внешний размер фрейма, следовательно, это
изменит количество отображаемых строк.

  Иногда такое @dfn{подразумеваемое изменение размера фрейма} может быть
нежелательным, например, когда фрейм развернут или сделан в полноэкранном
режиме (где он отключен по умолчанию).  В других случаях можно отключить
подразумеваемое изменение размера с помощью следующей опции:

@defopt frame-inhibit-implied-resize
Если этот параметр - @code{nil}, изменение шрифта, строки меню, панели
инструментов, внутренних границ, полос или полос прокрутки определенного
фрейма может неявно изменить размер области отображения фрейма, чтобы
сохранить количество столбцов или строк, отображаемых фреймом.  Если этот
параметр - не-@code{nil}, подразумеваемое изменение размера не выполняется.

Значением этой опции также может быть список параметров фрейма.  В этом
случае подразумеваемое изменение размера запрещается при изменении
параметра, который появляется в этом списке.  Параметры фрейма, которые в
настоящее время обрабатываются этой опцией:: @code{font},
@code{font-backend}, @code{internal-border-width}, @code{menu-bar-lines} и
@code{tool-bar-lines}.

Изменение любого из параметров фрейма @code{scroll-bar-width},
@code{scroll-bar-height}, @code{vertical-scroll-bars},
@code{horizontal-scroll-bars}, @code{left-fringe} и @code{right-fringe}
обрабатывается так, как если бы фрейм содержал только одно активное окно.
Это означает, например, что удаление вертикальных полос прокрутки на фрейме,
содержащем несколько боковых окон, уменьшит внешнюю ширину фрейма на ширину
одной полосы прокрутки при условии, что этот параметр - @code{nil}, и
оставит его неизменным, если этот параметр - @code{t} или список, содержащий
@code{vertical-scroll-bars}.

Значение по умолчанию - @code{'(tool-bar-lines)} для Lucid, Motif и
MS-Windows (что означает, что добавление/удаление панели инструментов не
изменяет высоту внешнего фрейма), @code{nil} для всех других оконных систем,
включая GTK+ (что означает, что изменение любого из параметров перечисленных
выше могут изменить размер внешнего фрейма), и @code{t} в противном случае
(что означает, что размер внешнего фрейма никогда не изменяется неявно, если
нет поддержки оконной системы).

Заметьте, что когда размер кадра недостаточно велик, чтобы приспособиться к
изменению любого из параметров, перечисленных выше, Emacs может попытаться
увеличить фрейм, даже если эта опция установлена в не-@code{nil}.
@end defopt


@node Frame Parameters
@section Параметры Фрейма
@cindex frame parameters

  У фрейма есть множество параметров, которые управляют его внешним видом и
поведением.  Какие параметры имеет фрейм, зависит от того, какой механизм
отображения он использует.

  Параметры фрейма существуют в основном для графического отображения.
Большинство параметров фрейма не действуют при применении к фрейму в
текстовом терминале; только параметры @code{height}, @code{width},
@code{name}, @code{title}, @code{menu-bar-lines}, @code{buffer-list} и
@code{buffer-predicate} делают что-то особенное.  Если терминал поддерживает
цвета, параметры @code{foreground-color}, @code{background-color},
@code{background-mode} и @code{display-type} также имеют значение.  Если
терминал поддерживает прозрачность фрейма, значение параметра @code{alpha}
также имеет значение.

  По умолчанию параметры фрейма сохраняются и восстанавливаются функциями
библиотеки рабочего стола (@pxref{Desktop Save Mode}), когда переменная
@code{desktop-restore-frames} имеет значение не-@code{nil}.  Приложения
несут ответственность за то, чтобы их параметры были включены в
@code{frameset-persistent-filter-alist}, чтобы избежать получения
бессмысленных или даже вредных значений в восстановленных сеансах.

@menu
* Parameter Access::       Как изменить параметры фрейма.
* Initial Parameters::     Указание параметров фрейма при создании.
* Window Frame Parameters:: Список параметров фреймов для оконных систем.
* Geometry::               Разбор геометрических характеристик.
@end menu

@node Parameter Access
@subsection Доступ к Параметрам Фрейма

Эти функции позволяют читать и изменять значения параметров кадра.

@defun frame-parameter frame parameter
Функция возвращает значение параметра @var{parameter} (символ) для
@var{frame}.  Если @var{frame} равен @code{nil}, возвращается параметр
выбранного фрейма.  Если @var{frame} не имеет настройки для @var{parameter},
функция возвращает @code{nil}.
@end defun

@defun frame-parameters &optional frame
Функция @code{frame-parameters} возвращает список, в котором перечислены все
параметры @var{frame} и их значения.  Если @var{frame} равен @code{nil} или
опущен, это возвращает параметры выбранного фрейма.
@end defun

@defun modify-frame-parameters frame alist
Функция изменяет фрейм @var{frame} на основе элементов @var{alist}.  Каждый
элемент @var{alist} имеет вид @code{(@var{parm} . @var{value})}, где
@var{parm} - это символ, обозначающий параметр.  Если вы не указан параметр
в @var{alist}, его значение не изменится.  Если @var{frame} равен
@code{nil}, по умолчанию используется выбранный фрейм.

Некоторые параметры имеют значение только для фреймов на определенных типах
дисплеев (@pxref{Frames}).  Если @var{alist} включает параметры, которые не
имеют смысла для отображения @var{frame}, эта функция изменит свое значение
в списке параметров фрейма, но в противном случае проигнорирует его.

Когда @var{alist} указывает более одного параметра, значение которого может
повлиять на новый размер @var{frame}, окончательный размер фрейма может
отличаться в зависимости от используемого инструментария.  Например,
указание, что отныне фрейм должен иметь меню и/или панель инструментов, а не
ничего, и одновременное указание новой высоты фрейма неизбежно приведет к
перерасчету высоты фрейма.  По идее, в таком случае эта функция будет
пытаться сделать так, чтобы явная спецификация высоты преобладала.  Однако
нельзя исключить, что добавление (или удаление) меню или панели
инструментов, когда в конечном итоге выполняется набором инструментов,
разрушит это намерение.

Иногда привязка @code{frame-inhibit-implied-resize}
(@pxref{Implied Frame Resizing}) к значению не-@code{nil} вокруг вызовов
этой функции может решить описанную здесь проблему.  Иногда, однако,
проблема может возникнуть именно в такой привязке.
@end defun

@defun set-frame-parameter frame parm value
Функция устанавливает параметр фрейма @var{parm} равным указанному
@var{value}.  Если @var{frame} равен @code{nil}, по умолчанию используется
выбранный фрейм.
@end defun

@defun modify-all-frames-parameters alist
Функция изменяет параметры фреймов всех существующих фреймов в соответствии
с @var{alist}, затем изменяет @code{default-frame-alist} (и, если
необходимо, @code{initial-frame-alist}), чтобы применить те же значени
я параметров к фреймам, которые будут создаваться впредь.
@end defun

@node Initial Parameters
@subsection Параметры Начального Фрейма
@cindex parameters of initial frame

Можно указать параметры для начального стартового фрейма, установив
@code{initial-frame-alist} в файле инициализации (@pxref{Init File}).

@defopt initial-frame-alist
Значение этой переменной представляет собой список значений параметров,
используемых при создании начального фрейма.  Можно установить эту
переменную, чтобы указать внешний вид начального фрейма без изменения
последующих фреймов.  Каждый элемент имеет форму:

@example
(@var{parameter} . @var{value})
@end example

Emacs создает начальный фрейм перед чтением файла инициализации.
После чтения этого файла Emacs проверяет @code{initial-frame-alist} и
применяет настройки параметров в измененном значении к уже созданному
начальному фрейму.

Если эти настройки влияют на геометрию и внешний вид фрейми, фрейм
отобразится с неправильными параметрами, а затем изменится на указанные.
Если это беспокоит, можно указать ту же геометрию и внешний вид с ресурсами
X; они вступают в силу до создания фрейма.
@xref{X Resources,, X Resources, emacs, The GNU Emacs Manual}.

Параметры ресурсов X обычно применяются ко всем фреймам.  Если нужно указать
некоторые ресурсы X исключительно ради начального фрейма и не требуется
чтобы они применялись к последующим фреймам, вот как этого добиться.
Задаются параметры в @code{default-frame-alist}, чтобы переопределить
ресурсы X для последующих фреймов; затем, чтобы они не влияли на начальный
фрейм, указываются те же параметры в @code{initial-frame-alist} со
значениями, соответствующими X-ресурсам.
@end defopt

@cindex minibuffer-only frame
Если эти параметры включают @code{(minibuffer . nil)}, это означает, что в
начальном фрейме не должно быть минибуфера.  В этом случае Emacs также
создает отдельный @dfn{minibuffer-only frame}.

@defopt minibuffer-frame-alist
Значение этой переменной представляет собой список значений параметров,
используемых при создании начального фрейма только для минибуфера (то есть
фрейма только для минибуфера, который Emacs создает, если
@code{initial-frame-alist} определяет фрейм без минибуфера).
@end defopt

@defopt default-frame-alist
Это список, определяющий значения параметров фрейма по умолчанию для всех
фреймов Emacs - первого фрейма и последующих фреймов.  При использовании
системы X Window можно получить те же результаты с помощью ресурсов X во
многих случаях.

Установка этой переменной не влияет на существующие фреймы.  Кроме того,
функции, отображающие буфер в отдельном фрейме, могут переопределить
параметры по умолчанию, предоставив свои собственные параметры.
@end defopt

Если вызывается Emacs с параметрами командной строки, которые определяют
внешний вид фрейма, эти параметры вступают в силу путем добавления элементов
в @code{initial-frame-alist} или @code{default-frame-alist}.  Параметры,
которые влияют только на начальный фрейм, такие как @samp{--geometry} и
@samp{--maximized}, добавляются к @code{initial-frame-alist}; остальные
добавится в @code{default-frame-alist}.
@pxref{Emacs Invocation,, Command Line Arguments for Emacs Invocation, emacs, The GNU Emacs Manual}.

@node Window Frame Parameters
@subsection Параметры Фрейма Окна
@cindex frame parameters for windowed displays

  Какие параметры имеет фрейм, зависит от того, какой механизм отображения
он использует.  В этом разделе описаны параметры, которые имеют особое
значение для некоторых или всех типов терминалов.  Из них @code{name},
@code{title}, @code{height}, @code{width}, @code{buffer-list} и
@code{buffer-predicate} предоставляет значимую информацию в терминальных
фреймах, а @code{tty-color-mode} имеет смысл только для фреймов на текстовых
терминалах.

@menu
* Basic Parameters::           Параметры, которые являются фундаментальными.
* Position Parameters::         Положение фрейма на экране.
* Size Parameters::             Размер фрейма.
* Layout Parameters::           Размер частей фрейма, а также включение или
                                   отключение некоторых частей.
* Buffer Parameters::           Какие буферы были или должны быть показаны.
* Frame Interaction Parameters::Параметры взаимодействия с другими фреймами.
* Mouse Dragging Parameters::   Параметры для изменения размера и
                                   перемещения фреймов мышью.
* Management Parameters::       Общение с оконным менеджером.
* Cursor Parameters::           Управление внешним видом курсора.
* Font and Color Parameters::   Шрифты и цвета для текста фрейма.
@end menu

@node Basic Parameters
@subsubsection Основные Параметры

  Эти параметры фрейма дают основную информацию о фрейме.  @code{title} и
@code{name} значимы на всех терминалах.

@table @code
@vindex display@r{, пареметр фрейма}
@item display
Дисплей, на котором открывается этот фрейм.  Это должна быть строка вида
@samp{@var{host}:@var{dpy}.@var{screen}}, как и переменная окружения
@env{DISPLAY}.  @xref{Multiple Terminals}, чтобы узнать больше об
отображаемых именах.

@vindex display-type@r{, пареметр фрейма}
@item display-type
Параметр описывает диапазон возможных цветов, которые можно использовать в
этом фрейме.  Его значение @code{color}, @code{grayscale} или @code{mono}.

@vindex title@r{, пареметр фрейма}
@item title
Если у фрейма есть заголовок не-@code{nil}, он появляется в строке заголовка
оконной системы в верхней части фрейма, а также в строке режима окон в этом
фрейме, если @code{mode-line-frame-identification} использует @samp{%F}
(@pxref{%-Constructs}).  Обычно это происходит, когда Emacs не использует
оконную систему и может отображать только один фрейм за раз.
@xref{Frame Titles}.

@vindex name@r{, параметр кадра}
@item name
Название фрейма.  Имя фрейма используется по умолчанию для заголовка фрейма,
если параметр @code{title} не указан или @code{nil}.  Если не указано имя,
Emacs автоматически установит имя фрейма (@pxref{Frame Titles}).

Если явно указано имя фрейма при создании фрейма, это имя также используется
(вместо имени исполняемого файла Emacs) при поиске ресурсов X для фрейма.

@vindex explicit-name@r{, пареметр фрейма}
@item explicit-name
Если имя фрейма было указано явно при создании фрейма, этот параметр будет
этим именем.  Если фрейм не был назван явно, этот параметр будет @code{nil}.
@end table


@node Position Parameters
@subsubsection Параметры Положения
@cindex window position on display
@cindex frame position

Параметры, описывающие X- и Y-смещения фрейма, всегда измеряются в пикселях.
Для нормального, не дочернего фрейма они определяют внешнюю позицию
(@pxref{Frame Geometry}) фрейма относительно его исходной точки отображения.
Для дочернего фрейма (@pxref{Child Frames}) они определяют внешнее положение
фрейма относительно исходного положения родительского фрейма.  (Обратить
внимание, что ни один из этих параметров не имеет значения для фреймов TTY.)

@table @code
@vindex left@r{, параметр фрейма}
@item left
Положение в пикселях левого внешнего края фрейма по отношению к левому краю
отображения фрейма или родительского фрейма.  Можно указать одним из
следующих способов.

@table @asis
@item an integer
Положительное целое число всегда связывает левый край фрейма с левым краем
его дисплея или родительского фрейма.  Отрицательное целое число связывает
правый край фрейма с правым краем дисплея или родительского фрейма.

@item @code{(+ @var{pos})}
Это определяет положение левого края фрейма относительно левого края его
дисплея или родительского фрейма.  Целое число @var{pos} может быть
положительным или отрицательным; отрицательное значение указывает положение
за пределами экрана или родительского фрейма или на мониторе, отличном от
основного (для дисплеев с несколькими мониторами).

@item @code{(- @var{pos})}
Это определяет положение правого края фрейма относительно правого края
дисплея или родительского фрейма.  Целое число @var{pos} может быть
положительным или отрицательным; отрицательное значение указывает положение
за пределами экрана или родительского фрейма или на мониторе, отличном от
основного (для дисплеев с несколькими мониторами).

@cindex left position ratio
@cindex top position ratio
@item a floating-point value
Значение с плавающей запятой в диапазоне от 0.0 до 1.0 указывает смещение
левого края через @dfn{соотношение левой позиции} фрейма --- отношение
левого края его внешнего фрейма к ширине рабочей области
(@pxref{Multiple Terminals}) фрейма или его родительского фрейма
(@pxref{Child Frames}) минус ширина внешнего фрейма.  Таким образом,
соотношение левой позиции 0.0 сбрасывает фрейм влево, коэффициент 0.5
центрирует его, а коэффициент 1.0 сбрасывает его справа от дисплея или
родительского фрейма.  Точно так же @dfn{коэффициент верхней позиции} фрейма
- это отношение верхнего положения фрейма к высоте его рабочей области или
родительского фрейма за вычетом высоты фрейма.

Emacs будет пытаться сохранить соотношения позиций дочернего фрейма
неизменными, если этот фрейм имеет параметр не-@code{nil} @code{keep-ratio}
(@pxref{Frame Interaction Parameters}), а его родительский фрейм изменяет
размер.

Поскольку внешний размер фрейма (@pxref{Frame Geometry}) обычно недоступен
до того, как фрейм станет видимым, обычно не рекомендуется использовать
значения с плавающей запятой при создании декорированных фреймов.  Значения
с плавающей запятой больше подходят для обеспечения того, чтобы
(недекорированный) дочерний фрейм правильно располагался в области своего
родительского фрейма.
@end table

Некоторые оконные менеджеры игнорируют позиции, указанные в программе.  Если
требуется уверенность, что указанная позиция не игнорируется, указывается
значение не-@code{nil} для параметра @code{user-position}, как в следующем
примере:

@example
(modify-frame-parameters
  nil '((user-position . t) (left . (+ -4))))
@end example

Как правило, не рекомендуется размещать фрейм относительно правого или
нижнего края экрана.  Расположение исходного или нового фрейма либо неточно
(потому что размер внешнего фрейма еще не полностью известен до того, как
фрейм станет видимым), либо вызовется дополнительное мерцание (если фрейм
необходимо переместить после того, как он стал видимым).

  Также обратить внимание, что позиции, указанные относительно
правого/нижнего края дисплея, рабочей области или родительского фрейма, а
также смещения с плавающей точкой сохраняются внутри как целочисленные
смещения относительно левого/верхнего края дисплея, рабочей области или края
родительского фрейма.  Они также возвращаются такими функциями, как
@code{frame-parameters}, и восстанавливаются как таковые процедурами
сохранения рабочего стола.

@vindex top@r{, параметр фрейма}
@item top
Положение верхнего (или нижнего) края экрана в пикселях относительно
верхнего (или нижнего) края дисплея или родительского фрейма.  Работает так
же, как @code{left}, за исключением вертикально, а не горизонтально.

@vindex icon-left@r{, параметр фрейма}
@item icon-left
Положение на экране левого края значка фрейма в пикселях, считая от левого
края экрана.  Это вступает в силу, когда фрейм отображается в виде значка,
если оконный менеджер поддерживает эту функцию.  Если указано значение для
этого параметра, также потребуется указать значение для @code{icon-top} и
наоборот.

@vindex icon-top@r{, параметр фрейма}
@item icon-top
Положение на экране верхнего края значка фрейма в пикселях, считая от
верхнего края экрана.  Это вступает в силу, когда фрейм отображается в виде
значка, если оконный менеджер поддерживает эту функцию.

@vindex user-position@r{, параметр фрейма}
@item user-position
Когда создаётся фрейм и указывается его положение на экране с помощью
параметров @code{left} и @code{top}, использовать этот параметр, чтобы
указать, была ли указанная позиция указана пользователем (явно запрошена
каким-то образом пользователем-человеком) или просто указана программой
(выбрана программой).  Значение не-@code{nil} говорит о том, что позиция
была указана пользователем.

@cindex window positions and window managers
Оконные менеджеры обычно принимают во внимание позиции, указанные
пользователем, а некоторые также учитывают позиции, определенные программой.
Но многие игнорируют определенные программой позиции, размещая окно по
умолчанию или позволяя пользователю размещать его с помощью мыши.  Некоторые
оконные менеджеры, в том числе @code{twm}, позволяют пользователю указывать,
следует ли подчиняться программным позициям или игнорировать их.

Когда вызывается @code{make-frame}, потребуется указать значение
не-@code{nil} для этого параметра, если значения параметров @code{left} и
@code{top} представляют заявленные пользователем предпочтения; в противном
случае используется @code{nil}.

@vindex z-group@r{, параметр фрейма}
@item z-group
Параметр определяет относительное положение окна оконной системы фрейма в
порядке наложения (Z-) отображения фрейма.

Если установлен в @code{above}, окно оконной системы фрейма отображается
над всеми другими окнами оконной системы, для которых не установлено
свойство @code{above}.  Если установлен в @code{nil}, окно фрейма
отображается под всеми окнами, для которых установлено свойство
@code{above}, и над всеми окнами, для которых установлено свойство
@code{below}.  Если установлено в @code{below}, окно фрейма отображается под
всеми окнами, для которых не установлено свойство @code{below}.

Чтобы разместить фрейм выше или ниже определенного другого фрейма,
использовать функцию @code{frame-restack} (@pxref{Raising and Lowering}).
@end table


@node Size Parameters
@subsubsection Параметры Размера
@cindex window size on display

Параметры фрейма обычно указывают размеры фрейма в единицах символов.  На
графических дисплеях грань @code{default} определяет фактические размеры в
пикселях этих символьных единиц (@pxref{Face Attributes}).

@table @code
@vindex width@r{, параметр фрейма}
@item width
Этот параметр определяет ширину фрейма.  Его можно указать следующим
образом:

@table @asis
@item an integer
Положительное целое число определяет ширину текстовой области
(@pxref{Frame Geometry}) фрейма в символах.

@item a cons cell
Если это cons-ячейка с символом @code{text-pixels} в ее @sc{car}, @sc{cdr}
этой ячейки определяет ширину текстовой области фрейма в пикселях.

@cindex frame width ratio
@cindex frame height ratio
@item a floating-point value
Число с плавающей точкой от 0.0 до 1.0 может использоваться для указания
ширины фрейма через его @dfn{соотношение ширины} --- отношение его внешней
ширины (@pxref{Frame Geometry}) к ширине рабочей области
(@pxref{Multiple Terminals}) фрейма или собственного фрейма
(@pxref{Child Frames}) его родительского фрейма.  Таким образом, значение
0.5 заставляет фрейм занимать половину ширины своей рабочей области или
родительского фрейма, а значение 1.0 - полную ширину.  Точно так же
@dfn{соотношение высоты} фрейма - это отношение его внешней высоты к высоте
его рабочей области или собственного фрейма его родителя.

Emacs будет пытаться сохранить неизменным соотношение ширины и высоты
дочернего фрейма, если этот фрейм имеет параметр не-@code{nil}
@code{keep-ratio} (@pxref{Frame Interaction Parameters}) и его родительский
фрейм изменяется.

Поскольку внешний размер фрейма обычно недоступен до того, как фрейм станет
видимым, обычно не рекомендуется использовать значения с плавающей запятой
при создании декорированных фреймов.  Значения с плавающей запятой больше
подходят для гарантии того, что дочерний фрейм всегда помещается в область
своего родительского фрейма, как, например, при настройке
@code{display-buffer-alist} (@pxref{Choosing Window}) через
@code{display-buffer-in-child-frame}.
@end table

Независимо от того, как был указан этот параметр, функции, сообщающие
значение этого параметра, такие как @code{frame-parameters}, всегда сообщают
ширину текстовой области фрейма в символах как целое число, округленное,
если необходимо, до кратного ширине символа фрейма по умолчанию.  Это
значение также используется процедурами сохранения рабочего стола.

@vindex height@r{, параметр фрейма}
@item height
Этот параметр определяет высоту фрейма.  Работает так же, как @code{width},
только вертикально, а не горизонтально.

@vindex user-size@r{, параметр фрейма}
@item user-size
Производит для параметров размера @code{height} и @code{width} то же, что
параметр @code{user-position} (@pxref{Position Parameters, user-position})
делает для параметров положения @code{top} и @code{left}.

@vindex min-width@r{, параметр фрейма}
@item min-width
Параметр указывает минимальную ширину (@pxref{Frame Geometry}) фрейма в
символах.  Обычно функции, устанавливающие начальную ширину фрейма или
изменяющие размер фрейма по горизонтали, обеспечивают отображение всех окон
фрейма, вертикальных полос прокрутки, полос, полей и вертикальных
разделителей.  Этот параметр, если не-@code{nil} позволяет сделать фрейм
более узким, чем было бы, в результате чего любые компоненты, которые не
подходят, будут обрезаны оконным менеджером.

@vindex min-height@r{, параметр фрейма}
@item min-height
Параметр указывает минимальную исходную высоту (@pxref{Frame Geometry})
фрейма в символах.  Обычно функции, устанавливающие начальный размер фрейма
или изменяющие размер фрейма, обеспечивают отображение всех окон фрейма,
горизонтальных полос прокрутки и разделителей, строк режима и заголовков,
эхо-области, внутреннего меню и панели инструментов.  Этот параметр, если
не-@code{nil} позволяет уменьшить размер фрейма, в результате чего любые
компоненты, которые не помещаются, будут обрезаны оконным менеджером.

@cindex fullboth frames
@cindex fullheight frames
@cindex fullwidth frames
@cindex maximized frames
@vindex fullscreen@r{, параметр фрейма}
@item fullscreen
Параметр указывает, следует ли максимизировать ширину фрейма, высоту или и
то, и другое.  Его значение может быть @code{fullwidth}, @code{fullheight},
@code{fullboth} или @code{maximized}.  @dfn{fullwidth} фрейма означает
максимальную ширину, @dfn{fullheight} фрейма - максимальную высоту, а
@dfn{fullboth} - максимальную ширину и максимальную высоту.  @dfn{maximized}
фрейма похож на ``fullboth'' фрейма, за исключением того, что обычно
сохраняет строку заголовка и кнопки для изменения размера и закрытия фрейма.
Кроме того, развернутые фреймы обычно не скрывают панель задач или панели,
отображаемые на рабочем столе.  С другой стороны, ``fullboth'' фрейма обычно
пропускает строку заголовка и занимает все доступное пространство экрана.

В этом отношении полноразмерные и полноширинные фреймы больше похожи на
развернутые фреймы.  Однако они обычно отображают внешнюю границу, которая
может отсутствовать в развернутых фреймах.  Следовательно, высота
развернутых и полноразмерных фреймов и ширина развернутых и полноразмерных
фреймов часто отличаются на несколько пикселей.

В некоторых оконных менеджерах может потребоваться настроить переменную
@code{frame-resize-pixelwise} (@pxref{Frame Size}), чтобы фрейм
действительно выглядел развернутым или полноэкранным.  Более того, некоторые
оконные менеджеры могут не поддерживать плавный переход между различными
состояниями полноэкранного режима или максимизации.  Изменение переменной
@code{x-frame-normalize-before-maximize} может помочь решить эту проблему.

В полноэкранном режиме в macOS скрываются как панель инструментов, так и
строка меню, однако обе будут отображаться, если указатель мыши переместится
в верхнюю часть экрана.

@vindex fullscreen-restore@r{, a frame parameter}
@item fullscreen-restore
Параметр указывает желаемое полноэкранное состояние фрейма после вызова
команды @code{toggle-frame-fullscreen}
(@pxref{Frame Commands,,, emacs, The GNU Emacs Manual}) в состоянии
``fullboth''.  Обычно этот параметр устанавливается автоматически этой
командой при переключении состояния на полное.  Если, однако, запускается
Emacs в состоянии ``fullboth'', потребуется указать желаемое поведение в
исходном файле, например, как

@example
(setq default-frame-alist
    '((fullscreen . fullboth)
      (fullscreen-restore . fullheight)))
@end example

Это даст новый фрейм во всю высоту после первого ввода в него @key{F11}.

@vindex fit-frame-to-buffer-margins@r{, параметр фрейма}
@item fit-frame-to-buffer-margins
Параметр позволяет переопределить значение опции
@code{fit-frame-to-buffer-margins} при подгонке этого фрейма к буферу его
корневого окна с помощью @code{fit-frame-to-buffer}
(@pxref{Resizing Windows}).

@vindex fit-frame-to-buffer-sizes@r{, параметр фрейма}
@item fit-frame-to-buffer-sizes
Параметр позволяет переопределить значение опции
@code{fit-frame-to-buffer-sizes} при подгонке этого фрейма к буферу его
корневого окна с помощью @code{fit-frame-to-buffer}
(@pxref{Resizing Windows}).
@end table


@node Layout Parameters
@subsubsection Параметры Макета
@cindex layout parameters of frames
@cindex frame layout parameters

  Эти параметры фрейма включают или отключают различные части фрейма или
управляют их размерами.

@table @code
@vindex border-width@r{, a параметр фрейма}
@item border-width
Ширина в пикселях внешней границы кадра (@pxref{Frame Geometry}).

@vindex internal-border-width@r{, параметр фрейма}
@item internal-border-width
Ширина в пикселях внутренней границы кадра (@pxref{Frame Geometry}).

@vindex vertical-scroll-bars@r{, a frame parameter}
@item vertical-scroll-bars
Есть ли в фрейме полосы прокрутки (@pxref{Scroll Bars}) для вертикальной
прокрутки и с какой стороны фрейма они должны быть.  Возможные значения:
@code{left}, @code{right} и @code{nil} без полос прокрутки.

@vindex horizontal-scroll-bars@r{, параметр фрейма}
@item horizontal-scroll-bars
Есть ли в фрейме полосы прокрутки для горизонтальной прокрутки (@code{t} и
@code{bottom} означают да, @code{nil} означает нет).

@vindex scroll-bar-width@r{, параметр фрейма}
@item scroll-bar-width
Ширина вертикальных полос прокрутки в пикселях или @code{nil} означает
использование ширины по умолчанию.

@vindex scroll-bar-height@r{, параметр фрейма}
@item scroll-bar-height
Высота горизонтальных полос прокрутки в пикселях или @code{nil}, что
означает использование высоты по умолчанию.

@vindex left-fringe@r{, параметр фрейма}
@vindex right-fringe@r{, параметр фрейма}
@item left-fringe
@itemx right-fringe
Ширина по умолчанию левой и правой кромок окон в этом фрейме
(@pxref{Fringes}).  Если любой из них равен нулю, это эффективно удаляет
соответствующую полосу.

Когда используется @code{frame-parameter} для запроса значения любого из
этих двух параметров фрейма, возвращаемое значение всегда является целым
числом.  При использовании @code{set-frame-parameter} передача значения
@code{nil} накладывает фактическое значение по умолчанию 8 пикселей.

@vindex right-divider-width@r{, параметр фрейма}
@item right-divider-width
Ширина (толщина), зарезервированная для правого разделителя
(@pxref{Window Dividers}) любого окна в фрейме, в пикселях.  Нулевое
значение означает, что правые разделители не отображаются.

@vindex bottom-divider-width@r{, параметр фрейма}
@item bottom-divider-width
Ширина (толщина), зарезервированная для нижнего делителя
(@pxref{Window Dividers}) любого окна в фрейме, в пикселях.  Нулевое
значение означает, что нижние разделители не отображаются.

@vindex menu-bar-lines@r{, параметр фрейма}
@item menu-bar-lines
Число строк, выделяемых в верхней части фрейма для строки меню
(@pxref{Menu Bar}).  По умолчанию значение равно единице, если включен режим
строки меню, и нулю в противном случае.
@xref{Menu Bars,,,emacs, The GNU Emacs Manual}.  Для внешней строки меню
(@pxref{Frame Layout}) это значение остается неизменным, даже если строка
меню переносится на две или более строк.  В этом случае значение
@code{menu-bar-size}, возвращаемое @code{frame-geometry}
(@pxref{Frame Geometry}), позволяет определить, действительно ли строка меню
занимает одну или несколько строк.

@vindex tool-bar-lines@r{, параметр фрейма}
@item tool-bar-lines
Количество строк для панели инструментов (@pxref{Tool Bar}).  По умолчанию
используется один, если включен режим панели инструментов, и ноль в
противном случае.  @xref{Tool Bars,,,emacs, The GNU Emacs Manual}.  Это
значение может измениться всякий раз, когда панель инструментов переносит
(@pxref{Frame Layout}).

@vindex tool-bar-position@r{, параметр фрейма}
@item tool-bar-position
Положение панели инструментов, когда Emacs был собран с помощью GTK+.  Его
значение может быть одним из @code{top}, @code{bottom} @code{left},
@code{right}.  По умолчанию - @code{top}.

@vindex line-spacing@r{, параметр фрейма}
@item line-spacing
Дополнительное пространство в пикселях (положительное целое число), которое
следует оставить под каждой текстовой строкой.  @xref{Line Height}, для
получения дополнительной информации.

@vindex no-special-glyphs@r{, параметр фрейма}
@item no-special-glyphs
Если установленно в не-@code{nil}, подавляется отображение любых глифов
усечения и продолжения (@pxref{Truncation}) для всех буферов, отображаемых
этим фреймом.  Это полезно для устранения таких глифов при подгонке фрейма
к его буферу через @code{fit-frame-to-buffer} (@pxref{Resizing Windows}).
@end table


@node Buffer Parameters
@subsubsection Параметры Буфера
@cindex frame, which buffers to display
@cindex buffers to display on frame

  Эти параметры фрейма, значимые для всех типов терминалов, имеют дело с
тем, какие буферы были или должны отображаться в фрейме.

@table @code
@vindex minibuffer@r{, параметр фрейма}
@item minibuffer
Имеет ли этот фрейм собственный минибуфер.  Значение @code{t} означает «да»,
@code{nil} означает «нет», @code{only} означает, что этот фрейм является
просто минибуфером.  Если значение является окном минибуфера (в каком-то
другом фрейме), фреймx использует этот минибуфер.

Параметр вступает в силу при создании фрейма.  Если установлен в @code{nil},
Emacs попытается установить его в окно минибуфера
@code{default-minibuffer-frame} (@pxref{Minibuffers and Frames}).  Для
существующего фрейма этот параметр может использоваться исключительно для
указания другого окна минибуфера.  Не разрешается менять его из окна
минибуфера на @code{t} и наоборот, или с @code{t} на @code{nil}.  Если
параметр уже определяет окно минибуфера, установка его на @code{nil} не
имеет никакого эффекта.

@vindex buffer-predicate@r{, параметр фрейма}
@item buffer-predicate
Функция предиката буфера для этого фрейма.  Функция @code{other-buffer}
использует этот предикат (из выбранного фрейма), чтобы решить, какие буферы
следует учитывать, если предикат не @code{nil}.  Вызывает предикат с одним
аргументом, буфером, один раз для каждого буфера; если предикат возвращает
значение не-@code{nil}, он считает этот буфер.

@vindex buffer-list@r{, параметр фрейма}
@item buffer-list
Список буферов, которые были выбраны в этом фрейме, отсортированные по
порядку в первую очередь идут последние выбранные.

@vindex unsplittable@r{, параметр фрейма}
@item unsplittable
Если не-@code{nil}, окно этого фрейма никогда не разделяется автоматически.
@end table


@node Frame Interaction Parameters
@subsubsection Frame Interaction Parameters
@cindex frame interaction parameters
@cindex interaction parameters between frames

Эти параметры обеспечивают формы взаимодействия между различными фреймами.

@table @code
@vindex parent-frame@r{, параметр фрейма}
@item parent-frame
Если не-@code{nil}, это означает, что этот фрейм является дочерним
(@pxref{Child Frames}), и этот параметр указывает его родительский фрейм.
Если @code {nil}, это означает, что этот фрейм является нормальным фреймом
верхнего уровня.

@vindex delete-before@r{, параметр фрейма}
@item delete-before
Если не-@code{nil}, этот параметр указывает другой фрейм, удаление которого
автоматически инициирует удаление этого фрейма.  @xref{Deleting Frames}.

@vindex mouse-wheel-frame@r{, параметр фрейма}
@item mouse-wheel-frame
Если не-@code{nil}, этот параметр указывает фрейм, окна которого будут
прокручиваться всякий раз, когда колесо мыши прокручивается с указателем
мыши, наведенным на этот фрейм, смотреть
@ref{Mouse Commands,,, emacs, The GNU Emacs Manual}.

@vindex no-other-frame@r{, параметр фрейма}
@item no-other-frame
Если установлен в не-@code{nil}, то этот фрейм не может быть кандидатом на
функции @code{next-frame}, @code{previous-frame}
(@pxref{Finding All Frames}) и @code{other-frame}, смотреть
@ref{Frame Commands,,, emacs, The GNU Emacs Manual}.

@vindex auto-hide-function@r{, параметр фрейма}
@item auto-hide-function
Когда параметр указывает функцию, функция будет вызываться вместо функции,
указанной переменной @code{frame-auto-hide-function}, при выходе из
единственного фрейма окна (@pxref{Quitting Windows}), не затрагивая другие
фреймы.

@vindex minibuffer-exit@r{, параметр фрейма}
@item minibuffer-exit
Когда параметр - не-@code{nil}, Emacs по умолчанию будет делать этот фрейм
невидимым всякий раз, когда минибуфер (@pxref{Minibuffers}) выходит из
строя.  В качестве альтернативы можно указать функции @code{iconify-frame} и
@code{delete-frame}.  Параметр полезен для автоматического исчезновения
дочернего фрейма (аналогично тому, как Emacs работает с окном) при выходе
из минибуфера.

@vindex keep-ratio@r{, параметр фрейма}
@item keep-ratio
Параметр в настоящее время имеет значение только для дочерних фреймов
(@pxref{Child Frames}).  Если это не-@code{nil}, то Emacs будет пытаться
сохранить соотношения размеров (ширины и высоты) фрейма
(@pxref{Size Parameters}), а также соотношения его левого и правого
положения (@pxref{Position Parameters}) неизменными всякий раз, когда
изменяется размер его родительского фрейма.

Если значение этого параметра - @code{nil}, позиция и размер фрейма остаются
неизменными при изменении размера родительского фрейма, поэтому соотношение
положения и размера может измениться.  Если значение этого параметра -
@code{t}, Emacs попытается сохранить размер фрейма и соотношения положения,
следовательно, размер и положение фрейма относительно его родительского
фрейма могут измениться.

Более индивидуальный контроль возможен при использовании cons-ячейки: в этом
случае соотношение ширины фрейма сохраняется, если @sc{car} ячейки имеет
значение @code{t} или @code{width-only}.  Соотношение высоты сохраняется,
если @sc{car} ячейки установлено в @code{t} или @code{height-only}.
Соотношение левой позиции сохраняется, если @sc{cdr} ячейки установлено в
@code{t} или @code{left-only}.  Коэффициент верхней позиции сохраняется,
если @sc{cdr} ячейки установлен в @code{t} или @code{top-only}.
@end table


@node Mouse Dragging Parameters
@subsubsection Параметры Перетаскивания Мышью
@cindex mouse dragging parameters
@cindex parameters for resizing frames with the mouse
@cindex parameters for moving frames with the mouse

Описанные ниже параметры обеспечивают поддержку изменения размера фрейма
путем перетаскивания его внутренних границ с помощью мыши.  Также позволяют
перемещать фрейм с помощью мыши, перетаскивая строку заголовка самого
верхнего окна или строку режима самого нижнего окна.

Эти параметры в основном полезны для дочерних фреймов
(@pxref{Child Frames}), которые поставляются без декораций оконного
менеджера.  При необходимости их можно использовать и для недекорированных
фреймов верхнего уровня.

@table @code
@vindex drag-internal-border@r{, параметр фрейма}
@item drag-internal-border
Если не-@code{nil}, размер фрейма можно изменить, перетащив его внутренние
границы, если они есть, с помощью мыши.

@vindex drag-with-header-line@r{, параметр фрейма}
@item drag-with-header-line
Если не-@code{nil}, фрейм можно перемещать с помощью мыши, перетаскивая
строку заголовка его самого верхнего окна.

@vindex drag-with-mode-line@r{, параметр фрейма}
@item drag-with-mode-line
Если не-@code{nil}, фрейм можно перемещать с помощью мыши, перетаскивая
строку режима его самого нижнего окна.  Обратить внимание, что такому фрейму
не разрешается иметь собственное окно минибуфера.

@vindex snap-width@r{, параметр фрейма}
@item snap-width
Фрейм, который перемещается с помощью мыши, будет ждать ``щелчок'' на
границе (ах) дисплея или его родительского кадра всякий раз, когда его
перетаскивают как можно ближе к такому краю, указанным количеством пикселей,
в этом параметре.

@vindex top-visible@r{, параметр фрейма}
@item top-visible
Если этот параметр является числом, верхний край фрейма никогда не
появляется над верхним краем его дисплея или родительского фрейма.  Более
того, столько пикселей фрейма задано этим числом, будет оставаться видимым,
когда фрейм перемещается по любому из оставшихся краев его дисплея или
родительского фрейма.  Установка этого параметра полезна для защиты от
перетаскивания дочернего фрейма с параметром не-@code{nil}
@code{drag-with-header-line} полностью за пределы его родительского фрейма.

@vindex bottom-visible@r{, параметр фрейма}
@item bottom-visible
Если параметр является числом, нижний край фрейма никогда не будет ниже
нижнего края его дисплея или родительского фрейма.  Более того, столько
пикселей фрейма, сколько задано этим числом, будет оставаться видимым, когда
фрейм перемещается по любому из оставшихся краев его дисплея или
родительского фрейма.  Установка этого параметра полезна для защиты от
перетаскивания дочернего фрейма с параметром не-@code{nil}
@code{drag-with-mode-line} полностью за пределы его родительского фрейма.
@end table


@node Management Parameters
@subsubsection Параметры Управления Окнами
@cindex window manager interaction, and frame parameters

  Следующие ниже параметры фрейма управляют различными аспектами
взаимодействия кадра с оконным менеджером или оконной системой.  Не влияют
на текстовые терминалы.

@table @code
@vindex visibility@r{, параметр фрейма}
@item visibility
Состояние видимости фрейма.  Есть три возможности: @code{nil} для
невидимого, @code{t} для видимого и @code{icon} для иконизированного.
@xref{Visibility of Frames}.

@vindex auto-raise@r{, параметр фрейма}
@item auto-raise
Если не-@code{nil}, Emacs автоматически поднимает фрейм при его выборе.
Некоторые оконные менеджеры не позволяют этого.

@vindex auto-lower@r{, параметр фрейма}
@item auto-lower
Если не-@code{nil}, Emacs автоматически опускает фрейм, когда он не выбран.
Некоторые оконные менеджеры не позволяют этого.

@vindex icon-type@r{, параметр фрейма}
@item icon-type
Тип значка, который будет использоваться для этого фрейма.  Если значение
является строкой, это указывает файл, содержащий растровое изображение для
использования; @code{nil} не указывает значок (в этом случае оконный
менеджер решает, что показывать); любое другое значение не-@code{nil}
определяет значок Emacs по умолчанию.

@vindex icon-name@r{, параметр фрейма}
@item icon-name
Имя для использования в значке этого фрейма, когда и если значок появляется.
Если это @code{nil}, используется заголовок фрейма.

@vindex window-id@r{, параметр фрейма}
@item window-id
Номер ID, используемый графическим дисплеем для этого фрейма.  Emacs
назначает этот параметр при создании фрейма; изменение параметра не влияет
на фактический номер ID.

@vindex outer-window-id@r{, параметр фрейма}
@item outer-window-id
Номер ID самого внешнего окна оконной системы, в котором существует фрейм.
Как и в случае с @code{window-id}, изменение этого параметра не имеет
фактического эффекта.

@vindex wait-for-wm@r{, параметр фрейма}
@item wait-for-wm
Если не-@code{nil}, указывает Xt дождаться, пока оконный менеджер подтвердит
изменения геометрии.  Некоторые оконные менеджеры, включая версии Fvwm2 и
KDE, не могут подтвердить, поэтому Xt зависает.  Установка для этого
параметра значения в @code{nil}, предотвратит зависание с этими оконными
менеджерами.

@vindex sticky@r{, параметр фрейма}
@item sticky
Если не-@code{nil}, фрейм виден на всех виртуальных рабочих столах в
системах с виртуальными рабочими столами.

@vindex inhibit-double-buffering@r{, параметр фрейма}
@item inhibit-double-buffering
Если не-@code{nil}, фрейм выводится на экран без двойной буферизации.  Emacs
обычно пытается использовать двойную буферизацию, где это возможно, для
уменьшения мерцания.  Установка этого свойства, решает возникающие ошибки
отображения или если требуется почувствовать ретро, flicker-y.

@vindex skip-taskbar@r{, параметр фрейма}
@item skip-taskbar
Если не-@code{nil}, это указывает диспетчеру окон удалить значок фрейма с
панели задач, связанной с отображением фрейма, и запретить переключение на
окно фрейма с помощью комбинации @kbd{Alt-@key{TAB}}.  В MS-Windows иконка
такого фрейма будет катиться???

@vindex no-focus-on-map@r{, параметр фрейма}
@item no-focus-on-map
Если не-@code{nil}, это означает, что фрейм не получает фокус ввода, когда
отображается в (@pxref{Visibility of Frames}).  Некоторые оконные менеджеры
могут не учитывать этот параметр.

@vindex no-accept-focus@r{, параметр фрейма}
@item no-accept-focus
Если не-@code{nil}, означает, что фрейм не получит фокус ввода посредством
явных щелчков мышью или при перемещении в него мыши используя
@code{focus-follows-mouse} (@pxref{Input Focus}) или
@code{mouse-autoselect-window} (@pxref{Mouse Window Auto-selection}).  Это
может иметь нежелательный побочный эффект, заключающийся в том, что
пользователь не может прокручивать невыбранный фрейм с помощью мыши.
Некоторые оконные менеджеры могут не учитывать этот параметр.

@vindex undecorated@r{, параметр фрейма}
@item undecorated
Если не-@code{nil}, окно оконной системы этого фрейма отрисовывается без
украшений, таких как заголовок, минимизация/развертывание блоков и внешних
границ.  Обычно это означает, что окно нельзя перетаскивать, изменять
размер, уменьшать, увеличивать или удалять с помощью мыши.  Если @code{nil},
окно фрейма обычно рисуется со всеми перечисленными выше элементами, если их
отображение не было приостановлено в настройках оконного менеджера.

В X Emacs использует подсказки оконного менеджера Motif для отключения
декораций.  Некоторые оконные менеджеры могут не соблюдать эти подсказки.

Сборки NS рассматривают панель инструментов как украшение и поэтому скрывают
ее на недекорированном фрейме.

@vindex override-redirect@r{, параметр фрейма}
@item override-redirect
@cindex override redirect frames
Если не-@code{nil}, означает, что @dfn{переопределяется перенаправление}
фрейма --- фрейм, не обрабатывается оконными менеджерами в X.
Переопределить фреймы перенаправления не имеют декораций оконного менеджера,
их можно позиционировать и изменять размер только с помощью функций
позиционирования и изменения размера Emacs и обычно рисуются поверх всех
остальных фреймов.  Установка этого параметра не работает на MS-Windows.

@ignore
@vindex parent-id@r{, параметр фрейма}
@item parent-id
@c ??? Еще не работает.
Номер X окна, которое должно быть родительским для этого окна.  Указание
этого позволяет создать окно Emacs внутри окна другого приложения.  (Нет
уверенности, что это будет реализовано; попробуйте и посмотрите, работает
ли.)
@end ignore

@vindex ns-appearance@r{, параметр фрейма}
@item ns-appearance
Доступно только в macOS, если установлено значение @code{dark}, рисовать
окно оконной системы этого фрейма с использованием темы ``vibrant dark'', в
противном случае использовать системное значение по умолчанию.  Тема
``vibrant dark'' может использоваться для установки темного вида панели
инструментов и полос прокрутки при использовании темы Emacs с темным фоном.

@vindex ns-transparent-titlebar@r{, параметр фрейма}
@item ns-transparent-titlebar
Доступно только в macOS, если не-@code{nil}, установить прозрачность
заголовка и панели инструментов.  Это эффективно устанавливает цвета фона
обоих в соответствии с цветом фона Emacs.
@end table


@node Cursor Parameters
@subsubsection Параметры Курсора
@cindex cursor, and frame parameters

  Этот параметр фрейма управляет тем, как выглядит курсор.

@table @code
@vindex cursor-type@r{, параметр фрейма}
@item cursor-type
Как вывести курсор.  Значущие идентификаторы:

@table @code
@item box
Отобразить заполненное поле. (Это значение по умолчанию.)
@item hollow
Показать пустое поле.
@item nil
Не отображать курсор.
@item bar
Отобразить вертикальную полосу между символами.
@item (bar . @var{width})
Отобразить вертикальную полосу шириной @var{width} пикселей между символами.
@item hbar
Отобразите горизонтальную полосу.
@item (hbar . @var{height})
Отобразить горизонтальную полосу высотой @var{height} пикселей.
@end table
@end table

@vindex cursor-type
Параметр фрейма @code{cursor-type} может быть переопределен переменными
@code{cursor-type} и @code{cursor-in-non-selected-windows}:

@defopt cursor-type
Локальная переменная буфера управляет тем, как будет выглядеть курсор в
выбранном окне, показывающем буфер.  Если её значение - @code{t}, это
означает использование курсора, заданного параметром фрейма
@code{cursor-type}.  В противном случае значение должно быть одним из
перечисленных выше типов курсора, и оно переопределяет параметр фрейма
@code{cursor-type}.
@end defopt

@defopt cursor-in-non-selected-windows
Локальная переменная буфра управляет тем, как курсор выглядит в окне,
которое не выбрано.  Поддерживает те же значения, что и параметр фрейма
@code{cursor-type}; Кроме того, @code{nil} означает, что курсор не
отображается в невыделенных окнах, а @code{t} (по умолчанию) означает
использование стандартной модификации обычного типа курсора (сплошная рамка
становится пустой рамкой, а полоса становится более узкой полосой).
@end defopt

@defopt x-stretch-cursor
Переменная управляет шириной блока курсора, отображаемого на очень широких
глифах, таких как табуляция или отрезок пробельного пространства.  По
умолчанию ширина блочного курсора равна ширине символа шрифта по умолчанию,
и не будет охватывать всю ширину глифа под ним, если этот глиф является
сверхшироким.  Значение не-@code{nil} этой переменной означает рисование
курсора блока шириной с глифом под ним.  Значение по умолчанию - @code{nil}.

Переменная не влияет на фреймы текстового режима, поскольку курсор
текстового режима выводится терминалом из-под контроля Emacs.
@end defopt

@defopt blink-cursor-alist
Переменная определяет, мирцание курсора.  Каждый элемент имеет вид
@code{(@var{on-state} . @var{off-state})}.  Когда тип курсора равен
@var{on-state} (сравнение с использованием @code{equal}), соответствующий
@var{off-state} указывает, как выглядит курсор, когда мигает.  Оба
@var{on-state} и @var{off-state} должны быть подходящими значениями для
параметра фрейма @code{cursor-type}.

Существуют различные значения по умолчанию для установки каждого типа
мигания курсора, если тип здесь не указан как @var{on-state}.  Изменения в
этой переменной не вступают в силу немедленно, если только не указан
параметр фрейма @code{cursor-type}.
@end defopt

@node Font and Color Parameters
@subsubsection Параметры Шрифта и Цвета
@cindex font and color, frame parameters

  Эти параметры фрейма управляют использованием шрифтов и цветов.

@table @code
@vindex font-backend@r{, параметр фрейма}
@item font-backend
Список символов с указанием @dfn{бекендов шрифтов}, которые будут
использоваться для рисования шрифтов во фрейме, в порядке приоритета.  В X
в настоящее время доступны два бэкенда шрифтов: @code{x} (драйвер шрифта
ядра X) и @code{xft} (драйвер шрифта Xft).  В MS-Windows в настоящее время
доступны два бэкенда шрифтов: @code{gdi} и @code{uniscribe}
(@pxref{Windows Fonts,,, emacs, The GNU Emacs Manual}).  В других системах
доступен только один бэкэнд шрифтов, поэтому нет смысла изменять этот
параметр фрейма.

@vindex background-mode@r{, параметр фрейма}
@item background-mode
Параметр имеет значение @code{dark} или @code{light}, в зависимости от того,
какой цвет фона - светлый или темный.

@vindex tty-color-mode@r{, параметр фрейма}
@item tty-color-mode
@cindex standard colors for character terminals
Параметр переопределяет цветовую поддержку терминала, заданную системной
базой данных возможностей терминала, поскольку значение этого параметра
определяет цветовой режим для использования на текстовом терминале.
Значение может быть символом или числом.  Число указывает количество
используемых цветов (и, косвенно, то, какие команды выполнять для получения
каждого цвета).  Например, @code{(tty-color-mode . 8)} определяет
использование управляющих последовательностей ANSI для 8 стандартных цветов
текста.  Значение @minus{}1 отключает поддержку цвета.

Если значением параметра является символ, указывается число через значение
@code{tty-color-mode-alist}, и вместо него используется связанное число.

@vindex screen-gamma@r{, параметр фрейма}
@item screen-gamma
@cindex gamma correction
Если это число, Emacs выполняет гамма-коррекцию, которая регулирует яркость
всех цветов.  Значение должно быть гаммой экрана вашего дисплея.

Обычные мониторы ПК имеют гамму экрана 2.2, поэтому значения цвета в Emacs и
в X-окнах в целом откалиброваны для правильного отображения на мониторе с
этим значением гаммы.  Если указывается 2.2 для @code{screen-gamma}, это
означает, что исправление не требуется.  Другие значения требуют коррекции,
чтобы скорректированные цвета отображались на вашем экране так, как они
выглядели бы без коррекции на обычном мониторе со значением гаммы 2.2.

Если монитор отображает слишком светлые цвета, потребуется указать значение
@code{screen-gamma} меньше, чем 2.2.  Это требует коррекции, которая делает
цвета темнее.  Значение гаммы экрана 1.5 может дать хорошие результаты для
цветных дисплеев LCD.

@vindex alpha@r{, параметр фрейма}
@item alpha
@cindex opacity, frame
@cindex transparency, frame
@vindex frame-alpha-lower-limit
Параметр определяет непрозрачность фрейма на графических дисплеях,
поддерживающих переменную непрозрачность.  Это должно быть целое число от 0
до 100, где 0 означает полностью прозрачный, а 100 означает полностью
непрозрачный.  Также может иметь значение @code{nil}, которое говорит Emacs
не устанавливать непрозрачность фрейма (оставив это оконному менеджеру).

Чтобы фрейм не исчез полностью из поля зрения, переменная
@code{frame-alpha-lower-limit} определяет нижний предел непрозрачности.
Если значение параметра фрейма меньше значения этой переменной, Emacs
использует последнее.  По умолчанию @code{frame-alpha-lower-limit} равно 20.

Параметр фрейма @code{alpha} также может быть cons-ячейкой
@code{(@var{active} . @var{inactive})}, где @var{active} - это
непрозрачность фрейма, когда он выбран, а @var{inactive} - это
непрозрачность, когда он не выбран.

Некоторые оконные системы не поддерживают параметр @code{alpha} для дочерних
фреймов (@pxref{Child Frames}).
@end table

Следующие параметры фрейма частично устарели в том смысле, что они
автоматически эквивалентны определенным атрибутам вида определенных видов
(@pxref{Standard Faces,,, emacs, The Emacs Manual}):

@table @code
@vindex font@r{, параметр фрейма}
@item font
Название шрифта для отображения текста во фрейме.  Это строка, либо
допустимое имя шрифта для системы, либо имя набора шрифтов Emacs
(@pxref{Fontsets}).  Эквивалентено атрибуту @code{font} вида @code{default}.

@vindex foreground-color@r{, параметр фрейма}
@item foreground-color
Цвет изображения символа.  Эквивалентно атрибуту @code{:foreground} вида
@code{default}.

@vindex background-color@r{, параметр фрейма}
@item background-color
Цвет фона символов.  Эквивалентен атрибуту @code{:background} вида
@code{default}.

@vindex mouse-color@r{, параметр фрейма}
@item mouse-color
Цвет указателя мыши.  Эквивалентно атрибуту @code{:background} вида
@code{mouse}.

@vindex cursor-color@r{, параметр фрейма}
@item cursor-color
Цвет курсора, который показывает точку.  Эквивалентно атрибуту
@code{:background} вида @code{cursor}.

@vindex border-color@r{, параметр фрейма}
@item border-color
Цвет границы фрейма.  Эквивалентно атрибуту @code{:background} вида
@code{border}.

@vindex scroll-bar-foreground@r{, параметр фрейма}
@item scroll-bar-foreground
Если не-@code{nil}, цвет переднего плана полос прокрутки.  Эквивалентно
атрибуту @code{:foreground} вида @code{scroll-bar}.

@vindex scroll-bar-background@r{, параметр фрейма}
@item scroll-bar-background
Если не-@code{nil}, цвет фона полос прокрутки.  Эквивалентно атрибуту
@code{:background} вида @code{scroll-bar}.
@end table


@node Geometry
@subsection Геометрия

  Вот как проверить данные в спецификации геометрии окна в стиле X:

@defun x-parse-geometry geom
@cindex geometry specification
Функция @code{x-parse-geometry} преобразует стандартную строку геометрии
окна X в список, который можно использовать как часть аргумента
@code{make-frame}.

Список описывает, какие параметры были указаны в @var{geom}, и дает
значения, указанные для них.  Каждый элемент выглядит как
@code{(@var{parameter} . @var{value})}.  Возможные значения @var{parameter}:
@code{left}, @code{top}, @code{width} и @code{height}.

Для параметров размера значение должно быть целым числом.  Имена параметров
положения @code{left} и @code{top} не совсем точны, потому что некоторые
значения вместо этого указывают положение правого или нижнего края.
Возможности @var{value} для параметров позиции: целое число, список
@code{(+ @var{pos})} или список @code{(- @var{pos})}; как описано ранее
(@pxref{Position Parameters}).

Вот пример:

@example
(x-parse-geometry "35x70+0-0")
     @result{} ((height . 70) (width . 35)
         (top - 0) (left . 0))
@end example
@end defun

@node Terminal Parameters
@section Параметры Терминала
@cindex terminal parameters

  Каждый терминал имеет список связанных параметров.  Эти
@dfn{параметры терминала} в основном представляют собой удобный способ
хранения локальных переменных терминала, но некоторые параметры терминала
имеют особое значение.

  В этом разделе описаны функции для чтения и изменения значений параметров
терминала.  Все они принимают в качестве аргумента либо терминал, либо
фрейм; последнее означает использование терминала этого фрейма.  Аргумент
@code{nil} означает терминал выбранного фрейма.

@defun terminal-parameters &optional terminal
Функция возвращает список, в котором перечислены все параметры
@var{terminal} и их значения.
@end defun

@defun terminal-parameter terminal parameter
Функция возвращает значение параметра @var{parameter} (символ) объекта
@var{terminal}.  Если @var{terminal} не имеет настройки для @var{parameter},
эта функция возвращает @code{nil}.
@end defun

@defun set-terminal-parameter terminal parameter value
Функция устанавливает для параметра @var{parameter} объекта @var{terminal}
значение указанного объекта @var{value} и возвращает предыдущее значение
этого параметра.
@end defun

Вот список нескольких параметров терминала, которые имеют особое значение:

@table @code
@item background-mode
Классификация цвета фона терминала: @code{light} или @code{dark}.
@item normal-erase-is-backspace
Значение равно 1 или 0, в зависимости от того, включен или выключен
@code{normal-erase-is-backspace-mode} на этом терминале.
@xref{DEL Does Not Delete,,, emacs, The Emacs Manual}.
@item terminal-initted
После инициализации терминала устанавливается функция инициализации,
специфичная для терминала.
@item tty-mode-set-strings
Если присутствует, список строк, содержащих escape-последовательности,
которые Emacs будет выводить при настройке tty для рендеринга.  Emacs
генерирует эти строки только при настройке терминала: если требуется
включить режим на терминале, который уже активен (например, находясь в
@code{tty-setup-hook}), явно вводится необходимая escape-последовательность
с помощью @code{send-string-to-terminal} в дополнение к добавлению
последовательности в @code{tty-mode-set-strings}.
@item tty-mode-reset-strings
Если присутствует, список строк, отменяющих эффекты строк в
@code{tty-mode-set-strings}.  Emacs выдает эти строки при выходе, удалении
терминала или приостановке работы.
@end table

@node Frame Titles
@section Заголовки Фреймов
@cindex frame title

  Каждый фрейм имеет параметр @code{name}; это используется по умолчанию для
заголовка фрейма, который оконные системы обычно отображают в верхней части
фрейма.  Можно указать имя явно, установив свойство фрейма @code{name}.

  Обычно не указывается имя явно, и Emacs автоматически вычисляет имя фрейма
на основе шаблона, хранящегося в переменной @code{frame-title-format}.
Emacs пересчитывает имя каждый раз при повторном отображении фрейма.

@defvar frame-title-format
Переменная указывает, как вычислить имя для фрейма, если не указано оно
явно.  Значение переменной фактически является конструкцией строки режима,
как и @code{mode-line-format}, за исключением того, что конструкции
@samp{%c}, @samp{%C} и @samp{%l} игнорируются.  @xref{Mode Line Data}.
@end defvar

@defvar icon-title-format
Переменная указывает, как вычислить имя для фрейма с иконкой, если явно не
указан заголовок фрейма.  Этот заголовок отображается в самом значке.
@end defvar

@defvar multiple-frames
Переменная автоматически устанавливается Emacs.  Её значение @code{t}, когда
есть два или более фреймов (не считая фреймов только для минибуфера или
невидимых фреймов).  Значение по умолчанию @code{frame-title-format}
использует @code{multiple-frames}, чтобы поместить имя буфера в заголовок
фрейма, только когда имеется более одного фрейма.

Не гарантируется, что значение этой переменной будет точным, за исключением
обработки @code{frame-title-format} или @code{icon-title-format}.
@end defvar

@node Deleting Frames
@section Удаление Фреймов
@cindex deleting frames

@dfn{Активный фрейм} - это тот, который не был удален.  Когда фрейм
удаляется, он удаляется со своего терминального дисплея, хотя может
продолжать существовать как объект Lisp до тех пор, пока на него не исчезнут
ссылки.

@deffn Command delete-frame &optional frame force
@vindex delete-frame-functions
Функция удаляет фрейм @var{frame}.  Аргумент @var{frame} должен указывать
активный фрейм (смотреть ниже) и по умолчанию использовать выбранный фрейм.

Сначала удаляется любой дочерний кадр @var{frame} (@pxref{Child Frames}) и
любой фрейм, параметр фрейма @code{delete-before} которого
(@pxref{Frame Interaction Parameters}) указывает @var{frame}.  Все такие
удаления выполняются рекурсивно; поэтому этот шаг гарантирует, что никаких
других фреймов с @var{frame} в качестве предка не будет.  Затем, если
@var{frame} не указывает всплывающую подсказку, эта функция запускает
ловушку @code{delete-frame-functions} (каждая функция получает один
аргумент, @var{frame}) перед фактическим уничтожением фрейма.

Обратить внимание, что фрейм не может быть удален, пока его минибуфер служит
суррогатным минибуфером для другого фрейма (@pxref{Minibuffers and Frames}).
Обычно не получиться удалить фрейм, если все остальные фреймы невидимы, но
если @var{force} равен не-@code{nil}, это сделать возможно.
@end deffn

@defun frame-live-p frame
Функция возвращает не-@code{nil}, если фрейм @var{frame} не был удален.
Возможные возвращаемые значения не-@code{nil} аналогичны значениям
@code{framep}.  @xref{Frames}.
@end defun

  Некоторые оконные менеджеры предоставляют команду для удаления окна.  Они
работают, отправляя специальное сообщение программе, которая управляет
окном.  Когда Emacs получает одну из этих команд, он генерирует событие
@code{delete-frame}, обычным определением которого является команда,
вызывающая функцию @code{delete-frame}.  @xref{Misc Events}.

@deffn Command delete-other-frames &optional frame
Команда удаляет все фреймы на терминале @var{frame}, кроме @var{frame}.
Если @var{frame} использует минибуфер другого фрейма, этот фрейм минибуфера
остается нетронутым.  Аргумент @var{frame} должен указывать активный фрейм
и по умолчанию использовать выбранный фрейм.  Внутренне эта команда
работает, вызывая @code{delete-frame} с @var{force} @code{nil} для всех
фреймов, которые должны быть удалены.

Функция не удаляет ни один из дочерних кадров @var{frame}
(@pxref{Child Frames}).  Если @var{frame} является дочерним фреймом, он
удаляет только одноуровневые объекты @var{frame}.
@end deffn


@node Finding All Frames
@section Поиск Всех Фреймов
@cindex frames, scanning all

@defun frame-list
Функция возвращает список всех активных фреймов, то есть тех, которые не
были удалены.  Аналогичено @code{buffer-list} для буферов и включает фреймы
на всех терминалах.  Список, который получается, создается заново, поэтому
изменение списка не влияет на внутреннюю структуру Emacs.
@end defun

@defun visible-frame-list
Функция возвращает список только видимых в данный момент фреймов.
@xref{Visibility of Frames}.  Фреймы на текстовых терминалах всегда
считаются видимыми, даже если фактически отображается только выбранный.
@end defun

@defun frame-list-z-order &optional display
Функция возвращает список фреймов Emacs в порядке Z (стекирования)
(@pxref{Raising and Lowering}).  Необязательный аргумент @var{display}
указывает, какой дисплей следует опросить.  @var{display} должен быть либо
фреймом, либо отображаемым именем (строкой).  Если опущено или @code{nil},
это означает отображение выбранного фрейма.  Возвращается @code{nil}, если
@var{display} не содержит фрейма Emacs.

Фреймы перечислены от самого верхнего (первого) до самого нижнего
(последнего).  В качестве особого случая, если @var{display} имеет значение
не-@code{nil} и задается активный фрейм, возвращаются дочерние фреймы этого
фрейма в Z (наложении) порядке.

Эта функция не имеет смысла для текстовых терминалов.
@end defun

@defun next-frame &optional frame minibuf
Функция позволяет удобно циклически перебирать все фреймы на конкретном
терминале с произвольной начальной точки.  Возвращается фрейм, следующий за
@var{frame}, в списке всех активных фреймов на терминале @var{frame}.
Аргумент @var{frame} должен указывать активный фрейм и по умолчанию
использовать выбранный фрейм.  Никогда не возвращается фрейм, у которого
параметр @code{no-other-frame} (@pxref{Frame Interaction Parameters}) равен
не-@code{nil}.

Второй аргумент, @var{minibuf}, говорит, какие фреймы следует учитывать:

@table @asis
@item @code{nil}
Исключить фреймы только для минибуфера.
@item @code{visible}
Учитывать все видимые фреймы.
@item 0
Учитывать все видимые или иконизированные фреймы.
@item a window
Рассматривать только фреймы, использующие это конкретное окно в качестве
своего минибуфера.
@item anything else
Рассмотреть все фреймы.
@end table
@end defun

@defun previous-frame &optional frame minibuf
Аналогично @code{next-frame}, но циклически перебирает все фреймы в
противоположном направлении.
@end defun

  Смотреть также @code{next-window} и @code{previous-window}, в
  @ref{Cyclic Window Ordering}.

@node Minibuffers and Frames
@section Минибуферы и Фреймы

Обычно у каждого фрейма есть собственное окно минибуфера внизу, которое
используется всякий раз, когда этот фрейм выбирается.  Можно получить это
окно с помощью функции @code{minibuffer-window}
(@pxref{Minibuffer Windows}).

@cindex frame without a minibuffer
@cindex surrogate minibuffer frame
Однако также можно создать фрейм без минибуфера.  Такой фрейм должен
использовать окно минибуфера какого-либо другого фрейма.  Этот другой фрейм
будет служить @dfn{фреймом суррогатного минибуфера} для этого фрейма и не
может быть удален через @code{delete-frame} (@pxref{Deleting Frames}), пока
этот фрейм существует.

Когда создается фрейм, можно явно указать его окно минибуфера (в каком-то
другом фрейме) с параметром @code{minibuffer} frame
(@pxref{Buffer Parameters}).  Если этого не сделаеть, то минибуфер находится
в фрейме, который указывается значением переменной
@code{default-minibuffer-frame}.  Этим значением должен быть фрейм, у
которого есть минибуфер.

Если используется фрейм только для минибуфера, можно захотеть, чтобы этот
фрейм поднимался при входе в минибуфер.  Если это так, установить для
переменной @code{minibuffer-auto-raise} значение @code{t}.
@xref{Raising and Lowering}.

@defvar default-minibuffer-frame
Переменная определяет фрейм, используемый по умолчанию для окна минибуфера.
Это не влияет на существующие фреймы.  Всегда локальна для текущего
терминала и не может быть локальным для буфера.  @xref{Multiple Terminals}.
@end defvar


@node Input Focus
@section Входной Фокус
@cindex input focus
@cindex selected frame

В любой момент один фрейм в Emacs - это @dfn{выбранный фрейм}.  Выбранное
окно всегда находится на выбранном фрейме.

Когда Emacs отображает свои фреймы на нескольких терминалах
(@pxref{Multiple Terminals}), каждый терминал имеет свой собственный
выбранный фрейм.  Но только один из них - @emph{это} выбранный фрейм:
фрейм, принадлежащий терминалу, с которого был получен последний ввод.  То
есть, когда Emacs запускает команду, пришедшую с определенного терминала,
выбранный фрейм является фреймом этого терминала.  Поскольку Emacs запускает
только одну команду в любой момент времени, ему нужно рассматривать только
один выбранный фрейм за раз; этот фрейм называется @dfn{выбранный фрейм} в
этом руководстве.  Дисплей, на котором отображается выбранный кадр, - это
@dfn{отображение выбранного кадра}.

@defun selected-frame
Функция возвращает выбранный фрейм.
@end defun

Некоторые оконные системы и оконные менеджеры направляют ввод с клавиатуры
на объект окна, в котором находится мышь; другие требуют явных щелчков или
@dfn{сместить фокус} команд для  различных оконных объектов.  В любом случае
Emacs автоматически отслеживает, какой фрейм находится в фокусе.  Чтобы явно
переключиться на другой фрейм из функции Lisp, вызвать
@code{select-frame-set-input-focus}.

Программы Lisp также могут временно переключать фреймы, вызывая функцию
@code{select-frame}.  Это не меняет концепции фокуса оконной системы;
скорее, ускользается из-под управления оконного менеджера до тех пор, пока
это управление каким-либо образом не будет подтверждено повторно.

При использовании текстового терминала одновременно на терминале может
отображаться только один фрейм, поэтому после вызова @code{select-frame}
следующее повторное отображение фактически отображает только что выбранный
фрейм.  Этот фрейм остается выбранным до следующего вызова
@code{select-frame}.  Каждый фрейм на текстовом терминале имеет номер,
который появляется в строке режима перед именем буфера
(@pxref{Mode Line Variables}).

@defun select-frame-set-input-focus frame &optional norecord
Функция выбирает @var{frame}, поднимает его (если оказывается закрытым
другими фреймами) и пытается передать ему фокус X-сервера.  На текстовом
терминале следующее повторное отображение отображает новый фрейм на всем
экране терминала.  Необязательный аргумент @var{norecord} имеет то же
значение, что и @code{select-frame} (смотреть ниже).  Возвращаемое значение
этой функции не имеет значения.
@end defun

В идеале описанная далее функция должна фокусировать фрейм, не поднимая его
над другими фреймами.  К сожалению, многие оконные системы или оконные
менеджеры могут отказаться подчиняться.

@defun x-focus-frame frame &optional noactivate
Функция дает @var{frame} фокус X-сервера без необходимости его поднятия.
@var{frame} установленное в @code{nil} означает использовать выбранный
фрейм.  В X необязательный аргумент @var{noactivate}, если не-@code{nil},
означает, что окно @var{frame} оконной системы не должно быть ``активным''
окном, которое должно настаивать на том, чтобы не поднимать @var{frame} над
другими фреймами.

В MS-Windows аргумент @var{noactivate} не действует.  Однако, если
@var{frame} является дочерним фреймом (@pxref{Child Frames}), функция обычно
фокусирует @var{frame}, не поднимая его над другими дочерними кадрами.

Если нет поддержки оконной системы, эта функция ничего не делает.
@end defun

@deffn Command select-frame frame &optional norecord
Функция выбирает фрейм @var{frame}, временно игнорируя фокус X-сервера, если
таковой имеется.  Выбор @var{frame} длится до следующего раза, когда
пользователь что-то сделает для выбора другого фрейма, или до следующего
вызова этой функции.  (Если используется оконная система, ранее выбранный
фрейм может быть восстановлен как выбранный фрейм после возврата в цикл
команд, потому что все еще может иметься фокус ввода оконной системы.)

Указанный @var{frame} становится выбранным фреймом, а его терминал
становится выбранным терминалом.  Затем функция вызывает
@code{select-window} как подпрограмму, передавая окно, выбранное в
@var{frame}, в качестве первого аргумента и @var{norecord} в качестве
второго аргумента (следовательно, если @var{norecord} - не-@code{nil}, это
позволяет избежать изменения порядка недавно выбранных окон и списка
буферов).  @xref{Selecting Windows}.

Функция возвращает @var{frame} или @code{nil}, если @var{frame} был удален. 

В общем, никогда не нужно использовать @code{select-frame} таким образом,
чтобы можно было переключиться на другой терминал, не переключаясь обратно,
в конце.
@end deffn

Emacs взаимодействует с оконной системой, организуя выбор фреймов в качестве
запросов сервера и оконного менеджера.  Делает это, генерируя особый вид
входного события, называемого событием @dfn{фокус}, когда это необходимо.
Командный цикл обрабатывает событие фокуса, вызывая
@code{handle-switch-frame}.  @xref{Focus Events}.

@deffn Command handle-switch-frame frame
Функция обрабатывает событие фокуса, выбирая кадр @var{frame}.

События фокуса обычно выполняют свою работу, вызывая эту команду.
Не вызывать это по какой-либо другой причине.
@end deffn

@defun redirect-frame-focus frame &optional focus-frame
Функция перенаправляет фокус с @var{frame} на @var{focus-frame}.  Это
означает, что @var{focus-frame} будет получать последующие нажатия клавиш и
события, предназначенные для @var{frame}.  После такого события значение
@code{last-event-frame} будет @var{focus-frame}.  Кроме того, события
switch-frame, указывающие @var{frame}, вместо этого выберут
@var{focus-frame}.

Если @var{focus-frame} опущен или @code{nil}, это отменяет любое
существующее перенаправление для @var{frame}, которое, таким образом, снова
получает свои собственные события.

Одно из применений перенаправления фокуса - для фреймов, у которых нет
минибуферов.  Эти фреймы используют минибуферы на других фреймах.  Активация
минибуфера на другом фрейме перенаправляет фокус на этот фрейм.  Это
помещает фокус на фрейм минибуфера, которому он принадлежит, даже если мышь
остается в фрейме, который активировал минибуфер.

Выбор фрейма также может изменить перенаправление фокуса.  Выбор фрейма
@code{bar}, когда был выбран @code{foo}, изменяет любые перенаправления,
указывающие на @code{foo}, так, чтобы вместо этого они указывали на
@code{bar}.  Это позволяет перенаправлению фокуса работать правильно, когда
пользователь переключается с одного кадра на другой с помощью
@code{select-window}.

Это означает, что фрейм, фокус которого перенаправлен на себя,
обрабатывается иначе, чем фрейм, фокус которого не перенаправлен.
@code{select-frame} влияет на первое, но не на второе.

Перенаправление длится до тех пор, пока не будет вызвана функция
@code{redirect-frame-focus} для его изменения.
@end defun

@defvar focus-in-hook
Нормальный запуск ловушки, когда фрейм Emacs получает фокус ввода.
Фокусировка кадра выбирается, когда этот хук запущен.
@end defvar

@defvar focus-out-hook
Нормальный запуск ловушки, когда фрейм Emacs потерял фокус ввода и вместо
этого никакой другой фрейм Emacs не получил фокус ввода.
@end defvar

@defopt focus-follows-mouse
Опция сообщает Emacs, передает ли оконный менеджер фокус, когда перемещается
указатель мыши во фрейм, и каким образом.  Может иметь три значимых
значения:

@table @asis
@item @code{nil}
Значение по умолчанию @code{nil} следует использовать, когда оконный
менеджер следует политике ``щелчок для фокусировки'', где требуется щелкнуть
мышью внутри фрейма, чтобы этот фрейм получил фокус.

@item @code{t}
Значение @code{t} следует использовать, когда оконный менеджер имеет фокус,
автоматически отслеживающий положение указателя мыши, но фрейм, который
получает фокус, не поднимается автоматически и может даже оставаться
закрытым другими окнами оконной системы.

@item @code{auto-raise}
Значение @code{auto-raise} следует использовать, когда оконный менеджер
имеет фокус, который автоматически следует за положением указателя мыши, а
фрейм, который получает фокус, поднимается автоматически.
@end table

Если эта опция - не-@code{nil}, Emacs перемещает указатель мыши на фрейм,
выбранный @code{select-frame-set-input-focus}.  Функция используется рядом
команд, например, @code{other-frame} и @code{pop-to-buffer}.

Различие между значениями @code{t} и @code{auto-raise} не требуется для
``нормальных'' фреймов, потому что оконный менеджер обычно заботится об их
повышении.  Полезно автоматически поднимать дочерние фреймы через
@code{mouse-autoselect-window} (@pxref{Mouse Window Auto-selection}).

Обратить внимание, что этот параметр не различает ``небрежный'' фокус (где
фрейм, у которого ранее был фокус, сохраняет фокус, пока указатель мыши не
перемещается в другое окно оконного менеджера) от фокуса ``строгий'' (где
фрейм сразу теряет фокус, когда его оставляет мышь указатель).  Также не
распознается, поддерживает ли оконный менеджер отложенную фокусировку или
автоподъем, где можете явно указать время до тех пор, пока новый фрейм не
получит фокус или не будет автоматически поднят.

Можете предоставить политику ``фокус следует за мышью'' для отдельных окон
Emacs, настроив переменную @code{mouse-autoselect-window}
(@pxref{Mouse Window Auto-selection}).
@end defopt


@node Visibility of Frames
@section Видимость Фреймов
@cindex visible frame
@cindex invisible frame
@cindex iconified frame
@cindex minimized frame
@cindex frame visibility

Фрейм на графическом дисплее может иметь размер @dfn{видимый},
@dfn{невидимый} или @dfn{иконизированный}.  Если виден, его содержимое
отображается обычным образом.  Если обозначен значком, его содержимое не
отображается, но где-то есть маленький значок, чтобы вернуть фрейм в поле
зрения (некоторые оконные менеджеры называют это состояние
@dfn{минимизированное}, а не @dfn{иконизированное}, но с точки зрения Emacs
это одно и тоже).  Если фрейм невидим, он вообще не отображается.

@cindex mapped frame
@cindex unmapped frame
  Концепция видимости тесно связана с концепцией (не) отображенных фреймов.
Фрейм (или, точнее, его окно оконной системы) есть и становится
@dfn{нанесенным на карту}, когда отображается в первый раз и всякий раз,
когда меняет свое состояние видимости с @code{иконизированного} или
@code{невидимого} на @code{видимое}.  И наоборот, фрейм становится
@dfn{не нанесенный на карту} всякий раз, когда он меняет свой статус с
@code{видимого} на @code{иконизированное} или @code{невидимое}.

  Видимость не имеет смысла на текстовых терминалах, поскольку в любом
случае фактически отображается только выбранный фрейм.

@defun frame-visible-p frame
Функция возвращает статус видимости фрейма @var{frame}.  Значение -
@code{t}, если @var{frame} виден, @code{nil}, если он невидим, и
@code{icon}, если он обозначен иконкой.

В текстовом терминале все фреймы считаются видимыми для этой функции, даже
если отображается только один фрейм.
@xref{Raising and Lowering}.
@end defun

@deffn Command iconify-frame &optional frame
Функция обозначает фрейм @var{frame}.  Если не указано @var{frame},
выбранный фрейм будет отмечен значком.  Обычно это делает все дочерние
фреймы @var{frame} (и их потомки) невидимыми (@pxref{Child Frames}).
@end deffn

@deffn Command make-frame-visible &optional frame
Функция делает видимым фрейм @var{frame}.  Если не указать @var{frame},
выбранный кадр станет видимым.  Это не поднимает фрейм, но можно сделать это
с помощью @code{raise-frame}, если хотите (@pxref{Raising and Lowering}).

Когда фрейм становится видимым, обычно все его дочерние фреймы (и их
потомки) также становятся видимыми (@pxref{Child Frames}).
@end deffn

@deffn Command make-frame-invisible &optional frame force
Функция делает невидимым фрейм @var{frame}.  Если опустить @var{frame},
выбранный фрейм станет невидимым.  Обычно это делает все дочерние фреймы
@var{frame} (и их потомки) также невидимыми (@pxref{Child Frames}).

Если @var{force} не является не-@code{nil}, функция отказывается делать
@var{frame} невидимым, если все остальные фреймы невидимы.
@end deffn

  Статус видимости фрейма также доступен как параметр фрейма.  Можно
прочитать или изменить его как таковой.  @xref{Management Parameters}.
Пользователь также может уменьшать и деактивировать фреймы с помощью
оконного менеджера.  Это происходит ниже уровня, на котором Emacs может
осуществлять любое управление, но Emacs действительно предоставляет события,
которые можно использовать для отслеживания таких изменений.
@xref{Misc Events}.

@defun x-double-buffered-p &optional frame
Функция возвращает не-@code{nil}, если @var{frame} в настоящее время
визуализируется с двойной буферизацией.  @var{frame} по умолчанию
использует выбранный фрейм.
@end defun


@node Raising and Lowering
@section Подъем, Опускание и Перестановка рам

@cindex raising a frame
@cindex lowering a frame
@cindex restacking a frame
@cindex frame stacking order
@cindex frame Z-order
@cindex Z-order
  В большинстве оконных систем используется метафора рабочего стола.  Частью
этой метафоры является идея о том, что окна системного уровня
(представляющие, например, фреймы Emacs) располагаются в условном третьем
измерении, перпендикулярном поверхности экрана.  Порядок, вызванный
наложением, является полным и обычно называется порядком наложения (или Z-)
порядком.  Там, где области двух окон перекрываются, то, что находится выше
в этом порядке, будет (частично) закрывать нижнее.

  Можно @dfn{поднимать} фрейм вверх этого порядка или @dfn{опускать} фрейм
вниз, используя функции @code{raise-frame} и @code{lower-frame}.  Можно
@dfn{перекладывать заново} фрейм непосредственно над или под другим фреймом,
используя функцию @code{frame-restack}.

  Обратить внимание, что все функции, описанные ниже, будут учитывать
привязку фреймов (и всех других окон оконной системы) к их соответствующей
z-группе (@pxref{Position Parameters}).  Например, обычно не получиться
опустить фрейм ниже окна рабочего стола, и не выйдет поднять фрейм, параметр
@code{z-group} которого равен @code{nil}, над панелью задач оконной системы
или окном всплывающей подсказки.

@deffn Command raise-frame &optional frame
Функция поднимает фрейм @var{frame} (по умолчанию, выбранный фрейм) над
всеми другими фреймами, принадлежащими той же или более низкой z-группе, что
и @var{frame}.  Если @var{frame} невидим или обозначен значком, он
становится видимым.  Если @var{frame} является дочерним фреймом
(@pxref{Child Frames}), это поднимает @var{frame} выше всех остальных
дочерних фреймов своего родителя.
@end deffn

@deffn Command lower-frame &optional frame
Функция опускает фрейм @var{frame} (по умолчанию, выбранный кадр) ниже всех
других фреймов, принадлежащих той же или более высокой z-группе, что и
@var{frame}.  Если @var{frame} является дочерним фреймом
(@pxref{Child Frames}), это опускает @var{frame} ниже всех остальных
дочерних фреймов своего родителя.
@end deffn

@defun frame-restack frame1 frame2 &optional above
Функция перезагружает @var{frame1} ниже @var{frame2}.  Это означает, что
если видны оба фрейма и их области отображения перекрываются, @var{frame2}
(частично) закроет @var{frame1}.  Если необязательный третий аргумент
@var{above} - не-@code{nil}, эта функция помещает @var{frame1} поверх
@var{frame2}.  Это означает, что если видны оба кадра и их области
отображения перекрываются, @var{frame1} (частично) закроет @var{frame2}.

Технически эту функцию можно рассматривать как атомарное действие,
выполняемое в два этапа: Первый шаг удаляет окно оконной системы
@var{frame1} с дисплея.  На втором шаге окно @var{frame1} повторно
вставляется в отображение ниже (вверху, если @var{above} истинно),
отображения @var{frame2}.  Следовательно, положение @var{frame2} в Z-порядке
отображения (наложения) относительно всех других фреймов, за исключением
@var{frame1}, остается неизменным.

Некоторые оконные менеджеры могут отказываться переупаковывать окна.
@end defun

Обратить внимание, что эффект перетасовки будет сохраняться только до тех
пор, пока ни один из задействованных фреймов не будет отмечен значком или
не станет невидимым.  Можно использовать параметр фрейма @code{z-group}
(@pxref{Position Parameters}), чтобы добавить фрейм к группе фреймов,
постоянно отображаемый над или под другими фреймами.  Пока фрейм принадлежит
к одной из этих групп, перетасовка будет влиять только на его относительное
положение в стеке внутри этой группы.  Эффект от перестановки фреймов,
принадлежащих разным z-группам, не определен.  Можно перечислить фреймы в их
текущем порядке наложения с помощью функции @code{frame-list-z-order}
(@pxref{Finding All Frames}).

@defopt minibuffer-auto-raise
Если это не-@code{nil}, активация минибуфера поднимает фрейм, в котором
находится окно минибуфера.
@end defopt

  В оконных системах также можно включить автоматическое поднятие (при
выборе фоейма) или автоматическое опускание (при отмене выбора фрейма) с
помощью параметров фрейма.  @xref{Management Parameters}.

@cindex top frame
  Концепция подъема и опускания фреймов также применима к фреймам текстового
терминала.  На каждом текстовом терминале одновременно отображается только
верхний фрейм.

@defun tty-top-frame &optional terminal
This function returns the top frame on @var{terminal}.  @var{terminal}
should be a terminal object, a frame (meaning that frame's terminal),
or @code{nil} (meaning the selected frame's terminal).  If it does not
refer to a text terminal, the return value is @code{nil}.
@end defun


@node Frame Configurations
@section Frame Configurations
@cindex frame configuration

  A @dfn{frame configuration} records the current arrangement of frames,
all their properties, and the window configuration of each one.
(@xref{Window Configurations}.)

@defun current-frame-configuration
This function returns a frame configuration list that describes
the current arrangement of frames and their contents.
@end defun

@defun set-frame-configuration configuration &optional nodelete
This function restores the state of frames described in
@var{configuration}.  However, this function does not restore deleted
frames.

Ordinarily, this function deletes all existing frames not listed in
@var{configuration}.  But if @var{nodelete} is не-@code{nil}, the
unwanted frames are iconified instead.
@end defun


@node Child Frames
@section Child Frames
@cindex child frames
@cindex parent frames

Child frames are objects halfway between windows (@pxref{Windows}) and
``normal'' frames.  Like windows, they are attached to an owning frame.
Unlike windows, they may overlap each other---changing the size or
position of one child frame does not change the size or position of any
of its sibling child frames.

  By design, operations to make or modify child frames are implemented
with the help of frame parameters (@pxref{Frame Parameters}) without any
specialized functions or customizable variables.  Note that child frames
are meaningful on graphical terminals only.

  To create a new child frame or to convert a normal frame into a child
frame, set that frame's @code{parent-frame} parameter (@pxref{Frame
Interaction Parameters}) to that of an already existing frame.  The
frame specified by that parameter will then be the frame's parent frame
as long as the parameter is not changed or reset.  Technically, this
makes the child frame's window-system window a child window of the
parent frame's window-system window.

@cindex reparent frame
@cindex nest frame
  The @code{parent-frame} parameter can be changed at any time.  Setting
it to another frame @dfn{reparents} the child frame.  Setting it to
another child frame makes the frame a @dfn{nested} child frame.  Setting
it to @code{nil} restores the frame's status as a top-level frame---a
frame whose window-system window is a child of its display's root
window.

  Since child frames can be arbitrarily nested, a frame can be both a
child and a parent frame.  Also, the relative roles of child and parent
frame may be reversed at any time (though it's usually a good idea to
keep the size of a child frame sufficiently smaller than that of its
parent).  An error will be signaled for the attempt to make a frame an
ancestor of itself.

   Most window-systems clip a child frame at the native edges
(@pxref{Frame Geometry}) of its parent frame---everything outside these
edges is usually invisible.  A child frame's @code{left} and @code{top}
parameters specify a position relative to the top-left corner of its
parent's native frame.  When the parent frame is resized, this position
remains conceptually unaltered.

  NS builds do not clip child frames at the parent frame's edges,
allowing them to be positioned so they do not obscure the parent frame
while still being visible themselves.

  Usually, moving a parent frame moves along all its child frames and
their descendants as well, keeping their relative positions unaltered.
Note that the hook @code{move-frame-functions} (@pxref{Frame Position})
is run for a child frame only when the position of the child frame
relative to its parent frame changes.

  When a parent frame is resized, its child frames conceptually retain
their previous sizes and their positions relative to the left upper
corner of the parent.  This means that a child frame may become
(partially) invisible when its parent frame shrinks.  The parameter
@code{keep-ratio} (@pxref{Frame Interaction Parameters}) can be used to
resize and reposition a child frame proportionally whenever its parent
frame is resized.  This may avoid obscuring parts of a frame when its
parent frame is shrunk.

  A visible child frame always appears on top of its parent frame thus
obscuring parts of it, except on NS builds where it may be positioned
beneath the parent.  This is comparable to the window-system window of a
top-level frame which also always appears on top of its parent
window---the desktop's root window.  When a parent frame is iconified or
made invisible (@pxref{Visibility of Frames}), its child frames are made
invisible.  When a parent frame is deiconified or made visible, its
child frames are made visible.  When a parent frame is about to be
deleted (@pxref{Deleting Frames}), its child frames are recursively
deleted before it.

  Whether a child frame can have a menu or tool bar is window-system or
window manager dependent.  Most window-systems explicitly disallow menus
bars for child frames.  It seems advisable to disable both, menu and
tool bars, via the frame's initial parameters settings.

  Usually, child frames do not exhibit window manager decorations like a
title bar or external borders (@pxref{Frame Geometry}).  When the child
frame does not show a menu or tool bar, any other of the frame's borders
(@pxref{Layout Parameters}) can be used instead of the external borders.

  In particular, under X (but not when building with GTK+), the frame's
outer border can be used.  On MS-Windows, specifying a non-zero outer
border width will show a one-pixel wide external border.  Under all
window-systems, the internal border can be used.  In either case, it's
advisable to disable a child frame's window manager decorations with the
@code{undecorated} frame parameter (@pxref{Management Parameters}).

  To resize or move an undecorated child frame with the mouse, special
frame parameters (@pxref{Mouse Dragging Parameters}) have to be used.
The internal border of a child frame, if present, can be used to resize
the frame with the mouse, provided that frame has a не-@code{nil}
@code{drag-internal-border} parameter.  If set, the @code{snap-width}
parameter indicates the number of pixels where the frame @dfn{snaps} at
the respective edge or corner of its parent frame.

  There are two ways to drag an entire child frame with the mouse: The
@code{drag-with-mode-line} parameter, if не-@code{nil}, allows to drag
a frame without minibuffer window (@pxref{Minibuffer Windows}) via the
mode line area of its bottommost window.  The
@code{drag-with-header-line} parameter, if не-@code{nil}, allows to
drag the frame via the header line area of its topmost window.

  In order to give a child frame a draggable header or mode line, the
window parameters @code{mode-line-format} and @code{header-line-format}
are handy (@pxref{Window Parameters}).  These allow to remove an
unwanted mode line (when @code{drag-with-header-line} is chosen) and to
remove mouse-sensitive areas which might interfere with frame dragging.

  To avoid that dragging moves a frame completely out of its parent's
native frame, something which might happen when the mouse cursor
overshoots and makes the frame difficult to retrieve once the mouse
button has been released, it is advisable to set the frame's
@code{top-visible} or @code{bottom-visible} parameter correspondingly.

  The @code{top-visible} parameter specifies the number of pixels at the
top of the frame that always remain visible within the parent's native
frame during dragging and should be set when specifying a не-@code{nil}
@code{drag-with-header-line} parameter.  The @code{bottom-visible}
parameter specifies the number of pixels at the bottom of the frame that
always remain visible within the parent's native frame during dragging
and should be preferred when specifying a не-@code{nil}
@code{drag-with-mode-line} parameter.

  When a child frame is used for displaying a buffer via
@code{display-buffer-in-child-frame} (@pxref{Buffer Display Action
Functions}), the frame's @code{auto-hide-function} parameter
(@pxref{Frame Interaction Parameters}) can be set to a function, in
order to appropriately deal with the frame when the window displaying
the buffer shall be quit.

  When a child frame is used during minibuffer interaction, for example,
to display completions in a separate window, the @code{minibuffer-exit}
parameter (@pxref{Frame Interaction Parameters}) is useful in order to
deal with the frame when the minibuffer is exited.

  The behavior of child frames deviates from that of top-level frames in
a number of other ways as well.  Here we sketch a few of them:

@itemize @bullet
@item
The semantics of maximizing and iconifying child frames is highly
window-system dependent.  As a rule, applications should never invoke
these operations on child frames.  By default, invoking
@code{iconify-frame} on a child frame will try to iconify the top-level
frame corresponding to that child frame instead.  To obtain a different
behavior, users may customize the option @code{iconify-child-frame}
described below.

@item
Raising, lowering and restacking child frames (@pxref{Raising and
Lowering}) or changing the @code{z-group} (@pxref{Position Parameters})
of a child frame changes only the stacking order of child frames with
the same parent.

@item
Many window-systems are not able to change the opacity (@pxref{Font and
Color Parameters}) of child frames.

@item
Transferring focus from a child frame to an ancestor that is not its
parent by clicking with the mouse in a visible part of that ancestor's
window may fail with some window-systems.  You may have to click into
the direct parent's window-system window first.

@item
Window managers might not bother to extend their focus follows mouse
policy to child frames.  Customizing @code{mouse-autoselect-window} can
help in this regard (@pxref{Mouse Window Auto-selection}).

@item
Dropping (@pxref{Drag and Drop}) on child frames is not guaranteed to
work on all window-systems.  Some will drop the object on the parent
frame or on some ancestor instead.
@end itemize

  The following two functions can be useful when working with child and
parent frames:

@defun frame-parent &optional frame
This function returns the parent frame of @var{frame}.  The parent frame
of @var{frame} is the Emacs frame whose window-system window is the
parent window of @var{frame}'s window-system window.  If such a frame
exists, @var{frame} is considered a child frame of that frame.

This function returns @code{nil} if @var{frame} has no parent frame.
@end defun

@defun frame-ancestor-p ancestor descendant
This functions returns не-@code{nil} if @var{ancestor} is an ancestor
of @var{descendant}.  @var{ancestor} is an ancestor of @var{descendant}
when it is either @var{descendant}'s parent frame or it is an ancestor
of @var{descendant}'s parent frame.  Both, @var{ancestor} and
@var{descendant} must specify live frames.
@end defun

Note also the function @code{window-largest-empty-rectangle}
(@pxref{Coordinates and Windows}) which can be used to inscribe a child
frame in the largest empty area of an existing window.  This can be
useful to avoid that a child frame obscures any text shown in that
window.

Customizing the following option can be useful to tweak the behavior of
@code{iconify-frame} for child frames.

@defopt iconify-child-frame
This option tells Emacs how to proceed when it is asked to iconify a
child frame.  If it is @code{nil}, @code{iconify-frame} will do nothing
when invoked on a child frame.  If it is @code{iconify-top-level}, Emacs
will try to iconify the top-level frame that is the ancestor of this
child frame instead.  If it is @code{make-invisible}, Emacs will try to
make this child frame invisible instead of iconifying it.

Any other value means to try iconifying the child frame.  Since such an
attempt may not be honored by all window managers and can even lead to
making the child frame unresponsive to user actions, the default is to
iconify the top level frame instead.
@end defopt


@node Mouse Tracking
@section Mouse Tracking
@cindex mouse tracking
@c @cindex tracking the mouse   Duplicates track-mouse

  Sometimes it is useful to @dfn{track} the mouse, which means to display
something to indicate where the mouse is and move the indicator as the
mouse moves.  For efficient mouse tracking, you need a way to wait until
the mouse actually moves.

  The convenient way to track the mouse is to ask for events to represent
mouse motion.  Then you can wait for motion by waiting for an event.  In
addition, you can easily handle any other sorts of events that may
occur.  That is useful, because normally you don't want to track the
mouse forever---only until some other event, such as the release of a
button.

@defmac track-mouse body@dots{}
This macro executes @var{body}, with generation of mouse motion events
enabled.  Typically, @var{body} would use @code{read-event} to read
the motion events and modify the display accordingly.  @xref{Motion
Events}, for the format of mouse motion events.

The value of @code{track-mouse} is that of the last form in @var{body}.
You should design @var{body} to return when it sees the up-event that
indicates the release of the button, or whatever kind of event means
it is time to stop tracking.

The @code{track-mouse} form causes Emacs to generate mouse motion
events by binding the variable @code{track-mouse} to a
не-@code{nil} value.  If that variable has the special value
@code{dragging}, it additionally instructs the display engine to
refrain from changing the shape of the mouse pointer.  This is
desirable in Lisp programs that require mouse dragging across large
portions of Emacs display, which might otherwise cause the mouse
pointer to change its shape according to the display portion it hovers
on (@pxref{Pointer Shape}).  Therefore, Lisp programs that need the
mouse pointer to retain its original shape during dragging should bind
@code{track-mouse} to the value @code{dragging} at the beginning of
their @var{body}.
@end defmac

The usual purpose of tracking mouse motion is to indicate on the screen
the consequences of pushing or releasing a button at the current
position.

In many cases, you can avoid the need to track the mouse by using
the @code{mouse-face} text property (@pxref{Special Properties}).
That works at a much lower level and runs more smoothly than
Lisp-level mouse tracking.

@ignore
@c These are not implemented yet.

These functions change the screen appearance instantaneously.  The
effect is transient, only until the next ordinary Emacs redisplay.  That
is OK for mouse tracking, since it doesn't make sense for mouse tracking
to change the text, and the body of @code{track-mouse} normally reads
the events itself and does not do redisplay.

@defun x-contour-region window beg end
This function draws lines to make a box around the text from @var{beg}
to @var{end}, in window @var{window}.
@end defun

@defun x-uncontour-region window beg end
This function erases the lines that would make a box around the text
from @var{beg} to @var{end}, in window @var{window}.  Use it to remove
a contour that you previously made by calling @code{x-contour-region}.
@end defun

@defun x-draw-rectangle frame left top right bottom
This function draws a hollow rectangle on frame @var{frame} with the
specified edge coordinates, all measured in pixels from the inside top
left corner.  It uses the cursor color, the one used for indicating the
location of point.
@end defun

@defun x-erase-rectangle frame left top right bottom
This function erases a hollow rectangle on frame @var{frame} with the
specified edge coordinates, all measured in pixels from the inside top
left corner.  Erasure means redrawing the text and background that
normally belong in the specified rectangle.
@end defun
@end ignore

@node Mouse Position
@section Mouse Position
@cindex mouse position
@cindex position of mouse

  The functions @code{mouse-position} and @code{set-mouse-position}
give access to the current position of the mouse.

@defun mouse-position
This function returns a description of the position of the mouse.  The
value looks like @code{(@var{frame} @var{x} . @var{y})}, where @var{x}
and @var{y} are integers giving the (possibly rounded) position in
multiples of the default character size of @var{frame} (@pxref{Frame
Font}) relative to the native position of @var{frame} (@pxref{Frame
Geometry}).
@end defun

@defvar mouse-position-function
If не-@code{nil}, the value of this variable is a function for
@code{mouse-position} to call.  @code{mouse-position} calls this
function just before returning, with its normal return value as the
sole argument, and it returns whatever this function returns to it.

This abnormal hook exists for the benefit of packages like
@file{xt-mouse.el} that need to do mouse handling at the Lisp level.
@end defvar

@defun set-mouse-position frame x y
This function @dfn{warps the mouse} to position @var{x}, @var{y} in
frame @var{frame}.  The arguments @var{x} and @var{y} are integers,
giving the position in multiples of the default character size of
@var{frame} (@pxref{Frame Font}) relative to the native position of
@var{frame} (@pxref{Frame Geometry}).

The resulting mouse position is constrained to the native frame of
@var{frame}.  If @var{frame} is not visible, this function does nothing.
The return value is not significant.
@end defun

@defun mouse-pixel-position
This function is like @code{mouse-position} except that it returns
coordinates in units of pixels rather than units of characters.
@end defun

@defun set-mouse-pixel-position frame x y
This function warps the mouse like @code{set-mouse-position} except that
@var{x} and @var{y} are in units of pixels rather than units of
characters.

The resulting mouse position is not constrained to the native frame of
@var{frame}.  If @var{frame} is not visible, this function does nothing.
The return value is not significant.
@end defun

On a graphical terminal the following two functions allow the absolute
position of the mouse cursor to be retrieved and set.

@defun mouse-absolute-pixel-position
This function returns a cons cell (@var{x} . @var{y}) of the coordinates
of the mouse cursor position in pixels, relative to a position (0, 0) of
the selected frame's display.
@end defun

@defun set-mouse-absolute-pixel-position x y
This function moves the mouse cursor to the position (@var{x}, @var{y}).
The coordinates @var{x} and @var{y} are interpreted in pixels relative
to a position (0, 0) of the selected frame's display.
@end defun

The following function can tell whether the mouse cursor is currently
visible on a frame:

@defun frame-pointer-visible-p &optional frame
This predicate function returns не-@code{nil} if the mouse pointer
displayed on @var{frame} is visible; otherwise it returns @code{nil}.
@var{frame} omitted or @code{nil} means the selected frame.  This is
useful when @code{make-pointer-invisible} is set to @code{t}: it
allows you to know if the pointer has been hidden.
@xref{Mouse Avoidance,,,emacs, The Emacs Manual}.
@end defun

@need 3000

@node Pop-Up Menus
@section Pop-Up Menus
@cindex menus, popup

  A Lisp program can pop up a menu so that the user can choose an
alternative with the mouse.  On a text terminal, if the mouse is not
available, the user can choose an alternative using the keyboard
motion keys---@kbd{C-n}, @kbd{C-p}, or up- and down-arrow keys.

@defun x-popup-menu position menu
This function displays a pop-up menu and returns an indication of
what selection the user makes.

The argument @var{position} specifies where on the screen to put the
top left corner of the menu.  It can be either a mouse button event
(which says to put the menu where the user actuated the button) or a
list of this form:

@example
((@var{xoffset} @var{yoffset}) @var{window})
@end example

@noindent
where @var{xoffset} and @var{yoffset} are coordinates, measured in
pixels, counting from the top left corner of @var{window}.  @var{window}
may be a window or a frame.

If @var{position} is @code{t}, it means to use the current mouse
position (or the top-left corner of the frame if the mouse is not
available on a text terminal).  If @var{position} is @code{nil}, it
means to precompute the key binding equivalents for the keymaps
specified in @var{menu}, without actually displaying or popping up the
menu.

The argument @var{menu} says what to display in the menu.  It can be a
keymap or a list of keymaps (@pxref{Menu Keymaps}).  In this case, the
return value is the list of events corresponding to the user's choice.
This list has more than one element if the choice occurred in a
submenu.  (Note that @code{x-popup-menu} does not actually execute the
command bound to that sequence of events.)  On text terminals and
toolkits that support menu titles, the title is taken from the prompt
string of @var{menu} if @var{menu} is a keymap, or from the prompt
string of the first keymap in @var{menu} if it is a list of keymaps
(@pxref{Defining Menus}).

Alternatively, @var{menu} can have the following form:

@example
(@var{title} @var{pane1} @var{pane2}...)
@end example

@noindent
where each pane is a list of form

@example
(@var{title} @var{item1} @var{item2}...)
@end example

Each @var{item} should be a cons cell, @code{(@var{line} . @var{value})},
where @var{line} is a string and @var{value} is the value to return if
that @var{line} is chosen.  Unlike in a menu keymap, a @code{nil}
@var{value} does not make the menu item non-selectable.
Alternatively, each @var{item} can be a string rather than a cons
cell; this makes a non-selectable menu item.

If the user gets rid of the menu without making a valid choice, for
instance by clicking the mouse away from a valid choice or by typing
@kbd{C-g}, then this normally results in a quit and
@code{x-popup-menu} does not return.  But if @var{position} is a mouse
button event (indicating that the user invoked the menu with the
mouse) then no quit occurs and @code{x-popup-menu} returns @code{nil}.
@end defun

  @strong{Usage note:} Don't use @code{x-popup-menu} to display a menu
if you could do the job with a prefix key defined with a menu keymap.
If you use a menu keymap to implement a menu, @kbd{C-h c} and @kbd{C-h
a} can see the individual items in that menu and provide help for them.
If instead you implement the menu by defining a command that calls
@code{x-popup-menu}, the help facilities cannot know what happens inside
that command, so they cannot give any help for the menu's items.

  The menu bar mechanism, which lets you switch between submenus by
moving the mouse, cannot look within the definition of a command to see
that it calls @code{x-popup-menu}.  Therefore, if you try to implement a
submenu using @code{x-popup-menu}, it cannot work with the menu bar in
an integrated fashion.  This is why all menu bar submenus are
implemented with menu keymaps within the parent menu, and never with
@code{x-popup-menu}.  @xref{Menu Bar}.

  If you want a menu bar submenu to have contents that vary, you should
still use a menu keymap to implement it.  To make the contents vary, add
a hook function to @code{menu-bar-update-hook} to update the contents of
the menu keymap as necessary.

@node Dialog Boxes
@section Dialog Boxes
@cindex dialog boxes

  A dialog box is a variant of a pop-up menu---it looks a little
different, it always appears in the center of a frame, and it has just
one level and one or more buttons.  The main use of dialog boxes is
for asking questions that the user can answer with ``yes'', ``no'',
and a few other alternatives.  With a single button, they can also
force the user to acknowledge important information.  The functions
@code{y-or-n-p} and @code{yes-or-no-p} use dialog boxes instead of the
keyboard, when called from commands invoked by mouse clicks.

@defun x-popup-dialog position contents &optional header
This function displays a pop-up dialog box and returns an indication of
what selection the user makes.  The argument @var{contents} specifies
the alternatives to offer; it has this format:

@example
(@var{title} (@var{string} . @var{value})@dots{})
@end example

@noindent
which looks like the list that specifies a single pane for
@code{x-popup-menu}.

The return value is @var{value} from the chosen alternative.

As for @code{x-popup-menu}, an element of the list may be just a
string instead of a cons cell @code{(@var{string} . @var{value})}.
That makes a box that cannot be selected.

If @code{nil} appears in the list, it separates the left-hand items from
the right-hand items; items that precede the @code{nil} appear on the
left, and items that follow the @code{nil} appear on the right.  If you
don't include a @code{nil} in the list, then approximately half the
items appear on each side.

Dialog boxes always appear in the center of a frame; the argument
@var{position} specifies which frame.  The possible values are as in
@code{x-popup-menu}, but the precise coordinates or the individual
window don't matter; only the frame matters.

If @var{header} is не-@code{nil}, the frame title for the box is
@samp{Information}, otherwise it is @samp{Question}.  The former is used
for @code{message-box} (@pxref{message-box}).  (On text terminals, the
box title is not displayed.)

In some configurations, Emacs cannot display a real dialog box; so
instead it displays the same items in a pop-up menu in the center of the
frame.

If the user gets rid of the dialog box without making a valid choice,
for instance using the window manager, then this produces a quit and
@code{x-popup-dialog} does not return.
@end defun

@node Pointer Shape
@section Pointer Shape
@cindex pointer shape
@cindex mouse pointer shape

  You can specify the mouse pointer style for particular text or
images using the @code{pointer} text property, and for images with the
@code{:pointer} and @code{:map} image properties.  The values you can
use in these properties are @code{text} (or @code{nil}), @code{arrow},
@code{hand}, @code{vdrag}, @code{hdrag}, @code{modeline}, and
@code{hourglass}.  @code{text} stands for the usual mouse pointer
style used over text.

  Over void parts of the window (parts that do not correspond to any
of the buffer contents), the mouse pointer usually uses the
@code{arrow} style, but you can specify a different style (one of
those above) by setting @code{void-text-area-pointer}.

@defopt void-text-area-pointer
This variable specifies the mouse pointer style for void text areas.
These include the areas after the end of a line or below the last line
in the buffer.  The default is to use the @code{arrow} (non-text)
pointer style.
@end defopt

  When using X, you can specify what the @code{text} pointer style
really looks like by setting the variable @code{x-pointer-shape}.

@defvar x-pointer-shape
This variable specifies the pointer shape to use ordinarily in the
Emacs frame, for the @code{text} pointer style.
@end defvar

@defvar x-sensitive-text-pointer-shape
This variable specifies the pointer shape to use when the mouse
is over mouse-sensitive text.
@end defvar

  These variables affect newly created frames.  They do not normally
affect existing frames; however, if you set the mouse color of a
frame, that also installs the current value of those two variables.
@xref{Font and Color Parameters}.

  The values you can use, to specify either of these pointer shapes, are
defined in the file @file{lisp/term/x-win.el}.  Use @kbd{M-x apropos
@key{RET} x-pointer @key{RET}} to see a list of them.

@node Window System Selections
@section Window System Selections
@cindex selection (for window systems)
@cindex clipboard
@cindex primary selection
@cindex secondary selection

  In window systems, such as X, data can be transferred between
different applications by means of @dfn{selections}.  X defines an
arbitrary number of @dfn{selection types}, each of which can store its
own data; however, only three are commonly used: the @dfn{clipboard},
@dfn{primary selection}, and @dfn{secondary selection}.  Other window
systems support only the clipboard.  @xref{Cut and Paste,, Cut and
Paste, emacs, The GNU Emacs Manual}, for Emacs commands that make use
of these selections.  This section documents the low-level functions
for reading and setting window-system selections.

@deffn Command gui-set-selection type data
This function sets a window-system selection.  It takes two arguments:
a selection type @var{type}, and the value to assign to it, @var{data}.

@var{type} should be a symbol; it is usually one of @code{PRIMARY},
@code{SECONDARY} or @code{CLIPBOARD}.  These are symbols with
upper-case names, in accord with X Window System conventions.  If
@var{type} is @code{nil}, that stands for @code{PRIMARY}.

If @var{data} is @code{nil}, it means to clear out the selection.
Otherwise, @var{data} may be a string, a symbol, an integer (or a cons
of two integers or list of two integers), an overlay, or a cons of two
markers pointing to the same buffer.  An overlay or a pair of markers
stands for text in the overlay or between the markers.  The argument
@var{data} may also be a vector of valid non-vector selection values.

This function returns @var{data}.
@end deffn

@defun gui-get-selection &optional type data-type
This function accesses selections set up by Emacs or by other
programs.  It takes two optional arguments, @var{type} and
@var{data-type}.  The default for @var{type}, the selection type, is
@code{PRIMARY}.

The @var{data-type} argument specifies the form of data conversion to
use, to convert the raw data obtained from another program into Lisp
data.  Meaningful values include @code{TEXT}, @code{STRING},
@code{UTF8_STRING}, @code{TARGETS}, @code{LENGTH}, @code{DELETE},
@code{FILE_NAME}, @code{CHARACTER_POSITION}, @code{NAME},
@code{LINE_NUMBER}, @code{COLUMN_NUMBER}, @code{OWNER_OS},
@code{HOST_NAME}, @code{USER}, @code{CLASS}, @code{ATOM}, and
@code{INTEGER}.  (These are symbols with upper-case names in accord
with X conventions.)  The default for @var{data-type} is
@code{STRING}.  Window systems other than X usually support only a
small subset of these types, in addition to @code{STRING}.
@end defun

@defopt selection-coding-system
This variable specifies the coding system to use when reading and
writing selections or the clipboard.  @xref{Coding
Systems}.  The default is @code{compound-text-with-extensions}, which
converts to the text representation that X11 normally uses.
@end defopt

@cindex clipboard support (for MS-Windows)
When Emacs runs on MS-Windows, it does not implement X selections in
general, but it does support the clipboard.  @code{gui-get-selection}
and @code{gui-set-selection} on MS-Windows support the text data type
only; if the clipboard holds other types of data, Emacs treats the
clipboard as empty.  The supported data type is @code{STRING}.

For backward compatibility, there are obsolete aliases
@code{x-get-selection} and @code{x-set-selection}, which were the
names of @code{gui-get-selection} and @code{gui-set-selection} before
Emacs 25.1.

@node Drag and Drop
@section Drag and Drop
@cindex drag and drop

@vindex x-dnd-test-function
@vindex x-dnd-known-types
  When a user drags something from another application over Emacs, that other
application expects Emacs to tell it if Emacs can handle the data that is
dragged.  The variable @code{x-dnd-test-function} is used by Emacs to determine
what to reply.  The default value is @code{x-dnd-default-test-function}
which accepts drops if the type of the data to be dropped is present in
@code{x-dnd-known-types}.  You can customize @code{x-dnd-test-function} and/or
@code{x-dnd-known-types} if you want Emacs to accept or reject drops based
on some other criteria.

@vindex x-dnd-types-alist
  If you want to change the way Emacs handles drop of different types
or add a new type, customize @code{x-dnd-types-alist}.  This requires
detailed knowledge of what types other applications use for drag and
drop.

@vindex dnd-protocol-alist
  When an URL is dropped on Emacs it may be a file, but it may also be
another URL type (ftp, http, etc.).  Emacs first checks
@code{dnd-protocol-alist} to determine what to do with the URL@.  If
there is no match there and if @code{browse-url-browser-function} is
an alist, Emacs looks for a match there.  If no match is found the
text for the URL is inserted.  If you want to alter Emacs behavior,
you can customize these variables.

@node Color Names
@section Color Names

@cindex color names
@cindex specify color
@cindex numerical RGB color specification
  A color name is text (usually in a string) that specifies a color.
Symbolic names such as @samp{black}, @samp{white}, @samp{red}, etc.,
are allowed; use @kbd{M-x list-colors-display} to see a list of
defined names.  You can also specify colors numerically in forms such
as @samp{#@var{rgb}} and @samp{RGB:@var{r}/@var{g}/@var{b}}, where
@var{r} specifies the red level, @var{g} specifies the green level,
and @var{b} specifies the blue level.  You can use either one, two,
three, or four hex digits for @var{r}; then you must use the same
number of hex digits for all @var{g} and @var{b} as well, making
either 3, 6, 9 or 12 hex digits in all.  (See the documentation of the
X Window System for more details about numerical RGB specification of
colors.)

  These functions provide a way to determine which color names are
valid, and what they look like.  In some cases, the value depends on the
@dfn{selected frame}, as described below; see @ref{Input Focus}, for the
meaning of the term ``selected frame''.

  To read user input of color names with completion, use
@code{read-color} (@pxref{High-Level Completion, read-color}).

@defun color-defined-p color &optional frame
This function reports whether a color name is meaningful.  It returns
@code{t} if so; otherwise, @code{nil}.  The argument @var{frame} says
which frame's display to ask about; if @var{frame} is omitted or
@code{nil}, the selected frame is used.

Note that this does not tell you whether the display you are using
really supports that color.  When using X, you can ask for any defined
color on any kind of display, and you will get some result---typically,
the closest it can do.  To determine whether a frame can really display
a certain color, use @code{color-supported-p} (see below).

@findex x-color-defined-p
This function used to be called @code{x-color-defined-p},
and that name is still supported as an alias.
@end defun

@defun defined-colors &optional frame
This function returns a list of the color names that are defined
and supported on frame @var{frame} (default, the selected frame).
If @var{frame} does not support colors, the value is @code{nil}.

@findex x-defined-colors
This function used to be called @code{x-defined-colors},
and that name is still supported as an alias.
@end defun

@defun color-supported-p color &optional frame background-p
This returns @code{t} if @var{frame} can really display the color
@var{color} (or at least something close to it).  If @var{frame} is
omitted or @code{nil}, the question applies to the selected frame.

Some terminals support a different set of colors for foreground and
background.  If @var{background-p} is не-@code{nil}, that means you are
asking whether @var{color} can be used as a background; otherwise you
are asking whether it can be used as a foreground.

The argument @var{color} must be a valid color name.
@end defun

@defun color-gray-p color &optional frame
This returns @code{t} if @var{color} is a shade of gray, as defined on
@var{frame}'s display.  If @var{frame} is omitted or @code{nil}, the
question applies to the selected frame.  If @var{color} is not a valid
color name, this function returns @code{nil}.
@end defun

@defun color-values color &optional frame
@cindex rgb value
This function returns a value that describes what @var{color} should
ideally look like on @var{frame}.  If @var{color} is defined, the
value is a list of three integers, which give the amount of red, the
amount of green, and the amount of blue.  Each integer ranges in
principle from 0 to 65535, but some displays may not use the full
range.  This three-element list is called the @dfn{rgb values} of the
color.

If @var{color} is not defined, the value is @code{nil}.

@example
(color-values "black")
     @result{} (0 0 0)
(color-values "white")
     @result{} (65280 65280 65280)
(color-values "red")
     @result{} (65280 0 0)
(color-values "pink")
     @result{} (65280 49152 51968)
(color-values "hungry")
     @result{} nil
@end example

The color values are returned for @var{frame}'s display.  If
@var{frame} is omitted or @code{nil}, the information is returned for
the selected frame's display.  If the frame cannot display colors, the
value is @code{nil}.

@findex x-color-values
This function used to be called @code{x-color-values},
and that name is still supported as an alias.
@end defun

@node Text Terminal Colors
@section Text Terminal Colors
@cindex colors on text terminals

  Text terminals usually support only a small number of colors, and
the computer uses small integers to select colors on the terminal.
This means that the computer cannot reliably tell what the selected
color looks like; instead, you have to inform your application which
small integers correspond to which colors.  However, Emacs does know
the standard set of colors and will try to use them automatically.

  The functions described in this section control how terminal colors
are used by Emacs.

  Several of these functions use or return @dfn{rgb values}, described
in @ref{Color Names}.

  These functions accept a display (either a frame or the name of a
terminal) as an optional argument.  We hope in the future to make
Emacs support different colors on different text terminals; then this
argument will specify which terminal to operate on (the default being
the selected frame's terminal; @pxref{Input Focus}).  At present,
though, the @var{frame} argument has no effect.

@defun tty-color-define name number &optional rgb frame
This function associates the color name @var{name} with
color number @var{number} on the terminal.

The optional argument @var{rgb}, if specified, is an rgb value, a list
of three numbers that specify what the color actually looks like.
If you do not specify @var{rgb}, then this color cannot be used by
@code{tty-color-approximate} to approximate other colors, because
Emacs will not know what it looks like.
@end defun

@defun tty-color-clear &optional frame
This function clears the table of defined colors for a text terminal.
@end defun

@defun tty-color-alist &optional frame
This function returns an alist recording the known colors supported by
a text terminal.

Each element has the form @code{(@var{name} @var{number} . @var{rgb})}
or @code{(@var{name} @var{number})}.  Here, @var{name} is the color
name, @var{number} is the number used to specify it to the terminal.
If present, @var{rgb} is a list of three color values (for red, green,
and blue) that says what the color actually looks like.
@end defun

@defun tty-color-approximate rgb &optional frame
This function finds the closest color, among the known colors
supported for @var{display}, to that described by the rgb value
@var{rgb} (a list of color values).  The return value is an element of
@code{tty-color-alist}.
@end defun

@defun tty-color-translate color &optional frame
This function finds the closest color to @var{color} among the known
colors supported for @var{display} and returns its index (an integer).
If the name @var{color} is not defined, the value is @code{nil}.
@end defun

@node Resources
@section X Resources

This section describes some of the functions and variables for
querying and using X resources, or their equivalent on your operating
system.  @xref{X Resources,, X Resources, emacs, The GNU Emacs
Manual}, for more information about X resources.

@defun x-get-resource attribute class &optional component subclass
The function @code{x-get-resource} retrieves a resource value from the X
Window defaults database.

Resources are indexed by a combination of a @dfn{key} and a @dfn{class}.
This function searches using a key of the form
@samp{@var{instance}.@var{attribute}} (where @var{instance} is the name
under which Emacs was invoked), and using @samp{Emacs.@var{class}} as
the class.

The optional arguments @var{component} and @var{subclass} add to the key
and the class, respectively.  You must specify both of them or neither.
If you specify them, the key is
@samp{@var{instance}.@var{component}.@var{attribute}}, and the class is
@samp{Emacs.@var{class}.@var{subclass}}.
@end defun

@defvar x-resource-class
This variable specifies the application name that @code{x-get-resource}
should look up.  The default value is @code{"Emacs"}.  You can examine X
resources for other application names by binding this
variable to some other string, around a call to @code{x-get-resource}.
@end defvar

@defvar x-resource-name
This variable specifies the instance name that @code{x-get-resource}
should look up.  The default value is the name Emacs was invoked with,
or the value specified with the @samp{-name} or @samp{-rn} switches.
@end defvar

To illustrate some of the above, suppose that you have the line:

@example
xterm.vt100.background: yellow
@end example

@noindent
in your X resources file (whose name is usually @file{~/.Xdefaults}
or @file{~/.Xresources}).  Then:

@example
@group
(let ((x-resource-class "XTerm") (x-resource-name "xterm"))
  (x-get-resource "vt100.background" "VT100.Background"))
     @result{} "yellow"
@end group
@group
(let ((x-resource-class "XTerm") (x-resource-name "xterm"))
  (x-get-resource "background" "VT100" "vt100" "Background"))
     @result{} "yellow"
@end group
@end example

@defvar inhibit-x-resources
If this variable is не-@code{nil}, Emacs does not look up X
resources, and X resources do not have any effect when creating new
frames.
@end defvar

@node Display Feature Testing
@section Display Feature Testing
@cindex display feature testing

  The functions in this section describe the basic capabilities of a
particular display.  Lisp programs can use them to adapt their behavior
to what the display can do.  For example, a program that ordinarily uses
a popup menu could use the minibuffer if popup menus are not supported.

  The optional argument @var{display} in these functions specifies which
display to ask the question about.  It can be a display name, a frame
(which designates the display that frame is on), or @code{nil} (which
refers to the selected frame's display, @pxref{Input Focus}).

  @xref{Color Names}, @ref{Text Terminal Colors}, for other functions to
obtain information about displays.

@defun display-popup-menus-p &optional display
This function returns @code{t} if popup menus are supported on
@var{display}, @code{nil} if not.  Support for popup menus requires
that the mouse be available, since the menu is popped up by clicking
the mouse on some portion of the Emacs display.
@end defun

@defun display-graphic-p &optional display
This function returns @code{t} if @var{display} is a graphic display
capable of displaying several frames and several different fonts at
once.  This is true for displays that use a window system such as X,
and false for text terminals.
@end defun

@defun display-mouse-p &optional display
@cindex mouse, availability
This function returns @code{t} if @var{display} has a mouse available,
@code{nil} if not.
@end defun

@defun display-color-p &optional display
@findex x-display-color-p
This function returns @code{t} if the screen is a color screen.
It used to be called @code{x-display-color-p}, and that name
is still supported as an alias.
@end defun

@defun display-grayscale-p &optional display
This function returns @code{t} if the screen can display shades of gray.
(All color displays can do this.)
@end defun

@defun display-supports-face-attributes-p attributes &optional display
@anchor{Display Face Attribute Testing}
This function returns не-@code{nil} if all the face attributes in
@var{attributes} are supported (@pxref{Face Attributes}).

The definition of ``supported'' is somewhat heuristic, but basically
means that a face containing all the attributes in @var{attributes},
when merged with the default face for display, can be represented in a
way that's

@enumerate
@item
different in appearance than the default face, and

@item
close in spirit to what the attributes specify, if not exact.
@end enumerate

Point (2) implies that a @code{:weight black} attribute will be
satisfied by any display that can display bold, as will
@code{:foreground "yellow"} as long as some yellowish color can be
displayed, but @code{:slant italic} will @emph{not} be satisfied by
the tty display code's automatic substitution of a dim face for
italic.
@end defun

@defun display-selections-p &optional display
This function returns @code{t} if @var{display} supports selections.
Windowed displays normally support selections, but they may also be
supported in some other cases.
@end defun

@defun display-images-p &optional display
This function returns @code{t} if @var{display} can display images.
Windowed displays ought in principle to handle images, but some
systems lack the support for that.  On a display that does not support
images, Emacs cannot display a tool bar.
@end defun

@defun display-screens &optional display
This function returns the number of screens associated with the display.
@end defun

@defun display-pixel-height &optional display
This function returns the height of the screen in pixels.
On a character terminal, it gives the height in characters.

For graphical terminals, note that on multi-monitor setups this
refers to the pixel height for all physical monitors associated with
@var{display}.  @xref{Multiple Terminals}.
@end defun

@defun display-pixel-width &optional display
This function returns the width of the screen in pixels.
On a character terminal, it gives the width in characters.

For graphical terminals, note that on multi-monitor setups this
refers to the pixel width for all physical monitors associated with
@var{display}.  @xref{Multiple Terminals}.
@end defun

@defun display-mm-height &optional display
This function returns the height of the screen in millimeters,
or @code{nil} if Emacs cannot get that information.

For graphical terminals, note that on multi-monitor setups this
refers to the height for all physical monitors associated with
@var{display}.  @xref{Multiple Terminals}.
@end defun

@defun display-mm-width &optional display
This function returns the width of the screen in millimeters,
or @code{nil} if Emacs cannot get that information.

For graphical terminals, note that on multi-monitor setups this
refers to the width for all physical monitors associated with
@var{display}.  @xref{Multiple Terminals}.
@end defun

@defopt display-mm-dimensions-alist
This variable allows the user to specify the dimensions of graphical
displays returned by @code{display-mm-height} and
@code{display-mm-width} in case the system provides incorrect values.
@end defopt

@cindex backing store
@defun display-backing-store &optional display
This function returns the backing store capability of the display.
Backing store means recording the pixels of windows (and parts of
windows) that are not exposed, so that when exposed they can be
displayed very quickly.

Values can be the symbols @code{always}, @code{when-mapped}, or
@code{not-useful}.  The function can also return @code{nil}
when the question is inapplicable to a certain kind of display.
@end defun

@cindex SaveUnder feature
@defun display-save-under &optional display
This function returns не-@code{nil} if the display supports the
SaveUnder feature.  That feature is used by pop-up windows
to save the pixels they obscure, so that they can pop down
quickly.
@end defun

@defun display-planes &optional display
This function returns the number of planes the display supports.
This is typically the number of bits per pixel.
For a tty display, it is log to base two of the number of colors supported.
@end defun

@defun display-visual-class &optional display
This function returns the visual class for the screen.  The value is
one of the symbols @code{static-gray} (a limited, unchangeable number
of grays), @code{gray-scale} (a full range of grays),
@code{static-color} (a limited, unchangeable number of colors),
@code{pseudo-color} (a limited number of colors), @code{true-color} (a
full range of colors), and @code{direct-color} (a full range of
colors).
@end defun

@defun display-color-cells &optional display
This function returns the number of color cells the screen supports.
@end defun

  These functions obtain additional information about the window
system in use where Emacs shows the specified @var{display}.  (Their
names begin with @code{x-} for historical reasons.)

@defun x-server-version &optional display
This function returns the list of version numbers of the GUI window
system running on @var{display}, such as the X server on GNU and Unix
systems.  The value is a list of three integers: the major and minor
version numbers of the protocol, and the distributor-specific release
number of the window system software itself.  On GNU and Unix systems,
these are normally the version of the X protocol and the
distributor-specific release number of the X server software.  On
MS-Windows, this is the version of the Windows OS.
@end defun

@defun x-server-vendor &optional display
This function returns the vendor that provided the window system
software (as a string).  On GNU and Unix systems this really means
whoever distributes the X server.  On MS-Windows this is the vendor ID
string of the Windows OS (Microsoft).

When the developers of X labeled software distributors as
``vendors'', they showed their false assumption that no system could
ever be developed and distributed noncommercially.
@end defun

@ignore
@defvar x-no-window-manager
This variable's value is @code{t} if no X window manager is in use.
@end defvar
@end ignore
