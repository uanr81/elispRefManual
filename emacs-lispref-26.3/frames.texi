@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2019 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Frames
@chapter Фреймы
@cindex frame

  @dfn{Фрейм} - экранный объект, содержащий одно или несколько окон Emacs
(@pxref{Windows}).  Это объект, который в терминологии графической среды
называется ``окно''; но здесь не получится назвать ``окном'', потому что
Emacs использует это слово для-другого.  В Emacs Lisp @dfn{объект фрейм} -
это объект Lisp, представляющий фрейм на экране.  @xref{Frame Type}.

  Фрейм изначально содержит одно главное окно и/или окно минибуфера; можно
разделить главное окно по вертикали или горизонтали на более мелкие окна.
@xref{Splitting Windows}.

@cindex terminal
  @dfn{Терминал} - это устройство отображения, способное отображать один или
несколько фреймов Emacs.  В Emacs Lisp @dfn{объект терминал} - это объект
Lisp, представляющий терминал.  @xref{Terminal Type}.

@cindex text terminal
@cindex graphical terminal
@cindex graphical display
  Есть два класса терминалов: @dfn{текстовые терминалы} и
@dfn{графические терминалы}.  Текстовые терминалы - это дисплеи без
поддержки графики, включая @command{xterm} и другие эмуляторы терминала.  В
текстовом терминале каждый фрейм Emacs занимает весь экран терминала; хотя
можно создавать дополнительные фреймы и переключаться между ними, терминал
показывает только фрейм за раз.  С другой стороны, графические терминалы
управляются системами графического отображения, такими как X Window System,
которые позволяют Emacs отображать несколько фреймов одновременно на одном и
том же дисплее.

  В системах GNU и Unix можно создавать дополнительные фреймы на любом
доступном терминале в рамках одного сеанса Emacs, независимо от того, был ли
Emacs запущен на текстовом или графическом терминале.  Emacs может
одновременно отображать как на графическом, так и на текстовом терминалах.
Это удобно, например, когда подключаться к одному сеансу из нескольких
удаленных мест.  @xref{Multiple Terminals}.

@defun framep object
Этот предикат возвращает значение не-@code{nil}, если @var{object} является
фреймом, и @code{nil} в противном случае.  Для фрейма значение указывает,
какой вид отображения используется в фрейме:

@table @code
@item t
Фрейм отображается на текстовом терминале.
@item x
Фрейм отображается на графическом терминале X.
@item w32
Фрейм отображается на графическом терминале MS-Windows.
@item ns
Фрейм отображается в графическом терминале GNUstep или Macintosh Cocoa.
@item pc
Фрейм отображается на терминале MS-DOS.
@end table
@end defun

@defun frame-terminal &optional frame
Функция возвращает объект терминала, который отображает @var{frame}.  Если
@var{frame} равен @code{nil} или не указан, по умолчанию используется
выбранный фрейм.
@end defun

@defun terminal-live-p object
Этот предикат возвращает значение не-@code{nil}, если @var{object} - это
активный терминал (то есть не удаленный), и @code{nil} в противном случае.
Для работающих терминалов возвращаемое значение указывает, какие фреймы
отображаются на этом терминале; список возможных значений такой же, как и
для @code{framep} выше.
@end defun

@cindex top-level frame
На графическом терминале различаются два типа фреймов: Обычный
@dfn{фрейм верхнего уровня} - это фрейм, окно оконной системы которого
является дочерним по отношению к корневому окну оконной системы для этого
терминала.  Дочерний фрейм - это фрейм, окно оконной системы которого
является дочерним по отношению к окну оконной системы другого фрейма Emacs.
@xref{Child Frames}.

@menu
* Creating Frames::             Создание дополнительных рамок.
* Multiple Terminals::         Отображение на нескольких разных устройствах.
* Frame Geometry::              Геометрические свойства фреймов.
* Frame Parameters::            Управление размером фрейма, положением,
                                   шрифтом и так далее.
* Terminal Parameters::         Параметры общие для всех фреймов
                                   на терминале.
* Frame Titles::               Автоматическое обновление заголовков фреймов.
* Deleting Frames::             Фреймы сохраняются до тех пор, пока не
                                   будут удалены явным образом.
* Finding All Frames::          Как изучить все существующие фреймы.
* Minibuffers and Frames::      Как фрейм находит используемый минибуфер.
* Input Focus::                 Указание выбранного кадра.
* Visibility of Frames::        Фреймы могут быть видимыми или невидимыми,
                                   а также значками.
* Raising and Lowering::        Подъем, опускание и перестановка фреймов.
* Frame Configurations::        Сохранение состояния всех кадров.
* Child Frames::                Делаем фрейм потомком для другого.
* Mouse Tracking::              Получение событий, которые говорят,
                                   когда движется мышь.
* Mouse Position::              Узнать положение мыши, перемещение мыши.
* Pop-Up Menus::                Отображение меню для выбора пользователем.
* Dialog Boxes::                Отображение поля, чтобы спросить да или нет.
* Pointer Shape::               Указание формы указателя мыши.
* Window System Selections::    Передача текста другим X-клиентам и от них.
* Drag and Drop::               Внутреннее устройство реализации
                                   Drag-and-Drop.
* Color Names::                 Получение определений названий цветов.
* Text Terminal Colors::        Определение цветов для текстовых терминалов.
* Resources::                   Получение значений ресурсов с сервера.
* Display Feature Testing::     Определение возможностей терминала.
@end menu


@node Creating Frames
@section Создание Фреймов
@cindex frame creation

Чтобы создать новый фрейм, вызывается функция @code{make-frame}.

@deffn Command make-frame &optional parameters
Функция создает и возвращает новый фрейм, отображающий текущий буфер.

Аргумент @var{parameters} - это список, который определяет параметры фрейма
для нового фрейма.  @xref{Frame Parameters}.  Если указан параметр
@code{terminal} в @var{parameters}, новый фрейм будет создан на этом
терминале.  В противном случае, если указан параметр фрейма
@code{window-system} в @var{parameters}, определяется, должен ли фрейм
отображаться на текстовом терминале или графическом терминале.
@xref{Window Systems}.  Если ни один из них не указан, новый фрейм создается
в том же терминале, что и выбранный фрейм.

Любые параметры, не упомянутые в @var{parameters}, по умолчанию равны
значениям в alist @code{default-frame-alist} (@pxref{Initial Parameters});
параметры, не указанные там, по умолчанию из ресурсов X или их эквивалента в
вашей операционной системе
(@pxref{X Resources,, X Resources, emacs, The GNU Emacs Manual}).  После
создания фрейма эта функция применяет любые параметры, указанные в
@code{frame-inherited-parameters} (смотреть ниже), которым еще не назначено,
беря значения из фрейма, который был выбран при вызове @code{make-frame}.

Обратить внимание, что на многомониторных дисплеях
(@pxref{Multiple Terminals}) оконный менеджер может позиционировать фрейм
иначе, чем указано в позиционных параметрах в @var{parameters}
(@pxref{Position Parameters}).  Например, у некоторых оконных менеджеров
есть политика отображения фрейма на мониторе, который содержит большую часть
окна (оно же @: монитор @dfn{доминирующий}).

Сама функция не делает новый фрейм выбранным. @xref{Input Focus}.  Ранее
выбранный фрейм остается выбранным.  Однако на графических терминалах
оконная система может выбрать новый фрейм по своим причинам.
@end deffn

@defvar before-make-frame-hook
Обычный обработчик, запускаемый @code{make-frame} перед созданием фрейма.
@end defvar

@defvar after-make-frame-functions
Аномальный перехватчик, запущенный @code{make-frame} после создания фрейма.
Каждая функция в @code{after-make-frame-functions} получает один аргумент -
только что созданный фрейм.
@end defvar

Обратить внимание, что любые функции, добавленные к этим перехватчикам вашим
начальным файлом, обычно не запускаются для начального фрейма, поскольку
Emacs читает начальный файл только после создания этого фрейма.  Однако,
если начальный фрейм задан для использования отдельного фрейма минибуфера
(@pxref{Minibuffers and Frames}), функции будут выполняться как для фрейма
без минибуфера, так и для фрейма минибуфера.

@defvar frame-inherited-parameters
Переменная определяет список параметров фрейма, которые вновь созданный
фрейм наследует от текущего выбранного фрейма.  Для каждого параметра
(символа), который является элементом в этом списке и не был назначен ранее
при обработке @code{make-frame}, функция устанавливает значение этого
параметра в созданном фрейме равным его значению в выбранном фрейме.
@end defvar


@node Multiple Terminals
@section Несколько Терминалов
@cindex multiple terminals
@cindex multi-tty
@cindex multiple X displays
@cindex displays, multiple

  Emacs представляет каждый терминал как тип данных @dfn{объект терминал}
(@pxref{Terminal Type}).  В системах GNU и Unix Emacs может использовать
несколько терминалов одновременно в каждом сеансе.  В других системах может
использовать только один терминал.  Каждый терминальный объект имеет
следующие атрибуты:

@itemize @bullet
@item
Название устройства, используемого терминалом. (такое как, @samp{:0.0} или
@file{/dev/tty}).

@item
Системы кодирования терминала и клавиатуры, используемые на терминале.
@xref{Terminal I/O Encoding}.

@item
Вид дисплея, связанный с терминалом.  Это символ, возвращаемый функцией
@code{terminal-live-p} (такое как, @code{x}, @code{t}, @code{w32},
@code{ns}, или @code{pc}).  @xref{Frames}.

@item
Список параметров терминала.  @xref{Terminal Parameters}.
@end itemize

  Примитива для создания терминальных объектов нет.  Emacs создает их по
мере необходимости, например, когда вызывается @code{make-frame-on-display}
(описано ниже).

@defun terminal-name &optional terminal
Функция возвращает имя файла устройства, используемого @var{terminal}.  Если
@var{terminal} опущен или @code{nil}, по умолчанию используется терминал
выбранного фрейма.  @var{terminal} также может быть фреймом, что означает
его терминал.
@end defun

@defun terminal-list
Функция возвращает список всех активных терминальных объектов.
@end defun

@defun get-device-terminal device
Функция возвращает терминал, имя устройства которого задано @var{device}.
Если @var{device} - строка, это может быть либо имя файла терминального
устройства, либо имя X-дисплея в форме
@samp{@var{host}:@var{server}.@var{screen}}.  Если @var{device} - это фрейм,
функция возвращает терминал этого фрейма; @code{nil} означает выбранный
фрейм.  Наконец, если @var{device} - это объект терминала, представляющий
работающий терминал, этот терминал возвращается.  Функция сигнализирует об
ошибке, если ее аргумент не соответствует ни одному из вышеперечисленных.
@end defun

@defun delete-terminal &optional terminal force
Функция удаляет все фреймы на @var{terminal} и освобождает используемые им
ресурсы.  Запускает ненормальную ловушку @code{delete-terminal-functions},
передавая @var{terminal} в качестве аргумента каждой функции.

Если @var{terminal} опущен или @code{nil}, по умолчанию используется
терминал выбранного фрейма.  @var{terminal} также может быть фреймом, что
означает его терминал.

Обычно функция сигнализирует об ошибке, если попытаться удалить единственный
активный терминал, но если @var{force} - не-@code{nil}, это можно сделать.
Emacs автоматически вызывает эту функцию, когда последний фрейм на терминале
удаляется (@pxref{Deleting Frames}).
@end defun

@defvar delete-terminal-functions
Ненормальная ловушка, запускаемая @code{delete-terminal}.  Каждая функция
получает один аргумент, аргумент @var{terminal} передается в
@code{delete-terminal}.  По техническим причинам функции могут вызываться
либо непосредственно перед удалением терминала, либо сразу после него.
@end defvar

@cindex terminal-local variables
  Несколько переменных Lisp: @dfn{terminal-local}; то есть у них есть
отдельная привязка для каждого терминала.  В любой момент действует привязка
для терминала, которому принадлежит текущий выбранный фрейм.  Эти переменные
включают @code{default-minibuffer-frame}, @code{defining-kbd-macro},
@code{last-kbd-macro} и @code{system-key-alist}.  Они всегда локальны для
терминала и никогда не могут быть локальными для буфера
(@pxref{Buffer-Local Variables}).

  В системах GNU и Unix каждый дисплей X представляет собой отдельный
графический терминал.  Когда Emacs запускается из оконной системы X, он
использует отображение X, заданное переменной среды @env{DISPLAY} или
параметром @samp{--display}
(@pxref{Initial Options,,, emacs, The GNU Emacs Manual}).  Emacs может
подключаться к другим дисплеям X с помощью команды
@code{make-frame-on-display}.  Каждый X-дисплей имеет свой собственный
выбранный фрейм и свои собственные окна минибуфера; однако только один из
этих фреймов является @emph{по настоящему} выбранным фреймом в любой момент
(@pxref{Input Focus}).  Emacs может даже подключаться к другим текстовым
терминалам, взаимодействуя с программой @command{emacsclient}.
@xref{Emacs Server,,, emacs, The GNU Emacs Manual}.

@cindex X display names
@cindex display name on X
  Один X-сервер может обрабатывать более одного дисплея.  Каждый дисплей X
имеет имя, состоящее из трех частей,
@samp{@var{hostname}:@var{displaynumber}.@var{screennumber}}.  Первая часть,
@var{hostname}, определяет имя машины, к которой физически подключен
дисплей.  Вторая часть, @var{displaynumber}, представляет собой
отсчитываемое от нуля число, которое идентифицирует один или несколько
мониторов, подключенных к этому компьютеру, которые имеют общую клавиатуру и
указывающее устройство (мышь, планшет и так далее).  Третья часть,
@var{screennumber}, определяет отсчитываемый от нуля номер экрана (отдельный
монитор), который является частью одной коллекции мониторов на этом
X-сервере.  Когда используется два или более экрана, принадлежащих одному
серверу, Emacs знает по схожести их имен, что они используют одну
ключевую карту.

  Системы, которые не используют систему X Window, такие как MS-Windows, не
поддерживают понятие X-дисплеев и имеют только один дисплей на каждом хосте.
Отображаемое имя в этих системах не соответствует указанному выше формату из
трех частей; например, отображаемое имя в системах MS-Windows представляет
собой постоянную строку @samp{w32} и существует для совместимости, чтобы
иметь возможность передавать ее функциям, ожидающим отображаемое имя.

@deffn Command make-frame-on-display display &optional parameters
Функция создает и возвращает новый фрейм на @var{display}, беря другие
параметры фрейма из alist @var{parameters}.  @var{display} должно быть
именем X-дисплея (строка).

Перед созданием фрейма эта функция гарантирует, что Emacs настроен для
отображения графики.  Например, если Emacs не обработал X-ресурсы (например,
если он был запущен на текстовом терминале), он делает это в это время.  В
остальном эта функция ведет себя как @code{make-frame}
(@pxref{Creating Frames}).
@end deffn

@defun x-display-list
Функция возвращает список, указывающий, к какому отображению X имеет
соединение Emacs.  Элементы списка представляют собой строки, и каждый из
них является отображаемым именем.
@end defun

@defun x-open-connection display &optional xrm-string must-succeed
Функция открывает соединение с X-дисплеем @var{display} без создания фрейма
на этом дисплее.  Обычно программы Emacs Lisp не нуждаются в вызове этой
функции, поскольку @code{make-frame-on-display} вызывает ее автоматически.
Единственная причина для его вызова - проверить, можно ли установить связь
с данным дисплеем X.

Необязательный аргумент @var{xrm-string}, если не @code{nil}, представляет
собой строку имен и значений ресурсов в том же формате, что и в файле
@file{.Xresources}.
@xref{X Resources,, X Resources, emacs, The GNU Emacs Manual}. Эти значения
применяются ко всем фреймам Emacs, созданным на этом дисплее, перекрывая
значения ресурсов, записанные на X-сервере.  Вот пример того, как может
выглядеть эта строка:

@example
"*BorderWidth: 3\n*InternalBorder: 2\n"
@end example

Если @var{must-succeed} равен не-@code{nil}, то при отказе от открытия
соединения Emacs завершается.  В противном случае это обычная ошибка Lisp.
@end defun

@defun x-close-connection display
Функция закрывает соединение для отображения @var{display}.  Прежде чем
можно это сделать, потребуется сначала удалить все фреймы, которые были
открыты на этом дисплее (@pxref{Deleting Frames}).
@end defun

@cindex multi-monitor
  В некоторых конфигурациях с несколькими мониторами один X-дисплей
выводится на несколько физических мониторов.  Можно использовать функции
@code{display-monitor-attributes-list} и @code{frame-monitor-attributes} для
получения информации о таких настройках.

@defun display-monitor-attributes-list &optional display
Функция возвращает список атрибутов физического монитора на @var{display},
который может быть отображаемым именем (строкой), терминалом или фреймом;
если опущено или @code{nil}, по умолчанию используется отображение
выбранного фрейма.  Каждый элемент списка представляет собой список
ассоциаций, представляющий атрибуты физического монитора.  Первый элемент
соответствует основному монитору.  Ключи и значения атрибутов::

@table @samp
@item geometry
Положение левого верхнего угла экрана монитора и его размер в пикселях как
@samp{(@var{x} @var{y} @var{width} @var{height})}.  Обратить внимание: если
монитор не является основным, некоторые координаты могут быть
отрицательными.

@item workarea
Положение левого верхнего угла и размер рабочей области (полезного
пространства) в пикселях формируется как
@samp{(@var{x} @var{y} @var{width} @var{height})}.  Это может отличаться от
@samp{geometry} тем, что пространство занято различными функциями оконного
менеджера (доки, панели задач и так далее)@: и может быть исключено из
рабочей зоны.  То, действительно ли такие функции удаляются из рабочей
области, зависит от платформы и среды.  Опять же, если монитор не является
основным монитором, некоторые координаты могут быть отрицательными.

@item mm-size
Ширина и высота в миллиметрах как @samp{(@var{width} @var{height})}

@item frames
Список фреймов, доминирующих на этом физическом мониторе (смотреть ниже).

@item name
Имя физического монитора @var{string}.

@item source
Источник мультимониторной информации как @var{string}; например,
@samp{XRandr} или @samp{Xinerama}.
@end table

@var{x}, @var{y}, @var{width} и @var{height} целые числа.
@samp{name} и @samp{source} могут отсутствовать.

Фрейм становится @dfn{доминирующим} на физическом мониторе, когда либо самая
большая область фрема находится на этом мониторе, либо (если кадр не
пересекает никакие физические мониторы) этот монитор является ближайшим к
фрейму.  В каждом (не всплывающем) фрейме (видимом или невидимом) на
графическом дисплее доминирует ровно один физический монитор за раз, хотя
фрейм может охватывать несколько (или ни одного) физических мониторов.

Вот пример данных, созданных этой функцией на дисплее с двумя мониторами:

@lisp
  (display-monitor-attributes-list)
  @result{}
  (((geometry 0 0 1920 1080) ;; @r{Левая основная панель задач monitor}
    (workarea 0 0 1920 1050) ;; @r{занимает часть высоты}
    (mm-size 677 381)
    (name . "DISPLAY1")
    (frames #<frame emacs@@host *Messages* 0x11578c0>
            #<frame emacs@@host *scratch* 0x114b838>))
   ((geometry 1920 0 1680 1050) ;; @r{Правый монитор }
    (workarea 1920 0 1680 1050) ;; @r{можно использовать весь экран}
    (mm-size 593 370)
    (name . "DISPLAY2")
    (frames)))
@end lisp

@end defun

@defun frame-monitor-attributes &optional frame
Функция возвращает атрибуты доминирующего физического монитора (смотреть
выше) @var{frame}, который по умолчанию соответствует выбранному фрейму.
@end defun


@node Frame Geometry
@section Геометрия Фрейма
@cindex frame geometry
@cindex frame position
@cindex position of frame
@cindex frame size
@cindex size of frame

Геометрия фрейма зависит от набора инструментов, который использовался для
создания этого экземпляра Emacs, и терминала, отображающего фрейм.  В этой
главе описаны эти зависимости и некоторые функции для их устранения.
Обратить внимание, что аргумент @var{frame} всех этих функций должен
указывать активный фрейм (@pxref{Deleting Frames}).  Если опущено или
@code{nil}, указывается выбранный фрейм (@pxref{Input Focus}).

@menu
* Frame Layout::            Базовая компоновка фреймов.
* Frame Font::              Шрифт фрейма по умолчанию и как его установить.
* Frame Position::          Положение фрейма на его дисплее.
* Frame Size::              Определение и получение размера фрейма.
* Implied Frame Resizing::  Подразумевается изменение размера фреймов и
                               как этого избежать.
@end menu


@node Frame Layout
@subsection Макет Фрейма
@cindex frame layout
@cindex layout of frame

Видимая фрейм занимает прямоугольную область на дисплее терминала.  Эта
область может содержать несколько вложенных прямоугольников, каждый из
которых служит своей цели.  На приведенном ниже рисунке схематично показано
расположение фрейма на графическом терминале.:
@smallexample
@group

        <------------ Outer Frame Width ----------->
        ____________________________________________
     ^(0)  ________ External/Outer Border _______   |
     | |  |_____________ Title Bar ______________|  |
     | | (1)_____________ Menu Bar ______________|  | ^
     | | (2)_____________ Tool Bar ______________|  | ^
     | | (3) _________ Internal Border ________  |  | ^
     | |  | |   ^                              | |  | |
     | |  | |   |                              | |  | |
Outer  |  | | Inner                            | |  | Native
Frame  |  | | Frame                            | |  | Frame
Height |  | | Height                           | |  | Height
     | |  | |   |                              | |  | |
     | |  | |<--+--- Inner Frame Width ------->| |  | |
     | |  | |   |                              | |  | |
     | |  | |___v______________________________| |  | |
     | |  |___________ Internal Border __________|  | v
     v |___________ External/Outer Border __________|
           <-------- Native Frame Width -------->

@end group
@end smallexample

На практике не все области, показанные на чертеже, будут или могут
присутствовать.  Значение этих областей описано ниже.

@table @asis
@item Outer Frame
@cindex outer frame
@cindex outer edges
@cindex outer width
@cindex outer height
@cindex outer size
@dfn{outer frame} - это прямоугольник, включающий все области, показанные на
чертеже.  Края этого прямоугольника называются @dfn{outer edges} фрейма.
Вместе @dfn{outer width} и @dfn{outer height} фрейма задают @dfn{outer size}
этого прямоугольника.

Знание внешнего размера фрейма полезно для размещения фрейма в рабочей
области его дисплея (@pxref{Multiple Terminals}) или для размещения двух
фреймов рядом друг с другом на экране.  Обычно внешний размер фрейма
доступен только после того, как фрейм был отображен (сделан видимым,
@pxref{Visibility of Frames}) хотя бы один раз.  Для начального фрейма или
фрейма, который еще не был создан, внешний размер может быть только оценен
или должен быть вычисляется из значений по умолчанию оконной системы или
оконного менеджера.  Один обходной путь состоит в том, чтобы получить
различия внешнего и собственного (смотреть ниже) размеров отображаемого
фрейма и использовать их для вычисления внешнего размера нового фрейма.

@cindex outer position
Положение верхнего левого угла внешнего фрейма (обозначено @samp{(0)} на
рисунке выше) - это @dfn{outer position} фрейма.  Внешнее положение
графического фрейма также называется ``позиция'' фрейма, потому что оно
обычно остается неизменным на его дисплее всякий раз, когда изменяется
размер фрейма или изменяется его макет.

Внешняя позиция определяется и может быть установлена через параметры фрейма
@code{left} и @code{top} (@pxref{Position Parameters}).  Для обычного фрейма
верхнего уровня эти параметры обычно представляют его абсолютное положение
(смотреть ниже) по отношению к исходной точке его отображения.  Для
дочернего фрейма (@pxref{Child Frames}) эти параметры представляют его
положение относительно исходного положения (смотреть ниже) его родительского
фрейма.  Для фреймов на текстовых терминалах значения этих параметров
бессмысленны и всегда равны нулю.

@item External Border
@cindex external border
@dfn{external border} - это часть декораций, предоставляемых оконным
менеджером.  Обычно используется для изменения размера фрейма с помощью мыши
и поэтому не отображается в ``fullboth'' и максимальных параметрах фрейма
(@pxref{Size Parameters}).  Его ширина определяется оконным менеджером и не
может быть изменена функциями Emacs.

На фреймах текстового терминала отсутствуют внешние границы.  Для
графических фреймов их отображение можно запретить, установив параметр
фрейма @code{override-redirect} или @code{undecorated}
(@pxref{Management Parameters}).

@item Outer Border
@cindex outer border
@dfn{outer border} - это отдельный фрейм рамка, ширину которого можно
указать с помощью параметра фрейма @code{border-width}
(@pxref{Layout Parameters}).  На практике отображается либо внешняя, либо
внешняя граница фрейма, но никогда обе одновременно.  Обычно внешняя граница
отображается только для специальных фреймов, которые не (полностью)
контролируются оконным менеджером, например фреймы всплывающих подсказок
(@pxref{Tooltips}), дочерние фреймы (@pxref{Child Frames}) и
@code{undecorated} или @code{override-redirect} фреймы
(@pxref{Management Parameters}).

Внешние границы никогда не отображаются на фреймах текстового терминала и
фреймах, сгенерированных подпрограммами GTK+.  В MS-Windows внешняя граница
эмулируется с помощью внешней границы шириной в один пиксель.
Не-инструментальные сборки на X позволяют изменять цвет внешней границы,
задав параметр фрейма @code{border-color} (@pxref{Layout Parameters}).

@item Title Bar
@cindex title bar
@cindex caption bar
@dfn{title bar}, он же @dfn{caption bar}, также является частью декораций
оконного менеджера и обычно отображает заголовок фрейма
(@pxref{Frame Titles}), а также кнопки для минимизации, развертывания и
удаления фрейма.  Его также можно использовать для перетаскивания фрейма
мышью.  Строка заголовка обычно не отображается для всех фреймов
(@pxref{Size Parameters}), всплывающих подсказок (@pxref{Tooltips}) и
дочерних фреймов (@pxref{Child Frames}) и не существует для оконечных
фреймов.  Отображение строки заголовка можно отключить, задав параметры
фрейма @code{override-redirect} или @code{undecorated}
(@pxref{Management Parameters}).

@item Menu Bar
@cindex internal menu bar
@cindex external menu bar
Строка меню (@pxref{Menu Bar}) может быть внутренней (нарисованной самим
Emacs) или внешней (нарисованной набором инструментов).  Большинство сборок
(GTK+, Lucid, Motif и MS-Windows) полагаются на внешнюю строку меню.  NS
также использует внешнюю строку меню, которая, однако, не является частью
внешнего фрейма.  Сборки без инструментов могут содержать внутреннюю строку
меню.  В фреймах текстового терминала строка меню является частью корневого
окна фрейма (@pxref{Windows and Frames}).  Как правило, в дочерних фреймах
(@pxref{Child Frames}) строки меню никогда не отображаются.  Отображение
строки меню можно отключить, установив параметр @code{menu-bar-lines}
(@pxref{Layout Parameters}) равным нулю.

Будет ли строка меню обернута или усечена, когда ее ширина становится
слишком большой, чтобы поместиться в ее фрейм, зависит от набора
инструментов.  Обычно только сборки Motif и MS-Windows могут обернуть строку
меню.  Когда они (отменяют) обёртывают строки меню, стараются сохранить
внешнюю высоту фрейма неизменной, поэтому вместо этого изменится собственная
высота фрейма (смотреть ниже).

@item Tool Bar
@cindex internal tool bar
@cindex external tool bar
Как и строка меню, панель инструментов (@pxref{Tool Bar}) может быть
внутренней (нарисованная самим Emacs) или внешней (нарисованная набором
инструментов).  В сборках GTK + и NS панель инструментов нарисована набором
инструментов.  В остальных сборках используются внутренние панели
инструментов.  С GTK+ панель инструментов может быть расположена с любой
стороны фрейма, сразу за внутренней границей, смотреть ниже.  Панели
инструментов обычно не отображаются для дочерних фреймов
(@pxref{Child Frames}).  Отображение панели инструментов можно отключить,
установив параметр @code{tool-bar-lines} (@pxref{Layout Parameters}) равным
нулю.

Если переменная @code{auto-resize-tool-bars} равна не-@code{nil}, Emacs
оборачивает внутреннюю панель инструментов, когда ее ширина становится
слишком большой для ее фрейма.  Если и когда Emacs (отменяет-) обертывает
внутреннюю панель инструментов, по умолчанию сохраняет внешнюю высоту фрейма
неизменной, поэтому вместо этого изменится собственная высота фрейма
(смотреть ниже). Emacs, созданный с помощью GTK +, с другой стороны, никогда
не оборачивает панель инструментов, но может автоматически увеличивать
внешнюю ширину фрейма, чтобы приспособить слишком длинную панель
инструментов.

@item Native Frame
@cindex native frame
@cindex native edges
@cindex native width
@cindex native height
@cindex native size
@dfn{native frame} - это прямоугольник, полностью расположенный внутри
внешнего фрейма.  Он исключает области, занятые внешней границей, строкой
заголовка и любым внешним меню или панелью инструментов.  Края родного
фрейма называются @dfn{native edges} фрейма.  Вместе @dfn{native width} и
@dfn{native height} фрейма определяют @dfn{native size} фрейма.

Собственный размер фрейма - это размер, который Emacs передает оконной
системе или оконному менеджеру при создании или изменении размера фрейма из
Emacs.  Это также размер, который Emacs получает от оконной системы или
оконного менеджера всякий раз, когда они изменяют размер окна оконной
системы фрейма, например, после максимизации фрейма путем нажатия
соответствующей кнопки в строке заголовка или при перетаскивании его внешней
границы мышью.

@cindex native position
Положение верхнего левого угла собственного фрейма определяет
@dfn{native position} фрейма.  (1) - (3) на рисунке выше указывают, что
положение для различных сборок:

@itemize @w{}
@item (1) не-toolkit и терминальные фреймы

@item (2) Lucid, Motif и MS-Windows фреймы

@item (3) GTK+ и NS фреймы
@end itemize

Соответственно, собственная высота фрейма может включать высоту панели
инструментов, но не высоту строки меню (Lucid, Motif, MS-Windows) или высоту
строки меню и панели инструментов (фреймы без инструментов и текстовые
терминалы).

Собственная позиция фрейма - это опорная позиция для функций, которые
устанавливают или возвращают текущую позицию мыши (@pxref{Mouse Position}),
а также для функций, работающих с положением окон, таких как
@code{window-edges}, @code{window-at} или @code{coordinates-in-window-p}
(@pxref{Coordinates and Windows}).  Также определяет (0, 0) источник для
поиска и позиционирования дочерних фреймов внутри этого фрейма
(@pxref{Child Frames}).

Также обратить внимание, что исходное положение фрейма обычно остается
неизменным на его дисплее при удалении или добавлении декораций оконного
менеджера путем изменения параметра фрейма @code{override-redirect} или
@code{undecorated} (@pxref{Management Parameters}).

@item Internal Border
Внутренняя граница - это граница, нарисованная Emacs вокруг внутреннего
фрейма (смотреть ниже).  Её ширина задается параметром фрейма
@code{internal-border-width} (@pxref{Layout Parameters}).  Её цвет
определяется фоном фрейма @code{internal-border}.

@item Inner Frame
@cindex inner frame
@cindex inner edges
@cindex inner width
@cindex inner height
@cindex inner size
@cindex display area
@dfn{inner frame} - это прямоугольник, зарезервированный для окон фрейма.
Заключен во внутренний фрейм, который, однако, не является частью
внутреннего фрейма.  Его края называются @dfn{inner edges} фрейма.
@dfn{inner width} и @dfn{inner height} указывают @dfn{inner size}
прямоугольника.  Внутренний фрейм иногда также называют @dfn{display area}
фрейма.

@cindex minibuffer-less frame
@cindex minibuffer-only frame
Как правило, внутренний фрейм подразделяется на корневое окно фрейма
(@pxref{Windows and Frames}) и окно минибуфера фрейма
(@pxref{Minibuffer Windows}).  Из этого правила есть два заметных
исключения: @dfn{minibuffer-less frame} содержит только корневое окно и не
содержит окно минибуфера.  @dfn{minibuffer-only frame} содержит только окно
минибуфера, которое также служит корневым окном этого фрейма.
@ref{Initial Parameters} о том, как создавать такие конфигурации фреймов.

@item Text Area
@cindex text area
@dfn{text area} фрейма - это несколько вымышленная область, которая может
быть встроена в исходный фрейм.  Её положение не указано.  Её ширину можно
получить, удалив из исходной ширины ширину внутренней границы, одной
вертикальной полосы прокрутки, а также одной левой и одной правой кромок,
если они указаны для этого фрейма, @ref{Layout Parameters}.  Её высоту можно
получить, удалив из исходной высоты ширину внутренней границы и высоту
внутреннего меню и панелей инструментов фрейма, а также одну горизонтальную
полосу прокрутки, если она указана для этого фрейма.
@end table

@cindex absolute position
@cindex absolute frame position
@cindex absolute edges
@cindex absolute frame edges
@cindex display origin
@cindex origin of display
@dfn{absolute position} кадра задается как пара (X, Y) горизонтальных и
вертикальных смещений пикселей относительно исходной точки (0, 0)
отображения фрейма.  Соответственно, @dfn{absolute edges} фрейма задаются
как пиксельные смещения от этого источника.

  Обратить внимание, что при использовании нескольких мониторов исходная
точка дисплея не обязательно совпадает с верхним левым углом всей
используемой области отображения терминала.  Следовательно, абсолютное
положение фрейма может быть отрицательным в такой среде, даже когда этот
фрейм полностью виден.

  По соглашению вертикальные смещения увеличивают ``downwards''.  Это
означает, что высота фрейма получается вычитанием смещения его верхнего края
из смещения его нижнего края.  Горизонтальные смещения увеличивают
``rightwards'', как и ожидалось, поэтому ширина фрейма рассчитывается путем
вычитания смещения его левого края из смещения его правого края.

  Для фрейма на графическом терминале следующая функция возвращает размеры
описанных выше областей.:

@defun frame-geometry &optional frame
Функция возвращает геометрические атрибуты @var{frame}.  Возвращаемое
значение - это список ассоциаций атрибутов, перечисленных ниже.  Все
значения координат, высоты и ширины являются целыми числами, считая пиксели.
Обратить внимание, что если @var{frame} еще не отображен,
(@pxref{Visibility of Frames}) некоторые из возвращаемых значений могут
представлять только приближения фактических значений - тех, которые можно
увидеть после отображения фрейма.

@table @code
@item outer-position
Cons-ячейка, представляющая абсолютную позицию внешнего @var{frame}
относительно начала координат в позиции (0, 0) отображения @var{frame}.

@item outer-size
Cons-ячейка внешней ширины и высоты @var{frame}.

@item external-border-size
Cons-ячейка горизонтальной и вертикальной ширины внешних границ @var{frame},
предоставляемых оконным менеджером.  Если оконный менеджер не предоставляет
эти значения, Emacs попытается угадать их по координатам внешнего и
внутреннего фрейма.

@item outer-border-width
Ширина внешней границы @var{frame}.  Значение имеет смысл только для сборок,
не относящихся к GTK+ и X.

@item title-bar-size
Cons-ячейки ширины и высоты строки заголовка @var{frame}, предоставляемые
оконным менеджером или операционной системой.  Если обе они равны нулю, у
фрейма нет строки заголовка.  Если только ширина равна нулю, Emacs не смог
получить информацию о ширине.

@item menu-bar-external
Если не-@code{nil}, это означает, что строка меню является внешней (не
является частью собственного фрейма @var{frame}).

@item menu-bar-size
Cons-ячейки ширины и высоты строки меню @var{frame}.

@item tool-bar-external
Если не-@code{nil}, это означает, что панель инструментов является внешней
(не является частью собственного фрейма @var{frame}).

@item tool-bar-position
Говорит о том, с какой стороны находится панель инструментов на @var{frame},
и может быть одним из @code{left}, @code{top}, @code{right} или
@code{bottom}.  Единственный инструментарий, который в настоящее время
поддерживает значение, отличное от @code{top} - это GTK+.

@item tool-bar-size
Cons-чейки ширины и высоты панели инструментов @var{frame}.

@item internal-border-width
Ширина внутренней границы @var{frame}.
@end table
@end defun

Следующая функция может использоваться для получения краев внешнего и
внутреннего фреймов.

@defun frame-edges &optional frame type
Функция возвращает абсолютные границы внешнего, собственного или внутреннего
фрейма @var{frame}.  @var{frame} должен быть активным фреймом и по умолчанию
быть выбранным.  Возвращенный список имеет вид
@w{@code{(@var{left} @var{top} @var{right} @var{bottom})}}, где все значения
указаны в пикселях относительно исходной точки отображения @var{frame}.  Для
терминальных фреймов значения, возвращаемые для @var{left} и @var{top},
всегда равны нулю.

Необязательный аргумент @var{type} указывает тип возвращаемых краёв:
@code{outer-edges} означает возвращать внешние края @var{frame},
@code{native-edges} (или @code{nil}) означает возвращать собственные края,
а @code{inner-edges} означает возвращать внутренние края.

По соглашению пиксели дисплея при значениях, возвращаемых для @var{left} и
@var{top}, считаются находящимися внутри (частью) @var{frame}.
Следовательно, если оба @var{left} и @var{top} равны нулю, пиксель в
исходной точке дисплея является частью @var{frame}.  С другой стороны,
пиксели в @var{bottom} и @var{right} считаются лежащими непосредственно за
пределами @var{frame}.  Это означает, что если есть, например, два соседних
фрейма, расположенных так, что правый внешний край фрейма слева равен левому
внешнему краю фрейма справа, пиксели на этом краю показывают часть фрейма
справа.
@end defun


@node Frame Font
@subsection Шрифт Фрейма
@cindex default font
@cindex default character size
@cindex default character width
@cindex default width of character
@cindex default character height
@cindex default height of character
У каждого фрейма есть @dfn{шрифт по умолчанию}, который определяет размер
символа по умолчанию для этого фрейма.  Этот размер подразумевается при
извлечении или изменении размера фрейма с точки зрения столбцов или строк
(@pxref{Size Parameters}).  Также используется при изменении размера
(@pxref{Window Sizes}) или разделении (@pxref{Splitting Windows}) окна.

@cindex line height
@cindex column width
@cindex canonical character height
@cindex canonical character width
Иногда вместо ``высота символа по умолчанию'' используются термины
@dfn{высота линии} и @dfn{каноническая высота символа}.  Точно так же
термины @dfn{ширина колонки} и @dfn{каноническая ширина символа}
используются вместо ``ширина символа по умолчанию''.

@defun frame-char-height &optional frame
@defunx frame-char-width &optional frame
Функции возвращают высоту и ширину символа в @var{frame} по умолчанию,
измеренную в пикселях.  Вместе эти значения определяют размер шрифта по
умолчанию на @var{frame}.  Значения зависят от выбора шрифта для
@var{frame}, смотреть @ref{Font and Color Parameters}.
@end defun

Шрифт по умолчанию также можно установить напрямую с помощью следующей
функции:

@deffn Command set-frame-font font &optional keep-size frames
Устанавливает шрифт по умолчанию @var{font}.  При интерактивном вызове
запрашивает имя шрифта и использует этот шрифт в выбранном фрейме.  При
вызове из Lisp @var{font} должен быть именем шрифта (строка), объектом
шрифта, сущностью шрифта или спецификацией шрифта.

Если необязательный аргумент @var{keep-size} - @code{nil}, сохраняется
количество строк и столбцов фрейма фиксированным.  (Если не-@code{nil},
параметр @code{frame-inhibit-implied-resize}, описанный в следующем разделе,
переопределит это.)  Если @var{keep-size} равен не-@code{nil} (или с
аргументом префикса), пытается сохраниться размер области отображения
текущего фрейма фиксированным, регулируя количество строк и столбцы.

Если необязательный аргумент @var{frames} - @code{nil}, шрифт применяется
только к выбранному фрейму.  Если @var{frames} - это не-@code{nil}, это
должен быть список фреймов, над которыми нужно действовать, или @code{t},
означающий все существующие и все будущие графические фреймы.
@end deffn


@node Frame Position
@subsection Положение Фрейма
@cindex frame position
@cindex position of frame

В графических системах положение нормального фрейма верхнего уровня
определяется как абсолютное положение его внешнего фрейма
(@pxref{Frame Geometry}).  Положение дочернего фрейма (@pxref{Child Frames})
задается через пиксельные смещения его внешних краев относительно исходного
положения его родительского кадра.

  Можно получить доступ или изменить положение фрейма, используя параметры
фрейма @code{left} и @code{top} (@pxref{Position Parameters}).  Вот две
дополнительные функции для работы с позициями существующего видимого фрейма.
Для обеих функций аргумент @var{frame} должен обозначать активный фрейм и
по умолчанию использовать выбранный фрейм.

@defun frame-position &optional frame
Для нормального, не дочернего фрейма эта функция возвращает cons-координаты
пиксельных координат его внешнего положения (@pxref{Frame Layout})
относительно исходной точки @code{(0, 0)} его отображения.  Для дочернего
фрейма (@pxref{Child Frames}) эта функция возвращает пиксельные координаты
его внешней позиции относительно исходной точки @code{(0, 0)} в исходной
позиции родительского фрейма @var{frame}.

Отрицательные значения никогда не указывают на смещение от правого или
нижнего края дисплея @var{frame} или родительского фрейма.  Скорее, они
означают, что внешняя позиция @var{frame} находится слева и/или над исходной
точкой его отображения или исходной позицией его родительского фрейма.
Обычно это означает, что @var{frame} виден только частично (или полностью не
видим).  Однако в системах, где исходная точка дисплея не совпадает с его
верхним левым углом, рамка может быть видна на дополнительном мониторе.

В фрейме текстового терминала оба значения равны нулю.
@end defun

@defun set-frame-position frame x y
Функция устанавливает внешнюю позицию фрейма @var{frame} на (@var{x},
@var{y}).  Последние аргументы определяют пиксели и обычно отсчитывают от
начала координат в позиции (0, 0) дисплея @var{frame}.  Для дочерних фреймов
они отсчитываются от исходной позиции родительского фрейма @var{frame}.

Отрицательные значения параметров позиционируют правый край внешнего фрейма
на @var{-x} пикселей слева от правого края экрана (или собственного
прямоугольника родительского фрейма), а нижний край на @var{-y} пикселей
вверх от нижнего края экрана (или родительского фрейма) родного
прямоугольника.

Обратить внимание, что отрицательные значения не позволяют выровнять правый
или нижний край @var{frame} точно по правому или нижнему краю его дисплея
или родительского фрейма.  Также не позволяют указать позицию, которая не
находится в пределах краев дисплея или родительского фрейма.  Параметры
фрейма @code{left} и @code{top} (@pxref{Position Parameters}) позволяют это
сделать, но все же могут не дать хороших результатов для исходного или
нового фрейма.

Функция не влияет на фреймы текстового терминала.
@end defun

@defvar move-frame-functions
@cindex frame position changes, a hook
Этот перехватчик определяет функции, которые запускаются, когда фрейм Emacs
перемещается (ему назначается новая позиция) оконной системой или оконным
менеджером.  Функции запускаются с одним аргументом - перемещенным фреймом.
Для дочернего фрейма (@pxref{Child Frames}) функции запускаются только
тогда, когда положение фрейма изменяется по отношению к положению его
родительского фрейма.
@end defvar


@node Frame Size
@subsection Размер Фрейма
@cindex frame size
@cindex text width of a frame
@cindex text height of a frame
@cindex text size of a frame
Канонический способ указать @dfn{размер фрейма} из Emacs - это указать его
@dfn{размер текста} --- кортеж ширины и высоты текстовой области
(@pxref{Frame Layout}) фрейма.  Его можно измерить либо в пикселях, либо в
единицах канонического размера символа фрейма (@pxref{Frame Font}).

  Для фреймов с внутренним меню или панелью инструментов нельзя точно
определить собственную высоту фрейма до того, как фрейм будет фактически
нарисован.  Это означает, что, как правило, не получиться использовать
собственный размер для указания начального размера фрейми.  Как только
узнать собственный размер видимого фрейма, можно вычислить его внешний
размер (@pxref{Frame Layout}), добавив оставшиеся компоненты из
возвращаемого значения @code{frame-geometry}.  Однако для невидимых фреймов
или фреймов, которые еще предстоит создать, внешний размер можно только
оценить.  Это также означает, что вычисление точного начального положения
фрейма, указанного с помощью смещений от правого или нижнего края экрана
(@pxref{Frame Position}), невозможно.

  Размер текста любого фрейма можно установить и получить с помощью
параметров фрейма @code{height} и @code{width} (@pxref{Size Parameters}).
Размер текста исходного фрейма также можно установить с помощью спецификации
геометрии X-стиля.  @xref{Emacs Invocation,, Command Line Arguments for Emacs Invocation, emacs, The GNU Emacs Manual}.  Ниже перечислены некоторые
функции для доступа и устанавки размера существующего видимого фрейма, по
умолчанию выбранной.

@defun frame-height &optional frame
@defunx frame-width &optional frame
Функции возвращают высоту и ширину текстовой области @var{frame}, измеренные
в единицах высоты шрифта по умолчанию и ширины @var{frame}
(@pxref{Frame Font}).  Эти функции представляют собой простые сокращения для
записи @code{(frame-parameter frame 'height)} и
@code{(frame-parameter frame 'width)}.

Если текстовая область @var{frame}, измеренная в пикселях, не кратна размеру
шрифта по умолчанию, значения, возвращаемые этими функциями, округляются в
меньшую сторону до количества символов шрифта по умолчанию, которые
полностью помещаются в текстовую область.
@end defun

Следующие далее функции возвращают ширину и высоту в пикселях собственного,
внешнего и внутреннего фрейма и текстовой области (@pxref{Frame Layout})
данного фрейма.  Для текстового терминала результаты выражаются в символах,
а не в пикселях.

@defun frame-outer-width &optional frame
@defunx frame-outer-height &optional frame
Функции возвращают внешнюю ширину и высоту @var{frame} в пикселях.
@end defun

@defun frame-native-height &optional frame
@defunx frame-native-width &optional frame
Функции возвращают исходную ширину и высоту @var{frame} в пикселях.
@end defun

@defun frame-inner-width &optional frame
@defunx frame-inner-height &optional frame
Функции возвращают внутреннюю ширину и высоту @var{frame} в пикселях.
@end defun

@defun frame-text-width &optional frame
@defunx frame-text-height &optional frame
Функции возвращают ширину и высоту текстовой области @var{frame} в пикселях.
@end defun

В оконных системах, которые его поддерживают, Emacs по умолчанию пытается
сделать размер текста фрейма, измеренный в пикселях, кратным размеру символа
фрейма.  Это, однако, обычно означает, что размер фрейма можно изменять
только с приращением размера символа при перетаскивании его внешних границ.
Это также может нарушить попытки по-настоящему развернуть фрейм или сделать
его ``полной высотой'' или ``полной шириной'' (@pxref{Size Parameters}),
оставив некоторое пустое пространство ниже и/или справа от фрейма.  В этом
случае может помочь следующий вариант.

@defopt frame-resize-pixelwise
Если этот параметр - @code{nil} (по умолчанию), размер пикселя текста фрейма
обычно округляется до кратного числа текущих значений
@code{frame-char-height} и @code{frame-char-width} этого фрейма при
изменении размера фрейма.  Если не-@code{nil}, округления не происходит,
следовательно, размеры фрейма могут увеличиваться/уменьшаться на один
пиксель.

Установка этой переменной обычно приводит к тому, что следующая операция
изменения размера передает соответствующие подсказки размера диспетчеру
окон.  Это означает, что эта переменная должна быть установлена только в
исходном файле пользователя; приложения никогда не должны привязывать его
временно.

Точное значение @code{nil} для этой опции зависит от используемого
инструментария.  Перетаскивание внешней границы с помощью мыши выполняется
посимвольно, если оконный менеджер готов обрабатывать подсказки
соответствующего размера.  Однако вызов @code{set-frame-size} (смотреть
ниже) с аргументами, которые не определяют размер фрейма как целое число,
кратное его размеру символа, может: игнорироваться, вызывать округление
(GTK+) или быть принятым (Lucid, Motif, MS-Windows).

В некоторых оконных менеджерах может потребоваться установить для опции
значение не-@code{nil}, чтобы фрейм выглядел действительно развернутым или
полноэкранным.
@end defopt

@defun set-frame-size frame width height &optional pixelwise
Функция устанавливает размер текстовой области @var{frame}, измеренный в
терминах канонической высоты и ширины символа на @var{frame}
(@pxref{Frame Font}).

Необязательный аргумент @var{pixelwise} не-@code{nil} означает, что вместо
этого нужно измерять новую ширину и высоту в пикселях.  Обратить внимание,
что если @code{frame-resize-pixelwise} равен @code{nil}, некоторые наборы
инструментов могут отказываться действительно выполнять запрос, если не
увеличивается/не уменьшается размер фрейма до кратного размера его символа.
@end defun

@defun set-frame-height frame height &optional pretend pixelwise
Функция изменяет размер текстовой области @var{frame} до высоты @var{height}
строк.  Размеры существующих окон в @var{frame} изменяются пропорционально
подгонке.

Если @var{pretend} равен не-@code{nil}, то Emacs отображает строки вывода
@var{height} в @var{frame}, но не изменяет свое значение для фактической
высоты фрейма.  Это полезно только на текстовых терминалах.  Использование
меньшей высоты, чем на самом деле реализует терминал, может быть полезно для
воспроизведения поведения, наблюдаемого на меньшем экране, или в случае
неисправности терминала при использовании всего экрана.  Непосредственная
установка высоты фрейма не всегда работает, потому что знание правильного
фактического размера может быть необходимо для правильного позиционирования
курсора на текстовых терминалах.

Необязательный четвертый аргумент @var{pixelwise} не-@code{nil} означает,
что @var{frame} должен иметь высоту @var{height} пикселей.  Обратить
внимание, что если @code{frame-resize-pixelwise} равно @code{nil}, некоторые
оконные менеджеры могут отказываться действительно выполнять запрос, если
не увеличивается/не уменьшается высота фрейма до кратной высоты его символа.
@end defun

@defun set-frame-width frame width &optional pretend pixelwise
Функция устанавливает ширину текстовой области @var{frame}, измеряемую в
символах.  Аргумент @var{pretend} имеет то же значение, что и аргумент
@code{set-frame-height}.

Необязательный четвертый аргумент @var{pixelwise} не-@code{nil} означает,
что @var{frame} должен иметь ширину @var{width} пикселей.  Обратить
внимание, что если @code{frame-resize-pixelwise} равно @code{nil}, некоторые
оконные менеджеры могут отказываться полностью удовлетворить запрос, если
не увеличивается/не уменьшается ширина фрейма до кратной ширины его символа.
@end defun

Ни одна из этих трех функций не сделает фрейм меньше, чем необходимо для
отображения всех его окон вместе с их полосами прокрутки, полосами, полями,
разделителями, режимом и строками заголовка.  Это контрастирует с запросами
оконного менеджера, запускаемыми, например, путем перетаскивания внешней
границы фрейма с помощью мыши.  Такие запросы всегда выполняются путем
отсечения, если необходимо, частей, которые не могут быть отображены в
правом нижнем углу фрейма.  Параметры @code{min-width} и @code{min-height}
(@pxref{Size Parameters}) можно использовать для получения аналогичного
поведения при изменении размера фрейма из Emacs.

@cindex tracking frame size changes
  Не нормальная ловушка @code{window-size-change-functions}
(@pxref{Window Hooks}) отслеживает все изменения внутреннего размера фрейма,
в том числе вызванные запросом оконной системы или оконного менеджера.
Чтобы исключить ложные срабатывания, которые могут возникнуть при изменении
только размеров окон фрейма без фактического изменения размера внутреннего
фрейма, используется следующая функция.

@defun frame-size-changed-p &optional frame
Функция возвращает не-@code{nil}, когда внутренняя ширина или высота
@var{frame} изменилась с момента последнего запуска
@code{window-size-change-functions} для @var{frame}.  Всегда возвращается
@code{nil} сразу после запуска @code{window-size-change-functions} для
@var{frame}.
@end defun


@node Implied Frame Resizing
@subsection Подразумеваемое Изменение Размера Фрейма
@cindex implied frame resizing
@cindex implied resizing of frame

По умолчанию Emacs пытается сохранить неизменным количество строк и столбцов
в текстовой области фрейма, например, при добавлении или удалении строки
меню, изменении шрифта по умолчанию или установке ширины полос прокрутки
фрейма.  Однако это означает, что в таком случае Emacs должен попросить
диспетчер окон изменить размер внешнего фрейма, чтобы приспособиться к
изменению размера.  Обратить внимание, что обертывание меню или панели
инструментов обычно не изменяет внешний размер фрейма, следовательно, это
изменит количество отображаемых строк.

  Иногда такое @dfn{подразумеваемое изменение размера фрейма} может быть
нежелательным, например, когда фрейм развернут или сделан в полноэкранном
режиме (где он отключен по умолчанию).  В других случаях можно отключить
подразумеваемое изменение размера с помощью следующей опции:

@defopt frame-inhibit-implied-resize
Если этот параметр - @code{nil}, изменение шрифта, строки меню, панели
инструментов, внутренних границ, полос или полос прокрутки определенного
фрейма может неявно изменить размер области отображения фрейма, чтобы
сохранить количество столбцов или строк, отображаемых фреймом.  Если этот
параметр - не-@code{nil}, подразумеваемое изменение размера не выполняется.

Значением этой опции также может быть список параметров фрейма.  В этом
случае подразумеваемое изменение размера запрещается при изменении
параметра, который появляется в этом списке.  Параметры фрейма, которые в
настоящее время обрабатываются этой опцией:: @code{font},
@code{font-backend}, @code{internal-border-width}, @code{menu-bar-lines} и
@code{tool-bar-lines}.

Изменение любого из параметров фрейма @code{scroll-bar-width},
@code{scroll-bar-height}, @code{vertical-scroll-bars},
@code{horizontal-scroll-bars}, @code{left-fringe} и @code{right-fringe}
обрабатывается так, как если бы фрейм содержал только одно активное окно.
Это означает, например, что удаление вертикальных полос прокрутки на фрейме,
содержащем несколько боковых окон, уменьшит внешнюю ширину фрейма на ширину
одной полосы прокрутки при условии, что этот параметр - @code{nil}, и
оставит его неизменным, если этот параметр - @code{t} или список, содержащий
@code{vertical-scroll-bars}.

Значение по умолчанию - @code{'(tool-bar-lines)} для Lucid, Motif и
MS-Windows (что означает, что добавление/удаление панели инструментов не
изменяет высоту внешнего фрейма), @code{nil} для всех других оконных систем,
включая GTK+ (что означает, что изменение любого из параметров перечисленных
выше могут изменить размер внешнего фрейма), и @code{t} в противном случае
(что означает, что размер внешнего фрейма никогда не изменяется неявно, если
нет поддержки оконной системы).

Заметьте, что когда размер кадра недостаточно велик, чтобы приспособиться к
изменению любого из параметров, перечисленных выше, Emacs может попытаться
увеличить фрейм, даже если эта опция установлена в не-@code{nil}.
@end defopt


@node Frame Parameters
@section Параметры Фрейма
@cindex frame parameters

  У фрейма есть множество параметров, которые управляют его внешним видом и
поведением.  Какие параметры имеет фрейм, зависит от того, какой механизм
отображения он использует.

  Параметры фрейма существуют в основном для графического отображения.
Большинство параметров фрейма не действуют при применении к фрейму в
текстовом терминале; только параметры @code{height}, @code{width},
@code{name}, @code{title}, @code{menu-bar-lines}, @code{buffer-list} и
@code{buffer-predicate} делают что-то особенное.  Если терминал поддерживает
цвета, параметры @code{foreground-color}, @code{background-color},
@code{background-mode} и @code{display-type} также имеют значение.  Если
терминал поддерживает прозрачность фрейма, значение параметра @code{alpha}
также имеет значение.

  По умолчанию параметры фрейма сохраняются и восстанавливаются функциями
библиотеки рабочего стола (@pxref{Desktop Save Mode}), когда переменная
@code{desktop-restore-frames} имеет значение не-@code{nil}.  Приложения
несут ответственность за то, чтобы их параметры были включены в
@code{frameset-persistent-filter-alist}, чтобы избежать получения
бессмысленных или даже вредных значений в восстановленных сеансах.

@menu
* Parameter Access::       Как изменить параметры фрейма.
* Initial Parameters::     Указание параметров фрейма при создании.
* Window Frame Parameters:: Список параметров фреймов для оконных систем.
* Geometry::               Разбор геометрических характеристик.
@end menu

@node Parameter Access
@subsection Доступ к Параметрам Фрейма

Эти функции позволяют читать и изменять значения параметров кадра.

@defun frame-parameter frame parameter
Функция возвращает значение параметра @var{parameter} (символ) для
@var{frame}.  Если @var{frame} равен @code{nil}, возвращается параметр
выбранного фрейма.  Если @var{frame} не имеет настройки для @var{parameter},
функция возвращает @code{nil}.
@end defun

@defun frame-parameters &optional frame
Функция @code{frame-parameters} возвращает список, в котором перечислены все
параметры @var{frame} и их значения.  Если @var{frame} равен @code{nil} или
опущен, это возвращает параметры выбранного фрейма.
@end defun

@defun modify-frame-parameters frame alist
Функция изменяет фрейм @var{frame} на основе элементов @var{alist}.  Каждый
элемент @var{alist} имеет вид @code{(@var{parm} . @var{value})}, где
@var{parm} - это символ, обозначающий параметр.  Если вы не указан параметр
в @var{alist}, его значение не изменится.  Если @var{frame} равен
@code{nil}, по умолчанию используется выбранный фрейм.

Некоторые параметры имеют значение только для фреймов на определенных типах
дисплеев (@pxref{Frames}).  Если @var{alist} включает параметры, которые не
имеют смысла для отображения @var{frame}, эта функция изменит свое значение
в списке параметров фрейма, но в противном случае проигнорирует его.

Когда @var{alist} указывает более одного параметра, значение которого может
повлиять на новый размер @var{frame}, окончательный размер фрейма может
отличаться в зависимости от используемого инструментария.  Например,
указание, что отныне фрейм должен иметь меню и/или панель инструментов, а не
ничего, и одновременное указание новой высоты фрейма неизбежно приведет к
перерасчету высоты фрейма.  По идее, в таком случае эта функция будет
пытаться сделать так, чтобы явная спецификация высоты преобладала.  Однако
нельзя исключить, что добавление (или удаление) меню или панели
инструментов, когда в конечном итоге выполняется набором инструментов,
разрушит это намерение.

Иногда привязка @code{frame-inhibit-implied-resize}
(@pxref{Implied Frame Resizing}) к значению не-@code{nil} вокруг вызовов
этой функции может решить описанную здесь проблему.  Иногда, однако,
проблема может возникнуть именно в такой привязке.
@end defun

@defun set-frame-parameter frame parm value
Функция устанавливает параметр фрейма @var{parm} равным указанному
@var{value}.  Если @var{frame} равен @code{nil}, по умолчанию используется
выбранный фрейм.
@end defun

@defun modify-all-frames-parameters alist
Функция изменяет параметры фреймов всех существующих фреймов в соответствии
с @var{alist}, затем изменяет @code{default-frame-alist} (и, если
необходимо, @code{initial-frame-alist}), чтобы применить те же значени
я параметров к фреймам, которые будут создаваться впредь.
@end defun

@node Initial Parameters
@subsection Параметры Начального Фрейма
@cindex parameters of initial frame

Можно указать параметры для начального стартового фрейма, установив
@code{initial-frame-alist} в файле инициализации (@pxref{Init File}).

@defopt initial-frame-alist
Значение этой переменной представляет собой список значений параметров,
используемых при создании начального фрейма.  Можно установить эту
переменную, чтобы указать внешний вид начального фрейма без изменения
последующих фреймов.  Каждый элемент имеет форму:

@example
(@var{parameter} . @var{value})
@end example

Emacs создает начальный фрейм перед чтением файла инициализации.
После чтения этого файла Emacs проверяет @code{initial-frame-alist} и
применяет настройки параметров в измененном значении к уже созданному
начальному фрейму.

Если эти настройки влияют на геометрию и внешний вид фрейми, фрейм
отобразится с неправильными параметрами, а затем изменится на указанные.
Если это беспокоит, можно указать ту же геометрию и внешний вид с ресурсами
X; они вступают в силу до создания фрейма.
@xref{X Resources,, X Resources, emacs, The GNU Emacs Manual}.

Параметры ресурсов X обычно применяются ко всем фреймам.  Если нужно указать
некоторые ресурсы X исключительно ради начального фрейма и не требуется
чтобы они применялись к последующим фреймам, вот как этого добиться.
Задаются параметры в @code{default-frame-alist}, чтобы переопределить
ресурсы X для последующих фреймов; затем, чтобы они не влияли на начальный
фрейм, указываются те же параметры в @code{initial-frame-alist} со
значениями, соответствующими X-ресурсам.
@end defopt

@cindex minibuffer-only frame
Если эти параметры включают @code{(minibuffer . nil)}, это означает, что в
начальном фрейме не должно быть минибуфера.  В этом случае Emacs также
создает отдельный @dfn{minibuffer-only frame}.

@defopt minibuffer-frame-alist
Значение этой переменной представляет собой список значений параметров,
используемых при создании начального фрейма только для минибуфера (то есть
фрейма только для минибуфера, который Emacs создает, если
@code{initial-frame-alist} определяет фрейм без минибуфера).
@end defopt

@defopt default-frame-alist
Это список, определяющий значения параметров фрейма по умолчанию для всех
фреймов Emacs - первого фрейма и последующих фреймов.  При использовании
системы X Window можно получить те же результаты с помощью ресурсов X во
многих случаях.

Установка этой переменной не влияет на существующие фреймы.  Кроме того,
функции, отображающие буфер в отдельном фрейме, могут переопределить
параметры по умолчанию, предоставив свои собственные параметры.
@end defopt

Если вызывается Emacs с параметрами командной строки, которые определяют
внешний вид фрейма, эти параметры вступают в силу путем добавления элементов
в @code{initial-frame-alist} или @code{default-frame-alist}.  Параметры,
которые влияют только на начальный фрейм, такие как @samp{--geometry} и
@samp{--maximized}, добавляются к @code{initial-frame-alist}; остальные
добавится в @code{default-frame-alist}.
@pxref{Emacs Invocation,, Command Line Arguments for Emacs Invocation, emacs, The GNU Emacs Manual}.

@node Window Frame Parameters
@subsection Параметры Фрейма Окна
@cindex frame parameters for windowed displays

  Какие параметры имеет фрейм, зависит от того, какой механизм отображения
он использует.  В этом разделе описаны параметры, которые имеют особое
значение для некоторых или всех типов терминалов.  Из них @code{name},
@code{title}, @code{height}, @code{width}, @code{buffer-list} и
@code{buffer-predicate} предоставляет значимую информацию в терминальных
фреймах, а @code{tty-color-mode} имеет смысл только для фреймов на текстовых
терминалах.

@menu
* Basic Parameters::           Параметры, которые являются фундаментальными.
* Position Parameters::         Положение фрейма на экране.
* Size Parameters::             Размер фрейма.
* Layout Parameters::           Размер частей фрейма, а также включение или
                                   отключение некоторых частей.
* Buffer Parameters::           Какие буферы были или должны быть показаны.
* Frame Interaction Parameters::Параметры взаимодействия с другими фреймами.
* Mouse Dragging Parameters::   Параметры для изменения размера и
                                   перемещения фреймов мышью.
* Management Parameters::       Общение с оконным менеджером.
* Cursor Parameters::           Управление внешним видом курсора.
* Font and Color Parameters::   Шрифты и цвета для текста фрейма.
@end menu

@node Basic Parameters
@subsubsection Основные Параметры

  Эти параметры фрейма дают основную информацию о фрейме.  @code{title} и
@code{name} значимы на всех терминалах.

@table @code
@vindex display@r{, пареметр фрейма}
@item display
Дисплей, на котором открывается этот фрейм.  Это должна быть строка вида
@samp{@var{host}:@var{dpy}.@var{screen}}, как и переменная окружения
@env{DISPLAY}.  @xref{Multiple Terminals}, чтобы узнать больше об
отображаемых именах.

@vindex display-type@r{, пареметр фрейма}
@item display-type
Параметр описывает диапазон возможных цветов, которые можно использовать в
этом фрейме.  Его значение @code{color}, @code{grayscale} или @code{mono}.

@vindex title@r{, пареметр фрейма}
@item title
Если у фрейма есть заголовок не-@code{nil}, он появляется в строке заголовка
оконной системы в верхней части фрейма, а также в строке режима окон в этом
фрейме, если @code{mode-line-frame-identification} использует @samp{%F}
(@pxref{%-Constructs}).  Обычно это происходит, когда Emacs не использует
оконную систему и может отображать только один фрейм за раз.
@xref{Frame Titles}.

@vindex name@r{, параметр кадра}
@item name
Название фрейма.  Имя фрейма используется по умолчанию для заголовка фрейма,
если параметр @code{title} не указан или @code{nil}.  Если не указано имя,
Emacs автоматически установит имя фрейма (@pxref{Frame Titles}).

Если явно указано имя фрейма при создании фрейма, это имя также используется
(вместо имени исполняемого файла Emacs) при поиске ресурсов X для фрейма.

@vindex explicit-name@r{, пареметр фрейма}
@item explicit-name
Если имя фрейма было указано явно при создании фрейма, этот параметр будет
этим именем.  Если фрейм не был назван явно, этот параметр будет @code{nil}.
@end table


@node Position Parameters
@subsubsection Параметры Положения
@cindex window position on display
@cindex frame position

Параметры, описывающие X- и Y-смещения фрейма, всегда измеряются в пикселях.
Для нормального, не дочернего фрейма они определяют внешнюю позицию
(@pxref{Frame Geometry}) фрейма относительно его исходной точки отображения.
Для дочернего фрейма (@pxref{Child Frames}) они определяют внешнее положение
фрейма относительно исходного положения родительского фрейма.  (Обратить
внимание, что ни один из этих параметров не имеет значения для фреймов TTY.)

@table @code
@vindex left@r{, параметр фрейма}
@item left
Положение в пикселях левого внешнего края фрейма по отношению к левому краю
отображения фрейма или родительского фрейма.  Можно указать одним из
следующих способов.

@table @asis
@item an integer
Положительное целое число всегда связывает левый край фрейма с левым краем
его дисплея или родительского фрейма.  Отрицательное целое число связывает
правый край фрейма с правым краем дисплея или родительского фрейма.

@item @code{(+ @var{pos})}
Это определяет положение левого края фрейма относительно левого края его
дисплея или родительского фрейма.  Целое число @var{pos} может быть
положительным или отрицательным; отрицательное значение указывает положение
за пределами экрана или родительского фрейма или на мониторе, отличном от
основного (для дисплеев с несколькими мониторами).

@item @code{(- @var{pos})}
Это определяет положение правого края фрейма относительно правого края
дисплея или родительского фрейма.  Целое число @var{pos} может быть
положительным или отрицательным; отрицательное значение указывает положение
за пределами экрана или родительского фрейма или на мониторе, отличном от
основного (для дисплеев с несколькими мониторами).

@cindex left position ratio
@cindex top position ratio
@item a floating-point value
Значение с плавающей запятой в диапазоне от 0.0 до 1.0 указывает смещение
левого края через @dfn{соотношение левой позиции} фрейма --- отношение
левого края его внешнего фрейма к ширине рабочей области
(@pxref{Multiple Terminals}) фрейма или его родительского фрейма
(@pxref{Child Frames}) минус ширина внешнего фрейма.  Таким образом,
соотношение левой позиции 0.0 сбрасывает фрейм влево, коэффициент 0.5
центрирует его, а коэффициент 1.0 сбрасывает его справа от дисплея или
родительского фрейма.  Точно так же @dfn{коэффициент верхней позиции} фрейма
- это отношение верхнего положения фрейма к высоте его рабочей области или
родительского фрейма за вычетом высоты фрейма.

Emacs будет пытаться сохранить соотношения позиций дочернего фрейма
неизменными, если этот фрейм имеет параметр не-@code{nil} @code{keep-ratio}
(@pxref{Frame Interaction Parameters}), а его родительский фрейм изменяет
размер.

Поскольку внешний размер фрейма (@pxref{Frame Geometry}) обычно недоступен
до того, как фрейм станет видимым, обычно не рекомендуется использовать
значения с плавающей запятой при создании декорированных фреймов.  Значения
с плавающей запятой больше подходят для обеспечения того, чтобы
(недекорированный) дочерний фрейм правильно располагался в области своего
родительского фрейма.
@end table

Некоторые оконные менеджеры игнорируют позиции, указанные в программе.  Если
требуется уверенность, что указанная позиция не игнорируется, указывается
значение не-@code{nil} для параметра @code{user-position}, как в следующем
примере:

@example
(modify-frame-parameters
  nil '((user-position . t) (left . (+ -4))))
@end example

Как правило, не рекомендуется размещать фрейм относительно правого или
нижнего края экрана.  Расположение исходного или нового фрейма либо неточно
(потому что размер внешнего фрейма еще не полностью известен до того, как
фрейм станет видимым), либо вызовется дополнительное мерцание (если фрейм
необходимо переместить после того, как он стал видимым).

  Также обратить внимание, что позиции, указанные относительно
правого/нижнего края дисплея, рабочей области или родительского фрейма, а
также смещения с плавающей точкой сохраняются внутри как целочисленные
смещения относительно левого/верхнего края дисплея, рабочей области или края
родительского фрейма.  Они также возвращаются такими функциями, как
@code{frame-parameters}, и восстанавливаются как таковые процедурами
сохранения рабочего стола.

@vindex top@r{, параметр фрейма}
@item top
Положение верхнего (или нижнего) края экрана в пикселях относительно
верхнего (или нижнего) края дисплея или родительского фрейма.  Работает так
же, как @code{left}, за исключением вертикально, а не горизонтально.

@vindex icon-left@r{, параметр фрейма}
@item icon-left
Положение на экране левого края значка фрейма в пикселях, считая от левого
края экрана.  Это вступает в силу, когда фрейм отображается в виде значка,
если оконный менеджер поддерживает эту функцию.  Если указано значение для
этого параметра, также потребуется указать значение для @code{icon-top} и
наоборот.

@vindex icon-top@r{, параметр фрейма}
@item icon-top
Положение на экране верхнего края значка фрейма в пикселях, считая от
верхнего края экрана.  Это вступает в силу, когда фрейм отображается в виде
значка, если оконный менеджер поддерживает эту функцию.

@vindex user-position@r{, параметр фрейма}
@item user-position
Когда создаётся фрейм и указывается его положение на экране с помощью
параметров @code{left} и @code{top}, использовать этот параметр, чтобы
указать, была ли указанная позиция указана пользователем (явно запрошена
каким-то образом пользователем-человеком) или просто указана программой
(выбрана программой).  Значение не-@code{nil} говорит о том, что позиция
была указана пользователем.

@cindex window positions and window managers
Оконные менеджеры обычно принимают во внимание позиции, указанные
пользователем, а некоторые также учитывают позиции, определенные программой.
Но многие игнорируют определенные программой позиции, размещая окно по
умолчанию или позволяя пользователю размещать его с помощью мыши.  Некоторые
оконные менеджеры, в том числе @code{twm}, позволяют пользователю указывать,
следует ли подчиняться программным позициям или игнорировать их.

Когда вызывается @code{make-frame}, потребуется указать значение
не-@code{nil} для этого параметра, если значения параметров @code{left} и
@code{top} представляют заявленные пользователем предпочтения; в противном
случае используется @code{nil}.

@vindex z-group@r{, параметр фрейма}
@item z-group
Параметр определяет относительное положение окна оконной системы фрейма в
порядке наложения (Z-) отображения фрейма.

Если установлен в @code{above}, окно оконной системы фрейма отображается
над всеми другими окнами оконной системы, для которых не установлено
свойство @code{above}.  Если установлен в @code{nil}, окно фрейма
отображается под всеми окнами, для которых установлено свойство
@code{above}, и над всеми окнами, для которых установлено свойство
@code{below}.  Если установлено в @code{below}, окно фрейма отображается под
всеми окнами, для которых не установлено свойство @code{below}.

Чтобы разместить фрейм выше или ниже определенного другого фрейма,
использовать функцию @code{frame-restack} (@pxref{Raising and Lowering}).
@end table


@node Size Parameters
@subsubsection Параметры Размера
@cindex window size on display

Параметры фрейма обычно указывают размеры фрейма в единицах символов.  На
графических дисплеях грань @code{default} определяет фактические размеры в
пикселях этих символьных единиц (@pxref{Face Attributes}).

@table @code
@vindex width@r{, параметр фрейма}
@item width
Этот параметр определяет ширину фрейма.  Его можно указать следующим
образом:

@table @asis
@item an integer
Положительное целое число определяет ширину текстовой области
(@pxref{Frame Geometry}) фрейма в символах.

@item a cons cell
Если это cons-ячейка с символом @code{text-pixels} в ее @sc{car}, @sc{cdr}
этой ячейки определяет ширину текстовой области фрейма в пикселях.

@cindex frame width ratio
@cindex frame height ratio
@item a floating-point value
Число с плавающей точкой от 0.0 до 1.0 может использоваться для указания
ширины фрейма через его @dfn{соотношение ширины} --- отношение его внешней
ширины (@pxref{Frame Geometry}) к ширине рабочей области
(@pxref{Multiple Terminals}) фрейма или собственного фрейма
(@pxref{Child Frames}) его родительского фрейма.  Таким образом, значение
0.5 заставляет фрейм занимать половину ширины своей рабочей области или
родительского фрейма, а значение 1.0 - полную ширину.  Точно так же
@dfn{соотношение высоты} фрейма - это отношение его внешней высоты к высоте
его рабочей области или собственного фрейма его родителя.

Emacs будет пытаться сохранить неизменным соотношение ширины и высоты
дочернего фрейма, если этот фрейм имеет параметр не-@code{nil}
@code{keep-ratio} (@pxref{Frame Interaction Parameters}) и его родительский
фрейм изменяется.

Поскольку внешний размер фрейма обычно недоступен до того, как фрейм станет
видимым, обычно не рекомендуется использовать значения с плавающей запятой
при создании декорированных фреймов.  Значения с плавающей запятой больше
подходят для гарантии того, что дочерний фрейм всегда помещается в область
своего родительского фрейма, как, например, при настройке
@code{display-buffer-alist} (@pxref{Choosing Window}) через
@code{display-buffer-in-child-frame}.
@end table

Независимо от того, как был указан этот параметр, функции, сообщающие
значение этого параметра, такие как @code{frame-parameters}, всегда сообщают
ширину текстовой области фрейма в символах как целое число, округленное,
если необходимо, до кратного ширине символа фрейма по умолчанию.  Это
значение также используется процедурами сохранения рабочего стола.

@vindex height@r{, параметр фрейма}
@item height
Этот параметр определяет высоту фрейма.  Работает так же, как @code{width},
только вертикально, а не горизонтально.

@vindex user-size@r{, параметр фрейма}
@item user-size
Производит для параметров размера @code{height} и @code{width} то же, что
параметр @code{user-position} (@pxref{Position Parameters, user-position})
делает для параметров положения @code{top} и @code{left}.

@vindex min-width@r{, параметр фрейма}
@item min-width
Параметр указывает минимальную ширину (@pxref{Frame Geometry}) фрейма в
символах.  Обычно функции, устанавливающие начальную ширину фрейма или
изменяющие размер фрейма по горизонтали, обеспечивают отображение всех окон
фрейма, вертикальных полос прокрутки, полос, полей и вертикальных
разделителей.  Этот параметр, если не-@code{nil} позволяет сделать фрейм
более узким, чем было бы, в результате чего любые компоненты, которые не
подходят, будут обрезаны оконным менеджером.

@vindex min-height@r{, параметр фрейма}
@item min-height
Параметр указывает минимальную исходную высоту (@pxref{Frame Geometry})
фрейма в символах.  Обычно функции, устанавливающие начальный размер фрейма
или изменяющие размер фрейма, обеспечивают отображение всех окон фрейма,
горизонтальных полос прокрутки и разделителей, строк режима и заголовков,
эхо-области, внутреннего меню и панели инструментов.  Этот параметр, если
не-@code{nil} позволяет уменьшить размер фрейма, в результате чего любые
компоненты, которые не помещаются, будут обрезаны оконным менеджером.

@cindex fullboth frames
@cindex fullheight frames
@cindex fullwidth frames
@cindex maximized frames
@vindex fullscreen@r{, параметр фрейма}
@item fullscreen
Параметр указывает, следует ли максимизировать ширину фрейма, высоту или и
то, и другое.  Его значение может быть @code{fullwidth}, @code{fullheight},
@code{fullboth} или @code{maximized}.  @dfn{fullwidth} фрейма означает
максимальную ширину, @dfn{fullheight} фрейма - максимальную высоту, а
@dfn{fullboth} - максимальную ширину и максимальную высоту.  @dfn{maximized}
фрейма похож на ``fullboth'' фрейма, за исключением того, что обычно
сохраняет строку заголовка и кнопки для изменения размера и закрытия фрейма.
Кроме того, развернутые фреймы обычно не скрывают панель задач или панели,
отображаемые на рабочем столе.  С другой стороны, ``fullboth'' фрейма обычно
пропускает строку заголовка и занимает все доступное пространство экрана.

В этом отношении полноразмерные и полноширинные фреймы больше похожи на
развернутые фреймы.  Однако они обычно отображают внешнюю границу, которая
может отсутствовать в развернутых фреймах.  Следовательно, высота
развернутых и полноразмерных фреймов и ширина развернутых и полноразмерных
фреймов часто отличаются на несколько пикселей.

В некоторых оконных менеджерах может потребоваться настроить переменную
@code{frame-resize-pixelwise} (@pxref{Frame Size}), чтобы фрейм
действительно выглядел развернутым или полноэкранным.  Более того, некоторые
оконные менеджеры могут не поддерживать плавный переход между различными
состояниями полноэкранного режима или максимизации.  Изменение переменной
@code{x-frame-normalize-before-maximize} может помочь решить эту проблему.

В полноэкранном режиме в macOS скрываются как панель инструментов, так и
строка меню, однако обе будут отображаться, если указатель мыши переместится
в верхнюю часть экрана.

@vindex fullscreen-restore@r{, a frame parameter}
@item fullscreen-restore
Параметр указывает желаемое полноэкранное состояние фрейма после вызова
команды @code{toggle-frame-fullscreen}
(@pxref{Frame Commands,,, emacs, The GNU Emacs Manual}) в состоянии
``fullboth''.  Обычно этот параметр устанавливается автоматически этой
командой при переключении состояния на полное.  Если, однако, запускается
Emacs в состоянии ``fullboth'', потребуется указать желаемое поведение в
исходном файле, например, как

@example
(setq default-frame-alist
    '((fullscreen . fullboth)
      (fullscreen-restore . fullheight)))
@end example

Это даст новый фрейм во всю высоту после первого ввода в него @key{F11}.

@vindex fit-frame-to-buffer-margins@r{, параметр фрейма}
@item fit-frame-to-buffer-margins
Параметр позволяет переопределить значение опции
@code{fit-frame-to-buffer-margins} при подгонке этого фрейма к буферу его
корневого окна с помощью @code{fit-frame-to-buffer}
(@pxref{Resizing Windows}).

@vindex fit-frame-to-buffer-sizes@r{, параметр фрейма}
@item fit-frame-to-buffer-sizes
Параметр позволяет переопределить значение опции
@code{fit-frame-to-buffer-sizes} при подгонке этого фрейма к буферу его
корневого окна с помощью @code{fit-frame-to-buffer}
(@pxref{Resizing Windows}).
@end table


@node Layout Parameters
@subsubsection Параметры Макета
@cindex layout parameters of frames
@cindex frame layout parameters

  Эти параметры фрейма включают или отключают различные части фрейма или
управляют их размерами.

@table @code
@vindex border-width@r{, a параметр фрейма}
@item border-width
Ширина в пикселях внешней границы кадра (@pxref{Frame Geometry}).

@vindex internal-border-width@r{, параметр фрейма}
@item internal-border-width
Ширина в пикселях внутренней границы кадра (@pxref{Frame Geometry}).

@vindex vertical-scroll-bars@r{, a frame parameter}
@item vertical-scroll-bars
Есть ли в фрейме полосы прокрутки (@pxref{Scroll Bars}) для вертикальной
прокрутки и с какой стороны фрейма они должны быть.  Возможные значения:
@code{left}, @code{right} и @code{nil} без полос прокрутки.

@vindex horizontal-scroll-bars@r{, параметр фрейма}
@item horizontal-scroll-bars
Есть ли в фрейме полосы прокрутки для горизонтальной прокрутки (@code{t} и
@code{bottom} означают да, @code{nil} означает нет).

@vindex scroll-bar-width@r{, параметр фрейма}
@item scroll-bar-width
Ширина вертикальных полос прокрутки в пикселях или @code{nil} означает
использование ширины по умолчанию.

@vindex scroll-bar-height@r{, параметр фрейма}
@item scroll-bar-height
Высота горизонтальных полос прокрутки в пикселях или @code{nil}, что
означает использование высоты по умолчанию.

@vindex left-fringe@r{, параметр фрейма}
@vindex right-fringe@r{, параметр фрейма}
@item left-fringe
@itemx right-fringe
Ширина по умолчанию левой и правой кромок окон в этом фрейме
(@pxref{Fringes}).  Если любой из них равен нулю, это эффективно удаляет
соответствующую полосу.

Когда используется @code{frame-parameter} для запроса значения любого из
этих двух параметров фрейма, возвращаемое значение всегда является целым
числом.  При использовании @code{set-frame-parameter} передача значения
@code{nil} накладывает фактическое значение по умолчанию 8 пикселей.

@vindex right-divider-width@r{, параметр фрейма}
@item right-divider-width
Ширина (толщина), зарезервированная для правого разделителя
(@pxref{Window Dividers}) любого окна в фрейме, в пикселях.  Нулевое
значение означает, что правые разделители не отображаются.

@vindex bottom-divider-width@r{, параметр фрейма}
@item bottom-divider-width
Ширина (толщина), зарезервированная для нижнего делителя
(@pxref{Window Dividers}) любого окна в фрейме, в пикселях.  Нулевое
значение означает, что нижние разделители не отображаются.

@vindex menu-bar-lines@r{, параметр фрейма}
@item menu-bar-lines
Число строк, выделяемых в верхней части фрейма для строки меню
(@pxref{Menu Bar}).  По умолчанию значение равно единице, если включен режим
строки меню, и нулю в противном случае.
@xref{Menu Bars,,,emacs, The GNU Emacs Manual}.  Для внешней строки меню
(@pxref{Frame Layout}) это значение остается неизменным, даже если строка
меню переносится на две или более строк.  В этом случае значение
@code{menu-bar-size}, возвращаемое @code{frame-geometry}
(@pxref{Frame Geometry}), позволяет определить, действительно ли строка меню
занимает одну или несколько строк.

@vindex tool-bar-lines@r{, параметр фрейма}
@item tool-bar-lines
Количество строк для панели инструментов (@pxref{Tool Bar}).  По умолчанию
используется один, если включен режим панели инструментов, и ноль в
противном случае.  @xref{Tool Bars,,,emacs, The GNU Emacs Manual}.  Это
значение может измениться всякий раз, когда панель инструментов переносит
(@pxref{Frame Layout}).

@vindex tool-bar-position@r{, параметр фрейма}
@item tool-bar-position
Положение панели инструментов, когда Emacs был собран с помощью GTK+.  Его
значение может быть одним из @code{top}, @code{bottom} @code{left},
@code{right}.  По умолчанию - @code{top}.

@vindex line-spacing@r{, параметр фрейма}
@item line-spacing
Дополнительное пространство в пикселях (положительное целое число), которое
следует оставить под каждой текстовой строкой.  @xref{Line Height}, для
получения дополнительной информации.

@vindex no-special-glyphs@r{, параметр фрейма}
@item no-special-glyphs
Если установленно в не-@code{nil}, подавляется отображение любых глифов
усечения и продолжения (@pxref{Truncation}) для всех буферов, отображаемых
этим фреймом.  Это полезно для устранения таких глифов при подгонке фрейма
к его буферу через @code{fit-frame-to-buffer} (@pxref{Resizing Windows}).
@end table


@node Buffer Parameters
@subsubsection Параметры Буфера
@cindex frame, which buffers to display
@cindex buffers to display on frame

  Эти параметры фрейма, значимые для всех типов терминалов, имеют дело с
тем, какие буферы были или должны отображаться в фрейме.

@table @code
@vindex minibuffer@r{, параметр фрейма}
@item minibuffer
Имеет ли этот фрейм собственный минибуфер.  Значение @code{t} означает «да»,
@code{nil} означает «нет», @code{only} означает, что этот фрейм является
просто минибуфером.  Если значение является окном минибуфера (в каком-то
другом фрейме), фреймx использует этот минибуфер.

Параметр вступает в силу при создании фрейма.  Если установлен в @code{nil},
Emacs попытается установить его в окно минибуфера
@code{default-minibuffer-frame} (@pxref{Minibuffers and Frames}).  Для
существующего фрейма этот параметр может использоваться исключительно для
указания другого окна минибуфера.  Не разрешается менять его из окна
минибуфера на @code{t} и наоборот, или с @code{t} на @code{nil}.  Если
параметр уже определяет окно минибуфера, установка его на @code{nil} не
имеет никакого эффекта.

@vindex buffer-predicate@r{, параметр фрейма}
@item buffer-predicate
Функция предиката буфера для этого фрейма.  Функция @code{other-buffer}
использует этот предикат (из выбранного фрейма), чтобы решить, какие буферы
следует учитывать, если предикат не @code{nil}.  Вызывает предикат с одним
аргументом, буфером, один раз для каждого буфера; если предикат возвращает
значение не-@code{nil}, он считает этот буфер.

@vindex buffer-list@r{, параметр фрейма}
@item buffer-list
Список буферов, которые были выбраны в этом фрейме, отсортированные по
порядку в первую очередь идут последние выбранные.

@vindex unsplittable@r{, параметр фрейма}
@item unsplittable
Если не-@code{nil}, окно этого фрейма никогда не разделяется автоматически.
@end table


@node Frame Interaction Parameters
@subsubsection Frame Interaction Parameters
@cindex frame interaction parameters
@cindex interaction parameters between frames

Эти параметры обеспечивают формы взаимодействия между различными фреймами.

@table @code
@vindex parent-frame@r{, параметр фрейма}
@item parent-frame
Если не-@code{nil}, это означает, что этот фрейм является дочерним
(@pxref{Child Frames}), и этот параметр указывает его родительский фрейм.
Если @code {nil}, это означает, что этот фрейм является нормальным фреймом
верхнего уровня.

@vindex delete-before@r{, параметр фрейма}
@item delete-before
Если не-@code{nil}, этот параметр указывает другой фрейм, удаление которого
автоматически инициирует удаление этого фрейма.  @xref{Deleting Frames}.

@vindex mouse-wheel-frame@r{, параметр фрейма}
@item mouse-wheel-frame
Если не-@code{nil}, этот параметр указывает фрейм, окна которого будут
прокручиваться всякий раз, когда колесо мыши прокручивается с указателем
мыши, наведенным на этот фрейм, смотреть
@ref{Mouse Commands,,, emacs, The GNU Emacs Manual}.

@vindex no-other-frame@r{, параметр фрейма}
@item no-other-frame
Если установлен в не-@code{nil}, то этот фрейм не может быть кандидатом на
функции @code{next-frame}, @code{previous-frame}
(@pxref{Finding All Frames}) и @code{other-frame}, смотреть
@ref{Frame Commands,,, emacs, The GNU Emacs Manual}.

@vindex auto-hide-function@r{, параметр фрейма}
@item auto-hide-function
Когда параметр указывает функцию, функция будет вызываться вместо функции,
указанной переменной @code{frame-auto-hide-function}, при выходе из
единственного фрейма окна (@pxref{Quitting Windows}), не затрагивая другие
фреймы.

@vindex minibuffer-exit@r{, параметр фрейма}
@item minibuffer-exit
Когда параметр - не-@code{nil}, Emacs по умолчанию будет делать этот фрейм
невидимым всякий раз, когда минибуфер (@pxref{Minibuffers}) выходит из
строя.  В качестве альтернативы можно указать функции @code{iconify-frame} и
@code{delete-frame}.  Параметр полезен для автоматического исчезновения
дочернего фрейма (аналогично тому, как Emacs работает с окном) при выходе
из минибуфера.

@vindex keep-ratio@r{, параметр фрейма}
@item keep-ratio
Параметр в настоящее время имеет значение только для дочерних фреймов
(@pxref{Child Frames}).  Если это не-@code{nil}, то Emacs будет пытаться
сохранить соотношения размеров (ширины и высоты) фрейма
(@pxref{Size Parameters}), а также соотношения его левого и правого
положения (@pxref{Position Parameters}) неизменными всякий раз, когда
изменяется размер его родительского фрейма.

Если значение этого параметра - @code{nil}, позиция и размер фрейма остаются
неизменными при изменении размера родительского фрейма, поэтому соотношение
положения и размера может измениться.  Если значение этого параметра -
@code{t}, Emacs попытается сохранить размер фрейма и соотношения положения,
следовательно, размер и положение фрейма относительно его родительского
фрейма могут измениться.

Более индивидуальный контроль возможен при использовании cons-ячейки: в этом
случае соотношение ширины фрейма сохраняется, если @sc{car} ячейки имеет
значение @code{t} или @code{width-only}.  Соотношение высоты сохраняется,
если @sc{car} ячейки установлено в @code{t} или @code{height-only}.
Соотношение левой позиции сохраняется, если @sc{cdr} ячейки установлено в
@code{t} или @code{left-only}.  Коэффициент верхней позиции сохраняется,
если @sc{cdr} ячейки установлен в @code{t} или @code{top-only}.
@end table


@node Mouse Dragging Parameters
@subsubsection Параметры Перетаскивания Мышью
@cindex mouse dragging parameters
@cindex parameters for resizing frames with the mouse
@cindex parameters for moving frames with the mouse

Описанные ниже параметры обеспечивают поддержку изменения размера фрейма
путем перетаскивания его внутренних границ с помощью мыши.  Также позволяют
перемещать фрейм с помощью мыши, перетаскивая строку заголовка самого
верхнего окна или строку режима самого нижнего окна.

Эти параметры в основном полезны для дочерних фреймов
(@pxref{Child Frames}), которые поставляются без декораций оконного
менеджера.  При необходимости их можно использовать и для недекорированных
фреймов верхнего уровня.

@table @code
@vindex drag-internal-border@r{, параметр фрейма}
@item drag-internal-border
Если не-@code{nil}, размер фрейма можно изменить, перетащив его внутренние
границы, если они есть, с помощью мыши.

@vindex drag-with-header-line@r{, параметр фрейма}
@item drag-with-header-line
Если не-@code{nil}, фрейм можно перемещать с помощью мыши, перетаскивая
строку заголовка его самого верхнего окна.

@vindex drag-with-mode-line@r{, параметр фрейма}
@item drag-with-mode-line
Если не-@code{nil}, фрейм можно перемещать с помощью мыши, перетаскивая
строку режима его самого нижнего окна.  Обратить внимание, что такому фрейму
не разрешается иметь собственное окно минибуфера.

@vindex snap-width@r{, параметр фрейма}
@item snap-width
Фрейм, который перемещается с помощью мыши, будет ждать ``щелчок'' на
границе (ах) дисплея или его родительского кадра всякий раз, когда его
перетаскивают как можно ближе к такому краю, указанным количеством пикселей,
в этом параметре.

@vindex top-visible@r{, параметр фрейма}
@item top-visible
Если этот параметр является числом, верхний край фрейма никогда не
появляется над верхним краем его дисплея или родительского фрейма.  Более
того, столько пикселей фрейма задано этим числом, будет оставаться видимым,
когда фрейм перемещается по любому из оставшихся краев его дисплея или
родительского фрейма.  Установка этого параметра полезна для защиты от
перетаскивания дочернего фрейма с параметром не-@code{nil}
@code{drag-with-header-line} полностью за пределы его родительского фрейма.

@vindex bottom-visible@r{, параметр фрейма}
@item bottom-visible
Если параметр является числом, нижний край фрейма никогда не будет ниже
нижнего края его дисплея или родительского фрейма.  Более того, столько
пикселей фрейма, сколько задано этим числом, будет оставаться видимым, когда
фрейм перемещается по любому из оставшихся краев его дисплея или
родительского фрейма.  Установка этого параметра полезна для защиты от
перетаскивания дочернего фрейма с параметром не-@code{nil}
@code{drag-with-mode-line} полностью за пределы его родительского фрейма.
@end table


@node Management Parameters
@subsubsection Параметры Управления Окнами
@cindex window manager interaction, and frame parameters

  Следующие ниже параметры фрейма управляют различными аспектами
взаимодействия кадра с оконным менеджером или оконной системой.  Не влияют
на текстовые терминалы.

@table @code
@vindex visibility@r{, параметр фрейма}
@item visibility
Состояние видимости фрейма.  Есть три возможности: @code{nil} для
невидимого, @code{t} для видимого и @code{icon} для иконизированного.
@xref{Visibility of Frames}.

@vindex auto-raise@r{, параметр фрейма}
@item auto-raise
Если не-@code{nil}, Emacs автоматически поднимает фрейм при его выборе.
Некоторые оконные менеджеры не позволяют этого.

@vindex auto-lower@r{, параметр фрейма}
@item auto-lower
Если не-@code{nil}, Emacs автоматически опускает фрейм, когда он не выбран.
Некоторые оконные менеджеры не позволяют этого.

@vindex icon-type@r{, параметр фрейма}
@item icon-type
Тип значка, который будет использоваться для этого фрейма.  Если значение
является строкой, это указывает файл, содержащий растровое изображение для
использования; @code{nil} не указывает значок (в этом случае оконный
менеджер решает, что показывать); любое другое значение не-@code{nil}
определяет значок Emacs по умолчанию.

@vindex icon-name@r{, параметр фрейма}
@item icon-name
Имя для использования в значке этого фрейма, когда и если значок появляется.
Если это @code{nil}, используется заголовок фрейма.

@vindex window-id@r{, параметр фрейма}
@item window-id
Номер ID, используемый графическим дисплеем для этого фрейма.  Emacs
назначает этот параметр при создании фрейма; изменение параметра не влияет
на фактический номер ID.

@vindex outer-window-id@r{, параметр фрейма}
@item outer-window-id
Номер ID самого внешнего окна оконной системы, в котором существует фрейм.
Как и в случае с @code{window-id}, изменение этого параметра не имеет
фактического эффекта.

@vindex wait-for-wm@r{, параметр фрейма}
@item wait-for-wm
Если не-@code{nil}, указывает Xt дождаться, пока оконный менеджер подтвердит
изменения геометрии.  Некоторые оконные менеджеры, включая версии Fvwm2 и
KDE, не могут подтвердить, поэтому Xt зависает.  Установка для этого
параметра значения в @code{nil}, предотвратит зависание с этими оконными
менеджерами.

@vindex sticky@r{, параметр фрейма}
@item sticky
Если не-@code{nil}, фрейм виден на всех виртуальных рабочих столах в
системах с виртуальными рабочими столами.

@vindex inhibit-double-buffering@r{, параметр фрейма}
@item inhibit-double-buffering
Если не-@code{nil}, фрейм выводится на экран без двойной буферизации.  Emacs
обычно пытается использовать двойную буферизацию, где это возможно, для
уменьшения мерцания.  Установка этого свойства, решает возникающие ошибки
отображения или если требуется почувствовать ретро, flicker-y.

@vindex skip-taskbar@r{, параметр фрейма}
@item skip-taskbar
Если не-@code{nil}, это указывает диспетчеру окон удалить значок фрейма с
панели задач, связанной с отображением фрейма, и запретить переключение на
окно фрейма с помощью комбинации @kbd{Alt-@key{TAB}}.  В MS-Windows иконка
такого фрейма будет катиться???

@vindex no-focus-on-map@r{, параметр фрейма}
@item no-focus-on-map
Если не-@code{nil}, это означает, что фрейм не получает фокус ввода, когда
отображается в (@pxref{Visibility of Frames}).  Некоторые оконные менеджеры
могут не учитывать этот параметр.

@vindex no-accept-focus@r{, параметр фрейма}
@item no-accept-focus
Если не-@code{nil}, означает, что фрейм не получит фокус ввода посредством
явных щелчков мышью или при перемещении в него мыши используя
@code{focus-follows-mouse} (@pxref{Input Focus}) или
@code{mouse-autoselect-window} (@pxref{Mouse Window Auto-selection}).  Это
может иметь нежелательный побочный эффект, заключающийся в том, что
пользователь не может прокручивать невыбранный фрейм с помощью мыши.
Некоторые оконные менеджеры могут не учитывать этот параметр.

@vindex undecorated@r{, параметр фрейма}
@item undecorated
Если не-@code{nil}, окно оконной системы этого фрейма отрисовывается без
украшений, таких как заголовок, минимизация/развертывание блоков и внешних
границ.  Обычно это означает, что окно нельзя перетаскивать, изменять
размер, уменьшать, увеличивать или удалять с помощью мыши.  Если @code{nil},
окно фрейма обычно рисуется со всеми перечисленными выше элементами, если их
отображение не было приостановлено в настройках оконного менеджера.

В X Emacs использует подсказки оконного менеджера Motif для отключения
декораций.  Некоторые оконные менеджеры могут не соблюдать эти подсказки.

Сборки NS рассматривают панель инструментов как украшение и поэтому скрывают
ее на недекорированном фрейме.

@vindex override-redirect@r{, параметр фрейма}
@item override-redirect
@cindex override redirect frames
Если не-@code{nil}, означает, что @dfn{переопределяется перенаправление}
фрейма --- фрейм, не обрабатывается оконными менеджерами в X.
Переопределить фреймы перенаправления не имеют декораций оконного менеджера,
их можно позиционировать и изменять размер только с помощью функций
позиционирования и изменения размера Emacs и обычно рисуются поверх всех
остальных фреймов.  Установка этого параметра не работает на MS-Windows.

@ignore
@vindex parent-id@r{, параметр фрейма}
@item parent-id
@c ??? Еще не работает.
Номер X окна, которое должно быть родительским для этого окна.  Указание
этого позволяет создать окно Emacs внутри окна другого приложения.  (Нет
уверенности, что это будет реализовано; попробуйте и посмотрите, работает
ли.)
@end ignore

@vindex ns-appearance@r{, параметр фрейма}
@item ns-appearance
Доступно только в macOS, если установлено значение @code{dark}, рисовать
окно оконной системы этого фрейма с использованием темы ``vibrant dark'', в
противном случае использовать системное значение по умолчанию.  Тема
``vibrant dark'' может использоваться для установки темного вида панели
инструментов и полос прокрутки при использовании темы Emacs с темным фоном.

@vindex ns-transparent-titlebar@r{, параметр фрейма}
@item ns-transparent-titlebar
Доступно только в macOS, если не-@code{nil}, установить прозрачность
заголовка и панели инструментов.  Это эффективно устанавливает цвета фона
обоих в соответствии с цветом фона Emacs.
@end table


@node Cursor Parameters
@subsubsection Параметры Курсора
@cindex cursor, and frame parameters

  Этот параметр фрейма управляет тем, как выглядит курсор.

@table @code
@vindex cursor-type@r{, параметр фрейма}
@item cursor-type
Как вывести курсор.  Значущие идентификаторы:

@table @code
@item box
Отобразить заполненное поле. (Это значение по умолчанию.)
@item hollow
Показать пустое поле.
@item nil
Не отображать курсор.
@item bar
Отобразить вертикальную полосу между символами.
@item (bar . @var{width})
Отобразить вертикальную полосу шириной @var{width} пикселей между символами.
@item hbar
Отобразите горизонтальную полосу.
@item (hbar . @var{height})
Отобразить горизонтальную полосу высотой @var{height} пикселей.
@end table
@end table

@vindex cursor-type
Параметр фрейма @code{cursor-type} может быть переопределен переменными
@code{cursor-type} и @code{cursor-in-non-selected-windows}:

@defopt cursor-type
Локальная переменная буфера управляет тем, как будет выглядеть курсор в
выбранном окне, показывающем буфер.  Если её значение - @code{t}, это
означает использование курсора, заданного параметром фрейма
@code{cursor-type}.  В противном случае значение должно быть одним из
перечисленных выше типов курсора, и оно переопределяет параметр фрейма
@code{cursor-type}.
@end defopt

@defopt cursor-in-non-selected-windows
Локальная переменная буфра управляет тем, как курсор выглядит в окне,
которое не выбрано.  Поддерживает те же значения, что и параметр фрейма
@code{cursor-type}; Кроме того, @code{nil} означает, что курсор не
отображается в невыделенных окнах, а @code{t} (по умолчанию) означает
использование стандартной модификации обычного типа курсора (сплошная рамка
становится пустой рамкой, а полоса становится более узкой полосой).
@end defopt

@defopt x-stretch-cursor
Переменная управляет шириной блока курсора, отображаемого на очень широких
глифах, таких как табуляция или отрезок пробельного пространства.  По
умолчанию ширина блочного курсора равна ширине символа шрифта по умолчанию,
и не будет охватывать всю ширину глифа под ним, если этот глиф является
сверхшироким.  Значение не-@code{nil} этой переменной означает рисование
курсора блока шириной с глифом под ним.  Значение по умолчанию - @code{nil}.

Переменная не влияет на фреймы текстового режима, поскольку курсор
текстового режима выводится терминалом из-под контроля Emacs.
@end defopt

@defopt blink-cursor-alist
Переменная определяет, мирцание курсора.  Каждый элемент имеет вид
@code{(@var{on-state} . @var{off-state})}.  Когда тип курсора равен
@var{on-state} (сравнение с использованием @code{equal}), соответствующий
@var{off-state} указывает, как выглядит курсор, когда мигает.  Оба
@var{on-state} и @var{off-state} должны быть подходящими значениями для
параметра фрейма @code{cursor-type}.

Существуют различные значения по умолчанию для установки каждого типа
мигания курсора, если тип здесь не указан как @var{on-state}.  Изменения в
этой переменной не вступают в силу немедленно, если только не указан
параметр фрейма @code{cursor-type}.
@end defopt

@node Font and Color Parameters
@subsubsection Параметры Шрифта и Цвета
@cindex font and color, frame parameters

  Эти параметры фрейма управляют использованием шрифтов и цветов.

@table @code
@vindex font-backend@r{, параметр фрейма}
@item font-backend
Список символов с указанием @dfn{бекендов шрифтов}, которые будут
использоваться для рисования шрифтов во фрейме, в порядке приоритета.  В X
в настоящее время доступны два бэкенда шрифтов: @code{x} (драйвер шрифта
ядра X) и @code{xft} (драйвер шрифта Xft).  В MS-Windows в настоящее время
доступны два бэкенда шрифтов: @code{gdi} и @code{uniscribe}
(@pxref{Windows Fonts,,, emacs, The GNU Emacs Manual}).  В других системах
доступен только один бэкэнд шрифтов, поэтому нет смысла изменять этот
параметр фрейма.

@vindex background-mode@r{, параметр фрейма}
@item background-mode
Параметр имеет значение @code{dark} или @code{light}, в зависимости от того,
какой цвет фона - светлый или темный.

@vindex tty-color-mode@r{, параметр фрейма}
@item tty-color-mode
@cindex standard colors for character terminals
Параметр переопределяет цветовую поддержку терминала, заданную системной
базой данных возможностей терминала, поскольку значение этого параметра
определяет цветовой режим для использования на текстовом терминале.
Значение может быть символом или числом.  Число указывает количество
используемых цветов (и, косвенно, то, какие команды выполнять для получения
каждого цвета).  Например, @code{(tty-color-mode . 8)} определяет
использование управляющих последовательностей ANSI для 8 стандартных цветов
текста.  Значение @minus{}1 отключает поддержку цвета.

Если значением параметра является символ, указывается число через значение
@code{tty-color-mode-alist}, и вместо него используется связанное число.

@vindex screen-gamma@r{, параметр фрейма}
@item screen-gamma
@cindex gamma correction
Если это число, Emacs выполняет гамма-коррекцию, которая регулирует яркость
всех цветов.  Значение должно быть гаммой экрана вашего дисплея.

Обычные мониторы ПК имеют гамму экрана 2.2, поэтому значения цвета в Emacs и
в X-окнах в целом откалиброваны для правильного отображения на мониторе с
этим значением гаммы.  Если указывается 2.2 для @code{screen-gamma}, это
означает, что исправление не требуется.  Другие значения требуют коррекции,
чтобы скорректированные цвета отображались на вашем экране так, как они
выглядели бы без коррекции на обычном мониторе со значением гаммы 2.2.

Если монитор отображает слишком светлые цвета, потребуется указать значение
@code{screen-gamma} меньше, чем 2.2.  Это требует коррекции, которая делает
цвета темнее.  Значение гаммы экрана 1.5 может дать хорошие результаты для
цветных дисплеев LCD.

@vindex alpha@r{, параметр фрейма}
@item alpha
@cindex opacity, frame
@cindex transparency, frame
@vindex frame-alpha-lower-limit
Параметр определяет непрозрачность фрейма на графических дисплеях,
поддерживающих переменную непрозрачность.  Это должно быть целое число от 0
до 100, где 0 означает полностью прозрачный, а 100 означает полностью
непрозрачный.  Также может иметь значение @code{nil}, которое говорит Emacs
не устанавливать непрозрачность фрейма (оставив это оконному менеджеру).

Чтобы фрейм не исчез полностью из поля зрения, переменная
@code{frame-alpha-lower-limit} определяет нижний предел непрозрачности.
Если значение параметра фрейма меньше значения этой переменной, Emacs
использует последнее.  По умолчанию @code{frame-alpha-lower-limit} равно 20.

Параметр фрейма @code{alpha} также может быть cons-ячейкой
@code{(@var{active} . @var{inactive})}, где @var{active} - это
непрозрачность фрейма, когда он выбран, а @var{inactive} - это
непрозрачность, когда он не выбран.

Некоторые оконные системы не поддерживают параметр @code{alpha} для дочерних
фреймов (@pxref{Child Frames}).
@end table

Следующие параметры фрейма частично устарели в том смысле, что они
автоматически эквивалентны определенным атрибутам вида определенных видов
(@pxref{Standard Faces,,, emacs, The Emacs Manual}):

@table @code
@vindex font@r{, параметр фрейма}
@item font
Название шрифта для отображения текста во фрейме.  Это строка, либо
допустимое имя шрифта для системы, либо имя набора шрифтов Emacs
(@pxref{Fontsets}).  Эквивалентено атрибуту @code{font} вида @code{default}.

@vindex foreground-color@r{, параметр фрейма}
@item foreground-color
Цвет изображения символа.  Эквивалентно атрибуту @code{:foreground} вида
@code{default}.

@vindex background-color@r{, параметр фрейма}
@item background-color
Цвет фона символов.  Эквивалентен атрибуту @code{:background} вида
@code{default}.

@vindex mouse-color@r{, параметр фрейма}
@item mouse-color
Цвет указателя мыши.  Эквивалентно атрибуту @code{:background} вида
@code{mouse}.

@vindex cursor-color@r{, параметр фрейма}
@item cursor-color
Цвет курсора, который показывает точку.  Эквивалентно атрибуту
@code{:background} вида @code{cursor}.

@vindex border-color@r{, параметр фрейма}
@item border-color
Цвет границы фрейма.  Эквивалентно атрибуту @code{:background} вида
@code{border}.

@vindex scroll-bar-foreground@r{, параметр фрейма}
@item scroll-bar-foreground
Если не-@code{nil}, цвет переднего плана полос прокрутки.  Эквивалентно
атрибуту @code{:foreground} вида @code{scroll-bar}.

@vindex scroll-bar-background@r{, параметр фрейма}
@item scroll-bar-background
Если не-@code{nil}, цвет фона полос прокрутки.  Эквивалентно атрибуту
@code{:background} вида @code{scroll-bar}.
@end table


@node Geometry
@subsection Геометрия

  Вот как проверить данные в спецификации геометрии окна в стиле X:

@defun x-parse-geometry geom
@cindex geometry specification
Функция @code{x-parse-geometry} преобразует стандартную строку геометрии
окна X в список, который можно использовать как часть аргумента
@code{make-frame}.

Список описывает, какие параметры были указаны в @var{geom}, и дает
значения, указанные для них.  Каждый элемент выглядит как
@code{(@var{parameter} . @var{value})}.  Возможные значения @var{parameter}:
@code{left}, @code{top}, @code{width} и @code{height}.

Для параметров размера значение должно быть целым числом.  Имена параметров
положения @code{left} и @code{top} не совсем точны, потому что некоторые
значения вместо этого указывают положение правого или нижнего края.
Возможности @var{value} для параметров позиции: целое число, список
@code{(+ @var{pos})} или список @code{(- @var{pos})}; как описано ранее
(@pxref{Position Parameters}).

Вот пример:

@example
(x-parse-geometry "35x70+0-0")
     @result{} ((height . 70) (width . 35)
         (top - 0) (left . 0))
@end example
@end defun

@node Terminal Parameters
@section Параметры Терминала
@cindex terminal parameters

  Каждый терминал имеет список связанных параметров.  Эти
@dfn{параметры терминала} в основном представляют собой удобный способ
хранения локальных переменных терминала, но некоторые параметры терминала
имеют особое значение.

  В этом разделе описаны функции для чтения и изменения значений параметров
терминала.  Все они принимают в качестве аргумента либо терминал, либо
фрейм; последнее означает использование терминала этого фрейма.  Аргумент
@code{nil} означает терминал выбранного фрейма.

@defun terminal-parameters &optional terminal
Функция возвращает список, в котором перечислены все параметры
@var{terminal} и их значения.
@end defun

@defun terminal-parameter terminal parameter
Функция возвращает значение параметра @var{parameter} (символ) объекта
@var{terminal}.  Если @var{terminal} не имеет настройки для @var{parameter},
эта функция возвращает @code{nil}.
@end defun

@defun set-terminal-parameter terminal parameter value
Функция устанавливает для параметра @var{parameter} объекта @var{terminal}
значение указанного объекта @var{value} и возвращает предыдущее значение
этого параметра.
@end defun

Вот список нескольких параметров терминала, которые имеют особое значение:

@table @code
@item background-mode
Классификация цвета фона терминала: @code{light} или @code{dark}.
@item normal-erase-is-backspace
Значение равно 1 или 0, в зависимости от того, включен или выключен
@code{normal-erase-is-backspace-mode} на этом терминале.
@xref{DEL Does Not Delete,,, emacs, The Emacs Manual}.
@item terminal-initted
После инициализации терминала устанавливается функция инициализации,
специфичная для терминала.
@item tty-mode-set-strings
Если присутствует, список строк, содержащих escape-последовательности,
которые Emacs будет выводить при настройке tty для рендеринга.  Emacs
генерирует эти строки только при настройке терминала: если требуется
включить режим на терминале, который уже активен (например, находясь в
@code{tty-setup-hook}), явно вводится необходимая escape-последовательность
с помощью @code{send-string-to-terminal} в дополнение к добавлению
последовательности в @code{tty-mode-set-strings}.
@item tty-mode-reset-strings
Если присутствует, список строк, отменяющих эффекты строк в
@code{tty-mode-set-strings}.  Emacs выдает эти строки при выходе, удалении
терминала или приостановке работы.
@end table

@node Frame Titles
@section Заголовки Фреймов
@cindex frame title

  Каждый фрейм имеет параметр @code{name}; это используется по умолчанию для
заголовка фрейма, который оконные системы обычно отображают в верхней части
фрейма.  Можно указать имя явно, установив свойство фрейма @code{name}.

  Обычно не указывается имя явно, и Emacs автоматически вычисляет имя фрейма
на основе шаблона, хранящегося в переменной @code{frame-title-format}.
Emacs пересчитывает имя каждый раз при повторном отображении фрейма.

@defvar frame-title-format
Переменная указывает, как вычислить имя для фрейма, если не указано оно
явно.  Значение переменной фактически является конструкцией строки режима,
как и @code{mode-line-format}, за исключением того, что конструкции
@samp{%c}, @samp{%C} и @samp{%l} игнорируются.  @xref{Mode Line Data}.
@end defvar

@defvar icon-title-format
Переменная указывает, как вычислить имя для фрейма с иконкой, если явно не
указан заголовок фрейма.  Этот заголовок отображается в самом значке.
@end defvar

@defvar multiple-frames
Переменная автоматически устанавливается Emacs.  Её значение @code{t}, когда
есть два или более фреймов (не считая фреймов только для минибуфера или
невидимых фреймов).  Значение по умолчанию @code{frame-title-format}
использует @code{multiple-frames}, чтобы поместить имя буфера в заголовок
фрейма, только когда имеется более одного фрейма.

Не гарантируется, что значение этой переменной будет точным, за исключением
обработки @code{frame-title-format} или @code{icon-title-format}.
@end defvar

@node Deleting Frames
@section Удаление Фреймов
@cindex deleting frames

@dfn{Активный фрейм} - это тот, который не был удален.  Когда фрейм
удаляется, он удаляется со своего терминального дисплея, хотя может
продолжать существовать как объект Lisp до тех пор, пока на него не исчезнут
ссылки.

@deffn Command delete-frame &optional frame force
@vindex delete-frame-functions
Функция удаляет фрейм @var{frame}.  Аргумент @var{frame} должен указывать
активный фрейм (смотреть ниже) и по умолчанию использовать выбранный фрейм.

Сначала удаляется любой дочерний кадр @var{frame} (@pxref{Child Frames}) и
любой фрейм, параметр фрейма @code{delete-before} которого
(@pxref{Frame Interaction Parameters}) указывает @var{frame}.  Все такие
удаления выполняются рекурсивно; поэтому этот шаг гарантирует, что никаких
других фреймов с @var{frame} в качестве предка не будет.  Затем, если
@var{frame} не указывает всплывающую подсказку, эта функция запускает
ловушку @code{delete-frame-functions} (каждая функция получает один
аргумент, @var{frame}) перед фактическим уничтожением фрейма.

Обратить внимание, что фрейм не может быть удален, пока его минибуфер служит
суррогатным минибуфером для другого фрейма (@pxref{Minibuffers and Frames}).
Обычно не получиться удалить фрейм, если все остальные фреймы невидимы, но
если @var{force} равен не-@code{nil}, это сделать возможно.
@end deffn

@defun frame-live-p frame
Функция возвращает не-@code{nil}, если фрейм @var{frame} не был удален.
Возможные возвращаемые значения не-@code{nil} аналогичны значениям
@code{framep}.  @xref{Frames}.
@end defun

  Некоторые оконные менеджеры предоставляют команду для удаления окна.  Они
работают, отправляя специальное сообщение программе, которая управляет
окном.  Когда Emacs получает одну из этих команд, он генерирует событие
@code{delete-frame}, обычным определением которого является команда,
вызывающая функцию @code{delete-frame}.  @xref{Misc Events}.

@deffn Command delete-other-frames &optional frame
Команда удаляет все фреймы на терминале @var{frame}, кроме @var{frame}.
Если @var{frame} использует минибуфер другого фрейма, этот фрейм минибуфера
остается нетронутым.  Аргумент @var{frame} должен указывать активный фрейм
и по умолчанию использовать выбранный фрейм.  Внутренне эта команда
работает, вызывая @code{delete-frame} с @var{force} @code{nil} для всех
фреймов, которые должны быть удалены.

Функция не удаляет ни один из дочерних кадров @var{frame}
(@pxref{Child Frames}).  Если @var{frame} является дочерним фреймом, он
удаляет только одноуровневые объекты @var{frame}.
@end deffn


@node Finding All Frames
@section Поиск Всех Фреймов
@cindex frames, scanning all

@defun frame-list
Функция возвращает список всех активных фреймов, то есть тех, которые не
были удалены.  Аналогичено @code{buffer-list} для буферов и включает фреймы
на всех терминалах.  Список, который получается, создается заново, поэтому
изменение списка не влияет на внутреннюю структуру Emacs.
@end defun

@defun visible-frame-list
Функция возвращает список только видимых в данный момент фреймов.
@xref{Visibility of Frames}.  Фреймы на текстовых терминалах всегда
считаются видимыми, даже если фактически отображается только выбранный.
@end defun

@defun frame-list-z-order &optional display
Функция возвращает список фреймов Emacs в порядке Z (стекирования)
(@pxref{Raising and Lowering}).  Необязательный аргумент @var{display}
указывает, какой дисплей следует опросить.  @var{display} должен быть либо
фреймом, либо отображаемым именем (строкой).  Если опущено или @code{nil},
это означает отображение выбранного фрейма.  Возвращается @code{nil}, если
@var{display} не содержит фрейма Emacs.

Фреймы перечислены от самого верхнего (первого) до самого нижнего
(последнего).  В качестве особого случая, если @var{display} имеет значение
не-@code{nil} и задается активный фрейм, возвращаются дочерние фреймы этого
фрейма в Z (наложении) порядке.

Эта функция не имеет смысла для текстовых терминалов.
@end defun

@defun next-frame &optional frame minibuf
Функция позволяет удобно циклически перебирать все фреймы на конкретном
терминале с произвольной начальной точки.  Возвращается фрейм, следующий за
@var{frame}, в списке всех активных фреймов на терминале @var{frame}.
Аргумент @var{frame} должен указывать активный фрейм и по умолчанию
использовать выбранный фрейм.  Никогда не возвращается фрейм, у которого
параметр @code{no-other-frame} (@pxref{Frame Interaction Parameters}) равен
не-@code{nil}.

Второй аргумент, @var{minibuf}, говорит, какие фреймы следует учитывать:

@table @asis
@item @code{nil}
Исключить фреймы только для минибуфера.
@item @code{visible}
Учитывать все видимые фреймы.
@item 0
Учитывать все видимые или иконизированные фреймы.
@item a window
Рассматривать только фреймы, использующие это конкретное окно в качестве
своего минибуфера.
@item anything else
Рассмотреть все фреймы.
@end table
@end defun

@defun previous-frame &optional frame minibuf
Аналогично @code{next-frame}, но циклически перебирает все фреймы в
противоположном направлении.
@end defun

  Смотреть также @code{next-window} и @code{previous-window}, в
  @ref{Cyclic Window Ordering}.

@node Minibuffers and Frames
@section Минибуферы и Фреймы

Обычно у каждого фрейма есть собственное окно минибуфера внизу, которое
используется всякий раз, когда этот фрейм выбирается.  Можно получить это
окно с помощью функции @code{minibuffer-window}
(@pxref{Minibuffer Windows}).

@cindex frame without a minibuffer
@cindex surrogate minibuffer frame
Однако также можно создать фрейм без минибуфера.  Такой фрейм должен
использовать окно минибуфера какого-либо другого фрейма.  Этот другой фрейм
будет служить @dfn{фреймом суррогатного минибуфера} для этого фрейма и не
может быть удален через @code{delete-frame} (@pxref{Deleting Frames}), пока
этот фрейм существует.

Когда создается фрейм, можно явно указать его окно минибуфера (в каком-то
другом фрейме) с параметром @code{minibuffer} frame
(@pxref{Buffer Parameters}).  Если этого не сделаеть, то минибуфер находится
в фрейме, который указывается значением переменной
@code{default-minibuffer-frame}.  Этим значением должен быть фрейм, у
которого есть минибуфер.

Если используется фрейм только для минибуфера, можно захотеть, чтобы этот
фрейм поднимался при входе в минибуфер.  Если это так, установить для
переменной @code{minibuffer-auto-raise} значение @code{t}.
@xref{Raising and Lowering}.

@defvar default-minibuffer-frame
Переменная определяет фрейм, используемый по умолчанию для окна минибуфера.
Это не влияет на существующие фреймы.  Всегда локальна для текущего
терминала и не может быть локальным для буфера.  @xref{Multiple Terminals}.
@end defvar


@node Input Focus
@section Входной Фокус
@cindex input focus
@cindex selected frame

В любой момент один фрейм в Emacs - это @dfn{выбранный фрейм}.  Выбранное
окно всегда находится на выбранном фрейме.

Когда Emacs отображает свои фреймы на нескольких терминалах
(@pxref{Multiple Terminals}), каждый терминал имеет свой собственный
выбранный фрейм.  Но только один из них - @emph{это} выбранный фрейм:
фрейм, принадлежащий терминалу, с которого был получен последний ввод.  То
есть, когда Emacs запускает команду, пришедшую с определенного терминала,
выбранный фрейм является фреймом этого терминала.  Поскольку Emacs запускает
только одну команду в любой момент времени, ему нужно рассматривать только
один выбранный фрейм за раз; этот фрейм называется @dfn{выбранный фрейм} в
этом руководстве.  Дисплей, на котором отображается выбранный кадр, - это
@dfn{отображение выбранного кадра}.

@defun selected-frame
Функция возвращает выбранный фрейм.
@end defun

Некоторые оконные системы и оконные менеджеры направляют ввод с клавиатуры
на объект окна, в котором находится мышь; другие требуют явных щелчков или
@dfn{сместить фокус} команд для  различных оконных объектов.  В любом случае
Emacs автоматически отслеживает, какой фрейм находится в фокусе.  Чтобы явно
переключиться на другой фрейм из функции Lisp, вызвать
@code{select-frame-set-input-focus}.

Программы Lisp также могут временно переключать фреймы, вызывая функцию
@code{select-frame}.  Это не меняет концепции фокуса оконной системы;
скорее, ускользается из-под управления оконного менеджера до тех пор, пока
это управление каким-либо образом не будет подтверждено повторно.

При использовании текстового терминала одновременно на терминале может
отображаться только один фрейм, поэтому после вызова @code{select-frame}
следующее повторное отображение фактически отображает только что выбранный
фрейм.  Этот фрейм остается выбранным до следующего вызова
@code{select-frame}.  Каждый фрейм на текстовом терминале имеет номер,
который появляется в строке режима перед именем буфера
(@pxref{Mode Line Variables}).

@defun select-frame-set-input-focus frame &optional norecord
Функция выбирает @var{frame}, поднимает его (если оказывается закрытым
другими фреймами) и пытается передать ему фокус X-сервера.  На текстовом
терминале следующее повторное отображение отображает новый фрейм на всем
экране терминала.  Необязательный аргумент @var{norecord} имеет то же
значение, что и @code{select-frame} (смотреть ниже).  Возвращаемое значение
этой функции не имеет значения.
@end defun

В идеале описанная далее функция должна фокусировать фрейм, не поднимая его
над другими фреймами.  К сожалению, многие оконные системы или оконные
менеджеры могут отказаться подчиняться.

@defun x-focus-frame frame &optional noactivate
Функция дает @var{frame} фокус X-сервера без необходимости его поднятия.
@var{frame} установленное в @code{nil} означает использовать выбранный
фрейм.  В X необязательный аргумент @var{noactivate}, если не-@code{nil},
означает, что окно @var{frame} оконной системы не должно быть ``активным''
окном, которое должно настаивать на том, чтобы не поднимать @var{frame} над
другими фреймами.

В MS-Windows аргумент @var{noactivate} не действует.  Однако, если
@var{frame} является дочерним фреймом (@pxref{Child Frames}), функция обычно
фокусирует @var{frame}, не поднимая его над другими дочерними кадрами.

Если нет поддержки оконной системы, эта функция ничего не делает.
@end defun

@deffn Command select-frame frame &optional norecord
Функция выбирает фрейм @var{frame}, временно игнорируя фокус X-сервера, если
таковой имеется.  Выбор @var{frame} длится до следующего раза, когда
пользователь что-то сделает для выбора другого фрейма, или до следующего
вызова этой функции.  (Если используется оконная система, ранее выбранный
фрейм может быть восстановлен как выбранный фрейм после возврата в цикл
команд, потому что все еще может иметься фокус ввода оконной системы.)

Указанный @var{frame} становится выбранным фреймом, а его терминал
становится выбранным терминалом.  Затем функция вызывает
@code{select-window} как подпрограмму, передавая окно, выбранное в
@var{frame}, в качестве первого аргумента и @var{norecord} в качестве
второго аргумента (следовательно, если @var{norecord} - не-@code{nil}, это
позволяет избежать изменения порядка недавно выбранных окон и списка
буферов).  @xref{Selecting Windows}.

Функция возвращает @var{frame} или @code{nil}, если @var{frame} был удален. 

В общем, никогда не нужно использовать @code{select-frame} таким образом,
чтобы можно было переключиться на другой терминал, не переключаясь обратно,
в конце.
@end deffn

Emacs взаимодействует с оконной системой, организуя выбор фреймов в качестве
запросов сервера и оконного менеджера.  Делает это, генерируя особый вид
входного события, называемого событием @dfn{фокус}, когда это необходимо.
Командный цикл обрабатывает событие фокуса, вызывая
@code{handle-switch-frame}.  @xref{Focus Events}.

@deffn Command handle-switch-frame frame
Функция обрабатывает событие фокуса, выбирая кадр @var{frame}.

События фокуса обычно выполняют свою работу, вызывая эту команду.
Не вызывать это по какой-либо другой причине.
@end deffn

@defun redirect-frame-focus frame &optional focus-frame
Функция перенаправляет фокус с @var{frame} на @var{focus-frame}.  Это
означает, что @var{focus-frame} будет получать последующие нажатия клавиш и
события, предназначенные для @var{frame}.  После такого события значение
@code{last-event-frame} будет @var{focus-frame}.  Кроме того, события
switch-frame, указывающие @var{frame}, вместо этого выберут
@var{focus-frame}.

Если @var{focus-frame} опущен или @code{nil}, это отменяет любое
существующее перенаправление для @var{frame}, которое, таким образом, снова
получает свои собственные события.

Одно из применений перенаправления фокуса - для фреймов, у которых нет
минибуферов.  Эти фреймы используют минибуферы на других фреймах.  Активация
минибуфера на другом фрейме перенаправляет фокус на этот фрейм.  Это
помещает фокус на фрейм минибуфера, которому он принадлежит, даже если мышь
остается в фрейме, который активировал минибуфер.

Выбор фрейма также может изменить перенаправление фокуса.  Выбор фрейма
@code{bar}, когда был выбран @code{foo}, изменяет любые перенаправления,
указывающие на @code{foo}, так, чтобы вместо этого они указывали на
@code{bar}.  Это позволяет перенаправлению фокуса работать правильно, когда
пользователь переключается с одного кадра на другой с помощью
@code{select-window}.

Это означает, что фрейм, фокус которого перенаправлен на себя,
обрабатывается иначе, чем фрейм, фокус которого не перенаправлен.
@code{select-frame} влияет на первое, но не на второе.

Перенаправление длится до тех пор, пока не будет вызвана функция
@code{redirect-frame-focus} для его изменения.
@end defun

@defvar focus-in-hook
Нормальный запуск ловушки, когда фрейм Emacs получает фокус ввода.
Фокусировка кадра выбирается, когда этот хук запущен.
@end defvar

@defvar focus-out-hook
Нормальный запуск ловушки, когда фрейм Emacs потерял фокус ввода и вместо
этого никакой другой фрейм Emacs не получил фокус ввода.
@end defvar

@defopt focus-follows-mouse
Опция сообщает Emacs, передает ли оконный менеджер фокус, когда перемещается
указатель мыши во фрейм, и каким образом.  Может иметь три значимых
значения:

@table @asis
@item @code{nil}
Значение по умолчанию @code{nil} следует использовать, когда оконный
менеджер следует политике ``щелчок для фокусировки'', где требуется щелкнуть
мышью внутри фрейма, чтобы этот фрейм получил фокус.

@item @code{t}
Значение @code{t} следует использовать, когда оконный менеджер имеет фокус,
автоматически отслеживающий положение указателя мыши, но фрейм, который
получает фокус, не поднимается автоматически и может даже оставаться
закрытым другими окнами оконной системы.

@item @code{auto-raise}
Значение @code{auto-raise} следует использовать, когда оконный менеджер
имеет фокус, который автоматически следует за положением указателя мыши, а
фрейм, который получает фокус, поднимается автоматически.
@end table

Если эта опция - не-@code{nil}, Emacs перемещает указатель мыши на фрейм,
выбранный @code{select-frame-set-input-focus}.  Функция используется рядом
команд, например, @code{other-frame} и @code{pop-to-buffer}.

Различие между значениями @code{t} и @code{auto-raise} не требуется для
``нормальных'' фреймов, потому что оконный менеджер обычно заботится об их
повышении.  Полезно автоматически поднимать дочерние фреймы через
@code{mouse-autoselect-window} (@pxref{Mouse Window Auto-selection}).

Обратить внимание, что этот параметр не различает ``небрежный'' фокус (где
фрейм, у которого ранее был фокус, сохраняет фокус, пока указатель мыши не
перемещается в другое окно оконного менеджера) от фокуса ``строгий'' (где
фрейм сразу теряет фокус, когда его оставляет мышь указатель).  Также не
распознается, поддерживает ли оконный менеджер отложенную фокусировку или
автоподъем, где можете явно указать время до тех пор, пока новый фрейм не
получит фокус или не будет автоматически поднят.

Можете предоставить политику ``фокус следует за мышью'' для отдельных окон
Emacs, настроив переменную @code{mouse-autoselect-window}
(@pxref{Mouse Window Auto-selection}).
@end defopt


@node Visibility of Frames
@section Видимость Фреймов
@cindex visible frame
@cindex invisible frame
@cindex iconified frame
@cindex minimized frame
@cindex frame visibility

Фрейм на графическом дисплее может иметь размер @dfn{видимый},
@dfn{невидимый} или @dfn{иконизированный}.  Если виден, его содержимое
отображается обычным образом.  Если обозначен значком, его содержимое не
отображается, но где-то есть маленький значок, чтобы вернуть фрейм в поле
зрения (некоторые оконные менеджеры называют это состояние
@dfn{минимизированное}, а не @dfn{иконизированное}, но с точки зрения Emacs
это одно и тоже).  Если фрейм невидим, он вообще не отображается.

@cindex mapped frame
@cindex unmapped frame
  Концепция видимости тесно связана с концепцией (не) отображенных фреймов.
Фрейм (или, точнее, его окно оконной системы) есть и становится
@dfn{нанесенным на карту}, когда отображается в первый раз и всякий раз,
когда меняет свое состояние видимости с @code{иконизированного} или
@code{невидимого} на @code{видимое}.  И наоборот, фрейм становится
@dfn{не нанесенный на карту} всякий раз, когда он меняет свой статус с
@code{видимого} на @code{иконизированное} или @code{невидимое}.

  Видимость не имеет смысла на текстовых терминалах, поскольку в любом
случае фактически отображается только выбранный фрейм.

@defun frame-visible-p frame
Функция возвращает статус видимости фрейма @var{frame}.  Значение -
@code{t}, если @var{frame} виден, @code{nil}, если он невидим, и
@code{icon}, если он обозначен иконкой.

В текстовом терминале все фреймы считаются видимыми для этой функции, даже
если отображается только один фрейм.
@xref{Raising and Lowering}.
@end defun

@deffn Command iconify-frame &optional frame
Функция обозначает фрейм @var{frame}.  Если не указано @var{frame},
выбранный фрейм будет отмечен значком.  Обычно это делает все дочерние
фреймы @var{frame} (и их потомки) невидимыми (@pxref{Child Frames}).
@end deffn

@deffn Command make-frame-visible &optional frame
Функция делает видимым фрейм @var{frame}.  Если не указать @var{frame},
выбранный кадр станет видимым.  Это не поднимает фрейм, но можно сделать это
с помощью @code{raise-frame}, если хотите (@pxref{Raising and Lowering}).

Когда фрейм становится видимым, обычно все его дочерние фреймы (и их
потомки) также становятся видимыми (@pxref{Child Frames}).
@end deffn

@deffn Command make-frame-invisible &optional frame force
Функция делает невидимым фрейм @var{frame}.  Если опустить @var{frame},
выбранный фрейм станет невидимым.  Обычно это делает все дочерние фреймы
@var{frame} (и их потомки) также невидимыми (@pxref{Child Frames}).

Если @var{force} не является не-@code{nil}, функция отказывается делать
@var{frame} невидимым, если все остальные фреймы невидимы.
@end deffn

  Статус видимости фрейма также доступен как параметр фрейма.  Можно
прочитать или изменить его как таковой.  @xref{Management Parameters}.
Пользователь также может уменьшать и деактивировать фреймы с помощью
оконного менеджера.  Это происходит ниже уровня, на котором Emacs может
осуществлять любое управление, но Emacs действительно предоставляет события,
которые можно использовать для отслеживания таких изменений.
@xref{Misc Events}.

@defun x-double-buffered-p &optional frame
Функция возвращает не-@code{nil}, если @var{frame} в настоящее время
визуализируется с двойной буферизацией.  @var{frame} по умолчанию
использует выбранный фрейм.
@end defun


@node Raising and Lowering
@section Подъем, Опускание и Перетасовка Фреймов

@cindex raising a frame
@cindex lowering a frame
@cindex restacking a frame
@cindex frame stacking order
@cindex frame Z-order
@cindex Z-order
  В большинстве оконных систем используется метафора рабочего стола.  Частью
этой метафоры является идея о том, что окна системного уровня
(представляющие, например, фреймы Emacs) располагаются в условном третьем
измерении, перпендикулярном поверхности экрана.  Порядок, вызванный
наложением, является полным и обычно называется порядком наложения (или Z-)
порядком.  Там, где области двух окон перекрываются, то, что находится выше
в этом порядке, будет (частично) закрывать нижнее.

  Можно @dfn{поднимать} фрейм вверх этого порядка или @dfn{опускать} фрейм
вниз, используя функции @code{raise-frame} и @code{lower-frame}.  Можно
@dfn{перекладывать заново} фрейм непосредственно над или под другим фреймом,
используя функцию @code{frame-restack}.

  Обратить внимание, что все функции, описанные ниже, будут учитывать
привязку фреймов (и всех других окон оконной системы) к их соответствующей
z-группе (@pxref{Position Parameters}).  Например, обычно не получиться
опустить фрейм ниже окна рабочего стола, и не выйдет поднять фрейм, параметр
@code{z-group} которого равен @code{nil}, над панелью задач оконной системы
или окном всплывающей подсказки.

@deffn Command raise-frame &optional frame
Функция поднимает фрейм @var{frame} (по умолчанию, выбранный фрейм) над
всеми другими фреймами, принадлежащими той же или более низкой z-группе, что
и @var{frame}.  Если @var{frame} невидим или обозначен значком, он
становится видимым.  Если @var{frame} является дочерним фреймом
(@pxref{Child Frames}), это поднимает @var{frame} выше всех остальных
дочерних фреймов своего родителя.
@end deffn

@deffn Command lower-frame &optional frame
Функция опускает фрейм @var{frame} (по умолчанию, выбранный кадр) ниже всех
других фреймов, принадлежащих той же или более высокой z-группе, что и
@var{frame}.  Если @var{frame} является дочерним фреймом
(@pxref{Child Frames}), это опускает @var{frame} ниже всех остальных
дочерних фреймов своего родителя.
@end deffn

@defun frame-restack frame1 frame2 &optional above
Функция перезагружает @var{frame1} ниже @var{frame2}.  Это означает, что
если видны оба фрейма и их области отображения перекрываются, @var{frame2}
(частично) закроет @var{frame1}.  Если необязательный третий аргумент
@var{above} - не-@code{nil}, эта функция помещает @var{frame1} поверх
@var{frame2}.  Это означает, что если видны оба кадра и их области
отображения перекрываются, @var{frame1} (частично) закроет @var{frame2}.

Технически эту функцию можно рассматривать как атомарное действие,
выполняемое в два этапа: Первый шаг удаляет окно оконной системы
@var{frame1} с дисплея.  На втором шаге окно @var{frame1} повторно
вставляется в отображение ниже (вверху, если @var{above} истинно),
отображения @var{frame2}.  Следовательно, положение @var{frame2} в Z-порядке
отображения (наложения) относительно всех других фреймов, за исключением
@var{frame1}, остается неизменным.

Некоторые оконные менеджеры могут отказываться переупаковывать окна.
@end defun

Обратить внимание, что эффект перетасовки будет сохраняться только до тех
пор, пока ни один из задействованных фреймов не будет отмечен значком или
не станет невидимым.  Можно использовать параметр фрейма @code{z-group}
(@pxref{Position Parameters}), чтобы добавить фрейм к группе фреймов,
постоянно отображаемый над или под другими фреймами.  Пока фрейм принадлежит
к одной из этих групп, перетасовка будет влиять только на его относительное
положение в стеке внутри этой группы.  Эффект от перестановки фреймов,
принадлежащих разным z-группам, не определен.  Можно перечислить фреймы в их
текущем порядке наложения с помощью функции @code{frame-list-z-order}
(@pxref{Finding All Frames}).

@defopt minibuffer-auto-raise
Если это не-@code{nil}, активация минибуфера поднимает фрейм, в котором
находится окно минибуфера.
@end defopt

  В оконных системах также можно включить автоматическое поднятие (при
выборе фоейма) или автоматическое опускание (при отмене выбора фрейма) с
помощью параметров фрейма.  @xref{Management Parameters}.

@cindex top frame
  Концепция подъема и опускания фреймов также применима к фреймам текстового
терминала.  На каждом текстовом терминале одновременно отображается только
верхний фрейм.

@defun tty-top-frame &optional terminal
Функция возвращает верхний фрейм на @var{terminal}.  @var{terminal} должен
быть конечным объектом, фреймом (то есть терминалом этого фрейма) или
@code{nil} (то есть терминалом выбранного фрейма).  Если не относится к
текстовому терминалу, возвращаемое значение - @code{nil}.
@end defun


@node Frame Configurations
@section Конфигурации Фреймов
@cindex frame configuration

  @dfn{Конфигурация фреймов} записывает текущее расположение фреймов, все их
свойства и конфигурацию окна каждого из них (@xref{Window Configurations}).

@defun current-frame-configuration
Функция возвращает список конфигурации фреймов, который описывает текущее
расположение фреймов и их содержимое.
@end defun

@defun set-frame-configuration configuration &optional nodelete
Функция восстанавливает состояние фреймов, описанное в @var{configuration}.
Однако эта функция не восстанавливает удаленные фреймы.

Обычно функция удаляет все существующие фреймы, не перечисленные в
@var{configuration}.  Но если @var{nodelete} равен не-@code{nil}, вместо
этого отображаются ненужные фреймы.
@end defun


@node Child Frames
@section Дочерние Фреймы
@cindex child frames
@cindex parent frames

Дочерние фреймы - это объекты, расположенные посередине между фреймами
(@pxref{Windows}) и ``нормальных'' окон.  Как и окна, они прикреплены к
фрейму-владельцу.  В отличие от окон, могут перекрывать друг друга -
изменение размера или положения одного дочернего фрейма не меняет размер
или положение любого из его дочерних фреймов-братьев.

  По замыслу, операции по созданию или изменению дочерних фреймов
реализованы с помощью параметров фрейма (@pxref{Frame Parameters}) без
каких-либо специализированных функций или настраиваемых переменных.
Обратить внимание, что дочерние фреймы имеют смысл только на графических
терминалах.

  Чтобы создать новый дочерний фрейм или преобразовать обычный фрейм в
дочерний фрейм, устанавливается для параметра @code{parent-frame} этого
фрейма (@pxref{Frame Interaction Parameters}) значение уже существующего
фрейма.  Фрейм, указанный этим параметром, будет в этом случае родительским
фреймом до тех пор, пока параметр не будет изменен или сброшен.  Технически
это делает окно оконной системы дочернего фрейма дочерним окном оконной
системы родительского фрейма.

@cindex reparent frame
@cindex nest frame
  Параметр @code{parent-frame} можно изменить в любой момент.  Установка
значением другой фрейм @dfn{репатентирует} дочерний фрейм.  Установка
значением другой дочерний фрейм делает фрейм дочерним @dfn{вложенным}
фреймом.  Установка значения в @code{nil} восстанавливает статус фрейма как
фрейм верхнего уровня - фрейм, становится окном оконной системы, которое
является дочерним по отношению к корневому окну дисплея фрейма.

  Поскольку дочерние фреймы могут быть вложены произвольно, фрейм может быть
как дочерним, так и родительским.  Кроме того, относительные роли дочернего
и родительского фреймов можно поменять местами в любое время (хотя обычно
рекомендуется сохранять размер дочернего фрейма достаточно меньшим, чем
фрейм его родителя).  Будет выдана ошибка при попытке сделать фрейм своим же
предком.

   Большинство оконных систем обрезают дочерний фрейм по родным краям
(@pxref{Frame Geometry}) его родительского фрейма - все, что находится за
пределами этих краев, обычно невидимо.  Параметры @code{left} и @code{top}
дочернего фрейма определяют положение относительно верхнего левого угла
родительского фрейма.  Когда размер родительского фрейма изменяется, это
положение концептуально остается неизменным.

  Сборки NS не обрезают дочерние фреймы по краям родительского фрейма, что
позволяет размещать их так, чтобы они не закрывали родительский фрейм,
оставаясь при этом видимыми сами по себе.

  Обычно при перемещении родительского фрейма перемещаются также все его
дочерние фреймы и их потомки, сохраняя их относительное положение
неизменным.  Обратить внимание, что обработчик @code{move-frame-functions}
(@pxref{Frame Position}) запускается для дочернего фрейма только тогда,
когда положение дочернего фрейма относительно его родительского фрейма
изменяется.

  Когда размер родительского фрейма изменяется, его дочерние фреймы
концептуально сохраняют свои предыдущие размеры и свое положение
относительно левого верхнего угла родительского фрейма.  Это означает, что
дочерний фрейм может стать (частично) невидимым, когда его родительский
фрейм сжимается.  Параметр @code{keep-ratio}
(@pxref{Frame Interaction Parameters}) можно использовать для
пропорционального изменения размера и перемещения дочернего фрейма всякий
раз, когда изменяется размер его родительского фрейма.  Это поможет избежать
затемнения частей фрейма при сжатии его родительского фрейма.

  Видимый дочерний фрейм всегда появляется поверх своего родительского
фрейма, закрывая его части, за исключением сборок NS, где он может быть
расположен под родительским фреймом.  Это сравнимо с окном оконной системы
фрейма верхнего уровня, который также всегда появляется поверх своего
родительского окна - корневого окна рабочего стола.  Когда родительский
фрейм отображается в виде значка или становится невидимым
(@pxref{Visibility of Frames}), его дочерние фреймы становятся невидимыми.
Когда родительский фрейм деиконифицируется или становится видимым, его
дочерние фреймы становятся видимыми.  Когда родительский фрейм должен быть
удален (@pxref{Deleting Frames}), его дочерние фреймы рекурсивно удаляются
перед ним.

  Может ли дочерний фрейм иметь меню или панель инструментов, зависит от
оконной системы или оконного менеджера.  Большинство оконных систем явно
запрещают строки меню для дочерних фреймов.  Кажется целесообразным
отключить и меню, и панели инструментов с помощью начальных настроек
параметров фрейма.

  Обычно дочерние фреймы не имеют таких украшений оконного менеджера, как
строка заголовка или внешние границы (@pxref{Frame Geometry}).  Когда в
дочернем фрейме не отображается меню или панель инструментов, вместо внешних
границ можно использовать любую другую из границ (@pxref{Layout Parameters})фрейма.

  В частности, под X (но не при построении с помощью GTK+) может
использоваться внешняя граница фрейма.  В MS-Windows при указании ненулевой
ширины внешней границы будет отображаться внешняя граница шириной в один
пиксель.  Под все оконные системы можно использовать внутренний фрейм.  В
любом случае рекомендуется отключить декорации оконного менеджера дочернего
фрейма параметром @code{undecorated} frame (@pxref{Management Parameters}).

  Чтобы изменить размер или переместить недекорированный дочерний фрейм с
помощью мыши, необходимо использовать специальные параметры фрейма
(@pxref{Mouse Dragging Parameters}).  Внутренняя граница дочернего фрейма,
если она есть, может использоваться для изменения размера фрейма с помощью
мыши, при условии, что фрейм имеет параметр @code{drag-internal-border}
установленный в не-@code{nil} .  Если установлено, параметр
@code{snap-width} указывает количество пикселей, в которых регистрируется
положение @dfn{щелчка} соответствующим крае или углу его родительского
фрейма.

  Есть два способа перетащить весь дочерний фрейм с помощью мыши: Параметр
@code{drag-with-mode-line}, если не-@code{nil}, позволяет перетащить фрейм
без окна минибуфера (@pxref{Minibuffer Windows}) через область строки режима
его самого нижнего окна.  Параметр @code{drag-with-header-line}, если
не-@code{nil}, позволяет перетаскивать фрейм через область строки заголовка
самого верхнего окна.

  Чтобы дать дочернему фрейму перетаскиваемый заголовок или строку режима,
удобны параметры окна @code{mode-line-format} и @code{header-line-format}
(@pxref{Window Parameters}).  Это позволяет удалить ненужную строку режима
(когда выбран @code{drag-with-header-line}) и удалить чувствительные к мыши
области, которые могут мешать перетаскиванию фрейму.

  Чтобы избежать того, что перетаскивание полностью перемещает фрейм из
собственного родительского фрейма, что может произойти, когда курсор мыши
выходит за пределы и затрудняет извлечение фрейма после того, как кнопка
мыши была отпущена, рекомендуется установить параметр @code{top-visible} или
@code{bottom-visible} фрейма соответствующим образом.

  Параметр @code{top-visible} указывает количество пикселей в верхней части
фрейма, которые всегда остаются видимыми в собственном фрейме родителя во
время перетаскивания, и должен быть установлен при указании параметра
@code{drag-with-header-line} в не-@code{nil}.  Параметр
@code{bottom-visible} указывает количество пикселей в нижней части фрейма,
которые всегда остаются видимыми в собственном фрейме родителя во время
перетаскивания, и его следует использовать при указаном параметре
@code{drag-with-mode-line} в не-@code{nil}.

  Когда дочерний фрейм используется для отображения буфера через
@code{display-buffer-in-child-frame}
(@pxref{Buffer Display Action Functions}), параметр
фрейма @code{auto-hide-function} (@pxref{Frame Interaction Parameters})
может быть установлен в функцию, чтобы должным образом работать с фреймом,
когда окно, отображающее буфер, должно быть закрыто.

  Когда дочерний фрейм используется во время взаимодействия с минибуфером,
например, для отображения завершений в отдельном окне, параметр
@code{minibuffer-exit} (@pxref{Frame Interaction Parameters}) полезен для
обработки фрейма при выходе из минибуфера.

  Поведение дочерних фреймов также отличается от поведения фреймов верхнего
уровня по ряду других причин.  Вот набросок некоторых из них:

@itemize @bullet
@item
Семантика развертывания дочерних фреймов и их пиктограммы сильно зависит от
оконной системы.  Как правило, приложения никогда не должны вызывать эти
операции над дочерними фреймами.  По умолчанию при вызове
@code{iconify-frame} в дочернем фрейме вместо этого будет предпринята
попытка превратить в иконку фрейм верхнего уровня, соответствующий этому
дочернему фрейму.  Чтобы получить другое поведение, пользователи могут
настроить параметр @code{iconify-child-frame}, описанный ниже.

@item
Поднятие, опускание и перетасовка дочерних фреймов
(@pxref{Raising and Lowering}) или изменение @code{z-group}
(@pxref{Position Parameters}) дочернего фрейма изменяет только порядок
наложения дочерних фреймов с тем же родителем.

@item
Многие оконные системы не могут изменять (@pxref{Font and Color Parameters})
непрозрачности дочерних фреймов.

@item
Передача фокуса от дочернего фрейма к предку, не являющемуся его
родительским, путем щелчка мышью в видимой части окна этого предка может
завершиться ошибкой с некоторыми оконными системами.  Возможно, придется
сначала щелкнуть окно оконной системы непосредственного родителя.

@item
Оконные менеджеры могут не беспокоиться о расширении своего внимания, следуя
политике мыши, на дочерние фреймы.  В этом отношении может помочь настройка
@code{mouse-autoselect-window} (@pxref{Mouse Window Auto-selection}).

@item
Удаление (@pxref{Drag and Drop}) дочерних фреймов не гарантируется для всех
оконных систем.  Некоторые вместо этого отбрасывают объект на родительский
фрейм или на какого-то предка.
@end itemize

  Следующие две функции могут быть полезны при работе с дочерними и
родительскими фреймами:

@defun frame-parent &optional frame
Функция возвращает родительский фрейм @var{frame}.  Родительский фрейм
@var{frame} - это фрейм Emacs, окно оконной системы которого является
родительским окном окна оконной системы @var{frame}.  Если такой фрейм
существует, @var{frame} считается его дочерним фреймом.

Функция возвращает @code{nil}, если @var{frame} не имеет родительского
фрейма.
@end defun

@defun frame-ancestor-p ancestor descendant
Функция возвращает не-@code{nil}, если @var{ancestor} является предком
@var{descendant}.  @var{ancestor} является предком @var{descendant}, если он
является либо родительским фреймом @var{descendant}, либо предком
родительского фрейма @var{descendant}.  Оба параметра @var{ancestor} и
@var{descendant} должны указывать активные фреймы.
@end defun

Обратить внимание на функцию @code{window-largest-empty-rectangle}
(@pxref{Coordinates and Windows}), которую можно использовать для вписывания
дочернего фрейма в самую большую пустую область существующего окна.  Это
может быть полезно, чтобы дочерний фрейм не заслонял любой текст,
отображаемый в этом окне.

Настройка следующего параметра может быть полезна для настройки поведения
@code{iconify-frame} для дочерних фреймов.

@defopt iconify-child-frame
Опция сообщает Emacs, как действовать, когда его просят обозначить дочерний
фрейм иконкой.  Если установлено в @code{nil}, @code{iconify-frame}, ничего
не будет делать при вызове в дочернем фрейме.  Если установлено в
@code{iconify-top-level}, Emacs вместо этого попытается минимальным фрейм
верхнего уровня, который является предком этого дочернего фрейма.  Если
установлено в @code{make-invisible}, Emacs попытается сделать этот дочерний
фрейм невидимым вместо того, чтобы пометить его значком.

Любое другое значение означает попытку обозначить дочерний фрейм значком.
Так как такая попытка может быть реализована не всеми оконными менеджерами и
даже может привести к тому, что дочерний фрейм не будет реагировать на
действия пользователя, по умолчанию вместо этого фрейм верхнего уровня будет
обозначаться пиктограммой.
@end defopt


@node Mouse Tracking
@section Отслеживание Мыши
@cindex mouse tracking
@c @cindex отслеживание мышки Дубликат track-mouse

  Иногда полезно @dfn{отслеживание} мыши, что означает отображение
чего-либо, чтобы указать, где находится мышь, и перемещать индикатор по мере
движения мыши.  Для эффективного отслеживания мыши нужен способ подождать,
пока мышь действительно начнёт перемещение.

  Удобный способ отслеживания мыши - запрашивать события, представляющие
движение мыши.  Затем можно дождаться движения, дождавшись события.  Кроме
того, можно легко справиться с любыми другими событиями, которые могут
произойти.  Это полезно, потому что обычно не требуется постоянно
отслеживать мышь - только до какого-либо другого события, например,
отпускания кнопки.

@defmac track-mouse body@dots{}
Макрос выполняет @var{body} с включенной генерацией событий движения мыши.
Обычно @var{body} использует @code{read-event} для чтения событий движения
и соответствующего изменения отображения.  @xref{Motion Events}, для формата
событий движения мыши.

Значение @code{track-mouse} - это значение последней формы в @var{body}.
Потребуется спроектировать @var{body} так, чтобы происходил возврат, когда
наблюдается событие up, которое указывает на отпускание кнопки, или любое
другое событие, означающее, что пора прекратить отслеживание.

Форма @code{track-mouse} заставляет Emacs генерировать события движения мыши
путем привязки переменной @code{track-mouse} к значению не-@code{nil}.  Если
эта переменная имеет специальное значение @code{dragging}, она дополнительно
указывает механизму отображения воздерживаться от изменения формы указателя
мыши.  Это желательно в программах Lisp, которые требуют перетаскивания
мышью через большие части дисплея Emacs, что в противном случае могло бы
вызвать изменение формы указателя мыши в соответствии с частью дисплея, на
которой он наведен на (@pxref{Pointer Shape}).  Поэтому программы Lisp,
которым требуется, чтобы указатель мыши сохранял свою исходную форму во
время перетаскивания, должны привязать @code{track-mouse} к значению
@code{dragging} в начале их @var{body}.
@end defmac

Обычная цель отслеживания движения мыши - указать на экране последствия
нажатия или отпускания кнопки в текущей позиции.

Во многих случаях можно избежать необходимости отслеживать мышь, используя
текстовое свойство @code{mouse-face} (@pxref{Special Properties}).  Это
работает на гораздо более низком уровне и работает более плавно, чем
отслеживание мыши на уровне Lisp.

@ignore
@c Они еще не реализованы.

Эти функции мгновенно изменяют внешний вид экрана.  Эффект временный, только
до следующего обычного повторного отображения Emacs.  OK для отслеживания
мыши, поскольку для отслеживания мыши не имеет смысла изменять текст, а
тело @code{track-mouse} обычно считывает события само и не выполняет
повторное отображение.

@defun x-contour-region window beg end
Функция рисует линии, образуя контур вокруг текста от @var{beg} до @var{end}
в окне @var{window}.
@end defun

@defun x-uncontour-region window beg end
Функция стирает строки, которые образовывали бы контур вокруг текста от
@var{beg} до @var{end}, в окне @var{window}.  Использовать, чтобы удалить
 контур, который сделан ранее, вызвав @code{x-contour-region}.
@end defun

@defun x-draw-rectangle frame left top right bottom
Функция рисует полый прямоугольник на кадре @var{frame} с указанными
координатами края, все они измеряются в пикселях от внутреннего верхнего
левого угла.  Используется цвет курсора, который используется для указания
 местоположения точки.
@end defun

@defun x-erase-rectangle frame left top right bottom
Функция стирает полый прямоугольник на фрейме @var{frame} с указанными
координатами края, все измеряются в пикселях от внутреннего верхнего левого
угла.  Стирание означает перерисовку текста и фона, которые обычно
 принадлежат указанному прямоугольнику.
@end defun
@end ignore

@node Mouse Position
@section Положение Мыши
@cindex mouse position
@cindex position of mouse

  Функции @code{mouse-position} и @code{set-mouse-position} дают доступ к
текущему положению мыши.

@defun mouse-position
Функция возвращает описание положения мыши.  Значение выглядит как
@code{(@var{frame} @var{x} . @var{y})}, где @var{x} и @var{y} - целые числа,
дающие (возможно, округленное) положение, кратное размеру символа по
умолчанию @var{frame} (@pxref{Frame Font}) относительно исходного положения
@var{frame} (@pxref{Frame Geometry}).
@end defun

@defvar mouse-position-function
Если не-@code{nil}, значение этой переменной является функцией для вызова
@code{mouse-position}.  @code{mouse-position} вызывает эту функцию
непосредственно перед возвратом с ее обычным возвращаемым значением в
качестве единственного аргумента и возвращает все, что ей возвращает эта
функция.

Этот ненормальный перехватчик существует для таких пакетов, как
@file{xt-mouse.el}, которым необходимо обрабатывать мышь на уровне Lisp.
@end defvar

@defun set-mouse-position frame x y
Функция @dfn{деформирует мышь} в позиции @var{x}, @var{y} в фрейме
@var{frame}.  Аргументы @var{x} и @var{y} являются целыми числами, задающими
позицию, кратную размеру символа по умолчанию @var{frame}
(@pxref{Frame Font}), относительно исходной позиции @var{frame}
(@pxref{Frame Geometry}).

Результирующая позиция мыши ограничена собственным фреймом @var{frame}.
Если @var{frame} не отображается, эта функция ничего не делает.
Возвращаемое значение не имеет значения.
@end defun

@defun mouse-pixel-position
Функция похожа на @code{mouse-position}, за исключением того, что она
возвращает координаты в пикселях, а не в символах.
@end defun

@defun set-mouse-pixel-position frame x y
Функция искажает мышь, как @code{set-mouse-position}, за исключением того,
что @var{x} и @var{y} выражается в единицах пикселей, а не в единицах
символов.

Результирующая позиция мыши не ограничивается собственным фреймом
@var{frame}.  Если @var{frame} не отображается, эта функция ничего не
делает.  Возвращаемое значение не имеет значения.
@end defun

На графическом терминале следующие две функции позволяют получить и
установить абсолютное положение курсора мыши.

@defun mouse-absolute-pixel-position
Функция возвращает cons-ячейку (@var{x} . @var{y}) координат позиции курсора
мыши в пикселях относительно позиции (0, 0) отображения выбранного фрейма.
@end defun

@defun set-mouse-absolute-pixel-position x y
Функция перемещает курсор мыши в позицию (@var{x}, @var{y}).  Координаты
@var{x} и @var{y} интерпретируются в пикселях относительно позиции (0, 0)
отображения выбранного фрейма.
@end defun

Следующая функция может определить, виден ли в данный момент курсор мыши на
фрейме:

@defun frame-pointer-visible-p &optional frame
Функция-предикат возвращает не-@code{nil}, если указатель мыши, отображаемый
на @var{frame}, виден; в противном случае возвращается @code{nil}.
@var{frame} опущено или @code{nil} означает выбранный фрейм.  Это полезно,
когда для @code{make-pointer-invisible} установлено значение @code{t}: это
позволяет узнать, был ли скрыт указатель.
@xref{Mouse Avoidance,,,emacs, The Emacs Manual}.
@end defun

@need 3000

@node Pop-Up Menus
@section Pop-Up Меню
@cindex menus, popup

  Программа Lisp может вызывать всплывающее меню, чтобы пользователь мог
выбрать альтернативу с помощью мыши.  В текстовом терминале, если мышь
недоступна, пользователь может выбрать альтернативу, используя клавиши
движения клавиатуры --- @kbd{C-n}, @kbd{C-p} или up- и down-arrow.

@defun x-popup-menu position menu
Функция отображает всплывающее меню и возвращает информацию о том, какой
выбор делает пользователь.

Аргумент @var{position} указывает, где на экране разместить левый верхний
угол меню.  Это может быть либо событие кнопки мыши (которое говорит, что
нужно поместить меню, в которое пользователь нажал кнопку), либо список
такой формы:

@example
((@var{xoffset} @var{yoffset}) @var{window})
@end example

@noindent
где @var{xoffset} и @var{yoffset} - координаты в пикселях, отсчитываемые от
верхнего левого угла @var{window}.  @var{window} может быть окном или
фреймом.

Если @var{position} - @code{t}, это означает использование текущего
положения мыши (или верхнего левого угла фрейма, если мышь недоступна в
текстовом терминале).  Если @var{position} - @code{nil}, это означает
предварительное вычисление эквивалентов привязки ключей для ключевой карты,
указанных в @var{menu}, без фактического отображения или всплывающего меню.

Аргумент @var{menu} говорит, что отображать в меню.  Это может быть ключевая
карта или список карт (@pxref{Menu Keymaps}).  В этом случае возвращаемое
значение - это список событий, соответствующих выбору пользователя.  В этом
списке более одного элемента, если выбор произошел в подменю. (Обратить
внимание, что @code{x-popup-menu} фактически не выполняет команду, связанную
с этой последовательностью событий.).  В текстовых терминалах и
инструментах, поддерживающих заголовки меню, заголовок берется из строки
приглашения @var{menu}, если @var{menu} - это карта, или из строки
приглашения первая карта в @var{menu}, если это список карт
(@pxref{Defining Menus}).

В качестве альтернативы @var{menu} может иметь следующий вид:

@example
(@var{title} @var{pane1} @var{pane2}...)
@end example

@noindent
где каждая панель представляет собой список формы

@example
(@var{title} @var{item1} @var{item2}...)
@end example

Каждый @var{item} должен быть cons-ячейкой,
@code{(@var{line} . @var{value})}, где @var{line} - строка, а @var{value} -
значение, которое нужно вернуть, если выбран эта @var{line}.  В отличие от
карты меню,  @var{value} в @code{nil} не делает пункт меню недоступным для
выбора.  В качестве альтернативы каждый @var{item} может быть строкой, а не
cons-ячейкой; это делает пункт меню недоступным для выбора.

Если пользователь избавляется от меню, не сделав правильного выбора,
например, щелкнув мышью вдали от действительного выбора или набрав
@kbd{C-g}, то это обычно приводит к выходу, и @code{x-popup-menu} ничего не
возвращает.  Но если @var{position} - это событие кнопки мыши (указывающее,
что пользователь вызвал меню с помощью мыши), тогда выхода не происходит, и
@code{x-popup-menu} возвращает @code{nil}.
@end defun

  @strong{Примечание об использовании:} Не использовать @code{x-popup-menu}
для отображения меню, если можно выполнить работу с префиксным ключом,
определенным с помощью карты меню.  Если используется раскладка меню для
реализации меню, @kbd{C-h c} and @kbd{C-h a} может видеть отдельные элементы
в этом меню и предоставлять для них справку.  Если вместо этого реализуется
меню, определяя команду, которая вызывает @code{x-popup-menu}, средства
справки не могут знать, что происходит внутри этой команды, поэтому они не
могут предоставить никакой помощи по элементам меню.

  Механизм панели меню, который позволяет переключаться между подменю,
перемещая мышь, не может заглянуть в определение команды, чтобы увидеть, что
вызывает @code{x-popup-menu}.  Следовательно, если попытаться реализовать
подменю с помощью @code{x-popup-menu}, оно не сможет работать со строкой
меню интегрированным образом.  Вот почему все подменю строки меню
реализованы с помощью карт меню внутри родительского меню, а не
@code{x-popup-menu}.  @xref{Menu Bar}.

  Если требуется, чтобы строка подменю содержала разное содержимое, все
равно нужно использовать карту меню для реализации этого.  Чтобы содержимое
изменялось, добавляется в @code{menu-bar-update-hook} функция перехвата,
чтобы при необходимости обновить содержимое карты меню.

@node Dialog Boxes
@section Диалоговые Окна
@cindex dialog boxes

  Диалоговое окно - это вариант всплывающего меню - оно выглядит немного
иначе, всегда появляется в центре фрейма и имеет только один уровень и одну
или несколько кнопок.  В основном диалоговые окна используются для того,
чтобы задавать вопросы, на которые пользователь может ответить с помощью
``да'', ``нет'' и некоторых других альтернатив.  С помощью одной кнопки
также можно пользователю подтвердить важную информацию.  Функции
@code{y-or-n-p} и @code{yes-or-no-p} используют диалоговые окна вместо
ключей, когда вызываются из команд, вызываемые щелчком мыши.

@defun x-popup-dialog position contents &optional header
Функция отображает всплывающее диалоговое окно и возвращает информацию о
том, какой выбор делает пользователь.  Аргумент @var{contents} указывает
предлагаемые альтернативы и имеет такой формат:

@example
(@var{title} (@var{string} . @var{value})@dots{})
@end example

@noindent
который выглядит как список, определяющий единственную панель для
@code{x-popup-menu}.

Возвращаемое значение - @var{value} из выбранной альтернативы.

Что касается @code{x-popup-menu}, элемент списка может быть просто строкой
вместо cons-ячейки @code{(@var{string} . @var{value})}.  Это делает окно,
которое нельзя выбрать.

Если в списке появляется @code{nil}, отделяются левые элементы от правых;
элементы, предшествующие @code{nil}, отображаются слева, а элементы,
следующие за @code{nil}, отображаются справа.  Если не включить @code{nil} в
список, то примерно половина элементов появится с каждой стороны.

Диалоговые окна всегда появляются в центре фрейма; аргумент @var{position}
указывает, какой фрейм.  Возможные значения такие же, как в
@code{x-popup-menu}, но точные координаты или отдельное окно здесь не имеют
значения; имеет значение только фрейм.

Если @var{header} - не-@code{nil}, заголовок фрейма для блока -
@samp{Information}, в противном случае - @samp{Question}.  Первый
используется для @code{message-box} (@pxref{message-box}).  (В текстовых
терминалах заголовок поля не отображается.)

В некоторых конфигурациях Emacs не может отображать настоящее диалоговое
окно; поэтому вместо этого он отображает те же элементы во всплывающем меню
в центре фрейма.

Если пользователь избавляется от диалогового окна, не сделав правильного
выбора, например, с помощью оконного менеджера, то это вызывает выход, и
@code{x-popup-dialog} не возвращается.
@end defun

@node Pointer Shape
@section Форма Указателя
@cindex pointer shape
@cindex mouse pointer shape

  Можно указать стиль указателя мыши для определенного текста или
изображений, используя свойство текста @code{pointer}, а также для
изображений со свойствами изображения @code{:pointer} и @code{:map}.  В этих
свойствах можно использовать значения @code{text} (или @code{nil}),
@code{arrow}, @code{hand}, @code{vdrag}, @code{hdrag}, @code{modeline} и
@code{hourglass}.  @code{text} обозначает обычный стиль указателя мыши,
используемый над текстом.

  Над пустыми частями окна (частями, которые не соответствуют какому-либо
содержимому буфера) указатель мыши обычно использует стиль @code{arrow}, но
можно указать другой стиль (один из указанных выше), установив
@code{void-text-area-pointer}.

@defopt void-text-area-pointer
Переменная определяет стиль указателя мыши для пустых текстовых областей.  К
ним относятся области после конца строки или ниже последней строки в буфере.
По умолчанию используется стиль указателя @code{arrow} (нетекстовый).
@end defopt

  При использовании X можно указать, как действительно выглядит стиль
указателя @code{text}, установив переменную @code{x-pointer-shape}.

@defvar x-pointer-shape
Переменная определяет форму указателя, которая обычно используется во фрейме
Emacs для стиля указателя @code{text}.
@end defvar

@defvar x-sensitive-text-pointer-shape
Переменная определяет форму указателя, используемую при наведении указателя
мыши на чувствительный к мыши текст.
@end defvar

  Переменные влияют на вновь созданные фреймы.  Обычно не влияют на
существующие фреймы; однако, если установить цвет мыши для фрейма, это также
установит текущее значение этих двух переменных.
@xref{Font and Color Parameters}.

  Значения, которые можно использовать для указания любой из этих форм
указателя, определены в файле @file{lisp/term/x-win.el}.  Использовать
@kbd{M-x apropos @key{RET} x-pointer @key{RET}}, чтобы увидеть их список.

@node Window System Selections
@section Выбор Оконной Системы
@cindex selection (for window systems)
@cindex clipboard
@cindex primary selection
@cindex secondary selection

  В оконных системах, таких как X, данные могут передаваться между
различными приложениями с помощью @dfn{выбора}.  X определяет произвольное
количество @dfn{выбираемых типов}, каждый из которых может хранить свои
собственные данные; однако обычно используются только три:
@dfn{буфер обмена}, @dfn{первичный отбор} и @dfn{вторичный отбор}.  Другие
оконные системы поддерживают только буфер обмена.
@xref{Cut and Paste,, Cut and Paste, emacs, The GNU Emacs Manual}, для
команд Emacs, которые используют этот выбор.  В этом разделе описаны
низкоуровневые функции для чтения и настройки выбора оконной системы.

@deffn Command gui-set-selection type data
Функция устанавливает выбор оконной системы.  Принимает два аргумента: тип
выбора @var{type} и значение, которое ему нужно присвоить, @var{data}.

@var{type} должен быть символом; обычно это один из @code{PRIMARY},
@code{SECONDARY} или @code{CLIPBOARD}.  Это символы с именами в верхнем
регистре в соответствии с соглашениями системы X Window.  Если @var{type}
равен @code{nil}, это означает @code{PRIMARY}.

Если @var{data} равен @code{nil}, это означает очистить выделение.  В
противном случае @var{data} может быть строкой, символом, целым числом (или
cons-ячейкой двух целых чисел или списком из двух целых чисел), наложением
или cons-ячейкой двух маркеров, указывающих на один и тот же буфер.
Наложение или пара маркеров обозначают текст в наложении или между
маркерами.  Аргумент @var{data} также может быть вектором допустимых
значений выбора.

Функция возвращает @var{data}.
@end deffn

@defun gui-get-selection &optional type data-type
Функция обращается к выборкам, установленным Emacs или другими программами.
Принимает два необязательных аргумента @var{type} и @var{data-type}.  По
умолчанию для @var{type}, типа выбора, используется @code{PRIMARY}.

Аргумент @var{data-type} определяет форму преобразования данных для
использования при преобразовании необработанных данных, полученных из другой
программы, в данные Lisp.  Значимые значения включают @code{TEXT},
@code{STRING}, @code{UTF8_STRING}, @code{TARGETS}, @code{LENGTH},
@code{DELETE}, @code{FILE_NAME}, @code{CHARACTER_POSITION}, @code{NAME},
@code{LINE_NUMBER}, @code{COLUMN_NUMBER}, @code{OWNER_OS}, @code{HOST_NAME},
@code{USER}, @code{CLASS}, @code{ATOM} и @code{INTEGER}.  (Это символы с
именами в верхнем регистре в соответствии с соглашениями X.).  По умолчанию
для @var{data-type} используется @code{STRING}.  Оконные системы, отличные
от X, обычно поддерживают лишь небольшое подмножество этих типов помимо
@code{STRING}.
@end defun

@defopt selection-coding-system
Переменная определяет систему кодирования, используемую при чтении и записи
выделенных фрагментов или буфера обмена.  @xref{Coding Systems}.  По
умолчанию используется @code{compound-text-with-extensions}, который
преобразуется в текстовое представление, которое обычно использует X11.
@end defopt

@cindex clipboard support (for MS-Windows)
Когда Emacs работает в MS-Windows, он вообще не реализует выбор X, но
поддерживает буфер обмена.  @code{gui-get-selection} и
@code{gui-set-selection} в MS-Windows поддерживает только текстовый тип
данных; если буфер обмена содержит другие типы данных, Emacs считает буфер
обмена пустым.  Поддерживаемый тип данных - @code{STRING}.

Для обратной совместимости существуют устаревшие псевдонимы
@code{x-get-selection} и @code{x-set-selection}, которые были именами
@code{gui-get-selection} и @code{gui-set-selection} до Emacs 25.1.

@node Drag and Drop
@section Перетащить и Отпустить
@cindex drag and drop

@vindex x-dnd-test-function
@vindex x-dnd-known-types
  Когда пользователь перетаскивает что-то из другого приложения через Emacs,
это другое приложение ожидает, что Emacs сообщит, может ли Emacs обработать
перетаскиваемые данные.  Переменная @code{x-dnd-test-function} используется
Emacs для определения ответа.  Значение по умолчанию -
@code{x-dnd-default-test-function}, которое допускает отбрасывание, если тип
удаляемых данных присутствует в @code{x-dnd-known-types}.  Можно настроить
@code{x-dnd-test-function} и/или @code{x-dnd-known-types}, если требуется,
чтобы Emacs принимал или отклонял отбрасывание на основе других критериев.

@vindex x-dnd-types-alist
  Если требуется изменить способ обработки Emacs сброса различных типов или
добавить новый тип, настраивается @code{x-dnd-types-alist}.  Для этого
требуется детальное знание того, какие типы используют для перетаскивания
другие приложения.

@vindex dnd-protocol-alist
  Когда URL-адрес отбрасывается в Emacs, это может быть файл, но это также
может быть URL-адрес другого типа (ftp, http и тому подобное).  Emacs
сначала проверяет @code{dnd-protocol-alist}, чтобы определить, что делать с
URL@.  Если там нет совпадений и если @code{browse-url-browser-function} -
это список, Emacs ищет там совпадение.  Если совпадений не найдено,
вставляется текст URL.  Если требуется изменить поведение Emacs, можно
настроить эти переменные.

@node Color Names
@section Названия Цвета

@cindex color names
@cindex specify color
@cindex numerical RGB color specification
  Название цвета - это текст (обычно в строке), определяющий цвет.
Допускаются символьные имена, такие как @samp{black}, @samp{white},
@samp{red} и так далее; используется @kbd{M-x list-colors-display}, чтобы
увидеть список определенных имен.  Также можно указать цвета численно в
таких формах, как @samp{#@var{rgb}} и @samp{RGB:@var{r}/@var{g}/@var{b}},
где @var{r} указывает уровень красного, @var{g} указывает уровень зеленого,
а @var{b} указывает уровень синего.  Можно использовать одну, две, три или
четыре шестнадцатеричных цифры для @var{r}; тогда потребуется использовать
одинаковое количество шестнадцатеричных цифр для всех @var{g} и @var{b},
сделав всего 3, 6, 9 или 12 шестнадцатеричных цифр.  (Смотреть документацию
системы X Window для получения более подробной информации о числовой
спецификации цветов RGB.)

  Функции позволяют определить допустимые названия цветов и их внешний вид.
В некоторых случаях значение зависит от @dfn{выбранного фрейма}, как описано
ниже; смотреть @ref{Input Focus}, чтобы узнать значение термина
``выбранный фрейм''.

  Чтобы прочитать вводимые пользователем названия цветов с завершением,
использовать @code{read-color} (@pxref{High-Level Completion, read-color}).

@defun color-defined-p color &optional frame
Функция сообщает, имеет ли значение название цвета.  Если это так,
возвращает @code{t}; в противном случае @code{nil}.  Аргумент @var{frame}
указывает, какой фрейм интересует; если @var{frame} опущен или @code{nil},
используется выбранный фрейм.

Обратить внимание, что это не говорит, действительно ли используемый
дисплей поддерживает этот цвет.  При использовании X можно запросить любой
определенный цвет на любом типе дисплея, и получить какой-то результат -
обычно самый близкий из возможных.  Чтобы определить, действительно ли фрейм
может отображать определенный цвет, используется @code{color-supported-p}
(смотреть ниже).

@findex x-color-defined-p
Раньше функция называлась @code{x-color-defined-p}, и это имя все еще
поддерживается как псевдоним.
@end defun

@defun defined-colors &optional frame
Функция возвращает список названий цветов, которые определены и
поддерживаются фреймом @var{frame} (по умолчанию, выбранный фрейм).  Если
@var{frame} не поддерживает цвета, используется значение @code{nil}.

@findex x-defined-colors
Раньше функция называлась @code{x-defined-colors}, и это имя все еще
поддерживается как псевдоним.
@end defun

@defun color-supported-p color &optional frame background-p
Возвращает @code{t}, если @var{frame} действительно может отображать цвет
@var{color} (или, по крайней мере, что-то близкое к нему).  Если @var{frame}
опущено или @code{nil}, вопрос относится к выбранному фрейму.

Некоторые терминалы поддерживают другой набор цветов для переднего плана и
фона.  Если @var{background-p} равен не-@code{nil}, это означает, что
спрашивается, можно ли использовать @var{color} в качестве фона; в противном
случае спрашивается, можно ли его использовать в качестве переднего плана.

Аргумент @var{color} должен быть допустимым именем цвета.
@end defun

@defun color-gray-p color &optional frame
Возвращает @code{t}, если @var{color} является оттенком серого, как
определено на дисплее @var{frame}.  Если @var{frame} опущено или @code{nil},
вопрос относится к выбранному фрейму.  Если @var{color} не является
допустимым именем цвета, функция возвращает @code{nil}.
@end defun

@defun color-values color &optional frame
@cindex rgb value
Функция возвращает значение, описывающее, как @var{color} должен в идеале
выглядеть на @var{frame}.  Если задан @var{color}, значение представляет
собой список из трех целых чисел, которые задают количество красного,
зеленого и синего.  Каждое целое число находится в диапазоне от 0 до 65535,
но некоторые дисплеи могут не использовать весь диапазон.  Этот список из
трех элементов называется @dfn{значениями rgb} цвета.

Если @var{color} не определен, используется значение @code{nil}.

@example
(color-values "black")
     @result{} (0 0 0)
(color-values "white")
     @result{} (65280 65280 65280)
(color-values "red")
     @result{} (65280 0 0)
(color-values "pink")
     @result{} (65280 49152 51968)
(color-values "hungry")
     @result{} nil
@end example

Значения цвета возвращаются для отображения @var{frame}.  Если @var{frame}
опущен или @code{nil}, информация возвращается для отображения выбранного
фрейма.  Если фрейм не может отображать цвета, используется значение
@code{nil}.

@findex x-color-values
Раньше функция называлась @code{x-color-values}, и это имя все еще
поддерживается как псевдоним.
@end defun

@node Text Terminal Colors
@section Цвета Текстовых Терминалов
@cindex colors on text terminals

  Текстовые терминалы обычно поддерживают только небольшое количество
цветов, а компьютер использует маленькие целые числа для выбора цветов на
терминале.  Это означает, что компьютер не может достоверно определить, как
выглядит выбранный цвет; вместо этого потребуется сообщить своему
приложению, какие маленькие целые числа каким цветам соответствуют.  Однако
Emacs знает стандартный набор цветов и будет пытаться использовать их
автоматически.

  Функции, описанные в этом разделе, управляют тем, как Emacs использует
цвета терминала.

  Некоторые из этих функций используют или возвращают @dfn{значения rgb},
как описано в @ref{Color Names}.

  Эти функции принимают отображение (либо фрейм, либо имя терминала) в
качестве необязательного аргумента.  Есть надежда, что в будущем Emacs будет
поддерживать разные цвета на разных текстовых терминалах; тогда этот
аргумент будет указывать, с каким терминалом работать (по умолчанию это
терминал выбранного фрейма; @pxref{Input Focus}).  Однако в настоящее время
аргумент @var{frame} не действует.

@defun tty-color-define name number &optional rgb frame
Функция связывает название цвета @var{name} с номером цвета @var{number} на
терминале.

Необязательный аргумент @var{rgb}, если указан, является значением rgb,
списком из трех чисел, которые определяют, как на самом деле выглядит цвет.
Если не указать @var{rgb}, тогда @code{tty-color-approximate} не сможет
использовать этот цвет для аппроксимации других цветов, потому что Emacs не
будет знать, как он выглядит.
@end defun

@defun tty-color-clear &optional frame
Эта функция очищает таблицу определенных цветов для текстового терминала.
@end defun

@defun tty-color-alist &optional frame
Функция возвращает список с известными цветами, поддерживаемыми текстовым
терминалом.

Каждый элемент имеет вид @code{(@var{name} @var{number} . @var{rgb})} или
@code{(@var{name} @var{number})}.  Здесь @var{name} - это название цвета,
@var{number} - это номер, используемый для его указания терминала.  Если
присутствует, @var{rgb} - это список из трех значений цвета (для красного,
зеленого и синего), которые определяют, как на самом деле выглядит цвет.
@end defun

@defun tty-color-approximate rgb &optional frame
Функция находит самый близкий цвет среди известных цветов, поддерживаемых
для @var{display}, к цвету, описанному значением rgb @var{rgb} (список
значений цвета).  Возвращаемое значение - это элемент
@code{tty-color-alist}.
@end defun

@defun tty-color-translate color &optional frame
Функция находит ближайший к @var{color} цвет среди известных цветов,
поддерживаемых для @var{display}, и возвращает его индекс (целое число).
Если имя @var{color} не определено, используется значение @code{nil}.
@end defun

@node Resources
@section X Ресурсы

В этом разделе описаны некоторые функции и переменные для запроса и
использования ресурсов X или их эквивалентов в операционной системе.
@xref{X Resources,, X Resources, emacs, The GNU Emacs Manual}, для получения
дополнительной информации о X-ресурсах.

@defun x-get-resource attribute class &optional component subclass
Функция @code{x-get-resource} извлекает значение ресурса из базы данных
X Window по умолчанию.

Ресурсы индексируются комбинацией @dfn{ключ} и @dfn{класс}.  Функция
выполняет поиск, используя ключ вида @samp{@var{instance}.@var{attribute}}
(где @var{instance} - это имя, под которым был вызван Emacs), и используя
@samp{Emacs.@var{class}} в качестве класса.

Необязательные аргументы @var{component} и @var{subclass} добавляются к
ключу и классу соответственно.  Потребуется указать их оба или ни один.
Если указать их, ключ будет
@samp{@var{instance}.@var{component}.@var{attribute}}, а класс
@samp{Emacs.@var{class}.@var{subclass}}.
@end defun

@defvar x-resource-class
Переменная определяет имя приложения, которое должен искать
@code{x-get-resource}.  Значение по умолчанию - @code{"Emacs"}.  Можно
исследовать ресурсы X на предмет имен других приложений, привязав эту
переменную к какой-либо другой строке вокруг вызова @code{x-get-resource}.
@end defvar

@defvar x-resource-name
Переменная определяет имя экземпляра, который должен искать
@code{x-get-resource}.  Значение по умолчанию - это имя, с которым был
вызван Emacs, или значение, указанное с помощью переключателей @samp{-name}
или @samp{-rn}.
@end defvar

Чтобы проиллюстрировать некоторые из вышеперечисленных, предположим,
что у есть строка:

@example
xterm.vt100.background: yellow
@end example

@noindent
в вашем файле ресурсов X (имя которого обычно @file{~/.Xdefaults} или
@file{~/.Xresources}).  Далее:

@example
@group
(let ((x-resource-class "XTerm") (x-resource-name "xterm"))
  (x-get-resource "vt100.background" "VT100.Background"))
     @result{} "yellow"
@end group
@group
(let ((x-resource-class "XTerm") (x-resource-name "xterm"))
  (x-get-resource "background" "VT100" "vt100" "Background"))
     @result{} "yellow"
@end group
@end example

@defvar inhibit-x-resources
Если эта переменная - не-@code{nil}, Emacs не ищет ресурсы X, а ресурсы X
не имеют никакого эффекта при создании новых фреймов.
@end defvar

@node Display Feature Testing
@section Тестирование Функций Дисплея
@cindex display feature testing

  Функции в этом разделе описывают основные возможности конкретного дисплея
Программы Lisp могут использовать их для адаптации своего поведения к
возможностям дисплея.  Например, программа, которая обычно использует
всплывающее меню, может использовать минибуфер, если всплывающие меню не
поддерживаются.

  Необязательный аргумент @var{display} в этих функциях указывает, о каком
дисплее следует задать вопрос.  Это может быть отображаемое имя, фрейм
(который обозначает дисплей, на котором находится фрейм) или @code{nil}
(который относится к отображению выбранного фрейма, @pxref{Input Focus}).

  @xref{Color Names}, @ref{Text Terminal Colors}, другие функции, чтобы
получить информацию о дисплеях.

@defun display-popup-menus-p &optional display
Функция возвращает @code{t}, если на @var{display} поддерживаются
всплывающие меню, @code{nil} если нет.  Для поддержки всплывающих меню
требуется, чтобы была доступна мышь, поскольку меню всплывает при щелчке
мышью в некоторой части дисплея Emacs.
@end defun

@defun display-graphic-p &optional display
Функция возвращает @code{t}, если @var{display} - графический дисплей,
способный отображать несколько фреймов и несколько разных шрифтов
одновременно.  Это верно для дисплеев, использующих оконную систему, такую
как X, и не верно для текстовых терминалов.
@end defun

@defun display-mouse-p &optional display
@cindex mouse, availability
Функция возвращает @code{t}, если у @var{display} есть мышь, и @code{nil},
если нет.
@end defun

@defun display-color-p &optional display
@findex x-display-color-p
Функция возвращает @code{t}, если экран цветной.  Раньше назывался
@code{x-display-color-p}, и это имя все еще поддерживается как псевдоним.
@end defun

@defun display-grayscale-p &optional display
Функция возвращает @code{t}, если экран может отображать оттенки серого.
(Все цветные дисплеи могут это сделать.)
@end defun

@defun display-supports-face-attributes-p attributes &optional display
@anchor{Display Face Attribute Testing}
Функция возвращает не-@code{nil}, если все атрибуты вида в @var{attributes}
поддерживаются (@pxref{Face Attributes}).

Определение ``поддерживаемый'' является несколько эвристическим, но в
основном означает, что вид отображения, содержащий все атрибуты в
@var{attributes}, при объединении с видом по умолчанию для отображения,
может быть представлен таким образом, чтобы

@enumerate
@item
отличается по внешнему виду от вида по умолчанию, и

@item
близок по духу к тому, что указывают атрибуты, если не совсем точен.
@end enumerate

Точка (2) подразумевает, что атрибут @code{:weight black} будет
удовлетворяться любым дисплеем, который может отображаться полужирным
шрифтом, как и @code{:foreground "yellow"}, пока может отображаться
некоторый желтоватый цвет, но @code{:slant italic} будет удовлетворять
@emph{не} при автоматической подстановке тусклого вида кодом отображения tty
для курсива.
@end defun

@defun display-selections-p &optional display
Функция возвращает @code{t}, если @var{display} поддерживает выбор.  Оконные
дисплеи обычно поддерживают выбор, но они также могут поддерживаться в
некоторых других случаях.
@end defun

@defun display-images-p &optional display
Функция возвращает @code{t}, если @var{display} может отображать
изображения.  Оконные дисплеи в принципе должны обрабатывать изображения,
но некоторые системы не поддерживают это.  На дисплее, который не
поддерживает изображения, Emacs не может отображать панель инструментов.
@end defun

@defun display-screens &optional display
Функция возвращает количество экранов, связанных с дисплеем.
@end defun

@defun display-pixel-height &optional display
Функция возвращает высоту экрана в пикселях.  На символьном терминале это
дает высоту в символах.

Для графических терминалов обратить внимание, что в настройках с несколькими
мониторами это относится к высоте пикселей для всех физических мониторов,
связанных с @var{display}.  @xref{Multiple Terminals}.
@end defun

@defun display-pixel-width &optional display
Функция возвращает ширину экрана в пикселях.  На символьном терминале дает
ширину в символах.

Для графических терминалов обратить внимание, что в настройках с несколькими
мониторами это относится к ширине в пикселях для всех физических мониторов,
связанных с @var{display}.  @xref{Multiple Terminals}.
@end defun

@defun display-mm-height &optional display
Функция возвращает высоту экрана в миллиметрах или @code{nil}, если Emacs не
может получить эту информацию.

Для графических терминалов обратить внимание, что в настройках с несколькими
мониторами это относится к высоте для всех физических мониторов, связанных с
@var{display}.  @xref{Multiple Terminals}.
@end defun

@defun display-mm-width &optional display
Функция возвращает ширину экрана в миллиметрах или @code{nil}, если Emacs не
может получить эту информацию.

Для графических терминалов обратить внимание, что в настройках с несколькими
мониторами это относится к ширине для всех физических мониторов, связанных с
@var{display}.  @xref{Multiple Terminals}.
@end defun

@defopt display-mm-dimensions-alist
Переменная позволяет пользователю указать размеры графических дисплеев,
возвращаемых @code{display-mm-height} и @code{display-mm-width}, в случае,
если система выдаёт неверные значения.
@end defopt

@cindex backing store
@defun display-backing-store &optional display
Функция возвращает возможность резервного хранилища дисплея.  Резервное
хранилище означает запись пикселей окон (и частей окон), которые не
отображаются, чтобы при экспонировании они могли отображаться очень быстро.

Значения могут быть символами @code{always}, @code{when-mapped} или
@code{not-useful}.  Функция также может возвращать @code{nil}, если вопрос
неприменим к определенному типу отображения.
@end defun

@cindex SaveUnder feature
@defun display-save-under &optional display
Функция возвращает не-@code{nil}, если дисплей поддерживает функцию
SaveUnder.  Эта функция используется всплывающими окнами для сохранения
скрытых пикселей, чтобы они могли быстро всплывать.
@end defun

@defun display-planes &optional display
Функция возвращает количество плоскостей, поддерживаемых дисплеем.  Обычно
это количество бит на пиксель.  Для дисплея tty это лог для двух из числа
поддерживаемых цветов.
@end defun

@defun display-visual-class &optional display
Функция возвращает визуальный класс для экрана.  Значение представляет собой
один из символов @code{static-gray} (ограниченное неизменное количество
оттенков серого), @code{gray-scale} (полный диапазон оттенков серого),
@code{static-color} (ограниченное, неизменное количество цветов),
@code{pseudo-color} (ограниченное количество цветов), @code{true-color}
(почти полная цветовая гамма) и @code{direct-color} (полная цветовая гамма).
@end defun

@defun display-color-cells &optional display
Функция возвращает количество цветных ячеек, поддерживаемых экраном.
@end defun

  Функции получают дополнительную информацию об используемой оконной
системе, где Emacs показывает указанный @var{display}.  (Их имена начинаются
с @code{x-} по историческим причинам.)

@defun x-server-version &optional display
Функция возвращает список номеров версий оконной системы GUI, работающей на
@var{display}, такой как X-сервер в системах GNU и Unix.  Значение
представляет собой список из трех целых чисел: номера основной и
дополнительной версии протокола и номер выпуска самого программного
обеспечения оконной системы, зависящий от дистрибьютива.  В системах GNU и
Unix это обычно версия протокола X и номер выпуска программного обеспечения
X-сервера для конкретного поставщика.  В MS-Windows это версия ОС Windows.
@end defun

@defun x-server-vendor &optional display
Функция возвращает поставщика, предоставившего программное обеспечение
оконной системы (в виде строки).  В системах GNU и Unix это действительно
означает того, кто распространяет X-сервер.  В MS-Windows это строка
идентификатора поставщика ОС Windows (Microsoft).

Когда разработчики X обозначили дистрибьюторов программного обеспечения как
``продавцы'', они продемонстрировали свое ложное предположение, что ни одна
система не может быть разработана и распространена некоммерчески.
@end defun

@ignore
@defvar x-no-window-manager
Значение этой переменной - @code{t}, если диспетчер окон X не используется.
@end defvar
@end ignore
