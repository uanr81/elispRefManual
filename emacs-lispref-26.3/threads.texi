@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 2012-2019 Free Software Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Threads
@chapter Потоки
@cindex threads
@cindex concurrency

  Emacs Lisp предоставляет ограниченную форму параллелизма,
называемую @dfn{потоки}.  Все потоки в данном экземпляре Emacs
используют одну и ту же память.  Параллелизм в Emacs Lisp -
``в основном кооперативный'', что означает, что Emacs будет
переключать выполнение между потоками только в строго
определенное время.  Однако поддержка потоков Emacs была
разработана таким образом, чтобы позже обеспечить более
детальный параллелизм, и правильные программы не должны
полагаться на совместное выполнение потоков.

  В настоящее время переключение потоков будет происходить
по явному запросу через @code{thread-yield}, при ожидании
ввода с клавиатуры или вывода процесса из асинхронных процессов
(например, во время @code{accept-process-output}) или во время
операций блокировки, связанных с потоками, таких как блокировка
мьютекса или @code{thread-join}.

  Emacs Lisp предоставляет примитивы для создания потоков и
управления ими, а также для создания и управления мьютексами и
условными переменными, полезными для синхронизации потоков.

  В то время как глобальные переменные являются общими для всех
потоков Emacs Lisp, локальные переменные такими не являются ---
динамическое связывание @code{let} является локальным.  Каждый
поток также имеет свой собственный текущий буфер
(@pxref{Current Buffer}) и свои собственные данные соответствия
(@pxref{Match Data}).

  Обратить внимание, что привязки @code{let} обрабатываются
реализацией Emacs Lisp особо.  Невозможно воспроизвести
это поведение при отвязке и перепривязке, кроме как с помощью
@code{let}.  Например, ручная реализация @code{let}, написанная
с использованием @code{unwind-protect}, не может обеспечить
привязку значений переменных к потоку.

  В случае лексических привязок (@pxref{Variable Scoping}) замыкание -
это объект, подобный любому другому в Emacs Lisp, и привязки в
замыкании используются всеми потоками, вызывающими замыкание.

@menu
* Basic Thread Functions::      Основные функции потока.
* Mutexes::                     Мьютексы обеспечивают монопольный доступ к данным.
* Condition Variables::         Межпоточные события.
@end menu

@node Basic Thread Functions
@section Основные Функции Потока

  Потоки можно создавать и ждать.  Прямой выход из потока невозможен,
но из текущего потока можно выйти неявно, и другие потоки могут
получить сигнал.

@defun make-thread function &optional name
Создать новый поток выполнения, который вызывает @var{function}.
Когда @var{function} возвращается, поток завершается.

Новый поток создается без действующих привязок локальных переменных.
Текущий буфер нового потока наследуется от текущего потока.

Можно указать @var{name}, чтобы дать имя потоку.  Имя используется
только для отладки и информационных целей; для Emacs это не имеет
значения.  Если указано @var{name}, это должна быть строка.

Функция возвращает новый поток.
@end defun

@defun threadp object
Функция возвращает @code{t}, если @var{object} представляет поток
Emacs, и @code{nil} в противном случае.
@end defun

@defun thread-join thread
Блокировать до тех пор, пока @var{thread} не завершится, или пока
текущий поток не получит сигнал.  Если @var{thread} уже завершился,
это немедленно возвращается.
@end defun

@defun thread-signal thread error-symbol data
Аналогично @code{signal} (@pxref{Signaling Errors}), но сигнал
доставляется в потоке @var{thread}.  Если текущим потоком является
@var{thread}, то он сразу вызывает @code{signal}.  В противном
случае @var{thread} получит сигнал, как только он станет текущим.
Если @var{thread} был заблокирован вызовом @code{mutex-lock},
@code{condition-wait}, или @code{thread-join}; @code{thread-signal},
разблокирует его.
@end defun

@defun thread-yield
Передать выполнение следующему исполняемому потоку.
@end defun

@defun thread-name thread
Вернуть имя @var{thread}, как указано в @code{make-thread}.
@end defun

@defun thread-live-p thread
Вернуть @code{t}, если @var{thread} жив, или @code{nil}, если нет.
Поток жив, пока его функция все еще выполняется.
@end defun

@defun thread--blocker thread
Вернуть объект, который ожидает @var{thread}.  Функция в первую
очередь предназначена для отладки, и для обозначения этого ей
присвоено имя с двойным дефисом.

Если @var{thread} заблокирован в @code{thread-join},
возвращается поток, который ожидается.

Если @var{thread} заблокирован в @code{mutex-lock}, возвращается мьютекс.

Если @var{thread} заблокирован в @code{condition-wait}, возвращается
переменная условия.

В противном случае возвращается @code{nil}.
@end defun

@defun current-thread
Вернуть текущий поток.
@end defun

@defun all-threads
Вернуть список всех живых объектов потока.
При каждом вызове возвращается новый список.
@end defun

Когда код, выполняемый потоком, сигнализирует о необработанной ошибке,
поток завершается.  Другие потоки могут получить доступ к форме ошибки,
из-за которой поток завершился, используя следующую функцию.

@defun thread-last-error
Функция возвращает последнюю форму ошибки, записанную, когда
поток завершился из-за ошибки.  Каждый поток, который завершается
ненормально, перезаписывает форму, сохраненную ошибкой предыдущего
потока, новым значением, поэтому доступ может быть только к последнему.
@end defun

@node Mutexes
@section Мьютексы

  @dfn{мьютекс} - эксклюзивная блокировка.  В любой момент ноль
или один поток могут владеть мьютексом.  Если поток пытается
получить мьютекс, а мьютекс уже принадлежит некоторому другому
потоку, то получающий поток будет блокироваться до тех пор, пока
мьютекс не станет доступным.

  Мьютексы Emacs Lisp относятся к типу @dfn{рекурсивных}, что
означает, что поток может повторно получить принадлежащий ему
мьютекс любое количество раз.  Мьютекс ведет подсчет того,
сколько раз он был получен, и каждое получение мьютекса должно
быть связано с выпуском.  Последнее освобождение потоком мьютекса
возвращает его в состояние unowned, потенциально позволяя
другому потоку получить мьютекс.

@defun mutexp object
Функция возвращает @code{t}, если @var{object} представляет
мьютекс Emacs, в противном случае - @code{nil}.
@end defun

@defun make-mutex &optional name
Создать новый мьютекс и вернуть его.  Если указано @var{name},
это имя, данное мьютексу.  Это должно быть строкой.  Имя
предназначено только для целей отладки; для Emacs это не имеет
значения.
@end defun

@defun mutex-name mutex
Вернуть имя @var{mutex}, как указано в @code{make-mutex}.
@end defun

@defun mutex-lock mutex
Это будет заблокировано до тех пор, пока этот поток не получит
@var{mutex} или пока этот поток не получит сигнал с помощью
@code{thread-signal}.  Если @var{mutex} уже принадлежит этому
потоку, он просто возвращается.
@end defun

@defun mutex-unlock mutex
Выпуск @var{mutex}.  Если @var{mutex} не принадлежит этому потоку,
это сигнализирует об ошибке.
@end defun

@defmac with-mutex mutex body@dots{}
Этот макрос - самый простой и безопасный способ оценивать формы,
удерживая мьютекс.  Получается @var{mutex}, вызывается @var{body}
и затем освобождается @var{mutex}.  Возвращается результат @var{body}.
@end defmac

@node Condition Variables
@section Переменные Состояния

  @dfn{Переменная состояния} - это способ блокировки потока до тех пор,
пока не произойдет какое-либо событие.  Поток может ждать условие
переменной, чтобы быть разбуженным, когда какой-либо другой поток
уведомит об этом условии.

  Условная переменная связана с мьютексом и, концептуально, с некоторым
условием.  Для правильной работы должен быть получен мьютекс, а затем
ожидающий поток должен выполнить цикл, проверяя условие и ожидая
условие переменной.  Например:

@example
(with-mutex mutex
  (while (not global-variable)
    (condition-wait cond-var)))
@end example

  Мьютекс обеспечивает атомарность, а цикл - надежность -
могут быть ложные уведомления.

  Точно так же мьютекс должен удерживаться перед уведомлением об условии.
Типичный и лучший подход - получить мьютекс, внести изменения, связанные
с этим условием, а затем уведомить его:

@example
(with-mutex mutex
  (setq global-variable (some-computation))
  (condition-notify cond-var))
@end example

@defun make-condition-variable mutex &optional name
Создать новую условную переменную, связанную с @var{mutex}. Если указано
@var{name}, это имя, присвоенное переменной условия.  Это должна быть
строка.  Имя предназначено только для целей отладки; для Emacs это не
имеет значения.
@end defun

@defun condition-variable-p object
Функция возвращает @code{t}, если @var{object} представляет переменную
условия, и @code{nil} в противном случае.
@end defun

@defun condition-wait cond
Подождать, пока другой поток уведомит @var{cond}, условную переменную.
Эта функция будет блокироваться до тех пор, пока условие не будет
уведомлено, или пока сигнал не будет доставлен в этот поток с помощью
@code{thread-signal}.

Вызов @code{condition-wait} без удержания мьютекса, связанного с
условием, является ошибкой.

@code{condition-wait} освобождает связанный мьютекс во время ожидания.
Это позволяет другим потокам получать мьютекс для уведомления об условии.
@end defun

@defun condition-notify cond &optional all
Уведомить условие @var{cond}.  Перед вызовом необходимо удерживать мьютекс с
условием @var{cond}.  Обычно @code{condition-notify} будит один ожидающий поток;
но если @var{all} не @code{nil}, то уведомляются все потоки,
ожидающие условие @var{cond}.

@code{condition-notify} освобождает связанный мьютекс во время ожидания.
Это позволяет другим потокам получать мьютекс для ожидания выполнения условия.
@c Зачем беспокоиться?
@end defun

@defun condition-name cond
Вернуть имя @var{cond}, переданное в @code{make-condition-variable}.
@end defun

@defun condition-mutex cond
Вернуть мьютекс, связанный с @var{cond}.  Обратить внимание, что связанный
мьютекс не может быть изменен.
@end defun
