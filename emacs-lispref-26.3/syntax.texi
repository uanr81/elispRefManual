@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2019 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Syntax Tables
@chapter Синтакс Таблицы
@cindex parsing buffer text
@cindex syntax table
@cindex text parsing

  @dfn{Синтакс таблица} определяет синтаксическую роль каждого символа в
буфере.  Это можно использовать, чтобы определить, где начинаются и
заканчиваются слова, символы и другие синтаксические конструкции.  Информация
используется многими средствами Emacs, включая режим Font Lock
(@pxref{Font Lock Mode}) и различными сложными командами перемещения
(@pxref{Motion}).

@menu
* Basics: Syntax Basics.     Основные понятия синтаксических таблиц.
* Syntax Descriptors::       Как классифицируются символы.
* Syntax Table Functions::   Как создавать, исследовать и изменять таблицы синтаксиса.
* Syntax Properties::        Переопределение синтаксиса с помощью текстовых свойств.
* Motion and Syntax::        Перемещение символов с определенным синтаксисом.
* Parsing Expressions::      Разбор сбалансированных выражений с использованием
                                 таблицы синтаксиса.
* Syntax Table Internals::   Как хранится информация таблицы синтаксиса.
* Categories::               Другой способ классификации синтаксиса символов.
@end menu

@node Syntax Basics
@section Понятия Таблицы Синтаксиса

  Таблица синтаксиса - это структура данных, которая может
использоваться для поиска @dfn{синтакс класса} и других
синтаксических свойств каждого символа.  Таблицы синтаксиса
используются программами Lisp для сканирования и перемещения
по тексту.

  Внутренне таблица синтаксиса представляет собой таблицу
символов (@pxref{Char-Tables}).  Элемент с индексом @var{c}
описывает символ с кодом @var{c}; его значение - это cons-ячейка,
которая определяет синтаксис рассматриваемого символа.
@xref{Syntax Table Internals}, подробности.  Однако вместо
использования @code{aset} и @code{aref} для изменения и
проверки содержимого таблицы синтаксиса обычно следует
использовать функции более высокого уровня @code{char-syntax} и
@code{modify-syntax-entry}, которые описаны в
@ref{Syntax Table Functions}.

@defun syntax-table-p object
Функция возвращает @code{t}, если @var{object} является
таблицей синтаксиса.
@end defun

  Каждый буфер имеет свой собственный основной режим, и каждый
основной режим имеет собственное представление о синтаксическом
классе различных символов.  Например, в режиме Lisp символ @samp{;}
начинает комментарий, но в режиме C он завершает оператор.  Для
поддержки этих вариантов таблица синтаксиса является локальной для
каждого буфера.  Обычно у каждого основного режима есть своя
собственная таблица синтаксиса, которая устанавливается во все буферы,
использующие этот режим.  Например, переменная
@code{emacs-lisp-mode-syntax-table} содержит таблицу синтаксиса,
используемую режимом Emacs Lisp, а переменная @code{c-mode-syntax-table}
содержит таблицу синтаксиса, используемую режимом C.  Изменение таблицы
синтаксиса основного режима изменяет синтаксис во всех буферах этого режима,
а также во всех буферах, впоследствии переведенных в этот режим. Иногда
несколько похожих режимов используют одну синтаксическую таблицу.
@xref{Example Major Modes}, пример, как настроить таблицу синтаксиса.

@cindex standard syntax table
@cindex inheritance, syntax table
  Таблица синтаксиса может @dfn{наследоваться} из другой таблицы
синтаксиса, которая называется её @dfn{родительская таблица синтаксиса}.
В таблице синтаксиса можно оставить класс синтаксиса некоторых символов
неопределенным, присвоив им класс синтаксиса ``наследовать''; такой символ
затем получает класс синтаксиса, указанный в родительской таблице синтаксиса
(@pxref{Syntax Class Table}).  Emacs определяет @dfn{стандартную таблицу
синтаксиса}, которая является родительской таблицей синтаксиса по умолчанию,
а также таблицей синтаксиса, используемой в режиме Fundamental.

@defun standard-syntax-table
Функция возвращает стандартную таблицу синтаксиса, которая является
таблицей синтаксиса, используемой в основном режиме.
@end defun

  Таблицы синтаксиса не используются программой чтения Emacs Lisp, которая
имеет свои собственные встроенные синтаксические правила, которые нельзя
изменить.  (Некоторые системы Lisp предоставляют способы переопределения
синтаксиса чтения, но здеся решено оставить эту функцию вне Emacs Lisp
для простоты.)

@node Syntax Descriptors
@section Дескрипторы Синтаксиса
@cindex syntax class

  @dfn{Класс синтаксиса} символа описывает его синтаксическую роль.
Каждая таблица синтаксиса определяет класс синтаксиса каждого символа.
Нет обязательной связи между классом символа в одной таблице синтаксиса
и его классом в любой другой таблице.

  Каждый синтаксический класс обозначается мнемоническим символом,
который служит именем класса, когда нужно указать класс. Обычно этот
символ-указатель часто присваивается этому классу; однако его значение
в качестве обозначения не меняется и не зависит от того, какой синтаксис
у этого символа в настоящее время.  Таким образом, @samp{\} как
символ-указатель всегда обозначает синтаксис escape-символа, независимо
от того, действительно ли символ @samp{\} имеет этот синтаксис в текущей
таблице синтаксиса.
@ifnottex
@xref{Syntax Class Table}, для списка классов синтаксиса и их обозначений.
@end ifnottex

@cindex syntax descriptor
  @dfn{Дескриптор синтаксиса} - это строка Lisp, которая описывает класс
синтаксиса и другие синтаксические свойства символа.  Если потребуется
изменить синтаксис символа, это делается путем вызова функции
@code{modify-syntax-entry} и передачи дескриптора синтаксиса в качестве
одного из ее аргументов (@pxref{Syntax Table Functions}).

  Первый символ в дескрипторе синтаксиса должен быть символом указателя
класса синтаксиса.  Второй символ, если он присутствует, указывает
соответствующий символ (например, в Lisp соответствующий символ для
@samp{(} - @samp{)}); пробел указывает на отсутствие соответствующего
символа.  Затем идут символы, определяющие дополнительные свойства
синтаксиса (@pxref{Syntax Flags}).

  Если соответствующий символ или флаги не требуются, достаточно только
одного символа (с указанием класса синтаксиса).

  Например, дескриптор синтаксиса для символа @samp{*} в режиме C - это
@code{". 23"} (то есть пунктуация, соответствующий слот символа не
используется, второй символ начала комментария, первый символ конца
комментария), а запись для @samp{\} - @samp{@w{. 14}} ( то есть пунктуация,
соответствующий слот символа не используется, первый символ начала
комментария, второй символ конца комментария).

  Emacs также определяет @dfn{необработанные дескрипторы синтаксиса}, которые
используются для описания классов синтаксиса на более низком уровне.
@xref{Syntax Table Internals}.

@menu
* Syntax Class Table::      Таблица классов синтаксиса.
* Syntax Flags::            Дополнительные флаги могут быть у
                                каждого символа.
@end menu

@node Syntax Class Table
@subsection Таблица Классов Синтаксиса
@cindex syntax class table

  Вот таблица классов синтаксиса, обозначающих их символов, их
значений и примеров их использования.

@table @asis
@item Whitespace characters: @samp{@ } or @samp{-}
Символы, отделяющие друг от друга символы и слова.  Обычно
пробельные символы не имеют другого синтаксического значения, а
несколько пробельных символов синтаксически эквивалентны одному.
Пробел, табуляция и подача формы классифицируются как пробелы почти
во всех основных режимах.

Этот синтаксический класс может быть обозначен как @w{@samp{@ }}
или @samp{-}.  Оба обозначения эквивалентны.

@item Word constituents: @samp{w}
Части слов в человеческих языках.  Обычно они используются в именах
переменных и команд в программах.  Все буквы верхнего и нижнего регистра,
а также цифры обычно являются составными частями слова.

@item Symbol constituents: @samp{_}
Дополнительные символы, используемые в именах переменных и команд
вместе с составляющими слова.  Примеры включают символы @samp{$&*+-_<>}
в режиме Lisp, которые могут быть частью имени символа, даже если они не
являются частью английских слов.  В стандарте C единственным допустимым
символом, не входящим в состав слова, является подчеркивание (@samp{_}).

@item Punctuation characters: @samp{.}
Символы, используемые как знаки препинания в человеческом языке или
используемые в языках программирования для отделения друг от друга символов.
Некоторые режимы языка программирования, такие как режим Emacs Lisp, не
содержат символов в этом классе, поскольку несколько символов, которые
не являются составляющими символа или слова, имеют другое применение.  В
других режимах языка программирования, таких как режим C, для операторов
используется синтаксис пунктуации.

@item Open parenthesis characters: @samp{(}
@itemx Close parenthesis characters: @samp{)}
Символы, используемые в разных парах для окружения предложений или выражений.
Такая группировка начинается с открывающей круглой скобки и заканчивается
закрытием.  Каждый символ открытой круглой скобки соответствует определенному
символу закрывающей скобки, и наоборот.  Обычно Emacs на мгновение указывает
соответствующую открытую скобку, когда вставляется закрывающая скобка.
@xref{Blinking}.

В человеческих языках и в коде C пары скобок - @samp{()}, @samp{[]} и @samp{@{@}}.
В Emacs Lisp разделители для списков и векторов (@samp{()} и @samp{[]})
классифицируются как символы скобок.

@item String quotes: @samp{"}
Символы, используемые для обозначения строковых констант.  Одинаковые строковые
кавычки появляются в начале и в конце строки.  Такие строки в кавычках не
распологаются.

Средства синтаксического анализа Emacs рассматривают строку как отдельный
токен.  Обычные синтаксические значения символов в строке подавляются.

В режимах Lisp есть два строковых символа кавычек: двойные кавычки (@samp{"})
и вертикальная черта (@samp{|}).  @samp{|} не используется в Emacs Lisp, но
используется в Common Lisp.  C также имеет два символа строковых кавычек:
двойные кавычки для строк и апостроф (@samp{'}) для символьных констант.

В человеческом тексте нет строковых кавычек.  Хочется, чтобы кавычки
отключили обычные синтаксические свойства других символов в кавычках.

@item Escape-syntax characters: @samp{\}
Символы, которые запускают escape-последовательность, например, в строковых
и символьных константах.  Символ @samp{\} принадлежит этому классу как в C,
так и в Lisp.  (Таким образом, в C он используется только внутри строк, но,
как выясняется, не составляет труда обращаться с ним таким образом во всем
коде C.)

Символы в этом классе считаются частью слов, если @code{words-include-escapes}
- не-@code{nil}.  @xref{Word Motion}.

@item Character quotes: @samp{/}
Символ, используемый для цитирования следующего символа, так что теряется
его обычное синтаксическое значение.  Отличается от escape-символа тем, что
затрагивается только следующий за ним символ.

Символы в этом классе считаются частью слов, если
@code{words-include-escapes} - не-@code{nil}.  @xref{Word Motion}.

Этот класс используется для обратной косой черты в режиме @TeX{}.

@item Paired delimiters: @samp{$}
Подобно символам строковых кавычек, за исключением того, что синтаксические
свойства символов между разделителями не подавляются.  В настоящее время
только режим @TeX{} использует парный разделитель --- @samp{$}, который
одновременно входит в математический режим и выходит из него.

@item Expression prefixes: @samp{'}
Символы, используемые для синтаксических операторов, которые считаются
частью выражения, если они появляются рядом с ними.  В режимах Lisp эти
символы включают апостроф, @samp{'} (используется для цитирования), запятую,
@samp{,} (используется в макросах) и @samp{#} (используется в синтаксисе
чтения для определенных типов данных).

@item Comment starters: @samp{<}
@itemx Comment enders: @samp{>}
@cindex comment syntax
Символы, используемые на разных языках для обозначения комментариев.  Текст
без комментариев. В Lisp точка с запятой (@samp{;}) начинает комментарий,
а символ новой строки или перевод формы заканчивает его.

@item Inherit standard syntax: @samp{@@}
Этот синтаксический класс не определяет конкретный синтаксис.  Указывает,
что нужно посмотреть в стандартной таблице синтаксиса, чтобы найти
синтаксис этого символа.

@item Generic comment delimiters: @samp{!}
Символы, которые начинают или заканчивают особый комментарий.  @emph{Любой}
универсальный разделитель комментариев  совпадает с @emph{любым} универсальным
разделителем комментариев , но не могут совпадать с начальным или
конечным элементом комментария; общие разделители комментариев могут совпадать
только друг с другом.

Этот синтаксический класс в первую очередь предназначен для использования
с текстовым свойством @code{syntax-table} (@pxref{Syntax Properties}).
Можно пометить любой диапазон символов как образующий комментарий, указав
первый и последний символы в свойствах range @code{syntax-table},
идентифицируя их как общие разделители комментариев.

@item Generic string delimiters: @samp{|}
Символы, которые начинают или заканчивают строку.  Этот класс отличается
от класса строковых кавычек тем, что общий @emph{любой} разделитель строк
может соответствовать любому другому универсальному разделителю строк; но
не соответствует обычным строковым кавычкам.

Этот синтаксический класс в первую очередь предназначен для использования
с текстовым свойством @code{syntax-table} (@pxref{Syntax Properties}).
Можно пометить любой диапазон символов как образующий строковую константу,
задав первый и последний символы свойств range @code{syntax-table},
идентифицируя их как общие разделители строк.
@end table

@node Syntax Flags
@subsection Флаги Синтаксиса
@cindex syntax flags

  Помимо классов, записи для символов в таблице синтаксиса могут указывать
флаги.  Есть восемь возможных флагов, представленных символами @samp{1},
@samp{2}, @samp{3}, @samp{4}, @samp{b}, @samp{c}, @samp{n} и @samp{p}.

  Все флаги, кроме @samp{p}, используются для описания разделителей
комментариев.  Цифровые флаги используются для разделителей комментариев,
состоящих из 2 символов.  Они указывают, что символ @emph{также} может быть
частью последовательности комментариев в дополнение к синтаксическим
свойствам, связанным с его классом символов.  Флаги не зависят от класса
и друг от друга, так как символы, такие как @samp{*} в режиме C, являются
символом пунктуации, @emph{и} - вторым символом последовательности начала
комментария, (@samp{\*}), @emph{и} - первым символом конца строки.
последовательность комментариев (@samp{*\}).  Флаги @samp{b}, @samp{c} и
@samp{n} используются для обозначения соответствующего разделителя
комментариев.

  Вот таблица возможных флагов для символа @var{c} и их значения:

@itemize @bullet
@item
@samp{1} означает, что @var{c} - это начало двухсимвольной
последовательности начала комментария.

@item
@samp{2} означает, что @var{c} - второй символ такой последовательности.

@item
@samp{3} означает, что @var{c} - это начало двухсимвольной
последовательности конца комментария.

@item
@samp{4} означает, что @var{c} - второй символ такой последовательности.

@item
@samp{b} означает, что @var{c} как разделитель комментариев принадлежит
к альтернативному стилю комментариев ``b''.  Для двухсимвольного
начального комментария этот флаг имеет значение только для второго символа,
а для двухсимвольного завершающего комментария он имеет значение только
для первого символа.

@item
@samp{c} означает, что @var{c} как разделитель комментариев принадлежит к
альтернативному стилю комментариев ``c''.  Для двухсимвольного разделителя
комментариев, @samp{c} для любого символа делает его стилем ``c''.

@item
@samp{n} на символе разделителя комментариев указывает, что этот вид
комментария может быть вложенным.  Внутри такого комментария будут
распознаваться только комментарии одного стиля.  Для двухсимвольного
разделителя комментария @samp{n} для любого символа делает его
вкладываемым.

@cindex comment style
Emacs поддерживает несколько стилей комментариев одновременно в одной
синтаксической таблице.  Стиль комментария - это набор флагов @samp{b},
@samp{c} и @samp{n}, поэтому может быть до 8 различных стилей комментариев,
каждый из которых назван набором своих флагов.  Каждый разделитель
комментариев имеет свой стиль и соответствует только разделителям
комментариев одного стиля.  Таким образом, если комментарий начинается
с последовательности начала комментария стиля ``bn'', он будет
продолжаться до следующей соответствующей последовательности конца
комментария стиля ``bn''.  Когда в наборе флагов не установлен ни
флаг @samp{b}, ни флаг @samp{c}, результирующий стиль называется
стилем ``a''.

Соответствующие настройки синтаксиса комментариев для C ++ могут
быть следующими:

@table @asis
@item @samp{/}
@samp{124}
@item @samp{*}
@samp{23b}
@item newline
@samp{>}
@end table

Это определяет четыре последовательности, ограничивающие комментарии:

@table @asis
@item @samp{/*}
Это последовательность начала комментария для стиля ``b'', потому
что второй символ, @samp{*}, имеет флаг @samp{b}.

@item @samp{//}
Это последовательность начала комментария для стиля ``a'', потому
что второй символ, @samp{/}, не имеет флага @samp{b}.

@item @samp{*/}
Это последовательность конца комментария для стиля b '', потому что
первый символ, @samp{*}, имеет флаг @samp{b}.

@item newline
Это последовательность конца комментария для стиля ``a'', потому
что символ новой строки не имеет флага @samp{b}.
@end table

@item
@samp{p} определяет дополнительный префиксный символ для синтаксиса
Lisp.  Эти символы рассматриваются как пробелы, когда они появляются
между выражениями.  Когда они появляются в выражении, они
обрабатываются в соответствии с их обычными классами синтаксиса.

Функция @code{backward-prefix-chars} перемещается назад по этим
символам, а также по символам, основным синтаксическим классом которых
является префикс (@samp{'}).  @xref{Motion and Syntax}.
@end itemize

@node Syntax Table Functions
@section Функции Таблицы Синтаксиса

  В этом разделе описываются функции для создания, доступа и
изменения синтаксических таблиц.

@defun make-syntax-table &optional table
Эта функция создает новую таблицу синтаксиса.  Если @var{table} -
не-@code{nil}, то родителем новой таблицы синтаксиса будет @var{table};
в противном случае родительской таблицейа является стандартная
синтаксическая таблица.

В новой таблице синтаксиса всем символам изначально присвоен класс
синтаксиса ``наследовать'' (@samp{@@}), то есть их синтаксис наследуется
от родительской таблицы (@pxref{Syntax Class Table}).
@end defun

@defun copy-syntax-table &optional table
Функция создает копию @var{table} и возвращает ее.  Если @var{table}
опущено или @code{nil}, возвращается копия стандартной таблицы синтаксиса.
В противном случае выдается сообщение об ошибке, если @var{table} не
является таблицей синтаксиса.
@end defun

@deffn Command modify-syntax-entry char syntax-descriptor  &optional table
@cindex syntax entry, setting
Функция устанавливает запись синтаксиса для @var{char} в соответствии с
@var{syntax-descriptor}.  @var{char} должен быть символом или cons-ячейкой
вида @code{(@var{min} . @var{max})}; в последнем случае функция
устанавливает записи синтаксиса для всех символов в диапазоне от @var{min}
до @var{max} включительно.

Синтаксис изменяется только для @var{table}, которая по умолчанию соответствует
таблице синтаксиса текущего буфера, а не для какой-либо другой таблицы синтаксиса.

Аргумент @var{syntax-descriptor} - это дескриптор синтаксиса, то есть строка,
первый символ которой является указателем класса синтаксиса, а второй и
последующие символы могут дополнительно определять совпадающий символ и
флаги синтаксиса.  @xref{Syntax Descriptors}.  Сообщается об ошибке, если
@var{syntax-descriptor} не является допустимым дескриптором синтаксиса.

Функция всегда возвращает @code{nil}.  Старая информация о синтаксисе в
таблице для этого символа отбрасывается.

@example
@group
@exdent @r{Примеры:}

;; @r{Поместить пробел в пробел класса.}
(modify-syntax-entry ?\s " ")
     @result{} nil
@end group

@group
;; @r{Сделать @samp{$} символом открытой круглой скобки ,}
;; @r{с @samp{^} в качестве соответствующего ему символу закрывающей скобки.}
(modify-syntax-entry ?$ "(^")
     @result{} nil
@end group

@group
;; @r{Сделать @samp{^} символом закрывающей скобки ,}
;; @r{с @samp{$} в качестве соответствующего ему символу открывающей скобки.}
(modify-syntax-entry ?^ ")$")
     @result{} nil
@end group

@group
;; @r{Сделать @samp{/} знаком препинания ,}
;; @r{первый символ последовательности начало-комментария,}
;; @r{второй символ последовательности конец-комментарий.}
;; @r{Используется в режиме C.}
(modify-syntax-entry ?/ ". 14")
     @result{} nil
@end group
@end example
@end deffn

@defun char-syntax character
Функция возвращает класс синтаксиса @var{character}, представленный
его обозначением (@pxref{Syntax Class Table}).  Это @emph{только}
возвращает класс, а не соответствующий ему символ или флаги синтаксиса.

Следующие примеры относятся к режиму C.  (Используется @code{string},
чтобы упростить просмотр символа, возвращаемого @code{char-syntax}.)

@example
@group
;; Пробелы имеют класс синтаксиса пробелов.
(string (char-syntax ?\s))
     @result{} " "
@end group

@group
;; Символы прямой косой черты имеют синтаксис пунктуации.
;; Обратить внимание, что этот вызов @code{char-syntax} не показывает,
;; что он также является частью последовательности comment-start и -end.
(string (char-syntax ?/))
     @result{} "."
@end group

@group
;; Открытые круглые скобки имеют синтаксис открытых скобок.
;; Обратить внимание, что этот вызов @code{char-syntax} не показывает, что
;; имеет соответствующий символ @samp{)}.
(string (char-syntax ?\())
     @result{} "("
@end group
@end example

@end defun

@defun set-syntax-table table
Функция делает @var{table} таблицей синтаксиса для текущего буфера.
Возвращается @var{table}.
@end defun

@defun syntax-table
Функция возвращает текущую таблицу синтаксиса, которая является
таблицей для текущего буфера.
@end defun

@deffn Command describe-syntax &optional buffer
Команда отображает содержимое таблицы синтаксиса @var{buffer}
(по умолчанию текущий буфер) в буфере справки.
@end deffn

@defmac with-syntax-table table body@dots{}
Макрос выполняет @var{body} с использованием @var{table} в качестве
текущей таблицы синтаксиса.  Возвращается значение последней формы в
@var{body} после восстановления старой текущей таблицы синтаксиса.

Поскольку каждый буфер имеет свою собственную текущую таблицу
синтаксиса, потребуется уточнить это: @code{with-syntax-table}
временно изменяет текущую таблицу синтаксиса того буфера, который
является текущим на момент запуска макроса.  Другие буферы не
затрагиваются.
@end defmac

@node Syntax Properties
@section Синтаксические Свойства
@kindex syntax-table @r{(текстовое свойство)}

Если таблица синтаксиса недостаточно гибкая, чтобы указать синтаксис
языка, возможно переопределить таблицу синтаксиса для определенных
вхождений символов в буфере, применив текстовое свойство
@code{syntax-table}.  @xref{Text Properties}, как применять свойства
текста.

  Допустимые значения текстового свойства @code{syntax-table}:

@table @asis
@item @var{syntax-table}
Если значение свойства является таблицей синтаксиса, эта таблица
используется вместо таблицы синтаксиса текущего буфера для определения
синтаксиса основного текстового символа.

@item @code{(@var{syntax-code} . @var{matching-char})}
Cons-ячейка этого формата представляет собой дескриптор необработанного
синтаксиса (@pxref{Syntax Table Internals}), который напрямую определяет
класс синтаксиса для нижележащего текстового символа.

@item @code{nil}
Если свойство - @code{nil}, синтаксис символа определяется из текущей
синтаксической таблицы обычным способом.
@end table

@defvar parse-sexp-lookup-properties
Если это не-@code{nil}, функции сканирования синтаксиса, такие как
@code{forward-sexp}, обращают внимание на свойства текста
@code{syntax-table}.  В противном случае используется только текущая
таблица синтаксиса.
@end defvar

@defvar syntax-propertize-function
Эта переменная, если не-@code{nil}, хранит функцию для применения
свойств @code{syntax-table} к указанному фрагменту текста.  Предназначается
для использования основными режимами для установки функции, которая
применяет свойства @code{syntax-table} некоторым подходящим для режима
способом.

Функция вызывается @code{syntax-ppss} (@pxref{Position Parse}) и режимом
Font Lock во время синтаксической фонификации (@pxref{Syntactic Font Lock}).
Вызывается с двумя аргументами @var{start} и @var{end}, которые являются
начальной и конечной позициями текста, с которыми происходит взаимодействие.
Разрешается вызывать @code{syntax-ppss} на любую позицию до @var{end}.
Однако не должно быть вызова @code{syntax-ppss-flush-cache}; поэтому не
получиться вызывать @code{syntax-ppss} в какой-либо позиции и позже изменять
буфер в более ранней позиции.
@end defvar

@defvar syntax-propertize-extend-region-functions
Этот ненормальный перехватчик запускается кодом синтаксического анализа
до вызова @code{syntax-propertize-function}.  Его роль - помочь найти
безопасные начальные и конечные позиции буфера для перехода к
@code{syntax-propertize-function}.  Например, основной режим может
добавить к этому перехватчику функцию для идентификации многострочных
синтаксических конструкций и обеспечения того, чтобы границы не
попадали в середину одной из них.

Каждая функция в этой ловушке принимает два аргумента @var{start}
and @var{end}.  Возвращает либо cons-ячейку с двумя настроенными
положениями буфера, @code{(@var{new-start} . @var{new-end})} или
@code{nil}, если настройка не требуется.  Функции ловушки запускаются
по очереди, многократно, пока все они не вернут @code{nil}.
@end defvar

@node Motion and Syntax
@section Движение и Синтаксис
@cindex moving across syntax classes
@cindex skipping characters of certain syntax

  В этом разделе описаны функции для перемещения между символами,
имеющими определенные классы синтаксиса.

@defun skip-syntax-forward syntaxes &optional limit
Функция перемещает точку между символами, имеющими классы синтаксиса,
упомянутые в @var{syntaxes} (строка символов класса синтаксиса).
Остановка, когда встречает конец буфера, позиция @var{limit}
(если указана) или символ, который не пропускается.

Если @var{syntaxes} начинается с @samp{^}, функция пропускает
символы с @emph{не} синтаксисом @var{syntaxes}.

Возвращаемое значение - это пройденное расстояние, которое является
неотрицательным целым числом.
@end defun

@defun skip-syntax-backward syntaxes &optional limit
Функция перемещает точку назад по символам, синтаксические классы
которых упомянуты в @var{syntaxes}.  Остановка, когда встречается
начало буфера, позиция @var{limit} (если указана) или символ,
который не должен пропускаться.

Если @var{syntaxes} начинается с @samp{^}, функция пропускает символы,
синтаксис которых @emph{не} @var{syntaxes}.

Возвращаемое значение указывает пройденное  расстояние. Это целое
число, равное нулю или меньше.
@end defun

@defun backward-prefix-chars
Функция перемещает точку назад на любое количество символов с
синтаксисом префикса выражения.  Сюда входят как символы в классе
синтаксиса префикса выражения, так и символы с флагом @samp{p}.
@end defun

@node Parsing Expressions
@section Анализ Выражений
@cindex parsing expressions
@cindex scanning expressions

  В этом разделе описаны функции для синтаксического анализа и сканирования
сбалансированных выражений.  Будут называться такие выражения @dfn{sexps},
следуя терминологии Lisp, даже если эти функции могут действовать на языках,
отличных от Lisp.  По сути, sexp представляет собой сбалансированную
группировку в скобках, строку или символ (то есть последовательность символов,
синтаксис которой является составной частью слова или составляющей символа).
Однако символы в классе синтаксиса префикса выражения
(@pxref{Syntax Class Table}) обрабатываются как часть sexp, если они
появляются рядом с ним.

  Таблица синтаксиса управляет интерпретацией символов, поэтому эти функции
могут использоваться для выражений Lisp в режиме Lisp и для выражений C в
режиме C.  @xref{List Motion}, изучить удобные функций более высокого уровня
для перемещения по сбалансированным выражениям.

  Синтаксис символа управляет тем, как изменяется состояние анализатора, а
не описывает само состояние.  Например, символ-разделитель строк переключает
состояние анализатора между строкой и кодом, но синтаксис символов не указывает
напрямую, находится ли положение внутри строки.  Например (обратить внимание,
что 15 - это код синтаксиса для общих разделителей строк),

@example
(put-text-property 1 9 'syntax-table '(15 . nil))
@end example

@noindent
не сообщает Emacs, что первые восемь символов текущего буфера являются строкой,
а скорее, что все они являются разделителями строк.  В результате Emacs
обрабатывает их как четыре последовательные пустые строковые константы.

@menu
* Motion via Parsing::       Функции перемещения, работающие путем синтаксического анализа.
* Position Parse::           Определение синтаксического состояния позиции.
* Parser State::             Как Emacs представляет синтаксическое состояние.
* Low-Level Parsing::        Разбор в указанном регионе.
* Control Parsing::          Параметры, влияющие на синтаксический анализ.
@end menu

@node Motion via Parsing
@subsection Команды Движения на Основе Синтаксического Анализа
@cindex motion based on parsing

  В этом разделе описаны простые функции перемещения точки, которые
работают на основе выражений синтаксического анализа.

@defun scan-lists from count depth
Функция просматривает вперед @var{count} сбалансированные группировки
в скобках с позиции @var{from}.  Возвращается позиция остановки сканирования.
Если @var{count} отрицательный, сканирование перемещается назад.

Если @var{depth} отлично от нуля, рассматривается начальная позиция как
глубокая скобка @var{depth}.  Сканер перемещается вперед или назад через
буфер до тех пор, пока глубина не изменится до нуля @var{count} раза.
Следовательно, положительное значение @var{depth} приводит к перемещению
уровней скобок @var{depth} из начальной позиции, а отрицательное значение
@var{depth} приводит к перемещению глубже на уровни скобок @var{-depth}.

При сканировании комментарии игнорируются, если
@code{parse-sexp-ignore-comments} равен не-@code{nil}.

Если сканирование достигает начала или конца доступной части буфера до
того, как оно просканировало группировки @var{count} в скобках, возвращается
значение @code{nil}, если глубина в этой точке равна нулю; если глубина не
равна нулю, сигнализируется ошибка @code{scan-error}.
@end defun

@defun scan-sexps from count
Функция просматривает вперед @var{count} sexps от позиции @var{from}.
Возвращается позиция остановки сканирования.  Если @var{count} отрицательно,
сканирование перемещается назад.

При сканировании комментарии игнорируются, если
@code{parse-sexp-ignore-comments} равно не-@code{nil}.

Если сканирование достигает начала или конца (доступной части) буфера,
находясь в середине группировки в скобках, выдается сигнал об ошибке.
Если достигается начало или конец между группировками, но до того, как
счетчик исчерпан, возвращается @code{nil}.
@end defun

@defun forward-comment count
Функция перемещает точку вперед через полных @var{count} комментариев
(то есть включая начальный и конечный разделители, если они есть), а
также любые пробелы, встречающиеся на пути.  Перемещение назад, если
@var{count} отрицательно.  Если встречается что-либо, кроме комментария
или пробела, остановка, оставляется точка в этом месте.  Это включает
(например) поиск конца комментария при движении вперед и ожидание начала
комментария.  Функция также останавливается сразу после перехода на
указанное количество полных комментариев . Если @var{count} комментариев
найдено, как ожидалось, и между ними нет ничего, кроме пробелов,
возвращается @code{t}; в противном случае возвращается @code{nil}.

Функция не может определить, встроены ли комментарии, которые она
просматривает, в строку.  Если они выглядят как комментарии,
обрабатываются как комментарии.

Чтобы переместиться вперед по всем комментариям и пробелам после точки,
используется @code{(forward-comment (buffer-size))}. @code{(buffer-size)}
- хороший аргумент, потому что количество комментариев в буфере не может
превышать такое количество.
@end defun

@node Position Parse
@subsection Нахождение Состояния Синтаксического Анализа для Позиции
@cindex parse state for a position

  Для синтаксического анализа, например отступов, часто полезно вычислить
синтаксическое состояние, соответствующее данной позиции буфера.
Эта функция делает это удобно.

@defun syntax-ppss &optional pos
Функция возвращает состояние парсера, которого парсер достиг бы в
позиции @var{pos}, начиная с начала видимой части буфера.
@iftex
Смотреть следующий раздел для
@end iftex
@ifnottex
@xref{Parser State},
@end ifnottex
для описания состояния парсера.

Возвращаемое значение такое же, как если бы вызывалась низкоуровневая
функция синтаксического анализа @code{parse-partial-sexp} для
синтаксического анализа от начала видимой части буфера до @var{pos}
(@pxref{Low-Level Parsing}).  Однако @code{syntax-ppss} использует кеши
для ускорения вычислений.  Из-за этой оптимизации второе значение
(предыдущее полное подвыражение) и шестое значение (минимальная глубина
скобок) в возвращенном состоянии синтаксического анализатора не имеют
смысла.

У этой функции есть побочный эффект: добавление в локальный буфер запись
в @code{before-change-functions} (@pxref{Change Hooks}) для
@code{syntax-ppss-flush-cache} (смотреть ниже).  Эта запись поддерживает
согласованность кеша при изменении буфера.  Однако кеш может не обновляться,
если вызывается @code{syntax-ppss}, когда @code{before-change-functions}
временно привязан к let, или если буфер изменяется без запуска ловушки,
например, при использовании @code{inhibit-modification-hooks}.  В таких
случаях необходимо явно вызвать @code{syntax-ppss-flush-cache}.
@end defun

@defun syntax-ppss-flush-cache beg &rest ignored-args
Функция очищает кеш, используемый @code{syntax-ppss}, начиная с позиции
@var{beg}.  Остальные аргументы @var{ignored-args} игнорируются; эта функция
принимает их, так что ее можно напрямую использовать в перехватчиках, таких
как @code{before-change-functions} (@pxref{Change Hooks}).
@end defun

@node Parser State
@subsection Состояние Парсера
@cindex parser state

  @dfn{Состояние парсера} - это список (в настоящее время) одиннадцати
элементов, описывающих состояние синтаксического анализатора после того,
как он проанализирует текст между указанной начальной точкой и указанной
конечной точкой в буфере.  Функции синтаксического анализа, такие как
@code{syntax-ppss},
@ifnottex
(@pxref{Position Parse})
@end ifnottex
возвращают состояние анализатора в качестве значения.  Некоторые функции
синтаксического анализа принимают состояние анализатора в качестве
аргумента для возобновления синтаксического анализа.

  Вот значения элементов состояния парсера:

@enumerate 0
@item
Глубина в круглых скобках, считая от 0.  @strong{Предупреждение:}
это может быть отрицательным числом, если между начальной и конечной
точкой парсера больше закрытых скобок, чем открытых.

@item
@cindex innermost containing parentheses
Позиция символа начала самой внутренней группы в скобках, содержащей
точку остановки; @code{nil}, если нет.

@item
@cindex previous complete subexpression
Позиция символа начала последнего полного подвыражения завершена;
@code{nil}, если нет.

@item
@cindex inside string
не-@code{nil}, если внутри строки.  Точнее, это символ, который
завершает строку, или @code{t}, если общий символ разделителя
строки должен завершать ее.

@item
@cindex inside comment
@code{t}, если он находится внутри не вложенного комментария
(любого стиля комментария; @pxref{Syntax Flags}); или уровня
вложенности комментария, если он находится внутри комментария,
который может быть вложенным.

@item
@cindex quote character
@code{t}, если конечная точка находится сразу после символа кавычки.

@item
Минимальная глубина скобок, обнаруженная во время этого сканирования.

@item
Какой комментарий активен: @code{nil}, если не в комментарии или в
комментарии стиля @samp{a};
1 за комментарий стиля @samp{b};
2 за комментарий стиля @samp{c}; и
@code{syntax-table} для комментария, который должен заканчиваться
общим символом-разделителем комментариев.

@item
Позиция начала строки или комментария.  Находясь внутри комментария,
это позиция, с которой комментарий начинался; находясь внутри строки,
это позиция, с которой строка начиналась.  За пределами строк и
комментариев этот элемент - @code{nil}.

@item
Список позиций открытых в данный момент круглых скобок, начиная с крайних.

@item
Когда последняя просканированная позиция буфера была (потенциальным)
первым символом двухсимвольной конструкции (разделитель комментариев
или пара символов с экранированием/кавычками), @var{syntax-code}
(@pxref{Syntax Table Internals}) этой позиции.  В противном случае
@code{nil}.
@end enumerate

  Элементы 1, 2 и 6 игнорируются в состоянии, которое передается в качестве
аргумента для продолжения синтаксического анализа.  Элементы 9 и 10 в
основном используются внутри кода парсера.

  Одна дополнительная полезная информация доступна из состояния парсера
с помощью этой функции:

@defun syntax-ppss-toplevel-pos state
Эта функция извлекает из состояния синтаксического анализатора
@var{state} последнюю просканированную в синтаксическом анализе позицию,
которая находилась на верхнем уровне грамматической структуры.
``На высшем уровне'' означает вне скобок, комментариев или строк.

Значение @code{nil}, если @var{state} представляет синтаксический анализ,
который достиг позиции верхнего уровня.
@end defun

@node Low-Level Parsing
@subsection Анализ Низкого Уровня

  Самый простой способ использовать синтаксический анализатор выражений -
это указать, что должно начинаться с заданной позиции с определенным
состоянием и выполнять синтаксический анализ до указанной конечной позиции.

@defun parse-partial-sexp start limit &optional target-depth stop-before state stop-comment
Функция анализирует sexp в текущем буфере, начиная с @var{start},
не просматривая @var{limit}.  Остановка в позиции @var{limit} или при
соблюдении определенных критериев, описанных ниже, и устанавление точки
в месте, где останавливается синтаксический анализ.  Возвращается состояние
синтаксического анализатора,
@ifinfo
(@pxref{Parser State})
@end ifinfo
описывающее состояние синтаксического анализа в точке, где он остановился.

@cindex parenthesis depth
Если третий аргумент @var{target-depth} равен не-@code{nil},
синтаксический анализ останавливается, если глубина в скобках становится
равной @var{target-depth}.  Глубина начинается с 0 или с любого значения,
указанного в @var{state}.

Если четвертым аргументом @var{stop-before} является не-@code{nil},
синтаксический анализ останавливается, когда дело доходит до любого символа,
который запускает sexp.  Если @var{stop-comment} равен не-@code{nil},
синтаксический анализ останавливается после начала невложенного комментария.
Если @var{stop-comment} - это символ @code{syntax-table}, синтаксический
анализ останавливается после начала невложенного комментария или строки,
или после конца невложенного комментария или строки, в зависимости от того,
что наступит раньше.

Если @var{state} - @code{nil}, предполагается, что @var{start} находится
на верхнем уровне структуры скобок, например, в начале определения функции.
В качестве альтернативы возможно возобновить синтаксический анализ в
середине структуры.  Для этого потребуется предоставить аргумент @var{state},
который описывает начальный статус синтаксического анализа.  Подойдет значение,
возвращенное предыдущим вызовом @code{parse-partial-sexp}.
@end defun

@node Control Parsing
@subsection Параметры для Управления Парсингом
@cindex parsing, control parameters

@defvar multibyte-syntax-as-symbol
Если эта переменная - не-@code{nil}, @code{scan-sexps} обрабатывает все
символы не-@acronym{ASCII} как составляющие символа, независимо от того,
что о них говорит синтаксическая таблица.  (Однако текстовые свойства
@code{syntax-table } могут переопределять синтаксис.)
@end defvar

@defopt parse-sexp-ignore-comments
@cindex skipping comments
Если значение равно не-@code{nil}, то комментарии обрабатываются как пробел
функциями в этом разделе @code{forward-sexp}, @code{scan-lists} и
@code{scan-sexps}.
@end defopt

На поведение @code{parse-partial-sexp} также влияет
@code{parse-sexp-lookup-properties} (@pxref{Syntax Properties}).

@defvar comment-end-can-be-escaped
Если эта локальная переменная буфера - не-@code{nil}, одиночный символ,
который обычно завершает комментарий, не делает этого при экранировании
этого символа.  Это используется в режимах C и C ++, где комментарии к
строкам, начинающиеся с @samp{\\}, могут быть продолжены на следующей
строке путем экранирования новой строки с помощью @samp{\}.
@end defvar

Можно использовать @code{forward-comment} для перемещения вперед или назад
по одному или нескольким комментариям.

@node Syntax Table Internals
@section Внутреннее Устройство Таблицы Синтаксиса
@cindex syntax table internals

  Таблицы синтаксиса реализованы как таблицы символов (@pxref{Char-Tables}),
но большинство программ на Lisp не работают напрямую со своими элементами.
Таблицы синтаксиса не хранят данные синтаксиса как дескрипторы синтаксиса
(@pxref{Syntax Descriptors}); они используют внутренний формат, который
задокументирован в этом разделе.  Этот внутренний формат также может быть
назначен как свойства синтаксиса (@pxref{Syntax Properties}).

@cindex syntax code
@cindex raw syntax descriptor
  Каждая запись в таблице синтаксиса - это @dfn{raw syntax descriptor}:
cons-ячейка в форме @code{(@var{syntax-code} . @var{matching-char})}.
@var{syntax-code} - это целое число, которое кодирует класс синтаксиса и
флаги синтаксиса в соответствии с таблицей ниже.  @var{matching-char}, если
не-@code{nil}, указывает соответствующий символ (аналогично второму символу
в дескрипторе синтаксиса).

@cindex syntax tables (accessing elements of)
Использовать @code{aref} (@pxref{Array Functions}), чтобы получить
необработанный дескриптор синтаксиса символа, например
@w{@code{(aref (syntax-table) ch)}}.

  Вот коды синтаксиса, соответствующие различным классам синтаксиса:

@multitable @columnfractions .2 .3 .2 .3
@item
@i{Code} @tab @i{Class} @tab @i{Code} @tab @i{Class}
@item
0 @tab пробел @tab 8 @tab парный разделитель
@item
1 @tab пунктуация @tab 9 @tab escape
@item
2 @tab слово @tab 10 @tab цитированный символ
@item
3 @tab символ @tab 11 @tab коментарий-начало
@item
4 @tab открывающая скобка @tab 12 @tab коментарий-конец
@item
5 @tab закрывающая скобка @tab 13 @tab наследование
@item
6 @tab префикс выражения @tab 14 @tab общий комментарий
@item
7 @tab строковая цитата @tab 15 @tab общая строка
@end multitable

@noindent
Например, в стандартной таблице синтаксиса запись для @samp{(} -
@code{(4 . 41)}.  41 - это код символа для @samp{)}.

  Флаги синтаксиса кодируются в битах более высокого порядка,
начиная с 16 бит от младшего бита.  В этой таблице дана степень
двойки, соответствующая каждому флагу синтаксиса.

@multitable @columnfractions .15 .3 .15 .3
@item
@i{Prefix} @tab @i{Flag} @tab @i{Prefix} @tab @i{Flag}
@item
@samp{1} @tab @code{(lsh 1 16)} @tab @samp{p} @tab @code{(lsh 1 20)}
@item
@samp{2} @tab @code{(lsh 1 17)} @tab @samp{b} @tab @code{(lsh 1 21)}
@item
@samp{3} @tab @code{(lsh 1 18)} @tab @samp{n} @tab @code{(lsh 1 22)}
@item
@samp{4} @tab @code{(lsh 1 19)} @tab @samp{c} @tab @code{(lsh 1 23)}
@end multitable

@defun string-to-syntax desc
Учитывая дескриптор синтаксиса @var{desc} (строка), эта функция
возвращает соответствующий необработанный дескриптор синтаксиса.
@end defun

@defun syntax-after pos
Функция возвращает дескриптор необработанного синтаксиса для символа в
буфере после позиции @var{pos}, принимая во внимание свойства синтаксиса,
а также таблицу синтаксиса.  Если @var{pos} находится за пределами
доступной части буфера (@pxref{Narrowing, accessible portion}),
возвращается значение @code{nil}.
@end defun

@defun syntax-class syntax
Функция возвращает код синтаксиса для необработанного дескриптора
синтаксиса @var{syntax}.  Точнее, берётся компонент @var{syntax-code}
дескриптора необработанного синтаксиса, маскируется старшие 16 бит,
которые записывают флаги синтаксиса, и возвращается результирующее
целое число.

Если @var{syntax} - @code{nil}, возвращаемое значение - @code{nil}.
Это так, что выражение

@example
(syntax-class (syntax-after pos))
@end example

@noindent
оценивается как @code{nil}, если @code{pos} находится за пределами
доступной части буфера, без выдачи ошибок или возврата неверного кода.
@end defun

@node Categories
@section Категории
@cindex categories of characters
@cindex character categories

  @dfn{Категории} предоставляют альтернативный способ синтаксической
классификации символов.  При необходимости можно определить несколько
категорий, а затем независимо назначить каждый символ одной или
нескольким категориям.  В отличие от классов синтаксиса, категории не
исключают друг друга; принадлежность одного символа к нескольким
категориям - это нормально.

@cindex category table
  Каждый буфер имеет @dfn{таблицу категорий}, в которой записывается,
какие категории определены, а также какие символы принадлежат каждой
категории.  Каждая таблица категорий определяет свои собственные категории,
но обычно они инициализируются путем копирования из стандартной таблицы
категорий, так что стандартные категории доступны во всех режимах.

  У каждой категории есть имя, которое представляет собой печатный символ
@acronym{ASCII} в диапазоне от @w{@samp{ }} до @samp{~}.  Указывается имя
категории, когда определяется она с помощью @code{define-category}.

@cindex category set
  Таблица категорий на самом деле является таблицей символов
(@pxref{Char-Tables}).  Элемент таблицы категорий с индексом @var{c} -
это @dfn{набор категорий} - логический вектор - который указывает, к каким
категориям принадлежит символ @var{c}.  В этом наборе категорий, если
элемент с индексом @var{cat} - @code{t}, это означает, что категория
@var{cat} является членом набора, и этот символ @var{c} принадлежит
категории @var{cat}.

Для следующих трех функций необязательный аргумент @var{table} по
умолчанию соответствует таблице категорий текущего буфера.

@defun define-category char docstring &optional table
Функция определяет новую категорию с именем @var{char} и документацией
@var{docstring} для таблицы категорий @var{table}.

Вот пример определения новой категории для символов с сильной
направленностью справа налево (@pxref{Bidirectional Display}) и
использования ее в специальной таблице категорий.  Для получения информации
о направленности символов в примере кода используется свойство
@samp{bidi-class} Unicode (@pxref{Character Properties, bidi-class}).

@example
(defvar special-category-table-for-bidi
  ;;     Сделать пустую таблицу категорий.
  (let ((category-table (make-category-table))
        ;; Создать таблицу символов, которая дает свойство 'bidi-class' Unicode
        ;; для каждого символа.
        (uniprop-table
         (unicode-property-table-internal 'bidi-class)))
    (define-category ?R "Characters of bidi-class R, AL, or RLO"
                     category-table)
    ;; Изменить запись категории для каждого символа, для которого свойство Unicode
    ;; 'bidi-class' имеет значение R, AL, или RLO -
    ;;  они имеют направленность справа налево.
    (map-char-table
     #'(lambda (key val)
         (if (memq val '(R AL RLO))
             (modify-category-entry key ?R category-table)))
     uniprop-table)
    category-table))
@end example
@end defun

@defun category-docstring category &optional table
Функция возвращает строку документации категории @var{category}
в таблице категорий @var{table}.

@example
(category-docstring ?a)
     @result{} "ASCII"
(category-docstring ?l)
     @result{} "Latin"
@end example
@end defun

@defun get-unused-category &optional table
Функция возвращает имя категории (символ), которое в настоящее время не
определено в @var{table}.  Если в @var{table} используются все возможные
категории, возвращается @code{nil}.
@end defun

@defun category-table
Функция возвращает таблицу категорий текущего буфера.
@end defun

@defun category-table-p object
Функция возвращает @code{t}, если @var{object} является таблицей
категорий, в противном случае - @code{nil}.
@end defun

@defun standard-category-table
Функция возвращает стандартную таблицу категорий.
@end defun

@defun copy-category-table &optional table
Функция создает копию @var{table} и возвращает ее.  Если @var{table} не
указано (или равно @code{nil}), возвращается копия стандартной таблицы
категорий.  В противном случае выдается сообщение об ошибке, если
@var{table} не является таблицей категорий.
@end defun

@defun set-category-table table
Функция делает @var{table} таблицей категорий для текущего буфера.
Возвращается @var{table}.
@end defun

@defun make-category-table
Это создает и возвращает пустую таблицу категорий.  В пустой таблице
категорий никакие категории не назначены, и символы не принадлежат ни
к каким категориям.
@end defun

@defun make-category-set categories
Функция возвращает новый набор категорий --- вектор типа bool ---,
начальным содержанием которого являются категории, перечисленные в
строке @var{categories}.  Элементы @var{categories} должны быть
названиями категорий; новый набор категорий имеет @code{t} для каждой
из этих категорий и @code{nil} для всех остальных категорий.

@example
(make-category-set "al")
     @result{} #&128"\0\0\0\0\0\0\0\0\0\0\0\0\2\20\0\0"
@end example
@end defun

@defun char-category-set char
Функция возвращает набор категорий для символа @var{char} в таблице
категорий текущего буфера.  Это логический вектор, который записывает,
к каким категориям принадлежит символ @var{char}.  Функция
@code{char-category-set} не выделяет память, потому что она возвращает
тот же bool-вектор, который существует в таблице категорий.

@example
(char-category-set ?a)
     @result{} #&128"\0\0\0\0\0\0\0\0\0\0\0\0\2\20\0\0"
@end example
@end defun

@defun category-set-mnemonics category-set
Функция преобразует набор категорий @var{category-set} в строку,
содержащую символы, обозначающие категории, которые являются членами набора.

@example
(category-set-mnemonics (char-category-set ?a))
     @result{} "al"
@end example
@end defun

@defun modify-category-entry char category &optional table reset
Функция изменяет набор категорий @var{char} в таблице категорий @var{table}
(по умолчанию используется таблица категорий текущего буфера).  @var{char}
может быть символом или cons-ячейкой вида @code{(@var{min} . @var{max})};
в последнем случае функция изменяет наборы категорий для всех символов в
диапазоне от @var{min} до @var{max} включительно.

Обычно изменяется набор категорий, добавляется к нему @var{category}.
Но если @var{reset} равен не-@code{nil}, вместо этого удаляется @var{category}.
@end defun

@deffn Command describe-categories &optional buffer-or-name
Функция описывает спецификации категорий в текущей таблице категорий.
Вставляет описания в буфер, а затем отображает этот буфер.  Если
@var{buffer-or-name} равен не-@code{nil}, вместо этого описывается
таблицу категорий этого буфера.
@end deffn
