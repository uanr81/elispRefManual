@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1993, 1998-1999, 2001-2019 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node GNU Emacs Internals
@appendix Внутреннее Устройство GNU Emacs

В этой главе описывается, как выполняется дамп исполняемого файла Emacs с
предварительно загруженными библиотеками Lisp, как распределяется память и некоторые
внутренние аспекты GNU Emacs, которые могут быть интересны программистам на C.

@menu
* Building Emacs::      Как происходит сборка Emacs.
* Pure Storage::        Kludge, чтобы сделать предустановленные функции Lisp общими.
* Garbage Collection::  Освобождение места для неиспользуемых объектов Lisp.
* Stack-allocated Objects::    Временные cons и строки в стеке C.
* Memory Usage::        Информация об общем размере созданных на данный момент
                           Lisp-объектов.
* C Dialect::           На каком варианте C написан Emacs.
* Writing Emacs Primitives::   Написание кода C для Emacs.
* Writing Dynamic Modules::    Написание загружаемых модулей для Emacs.
* Object Internals::    Форматы данных буферов, окон, процессов.
* C Integer Types::     Как целочисленные типы C используются в Emacs.
@end menu

@node Building Emacs
@section Сборка Emacs
@cindex building Emacs
@pindex temacs

  В этом разделе объясняются шаги, необходимые для создания исполняемого файла Emacs.
Не обязательно знать этот материал для сборки и установки Emacs, поскольку make-файлы
делают все это автоматически.  Информация имеет отношение к разработчикам Emacs.

  Для сборки Emacs требуется GNU Make версии 3.81 или новее.

  Компиляция исходных файлов C в каталоге @file{src} создает исполняемый файл с именем
@file{temacs}, также называемый @dfn{чистый нечистый Emacs}.  Cодержит интерпретатор
Emacs Lisp и процедуры ввода-вывода, но без команд редактирования.

@cindex @file{loadup.el}
  Команда @w{@command{temacs -l loadup}} запустит @file{temacs} и направит его на
загрузку @file{loadup.el}.  Библиотека @code{loadup} загружает дополнительные
библиотеки Lisp, которые устанавливают обычную среду редактирования Emacs.  После
этого шага исполняемый файл Emacs больше не является @dfn{голым}.

@cindex dumping Emacs
  Поскольку загрузка стандартных файлов Lisp занимает некоторое время, исполняемый
файл @file{temacs} обычно не запускается пользователями напрямую.  Вместо этого в
качестве одного из последних шагов сборки Emacs запускается команда
@samp{temacs -batch -l loadup dump}.  Специальный аргумент @samp{dump} заставляет
@command{temacs} выгружать исполняемую программу, называемую @file{emacs}, в которую
предварительно загружены все стандартные файлы Lisp.  (Аргумент @samp{-batch}
предотвращает попытку @file{temacs} инициализировать какие-либо свои данные на
терминале, так что таблицы информации о терминале остаются пустыми в выгруженном
Emacs.)

@cindex preloaded Lisp files
@vindex preloaded-file-list
  Установлен дамп исполняемый файл @file{emacs} (также называемый @dfn{чистый} Emacs).
Переменная @code{preloaded-file-list} хранит список файлов Lisp, предварительно
загруженных в выгруженный Emacs.  Если перенести Emacs в новую операционную систему
и не иметь возможности реализовать дамп, то Emacs должен загружать @file{loadup.el}
при каждом запуске.

@cindex build details
@cindex deterministic build
@cindex @option{--disable-build-details} option to @command{configure}
  По умолчанию сбрасываемый исполняемый файл @file{emacs} записывает такие детали,
как время сборки и имя хоста.  Использовать опцию @option{--disable-build-details}
для @command{configure}, чтобы скрыть эти детали, так что сборка и установка Emacs
дважды из одних и тех же источников с большей вероятностью приведет к созданию
идентичных копий Emacs.

@cindex @file{site-load.el}
  Можно указать дополнительные файлы для предварительной загрузки, написав библиотеку
с именем @file{site-load.el}, которая их загружает.  Может потребоваться перестроить
Emacs с добавленным определением

@example
#define SITELOAD_PURESIZE_EXTRA @var{n}
@end example

@noindent
сделать @var{n} добавленными байтами чистого пространства для хранения дополнительных
файлов; смотреть @file{src/puresize.h}.
(Попробуйте добавить приращение 20000, пока оно не станет достаточно большим.)  Однако
преимущество предварительной загрузки дополнительных файлов уменьшается по мере того,
как машины становятся быстрее.  На современных машинах это обычно не рекомендуется.

  После того, как @file{loadup.el} читает @file{site-load.el}, находятся строки
документации для примитивных и предварительно загруженных функций (и переменных) в
файле @file{etc/DOC}, где они хранятся, путем вызова @code{Snarf-documentation}
(@pxref{Definition of Snarf-documentation,, Accessing Documentation}).

@cindex @file{site-init.el}
@cindex preloading additional functions and variables
  Можно указать другие выражения Lisp для выполнения непосредственно перед сбросом,
поместив их в библиотеку с именем @file{site-init.el}.  Этот файл запускается после
нахождения строк документации.

  Если требуется предварительно загрузить определения функций или переменных, есть три
способа сделать это и сделать их строки документации доступными при последующем
запуске Emacs:

@itemize @bullet
@item
Настроить сканирование этих файлов при создании файла @file{etc/DOC} и загрузите их
с помощью @file{site-load.el}.

@item
Загрузить файлы с помощью @file{site-init.el}, затем скопировать файлы в каталог
установки для файлов Lisp при установке Emacs.

@item
Задать значение @code{nil} для @code{byte-compile-dynamic-docstrings} как локальную
переменную в каждом из этих файлов и загрузить их с помощью @file{site-load.el} или
@file{site-init.el}.  (Этот метод имеет тот недостаток, что строки документации все
время занимают место в Emacs.)
@end itemize

@cindex change @code{load-path} at configure time
@cindex @option{--enable-locallisppath} option to @command{configure}
  Не рекомендуется помещать в @file{site-load.el} или @file{site-init.el} что-либо,
что изменило бы какие-либо функции, которые пользователи ожидают от обычного
немодифицированного Emacs.  Если чувствуется, что должны переопределиться обычные
функции сайта, сделать это с помощью @file{default.el}, чтобы пользователи могли
отменить изменения, если захочется.  @xref{Startup Summary}.  Обратить внимание, что
если @file{site-load.el} или @file{site-init.el} изменяет @code{load-path}, изменения
будут потеряны после сброса.  @xref{Library Search}.  Чтобы навсегда изменить
@code{load-path}, использовать опцию @option{--enable-locallisppath} для
@command{configure}.

  В пакете, который может быть предварительно загружен, иногда необходимо (или
полезно) отложить определенные вычисления до последующего запуска Emacs.  Подавляющее
большинство таких случаев связано со значениями настраиваемых переменных.  Например,
@code{tutorial-directory} - это предварительно загруженная переменная, определенная в
@file{startup.el}.  Значение по умолчанию устанавливается на основе
@code{data-directory}.  Переменная должна получить доступ к значению
@code{data-directory} при запуске Emacs, а не при его выгрузке, потому что исполняемый
файл Emacs, вероятно, был установлен в другом месте с момента его выгрузки.

@defun custom-initialize-delay symbol value
Функция откладывает инициализацию @var{symbol} до следующего запуска Emacs.  Обычно
используется эта функция, определённая со свойством @code{:initialize} настраиваемой
переменной.  (Аргумент @var{value} не используется и предоставляется только для
совместимости с формой, которую ожидает Custom.)
@end defun

В том маловероятном случае, если понадобится более общая функциональность, чем
предоставляет @code{custom-initialize-delay}, можно использовать
@code{before-init-hook} (@pxref{Startup Summary}).

@defun dump-emacs to-file from-file
@cindex unexec
Функция выгружает текущее состояние Emacs в исполняемый файл @var{to-file}.  Берется
символы из @var{from-file} (обычно это исполняемый файл @file{temacs}).

Если нужно использовать эту функцию в Emacs, который уже был выгружен, потребуется
запустить Emacs с @samp{-batch}.
@end defun

@node Pure Storage
@section Чистое Хранилище
@cindex pure storage

  Emacs Lisp использует два типа хранилища для созданных пользователем объектов Lisp:
@dfn{нормальное хранение} и @dfn{чистое хранилище}.  Обычное хранилище - это место,
где все новые данные, созданные во время сеанса Emacs, хранятся
(@pxref{Garbage Collection}).  Чистое хранилище используется для определенных данных в
предварительно загруженных стандартных файлах Lisp - данных, которые никогда не должны
изменяться во время фактического использования Emacs.

  Чистое хранилище выделяется только тогда, когда @command{temacs} загружает
стандартные предварительно загруженные библиотеки Lisp.  В файле @file{emacs} помечено
как доступный только для чтения (в операционных системах, которые это разрешают), так
что пространство памяти может совместно использоваться всеми заданиями Emacs,
запущенными на машине одновременно.  Чистое хранилище не расширяется; фиксированная
сумма выделяется при компиляции Emacs, и если этого недостаточно для предварительно
загруженных библиотек, @file{temacs} выделяет динамическую память для той части,
которая не подходит.  Полученное изображение будет работать, но сборщик мусора
(@pxref{Garbage Collection}) в этой ситуации отключен, что приведет к утечке памяти.
Такое переполнение обычно не происходит, если не попытаться предварительно загрузить
дополнительные библиотеки или добавить функции к стандартным.  Emacs отобразит
предупреждение о переполнении при запуске.  Если это произойдет, следует увеличить
параметр компиляции @code{SYSTEM_PURESIZE_EXTRA} в файле @file{src/puresize.h} и
пересобрать Emacs.

@defun purecopy object
Функция делает копию в чистом хранилище @var{object} и возвращает ее.  Копируется
строка, просто создавая новую строку с теми же символами, но без текстовых свойств, в
чистом хранилище.  Рекурсивно копирует содержимое векторов и cons-ячеек.  Не
копируются другие объекты, такие как символы, а просто возвращаются без изменений.
Сигнализируется об ошибке, если задано скопировать маркеры.

Функция не работает, кроме случаев, когда Emacs собирается и выгружается; обычно
вызывается только в предварительно загруженных файлах Lisp.
@end defun

@defvar pure-bytes-used
Значение этой переменной - количество байтов чистой памяти, выделенной на данный
момент.  Обычно в выгруженном Emacs это число очень близко к общему объему доступной
чистой памяти - в противном случае предварительно бы распределилось меньше.
@end defvar

@defvar purify-flag
Переменная определяет, должен ли @code{defun} делать копию определения функции в
чистом хранилище.  Если это не-@code{nil}, то определение функции копируется в чистое
хранилище.

Флаг имеет значение @code{t} при первоначальной загрузке всех основных функций для
сборки Emacs (что позволяет использовать эти функции совместно и не собирать).
Выгрузка Emacs как исполняемого файла всегда записывает @code{nil} в эту переменную,
независимо от того, какое значение она имеет до и после выгрузки.

Не нужно изменять этот флаг в работающем Emacs.
@end defvar

@node Garbage Collection
@section Сбор Мусора

@cindex memory allocation
  Когда программа создает список или пользователь определяет новую функцию (например,
загружая библиотеку), эти данные помещаются в обычное хранилище.  Если нормального
хранилища не хватает, Emacs просит операционную систему выделить больше памяти.
Различные типы объектов Lisp, такие как символы, cons-ячейки, небольшие векторы,
маркеры и так далее, разделены в отдельные блоки в памяти.  (Большие векторы, длинные
строки, буферы и некоторые другие типы редактирования, которые довольно большие,
выделяются отдельными блоками, по одному на объект; маленькие строки упаковываются в
блоки по 8 Кбайт, а маленькие векторы упаковываются в блоки по 4 Кбайт) .

@cindex vector-like objects, storage
@cindex storage of vector-like Lisp objects
  Помимо базового вектора, многие объекты, такие как окно, буфер и фрейм, управляются
так, как если бы они были векторами.  Соответствующие структуры данных C включают поле
@code{union vectorlike_header}, член @code{size} которого содержит подтип,
перечисляемый @code{enum pvec_type}, и информацию о том, сколько полей
@code{Lisp_Object} содержит эта структура и каков размер остальных данных.  Эта
информация необходима для расчета объема памяти, занимаемого объектом, и используется
кодом распределения векторов при итерации по векторным блокам.

@cindex garbage collection
  Довольно распространено использовать какое-то хранилище на некоторое время, а затем
освободить его, (например) уничтожив буфер или удалив последний указатель на объект.
Emacs предоставляет @dfn{сборщик мусора} для восстановления этого заброшенного
хранилища.  Сборщик мусора работает, находя и отмечая все объекты Lisp, которые все
еще доступны для программ на Lisp.  Для начала предполагается, что все символы, их
значения и соответствующие определения функций, а также любые данные, находящиеся в
настоящее время в стеке, доступны.  Также доступны любые объекты, которые могут быть
достигнуты косвенно через другие доступные объекты.

  Когда маркировка закончена, все объекты, которые еще не помечены, являются мусором.
Независимо от того, что делает программа на Lisp или пользователь, на них невозможно
сослаться, поскольку больше нет способа связаться с ними.  Их пространство с таким же
успехом можно использовать повторно, потому что никто не затронит больше их.  Вторая
фаза (очистка) сборщика мусора предусматривает их повторное использование.

@c ??? Может быть, добавить сюда что-нибудь, описывающее слабые хеш-таблицы?

@cindex free list
  Фаза развертки помещает неиспользуемые cons-ячейки в @dfn{свободный список} для
будущего распределения; то же самое для символов и маркеров.  Сжимаются доступные
строки, поэтому занимают меньше 8k блоков; затем освобождаются остальные 8k блоков.
Недостижимые векторы из векторных блоков объединяются для создания максимально
возможных свободных областей; если свободная область охватывает полный блок размером
4 КБ, этот блок освобождается.  В противном случае свободная область записывается в
массиве свободного списка, где каждая запись соответствует свободному списку областей
того же размера.  Большие векторы, буферы и другие большие объекты выделяются и
освобождаются индивидуально.

@cindex CL note---allocate more storage
@quotation
@b{Common Lisp Примечание:} В отличие от других Lisp, GNU Emacs Lisp не вызывает
сборщик мусора, когда список свободных мест пуст.  Вместо этого просто запрашивается у
операционной системы выделение большего объема памяти, и обработка продолжается до
тех пор, пока не будут использованы байты @code{gc-cons-threshold}.

Это означает, что можно убедиться, что сборщик мусора не будет запускаться во время
определенной части программы Lisp, явно вызвав сборщик мусора непосредственно перед
ним (при условии, что эта часть программы не использует столько места, чтобы
запустить второй раз сборщик мусора).
@end quotation

@deffn Command garbage-collect
Команда запускает сборку мусора и возвращает информацию об объеме используемого
пространства.  (Сборка мусора также может происходить спонтанно, если использовать
более @code{gc-cons-threshold} байтов данных Lisp с момента предыдущей сборки мусора.)

@code{garbage-collect} возвращает список с информацией об объеме используемого
пространства, где каждая запись имеет форму @samp{(@var{name} @var{size} @var{used})}
или @samp{(@var{name} @var{size} @var{used} @var{free})}.  В записи @var{name} - это
символ, описывающий тип объектов, которые представляет эта запись, @var{size} - это
количество байтов, используемых каждым из них, @var{used} - это количество тех
объектов, которые были обнаружены живыми в куче, а необязательный @var{free} -
количество тех объектов, которые не являются активными, но которые Emacs хранит для
будущих распределений.  Итак, общий результат:

@example
((@code{conses} @var{cons-size} @var{used-conses} @var{free-conses})
 (@code{symbols} @var{symbol-size} @var{used-symbols} @var{free-symbols})
 (@code{miscs} @var{misc-size} @var{used-miscs} @var{free-miscs})
 (@code{strings} @var{string-size} @var{used-strings} @var{free-strings})
 (@code{string-bytes} @var{byte-size} @var{used-bytes})
 (@code{vectors} @var{vector-size} @var{used-vectors})
 (@code{vector-slots} @var{slot-size} @var{used-slots} @var{free-slots})
 (@code{floats} @var{float-size} @var{used-floats} @var{free-floats})
 (@code{intervals} @var{interval-size} @var{used-intervals} @var{free-intervals})
 (@code{buffers} @var{buffer-size} @var{used-buffers})
 (@code{heap} @var{unit-size} @var{total-size} @var{free-size}))
@end example

Вот пример:

@example
(garbage-collect)
      @result{} ((conses 16 49126 8058) (symbols 48 14607 0)
                 (miscs 40 34 56) (strings 32 2942 2607)
                 (string-bytes 1 78607) (vectors 16 7247)
                 (vector-slots 8 341609 29474) (floats 8 71 102)
                 (intervals 56 27 26) (buffers 944 8)
                 (heap 1024 11715 2678))
@end example

Ниже приведена таблица, объясняющая каждый элемент.  Обратить внимание, что последняя
запись @code{heap} является необязательной и присутствует только в том случае, если
базовая реализация @code{malloc} предоставляет функцию @code{mallinfo}.

@table @var
@item cons-size
Внутренний размер cons-ячейки, то есть @code{sizeof (struct Lisp_Cons)}.

@item used-conses
Количество используемых cons-ячеек.

@item free-conses
Количество cons-ячеек, пространство для которых было получено из операционной системы,
но которые в настоящее время не используются.

@item symbol-size
Внутренний размер символа, то есть @code{sizeof (struct Lisp_Symbol)}.

@item used-symbols
Количество используемых символов.

@item free-symbols
Количество символов, пространство для которых было получено из операционной системы,
но которые в настоящее время не используются.

@item misc-size
Внутренний размер другой сущности, то есть @code{sizeof (union Lisp_Misc)}, который
является размером самого большого типа, перечисленного в @code{enum Lisp_Misc_Type}.

@item used-miscs
Количество используемых разных объектов.  К ним относятся маркеры и наложения, а
также некоторые объекты, невидимые для пользователей.

@item free-miscs
Количество разных объектов, для которых из операционной системы было получено
пространство, но которые в настоящее время не используются.

@item string-size
Внутренний размер заголовка строки, то есть @code{sizeof (struct Lisp_String)}.

@item used-strings
Количество используемых заголовков строк.

@item free-strings
Количество строковых заголовков, пространство для которых было получено из
операционной системы, но которые в настоящее время не используются.

@item byte-size
Используется для удобства и равно @code{sizeof (char)}.

@item used-bytes
Общий размер всех строковых данных в байтах.

@item vector-size
Внутренний размер векторного заголовка, то есть @code{sizeof (struct Lisp_Vector)}.

@item used-vectors
Количество векторных заголовков, выделенных из векторных блоков.

@item slot-size
Внутренний размер слота вектора, всегда равен @code{sizeof (Lisp_Object)}.

@item used-slots
Количество слотов во всех используемых векторах.

@item free-slots
Количество свободных слотов во всех векторных блоках.

@item float-size
Внутренний размер объекта типа float, то есть @code{sizeof (struct Lisp_Float)}.
(Не путать с родной платформой @code{float} или @code{double}.)

@item used-floats
Число использования floats.

@item free-floats
Число чисел с плавающей запятой, пространство для которых было получено из
операционной системы, но которые в настоящее время не используются.

@item interval-size
Внутренний размер интервального объекта, то есть @code{sizeof (struct interval)}.

@item used-intervals
Количество используемых интервалов.

@item free-intervals
Количество интервалов, для которых пространство было получено из операционной
системы, но в настоящее время не используется.

@item buffer-size
Внутренний размер буфера, то есть @code{sizeof (struct buffer)}.
(Не путать со значением, возвращаемым функцией @code{buffer-size}.)

@item used-buffers
Количество используемых буферных объектов.  Это включает убитые буферы, невидимые
для пользователей, то есть все буферы в списке @code{all_buffers}.

@item unit-size
Единица измерения пространства кучи, всегда равная 1024 байтам.

@item total-size
Общий размер кучи в единицах @var{unit-size}.

@item free-size
Пространство кучи, которое в настоящее время не используется, в единицах
@var{unit-size}.
@end table

Если было переполнение в чистом пространстве (@pxref{Pure Storage}),
@code{garbage-collect} возвращает @code{nil}, потому что настоящая сборка мусора
не может быть выполнена.
@end deffn

@defopt garbage-collection-messages
Если переменная - не-@code{nil}, Emacs отображает сообщение в начале и в конце
сборки мусора.  Значение по умолчанию - @code{nil}.
@end defopt

@defvar post-gc-hook
Нормальный перехватчик, который запускается в конце сборки мусора.  Сборка мусора
запрещена во время выполнения функций перехватчика, поэтому буть осторожным при их
написании.
@end defvar

@defopt gc-cons-threshold
Значение этой переменной - количество байтов памяти, которые должны быть выделены для
объектов Lisp после одной сборки мусора, чтобы запустить другую сборку мусора.  Можно
использовать результат, возвращаемый @code{garbage-collect}, для получения информации
о размере конкретного типа объекта; пространство, выделенное для содержимого буферов,
не учитывается.  Обратить внимание, что последующая сборка мусора не происходит сразу
после того, как порог исчерпан, а только при следующем вызове интерпретатора Lisp.

Начальное пороговое значение - @code{GC_DEFAULT_THRESHOLD}, определенное в
@file{alloc.c}.  Поскольку это определено в единицах @code{word_size}, значение
составляет 400 000 для 32-битной конфигурации по умолчанию и 800 000 для 64-битной.
Если указать большее значение, сборка мусора будет происходить реже.  Это сокращает
время, затрачиваемое на сборку мусора, но увеличивает общее использование памяти.
Можно захотеть сделать это при запуске программы, которая создает много данных на
Lisp.

Можно сделать сборы более частыми, указав меньшее значение, вплоть до 1/10 от
@code{GC_DEFAULT_THRESHOLD}.  Значение меньше этого минимума будет действовать только
до следующей сборки мусора, после чего @code{garbage-collect} вернет порог обратно на
минимум.
@end defopt

@defopt gc-cons-percentage
Значение этой переменной указывает количество потребляемых ресурсов до того, как
произойдет сборка мусора, как часть текущего размера кучи.  Этот критерий и
@code{gc-cons-threshold} применяются параллельно, и сборка мусора происходит только
тогда, когда оба критерия удовлетворяются.

По мере увеличения размера кучи время выполнения сборки мусора увеличивается.  Таким
образом, может быть желательно делать их реже пропорционально.
@end defopt

  Значение, возвращаемое @code{garbage-collect}, описывает объем памяти, используемый
данными Lisp, с разбивкой по типам данных.  Напротив, функция @code{memory-limit}
предоставляет информацию об общем объеме памяти, используемой Emacs в настоящее время.

@defun memory-limit
Функция возвращает адрес последнего выделенного Emacs байта, деленный на 1024.
Делится значение на 1024, чтобы убедиться, что оно соответствует целому числу Lisp.

Можно использовать это, чтобы получить общее представление о том, как действия влияют
на использование памяти.
@end defun

@defvar memory-full
Переменная @code{t}, если в Emacs почти не хватает памяти для объектов Lisp, и
@code{nil} в противном случае.
@end defvar

@defun memory-use-counts
Возвращает список чисел, которые подсчитывают количество объектов, созданных в этом
сеансе Emacs.  Каждый из этих счетчиков увеличивается для определенного типа объекта.
Смотреть подробности в строке документации.
@end defun

@defun memory-info
Функция возвращает общий объем системной памяти и ее объем.  В неподдерживаемой
системе значение может быть @code{nil}.
@end defun

@defvar gcs-done
Переменная содержит общее количество сборок мусора, выполненных на данный момент в
этом сеансе Emacs.
@end defvar

@defvar gc-elapsed
Переменная содержит общее количество секунд, прошедшее с момента сборки мусора в этом
сеансе Emacs, в виде числа с плавающей запятой.
@end defvar

@node Stack-allocated Objects
@section Объекты, Размещенные в Стеке

@cindex stack allocated Lisp objects
@cindex Lisp objects, stack-allocated
  Описанный выше сборщик мусора используется для управления данными, видимыми из
программ Lisp, а также большей частью данных, используемых внутри интерпретатора Lisp.
Иногда может быть полезно выделить временные внутренние объекты с помощью стека C
интерпретатора.  Это может повысить производительность, поскольку выделение стека
обычно происходит быстрее, чем использование памяти кучи для выделения сборщику
мусора и для ее освобождения.  Обратной стороной является то, что использование таких
объектов после их освобождения приводит к неопределенному поведению, поэтому
использование должно быть хорошо продумано и тщательно отлажено с помощью функции
@code{GC_CHECK_MARKED_OBJECTS} (смотреть @file{src/alloc.c}).  В частности, объекты,
размещенные в стеке, никогда не должны быть видимыми для пользовательского кода Lisp.

  В настоящее время таким образом можно размещать cons-ячейки и строки.  Это
реализовано макросами C, такими как @code{AUTO_CONS} и @code{AUTO_STRING}, которые
определяют именованный @code{Lisp_Object} со временем жизни блока.  Сборщик мусора не
освобождает эти объекты; вместо этого они имеют автоматическую продолжительность
хранения, то есть они выделяются как локальные переменные и автоматически
освобождаются в конце выполнения блока C, который определил объект.

  По соображениям производительности строки, выделенные стеком, ограничены символами
@acronym{ASCII}, и многие из этих строк являются неизменяемыми, то есть вызов
@code{ASET} для них приводит к неопределенному поведению.

@node Memory Usage
@section Использование Памяти
@cindex memory usage

  Функции и переменные предоставляют информацию об общем объеме памяти, выделенной
Emacs, с разбивкой по типам данных.  Обратить внимание на разницу между ними и
значениями, возвращаемыми @code{garbage-collect}; эти подсчитывают объекты, которые в
настоящее время существуют, но подсчитывают количество или размер всех выделений,
в том числе для объектов, которые уже были освобождены.

@defvar cons-cells-consed
Общее количество cons-ячеек, выделенных на данный момент в этом сеансе Emacs.
@end defvar

@defvar floats-consed
Общее количество чисел с плавающей запятой, выделенных на данный момент в этом
сеансе Emacs.
@end defvar

@defvar vector-cells-consed
Общее количество векторных ячеек, выделенных на данный момент в этом сеансе Emacs.
@end defvar

@defvar symbols-consed
Общее количество символов, выделенных на данный момент в этом сеансе Emacs.
@end defvar

@defvar string-chars-consed
Общее количество строковых символов, выделенных на данный момент в этом сеансе.
@end defvar

@defvar misc-objects-consed
Общее количество разных объектов, выделенных на данный момент в этом сеансе.  К ним
относятся маркеры и наложения, а также некоторые объекты, невидимые для пользователей.
@end defvar

@defvar intervals-consed
Общее количество интервалов, выделенных на данный момент в этом сеансе Emacs.
@end defvar

@defvar strings-consed
Общее количество строк, выделенных на данный момент в этом сеансе Emacs.
@end defvar

@node C Dialect
@section C Диалект
@cindex C programming language

Часть C Emacs переносима на C99 или новее: специфичные для C11 особенности, такие как
@samp{<stdalign.h>} и @samp{_Noreturn}, не используются без проверки, обычно во время
настройки, а процедура сборки Emacs предоставляет заменяющую реализацию, если это
необходимо.  Некоторые функции C11, такие как анонимные структуры и объединения,
слишком сложно имитировать, поэтому их полностью избегают.

В какой-то момент в будущем базовый диалект C, несомненно, изменится на C11.

@node Writing Emacs Primitives
@section Написание Примитивов Emacs
@cindex primitive function internals
@cindex writing Emacs primitives

  Примитивы Lisp - это функции Lisp, реализованные в C@.  Детали взаимодействия с
функцией C, чтобы Lisp мог ее вызывать, обрабатываются несколькими макросами C.
Единственный способ понять, как писать новый код на C, - это прочитать исходный код,
но можно объяснить некоторые вещи здесь.

  Примером специальной формы является определение @code{or} из @file{eval.c}.
(Обычная функция будет иметь такой же общий вид.)

@smallexample
@group
DEFUN ("or", For, Sor, 0, UNEVALLED, 0,
       doc: /* Вычислять аргументы,
пока один из них не даст non-nil,
затем вернуть это значение. Остальные аргументы
вообще не вызываются.  Если все аргументы
возвращают nil, возвращается nil.
@end group
@group
usage: (or CONDITIONS...)  */)
  (Lisp_Object args)
@{
  Lisp_Object val = Qnil;
@end group

@group
  while (CONSP (args))
    @{
      val = eval_sub (XCAR (args));
      if (!NILP (val))
        break;
      args = XCDR (args);
      maybe_quit ();
    @}
@end group

@group
  return val;
@}
@end group
@end smallexample

@cindex @code{DEFUN}, макрос C для определения примитивов Lisp
  Начнем с точного объяснения аргументов макроса @code{DEFUN}.
Вот шаблон для них:

@example
DEFUN (@var{lname}, @var{fname}, @var{sname}, @var{min}, @var{max}, @var{interactive}, @var{doc})
@end example

@table @var
@item lname
Имя символа Lisp, определяемого как имя функции; в приведенном выше примере это
@code{or}.

@item fname
Имя функции C для функции.  Имя, которое используется в коде C для вызова функции.
По соглашению, имя @samp{F} добавляется к имени Lisp, а все дефисы (@samp{-}) в имени
Lisp заменены на символы подчеркивания.  Таким образом, чтобы вызвать эту функцию из
кода C, вызвать @code{For}.

@item sname
Имя переменной C для использования в структуре, содержащей данные для объекта subr,
представляющего функцию в Lisp.  Эта структура передает имя символа Lisp в процедуру
инициализации, которая создаст символ и сохранит объект subr в качестве его
определения.  По соглашению это имя всегда @var{fname} с заменой @samp{F} на @samp{S}.

@item min
Минимальное количество аргументов, которое требуется функции.  Функция @code{or}
допускает минимум ноль аргументов.

@item max
Максимальное количество аргументов, которое принимает функция, если есть фиксированный
максимум.  В качестве альтернативы это может быть @code{UNEVALLED}, указывающий на
специальную форму, которая принимает неоцененные аргументы, или @code{MANY},
указывающий неограниченное количество оцениваемых аргументов (эквивалент
@code{&rest}).  Оба @code{UNEVALLED} и @code{MANY} - это макросы.  Если @var{max} -
число, оно должно быть больше @var{min}, но меньше 8.

@cindex interactive specification in primitives
@item interactive
Интерактивная спецификация, строка, которая может использоваться в качестве аргумента
@code{interactive} в Lisp-функции (@pxref{Using Interactive}).  В случае @code{or}
это @code{0} (нулевой указатель), указывающий на то, что @code{or} не может быть
вызвано интерактивно.  Значение @code{""} указывает на функцию, которая не должна
получать аргументов при интерактивном вызове.  Если значение начинается с @samp{"(},
строка оценивается как форма Lisp.  Например:

@example
@group
DEFUN ("foo", Ffoo, Sfoo, 0, 3,
       "(list (read-char-by-name \"Insert character: \")\
              (prefix-numeric-value current-prefix-arg)\
              t)",
       doc: /* @dots{} */)
@end group
@end example

@item doc
Строка документации.  Используется синтаксис комментариев C, а не синтаксис строки C,
потому что синтаксис комментариев не требует ничего особенного для включения
нескольких строк.  @samp{doc:} идентифицирует следующий комментарий как строку
документации.  Разделители @samp{/*} и @samp{*/}, которые начинают и заканчивают
комментарий, не являются частью строки документации.

Если последняя строка строки документации начинается с ключевого слова @samp{usage:},
остальная часть строки рассматривается как список аргументов для целей документации.
Таким образом, можно использовать в строке документации имена аргументов, отличные от
тех, которые используются в коде C.  @samp{usage:} требуется, если функция имеет
неограниченное количество аргументов.

Все обычные правила для строк документации в коде Lisp (@pxref{Documentation Tips})
применимы и к строкам документации на языке C.

За строкой документации может следовать список атрибутов функции C для функции C,
реализующей примитив, например:

@example
@group
DEFUN ("bar", Fbar, Sbar, 0, UNEVALLED, 0
       doc: /* @dots{} */
       attributes: @var{attr1} @var{attr2} @dots{})
@end group
@end example

@noindent
Можно указать более одного атрибута один за другим.  В настоящее время распознаются
только следующие атрибуты:

@table @code
@item noreturn
Объявляет функцию C как функцию, которая никогда не возвращается.  Это соответствует
ключевому слову @code{_Noreturn} C11 и атрибуту
@w{@code{__attribute__ ((__noreturn__))}} GCC
(@pxref{Function Attributes,,, gcc, Using the GNU Compiler Collection}).

@item const
Объявляет, что функция не проверяет никаких значений, кроме своих аргументов, и не
имеет никаких эффектов, кроме возвращаемого значения.  Это соответствует атрибуту 
@w{@code{__attribute__ ((__const__))}} GCC.

@item noinline
Соответствует атрибуту @w{@code{__attribute__ ((__noinline__))}} GCC, который
предотвращает рассмотрение функции для встраивания.  Это может потребоваться,
например, для предотвращения эффектов оптимизации времени компоновки для переменных
на основе стека.
@end table

@end table

  После вызова макроса @code{DEFUN} требуется написать список аргументов для функции
C, включая типы для аргументов.  Если примитив принимает фиксированное максимальное
количество аргументов Lisp, должен быть один аргумент C для каждого аргумента Lisp и
каждый аргумент должен иметь тип @code{Lisp_Object}.  (Различные макросы и функции для
создания значений типа @code{Lisp_Object} объявлены в файле @file{lisp.h}.)  Если
примитив является специальной формой, должен принимать список Lisp, содержащий его
неоцененные аргументы Lisp, как единственный аргумент типа @code{Lisp_Object}.  Если
примитив не имеет верхнего предела на количество вычисляемых аргументов Lisp, должен
иметь ровно два аргумента C: первый - это количество аргументов Lisp, а второй - это
адрес блока, содержащего их значения.  У них есть типы @code{ptrdiff_t} и
@w{@code{Lisp_Object *}} соответственно.  Поскольку @code{Lisp_Object} может содержать
любой объект Lisp любого типа данных, можно определить фактический тип данных только
во время выполнения; поэтому, если требуется, чтобы примитив принимал аргумент только
определенного типа, нужно явно проверить тип, используя подходящий предикат
(@pxref{Type Predicates}).
@cindex type checking internals

@cindex garbage collection protection
@cindex protect C variables from garbage collection
  Внутри самой функции @code{For} локальная переменная @code{args} ссылается на
объекты, контролируемые сборщиком мусора Emacs с маркировкой стека.  Хотя сборщик
мусора не восстанавливает объекты, доступные из переменных стека C @code{Lisp_Object},
он может перемещать некоторые компоненты объекта, такие как содержимое строки или
текст буфера.  Следовательно, функции, которые обращаются к этим компонентам, должны
позаботиться о том, чтобы повторно получить их адреса после выполнения оценки Lisp.
Это означает, что вместо сохранения указателей C на содержимое строки или текст
буфера, код должен сохранять позицию буфера или строки и пересчитывать указатель C из
этой позиции после выполнения оценки Lisp.  Оценка Lisp может происходить через
вызовы @code{eval_sub} или @code{Feval}, прямо или косвенно.

@cindex @code{maybe_quit}, use in Lisp primitives
  Обратить внимание на вызов @code{maybe_quit} внутри цикла: эта функция проверяет,
нажал ли пользователь @kbd{C-g}, и, если да, прерывает обработку.  Потребуется делать
это в любом цикле, который потенциально может потребовать большого количества
итераций; в этом случае список аргументов может быть очень длинным.  Это увеличивает
скорость отклика Emacs и улучшает взаимодействие с пользователем.

  Не требуется использовать инициализаторы C для статических или глобальных
переменных, если только переменные никогда не записываются после сброса Emacs.  Эти
переменные с инициализаторами размещаются в области памяти, которая становится
доступной только для чтения (в некоторых операционных системах) в результате сброса
Emacs.  @xref{Pure Storage}.

@cindex @code{defsubr}, Lisp symbol for a primitive
  Определения функции C недостаточно, чтобы сделать примитив Lisp доступным; также
потребуется создать символ Lisp для примитива и сохранить подходящий объект subr в
его функциональной ячейке.  Код выглядит так:

@example
defsubr (&@var{sname});
@end example

@noindent
Здесь @var{sname} - это имя, которое вы использовали в качестве третьего аргумента
@code{DEFUN}.

  Если добавляется новый примитив в файл, в котором уже определены примитивы Lisp,
найть функцию (в конце файла) с именем @code{syms_of_@var{something}} и добавить туда
вызов @code{defsubr}.  Если в файле нет этой функции или если создаётся новый файл,
добавить к нему @code{syms_of_@var{filename}} (например, @code{syms_of_myfile}).
Затем найтидите место в @file{emacs.c}, где вызываются все эти функции, и добавьте туда вызов @code{syms_of_@var{filename}}.

@anchor{Defining Lisp variables in C}
@vindex byte-boolean-vars
@cindex defining Lisp variables in C
@cindex @code{DEFVAR_INT}, @code{DEFVAR_LISP}, @code{DEFVAR_BOOL}
  Функция @code{syms_of_@var{filename}} также является местом для определения любых
переменных C, которые должны быть видны как переменные Lisp.  @code{DEFVAR_LISP}
делает переменную C типа @code{Lisp_Object} видимой в Lisp.  @code{DEFVAR_INT} делает
переменную C типа @code{int} видимой в Lisp со значением, которое всегда является
целым числом.  @code{DEFVAR_BOOL} делает переменную C типа @code{int} видимой в Lisp
со значением @code{t} или @code{nil}.  Обратить внимание, что переменные, определенные
с помощью @code{DEFVAR_BOOL}, автоматически добавляются в список
@code{byte-boolean-vars}, используемый компилятором байтов.

@cindex defining customization variables in C
  Если нужно, чтобы переменная Lisp, определенная в C, вела себя как переменная,
объявленная с помощью @code{defcustom}, добавить соответствующую запись в
@file{cus-start.el}.

@cindex @code{staticpro}, protection from GC
  Если определяется переменная C файловой области типа @code{Lisp_Object}, потребуется
защитить ее от сборки мусора, вызвав @code{staticpro} в @code{syms_of_@var{filename}},
например:

@example
staticpro (&@var{variable});
@end example

  Вот еще один пример функции с более сложными аргументами.  Это происходит из кода в
@file{window.c}, и он демонстрирует использование макросов и функций для управления
объектами Lisp.

@smallexample
@group
DEFUN ("coordinates-in-window-p", Fcoordinates_in_window_p,
       Scoordinates_in_window_p, 2, 2, 0,
       doc: /* Return non-nil if COORDINATES are in WINDOW.
  @dots{}
@end group
@group
  or `right-margin' is returned.  */)
  (register Lisp_Object coordinates, Lisp_Object window)
@{
  struct window *w;
  struct frame *f;
  int x, y;
  Lisp_Object lx, ly;
@end group

@group
  w = decode_live_window (window);
  f = XFRAME (w->frame);
  CHECK_CONS (coordinates);
  lx = Fcar (coordinates);
  ly = Fcdr (coordinates);
  CHECK_NUMBER (lx);
  CHECK_NUMBER (ly);
  x = FRAME_PIXEL_X_FROM_CANON_X (f, lx) + FRAME_INTERNAL_BORDER_WIDTH (f);
  y = FRAME_PIXEL_Y_FROM_CANON_Y (f, ly) + FRAME_INTERNAL_BORDER_WIDTH (f);
@end group

@group
  switch (coordinates_in_window (w, x, y))
    @{
    case ON_NOTHING:            /* NOT in window at all.  */
      return Qnil;
@end group

    @dots{}

@group
    case ON_MODE_LINE:          /* In mode line of window.  */
      return Qmode_line;
@end group

    @dots{}

@group
    case ON_SCROLL_BAR:         /* On scroll-bar of window.  */
      /* Historically we are supposed to return nil in this case.  */
      return Qnil;
@end group

@group
    default:
      emacs_abort ();
    @}
@}
@end group
@end smallexample

  Обратить внимание, что код C не может вызывать функции по имени, если они не
определены в C@.  Способ вызова функции, написанной на Lisp, заключается в
использовании @code{Ffuncall}, который воплощает функцию Lisp @code{funcall}.
Поскольку функция Lisp @code{funcall} принимает неограниченное количество аргументов,
в C она принимает два: количество аргументов уровня Lisp и одномерный массив,
содержащий их значения.  Первый аргумент уровня Lisp - это вызываемая функция Lisp,
а остальные - аргументы, передаваемые ей.

  Функции языка C @code{call0}, @code{call1}, @code{call2} и так далее предоставляют
удобные способы вызова функции Lisp с фиксированным числом аргументов.  Работают,
вызывая @code{Ffuncall}.

  @file{eval.c} - очень хороший файл для поиска примеров; @file{lisp.h} содержит
определения некоторых важных макросов и функций.

  Если определяется функция без побочных эффектов, присвоить ей свойство не-@code{nil}
@code{side-effect-free} или @code{pure}, соответственно (@pxref{Standard Properties}).

@node Writing Dynamic Modules
@section Написание Динамически Загружаемых Модулей
@cindex writing emacs modules
@cindex dynamic modules, writing

@cindex module @acronym{API}
  В этом разделе описывается модуль @acronym{API} Emacs и его использование при
написании модулей расширения для Emacs.  Модуль @acronym{API} определен на языке
программирования C, поэтому описание и примеры в этом разделе предполагают, что
модуль написан на C@.  Для других языков программирования нужно будет использовать
соответствующие привязки, интерфейсы и средства для вызова кода C.  Для кода Emacs C
требуется компилятор (@pxref{C Dialect}) C99 или более поздней версии, поэтому
примеры кода в этом разделе также соответствуют этому стандарту.

Написание модуля и его интеграция в Emacs включает следующие задачи:

@itemize @bullet
@item
Написание кода инициализации модуля.

@item
Написание одной или нескольких функций модуля.

@item
Обмен значениями и объектами между Emacs и функциями вашего модуля.

@item
Обработка ошибок и нелокальных выходов.
@end itemize

@noindent
В следующих подразделах более подробно описаны эти задачи и само @acronym{API}.

После того, как модуль написан, скомпилировать его для создания общей библиотеки в
соответствии с соглашениями базовой платформы.  Затем поместить разделяемую библиотеку
в каталог, упомянутый в @code{load-path} (@pxref{Library Search}), где Emacs найдет
ее.

Если требуется проверить соответствие модуля динамическому модулю Emacs @acronym{API},
вызвать Emacs с опцией @kbd{--module-assertions}.
@xref{Initial Options,,,emacs, The GNU Emacs Manual}.

@menu
* Module Initialization::
* Module Functions::
* Module Values::
* Module Misc::
* Module Nonlocal::
@end menu

@node Module Initialization
@subsection Код Инициализации Модуля
@cindex module initialization

  Начать свой модуль с включения заголовочного файла @file{emacs-module.h} и
определения символа совместимости с GPL:

@example
#include <emacs-module.h>

int plugin_is_GPL_compatible;
@end example

Файл @file{emacs-module.h} устанавливается в дерево включения системы как часть
установки Emacs.  Кроме того, можно найти его в дереве исходных текстов Emacs.

@anchor{module initialization function}
Затем пишется функцию инициализации для модуля.

@deftypefn Function int emacs_module_init (struct emacs_runtime *@var{runtime})
Emacs вызывает эту функцию, когда загружает модуль.  Если модуль не экспортирует
функцию с именем @code{emacs_module_init}, попытка загрузить модуль будет
сигнализировать об ошибке.  Функция инициализации должна возвращать ноль, если
инициализация прошла успешно, в противном случае - ненулевое значение.  В последнем
случае Emacs сообщит об ошибке, и загрузка модуля завершится неудачно.  Если
пользователь нажимает @kbd{C-g} во время инициализации, Emacs игнорирует возвращаемое
значение функции инициализации и выходит из (@pxref{Quitting}).  (При необходимости
можно поймать завершение работы пользователя внутри функции инициализации
@pxref{should_quit}.)

Аргумент @var{runtime} - это указатель на объект C @code{struct}, который включает
2 открытых поля: @code{size}, который предоставляет размер структуры в байтах; и
@code{get_environment}, который предоставляет указатель на функцию, которая позволяет
функции инициализации модуля получить доступ к объекту среды Emacs и его интерфейсам.

Функция инициализации должна выполнять любую инициализацию, необходимую для модуля.
Кроме того, может выполнять следующие задачи:

@table @asis
@cindex compatibility, between modules and Emacs
@item Compatibility verification
Модуль может проверить, что исполняемый файл Emacs, который загружает модуль,
совместим с модулем, сравнив член @code{size} структуры @var{runtime} со значением,
скомпилированным в модуль:

@example
int
emacs_module_init (struct emacs_runtime *ert)
@{
  if (ert->size < sizeof (*ert))
    return 1;
@}
@end example

@noindent
Если размер объекта среды выполнения, переданного модулю, меньше ожидаемого, это
означает, что модуль был скомпилирован для более новой (более поздней) версии Emacs,
чем та, которая пытается его загрузить, то есть@: модуль может быть несовместим с
двоичным файлом Emacs.

Кроме того, модуль может проверить совместимость модуля @acronym{API} с тем, что
модуль ожидает.  В следующем примере кода предполагается, что он является частью
функции @code{emacs_module_init}, показанной выше:

@example
  emacs_env *env = ert->get_environment (ert);
  if (env->size < sizeof (*env))
    return 2;
@end example

@noindent
@cindex module runtime environment
Вызывает функцию @code{get_environment}, используя указатель, предоставленный в
структуре @code{runtime}, для получения указателя на @acronym{API} @dfn{environment},
C @code{struct}, который также имеет поле @code{size}, содержащее размер структуры в
байтах.

Наконец, можно написать модуль, который будет работать со старыми версиями Emacs,
сравнив размер среды, передаваемой Emacs, с известными размерами, например:

@example
  emacs_env *env = ert->get_environment (ert);
  if (env->size >= sizeof (struct emacs_env_26))
    emacs_version = 26;  /* Emacs 26 or later.  */
  else if (env->size >= sizeof (struct emacs_env_25))
    emacs_version = 25;
  else
    return 2; /* Unknown or unsupported version.  */
@end example

@noindent
Это работает, потому что более поздние версии Emacs всегда @emph{добавляют} члены в
среду, никогда не @emph{удаляют} какие-либо члены , поэтому размер может увеличиваться
только с новыми выпусками Emacs.  Учитывая версию Emacs, модуль может использовать
только те части модуля @acronym{API}, которые существовали в этой версии, поскольку
эти части идентичны в более поздних версиях.

Рекомендуется, чтобы модули всегда выполняли проверку совместимости, если только они
не выполняют свою работу полностью в функции инициализации, и не обращаются к
каким-либо объектам Lisp и не используют какие-либо функции Emacs, доступные через
структуру среды.

@item Binding module functions to Lisp symbols
Дает имена функциям модуля, чтобы код Lisp мог вызывать их по этому имени.  Описано,
как это сделать, в @ref{Module Functions} ниже.
@end table
@end deftypefn

@node Module Functions
@subsection Написание Функций Модуля
@cindex writing module functions
@cindex module functions

  Основная причина написания модуля Emacs - сделать дополнительные функции доступными
для программ на Lisp, которые загружают модуль.  В этом подразделе описывается, как
писать такие @dfn{функции модуля}.

Функция модуля имеет следующую общую форму и подпись:

@deftypefn Function emacs_value module_func (emacs_env *@var{env}, ptrdiff_t @var{nargs}, emacs_value *@var{args}, void *@var{data})
Аргумент @var{env} предоставляет указатель на среду @acronym{API}, необходимый для
доступа к объектам и функциям Emacs.  Аргумент @var{nargs} - это необходимое
количество аргументов, которое может быть нулевым (смотреть @code{make_function} ниже
для более гибкого указания номера аргумента), а @var{args} - указатель на массив
аргументов функции.  Аргумент @var{data} указывает на дополнительные данные,
необходимые для функции, которые были упорядочены при вызове @code{make_function}
(смотреть ниже) для создания функции Emacs из @code{module_func}.

Функции модуля используют тип @code{emacs_value} для связи объектов Lisp между Emacs и
модулем (@pxref{Module Values}).  @acronym{API}, описанный ниже и в следующих
подразделах, предоставляет средства для преобразования между базовыми типами данных
C и соответствующими объектами @code{emacs_value}.

Функция модуля всегда возвращает значение.  Если функция возвращается нормально, код
Lisp, который ее вызвал, увидит объект Lisp, соответствующий значению
@code{emacs_value}, которое вернула функция.  Однако, если пользователь набрал
@kbd{C-g}, или если функция модуля или ее вызываемые объекты сигнализировали об ошибке
или выходили (@pxref{Module Nonlocal}) нелокально, Emacs проигнорирует возвращаемое
значение и завершит работу или выбросит, как это происходит, когда код Lisp
встречается с теми же ситуациями.
@end deftypefn

После написания кода C для функции модуля потребуется создать из него объект функции
Lisp, используя функцию @code{make_function}, указатель которой предоставляется в
среде (напоминается, что указатель на среду возвращается функцией
@code{get_environment}).  Обычно это делается в функции инициализации модуля
(@pxref{module initialization function}) после проверки совместимости @acronym{API}.

@deftypefn Function emacs_value make_function (emacs_env *@var{env}, ptrdiff_t @var{min_arity}, ptrdiff_t @var{max_arity}, subr @var{func}, const char *@var{docstring}, void *@var{data})
@vindex emacs_variadic_function
Возвращает функцию Emacs, созданную из функции C @var{func}, сигнатура которой такая
же, как описано для @code{module_func} выше (предполагается, что здесь @code{typedef}
как @code{subr}).  Аргументы @var{min_arity} и @var{max_arity} определяют минимальное
и максимальное количество аргументов, которые может принимать @var{func}.  Аргумент
@var{max_arity} может иметь специальное значение @code{emacs_variadic_function},
которое заставляет функцию принимать неограниченное количество аргументов, как
ключевое слово @code{&rest} в Lisp (@pxref{Argument List}).

Аргумент @var{data} - это способ организовать передачу произвольных дополнительных
данных в @var{func} при её вызове.  Любой указатель, переданный в
@code{make_function}, будет передан в @var{func} без изменений.

Аргумент @var{docstring} указывает строку документации для функции.  Это должна быть
либо строка @acronym{ASCII}, либо строка не-@acronym{ASCII} в кодировке UTF-8, либо
указатель @code{NULL}; в последнем случае у функции не будет документации.  Строка
документации может заканчиваться строкой, определяющей объявленное соглашение о
вызовах, смотреть @ref{Function Documentation}.

Поскольку каждая функция модуля должна принимать указатель на среду в качестве своего
первого аргумента, вызов @code{make_function} может быть выполнен из любой функции
модуля, но обычно требуется сделать это из функции инициализации модуля, чтобы все
функции модуля были известны в Emacs после загрузки модуля.
@end deftypefn

Наконец, нужно привязать функцию Lisp к символу, чтобы код Lisp мог вызывать эту
функцию по имени.  Для этого использовать модуль @acronym{API} функции @code{intern}
(@pxref{intern}), указатель которого также предоставляется в среде, к которой могут
обращаться функции модуля.

Комбинируя вышеперечисленные шаги, код, который организует возможность вызова функции
@code{module_func} в C как @code{module-func} из Lisp, будет выглядеть так, как часть
функции инициализации модуля:

@example
 emacs_env *env = ert->get_environment (ert);
 emacs_value func = env->make_function (env, min_arity, max_arity,
                                        module_func, docstring, data);
 emacs_value symbol = env->intern (env, "module-func");
 emacs_value args[] = @{symbol, func@};
 env->funcall (env, env->intern (env, "defalias"), 2, args);
@end example

@noindent
Это делает символ @code{module-func} известным Emacs, вызывая @code{env->intern}, а
затем вызывается @code{defalias} из Emacs для привязки функции к этому символу.
Обратить внимание, что можно использовать @code{fset} вместо @code{defalias};
различия описаны в @ref{Defining Functions, defalias}.

Используя модуль @acronym{API}, можно определять более сложные функции и типы данных:
интерактивные функции, встроенные функции, макросы и так далее.  Однако результирующий
код C будет громоздким и трудным для чтения.  Поэтому рекомендуется ограничить код
модуля, который создает функции и структуры данных, до абсолютного минимума, а
остальное оставить для пакета Lisp, который будет сопровождать модуль, потому что
выполнение этих дополнительных задач в Lisp намного проще и приведет к гораздо более
читаемому коду.  Например, учитывая функцию модуля @code{module-func}, определенную,
как указано выше, один из способов создания на ее основе интерактивной команды
@code{module-cmd} - это использовать следующую простую оболочку Lisp:

@lisp
(defun module-cmd (&rest args)
  "Строка документации для команды."
  (interactive @var{spec})
  (apply 'module-func args))
@end lisp

Пакет Lisp, который идет с модулем, может затем загрузить модуль, используя примитив
@code{module-load} (@pxref{Dynamic Modules}), когда пакет загружается в Emacs.

@node Module Values
@subsection Преобразование Между Значениями Lisp и Модулем
@cindex module values, conversion

@cindex @code{emacs_value} data type
  За очень немногими исключениями, большинству модулей необходимо обмениваться данными
с программами на Lisp, которые их вызывают: принимать аргументы для функций модуля и
возвращать значения из функций модуля.  Для этой цели модуль @acronym{API}
предоставляет тип @code{emacs_value}, который представляет объекты Emacs Lisp,
передаваемые через @acronym{API}; это функциональный эквивалент типа
@code{Lisp_Object}, который используется в примитивах языка Си в Emacs
(@pxref{Writing Emacs Primitives}).  В этом разделе описываются части модуля
@acronym{API}, которые позволяют создавать объекты @code{emacs_value}, соответствующие
базовым типам данных Lisp, и как получить доступ из данных C в объектах
@code{emacs_value}, которые соответствуют объектам Lisp.

Все функции, описанные ниже, на самом деле являются @emph{указателями на функции},
предоставляемыми через указатель на среду, которую принимает каждая функция модуля.
Следовательно, код модуля должен вызывать эти функции через указатель среды, например:

@example
emacs_env *env;  /* указатель среды */
env->some_function (arguments@dots{});
@end example

@noindent
Указатель @code{emacs_env} обычно поступает из первого аргумента функции модуля или
из вызова @code{get_environment}, если нужна среда в функции инициализации модуля.

Большинство функций, описанных ниже, стали доступны в Emacs 25, первом выпуске Emacs,
который поддерживал динамические модули.  Для тех немногих функций, которые стали
доступны в более поздних выпусках Emacs, упоминается первая версия Emacs, которая их
поддерживала.

Следующие функции @acronym{API} извлекают значения различных типов данных C из
объектов @code{emacs_value}.  Все они вызывают условие ошибки
@code{wrong-type-argument} (@pxref{Type Predicates}), если объект аргумента
@code{emacs_value} не соответствует типу, ожидаемому функцией.
@xref{Module Nonlocal}, где подробно описано, как сигнализация об ошибках работает в
модулях Emacs и как перехватывать ошибки внутри модуля до того, как они будут
переданы в Emacs.  Функция @acronym{API} @code{type_of} (@pxref{Module Misc, type_of})
может использоваться для получения типа объекта @code{emacs_value}.

@deftypefn Function intmax_t extract_integer (emacs_env *@var{env}, emacs_value @var{arg})
Функция возвращает значение целого числа Lisp, заданное @var{arg}.  Тип данных C
возвращаемого значения, @code{intmax_t}, является самым широким интегральным типом
данных, поддерживаемым компилятором C, обычно @w{@code{long long}}.
@end deftypefn

@deftypefn Function double extract_float (emacs_env *@var{env}, emacs_value @var{arg})
Функция возвращает значение числа с плавающей запятой в Lisp, заданное @var{arg}, в
виде значения C @code{double}.
@end deftypefn

@deftypefn Function bool copy_string_contents (emacs_env *@var{env}, emacs_value @var{arg}, char *@var{buf}, ptrdiff_t *@var{len})
Функция сохраняет текст в кодировке UTF-8 строки Lisp, заданной @var{arg}, в массиве
@code{char}, на который указывает @var{buf}, который должен иметь достаточно места для
хранения как минимум @code{*@var{len}} байтов, включая завершающий нулевой байт.
Аргумент @var{len} не должен быть указателем @code{NULL}, и при вызове функции должен
указывать на значение, определяющее размер @var{buf} в байтах.

Если размер буфера, указанный в @code{*@var{len}}, достаточно велик для хранения
текста строки, функция сохраняет в @code{*@var{len}} фактическое количество байтов,
скопированных в @var{buf}, включая завершающий нулевой байт, и возвращает @code{true}.
Если буфер слишком мал, функция вызывает условие ошибки @code{args-out-of-range},
сохраняет необходимое количество байтов в @code{*@var{len}} и возвращает @code{false}.
@xref{Module Nonlocal}, как обрабатывать ошибки ожидания.

Аргумент @var{buf} может быть указателем @code{NULL}, и в этом случае функция
сохраняет в @code{*@var{len}} количество байтов, необходимых для хранения содержимого
@var{arg}, и возвращается @code{true}.  Вот как можно определить размер @var{buf},
необходимый для хранения конкретной строки: сначала вызвать
@code{copy_string_contents} с @code{NULL} как @var{buf}, затем выделить достаточно
памяти для хранения количества байтов, хранимых функцией в @code{*@var{len}}, и снова
вызвать функцию с @var{buf} установленное в не-@code{NULL}, чтобы собственно выполнить
копирование текста.
@end deftypefn

@deftypefn Function emacs_value vec_get (emacs_env *@var{env}, emacs_value @var{vector}, ptrdiff_t @var{index})
Функция возвращает @var{index} элемента в @var{vector}.  @var{index} первого элемента
вектора равен нулю.  Функция вызывает ошибку @code{args-out-of-range}, если значение
@var{index} недопустимо.  Чтобы извлечь данные C из значения, возвращаемого функцией,
использовать другие функции извлечения, описанные здесь, в зависимости от типа данных
Lisp, хранящегося в этом элементе вектора.
@end deftypefn

@deftypefn Function ptrdiff_t vec_size (emacs_env *@var{env}, emacs_value @var{vector})
Функция возвращает количество элементов в @var{vector}.
@end deftypefn

@deftypefn Function void vec_set (emacs_env *@var{env}, emacs_value @var{vector}, ptrdiff_t @var{index}, emacs_value @var{value})
Функция сохраняет @var{value} в элементе @var{vector} с индексом @var{index}.
Вызывается ошибка @code{args-out-of-range}, если значение @var{index} недопустимо.
@end deftypefn

Следующие функции @acronym{API} создают объекты @code{emacs_value} из базовых типов
данных C.  Все они возвращают созданный объект @code{emacs_value}.

@deftypefn Function emacs_value make_integer (emacs_env *@var{env}, intmax_t @var{n})
Функция принимает целочисленный аргумент @var{n} и возвращает соответствующий объект
@code{emacs_value}.  Это вызывает условие ошибки @code{overflow-error}, если значение
@var{n} не может быть представлено как целое число Emacs, то есть@: не находится в
пределах, установленных @code{most-negative-fixnum} и @code{most-positive-fixnum}.
(@pxref{Integer Basics}).
@end deftypefn

@deftypefn Function emacs_value make_float (emacs_env *@var{env}, double @var{d})
Функция принимает аргумент @code{double} @var{d} и возвращает соответствующее значение
Emacs с плавающей запятой.
@end deftypefn

@deftypefn Function emacs_value make_string (emacs_env *@var{env}, const char *@var{str}, ptrdiff_t @var{strlen})
Функция создает строку Emacs из текстовой строки C, на которую указывает @var{str},
длина которой в байтах, не включая завершающий нулевой байт, равна @var{strlen}.
Исходная строка в @var{str} может быть строкой @acronym{ASCII} или строкой
не-@acronym{ASCII} в кодировке UTF-8; может включать встроенные нулевые байты и не
должна заканчиваться завершающим нулевым байтом в @code{@var{str}[@var{strlen}]}.
Функция вызывает условие ошибки @code{overflow-error}, если @var{strlen} отрицательно
или превышает максимальную длину строки Emacs.
@end deftypefn

@acronym{API} не предоставляет функций для управления структурами данных Lisp,
например, создания списков с помощью @code{cons} и @code{list}
(@pxref{Building Lists}), извлечения членов списка с помощью @code{car} и @code{cdr}
(@pxref{List Elements}), создания векторов с помощью @code{vector}
(@pxref{Vector Functions}) и так далее.  Для этого использовать @code{intern} и
@code{funcall}, описанно в следующем подразделе, для вызова соответствующих функций
Lisp.

Обычно у объектов @code{emacs_value} довольно короткое время жизни: оно заканчивается,
когда указатель @code{emacs_env}, использованный для их создания, выходит за пределы
области видимости.  Иногда может потребоваться создать объекты
@dfn{глобальные ссылки}: @code{emacs_value}, которые живут столько, сколько нужно.
Использовать следующие две функции для управления такими объектами.

@deftypefn Function emacs_value make_global_ref (emacs_env *@var{env}, emacs_value @var{value})
Функция возвращает глобальную ссылку для @var{value}.
@end deftypefn

@deftypefn Function void free_global_ref (emacs_env *@var{env}, emacs_value @var{global_value})
Функция освобождает @var{global_value}, ранее созданное @code{make_global_ref}.
@var{global_value} больше не действует после вызова.  Код модуля должен связывать
каждый вызов @code{make_global_ref} с соответствующим @code{free_global_ref}.
@end deftypefn

@cindex user pointer, using in module functions
Альтернативой хранению структур данных C, которые необходимо передать функциям модуля
позже, является создание объектов @dfn{пользовательские указатели}.  Пользовательский
указатель или объект @code{user-ptr} - это объект Lisp, который инкапсулирует указатель C и может иметь связанную функцию финализатора, которая вызывается, когда объект
(@pxref{Garbage Collection}) собирает мусор.  Модуль @acronym{API} предоставляет
функции для создания и доступа к объектам @code{user-ptr}.  Эти функции вызывают
состояние ошибки @code{wrong-type-argument}, если они вызываются со значением
@code{emacs_value}, которым не представляется объект @code{user-ptr}.

@deftypefn Function emacs_value make_user_ptr (emacs_env *@var{env}, emacs_finalizer @var{fin}, void *@var{ptr})
Функция создает и возвращает объект @code{user-ptr}, который обертывает указатель C
@var{ptr}.  Функция финализатора @var{fin} может быть указателем @code{NULL} (что
означает отсутствие финализатора) или может быть функцией следующей сигнатуры:

@example
typedef void (*emacs_finalizer) (void *@var{ptr});
@end example

@noindent
Если @var{fin} не является указателем @code{NULL}, будет вызываться с @var{ptr} в
качестве аргумента при сборке мусора для объекта @code{user-ptr}.  Не запускать
дорогостоящий код в финализаторе, потому что сборщик мусора должен завершать работу
быстро, чтобы Emacs оставался отзывчивым.
@end deftypefn

@deftypefn Function void *get_user_ptr (emacs_env *@var{env}, emacs_value val)
Функция извлекает указатель C из объекта Lisp, представленный значением @var{val}.
@end deftypefn

@deftypefn Function void set_user_ptr (emacs_env *@var{env}, emacs_value @var{value}, void *@var{ptr})
Функция устанавливает указатель C, встроенный в объект @code{user-ptr}, представленный
@var{value}, указателем @var{ptr}.
@end deftypefn

@deftypefn Function emacs_finalizer get_user_finalizer (emacs_env *@var{env}, emacs_value val)
Функция возвращает финализатор объекта @code{user-ptr}, представленного значения
@var{val}, или @code{NULL}, если у него нет финализатора.
@end deftypefn

@deftypefn Function void set_user_finalizer (emacs_env *@var{env}, emacs_value @var{val}, emacs_finalizer @var{fin})
Функция изменяет финализатор объекта @code{user-ptr}, представленного значения
@var{val}, на @var{fin}.  Если @var{fin} является указателем на @code{NULL}, объект
@code{user-ptr} не будет иметь финализатора.
@end deftypefn

@node Module Misc
@subsection Разные Удобные Функции для Модулей

  В этом подразделе описываются несколько удобных функций, предоставляемых модулем
@acronym{API}.  Как и функции, описанные в предыдущих подразделах, все они на самом
деле являются указателями на функции и должны вызываться через указатель
@code{emacs_env}.  Описание функций, которые были представлены после того, как Emacs
25 вызывает первую версию, в которой они стали доступны.

@deftypefn Function bool eq (emacs_env *@var{env}, emacs_value @var{val1}, emacs_value @var{val2})
Функция возвращает @code{true}, если объекты Lisp, представленные @var{val1} и
@var{val2}, идентичны, в противном случае - @code{false}.  Это то же самое, что и
функция Lisp @code{eq} (@pxref{Equality Predicates}), но исключает необходимость
интернировать объекты, представленные аргументами.

Для других предикатов равенства нет функций @acronym{API}, поэтому нужно будет
использовать @code{intern} и @code{funcall}, описанный ниже, для выполнения более
сложных тестов на равенство.
@end deftypefn

@deftypefn Function bool is_not_nil (emacs_env *@var{env}, emacs_value @var{val})
Функция проверяет, является ли объект Lisp, представленный @var{val}, не-@code{nil};
это соответственно возвращает @code{true} или @code{false}.

Обратить внимание, что можно реализовать эквивалентный тест, используя @code{intern},
чтобы получить @code{emacs_value}, представляющий @code{nil}, а затем использовать
@code{eq}, описанный выше, для проверки равенства.  Но пользоваться этой функцией
удобнее.
@end deftypefn

@deftypefn Function emacs_value type_of (emacs_env *@var{env}, emacs_value @code{object})
Функция возвращает тип @var{object} как значение, представляющее символ: @code{string}
для строки, @code{integer} для целого числа, @code{process} для процесса и так далее.
Можно использовать @code{intern} и @code{eq} для сравнения с символами известного
типа, если код должен зависеть от типа объекта.
@end deftypefn

@anchor{intern}
@deftypefn Function emacs_value intern (emacs_env *@var{env}, const char *name)
Функция возвращает интернированный символ Emacs с именем @var{name}, который должен
быть строкой @acronym{ASCII} с завершающим нулем.  Это создает новый символ, если он
еще не существует.

Вместе с @code{funcall}, описанным ниже, эта функция предоставляет средства для
вызова любой функции Emacs, вызываемой Lisp, при условии, что ее имя является чистой
строкой @acronym{ASCII}.  Например, вот как интернировать не-@acronym{ASCII} символ с
именем @code{name_str} , вызвав более мощную функцию @code{intern} в Emacs
(@pxref{Creating Symbols}):

@example
emacs_value fintern = env->intern (env, "intern");
emacs_value sym_name =
  env->make_string (env, name_str, strlen (name_str));
emacs_value intern_args[] = @{ sym_name, env->intern (env, "nil") @};
emacs_value symbol = env->funcall (env, fintern, 2, intern_args);
@end example

@end deftypefn

@deftypefn Function emacs_value funcall (emacs_env *@var{env}, emacs_value @var{func}, ptrdiff_t @var{nargs}, emacs_value *@var{args})
Функция вызывает указанную @var{func}, передавав аргументы @var{nargs} из массива, на
который указывает @var{args}.  Аргумент @var{func} может быть символом функции
(например, возвращенным @code{intern}, описанным выше), функцией модуля, возвращаемой
@code{make_function} (@pxref{Module Functions}), подпрограммой, написанной на C, и так
далее.  Если @var{nargs} равно нулю, @var{args} может быть указателем @code{NULL}.

Функция возвращает значение, возвращаемое @var{func}.
@end deftypefn

Если модуль включает потенциально длительный код, рекомендуется время от времени
проверять в этом коде, хочет ли пользователь выйти, например, набрав @kbd{C-g}
(@pxref{Quitting}).  Для этой цели предусмотрена следующая функция, доступная начиная
с Emacs 26.1.

@anchor{should_quit}
@deftypefn Function bool should_quit (emacs_env *@var{env})
Функция возвращает @code{true}, если пользователь хочет выйти.  В этом случае
рекомендуется, чтобы функция модуля прервала любую текущую обработку и вернулась как
можно скорее.
@end deftypefn

@node Module Nonlocal
@subsection Нелокальные Выходы в Модулях
@cindex nonlocal exits, in modules

  Emacs Lisp поддерживает нелокальные выходы, посредством которых управление
программой передается от одной точки программы к другой удаленной точке.
@xref{Nonlocal Exits}.  Таким образом, функции Lisp, вызываемые модулем, могут
завершаться нелокально, вызывая @code{signal} или @code{throw}, и функции модуля
должны правильно обрабатывать такие нелокальные выходы.  Такая обработка необходима,
потому что программы на C не будут автоматически освобождать ресурсы и выполнять
другие операции очистки в этих случаях; код модуля должен это делать сам.  Модуль
@acronym{API} предоставляет для этого средства, описанные в этом подразделе.  Это
обычно доступно, начиная с Emacs 25; те из них, которые стали доступны в более поздних
выпусках, явно вызывают первую версию Emacs, в которой они стали частью @acronym{API}.

Когда некоторый код Lisp, вызываемый функцией модуля, сигнализирует об ошибке или
выдает ошибку, нелокальный выход перехватывается, а ожидающий выход и связанные с ним
данные сохраняются в среде.  Когда в среде ожидается нелокальный выход, любая функция
модуля @acronym{API}, вызываемая с указателем на эту среду, немедленно вернется без
какой-либо обработки (функции @code{non_local_exit_check}, @code{non_local_exit_get} и
@code{non_local_exit_clear} являются исключениями из этого правила).  Если функция
модуля затем ничего не делает и возвращается в Emacs, ожидающий нелокальный выход
заставит Emacs действовать в соответствии с ней: сигнализировать об ошибке или
перенаправлять в соответствующий @code{catch}.

Итак, самым простым ``умением обращаться'' с нелокальными выходами в функциях модуля -
это не делать ничего особенного и позволить остальной части кода работать, как будто
ничего не произошло.  Однако это может вызвать два класса проблем:

@itemize @minus
@item
Функция модуля может использовать неинициализированные или неопределенные значения,
поскольку функции @acronym{API} возвращаются немедленно, не давая ожидаемых
результатов.

@item
В модуле может произойти утечка ресурсов, потому что у него может не быть возможности
освободить их.
@end itemize

Поэтому рекомендуется, чтобы функции модуля проверяли наличие нелокальных условий
выхода и восстанавливались после них, используя функции, описанные ниже.

@deftypefn Function enum emacs_funcall_exit non_local_exit_check (emacs_env *@var{env})
Функция возвращает вид нелокального условия выхода, хранящегося в @var{env}.
Возможные значения:

@vindex emacs_funcall_exit@r{, enumeration}
@vtable @code
@item emacs_funcall_exit_return
Последняя функция @acronym{API} завершилась нормально.
@item emacs_funcall_exit_signal
Последняя функция @acronym{API} сообщила об ошибке.
@item emacs_funcall_exit_throw
Последняя функция @acronym{API} завершилась через @code{throw}.
@end vtable
@end deftypefn

@deftypefn Function emacs_funcall_exit non_local_exit_get (emacs_env *@var{env}, emacs_value *@var{symbol}, emacs_value *@var{data})
Функция возвращает вид нелокального условия выхода, хранящегося в @var{env}, как и
@code{non_local_exit_check}, но также возвращает полную информацию о нелокальном
выходе, если таковая имеется.  Если возвращаемое значение -
@code{emacs_funcall_exit_signal}, функция сохраняет символ ошибки в
@code{*@var{symbol}}, а данные ошибки - в @code{*@var{data}}
(@pxref{Signaling Errors}).  Если возвращаемое значение -
@code{emacs_funcall_exit_throw}, функция сохраняет символ тега @code{catch} в
@code{*@var{symbol}} и значение @code{throw} в @code{*@var{data}}.  Функция не
сохраняет ничего в памяти, на которую указывают эти аргументы, если возвращаемое
значение - @code{emacs_funcall_exit_return}.
@end deftypefn

Потребуется проверять нелокальные условия выхода там, где это важно: перед выделением
некоторого ресурса или после выделения ресурса, который может нуждаться в
освобождении, или когда сбой означает, что дальнейшая обработка невозможна или
неосуществима.

Как только функция модуля обнаружила, что нелокальный выход ожидает обработки, она
может либо вернуться в Emacs (после выполнения необходимой локальной очистки), либо
попытаться восстановиться после нелокального выхода.  Следующие функции @acronym{API}
помогут с этими задачами.

@deftypefn Function void non_local_exit_clear (emacs_env *@var{env})
Функция очищает отложенные нелокальные условия выхода и данные из @var{env}.  После
её вызова функции модуля @acronym{API} будут работать нормально.  Использовать эту
функцию, если функция модуля может восстанавливаться после нелокальных выходов функций
Lisp, которые она вызывает и продолжает, а также перед вызовом любой из следующих двух
функций (или любых других функций @acronym{API}, если требуется, чтобы они выполняли
свою предполагаемую обработку, когда нелокальный ожидается выход).
@end deftypefn

@deftypefn Function void non_local_exit_throw (emacs_env *@var{env}, emacs_value @var{tag}, emacs_value @var{value})
Функция бросает в Lisp символ @code{catch}, представленный @var{tag}, передавая ему
@var{value} в качестве возвращаемого значения.  Как правило, функция модуля должна
вернуться вскоре после вызова этой функции.  Одно из применений этой функции - когда
требуется повторно вызвать нелокальный выход из одной из вызываемых функций
@acronym{API} или Lisp.
@end deftypefn

@deftypefn Function void non_local_exit_signal (emacs_env *@var{env}, emacs_value @var{error}, emacs_value @var{data})
Функция сигнализирует об ошибке, представленной @var{error}, с указанными данными об
ошибке @var{data}.  Функция модуля должна вернуться вскоре после вызова этой функции.
Функция может быть полезна, например, для передачи сообщений об ошибках от функций
модуля в Emacs.
@end deftypefn


@node Object Internals
@section Внутреннее Устройство Объекта
@cindex object internals

  Emacs Lisp предоставляет богатый набор типов данных.  Некоторые из них, например
cons-ячейки, целые числа и строки, являются общими почти для всех диалектов Lisp.
Некоторые другие, такие как маркеры и буферы, являются совершенно особенными и
необходимы для обеспечения базовой поддержки для написания команд редактора в Lisp.
Чтобы реализовать такое разнообразие типов объектов и обеспечить эффективный способ
передачи объектов между подсистемами интерпретатора, существует набор структур данных
C и специальный тип для представления указателей на все из них, известный как
@dfn{помеченный указатель}.

  В C помеченный указатель - это объект типа @code{Lisp_Object}.  Любая
инициализированная переменная такого типа всегда содержит значение одного из следующих
основных типов данных: целое число, символ, строка, cons-ячейка, float, векторный или
другой объект.  Каждый из этих типов данных имеет соответствующее значение тега.  Все
теги нумеруются @code{enum Lisp_Type} и помещаются в 3-битное битовое поле
@code{Lisp_Object}.  Остальные биты - это само значение.  Целые числа являются
немедленными, то есть непосредственно представлены этими @dfn{битовыми значениями}, а
все другие объекты представлены указателями C на соответствующий объект, выделенный
из среды.  Ширина @code{Lisp_Object} зависит от платформы и конфигурации: обычно она
равна ширине указателя базовой платформы (то есть 32-битная на 32-битной машине и
64-битная на 64-битной), но также и там. - это специальная конфигурация, в которой
@code{Lisp_Object} является 64-битным, но все указатели 32-битными.  Последний прием
был разработан для преодоления ограниченного диапазона значений целых чисел Lisp в
32-битной системе с использованием 64-битного типа @code{long long} для
@code{Lisp_Object}.\

  Следующие структуры данных C определены в @file{lisp.h} для представления основных
типов данных помимо целых чисел:

@table @code
@item struct Lisp_Cons
Cons-ячейка, объект, используемый для построения списков.

@item struct Lisp_String
Строка, основной объект для представления последовательности символов.

@item struct Lisp_Vector
Массив, набор объектов Lisp фиксированного размера, к которым можно получить доступ
с помощью индекса.

@item struct Lisp_Symbol
Символ - объект с уникальным именем, обычно используемый в качестве идентификатора.

@item struct Lisp_Float
Значение с плавающей запятой.

@item union Lisp_Misc
Разные типы объектов, не подходящие ни для одного из вышеперечисленных.
@end table

  Эти типы являются первоклассными гражданами внутренней системы типов.  Поскольку
пространство тегов ограничено, все остальные типы являются подтипами либо
@code{Lisp_Vectorlike} либо @code{Lisp_Misc}.  Подтипы векторов перечислены
@code{enum pvec_type}, и почти все сложные объекты, такие как окна, буферы, фреймы и
процессы, попадают в эту категорию.  Остальные специальные типы, включая маркеры и
наложения, нумеруются @code{enum Lisp_Misc_Type} и образуют набор подтипов
@code{Lisp_Misc}.

  Ниже приводится описание нескольких подтипов @code{Lisp_Vectorlike}.  Объект Buffer
представляет текст для отображения и редактирования.  Окно - это часть структуры
отображения, которая показывает буфер или используется как контейнер для рекурсивного
размещения других окон в том же фрейме.  (Не путать объект окна Emacs Lisp с окном
как объектом, управляемым системой пользовательского интерфейса, такой как X; в
терминологии Emacs последний называется фреймом.)  Наконец, объект процесса
используется для управления подпроцессами.

@menu
* Buffer Internals::    Компоненты буферной структуры.
* Window Internals::    Компоненты оконной конструкции.
* Process Internals::   Компоненты структуры процесса.
@end menu

@node Buffer Internals
@subsection Внутреннее Устройство Буфера
@cindex internals, of buffer
@cindex buffer internals

  Две структуры (смотреть @file{buffer.h}) используются для представления буферов в
C@.  Структура @code{buffer_text} содержит поля, описывающие текст буфера; структура
@code{buffer} содержит другие поля.  В случае косвенных буферов две или более
структуры @code{buffer} ссылаются на одну и ту же структуру @code{buffer_text}.

Вот некоторые из полей в @code{struct buffer_text}:

@table @code
@item beg
Адрес содержимого буфера.  Содержимое буфера представляет собой линейный C-массив
@code{char} с промежутком где-то посередине.

@item gpt
@itemx gpt_byte
Позиции символа и байта в буферном пространстве.  @xref{Buffer Gap}.

@item z
@itemx z_byte
Позиции символа и байта конца текста буфера.

@item gap_size
Размер буферного пространства.  @xref{Buffer Gap}.

@item modiff
@itemx save_modiff
@itemx chars_modiff
@itemx overlay_modiff
Эти поля подсчитывают количество событий модификации буфера, выполненных в этом
буфере.  @code{modiff} увеличивается после каждого события модификации буфера и
никогда не изменяется; @code{save_modiff} содержит значение @code{modiff} при
последнем посещении или сохранении буфера; @code{chars_modiff} учитывает только
модификации символов в буфере, игнорируя все другие виды изменений (например,
свойства текста); а @code{overlay_modiff} учитывает только модификации наложения
буфера.

@item beg_unchanged
@itemx end_unchanged
Количество символов в начале и конце текста, которые, как известно, не изменились с
момента последнего полного повторного отображения.

@item unchanged_modified
@itemx overlay_unchanged_modified
Значения @code{modiff} и @code{overlay_modiff}, соответственно, после последнего
полного повторного отображения.  Если их текущие значения совпадают с @code{modiff}
или @code{overlay_modiff}, это означает, что @code{beg_unchanged} и
@code{end_unchanged} не содержит полезной информации.

@item markers
Маркеры, относящиеся к этому буферу.  На самом деле это единственный маркер, и
последовательные элементы в его маркере @code{chain} являются другими маркерами,
относящимися к этому тексту буфера.

@item intervals
Дерево интервалов, которое записывает текстовые свойства этого буфера.
@end table

Вот некоторые из полей @code{struct buffer}:

@table @code
@item header
Заголовок типа @code{union vectorlike_header} является общим для всех векторных
объектов.

@item own_text
Структура @code{struct buffer_text}, которая обычно хранит содержимое буфера.  В
косвенных буферах это поле не используется.

@item text
Указатель на структуру @code{buffer_text} для этого буфера.  В обычном буфере это
поле @code{own_text} описано выше.  В косвенном буфере это поле @code{own_text}
базового буфера.

@item next
Указатель на следующий буфер в цепочке всех буферов, включая уничтоженные буферы.  Эта
цепочка используется только для выделения и сборки мусора, чтобы правильно собирать
уничтоженные буферы.

@item pt
@itemx pt_byte
Позиции символа и байта точки в буфере.

@item begv
@itemx begv_byte
Позиции символа и байта начала доступного диапазона текста в буфере.

@item zv
@itemx zv_byte
Позиции символа и байта конца доступного диапазона текста в буфере.

@item base_buffer
В косвенном буфере это указывает на базовый буфер.  В обычном буфере это равно нулю.

@item local_flags
Поле содержит флаги, указывающие, что определенные переменные являются локальными в
этом буфере.  Такие переменные объявляются в коде C с помощью
@code{DEFVAR_PER_BUFFER}, и их привязки к локальному буферу хранятся в полях самой
структуры буфера.  (Некоторые из этих полей описаны в этой таблице.)

@item modtime
Время модификации посещенного файла.  Устанавливается, когда файл записывается или
читается.  Перед записью буфера в файл это поле сравнивается со временем модификации
файла, чтобы увидеть, изменился ли файл на диске.  @xref{Buffer Modification}.

@item auto_save_modified
Время последнего автоматического сохранения буфера.

@item last_window_start
@code{window-start} позиция в буфере на момент последнего отображения буфера в окне.

@item clip_changed
Флаг указывает, что в буфере изменилось сужение.
@xref{Narrowing}.

@item prevent_redisplay_optimizations_p
Флаг указывает, что не следует использовать оптимизацию повторного отображения для
отображения этого буфера.

@item overlay_center
Поле содержит текущее положение центра наложения.  @xref{Managing Overlays}.

@item overlays_before
@itemx overlays_after
Поля содержат, соответственно, список наложений, которые заканчиваются в текущем
центре наложения или перед ним, и список наложений, которые заканчиваются после
текущего центра наложения.  @xref{Managing Overlays}.  @code{overlays_before}
сортируется в порядке убывания конечной позиции, а @code{overlays_after} сортируется
в порядке увеличения начальной позиции.

@c FIXME? следующие теперь все Lisp_Object BUFFER_INTERNAL_FIELD (foo).

@item name
Строка Lisp, которая называет буфер.  Гарантируется уникальность.
@xref{Buffer Names}.  Это и следующие поля имеют свои имена в определении структуры C,
оканчивающиеся на @code{_}, чтобы указать, что к ним следует обращаться не напрямую, а
через макрос @code{BVAR}, например:

@example
  Lisp_Object buf_name = BVAR (buffer, name);
@end example

@item save_length
Длина файла, который посещает этот буфер, при последнем чтении или сохранении.  Может
иметь 2 специальных значения: @minus{}1 означает, что автосохранение в этом буфере
отключено, а @minus{}2 означает, что автосохранение не отключается, если текст в
буфере сильно сжимается.  Это и другие поля, связанные с сохранением, не хранятся в
структуре @code{buffer_text}, потому что косвенные буферы никогда не сохраняются.

@item directory
Каталог для раскрытия относительных имен файлов.  Это значение переменной
@code{default-directory} (@pxref{File Name Expansion}), локально в буфере.

@item filename
Имя файла, посещенного в этом буфере, или @code{nil}.  Это значение переменной
@code{buffer-file-name}, локально в буфере.  (@pxref{Buffer File Name}).

@item undo_list
@itemx backed_up
@itemx auto_save_file_name
@itemx auto_save_file_format
@itemx read_only
@itemx file_format
@itemx file_truename
@itemx invisibility_spec
@itemx display_count
@itemx display_time
В этих полях хранятся значения переменных Lisp, которые автоматически становятся
локальными в буфере (@pxref{Buffer-Local Variables}), чьи соответствующие имена
переменных имеют дополнительный префикс @code{buffer-} и имеют символы подчеркивания,
замененные дефисами.  Например, @code{undo_list} хранит значение
@code{buffer-undo-list}.

@item mark
Отметка для буфера.  Метка является маркером, поэтому она также включена в список
@code{markers}.  @xref{The Mark}.

@item local_var_alist
Список ассоциаций, описывающий привязки локальных переменных этого буфера, за
исключением встроенных локальных привязок буфера, которые имеют специальные слоты в
объекте буфера.  (Эти слоты не указаны в этой таблице.)
@xref{Buffer-Local Variables}.

@item major_mode
Символ, обозначающий основной режим этого буфера, например, @code{lisp-mode}.

@item mode_name
Красивое название основного режима, например, @code{"Lisp"}.

@item keymap
@itemx abbrev_table
@itemx syntax_table
@itemx category_table
@itemx display_table
В этих полях хранится локальная ключевая карта (@pxref{Keymaps}), таблица сокращений
(@pxref{Abbrev Tables}), таблица синтаксиса (@pxref{Syntax Tables}), таблица
категорий (@pxref{Categories}) и таблица отображения (@pxref{Display Tables}).

@item downcase_table
@itemx upcase_table
@itemx case_canon_table
В этих полях хранятся таблицы преобразования для преобразования текста в нижний и
верхний регистры, а также для канонизации текста для поиска по регистру.
@xref{Case Tables}.

@item minor_modes
Список второстепенных режимов этого буфера.

@item pt_marker
@itemx begv_marker
@itemx zv_marker
Поля используются только в косвенном буфере или в буфере, который является основой
косвенного буфера.  Каждый содержит маркер, который записывает @code{pt}, @code{begv}
и @code{zv} соответственно для этого буфера, когда буфер не является текущим.

@item mode_line_format
@itemx header_line_format
@itemx case_fold_search
@itemx tab_width
@itemx fill_column
@itemx left_margin
@itemx auto_fill_function
@itemx truncate_lines
@itemx word_wrap
@itemx ctl_arrow
@itemx bidi_display_reordering
@itemx bidi_paragraph_direction
@itemx selective_display
@itemx selective_display_ellipses
@itemx overwrite_mode
@itemx abbrev_mode
@itemx mark_active
@itemx enable_multibyte_characters
@itemx buffer_file_coding_system
@itemx cache_long_line_scans
@itemx point_before_scroll
@itemx left_fringe_width
@itemx right_fringe_width
@itemx fringes_outside_margins
@itemx scroll_bar_width
@itemx indicate_empty_lines
@itemx indicate_buffer_boundaries
@itemx fringe_indicator_alist
@itemx fringe_cursor_alist
@itemx scroll_up_aggressively
@itemx scroll_down_aggressively
@itemx cursor_type
@itemx cursor_in_non_selected_windows
В этих полях хранятся значения переменных Lisp, которые автоматически становятся
локальными в буфере (@pxref{Buffer-Local Variables}), чьи соответствующие имена
переменных имеют символы подчеркивания, замененные дефисами.  Например,
@code{mode_line_format} хранит значение @code{mode-line-format}.

@item last_selected_window
Это последнее окно, которое было выбрано с этим буфером в нем, или @code{nil}, если
это окно больше не отображает этот буфер.
@end table

@node Window Internals
@subsection Внутреннее Устройство Окна
@cindex internals, of window
@cindex window internals

  Поля окна (полный список смотреть в определении @code{struct window} в
@file{window.h}) включают:

@table @code
@item frame
Фрейм, на котором находится это окно, как объект Lisp.

@item mini
Ненулевое значение, если это окно является окном минибуфера, окном, показывающим
минибуфер или эхо-область.

@item pseudo_window_p
@cindex pseudo window
Ненулевое значение, если это окно @dfn{псевдоокно}.  Псевдоокно - это либо окно,
используемое для отображения строки меню или панели инструментов (когда Emacs
использует наборы инструментов, которые не отображают собственную строку меню и
панель инструментов), либо окно, показывающее всплывающую подсказку во фрейме
всплывающей подсказки.  Псевдоокна обычно недоступны из кода Lisp.

@item parent
Внутри Emacs выстраивает окна в виде дерева; у каждой группы братьев и сестер есть
родительское окно, область которого включает всех братьев и сестер.  Это поле
указывает на родителя окна в этом дереве как на объект Lisp.  Для корневого окна
дерева и окна минибуфера это всегда @code{nil}.

Родительские окна не отображают буферы и играют небольшую роль в отображении, за
исключением формирования своих дочерних окон.  Программы Emacs Lisp не могут напрямую
управлять родительскими окнами; они работают с окнами на листьях дерева, которые
фактически отображают буферы.

@item contents
Для оконного листа и окон, показывающих всплывающую подсказку, это буфер, как объект
Lisp, который окно отображает.  Для внутреннего (родительского) окна это его первое
дочернее окно.  Для псевдоокна, показывающего меню или панель инструментов, это
@code{nil}.  Это также @code{nil} для окна, которое было удалено.

@item next
@itemx prev
Следующий и предыдущий брат этого окна как объекты Lisp.  @code{next} имеет значение
@code{nil}, если окно является самым правым или самым нижним в своей группе;
@code{prev} является @code{nil}, если самый левый или самый верхний член в своей
группе.  То, находится ли брат левее/правее или выше/ниже, определяется полем
@code{horizontal} родительского элемента: если оно не равно нулю, то братья и сестры
располагаются горизонтально.

В качестве особого случая @code{next} корневого окна фрейма указывает на окно
минибуфера фрейма, при условии, что это не фрейм, состоящий только из минибуфера или
который не имеет минибуфера.  На таких фреймах @code{prev} окна минибуфера указывает
на корневое окно этого фрейма.  В любом другом случае поля @code{next} корневого окна
и @code{prev} окна минибуфера (если есть) имеют значение @code{nil}.

@item left_col
Левый край окна, измеряемый в столбцах, относительно самого левого столбца (столбец 0)
собственного фрейма окна.

@item top_line
Верхний край окна, измеряемый в строках, относительно самой верхней линии (строка 0)
собственного фрейма окна.

@item pixel_left
@itemx pixel_top
Левый и верхний края этого окна, измеряемые в пикселях, относительно верхнего левого
угла (0, 0) собственного фрейма окна.

@item total_cols
@itemx total_lines
Общая ширина и высота окна, измеренная в столбцах и строках соответственно.  Значения
включают полосы прокрутки и полосы, разделители и/или разделительную линию в правой
части окна (если есть).

@item pixel_width;
@itemx pixel_height;
Общая ширина и высота окна в пикселях.

@item start
Маркер, указывающий на позицию в буфере, которая является первым символом (в
логическом порядке @pxref{Bidirectional Display}), отображаемым в окне.

@item pointm
@cindex window point internals
Значение точки в текущем буфере, когда выбрано это окно; когда не выбрано, сохраняется
предыдущее значение.

@item old_pointm
Значение @code{pointm} во время последнего повторного отображения.

@item force_start
Если этот флаг - не-@code{nil}, это говорит о том, что окно было явно прокручено
программой Lisp, и значение @code{start} окна было установлено для повторного
отображения для согласования.  Это влияет на то, что делает следующее повторное
отображение, если точка находится за пределами экрана: вместо прокрутки окна, чтобы
показать текст вокруг точки, перемещается точка в место, которое находится на экране.

@item optional_new_start
Похоже на @code{force_start}, но следующее повторное отображение будет выполняться
только в том случае, если точка остается видимой.

@item start_at_line_beg
Не-@code{nil} означает, что текущее значение @code{start} было началом строки при
его выборе.

@item use_time
Последний раз, когда было выбрано окно.  Функция @code{get-lru-window} использует это
поле.

@item sequence_number
Уникальный номер, присвоенный этому окну при его создании.

@item last_modified
@code{modiff} буфера окна на момент последнего завершения повторного отображения в
этом окне.

@item last_overlay_modified
@code{overlay_modiff} буфера окна на момент последнего завершения повторного
отображения в этом окне.

@item last_point
Значение точки в буфере на момент последнего повторного отображения в этом окне.

@item last_had_star
Ненулевое значение означает, что буфер окна был изменен при последнем обновлении окна.

@item vertical_scroll_bar_type
@itemx horizontal_scroll_bar_type
Типы вертикальной и горизонтальной полос прокрутки этого окна.

@item scroll_bar_width
@itemx scroll_bar_height
Ширина вертикальной полосы прокрутки этого окна и высота горизонтальной полосы
прокрутки этого окна в пикселях.

@item left_margin_cols
@itemx right_margin_cols
Ширина левого и правого полей в этом окне.  Нулевое значение означает отсутствие
оконтовки.

@item left_fringe_width
@itemx right_fringe_width
Ширина в пикселях левой и правой оконтовки в этом окне.  Значение @minus{}1 означает
использование значений фрейма.

@item fringes_outside_margins
Ненулевое значение означает полосы за пределами полей дисплея; в других положениях они
находятся между полем и текстом.

@item window_end_pos
Вычисляется как @code{z} минус буферная позиция последнего глифа в текущей матрице
окна.  Значение допустимо, только если @code{window_end_valid} не равно нулю.

@item window_end_bytepos
Позиция байта, соответствующая @code{window_end_pos}.

@item window_end_vpos
Вертикальное положение строки, содержащей @code{window_end_pos}.

@item window_end_valid
В этом поле устанавливается ненулевое значение, если @code{window_end_pos} и
@code{window_end_vpos} являются действительными.  Это значение равно нулю, если
нетривиальное повторное отображение отменяется, поскольку в этом случае отображение,
для которого был вычислено @code{window_end_pos}, не попадает на экран.

@item cursor
Структура, описывающая, где находится курсор в этом окне.

@item last_cursor_vpos
Вертикальное положение строки, показывающей курсор, относительно окна на момент
последнего завершенного повторного отображения.

@item phys_cursor
Структура, описывающая, где физически находится курсор этого окна.

@item phys_cursor_type
@c FIXME Что это?
@c itemx phys_cursor_ascent
@itemx phys_cursor_height
@itemx phys_cursor_width
Тип, высота и ширина курсора, с которыми последний раз отображался в этом окне.

@item phys_cursor_on_p
Поле не равно нулю, если курсор физически включен.

@item cursor_off_p
Ненулевое значение означает, что курсор в этом окне логически выключен.  Используется
для мигания курсора.

@item last_cursor_off_p
Поле содержит значение @code{cursor_off_p} на момент последнего повторного
отображения.

@item must_be_updated_p
Устанавливается в 1 во время повторного отображения, когда это окно необходимо
обновить.

@item hscroll
Количество столбцов, по которым изображение в окне прокручивается по горизонтали
влево.  Обычно это 0.  Когда прокручивается только текущая строка, это описывает,
насколько прокручивается текущая строка.

@item min_hscroll
Минимальное значение @code{hscroll}, задаваемое пользователем через
@code{set-window-hscroll} (@pxref{Horizontal Scrolling}).  Когда прокручивается только
текущая строка, это описывает горизонтальную прокрутку строк, отличных от текущей.

@item vscroll
Величина вертикальной прокрутки в пикселях.  Обычно это 0.

@item dedicated
Не-@code{nil}, если это окно предназначено для своего буфера.

@item combination_limit
Предел комбинации этого окна, имеющий значение только для родительского окна.  Если
это @code{t}, то нельзя удалить это окно и повторно объединить его дочерние окна с
другими братьями и сестрами этого окна.

@item window_parameters
Список параметров этого окна.

@item display_table
Таблица отображения окна или @code{nil}, если для него ничего не указано.

@item update_mode_line
Ненулевое значение означает, что строку режима этого окна необходимо обновить.

@item mode_line_height
@itemx header_line_height
Высота в пикселях строки режима и строки заголовка или @minus{}1, если неизвестна.

@item base_line_number
Номер строки определенной позиции в буфере или ноль.
Используется для отображения номера строки точки в строке режима.

@item base_line_pos
Позиция в буфере, для которой известен номер строки, или ноль, что означает, что
ничего не известно.  Если это @minus{}1, не отображать номер строки, пока в окне
отображается этот буфер.

@item column_number_displayed
Номер столбца, отображаемый в данный момент в строке режима этого окна, или @minus{}1,
если номера столбцов не отображаются.

@item current_matrix
@itemx desired_matrix
Матрицы глифов, описывающие текущее и желаемое отображение этого окна.
@end table

@node Process Internals
@subsection Внутреннее Устройство Процесса
@cindex internals, of process
@cindex process internals

  Поля процесса (полный список смотреть в определении @code{struct Lisp_Process} в
@file{process.h}) включают:

@table @code
@item name
Строка Lisp, имя процесса.

@item command
Список, содержащий аргументы команды, которые использовались для запуска этого
процесса.  Для сетевого или последовательного процесса это @code{nil}, если процесс
запущен, или @code{t}, если процесс остановлен.

@item filter
Функция Lisp, используемая для приема вывода от процесса.

@item sentinel
Функция Lisp, вызываемая всякий раз, когда изменяется состояние процесса.

@item buffer
Связанный буфер процесса.

@item pid
Целое число, процесс операционной системы @acronym{ID}.
Псевдопроцессы, такие как сетевые или последовательные соединения, используют
значение 0.

@item childp
Флаг @code{t}, если это действительно дочерний процесс.  Для сетевого или
последовательного подключения это список на основе аргументов
@code{make-network-process} или @code{make-serial-process}.

@item mark
Маркер, указывающий позицию конца последнего вывода этого процесса, вставленного в
буфер.  Часто, но не всегда, это конец буфера.

@item kill_without_query
Если это ненулевое значение, то при закрытии Emacs, пока этот процесс все еще запущен,
не запрашивается подтверждение об удалении процесса.

@item raw_status
Необработанный статус процесса, возвращенный системным вызовом @code{wait}.

@item status
Статус процесса должен вернуть @code{process-status}.  Это символ Lisp, cons-ячейка
или список.

@item tick
@itemx update_tick
Если эти два поля не равны, необходимо сообщить об изменении статуса процесса, либо
запустив наблюдателя, либо вставив сообщение в буфер процесса.

@item pty_flag
Ненулевое значение, если для связи с подпроцессом используется pty; ноль, если
используется канал.

@item infd
Дескриптор файла для ввода из процесса.

@item outfd
Дескриптор файла для вывода в процесс.

@item tty_name
Имя терминала, который использует подпроцесс, или @code{nil}, если используется
каналы.

@item decode_coding_system
Кодовая система для декодирования входных данных этого процесса.

@item decoding_buf
Рабочий буфер для декодирования.

@item decoding_carryover
Размер переходящего остатка при декодировании.

@item encode_coding_system
Система кодирования для кодирования вывода этого процесса.

@item encoding_buf
Рабочий буфер для кодирования.

@item inherit_coding_system_flag
Флаг для установки @code{coding-system} буфера процесса из системы кодирования,
используемой для декодирования вывода процесса.

@item type
Символ, обозначающий тип процесса: @code{real}, @code{network}, @code{serial}.

@end table

@node C Integer Types
@section Cи Целочисленные Типы
@cindex integer types (C programming language)

Вот несколько рекомендаций по использованию целочисленных типов в исходном коде Emacs
C.  Эти руководящие принципы иногда дают разные советы; рекомендуется здравый смысл.

@itemize @bullet
@item
Избегать произвольных ограничений.  Например, избегать @code{int len = strlen (s);},
если длина @code{s} не требуется по другим причинам, чтобы соответствовать диапазону
@code{int}.

@item
Не предполагать, что целочисленная арифметика со знаком завершается при переполнении.
Это больше не верно для целей переноса Emacs: целочисленное переполнение со знаком на
практике имеет неопределенное поведение и может сбрасывать ядро или даже вызывать
нелогичное поведение более раннего или более позднего кода.  Беззнаковое переполнение
надежно дополняется по модулю двойки.

@item
Предпочитать подписанные типы беззнаковым, так как код сбивает с толку при объединении
подписанных и неподписанных типов.  Многие другие руководящие принципы предполагают,
что типы подписаны; в более редких случаях, когда требуются беззнаковые типы,
аналогичный совет может применяться к беззнаковым аналогам (например, @code{size_t}
вместо @code{ptrdiff_t} или @code{uintptr_t} вместо @code{intptr_t}).

@item
Предпочитать @code{int} для кодов символов Emacs в диапазоне 0 ..@: 0x3FFFFF@.  В
более общем случае, предпочитать @code{int} для целых чисел, которые, как известно,
находятся в диапазоне @code{int}, например, счетчиков столбцов экрана.

@item
Предпочитать @code{ptrdiff_t} для размеров, то есть для целых чисел, ограниченных
максимальным размером любого отдельного объекта C или максимальным количеством
элементов в любом массиве C.  Это часть общего предпочтения Emacs для подписанных
типов.  Использование @code{ptrdiff_t} ограничивает объекты байтами
@code{PTRDIFF_MAX}, но большие объекты в любом случае вызовут проблемы, поскольку они
нарушат вычитание указателя, поэтому это не налагает произвольного ограничения.

@item
Избегать @code{ssize_t}, кроме случаев взаимодействия с низкоуровневыми
API-интерфейсами, которые имеют ограничения, связанные с @code{ssize_t}.  Хотя это
эквивалентно @code{ptrdiff_t} на типичных платформах, @code{ssize_t} иногда уже,
поэтому его использование для вычислений, связанных с размером, может вызвать
переполнение.  Кроме того, @code{ptrdiff_t} более распространено и лучше
стандартизировано, имеет стандартные форматы @code{printf} и является основой для
внутренней проверки переполнения размера Emacs.  При использовании @code{ssize_t}
обратить внимание, что POSIX требует поддержки только значений в диапазоне
@minus{}1 ..@: @code{SSIZE_MAX}.

@item
Предпочитать @code{intptr_t} для внутреннего представления указателей или для целых
чисел, ограниченных только количеством объектов, которые могут существовать в любой
момент времени, или общим количеством байтов, которые могут быть выделены.  В
настоящее время Emacs иногда использует другие типы, когда лучше было бы
@code{intptr_t}; исправление этого является более низким приоритетом, поскольку код
работает как есть на текущих целях переноса Emacs.

@item
Предпочитать определенный в Emacs тип @code{EMACS_INT} для представления значений,
преобразованных в или из Emacs Lisp fixnums, поскольку арифметика fixnum основана на
@code{EMACS_INT}.

@item
При представлении системного значения (например, размера файла или количества секунд
с начала эпохи) предпочтение следует отдавать соответствующему типу системы (например,
@code{off_t}, @code{time_t}).  Не предполагать, что тип системы подписан, если только
это предположение не является безопасным.  Например, хотя @code{off_t} всегда
подписано, @code{time_t} не обязательно.

@item
Предпочитать определяемый Emacs тип @code{printmax_t} для представления значений,
которые могут быть любым целым числом со знаком, которое может быть напечатано с
помощью функции семейства @code{printf}.

@item
Предпочитать @code{intmax_t} для представления значений, которые могут быть любым
целым числом со знаком.

@item
Предпочитать @code{bool}, @code{false} и @code{true} для логических значений.
Использование @code{bool} может сделать программы более легкими для чтения и немного
быстрее, чем использование @code{int}.  Хотя @code{int}, @code{0} и @code{1} тоже
можно использовать, этот старый стиль постепенно отменяется.  При использовании
@code{bool} соблюдать ограничения реализации замены @code{bool}, как описано в
исходном файле @file{lib/stdbool.in.h}.  В частности, логические битовые поля должны
иметь тип @code{bool_bf}, а не @code{bool}, чтобы они работали правильно даже при
компиляции Objective C со стандартным GCC.

@item
В битовых полях предпочитать @code{unsigned int} или @code{signed int} @code{int},
поскольку @code{int} менее переносимо: может быть подписаным, а может и не быть.
Однобитовые поля должны иметь размер @code{unsigned int} или @code{bool_bf}, чтобы их
значения были равны 0 или 1.
@end itemize

@c FIXME Упоминание src/globals.h где-нибудь в этом файле?
