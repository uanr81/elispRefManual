@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2019 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Processes
@chapter Процессы
@cindex дочерний процесс
@cindex родительский процесс
@cindex подпроцесс
@cindex процесс

  В терминологии операционных систем @dfn{процесс} - это пространство, в котором может
выполняться программа.  Emacs работает в процессе.  Программы Emacs Lisp могут
вызывать другие программы в своих собственных процессах.  Они называются
@dfn{подпроцессы} или @dfn{дочерние процессы} процесса Emacs, который является их
@dfn{родительским процессом}.

  Подпроцесс Emacs может быть @dfn{синхронный} или @dfn{асинхронный}, в зависимости
от того, как он создан.  Когда создается синхронный подпроцесс, программа на Lisp
ожидает завершения подпроцесса, прежде чем продолжить выполнение.  Когда создается
асинхронный подпроцесс, он может работать параллельно с программой Lisp.  Этот вид
подпроцесса представлен в Emacs объектом Lisp, который также называется процессом.
Программы на Lisp могут использовать этот объект для связи с подпроцессом или для
управления им.  Например, можно отправлять сигналы, получать информацию о состоянии,
получать выходные данные от процесса или отправлять ему входные данные.

  В дополнение к процессам, запускающим программы, программы на Lisp могут открывать
соединения нескольких типов с устройствами или процессами, запущенными на той же
машине или на других машинах.  Поддерживаемые типы соединений: сетевые соединения TCP
и UDP, соединения через последовательный порт и соединения по каналу.  Каждое такое
соединение также представлено объектом процесса.

@defun processp object
Функция возвращает @code{t}, если @var{object} представляет объект процесса Emacs, в
противном случае - @code{nil}.  Объект процесса может представлять подпроцесс,
выполняющий программу, или соединение любого поддерживаемого типа.
@end defun

  Помимо подпроцессов текущего сеанса Emacs, также можно получить доступ к другим
процессам, запущенным на вашем компьютере.  @xref{System Processes}.

@menu
* Subprocess Creation::      Функции, запускающие подпроцессы.
* Shell Arguments::          Цитирование аргумента для передачи его в оболочку.
* Synchronous Processes::    Подробности использования синхронных подпроцессов.
* Asynchronous Processes::   Запуск асинхронного подпроцесса.
* Deleting Processes::       Удаление асинхронного подпроцесса.
* Process Information::      Доступ к статусу выполнения и другим атрибутам.
* Input to Processes::       Отправка ввода в асинхронный подпроцесс.
* Signals to Processes::     Остановка, продолжение или прерывание асинхронного
                                подпроцесса.
* Output from Processes::    Сбор вывода из асинхронного подпроцесса.
* Sentinels::                Часовые запускаются при изменении статуса выполнения
                                процесса.
* Query Before Exit::        Следует ли запрашивать, убьет ли процесс выход.
* System Processes::         Доступ к другим процессам, запущенным в вашей системе.
* Transaction Queues::       Связь с подпроцессами на основе транзакций.
* Network::                  Открытие сетевых подключений.
* Network Servers::          Сетевые серверы позволяют Emacs принимать сетевые
                                 соединения.
* Datagrams::                Сетевые подключения UDP.
* Low-Level Network::        Низкоуровневая, но более общая функция для создания
                                соединений и серверов.
* Misc Network::             Дополнительные актуальные функции для сетевых
                                подключений.
* Serial Ports::             Связь с последовательными портами.
* Byte Packing::             Использование bindat для упаковки и распаковки
                                 двоичных данных.
@end menu

@node Subprocess Creation
@section Функции, Создающие Подпроцессы
@cindex создать подпроцесс
@cindex процесс создание

  Есть три примитива, которые создают новый подпроцесс для запуска программы.  Один
из них, @code{make-process}, создает асинхронный процесс и возвращает объект процесса
(@pxref{Asynchronous Processes}).  Два других, @code{call-process} и
@code{call-process-region}, создают синхронный процесс и не возвращают объект процесса
(@pxref{Synchronous Processes}).  Существуют различные функции более высокого уровня,
которые используют эти примитивы для запуска определенных типов процессов.

  Синхронные и асинхронные процессы объясняются в следующих разделах.  Поскольку все
три функции вызываются одинаково, здесь описаны их общие аргументы.

@cindex выполнить программу
@cindex переменная окружения @env{PATH}
@cindex переменная окружения @env{HOME}
  Во всех случаях функции указывают программу, которую нужно запустить.  Об ошибке
сообщается, если файл не найден или не может быть выполнен.  Если имя файла
относительное, переменная @code{exec-path} содержит список каталогов для поиска.
Emacs инициализирует @code{exec-path} при запуске на основе значения переменной
окружения @env{PATH}.  Стандартные конструкции имен файлов, @samp{~}, @samp{.} и
@samp{..}, интерпретируются как обычно в @code{exec-path}, но подстановки переменных
окружения (@samp{$HOME} и так далее)@: не происходит; использовать
@code{substitute-in-file-name}, чтобы выполнить подстановку
(@pxref{File Name Expansion}).  @code{nil} в этом списке относится к
@code{default-directory}.

  При запуске программы также можно попробовать добавить суффиксы к указанному имени:

@defopt exec-suffixes
Переменная представляет собой список суффиксов (строк), которые можно попытаться
добавить к указанному имени файла программы.  Список должен включать @code{""}, если
требуется, чтобы имя использовалось точно так, как указано.  Значение по умолчанию
зависит от системы.
@end defopt

  @strong{Пожалуйста, обратить внимание:} Аргумент @var{program} содержит только имя
программного файла; не может содержать аргументов командной строки.  Потребуется
использовать отдельный аргумент @var{args} для их предоставления, как описано ниже.

  Каждая из функций создания подпроцессов имеет аргумент @var{buffer-or-name}, который
указывает, куда будет идти вывод программы.  Это должен быть буфер или имя буфера;
если это имя буфера, будет создан буфер, если он еще не существует.  Это также может
быть @code{nil}, который говорит об отказе от вывода, если пользовательская функция
фильтра не обрабатывает его.  (@xref{Filter Functions} и @ref{Read and Print}.)
Обычно следует избегать того, чтобы несколько процессов отправляли вывод в один и тот
же буфер, потому что их вывод будет перемешиваться случайным образом.  Для синхронных
процессов можно отправить вывод в файл, а не в буфер (и поэтому соответствующий
аргумент более уместно называть @var{назначение}).  По умолчанию стандартный поток
вывода и стандартный поток ошибок направляются в одно и то же место назначения, но
все 3 примитива позволяют дополнительно направить стандартный поток ошибок в другое
место назначения.

@cindex программные аргументы
  Все три функции создания подпроцесса позволяют указать аргументы командной строки
для запуска процесса.  Для @code{call-process} и @code{call-process-region} это
аргумент @code{&rest}, @var{args}.  Для @code{make-process} и программы, которую нужно
запустить, ее аргументы командной строки указываются в виде списка строк.  Все
аргументы командной строки должны быть строками, и они предоставляются программе как
отдельные строки аргументов.  Подстановочные знаки и другие конструкции оболочки не
имеют специального значения в этих строках, поскольку строки передаются
непосредственно в указанную программу.

@cindex переменные среды, подпроцессы
  Подпроцесс наследует свою среду от Emacs, но можно указать для него переопределения
с помощью @code{process-environment}.  @xref{System Environment}.  Подпроцесс
получает свой текущий каталог из значения @code{default-directory}.

@defvar exec-directory
@pindex movemail
Значением этой переменной является строка, имя каталога, содержащего программы,
поставляемые с GNU Emacs и предназначенные для вызова Emacs.  Программа
@code{movemail} является примером такой программы; Rmail использует её для получения
новой почты из почтового ящика.
@end defvar

@defopt exec-path
Значение этой переменной представляет собой список каталогов для поиска программ для
запуска в подпроцессах.  Каждый элемент - это либо имя каталога (то есть строка),
либо @code{nil}, что обозначает каталог по умолчанию (который является значением
@code{default-directory}).  @xref{Locating Files, executable-find}, подробности
этого поиска.
@cindex каталоги программ

Значение @code{exec-path} используется @code{call-process} и @code{start-process},
когда аргумент @var{program} не является абсолютным именем файла.

Как правило, не требуется изменять @code{exec-path} напрямую.  Вместо этого убедиться,
что переменная окружения @env{PATH} установлена правильно перед запуском Emacs.
Попытка изменить @code{exec-path} независимо от @env{PATH} может привести к
запутанным результатам.
@end defopt

@node Shell Arguments
@section Аргументы Shell
@cindex аргументы для команд оболочки
@cindex оболочка аргументы команд

  Программам на Lisp иногда требуется запустить оболочку и дать ей команду,
содержащую имена файлов, указанные пользователем.  Эти программы должны поддерживать
любое допустимое имя файла.  Но оболочка уделяет особое внимание определенным
символам, и если эти символы встречаются в имени файла, они запутают оболочку.  Для
обработки этих символов используется функция @code{shell-quote-argument}:

@defun shell-quote-argument argument
Функция возвращает строку, которая представляет в синтаксисе оболочки аргумент,
фактическое содержимое которого - @var{argument}.  Должно надежно работать, чтобы
объединить возвращаемое значение в команду оболочки, а затем передать ее оболочке для
выполнения.

Что именно делает эта функция, зависит от вашей операционной системы.  Функция
предназначена для работы с синтаксисом стандартной оболочки вашей системы; если
используется необычная оболочка, потребуется будет переопределить эту функцию.
@xref{Security Considerations}.

@example
;; @r{В этом примере показано поведение в системах GNU и Unix.}
(shell-quote-argument "foo > bar")
     @result{} "foo\\ \\>\\ bar"

;; @r{В этом примере показано поведение в MS-DOS и MS-Windows.}
(shell-quote-argument "foo > bar")
     @result{} "\"foo > bar\""
@end example

Вот пример использования @code{shell-quote-argument} для создания команды оболочки:

@example
(concat "diff -u "
        (shell-quote-argument oldfile)
        " "
        (shell-quote-argument newfile))
@end example
@end defun

@cindex цитирование и снятие кавычек с аргументов командной строки
@cindex ввод минибуфера и аргументы командной строки
@cindex @code{call-process}, аргументы командной строки из минибуфера
@cindex @code{start-process}, аргументы командной строки из минибуфера
  Следующие две функции полезны для объединения списка отдельных строк аргументов
командной строки в одну строку и разделения строки на список отдельных аргументов
командной строки.  Эти функции в основном предназначены для преобразования
пользовательского ввода в минибуфер, строки Lisp, в список строковых аргументов,
передаваемых в @code{make-process}, @code{call-process} или @code{start-process}, или
для преобразования таких списков аргументов в одну строку Lisp, которая будет
представлена в минибуфер или эхо-область.  Обратить внимание, что если задействована
оболочка (например, при использовании @code{call-process-shell-command}), аргументы
все равно должны быть защищены @code{shell-quote-argument};
@code{combine-and-quote-strings} - это @emph{не} предназначено для защиты специальных
символов от оценки оболочкой.

@defun split-string-and-unquote string &optional separators
Функция разбивает @var{string} на подстроки в соответствии с регулярным выражением
@var{separators}, как @code{split-string} делает (@pxref{Creating Strings}); кроме
того, удаляются кавычки из подстрок.  Затем составляется список подстрок и
возвращается.

Если @var{separators} опущено или @code{nil}, по умолчанию используется
@code{"\\s-+"}, которое является регулярным выражением, которое соответствует одному
или нескольким символам с синтаксисом пробелов (@pxref{Syntax Class Table}).

Функция поддерживает два типа заключения в кавычки: заключение всей строки в двойные
кавычки @code{"@dots{}"} и заключение отдельных символов в кавычки с помощью
escape-символа обратной косой черты @samp{\}.  Последнее также используется в строках
Lisp, так что эта функция тоже может их обрабатывать.
@end defun

@defun combine-and-quote-strings list-of-strings &optional separator
Функция объединяет @var{list-of-strings} в одну строку, при необходимости помещая
каждую строку в кавычки.  Также вставляется строка @var{separator} между каждой парой
строк; если @var{separator} опущено или @code{nil}, по умолчанию используется
@code{" "}.  Возвращаемое значение - результирующая строка.

Строки в @var{list-of-strings}, которые нуждаются в кавычках, включают в себя
@var{separator} в качестве подстроки.  Цитирование строки заключает ее в двойные
кавычки @code{"@dots{}"}.  В простейшем случае, если составляется команда из отдельных
аргументов командной строки, каждый аргумент, который включает встроенные пробелы,
будет заключен в кавычки.
@end defun

@node Synchronous Processes
@section Создание Синхронного Процесса
@cindex synchronous subprocess

  После создания @dfn{синхронного процесса} Emacs ожидает завершения процесса, прежде
чем продолжить.  Запуск Dired в GNU или Unix@footnote{В других системах Emacs использует эмуляцию @code{ls} Lisp; смотреть @ref{Contents of Directories}.} пример этого:
запускается @code{ls} в синхронном процессе, а затем немного изменяется вывод.
Поскольку процесс является синхронным, весь список каталогов попадает в буфер до того,
как Emacs попытается что-либо с ним сделать.

  Пока Emacs ожидает завершения синхронного подпроцесса, пользователь может выйти,
набрав @kbd{C-g}.  Первое @kbd{C-g} пытается убить подпроцесс сигналом @code{SIGINT};
но ожидается, пока подпроцесс действительно не завершится, прежде чем завершить
работу.  Если в это время пользователь набирает другой раз @kbd{C-g}, немедленно
завершается подпроцесс с помощью @code{SIGKILL} и немедленно завершается работа
(кроме MS-DOS, где удаление других процессов не работает).  @xref{Quitting}.

  Функции синхронного подпроцесса возвращают указание на то, как процесс завершился.

  Выходные данные синхронного подпроцесса обычно декодируются с использованием
системы кодирования, что очень похоже на чтение текста из файла.  Входные данные,
отправляемые @code{call-process-region} подпроцессу, кодируются с использованием
системы кодирования, очень похоже на текст, записанный в файл.  @xref{Coding Systems}.

@defun call-process program &optional infile destination display &rest args
Функция вызывает @var{program} и ждет ее завершения.

Текущий рабочий каталог подпроцесса устанавливается равным текущему значению буфера
@code{default-directory}, если он локальный (как определено
@code{unhandled-file-name-directory}), или ~ в противном случае.  Если требуется
запустить процесс в удаленном каталоге, использовать @code{process-file}.

Стандартный ввод для нового процесса поступает из файла @var{infile}, если
@var{infile} не является @code{nil}, и из нулевого устройства в противном случае.
Аргумент @var{destination} говорит, куда поместить вывод процесса.  Вот возможности:

@table @asis
@item a buffer
Вставить вывод в этот буфер перед точкой.  Это включает как стандартный поток вывода,
так и стандартный поток ошибок процесса.

@item a buffer name (a string)
Вставить вывод в буфер с этим именем перед точкой.

@item @code{t}
Вставить вывод в текущий буфер перед точкой.

@item @code{nil}
Отказ от вывода.

@item 0
Отбросить вывод и немедленно вернуть @code{nil}, не дожидаясь завершения подпроцесса.

В этом случае процесс не является полностью синхронным, поскольку может выполняться
параллельно с Emacs; но можно думать об этом как о синхронном в том смысле, что Emacs
по существу завершает подпроцесс, как только эта функция возвращается.

MS-DOS не поддерживает асинхронные подпроцессы, поэтому этот параметр там не работает.

@item @code{(:file @var{file-name})}
Отправить вывод в файл с указанным именем, перезаписав его, если он уже существует.

@item @code{(@var{real-destination} @var{error-destination})}
Держать стандартный поток вывода отдельно от стандартного потока ошибок; обрабатывать
обычный вывод, как указано в @var{real-destination}, и избавляться от вывода ошибок
в соответствии с @var{error-destination}.  Если @var{error-destination} имеет значение
@code{nil}, это означает, что вывод ошибки следует отбросить, @code{t} означает
смешать его с обычным выводом, а строка указывает имя файла для перенаправления
вывода ошибок.

Возможно напрямую указать буфер для вывода сообщения об ошибке; это слишком сложно
реализовать.  Но можно добиться этого результата, отправив вывод ошибки во временный
файл, а затем вставив файл в буфер после завершения подпроцесса.
@end table

Если @var{display} равно не-@code{nil}, то @code{call-process} повторно отображает
буфер при вставке вывода.  (Однако, если для декодирования выходных данных выбрана
система кодирования @code{undecided}, что означает вывод кодировки из фактических
данных, то повторное отображение иногда не может продолжаться после обнаружения
символов не-@acronym{ASCII}.  Есть фундаментальные причины, по которым это трудно
исправить; смотреть @ref{Output from Processes}.)

В противном случае функция @code{call-process} не отображает повторно, и результаты
становятся видимыми на экране только тогда, когда Emacs повторно отображает этот
буфер в обычном ходе событий.

Остальные аргументы, @var{args}, представляют собой строки, определяющие аргументы
командной строки для программы.  Каждая строка передается @var{program} как отдельный
аргумент.

Значение, возвращаемое @code{call-process} (если не указано ему не ждать), указывает
причину завершения процесса.  Число указывает статус выхода подпроцесса; 0 означает
успех, а любое другое значение означает неудачу.  Если процесс завершился сигналом,
@code{call-process} возвращает строку, описывающую сигнал.  Если указано
@code{call-process} не ждать, возвращается @code{nil}.

В приведенных ниже примерах буфер @samp{foo} является текущим.

@smallexample
@group
(call-process "pwd" nil t)
     @result{} 0

---------- Buffer: foo ----------
/home/lewis/manual
---------- Buffer: foo ----------
@end group

@group
(call-process "grep" nil "bar" nil "lewis" "/etc/passwd")
     @result{} 0

---------- Buffer: bar ----------
lewis:x:1001:1001:Bil Lewis,,,,:/home/lewis:/bin/bash

---------- Buffer: bar ----------
@end group
@end smallexample

Вот пример использования @code{call-process}, который использовался в определении
функции @code{insert-directory}:

@smallexample
@group
(call-process insert-directory-program nil t nil switches
              (if full-directory-p
                  (concat (file-name-as-directory file) ".")
                file))
@end group
@end smallexample
@end defun

@defun process-file program &optional infile buffer display &rest args
Функция обрабатывает файлы синхронно в отдельном процессе.  Похоже на
@code{call-process}, но может вызывать обработчик файла на основе значения переменной
@code{default-directory}, которая указывает текущий рабочий каталог подпроцесса.

Аргументы обрабатываются почти так же, как для @code{call-process}, со следующими
отличиями:

Некоторые обработчики файлов могут поддерживать не все комбинации и формы аргументов
@var{infile}, @var{buffer} и @var{display}.  Например, некоторые обработчики файлов
могут вести себя так, как если бы @var{display} было в @code{nil}, независимо от
фактически переданного значения.  В качестве другого примера, некоторые обработчики
файлов могут не поддерживать разделение стандартного вывода и вывода ошибок с помощью
аргумента @var{buffer}.

Если вызывается обработчик файлов, определяется программа для запуска на основе
первого аргумента @var{program}.  Например, предположить, что вызывается обработчик
удаленных файлов.  Тогда путь, который используется для поиска программы, может
отличаться от @code{exec-path}.

Второй аргумент @var{infile} может вызывать обработчик файла.  Обработчик файла может
отличаться от обработчика, выбранного для самой функции @code{process-file}.
(Например, @code{default-directory} может быть на одном удаленном хосте, а
@var{infile} - на другом удаленном хосте.  Или @code{default-directory} может быть
подходящим, тогда как @var{infile} находится на удаленном хосте.)

Если @var{buffer} - это список в форме, в которой @code{(@var{real-destination}
@var{error-destination})} и @var{error-destination} называет файл, то применяются те
же замечания, что и для @var{infile}.

Остальные аргументы (@var{args}) будут переданы процессу дословно.  Emacs не участвует
в обработке имен файлов, присутствующих в @var{args}.  Чтобы избежать путаницы, лучше
избегать абсолютных имен файлов в @var{args}, а вместо этого указывать все имена
файлов относительно @code{default-directory}.  Функция @code{file-relative-name}
полезна для построения таких относительных имен файлов.  В качестве альтернативы
можно использовать @code{file-local-name} (@pxref{Magic File Names}) для получения
абсолютного имени файла с точки зрения удаленного хоста.
@end defun

@defvar process-file-side-effects
Переменная указывает, изменяет ли вызов @code{process-file} удаленные файлы.

По умолчанию переменная всегда имеет значение @code{t}, что означает, что вызов
@code{process-file} потенциально может изменить любой файл на удаленном хосте.  Если
установлено значение @code{nil}, обработчик файлов может оптимизировать свое
поведение в отношении кэширования атрибутов удаленного файла.

Потребуется изменять эту переменную только с помощью привязки let; и никогда с помощью
@code{setq}.
@end defvar

@defun call-process-region start end program &optional delete destination display &rest args
Функция отправляет текст из @var{start} в @var{end} в качестве стандартного ввода для
процесса, выполняющего @var{program}.  Удаляет отправленный текст, если @var{delete}
равно не-@code{nil}; это полезно, когда @var{destination} равно @code{t}, чтобы
вставить вывод в текущий буфер вместо ввода.

Аргументы @var{destination} и @var{display} определяют, что делать с выводом
подпроцесса и нужно ли обновлять отображение по мере его поступления.  Подробнее
смотреть описание @code{call-process} выше.  Если @var{destination} является целым
числом 0, @code{call-process-region} отбрасывает вывод и немедленно возвращает
@code{nil}, не дожидаясь завершения подпроцесса (это работает только в том случае,
если поддерживаются асинхронные подпроцессы, то есть не в MS-DOS).

Остальные аргументы, @var{args}, представляют собой строки, определяющие аргументы
командной строки для программы.

Возвращаемое значение @code{call-process-region} такое же, как у @code{call-process}:
@code{nil}, если указан возврат без ожидания; в противном случае - число или строка,
указывающая, как завершился подпроцесс.

В следующем примере используется @code{call-process-region} для запуска утилиты
@code{cat} со стандартным вводом - первые пять символов в буфере @samp{foo} (слово
@samp{input}).  @code{cat} копирует стандартный ввод в стандартный вывод.  Поскольку
аргумент @var{destination} равен @code{t}, этот вывод вставляется в текущий буфер.

@smallexample
@group
---------- Buffer: foo ----------
input@point{}
---------- Buffer: foo ----------
@end group

@group
(call-process-region 1 6 "cat" nil t)
     @result{} 0

---------- Buffer: foo ----------
inputinput@point{}
---------- Buffer: foo ----------
@end group
@end smallexample

  Например, команда @code{shell-command-on-region} использует
@code{call-shell-region} примерно так:

@smallexample
@group
(call-shell-region
 start end
 command              ; @r{команда оболочки}
 nil                  ; @r{не удалять регион}
 buffer)              ; @r{отправить вывод в @code{buffer}}
@end group
@end smallexample
@end defun

@defun call-process-shell-command command &optional infile destination display
Функция синхронно выполняет команду оболочки @var{command}.  Остальные аргументы
обрабатываются как в @code{call-process}.  Старое соглашение о вызовах позволяло
передавать любое количество дополнительных аргументов после @var{display}, которые
были объединены с @var{command}; это все еще поддерживается, но настоятельно не
рекомендуется.
@end defun

@defun process-file-shell-command command &optional infile destination display
Функция похожа на @code{call-process-shell-command}, но использует внутри
@code{process-file}.  В зависимости от @code{default-directory}, @var{command} может
выполняться также на удаленных хостах.  Старое соглашение о вызовах позволяло
передавать любое количество дополнительных аргументов после @var{display}, которые
были объединены с @var{command}; это все еще поддерживается, но настоятельно не
рекомендуется.
@end defun

@defun call-shell-region start end command &optional delete destination
Функция отправляет текст из @var{start} в @var{end} в качестве стандартного ввода в
подчиненную оболочку, выполняющую @var{command}.  Эта функция похожа на
@code{call-process-region}, но процесс является оболочкой.  Аргументы @code{delete},
@code{destination} и возвращаемое значение такие же, как в @code{call-process-region}.
Обратить внимание, что эта функция не принимает дополнительных аргументов.
@end defun

@defun shell-command-to-string command
Функция выполняет @var{command} (строку) как команду оболочки, а затем возвращает
вывод команды в виде строки.
@end defun

@c Существует также команда shell-command-on-region, но это скорее пользовательская
@c команда, а не что-то для использования в программах.

@defun process-lines program &rest args
Функция запускает @var{program}, ожидает её завершения и возвращает вывод в виде
списка строк.  Каждая строка в списке содержит одну строку текста, выводимого
программой; символы конца строки удаляются из каждой строки.  Аргументы указываются
после @var{program}, @var{args} - это строки, которые определяют аргументы командной
строки, с которыми следует запускать программу.

Если @var{program} завершается с ненулевым статусом выхода, эта функция сигнализирует
об ошибке.

Функция работает, вызывая @code{call-process}, поэтому вывод программы декодируется
так же, как для @code{call-process}.
@end defun

@node Asynchronous Processes
@section Создание Асинхронного Процесса
@cindex asynchronous subprocess

  В этом разделе описывается, как создать файл @dfn{асинхронного процесса}.  После
создания асинхронного процесса он запускается параллельно с Emacs, и Emacs может
связываться с ним, используя функции, описанные в следующих разделах
(@pxref{Input to Processes} и @pxref{Output from Processes}).  Обратить внимание, что
обмен данными между процессами является только частично асинхронным: Emacs отправляет
и получает данные в процесс и из процесса только тогда, когда эти функции вызываются.

@cindex pty, когда использовать для связи подпроцесса
@cindex pipe, когда использовать для связи подпроцесса
  Асинхронный процесс управляется либо через @dfn{pty} (псевдотерминал), либо через
@dfn{канал}.  Выбор pty или pipe производится при создании процесса, по умолчанию на
основе значения переменной @code{process-connection-type} (смотреть ниже).  Если
доступно, pty обычно предпочтительнее для процессов, видимых пользователю, как в
режиме Shell, потому что они позволяют управлять заданиями (@kbd{C-c}, @kbd{C-z} и
так далее)@: между процессом и его дочерними процессами, а также потому, что
интерактивные программы обрабатывают pty как терминальные устройства, тогда как каналы
не поддерживают эти функции.  Однако для подпроцессов, используемых программами на
Lisp для внутренних целей (то есть взаимодействие пользователя с подпроцессом не
требуется), когда между подпроцессом и программой на Lisp необходимо обмениваться
значительными объемами данных, часто лучше использовать канал, потому что они более
эффективны.  Кроме того, общее количество pty ограничено во многих системах, и неплохо
не тратить их без надобности.

@defun make-process &rest args
Функция является базовым примитивом низкого уровня для запуска асинхронных
подпроцессов.  Возвращается объект процесса, представляющий подпроцесс.  По сравнению
с более высокоуровневым @code{start-process}, описанным ниже, принимаются аргументы
ключевого слова, является более гибким и позволяет указывать фильтры процесса и
контрольные точки за один вызов.

Аргументы @var{args} представляют собой список пар ключевое слово/аргумент.  Пропуск
ключевого слова всегда эквивалентно его указанию со значением @code{nil}.  Вот
значимые ключевые слова:

@table @asis
@item :name @var{name}
Использовать строку @var{name} в качестве имени процесса; если процесс с таким именем
уже существует, то @var{name} модифицируется (добавлением @samp{<1>} и так далее)@:
чтобы имя было уникальным.

@item :buffer @var{buffer}
Использовать @var{buffer} в качестве буфера процесса.  Если значение равно @code{nil},
подпроцесс не связан ни с каким буфером.

@item :command @var{command}
Использовать @var{command} в качестве командной строки процесса.  Значение должно быть
списком, начинающимся с имени исполняемого файла программы, за которым следуют строки,
передаваемые программе в качестве аргументов.  Если первым элементом списка является
@code{nil}, Emacs открывает новый псевдотерминал (pty) и связывает его ввод и вывод с
@var{buffer}, фактически не выполняя никакой программы; остальные элементы списка в
этом случае игнорируются.

@item :coding @var{coding}
Если @var{coding} является символом, это указывает систему кодирования, которая будет
использоваться как для чтения, так и для записи данных из и в соединение.  Если
@var{coding} является cons-ячейкой @w{@code{(@var{decoding} . @var{encoding})}}, тогда
@var{decoding} будет использоваться для чтения, а @var{encoding} - для записи.
Система кодирования, используемая для кодирования данных, записанных в программу,
также используется для кодирования аргументов командной строки (но не самой программы,
имя файла которой кодируется как любое другое имя файла;
@pxref{Encoding and I/O, file-name-coding-system}).

Если @var{coding} равно @code{nil}, будут применяться правила по умолчанию для поиска
системы кодирования.  @xref{Default Coding Systems}.

@item :connection-type @var{type}
Инициализировать тип устройства, используемого для связи с подпроцессом.  Возможные
значения: @code{pty} для использования pty, @code{pipe} для использования канала или
@code{nil} для использования значения по умолчанию, полученного из значения переменной
@code{process-connection-type}.  Этот параметр и значение
@code{process-connection-type} игнорируются, если для параметра @code{:stderr}
указано значение не-@code{nil}; в этом случае тип всегда будет @code{pipe}.  В
системах, где ptys недоступны (MS-Windows), этот параметр также игнорируется, и
каналы используются безоговорочно.

@item :noquery @var{query-flag}
Инициализировать флаг запроса процесса на @var{query-flag}.
@xref{Query Before Exit}.

@item :stop @var{stopped}
Если @var{stopped} равно не-@code{nil}, запустить процесс в остановленном состоянии.

@item :filter @var{filter}
Инициализировать фильтр процесса как @var{filter}.  Если не указано, будет
предоставлен фильтр по умолчанию, который позже можно будет переопределить.
@xref{Filter Functions}.

@item :sentinel @var{sentinel}
Инициализировать часовой процесс @var{sentinel}.  Если не указано иное, будет
использоваться дозорный по умолчанию, который можно изменить позже.
@xref{Sentinels}.

@item :stderr @var{stderr}
Связать @var{stderr} со стандартной ошибкой процесса.  Значение не-@code{nil} должно
быть либо буферным, либо конвейерным процессом, созданным с помощью
@code{make-pipe-process}, как описано ниже.
@end table

Исходный список аргументов, модифицированный фактической информацией о соединении,
доступен через функцию @code{process-contact}.

Текущий рабочий каталог подпроцесса устанавливается равным текущему значению буфера
@code{default-directory}, если он локальный (как определено
`unhandled-file-name-directory') или "~" в противном случае.  Если требуется запустить
процесс в удаленном каталоге, использовать @code{start-file-process}.
@end defun

@defun make-pipe-process &rest args
Функция создает двунаправленный канал, который можно присоединить к дочернему
процессу.  Это полезно с ключевым словом @code{:stderr} для @code{make-process}.
Функция возвращает объект процесса.

Аргументы @var{args} представляют собой список пар ключевое слово/аргумент.  Пропуск
ключевого слова всегда эквивалентен его указанию со значением @code{nil}.

Вот значимые ключевые слова:

@table @asis
@item :name @var{name}
Использовать строку @var{name} в качестве имени процесса.  Как и в случае с
@code{make-process}, изменяется при необходимости, чтобы сделаться уникальным именем.

@item :buffer @var{buffer}
Использовать @var{buffer} в качестве буфера процесса.

@item :coding @var{coding}
Если @var{coding} является символом, это указывает систему кодирования, которая будет
использоваться как для чтения, так и для записи данных из и в соединение.  Если
@var{coding} является cons-ячейкой @w{@code{(@var{decoding} . @var{encoding})}}, тогда
@var{decoding} будет использоваться для чтения, а @var{encoding} - для записи.

Если @var{coding} равно @code{nil}, будут применяться правила по умолчанию для поиска
системы кодирования.  @xref{Default Coding Systems}.

@item :noquery @var{query-flag}
Инициализировать флаг запроса процесса на @var{query-flag}.
@xref{Query Before Exit}.

@item :stop @var{stopped}
Если @var{stopped} равно не-@code{nil}, запустить процесс в остановленном состоянии.
В остановленном состоянии конвейерный процесс не принимает входящие данные, но можно
отправлять исходящие данные.  Остановленное состояние устанавливается
@code{stop-process} и очищается @code{continue-process}
(@pxref{Signals to Processes}).

@item :filter @var{filter}
Инициализировать фильтр процесса как @var{filter}.  Если не указано, будет
предоставлен фильтр по умолчанию, который можно будет изменить позже.
@xref{Filter Functions}.

@item :sentinel @var{sentinel}
Инициализировать процесс наблюдатель @var{sentinel}.  Если не указано иное, будет
использоваться дозорный по умолчанию, который можно изменить позже.
@xref{Sentinels}.
@end table

Исходный список аргументов, модифицированный фактической информацией о соединении,
доступен через функцию @code{process-contact}.
@end defun

@defun start-process name buffer-or-name program &rest args
Функция является оболочкой более высокого уровня вокруг @code{make-process},
предоставляя интерфейс, похожий на @code{call-process}.  Создается новый асинхронный
подпроцесс и запускается в нем указанный @var{program}.  Возвращается объект процесса,
который обозначает новый подпроцесс в Lisp.  Аргумент @var{name} указывает имя объекта
процесса; как и в случае с @code{make-process}, при необходимости имя изменяется,
чтобы быть уникальным.  Буфер @var{buffer-or-name} - это буфер, который связывается
с процессом.

Если @var{program} равно @code{nil}, Emacs открывает новый псевдотерминал (pty) и
связывает его ввод и вывод с @var{buffer-or-name} без создания подпроцесса.  В этом
случае остальные аргументы @var{args} игнорируются.

Остальные @var{args} - это строки, которые определяют аргументы командной строки для
подпроцесса.

В приведенном ниже примере первый процесс запускается и работает (скорее, спит) в
течение 100 секунд (выходной буфер @samp{foo} создается немедленно).  Тем временем
запускается второй процесс, которому для уникальности присвоено имя
@samp{my-process<1>}.  Он вставляет список каталогов в конец буфера @samp{foo} до
завершения первого процесса.  Затем он завершается, и соответствующее сообщение
вставляется в буфер.  Гораздо позже первый процесс завершается, и для него в буфер
вставляется другое сообщение.

@smallexample
@group
(start-process "my-process" "foo" "sleep" "100")
     @result{} #<process my-process>
@end group

@group
(start-process "my-process" "foo" "ls" "-l" "/bin")
     @result{} #<process my-process<1>>

---------- Buffer: foo ----------
total 8336
-rwxr-xr-x 1 root root 971384 Mar 30 10:14 bash
-rwxr-xr-x 1 root root 146920 Jul  5  2011 bsd-csh
@dots{}
-rwxr-xr-x 1 root root 696880 Feb 28 15:55 zsh4

Process my-process<1> finished

Process my-process finished
---------- Buffer: foo ----------
@end group
@end smallexample
@end defun

@defun start-file-process name buffer-or-name program &rest args
Как и @code{start-process}, эта функция запускает новый асинхронный подпроцесс,
в котором запущена @var{program}, и возвращает объект процесса.

Отличие от @code{start-process} в том, что эта функция может вызывать обработчик
файла на основе значения @code{default-directory}.  Этот обработчик должен запускать
@var{program}, возможно, на локальном хосте, возможно, на удаленном хосте, который
соответствует @code{default-directory}.  В последнем случае локальная часть
@code{default-directory} становится рабочим каталогом процесса.

Функция не пытается вызвать обработчики имен файлов для @var{program} или остальной
части @var{args}.  По этой причине, если @var{program} или любой из @var{args}
используют синтаксис удаленного файла (@pxref{Magic File Names}), они должны быть
преобразованы либо в имена файлов относительно @code{default-directory}, либо в имена,
которые идентифицируют файлы локально на удаленном хосте, запустщеные через
@code{file-local-name}.

В зависимости от реализации обработчика файлов может оказаться невозможным применить
@code{process-filter} или @code{process-sentinel} к результирующему объекту процесса.
@xref{Filter Functions} и @ref{Sentinels}.

@c FIXME  Можем ли мы найти лучший пример (то есть более современную функцию
@c, которая действительно задокументирована).
Некоторые обработчики файлов могут не поддерживать @code{start-file-process}
(например, функция @code{ange-ftp-hook-function}).  В таких случаях эта функция
ничего не делает и возвращает @code{nil}.
@end defun

@defun start-process-shell-command name buffer-or-name command
Функция похожа на @code{start-process}, за исключением того, что она использует
оболочку для выполнения указанной @var{command}.  Аргумент @var{command} - это
командная строка оболочки.  Переменная @code{shell-file-name} указывает, какую
оболочку использовать.

Смысл запуска программы через оболочку, а не напрямую через @code{make-process} или
@code{start-process}, заключается в том, чтобы можно было использовать функции
оболочки, такие как подстановочные знаки в аргументах.  Из этого следует, что если
включаются в команду любые произвольные аргументы, указанные пользователем,
потребуется сначала заключить их в кавычки с @code{shell-quote-argument}, чтобы любые
специальные символы оболочки @emph{не} имели свои особые значения оболочки.
@xref{Shell Arguments}.  Конечно, при выполнении команд на основе пользовательского
ввода также потребуется учитывать последствия для безопасности.
@end defun

@defun start-file-process-shell-command name buffer-or-name command
Функция похожа на @code{start-process-shell-command}, но использует внутри
@code{start-file-process}.  Из-за этого @var{command} также может выполняться на
удаленных хостах, в зависимости от @code{default-directory}.
@end defun

@defvar process-connection-type
Переменная контролирует тип устройства, используемого для связи с асинхронными
подпроцессами.  Если это не-@code{nil}, то используются pty, если они доступны.
В противном случае используются каналы.

Значение @code{process-connection-type} вступает в силу при вызове
@code{make-process} или @code{start-process}.  Таким образом, можно указать, как
взаимодействовать с одним подпроцессом, привязав переменную к вызову этих функций.

Обратить внимание, что значение этой переменной игнорируется, когда
@code{make-process} вызывается со значением не-@code{nil} параметра @code{:stderr};
в этом случае Emacs будет связываться с процессом с помощью каналов.  Также
игнорируется, если pty недоступны (MS-Windows).

@smallexample
@group
(let ((process-connection-type nil))  ; @r{use a pipe}
  (start-process @dots{}))
@end group
@end smallexample

Чтобы определить, действительно ли данный подпроцесс получил канал или pty,
использовать функцию @code{process-tty-name} (@pxref{Process Information}).
@end defvar

@node Deleting Processes
@section Удаление Процессов
@cindex deleting processes

  @dfn{Удаление процесса} немедленно отключает Emacs от подпроцесса.  Процессы
удаляются автоматически после завершения, но не обязательно сразу.  Можно в любой
момент удалить процесс явным образом.  Если явно удалить завершенный процесс до того,
как он будет удален автоматически, никакого вреда не будет.  Удаление запущенного
процесса отправляет сигнал для его завершения (и его дочерних процессов, если таковые
имеются) и вызывает наблюдателя процесса.  @xref{Sentinels}.

  Когда процесс удаляется, сам объект процесса продолжает существовать, пока на него
указывают другие объекты Lisp.  Все примитивы Lisp, которые работают с объектами
процессов, принимают удаленные процессы, но те, которые выполняют ввод-вывод или
отправляют сигналы, сообщают об ошибке.  Метка процесса продолжает указывать на то
же место, что и раньше, обычно в буфер, куда вставлялись выходные данные процесса.

@defopt delete-exited-processes
Переменная управляет автоматическим удалением завершившихся процессов (из-за вызова
@code{exit} или сигнала).  Если это @code{nil}, они продолжают существовать, пока
пользователь не запустит @code{list-processes}.  В противном случае они удаляются
сразу после выхода.
@end defopt

@defun delete-process process
Функция удаляет процесс, завершая его сигналом @code{SIGKILL}, если процесс выполнял
программу.  Аргументом может быть процесс, имя процесса, буфер или имя буфера.  (Буфер
или имя-буфера обозначают процесс, который возвращает @code{get-buffer-process}.)
Вызов @code{delete-process} в запущенном процессе завершает его, обновляет статус
процесса и немедленно запускает наблюдателя.  Если процесс уже завершен, вызов
@code{delete-process} не влияет ни на его статус, ни на работу его дозорного (что
рано или поздно произойдет).

Если объект процесса представляет собой сетевое, последовательное или канальное
соединение, его статус изменяется на @code{closed}; в противном случае изменяется на
@code{signal}, если процесс еще не завершился.
@xref{Process Information, process-status}.

@smallexample
@group
(delete-process "*shell*")
     @result{} nil
@end group
@end smallexample
@end defun

@node Process Information
@section Информация о Процессе
@cindex process information

  Некоторые функции возвращают информацию о процессах.

@deffn Command list-processes &optional query-only buffer
Команда отображает список всех живых процессов.  Кроме того, окончательно удаляются
все процессы со статусом @samp{Exited} или @samp{Signaled}.  Возвращается @code{nil}.

Процессы отображаются в буфере с именем @file{*Process List*} (если не указать иное
с помощью необязательного аргумента @var{buffer}), основным режимом которого является
режим меню процесса.

Если @var{query-only} равно не-@code{nil}, перечисляются только процессы, флаг
запроса которых равен не-@code{nil}.  @xref{Query Before Exit}.
@end deffn

@defun process-list
Функция возвращает список всех процессов, которые не были удалены.

@smallexample
@group
(process-list)
     @result{} (#<process display-time> #<process shell>)
@end group
@end smallexample
@end defun

@defun get-process name
Функция возвращает процесс с именем @var{name} (строка) или @code{nil}, если его нет.
Аргумент @var{name} также может быть объектом процесса, и в этом случае он
возвращается.

@smallexample
@group
(get-process "shell")
     @result{} #<process shell>
@end group
@end smallexample
@end defun

@defun process-command process
Функция возвращает команду, которая была выполнена для запуска @var{process}.  Это
список строк, первая строка - это выполняемая программа, а остальные строки -
аргументы, которые были переданы программе.  Для сетевого, последовательного или
канального соединения это либо @code{nil}, что означает, что процесс запущен, либо
@code{t} (процесс остановлен).

@smallexample
@group
(process-command (get-process "shell"))
     @result{} ("bash" "-i")
@end group
@end smallexample
@end defun

@defun process-contact process &optional key
Функция возвращает информацию о том, как было установлено сетевое, последовательное
или канальное соединение.  Когда @var{key} равно @code{nil}, возвращается
@code{(@var{hostname} @var{service})} для сетевого соединения,
@code{(@var{port} @var{speed})} для последовательного соединения и @code{t} для
канального соединения.  Для обычного дочернего процесса эта функция всегда возвращает
@code{t} при вызове с @code{nil} @var{key}.

Если @var{key} - @code{t}, значение представляет собой полную информацию о состоянии
соединения, сервера, последовательного порта или канала; то есть список ключевых слов
и значений, указанных в @code{make-network-process}, @code{make-serial-process} или
@code{make-pipe-process}, за исключением того, что некоторые из значений представляют
текущий статус вместо того, что указано.

Для сетевого процесса значения включают (полный список смотреть в
@code{make-network-process}):

@table @code
@item :buffer
Связанное значение - это буфер процесса.
@item :filter
Связанное значение - это функция фильтрации процесса.  @xref{Filter
Functions}.
@item :sentinel
Связанное значение - это функция наблюдательного процесса. @xref{Sentinels}.
@item :remote
В соединении - адрес во внутреннем формате удаленного узла.
@item :local
Локальный адрес во внутреннем формате.
@item :service
На сервере, если указано @code{t} для @var{service}, это значение будет фактическим
номером порта.
@end table

@code{:local} и @code{:remote} включаются, даже если они не были явно указаны
в @code{make-network-process}.

Для последовательного соединения смотреть @code{make-serial-process} и
@code{serial-process-configure} для списка ключей.  Для канального соединения
смотреть @code{make-pipe-process} для списка ключей.

Если @var{key} - ключевое слово, функция возвращает значение, соответствующее этому
ключевому слову.
@end defun

@defun process-id process
Функция возвращает @acronym{PID} для @var{process}.  Это целое число, которое
отличает процесс @var{process} от всех других процессов, запущенных на том же
компьютере в настоящее время.  @acronym{PID} процесса выбирается ядром операционной
системы при запуске процесса и остается неизменным, пока процесс существует.  Для
сетевых, последовательных и канальных соединений функцией возвращается @code{nil}.
@end defun

@defun process-name process
Функция возвращает имя @var{process} в виде строки.
@end defun

@defun process-status process-name
Функция возвращает статус @var{process-name} в виде символа.  Аргумент
@var{process-name} должен быть процессом, буфером или именем процесса (строкой).

Возможные значения для фактического подпроцесса:

@table @code
@item run
для запущенного процесса.
@item stop
для процесса, который остановлен, но может быть продолжен.
@item exit
для завершившегося процесса.
@item signal
для процесса, получившего фатальный сигнал.
@item open
для открытого сетевого, последовательного или канального соединения.
@item closed
для закрытого сетевого, последовательного или канального соединения.  После того, как
соединение закрыто, можно его повторно открыть, хотя можно открыть новое соединение
в том же месте.
@item connect
для неблокирующего соединения, ожидающего завершения.
@item failed
для неблокирующего соединения, которое не удалось завершить.
@item listen
для сетевого сервера, который слушает.
@item nil
если @var{process-name} - это не имя существующего процесса.
@end table

@smallexample
@group
(process-status (get-buffer "*shell*"))
     @result{} run
@end group
@end smallexample

Для сетевого, последовательного или канального соединения @code{process-status}
возвращает один из символов @code{open}, @code{stop} или @code{closed}.  Последнее
означает, что другая сторона закрыла соединение или Emacs сделал
@code{delete-process}.  Значение @code{stop} означает, что для соединения был вызвано
@code{stop-process}.
@end defun

@defun process-live-p process
Функция возвращает не-@code{nil}, если @var{process} жив.  Процесс считается живым,
если его статус - @code{run}, @code{open}, @code{listen}, @code{connect} или
@code{stop}.
@end defun

@defun process-type process
Функция возвращает символ @code{network} для сетевого подключения или сервера,
@code{serial} для подключения через последовательный порт, @code{pipe} для
подключения по каналу или @code{real} для подпроцесса, созданного для запуска
программы.
@end defun

@defun process-exit-status process
Функция возвращает статус выхода @var{process} или номер сигнала, который его убил.
(Использовать результат @code{process-status}, чтобы определить, какой из них.)
Если @var{process} еще не завершился, значение равно 0.  Для сетевых, последовательных
и канальных соединений, которые уже закрыты, значение равно 0 или 256, в зависимости
от того, было ли соединение закрыто нормально или ненормально.
@end defun

@defun process-tty-name process
Функция возвращает имя терминала, которое @var{process} использует для связи с Emacs
--- или @code{nil}, если используются каналы вместо pty (смотреть
@code{process-connection-type} в @ref{Asynchronous Processes}).  Если @var{process}
представляет программу, работающую на удаленном узле, имя терминала, используемое этой
программой на удаленном узле, предоставляется как свойство процесса @code{remote-tty}.
Если @var{process} представляет собой сетевое, последовательное или канальное
соединение, значение равно @code{nil}.
@end defun

@defun process-coding-system process
@anchor{Coding systems for a subprocess}
Функция возвращает cons-ячейку @code{(@var{decode} . @var{encode})}, описывающую
системы кодирования, используемые для декодирования вывода из @var{process}
(@pxref{Coding Systems}) и кодирования ввода в него.
@end defun

@defun set-process-coding-system process &optional decoding-system encoding-system
Функция определяет системы кодирования, которые будут использоваться для последующего
вывода и ввода в @var{process}.  Будет использовано @var{decoding-system} для
декодирования вывода подпроцесса и @var{encoding-system} для кодирования ввода
подпроцесса.
@end defun

  У каждого процесса также есть список свойств, который можно использовать для
хранения различных значений, связанных с процессом.

@defun process-get process propname
Функция возвращает значение свойства @var{propname} объекта @var{process}.
@end defun

@defun process-put process propname value
Функция устанавливает значение свойства @var{propname} объекта @var{process}
равное @var{value}.
@end defun

@defun process-plist process
Функция возвращает список процессов @var{process}.
@end defun

@defun set-process-plist process plist
Функция устанавливает для списка процессов @var{process} значение @var{plist}.
@end defun

@node Input to Processes
@section Отправка Ввода в Процессы
@cindex process input

  Асинхронные подпроцессы получают входные данные, когда они отправляются им из Emacs,
что делается с помощью функций этого раздела.  Потребуется указать процесс для
отправки входных данных и входные данные для отправки.  Если подпроцесс запускает
программу, данные появляются на стандартном вводе этой программы; для подключений
данные отправляются на подключенное устройство или программу.

@c FIXME который?
  Некоторые операционные системы имеют ограниченное пространство для буферизованного
ввода в pty.  В этих системах Emacs периодически отправляет @acronym{EOF} среди
других символов, чтобы заставить их пройти.  Для большинства программ эти
@acronym{EOF} не вредны.

  Вход подпроцесса обычно кодируется с использованием системы кодирования до того, как
подпроцесс получает его, как текст, записанный в файл.  Можно использовать
@code{set-process-coding-system}, чтобы указать, какую систему кодирования
использовать (@pxref{Process Information}).  В противном случае система кодирования
берется из @code{coding-system-for-write}, если это не-@code{nil}; или еще от
дефолтного механизма (@pxref{Default Coding Systems}).

  Иногда система не может принять ввод для этого процесса, потому что буфер ввода
заполнен.  Когда это происходит, функции отправки ждут некоторое время, принимая вывод
от подпроцессов, а затем повторяют попытку.  Это дает подпроцессу возможность
прочитать больше ожидающих ввода и освободить место в буфере.  Также это позволяет
запускать фильтры (включая тот, который запущен в данный момент), наблюдателей и
таймеры - так что учитывать это при написании кода.

  В этих функциях аргумент @var{process} может быть процессом или именем процесса,
или буфером, или именем буфера (что означает процесс через @code{get-buffer-process}).
@code{nil} означает текущий буферный процесс.

@defun process-send-string process string
Функция отправляет @var{process} содержимое @var{string} в качестве стандартного
ввода.  Возвращается @code{nil}.  Например, чтобы создать файлы списка буферов
оболочки:

@smallexample
@group
(process-send-string "shell<1>" "ls\n")
     @result{} nil
@end group
@end smallexample
@end defun

@defun process-send-region process start end
Функция отправляет текст в области, определенной @var{start} и @var{end}, в качестве
стандартного ввода в @var{process}.

Сообщается об ошибке, если оба @var{start} и @var{end} не являются целыми числами
или маркерами, указывающими позиции в текущем буфере.  (Неважно, какое число больше.)
@end defun

@defun process-send-eof &optional process
Функция заставляет @var{process} видеть на входе конец файла.  @acronym{EOF} идет
после любого уже отправленного ему текста. Функция возвращает @var{process}.

@smallexample
@group
(process-send-eof "shell")
     @result{} "shell"
@end group
@end smallexample
@end defun

@defun process-running-child-p &optional process
Функция сообщит, передал ли @var{process}, который должен быть не соединением, а
реальным подпроцессом, управление своим терминалом собственному дочернему процессу.
Если это правда, функция возвращает числовой идентификатор группы процессов переднего
плана @var{process}; возвращается @code{nil}, если Emacs может быть уверен, что это не
так.  Значение - @code{t}, если Emacs не может сказать, правда ли это.  Эта функция
сигнализирует об ошибке, если @var{process} является сетевым, последовательным или
канальным соединением, или если подпроцесс не активен.
@end defun

@node Signals to Processes
@section Отправка Сигналов Процессам
@cindex process signals
@cindex sending signals
@cindex signals

  @dfn{Отправка сигнала} для подпроцесса - это способ прервать его деятельность.
Есть несколько разных сигналов, каждый из которых имеет свое значение.  Набор сигналов
и их названия определяются операционной системой.  Например, сигнал @code{SIGINT}
означает, что пользователь набрал @kbd{C-c} или что произошло нечто подобное.

  Каждый сигнал стандартно влияет на подпроцесс.  Большинство сигналов убивают
подпроцесс, но вместо этого некоторые останавливают (или возобновляют) выполнение.
Большинство сигналов можно опционально обрабатывать с помощью программ; если
программа обрабатывает сигнал, то вообще ничего нельзя сказать о ее действиях.

  Можно отправлять сигналы явно, вызывая функции этого раздела.  Emacs также
автоматически отправляет сигналы в определенное время: уничтожение буфера отправляет
сигнал @code{SIGHUP} всем связанным с ним процессам; завершение работы Emacs посылает
сигнал @code{SIGHUP} всем оставшимся процессам.  (@code{SIGHUP} - это сигнал, который
обычно указывает на то, что пользователь ``повесил трубку'', то есть отключился.)

  Каждая из функций отправки сигнала принимает два необязательных аргумента:
@var{process} и @var{current-group}.

  Аргумент @var{process} должен быть либо процессом, либо именем процесса, либо
буфером, либо именем буфера, либо @code{nil}.  Имя буфера или буфер обозначает
процесс через @code{get-buffer-process}.  @code{nil} обозначает процесс, связанный с
текущим буфером.  За исключением @code{stop-process} и @code{continue-process},
ошибка выдается, если @var{process} не идентифицирует активный процесс или
представляет сетевое, последовательное или канальное соединение.

  Аргумент @var{current-group} - это флаг, который имеет значение, когда запускается
оболочка управления заданиями как подпроцесс Emacs.  Если это не-@code{nil}, то
сигнал отправляется в текущую группу процессов терминала, которую Emacs использует
для связи с подпроцессом.  Если процесс является оболочкой управления заданиями, это
означает текущее подзадание оболочки.  Если @var{current-group} равно @code{nil},
сигнал посылается группе процессов непосредственного подпроцесса Emacs.  Если
подпроцесс является оболочкой управления заданиями, это сама оболочка.  Если
@var{current-group} равно @code{lambda}, сигнал отправляется группе процессов,
владеющей терминалом, но только если это не оболочка.

  Флаг @var{current-group} не действует, когда канал используется для связи с
подпроцессом, потому что операционная система не поддерживает различие в случае
каналов.  По той же причине оболочки управления заданиями не будут работать при
использовании канала.  Смотреть @code{process-connection-type} в
@ref{Asynchronous Processes}.

@defun interrupt-process &optional process current-group
Функция прерывает процесс @var{process}, посылая сигнал @code{SIGINT}.  Вне Emacs
этот сигнал посылается при вводе символа прерывания (обычно @kbd{C-c} в некоторых
системах и @key{DEL} в других).  Когда аргумент @var{current-group} - не-@code{nil},
можно думать об этой функции как о вводе @kbd{C-c} на терминале, с помощью которого
Emacs общается с подпроцессом.
@end defun

@defun kill-process &optional process current-group
Функция убивает процесс @var{process}, посылая сигнал @code{SIGKILL}.  Этот сигнал
немедленно завершает подпроцесс и не может быть обработан подпроцессом.
@end defun

@defun quit-process &optional process current-group
Функция отправляет сигнал @code{SIGQUIT} процессу @var{process}.  Сигнал посылается
символом выхода (обычно @kbd{C-\}), когда положение не внутри Emacs.
@end defun

@defun stop-process &optional process current-group
Функция останавливает указанный @var{process}.  Если это реальный подпроцесс,
выполняющий программу, отправляется сигнал @code{SIGTSTP} этому подпроцессу.  Если
@var{process} представляет сетевое, последовательное или канальное соединение, эта
функция запрещает обработку входящих данных из соединения; для сетевого сервера это
означает отказ от новых подключений.  Использовать @code{continue-process}, чтобы
возобновить нормальное выполнение.

Вне Emacs, в системах с управлением заданиями, стоп-символ (обычно @kbd{C-z}) обычно
отправляет сигнал @code{SIGTSTP} подпроцессу.  Когда @var{current-group} равно
не-@code{nil}, можно думать об этой функции как о вводе @kbd{C-z} на терминале,
который Emacs использует для связи с подпроцессом.
@end defun

@defun continue-process &optional process current-group
Функция возобновляет выполнение процесса @var{process}.  Если это реальный подпроцесс,
выполняющий программу, посылается этому подпроцессу сигнал @code{SIGCONT}; это
предполагает, что @var{process} был остановлен ранее.  Если @var{process} представляет
собой сетевое, последовательное или канальное соединение, эта функция возобновляет
обработку входящих данных из соединения.  Для последовательных подключений данные,
поступившие во время остановки процесса, могут быть потеряны.
@end defun

@deffn Command signal-process process signal
Функция отправляет сигнал для обработки @var{process}.  Аргумент @var{signal}
указывает, какой сигнал отправить; это должно быть целое число или символ, имя
которого является сигналом.

Ааргументом @var{process} может быть системный процесс @acronym{ID} (целое число);
это позволяет посылать сигналы процессам, не являющимся дочерними по отношению к
Emacs.  @xref{System Processes}.
@end deffn

Иногда необходимо отправить сигнал нелокальному асинхронному процессу.  Это возможно,
написав собственную реализацию @code{interrupt-process}.  Затем эту функцию нужно
добавить в @code{interrupt-process-functions}.

@defvar interrupt-process-functions
Переменная представляет собой список функций, вызываемых для @code{interrupt-process}.
Аргументы функций такие же, как у @code{interrupt-process}.  Эти функции вызываются в
порядке списка, пока одна из них не вернет не-@code{nil}.  Функция по умолчанию,
которая всегда должна быть последней в этом списке, -
@code{internal-default-interrupt-process}.

Это механизм, с помощью которого Tramp реализует @code{interrupt-process}.
@end defvar

@node Output from Processes
@section Получение Вывода от Процессов
@cindex вывод процесса
@cindex процесс вывод

  Вывод, который асинхронный подпроцесс записывает в свой стандартный выходной поток,
передается функции, называемой @dfn{функция фильтра}.  Функция фильтра по умолчанию
просто вставляет вывод в буфер, который называется ассоциированным буфером процесса
(@pxref{Process Buffers}).  Если у процесса нет буфера, то фильтр по умолчанию
отбрасывает вывод.

  Если подпроцесс записывает в свой стандартный поток ошибок, по умолчанию вывод
ошибок также передается в функцию фильтрации процесса.  Если Emacs использует
псевдо-TTY (pty) для связи с подпроцессом, то невозможно разделить потоки стандартного
вывода и стандартные потоки ошибок подпроцесса, потому что псевдо-TTY имеет только
один канал вывода.  В этом случае, если требуется сохранить вывод в эти потоки
отдельно, нужно перенаправить один из них в файл - например, используя соответствующую
команду оболочки через @code{start-process-shell-command} или аналогичную функцию.

  В качестве альтернативы можно использовать параметр @code{:stderr} со значением
не-@code{nil} в вызове @code{make-process}
(@pxref{Asynchronous Processes, make-process}), чтобы сделать вывод ошибок отдельно
от стандартного вывода; в этом случае Emacs будет использовать каналы для связи с
подпроцессом.

  Когда подпроцесс завершается, Emacs читает любой ожидающий вывод, а затем прекращает
чтение вывода этого подпроцесса.  Следовательно, если у подпроцесса есть дочерние
элементы, которые все еще живы и все еще производят вывод, Emacs не получит этот
вывод.

  Выход из подпроцесса может поступать только пока Emacs ожидает: при чтении
терминального ввода (смотреть функцию @code{waiting-for-user-input-p}), в
@code{sit-for} и @code{sleep-for} (@pxref{Waiting}), в @code{accept-process-output}
(@pxref{Accepting Output}) и в функциях, которые отправляют данные в процессы
(@pxref{Input to Processes}).  Это сводит к минимуму проблему временных ошибок,
которые обычно мешают параллельному программированию.  Например, можно безопасно
создать процесс и только затем указать его функцию буфера или фильтра; никакие
выходные данные не могут поступить до завершения этого, если промежуточный код не
вызывает никаких ожидающих примитивов.

@defvar process-adaptive-read-buffering
В некоторых системах, когда Emacs считывает выходные данные подпроцесса, выходные
данные считываются очень маленькими блоками, что может привести к очень низкой
производительности.  Это поведение можно до некоторой степени исправить, установив
для переменной @code{process-adaptive-read-buffering} значение не-@code{nil} (по
умолчанию), так как это автоматически задерживает чтение из таких процессов, что
позволяет им производить больше вывода до того, как Emacs попытается его прочитать.
@end defvar

@menu
* Process Buffers::         По умолчанию вывод помещается в буфер.
* Filter Functions::        Функции фильтра принимают выходные данные процесса.
* Decoding Output::         Фильтры могут иметь однобайтовые или многобайтовые строки.
* Accepting Output::        Как дождаться прихода вывода процесса.
* Processes and Threads::   Как взаимодействуют процессы и потоки.
@end menu

@node Process Buffers
@subsection Буферы Процесса

  Процесс может (и обычно имеет) иметь @dfn{связанный буфер}, который является обычным
буфером Emacs, который используется для двух целей: для хранения выходных данных
процесса и принятия решения о том, когда завершить процесс.  Также можно использовать
буфер для идентификации процесса, над которым нужно работать, поскольку в обычной
практике с любым заданным буфером связан только один процесс.  Многие приложения
процессов также используют буфер для редактирования ввода, отправляемого процессу, но
он не встроен в Emacs Lisp.

  По умолчанию вывод процесса вставляется в связанный буфер.  (Можно изменить это,
определив пользовательскую функцию фильтра, @pxref{Filter Functions}.)  Позиция для
вставки вывода определяется @code{process-mark}, который затем обновляется, чтобы
указать на конец только что вставленного текста.  Обычно, но не всегда,
@code{process-mark} находится в конце буфера.

@findex process-kill-buffer-query-function
  Удаление связанного с процессом буфера также приводит к уничтожению процесса.
Emacs сначала запрашивает подтверждение, если @code{process-query-on-exit-flag}
процесса - не-@code{nil} (@pxref{Query Before Exit}).  Это подтверждение выполняет
функция @code{process-kill-buffer-query-function}, запускаемая из
@code{kill-buffer-query-functions} (@pxref{Killing Buffers}).

@defun process-buffer process
Функция возвращает связанный буфер указанного @var{process}.

@smallexample
@group
(process-buffer (get-process "shell"))
     @result{} #<buffer *shell*>
@end group
@end smallexample
@end defun

@defun process-mark process
Функция возвращает маркер процесса для @var{process}, который указывает, куда
вставить вывод процесса.

Если @var{process} не имеет буфера, @code{process-mark} возвращает маркер, который
никуда не указывает.

Функция фильтра по умолчанию использует этот маркер, чтобы решить, куда вставить
вывод процесса, и обновляет его так, чтобы он указывал после вставленного текста.  Вот
почему последовательные пакеты вывода вставляются последовательно.

Пользовательские функции фильтра обычно должны использовать этот маркер таким же
образом.  Для примера функции фильтра, которая использует @code{process-mark},
@pxref{Process Filter Example}.

Когда ожидается, что пользователь введет ввод в буфер процесса для передачи процессу,
маркер процесса отделяет новый ввод от предыдущего вывода.
@end defun

@defun set-process-buffer process buffer
Функция устанавливает буфер, связанный с @var{process}, на @var{buffer}.  Если
@var{buffer} равен @code{nil}, процесс становится связанным без буфера.
@end defun

@defun get-buffer-process buffer-or-name
Функция возвращает неудаленный процесс, связанный с буфером, указанным в
@var{buffer-or-name}.  Если с ней связано несколько процессов, функция выбирает один
(в настоящее время последний созданный, но не рассчитывать на это).  Удаление процесса
(смотреть @code{delete-process}) делает невозможным возврат этой функции.

Обычно плохая идея иметь более одного процесса, связанного с одним и тем же буфером.

@smallexample
@group
(get-buffer-process "*shell*")
     @result{} #<process shell>
@end group
@end smallexample

Удаление буфера процесса удаляет процесс, который завершает подпроцесс сигналом
@code{SIGHUP} (@pxref{Signals to Processes}).
@end defun

Если буфер процесса отображается в окне, программа на Lisp может пожелать сообщить
процессу размеры этого окна, чтобы процесс мог адаптировать свой вывод к этим
измерениям, так же, как он адаптируется к размерам экрана.  Следующие функции
позволяют передавать такую информацию процессам; однако не все системы поддерживают
базовую функциональность, поэтому лучше всего использовать резервные варианты,
например, с помощью аргументов командной строки или переменных среды.

@defun set-process-window-size process height width
Сообщить процессу @var{process}, что размер его логического окна имеет размеры
@var{width} на @var{height} в единицах символов.  Если этой функции удается передать
эту информацию процессу, она возвращает @code{t}; в противном случае возвращается
@code{nil}.
@end defun

Когда окна, отображающие буферы, связанные с процессом, изменяют свои размеры,
затронутые процессы должны быть проинформированы об этих изменениях.  По умолчанию,
когда конфигурация окна изменяется, Emacs автоматически вызывает
@code{set-process-window-size} от имени каждого процесса, буфер которого отображается
в окне, передавая ему наименьшие размеры всех окон, отображающих буфер процесса.  Это
работает через @code{window-configuration-change-hook} (@pxref{Window Hooks}),
которому указано вызвать функцию, которая является значением переменной
@code{window-adjust-process-window-size-function} для каждого процесса, буфер которого
отображается как минимум в одном окне.  Можно настроить это поведение, установив
значение этой переменной.

@defopt window-adjust-process-window-size-function
Значение этой переменной должно быть функцией двух аргументов: процесса и списка окон,
отображающих буфер процесса.  Когда функция вызывается, буфер процесса является
текущим буфером.  Функция должна возвращать cons-ячейку
@w{@code{(@var{width} . @var{height})}}, которая описывает размеры окна логического
процесса, передаваемого через вызов @code{set-process-window-size}.  Функция также
может возвращать @code{nil}, и в этом случае Emacs не будет вызывать
@code{set-process-window-size} для этого процесса.

Emacs предоставляет для этой переменной два предопределенных значения:
@code{window-adjust-process-window-size-smallest}, которое возвращает наименьшее из
всех размеров окон, отображающих буфер процесса; и
@code{window-adjust-process-window-size-largest}, которое возвращает наибольшие
размеры.  Для более сложных стратегий напишите свою собственную функцию.

Переменная может быть локальной для буфера.
@end defopt

Если у процесса есть свойство @code{adjust-window-size-function}
(@pxref{Process Information}), его значение переопределяет глобальные и локальные в
буфере значения @code{window-adjust-process-window-size-function}.

@node Filter Functions
@subsection Функции Фильтра Процесса
@cindex фильтр функции
@cindex процесс фильтры

@cindex функция фильтра по умолчанию для процесса
  Процесс @dfn{функция фильтра} - это функция, которая получает стандартный вывод от
связанного процесса.  @emph{Весь} вывод этого процесса передается фильтру.  Фильтр по
умолчанию просто выводит данные непосредственно в буфер процесса.

  По умолчанию вывод ошибок из процесса, если таковые имеются, также передается в
функцию фильтрации, если место назначения для стандартного потока ошибок процесса не
было отделено от стандартного вывода при создании процесса.  Emacs будет вызывать
функцию фильтра только во время определенных вызовов функций.
@xref{Output from Processes}.  Обратить внимание, что если какая-либо из этих функций
вызывается фильтром, фильтр может вызываться рекурсивно.

  Функция фильтра должна принимать два аргумента: связанный процесс и строку, которая
выводится только что от нее.  Затем функция может делать с выводом все, что пожелает.

@c Обратить внимание, что этот текст дублируется в разделе «Наблюдатели».
  Выход обычно запрещается функцией фильтра - в противном случае эффект ввода
@kbd{C-g} на уровне команды или выхода из команды пользователя был бы непредсказуем.
Если требуется разрешить выход внутри функции фильтра, привязать @code{inhibit-quit}
к @code{nil}.  В большинстве случаев правильный способ сделать это - использовать
макрос @code{with-local-quit}.  @xref{Quitting}.

  Если ошибка происходит во время выполнения функции фильтра, она перехватывается
автоматически, чтобы не останавливать выполнение любой программы, которая выполнялась
при запуске функции фильтрации.  Однако, если @code{debug-on-error} равно
не-@code{nil}, ошибки не обнаруживаются.  Это позволяет использовать отладчик Lisp для
отладки функций фильтрации.  @xref{Debugger}.

 Многие функции фильтрации иногда (или всегда) вставляют вывод в буфер процесса,
имитируя действия фильтра по умолчанию.  Такие функции фильтрации должны убедиться,
что они сохраняют текущий буфер, выбирают правильный буфер (если он другой) перед
вставкой вывода, а затем восстанавливают исходный буфер.  Также проводиться проверка,
жив ли буфер, обновить маркер процесса и в некоторых случаях обновить значение точки.
Вот как это сделать:

@anchor{Process Filter Example}
@smallexample
@group
(defun ordinary-insertion-filter (proc string)
  (when (buffer-live-p (process-buffer proc))
    (with-current-buffer (process-buffer proc)
      (let ((moving (= (point) (process-mark proc))))
@end group
@group
        (save-excursion
          ;; @r{Вставить текст, продвигая маркер процесса.}
          (goto-char (process-mark proc))
          (insert string)
          (set-marker (process-mark proc) (point)))
        (if moving (goto-char (process-mark proc)))))))
@end group
@end smallexample

  Чтобы фильтр принудительно отображал буфер процесса всякий раз, когда приходит
новый текст, можно вставить строку, подобную следующей, непосредственно перед
конструкцией @code{with-current-buffer}:

@smallexample
(display-buffer (process-buffer proc))
@end smallexample

  Чтобы указать на конец нового вывода, независимо от того, где он был ранее, удалить
переменную @code{moving} из примера и вызвать @code{goto-char} безоговорочно.
Обратить внимание, что это не обязательно перемещает точку окна.  Фильтр по умолчанию
фактически использует @code{insert-before-markers}, который перемещает все маркеры,
включая точку окна.  Это может переместить несвязанные маркеры, поэтому обычно лучше
переместить точку окна явно или установить для нее тип вставки @code{t}
(@pxref{Window Point}).

@ignore
  В более ранних версиях Emacs каждая функция фильтра, которая выполняла поиск или
сопоставление регулярных выражений, должна была явно сохранять и восстанавливать
данные сопоставления.  Теперь Emacs делает это автоматически для функций фильтрации; 
им никогда не нужно делать это явно.
@end ignore
  Обратить внимание, что Emacs автоматически сохраняет и восстанавливает данные
совпадений при выполнении функций фильтрации.  @xref{Match Data}.

  Выходные данные фильтра могут приходить кусками любого размера.  Программа, которая
производит один и тот же результат дважды подряд, может отправлять его один раз в виде
одного пакета по 200 символов и пяти пакетов по 40 символов в следующий раз.  Если
фильтр ищет определенные текстовые строки в выводе подпроцесса, обязательно
обработать случай, когда одна из этих строк разделена на два или более пакетов вывода;
один из способов сделать это - вставить полученный текст во временный буфер, в котором
затем можно будет выполнить поиск.

@defun set-process-filter process filter
Функция дает @var{process} функцию фильтрации @var{filter}.  Если @var{filter} равно
@code{nil}, выдаётся процессу фильтр по умолчанию, который вставляет вывод процесса в
буфер процесса.
@end defun

@defun process-filter process
Функция возвращает функцию фильтра @var{process}.
@end defun

Если вывод процесса необходимо передать нескольким фильтрам, можно использовать
@code{add-function}, чтобы объединить существующий фильтр с новым.
@xref{Advising Functions}.

  Вот пример использования функции фильтра:

@smallexample
@group
(defun keep-output (process output)
   (setq kept (cons output kept)))
     @result{} keep-output
@end group
@group
(setq kept nil)
     @result{} nil
@end group
@group
(set-process-filter (get-process "shell") 'keep-output)
     @result{} keep-output
@end group
@group
(process-send-string "shell" "ls ~/other\n")
     @result{} nil
kept
     @result{} ("lewis@@slug:$ "
@end group
@group
"FINAL-W87-SHORT.MSS    backup.otl              kolstad.mss~
address.txt             backup.psf              kolstad.psf
backup.bib~             david.mss               resume-Dec-86.mss~
backup.err              david.psf               resume-Dec.psf
backup.mss              dland                   syllabus.mss
"
"#backups.mss#          backup.mss~             kolstad.mss
")
@end group
@end smallexample

@ignore   @c Код в этом примере не показывает правильный способ делать что-то.
Вот еще один, более реалистичный пример, демонстрирующий, как использовать метку
процесса для вставки таким же образом, как и фильтр по умолчанию:

@smallexample
@group
;; @r{Вставить ввод в буфер, указанный @code{my-shell-buffer}}
;;   @r{и убедиться, что этот буфер отображается в каком-либо окне.}
(defun my-process-filter (proc str)
  (let ((cur (selected-window))
        (pop-up-windows t))
    (pop-to-buffer my-shell-buffer)
@end group
@group
    (goto-char (point-max))
    (insert str)
    (set-marker (process-mark proc) (point-max))
    (select-window cur)))
@end group
@end smallexample
@end ignore

@node Decoding Output
@subsection Декодирование Выхода Процесса
@cindex decode process output

  Когда Emacs записывает вывод процесса непосредственно в многобайтовый буфер, он
декодирует вывод в соответствии с системой кодирования вывода процесса.  Если система
кодирования - @code{raw-text} или @code{no-conversion}, Emacs преобразует однобайтовый
вывод в многобайтовый, используя @code{string-to-multibyte}, и вставляет полученный
многобайтовый текст.

  Можно использовать @code{set-process-coding-system}, чтобы указать, какую систему
кодирования использовать (@pxref{Process Information}).  В противном случае система
кодирования берется из @code{coding-system-for-read}, если это не-@code{nil}; или еще
от дефолтного механизма (@pxref{Default Coding Systems}).  Если текст, выводимый
процессом, содержит нулевые байты, Emacs по умолчанию использует для него
@code{no-conversion}; смотреть
@ref{Lisp and Coding Systems, inhibit-null-byte-detection}, как управлять этим
поведением.

  @strong{Предупреждение:} Системы кодирования, такие как @code{undecided}, которые
определяют систему кодирования по данным, не работают полностью надежно с асинхронным
выводом подпроцесса.  Это потому, что Emacs должен обрабатывать вывод асинхронного
подпроцесса пакетами по мере его поступления.  Emacs должен пытаться определить
правильную систему кодирования по одному пакету за раз, и это не всегда срабатывает.
Поэтому, если это вообще возможно, указать систему кодирования, которая определяет как
преобразование кода символа, так и преобразование конца строки, то есть такую, как
@code{latin-1-unix}, а не @code{undecided} или @code{latin-1}.

@c Давайте сохраним записи указателя, которые были там для
@c set-process-filter-multibyte и process-filter-multibyte-p,
@cindex фильтр процесса многобайтовый флаг
@cindex многобайтовый флаг фильтра процесса
  Когда Emacs вызывает функцию фильтрации процесса, предоставляется вывод процесса в
виде многобайтовой строки или однобайтовой строки в соответствии с системой
кодирования фильтра процесса.  Emacs декодирует вывод в соответствии с системой
кодирования вывода процесса, которая обычно производит многобайтовую строку, за
исключением таких систем кодирования, как @code{binary} и @code{raw-text}.

@node Accepting Output
@subsection Принятие Вывода от Процессов
@cindex принятие ввода от процессов

  Выходные данные асинхронных подпроцессов обычно поступают только тогда, когда Emacs
ожидает какого-либо внешнего события, такого как истекшее время или ввод терминала.
Иногда в программе на Lisp полезно явно разрешить выходным данным достичь определенной
точки или даже дождаться, пока выходные данные не поступят от процесса.

@defun accept-process-output &optional process seconds millisec just-this-one
Функция позволяет Emacs читать ожидающий вывод от процессов.  Выходные данные
передаются их функциям фильтрации.  Если @var{process} равен не-@code{nil}, то эта
функция не возвращается, пока не будет получен какой-либо вывод от @var{process} или
@var{process} не закрыл соединение.

Аргументы @var{seconds} и @var{millisec} позволяют указать периоды ожидания.  Первый
указывает период, измеряемый в секундах, а второй - период в миллисекундах.  Два
указанных таким образом периода времени складываются, и @code{accept-process-output}
возвращается по истечении этого времени, даже если нет вывода подпроцесса.

Аргумент @var{millisec} устарел (и не должен использоваться), потому что @var{seconds}
может быть с плавающей запятой, чтобы указать время ожидания дробное количество
секунд.  Если @var{seconds} равно 0, функция принимает любой ожидающий вывод, но
не ждет.

@c Emacs 22.1 feature
Если @var{process} - это процесс, а аргумент @var{just-this-one} - не-@code{nil},
обрабатывается только вывод этого процесса, приостанавливая вывод от других процессов
до тех пор, пока какой-либо вывод не будет получен от этого процесса или не истечет
время ожидания.  Если @var{just-this-one} - целое число, также запретить запуск
таймеров.  Эта функция обычно не рекомендуется, но может быть необходима для
определенных приложений, таких как синтез речи.

Функция @code{accept-process-output} возвращает не-@code{nil}, если получен результат
от @var{process}, или от любого процесса, если @var{process} - @code{nil}; это может
произойти даже после выхода из процесса, если соответствующее соединение содержит
буферизованные данные.  Функция возвращает @code{nil}, если время ожидания истекло
или соединение было закрыто до прихода вывода.
@end defun

Если соединение от процесса содержит буферизованные данные,
@code{accept-process-output} может вернуть не-@code{nil} даже после выхода из
процесса.  Поэтому хотя и следующий цикл:

@example
;; Этот цикл содержит ошибку.
(while (process-live-p process)
  (accept-process-output process))
@end example

@noindent
будет часто читать весь вывод @var{process}, он имеет состояние гонки и может
пропустить какой-то вывод, если @code{process-live-p} возвращает @code{nil}, в то
время как соединение все еще содержит данные.  Лучше написать цикл так:

@example
(while (accept-process-output process))
@end example

@node Processes and Threads
@subsection Процессы и Потоки
@cindex processes, threads

  Поскольку потоки были относительно поздним добавлением к Emacs Lisp и из-за того,
что динамическое связывание иногда использовалось вместе с
@code{accept-process-output}, по умолчанию процесс блокируется для потока, который его
создал.  Когда процесс заблокирован для потока, вывод процесса может быть принят
только этим потоком.

  Программа на Lisp может указать, для какого потока процесс должен быть заблокирован,
или дать команду Emacs разблокировать процесс, и в этом случае ее вывод может быть
обработан любым потоком.  Только один поток будет ждать вывода от данного процесса
одновременно - как только один поток начинает ждать вывода, процесс временно
блокируется до тех пор, пока @code{accept-process-output} или @code{sit-for} не
вернется.

  Если поток завершается, все процессы, заблокированные для него, разблокируются.

@defun process-thread process
Вернуть поток, в котором заблокирован @var{process}.  Если @var{process}
разблокирован, вернуть @code{nil}.
@end defun

@defun set-process-thread process thread
Установить блокировку @var{process} с @var{thread}.  @var{thread} может быть
@code{nil}, и в этом случае процесс разблокируется.
@end defun

@node Sentinels
@section Наблюдатель: Обнаружение Изменений Статуса Процесса
@cindex process sentinel
@cindex sentinel (of process)

  @dfn{Процесс наблюдатель} - это функция, которая вызывается всякий раз, когда
связанный процесс меняет статус по любой причине, включая сигналы (отправленные Emacs
или вызванные собственными действиями процесса), которые завершают, останавливают или
продолжают процесс.  Наблюдатель процесса также вызывается, если процесс завершается.
Наблюдаетель получает два аргумента: процесс, для которого произошло событие, и
строку, описывающую тип события.

@cindex контрольная функция процесса по умолчанию
  Если для процесса не указана функция наблюдаетель, он будет использовать стандартную
контрольную функцию, которая вставляет сообщение в буфер процесса с именем процесса и
строкой, описывающей событие.

  Строка, описывающая событие, выглядит следующим образом:

@itemize @bullet
@item
@code{"finished\n"}.

@item
@code{"deleted\n"}.

@item
@code{"exited abnormally with code @var{exitcode} (ядро сброшено)\n"}.
Часть ``ядро сброшено'' является необязательной и появляется только в том случае,
если процесс выгружает ядро.

@item
@code{"failed with code @var{fail-code}\n"}.

@item
@code{"@var{signal-description} (ядро сброшено)\n"}.  @var{signal-description} - это
системно-зависимое текстовое описание сигнала, например, @code{"killed"} для
@code{SIGKILL}.  Часть ``ядро сброшено'' является необязательной и появляется только
в том случае, если процесс выгружает ядро.

@item
@code{"open from @var{host-name}\n"}.

@item
@code{"open\n"}.

@item
@code{"connection broken by remote peer\n"}.
@end itemize

  Наблюдатель запускается только тогда, когда Emacs ожидает (например, ввода
терминала, или истечения времени, или вывода процесса).  Это позволяет избежать ошибок
синхронизации, которые могут возникнуть в результате запуска контрольных точек в
случайных местах в середине других программ на Lisp.  Программа может подождать, пока
запустятся наблюдатели, вызывая @code{sit-for} или @code{sleep-for} (@pxref{Waiting})
или @code{accept-process-output} (@pxref{Accepting Output}).  Emacs также позволяет
запускать наблюдателей, когда командный цикл считывает ввод.  @code{delete-process}
вызывает наблюдателя, когда завершает запущенный процесс.

  Emacs не хранит очередь из нескольких причин для вызова наблюдателя одного процесса;
записывает только текущий статус и факт изменения.  Таким образом, два изменения
статуса, происходящие в быстрой последовательности, могут вызвать наблюдателя только
один раз.  Однако завершение процесса всегда запускает наблюдателя только один раз.
Это связано с тем, что статус процесса не может измениться снова после завершения.

  Emacs явно проверяет вывод процесса перед запуском наблюдателя процесса.  Как только
наблюдатель запускается из-за завершения процесса, дальнейшие выходные данные от
процесса поступать не могут.

  Наблюдаетель, записывающий вывод в буфер процесса, должен проверить, жив ли еще
буфер.  Если попытаться вставить в несуществующий буфер, получится ошибка.  Если
буфера нет, @code{(buffer-name (process-buffer @var{process}))} возвращает @code{nil}.

@c Обратить внимание, что этот текст дублируется в разделе функций фильтра.
  Завершение работы обычно запрещено внутри устройства наблюдения - в противном случае
эффект ввода @kbd{C-g} на уровне команды или выхода из команды пользователя был бы
непредсказуем.  Если требуется разрешить завершение работы внутри наблюдателя,
привязать @code{inhibit-quit} к @code{nil}.  В большинстве случаев правильный способ
сделать это - использовать макрос @code{with-local-quit}.  @xref{Quitting}.

  Если во время выполнения наблюдения происходит ошибка, она перехватывается
автоматически, чтобы не останавливать выполнение любых программ, запущенных при
запуске наблюдателя.  Однако, если @code{debug-on-error} равно не-@code{nil}, ошибки
не обнаруживаются.  Это позволяет использовать отладчик Lisp для отладки наблюдателя.
@xref{Debugger}.

  Пока наблюдатель работает, процесс наблюдатель временно устанавливается на
@code{nil}, чтобы наблюдатель не запускался рекурсивно.  По этой причине наблюдатель
не может указать нового наблюдателя.

@ignore
  В более ранних версиях Emacs каждый дозорный, который выполнял поиск или
сопоставление регулярных выражений, должен был явно сохранять и восстанавливать
данные сопоставления.  Теперь Emacs делает это автоматически для часовых; им никогда
 не нужно делать это явно.
@end ignore
 Заметить, что Emacs автоматически сохраняет и восстанавливает данные совпадений при
выполнении наблюдателя.  @xref{Match Data}.

@defun set-process-sentinel process sentinel
Функция связывает @var{sentinel} с @var{process}.  Если @var{sentinel} равно
@code{nil}, то процесс будет иметь дозорного по умолчанию, который вставляет сообщение
в буфер процесса при изменении статуса процесса.

Изменения в дозорных процессах вступают в силу немедленно - если дозорный планируется
запустить, но он еще не был вызван, и указывается новый дозорный, при последующем
вызове дозорного будет использоваться новый.

@smallexample
@group
(defun msg-me (process event)
   (princ
     (format "Process: %s had the event '%s'" process event)))
(set-process-sentinel (get-process "shell") 'msg-me)
     @result{} msg-me
@end group
@group
(kill-process (get-process "shell"))
     @print{} Process: #<process shell> had the event 'killed'
     @result{} #<process shell>
@end group
@end smallexample
@end defun

@defun process-sentinel process
Функция возвращает дозорного @var{process}.
@end defun

В случае, если изменения статуса процесса необходимо передать нескольким дозорным,
можно использовать @code{add-function} для объединения существующего дозорного с
новым.  @xref{Advising Functions}.

@defun waiting-for-user-input-p
Пока функция дозорного или фильтра работает, функция возвращает не-@code{nil}, если
Emacs ждал ввода с клавиатуры от пользователя в момент вызова функции дозорного или
фильтра, или @code{nil}, если это не так.
@end defun

@node Query Before Exit
@section Запрос Перед Выходом

  Когда Emacs завершает работу, завершает все свои подпроцессы.  Для подпроцессов,
запускающих программу, отправляется сигнал @code{SIGHUP}; соединения просто
закрываются.  Поскольку подпроцессы могут выполнять ценную работу, Emacs обычно
просит пользователя подтвердить, что их можно завершить.  У каждого процесса есть
флаг запроса, который, если не-@code{nil}, говорит, что Emacs должен запрашивать
подтверждение перед выходом и, таким образом, прерывать этот процесс.  По умолчанию
для флага запроса установлено значение @code{t}, что означает @emph{выполнять} запрос.

@defun process-query-on-exit-flag process
Возвращается флаг запроса @var{process}.
@end defun

@defun set-process-query-on-exit-flag process flag
Функция устанавливает флаг запроса @var{process} в @var{flag}.  Возвращается
@var{flag}.

Вот пример использования @code{set-process-query-on-exit-flag} в процессе оболочки,
чтобы избежать запросов:

@smallexample
@group
(set-process-query-on-exit-flag (get-process "shell") nil)
     @result{} nil
@end group
@end smallexample
@end defun

@defopt confirm-kill-processes
Если для этой пользовательской опции установлено значение @code{t} (по умолчанию), то
Emacs запрашивает подтверждение перед завершением процессов при выходе.  Если это
@code{nil}, Emacs уничтожает процессы без подтверждения, то есть флаг запроса всех
процессов игнорируется.
@end defopt

@node System Processes
@section Доступ к Другим Процессам
@cindex system processes

  Помимо доступа к процессам, которые являются подпроцессами текущего сеанса Emacs, и
управления ими, программы Emacs Lisp также могут обращаться к другим процессам,
запущенным на той же машине.  Называются они @dfn{системные процессы}, чтобы отличить
их от подпроцессов Emacs.

  Emacs предоставляет несколько примитивов для доступа к системным процессам.  Не все
платформы поддерживают эти примитивы; на тех, которые этого не делают, эти примитивы
возвращают @code{nil}.

@defun list-system-processes
Функция возвращает список всех процессов, запущенных в системе.  Каждый процесс
идентифицируется своим @acronym{PID}, числовым идентификатором процесса, который
назначается операционной системой и отличает этот процесс от всех других процессов,
выполняемых на той же машине в одно и то же время.
@end defun

@defun process-attributes pid
Функция возвращает список атрибутов для процесса, заданного его идентификатором
@var{pid}.  Каждая ассоциация в списке имеет форму @code{(@var{key} . @var{value})},
где @var{key} обозначает атрибут, а @var{value} - значение этого атрибута.  Ниже
перечислены различные атрибуты @var{key}, которые может возвращать эта функция.  Не
все платформы поддерживают все эти атрибуты; если атрибут не поддерживается, его связь
не появится в возвращаемом списке.  Значения, являющиеся числами, могут быть целыми
числами или с плавающей запятой, в зависимости от величины значения.

@table @code
@item euid
Эффективный идентификатор пользователя, запустившего процесс.  Соответствующее
значение @var{value} - это число.  Если процесс был запущен тем же пользователем,
который запускает текущий сеанс Emacs, значение идентично тому, что возвращает
@code{user-uid} (@pxref{User Identification}).

@item user
Имя пользователя, соответствующее эффективному идентификатору пользователя
процесса, строка.

@item egid
Идентификатор группы эффективного идентификатора пользователя, число.

@item group
Имя группы, соответствующее действующему идентификатору группы пользователя, строка.

@item comm
Имя команды, выполняемой в процессе.  Это строка, которая обычно указывает имя
исполняемого файла процесса без ведущих каталогов.  Однако некоторые специальные
системные процессы могут сообщать строки, не соответствующие исполняемому файлу
программы.

@item state
Статический код процесса.  Это короткая строка, которая кодирует состояние
планирования процесса.  Вот список наиболее часто встречающихся кодов:

@table @code
@item "D"
непрерывный сон (обычно ввод-вывод)
@item "R"
Запущен
@item "S"
прерывистый сон (ожидание какого-то события)
@item "T"
остановлен, например, сигналом управления заданием
@item "Z"
зомби: процесс, который завершился, но не был получен его родителем
@end table

@noindent
Полный список возможных состояний смотреть на странице руководства по
команде @command{ps}.

@item ppid
Идентификатор родительского процесса, число.

@item pgrp
Идентификатор группы процессов процесса, число.

@item sess
Идентификатор сеанса процесса.  Это номер, который является идентификатором процесса
@dfn{лидер сессии}.

@item ttname
Строка, представляющая собой имя управляющего терминала процесса.  В системах Unix и
GNU это обычно имя файла соответствующего терминального устройства, например
@file{/dev/pts65}.

@item tpgid
Числовой идентификатор группы процессов группы процессов переднего плана, которая
использует терминал процесса.

@item minflt
Количество незначительных ошибок страниц, вызванных процессом с момента его начала.
(Незначительные ошибки страницы - это те, которые не связаны с чтением с диска.)

@item majflt
Количество серьезных ошибок страниц, вызванных процессом с момента его начала.
(Для серьезных ошибок страниц требуется чтение с диска, поэтому они обходятся
дороже, чем мелкие ошибки страниц.)

@item cminflt
@itemx cmajflt
Аналогично @code{minflt} и @code{majflt}, но включает количество ошибок страниц для
всех дочерних процессов данного процесса.

@item utime
Время, затрачиваемое процессом в контексте пользователя на выполнение кода приложения.
Соответствующее значение @var{value} имеет формат
@w{@code{(@var{high} @var{low} @var{microsec} @var{picosec})}}, тот же формат, который
используется функциями @code{current-time} (@pxref{Time of Day, current-time}) и
@code{file-attributes} (@pxref{File Attributes}).

@item stime
Время, затрачиваемое процессом в контексте системы (ядра) на обработку системных
вызовов.  Соответствующее значение @var{value} имеет тот же формат, что и
@code{utime}.

@item time
Сумма @code{utime} и @code{stime}.  Соответствующее @var{value} имеет тот
же формат, что и @code{utime}.

@item cutime
@itemx cstime
@itemx ctime
Аналогично @code{utime}, @code{stime} и @code{time}, но включает время всех дочерних
процессов данного процесса.

@item pri
Числовой приоритет процесса.

@item nice
@dfn{хорошее значение} процесса, номер.  (Процессы с меньшими значениями nice
планируются более благоприятно.)

@item thcount
Количество потоков в процессе.

@item start
Время, когда процесс был запущен, в том же формате
@code{(@var{high} @var{low} @var{microsec} @var{picosec})}, что
@code{file-attributes} и @code{current-time}.

@item etime
Время, прошедшее с момента запуска процесса, в формате
@code{(@var{high} @var{low} @var{microsec} @var{picosec})}.

@item vsize
Размер виртуальной памяти процесса, измеряемый в килобайтах.

@item rss
Размер @dfn{резидентского набора} процесса, количество килобайт, занимаемых
процессом в физической памяти машины.

@item pcpu
Процент процессорного времени, использованного процессом с момента его запуска.
Соответствующее значение @var{value} - это число с плавающей запятой от 0 до 100.

@item pmem
Процент общей физической памяти, установленной на машине, используемой резидентным
набором процесса.  Значение представляет собой число с плавающей запятой от 0 до 100.

@item args
Командная строка, с которой был вызван процесс.  Это строка, в которой отдельные
аргументы командной строки разделены пробелами; символы пробела, встроенные в
аргументы, заключаются в кавычки, соответствующие системной оболочке: экранируются
символами обратной косой черты в GNU и Unix и заключаются в двойные кавычки в Windows.
Таким образом, эту строку командной строки можно напрямую использовать в примитивах,
таких как @code{shell-command}.
@end table

@end defun


@node Transaction Queues
@section Очереди Транзакций
@cindex transaction queue

@c Это не очень информативно.  Что такое транзакция и когда мной может быть
@c использована?
Можно использовать @dfn{очередь транзакций} для связи с подпроцессом с помощью
транзакций.  Сначала использовать @code{tq-create} для создания очереди транзакций,
взаимодействующей с указанным процессом.  Затем можно вызвать @code{tq-enqueue} для
отправки транзакции.

@defun tq-create process
Функция создает и возвращает очередь транзакций, взаимодействующую с @var{process}.
Аргумент @var{process} должен быть подпроцессом, способным отправлять и получать
потоки байтов.  Это может быть дочерний процесс или TCP-соединение с сервером,
возможно, на другом компьютере.
@end defun

@defun tq-enqueue queue question regexp closure fn &optional delay-question
Функция отправляет транзакцию в очередь @var{queue}.  Указание очереди приводит к
указанию подпроцесса, с которым нужно взаимодействовать.

Аргумент @var{question} - это исходящее сообщение, с которого начинается транзакция.
Аргумент @var{fn} - это функция, вызываемая при получении соответствующего ответа;
она вызывается с двумя аргументами: @var{closure} и полученный ответ.

Аргумент @var{regexp} - это регулярное выражение, которое должно соответствовать
тексту в конце всего ответа, но не до него; вот как @code{tq-enqueue} определяет,
где заканчивается ответ.

Если аргумент @var{delay-question} - не-@code{nil}, отложить отправку этого вопроса
до тех пор, пока процесс не закончит отвечать на все предыдущие вопросы.  Это дает
более надежные результаты для некоторых процессов.
@ignore

@c Тогда не будем об этом упоминать.  Возвращаемое значение @code{tq-enqueue}
@c само по себе не имеет смысла.
@end ignore
@end defun

@defun tq-close queue
Завершить очередь транзакций @var{queue}, ожидая завершения всех ожидающих транзакций,
а затем завершить соединение или дочерний процесс.
@end defun

Очереди транзакций реализованы с помощью функции фильтрации.
@xref{Filter Functions}.

@node Network
@section Сетевые Соединения
@cindex network connection
@cindex TCP
@cindex UDP

  Программы Emacs Lisp могут открывать сетевые соединения потока (TCP) и дейтаграммы
(UDP) (@pxref{Datagrams}) с другими процессами на той же или других машинах.  Сетевое
соединение обрабатывается Lisp во многом как подпроцесс и представлено объектом
процесса.  Однако процесс, с которым происходит общение, не является потомком процесса
Emacs, не имеет процесса @acronym{ID}, и не выйдет его убить или послать ему сигналы.
Все, что можно делать, это отправлять и получать данные.  @code{delete-process}
закрывает соединение, но не убивает программу на другом конце; эта программа должна
решить, что делать с закрытием соединения.

  Программы на Lisp могут прослушивать соединения, создавая сетевые серверы.  Сетевой
сервер также представлен своего рода объектом процесса, но, в отличие от сетевого
соединения, сетевой сервер никогда не передает данные сам.  Когда он получает запрос
на соединение, он создает новое сетевое соединение, представляющее только что
установленное соединение.  (Сетевое соединение наследует определенную информацию,
включая список процессов, от сервера.)  Затем сетевой сервер возвращается к
прослушиванию дополнительных запросов на соединение.

  Сетевые соединения и серверы создаются путем вызова @code{make-network-process} со
списком аргументов, состоящим из пар ключевое слово/аргумент, например
@code{:server t} для создания серверного процесса или @code{:type 'datagram} для
создания датаграммного соединения.  @xref{Low-Level Network}, для подробностей.
Также можно использовать функцию @code{open-network-stream}, описанную ниже.

  Чтобы различать различные типы процессов, функция @code{process-type} возвращает
символ @code{network} для сетевого соединения или сервера, @code{serial} для
соединения через последовательный порт, @code{pipe} для соединения по каналу или
@code{real} для реального подпроцесса.

  Функция @code{process-status} возвращает @code{open}, @code{closed}, @code{connect},
@code{stop} или @code{failed} для сетевых подключений.  Для сетевого сервера статус
всегда @code{listen}.  За исключением @code{stop}, ни одно из этих значений
невозможно для реального подпроцесса.  @xref{Process Information}.

  Можно остановить и возобновить работу сетевого процесса, вызвав @code{stop-process}
и @code{continue-process}.  Для серверного процесса остановка означает отказ от новых
подключений.  (До 5 запросов на подключение будут поставлены в очередь, когда
возобновится работа сервера; можно увеличить этот предел, если он не наложен
операционной системой - смотреть ключевое слово @code{:server} для
@code{make-network-process}, @ref{Network Processes}.)  Для подключения к сетевому
потоку остановка означает не обрабатывать ввод (любой поступающий ввод ожидает, пока
не возобновится соединение).  Для подключения дейтаграммы некоторое количество пакетов
может быть поставлено в очередь, но ввод может быть потерян.  Можно использовать
функцию @code{process-command}, чтобы определить, остановлено ли сетевое соединение
или сервер; значение не-@code{nil} означает да.

@cindex сетевое соединение, зашифрованное
@cindex зашифрованные сетевые соединения
@cindex @acronym{TLS} сетевое соединение
@cindex @acronym{STARTTLS} сетевое соединение
Emacs может создавать зашифрованные сетевые соединения, используя встроенную или
внешнюю поддержку.  Встроенная поддержка использует библиотеку безопасности
транспортного уровня GnuTLS;  смотреть
@uref{https://www.gnu.org/software/gnutls/, the GnuTLS project page}.
Если Emacs скомпилирован с поддержкой GnuTLS, функция @code{gnutls-available-p}
определена и возвращает не-@code{nil}.  Для получения более подробной информации,
@pxref{Top,, Overview, emacs-gnutls, The Emacs-GnuTLS manual}.  Внешняя поддержка
использует библиотеку @file{starttls.el}, для которой в системе должна быть
установлена вспомогательная утилита, такая как @command{gnutls-cli}.
Функция @code{open-network-stream} может прозрачно обрабатывать детали создания
зашифрованных соединений, используя любую доступную поддержку.

@defun open-network-stream name buffer host service &rest parameters
Функция открывает TCP-соединение с дополнительным шифрованием и возвращает объект
процесса, представляющий соединение.

Аргумент @var{name} определяет имя объекта процесса.  Изменяется оно по мере
необходимости, чтобы быть уникальным.

Аргумент @var{buffer} - это буфер, который нужно связать с соединением.  Вывод из
соединения вставляется в буфер, если не указана собственная функция фильтра для
обработки вывода.  Если @var{buffer} равно @code{nil}, это означает, что соединение не
связано ни с каким буфером.

Аргументы @var{host} и @var{service} указывают, к чему подключаться; @var{host} - это
имя хоста (строка), а @var{service} - это имя определенной сетевой службы (строка) или
номер порта (целое число, например @code{80}, или целе число строкой, например
@code{"80"}).

Остальные аргументы @var{parameters} - это пары ключевое слово/аргумент, которые в
основном относятся к зашифрованным соединениям:

@table @code

@item :nowait @var{boolean}
Если не-@code{nil}, попробовать установить асинхронное соединение.

@item :type @var{type}
Тип подключения.  Варианты:

@table @code
@item plain
Обычное незашифрованное соединение.
@item tls
@itemx ssl
Соединение @acronym{TLS} (Transport Layer Security).
@item nil
@itemx network
Начать с простого соединения, и если указаны параметры @samp{:success} и
@samp{:capability-command}, пробовать перейти на зашифрованное соединение через
@acronym{STARTTLS}.  Если не удается, сохранить незашифрованное соединение.
@item starttls
То же что и @code{nil}, но если @acronym{STARTTLS} не работает, разорвать соединение.
@item shell
Соединение оболочки.
@end table

@item :always-query-capabilities @var{boolean}
Если не-@code{nil}, всегда запрашивать возможности сервера, даже при подключении
@samp{plain}.

@item :capability-command @var{capability-command}
Командная строка для запроса возможностей хоста.

@item :end-of-command @var{regexp}
@itemx :end-of-capability @var{regexp}
Регулярное выражение, соответствующее концу команды или концу команды
@var{capability-command}.  Последнее по умолчанию соответствует первому.

@item :starttls-function @var{function}
Функция одного аргумента (ответ на @var{capability-command}), которая возвращает либо
@code{nil}, либо команду на активацию @acronym{STARTTLS}, если поддерживается.

@item :success @var{regexp}
Регулярное выражение, соответствующее успешному согласованию @acronym{STARTTLS}.

@item :use-starttls-if-possible @var{boolean}
Если не-@code{nil}, выполнить гибкие обновления @acronym{STARTTLS}, даже если Emacs не
имеет встроенной поддержки @acronym{TLS}.

@item :warn-unless-encrypted @var{boolean}
Если не-@code{nil} и @code{:return-value} также является не-@code{nil}, Emacs
предупредит, если соединение не зашифровано.  Это полезно для таких протоколов, как
@acronym{IMAP} и ему подобных где большинство пользователей ожидают, что сетевой
трафик будет зашифрован.

@item :client-certificate @var{list-or-t}
Либо список в форме @code{(@var{key-file} @var{cert-file})}, содержащий имя файла
ключа сертификата и самого файла сертификата, либо @code{t}, что означает запрос
@code{auth-source} для получения этой информации
(@pxref{Top,,Overview, auth, The Auth-Source Manual}). Используется только для
@acronym{TLS} или @acronym{STARTTLS}.

@item :return-list @var{cons-or-nil}
Возвращаемое значение этой функции.  Если опущено или @code{nil}, вернуть объект
процесса.  В противном случае cons-ячейки вида
@code{(@var{process-object} . @var{plist})}, где @var{plist} имеет ключевые слова:

@table @code
@item :greeting @var{string-or-nil}
Если не-@code{nil}, строка приветствия, возвращаемая хостом.
@item :capabilities @var{string-or-nil}
Если не-@code{nil}, строка возможностей хоста.
@item :type @var{symbol}
Тип подключения: @samp{plain} или @samp{tls}.
@end table

@item :shell-command @var{string-or-nil}
Если соединение @code{type} - @code{shell}, этот параметр будет интерпретироваться
как строка спецификации формата, которая будет выполнена для установления соединения.
Доступные спецификации: @samp{%s} для имени хоста и @samp{%p} для номера порта.
Например, если требуется вначале установить ssh в @samp{gateway}, прежде чем
устанавливать простое соединение, этот параметр может иметь вид
@samp{ssh gateway nc %s %p}.

@end table

@end defun


@node Network Servers
@section Сетевые Серверы
@cindex network servers

  Создается сервер, вызовом @code{make-network-process} (@pxref{Network Processes}) с
@code{:server t}.  Сервер будет прослушивать запросы на подключение от клиентов.
Когда принимается запрос на соединение с клиентом, он создает новое сетевое
соединение, которое само является объектом процесса, со следующими параметрами:

@itemize @bullet
@item
Имя процесса соединения создается путем объединения @var{name} серверного процесса со
строкой идентификации клиента.  
@c FIXME?  А как насчет IPv6? Скажите вкратце, в чем разница?
Строка идентификации клиента для IPv4-соединения выглядит как
@samp{<@var{a}.@var{b}.@var{c}.@var{d}:@var{p}>}, что представляет собой адрес и
номер порта.  В противном случае это уникальный номер в скобках, как в
@samp{<@var{nnn}>}.  Номер уникален для каждого соединения в сеансе Emacs.

@item
Если на сервере установлен фильтр, отличный от фильтра по умолчанию, процесс
подключения не получает отдельный буфер процесса; в противном случае Emacs создает
для этой цели новый буфер.  Имя буфера - это имя буфера сервера или имя процесса,
объединенное со строкой идентификации клиента.

Значение буфера процесса сервера никогда не используется напрямую, но функция журнала
может извлечь его и использовать для регистрации соединений, вставив туда текст.

@item
Тип связи, а также фильтр процесса и наблюдатель унаследованы от таковых на сервере.
Сервер никогда не использует напрямую свой фильтр и наблюдателя; их единственная цель
- инициализировать соединения с сервером.

@item
Контактная информация процесса подключения устанавливается в соответствии с адресной
информацией клиента (обычно это IP-адрес и номер порта).  Эта информация связана с
ключевыми словами @code{process-contact} @code{:host}, @code{:service},
@code{:remote}.

@item
Локальный адрес подключения устанавливается в соответствии с номером порта,
используемым для подключения.

@item
Список клиентского процесса инициализируется из списка сервера.
@end itemize

@node Datagrams
@section Дейтаграммы
@cindex datagrams

  Соединение @dfn{дейтаграммы} взаимодействует с отдельными пакетами, а не с потоками
данных.  Каждый вызов @code{process-send} отправляет один пакет дейтаграммы
(@pxref{Input to Processes}), и каждая полученная дейтаграмма приводит к одному
вызову функции фильтрации.

  Дейтаграммное соединение не должно постоянно взаимодействовать с одним и тем же
удаленным узлом.  У него есть @dfn{адрес удаленного узла}, который указывает, куда
отправлять дейтаграммы.  Каждый раз, когда входящая дейтаграмма передается в функцию
фильтрации, одноранговый адрес устанавливается равным адресу, с которого пришла
дейтаграмма; таким образом, если функция фильтра отправит дейтаграмму, она вернется в
это место.  Можно указать адрес удаленного узла при создании дейтаграммного
подключения с помощью ключевого слова @code{:remote}.  Можно изменить это позже,
вызвав @code{set-process-datagram-address}.

@defun process-datagram-address process
Если @var{process} - это дейтаграммное соединение или сервер, эта функция возвращает
его удаленный одноранговый адрес.
@end defun

@defun set-process-datagram-address process address
Если @var{process} является дейтаграммным соединением или сервером, эта функция
устанавливает для его удаленного однорангового узла адрес @var{address}.
@end defun

@node Low-Level Network
@section Низкоуровневый Доступ к Сети

  Также можете создавать сетевые соединения, работая на более низком уровне, чем у
@code{open-network-stream}, используя @code{make-network-process}.

@menu
* Proc: Network Processes.   Использование @code{make-network-process}.
* Options: Network Options.  Дальнейший контроль сетевых подключений.
* Features: Network Feature Testing.
                             Определение того, какие сетевые функции работают на
                                используемом вами компьютере.
@end menu

@node Network Processes
@subsection @code{make-network-process}

   Основная функция для создания сетевых подключений и сетевых серверов -
@code{make-network-process}.  Может выполнять любую из этих задач, в зависимости от
аргументов, которые приведены.

@defun make-network-process &rest args
Функция создает сетевое соединение или сервер и возвращает объект процесса, который
его представляет.  Аргументы @var{args} - это список пар ключевое слово/аргумент.
Пропуск ключевого слова всегда эквивалентен его указанию со значением @code{nil}, за
исключением @code{:coding}, @code{:filter-multibyte} и @code{:reuseaddr}.  Вот
значимые ключевые слова (соответствующие параметрам сети перечислены в следующем
разделе):

@table @asis
@item :name @var{name}
Использовать строку @var{name} в качестве имени процесса.  При необходимости оно
модифицируется, чтобы было уникальным.

@item :type @var{type}
Указать тип связи.  Значение @code{nil} указывает соединение с потоком (по умолчанию);
@code{datagram} определяет дейтаграмное соединение; @code{seqpacket} определяет
соединение с последовательным потоком пакетов.  К этим типам могут быть отнесены
соединения и серверы.

@item :server @var{server-flag}
Если @var{server-flag} равно не-@code{nil}, создать сервер.  В противном случае
создать соединение.  Для сервера потокового типа @var{server-flag} может быть целым
числом, которое затем определяет длину очереди ожидающих подключений к серверу.
Длина очереди по умолчанию - 5.

@item :host @var{host}
Указать хост для подключения.  @var{host} должно быть именем хоста или
интернет-адресом в виде строки или символа @code{local} для указания локального хоста.
Если указать @var{host} для сервера, оно должно указать действительный адрес для
локального хоста, и будут приниматься только клиенты, подключающиеся к этому адресу.

@item :service @var{service}
@var{service} указывает номер порта для подключения; или, для сервера, номер порта
для прослушивания.  Это должно быть имя службы, например @samp{"http"}, которое
переводится в номер порта, или целое число, например @samp{80}, или целочисленная
строка, например @samp{"80"}, которая напрямую указывает номер порта.  Для сервера это
также может быть @code{t}, что означает, что система может выбрать неиспользуемый
номер порта.

@item :family @var{family}
@var{family} определяет семейство адресов (и протоколов) для связи.  @code{nil}
означает автоматическое определение правильного семейства адресов для данного
@var{host} и @var{service}.  @code{local} указывает сокет Unix, и в этом случае
@var{host} игнорируется.  @code{ipv4} и @code{ipv6} указывать IPv4 и IPv6
соответственно.

@item :use-external-socket @var{use-external-socket}
Если @var{use-external-socket} равно не-@code{nil}, использовать любые сокеты,
переданные Emacs при вызове, вместо выделения одного.  Это используется кодом сервера
Emacs, чтобы разрешить активацию сокета по требованию.  Если Emacs не передал сокет,
эта опция игнорируется.

@item :local @var{local-address}
Для серверного процесса @var{local-address} - это адрес для прослушивания.
Это переопределяет @var{family}, @var{host} и @var{service}, поэтому можно не
указывать их.

@item :remote @var{remote-address}
Для подключения @var{remote-address} - это адрес для подключения.  Это переопределяет
@var{family}, @var{host} и @var{service}, поэтому можно не указывать их.

Для сервера дейтаграмм @var{remote-address} определяет начальную настройку удаленного
адреса дейтаграммы.

Формат @var{local-address} или @var{remote-address} зависит от семейства адресов:

@itemize -
@item
Адрес IPv4 представлен как пятиэлементный вектор из четырех 8-битных целых чисел и
одного 16-битного целого числа @code{[@var{a} @var{b} @var{c} @var{d} @var{p}]},
соответствующих числовому IPv4-адресу @var{a}.@var{b}.@var{c}.@var{d} и номеру
порта @var{p}.

@item
Адрес IPv6 представлен как вектор из девяти элементов 16-битных целых чисел
@code{[@var{a} @var{b} @var{c} @var{d} @var{e} @var{f} @var{g} @var{h} @var{p}]},
соответствующих числовому адресу IPv6
@var{a}:@var{b}:@var{c}:@var{d}:@var{e}:@var{f}:@var{g}:@var{h} и номеру
порта @var{p}.

@item
Локальный адрес представлен в виде строки, которая указывает адрес в локальном
адресном пространстве.

@item
Адрес неподдерживаемого семейства представлен cons-ячейкой
@code{(@var{f} . @var{av})}, где @var{f} - номер семейства, а @var{av} - вектор,
определяющий адрес сокета с использованием одного элемента на байт данных адреса.
Не полагаться на этот формат в переносимом коде, так как он может зависеть от
констант, определенных реализацией, размеров данных и выравнивания структуры данных.
@end itemize

@item :nowait @var{bool}
Если @var{bool} равно не-@code{nil} для потокового соединения, вернуться, не дожидаясь
завершения соединения.  При успешном или неудачном соединении Emacs вызовет
функцию наблюдения со вторым аргументом, совпадающим с @code{"open"} (в случае успеха)
или @code{"failed"}.  По умолчанию используется блокировка, поэтому
@code{make-network-process} не возвращается, пока соединение не будет установлено
успешно или оно не удастся.

Если настраивать асинхронное соединение TLS, также необходимо предоставить параметр
@code{:tls-parameters} (смотреть ниже).

В зависимости от возможностей Emacs, асинхронность @code{:nowait} может варьироваться.
Три элемента, которые могут (или не могут) выполняться асинхронно, - это разрешение
имени домена, настройка сокета и (для соединений TLS) согласование TLS.

Многие функции, которые взаимодействуют с объектами процессов (например,
@code{process-datagram-address}), полагаются на них, по крайней мере, на наличие
сокета, прежде чем они смогут вернуть полезное значение.  Эти функции будут
заблокированы до тех пор, пока сокет не достигнет желаемого статуса.  Рекомендуемый
способ взаимодействия с асинхронными сокетами - установить наблюдателя на процесс, а
не пытаться взаимодействовать с ним до того, как изменится статус на @samp{"run"}.
Таким образом, ни одна из этих функций не будет заблокирована.

@item :tls-parameters
При открытии TLS-соединения первым элементом должен быть тип TLS (который должен
иметь значение @code{gnutls-x509pki} или @code{gnutls-anon}, а остальные элементы
должны формировать список ключевых слов, приемлемый для @code{gnutls-boot} (этот
список ключевых слов можно получить из функции @code{gnutls-boot-parameters}).  После
этого соединение TLS будет согласовано после завершения соединения с хостом.

@item :stop @var{stopped}
Если @var{stopped} - не-@code{nil}, запустить сетевое соединение или сервер в
остановленном состоянии.

@item :buffer @var{buffer}
Использовать @var{buffer} в качестве буфера процесса.

@item :coding @var{coding}
Использовать @var{coding} в качестве системы кодирования для этого процесса.  Чтобы
указать разные системы кодирования для декодирования данных из соединения и для
кодирования данных, отправляемых в него, указать
@code{(@var{decoding} . @var{encoding})} для @var{coding}.

Если вообще не указать это ключевое слово, по умолчанию система кодирования
определяется по данным.

@item :noquery @var{query-flag}
Инициализировать флаг запроса процесса в @var{query-flag}.
@xref{Query Before Exit}.

@item :filter @var{filter}
Инициализировать фильтр процесса как @var{filter}.

@item :filter-multibyte @var{multibyte}
Если @var{multibyte} равно не-@code{nil}, строки, передаваемые фильтру процесса,
являются многобайтовыми, в противном случае - однобайтовыми.  По умолчанию
используется значение @code{enable-multibyte-characters} по умолчанию.

@item :sentinel @var{sentinel}
Инициализировать процесс наблюдатель @var{sentinel}.

@item :log @var{log}
Инициализировать функцию журнала серверного процесса как @var{log}.  Функция журнала
вызывается каждый раз, когда сервер принимает сетевое соединение от клиента.
Аргументы, передаваемые функции журнала: @var{server}, @var{connection} и
@var{message}; где @var{server} - это серверный процесс, @var{connection} - новый
процесс для подключения, а @var{message} - строка, описывающая, что произошло.

@item :plist @var{plist}
Инициализировать plist процесса как @var{plist}.
@end table

Исходный список аргументов, модифицированный фактической информацией о соединении,
доступен через функцию @code{process-contact}.
@end defun

@node Network Options
@subsection Параметры Сети

  При создании сетевого процесса можно указать следующие параметры сети.  За
исключением @code{:reuseaddr}, также можно установить или изменить эти параметры
позже, используя @code{set-network-process-option}.

  Для серверного процесса параметры, указанные с помощью @code{make-network-process},
не наследуются клиентскими соединениями, поэтому нужно будет установить необходимые
параметры для каждого дочернего соединения по мере его создания.

@table @asis
@item :bindtodevice @var{device-name}
Если @var{device-name} - непустая строка, определяющая имя сетевого интерфейса
(смотреть @code{network-interface-list}), обрабатывать только пакеты, полученные на
этом интерфейсе.  Если @var{device-name} - @code{nil} (по умолчанию), обрабатывать
пакеты, полученные на любом интерфейсе.

Для использования этой опции в некоторых системах могут потребоваться особые
привилегии.

@item :broadcast @var{broadcast-flag}
Если @var{broadcast-flag} равно не-@code{nil} для дейтаграммного процесса, процесс
получит пакет дейтаграммы, отправленный на широковещательный адрес, и сможет
отправлять пакеты на широковещательный адрес.  Это игнорируется для потокового
соединения.

@item :dontroute @var{dontroute-flag}
Если @var{dontroute-flag} равно не-@code{nil}, процесс может отправлять сообщения
только хостам в той же сети, что и локальный хост.

@item :keepalive @var{keepalive-flag}
Если @var{keepalive-flag} равно не-@code{nil} для потокового соединения, включить
обмен сообщениями проверки активности низкого уровня.

@item :linger @var{linger-arg}
Если @var{linger-arg} равно не-@code{nil}, дождаться успешной передачи всех пакетов в
очереди в соединении, прежде чем оно будет удалено (смотреть @code{delete-process}).
Если @var{linger-arg} является целым числом, указывается максимальное время в
секундах, в течение которого нужно ожидать отправки пакетов из очереди перед закрытием
соединения.  По умолчанию используется @code{nil}, что означает отбрасывание
неотправленных пакетов в очереди при удалении процесса.

@c FIXME  Где данные out-of-band ...?
@item :oobinline @var{oobinline-flag}
Если @var{oobinline-flag} равно не-@code{nil} для потокового соединения, получать
внеполосные данные в обычном потоке данных.  В противном случае игнорировать
внеполосные данные.

@item :priority @var{priority}
Установить приоритет пакетов, отправляемых по этому соединению, на целое число
@var{priority}.  Интерпретация этого числа зависит от протокола; например, установка
поля TOS (тип службы) в IP-пакетах, отправляемых через это соединение.  Это также
может иметь эффекты, зависящие от системы, такие как выбор определенной очереди вывода
на сетевом интерфейсе.

@item :reuseaddr @var{reuseaddr-flag}
Если @var{reuseaddr-flag} - не-@code{nil} (по умолчанию) для процесса потокового
сервера, разрешить этому серверу повторно использовать определенный номер порта
(смотреть @code{:service}), если другой процесс на этом хосте уже не прослушивает
этот порт.  Если @var{reuseaddr-flag} - @code{nil}, может быть период времени после
последнего использования этого порта (любым процессом на хосте), когда невозможно
создать новый сервер на этом порту.
@end table

@defun set-network-process-option process option value &optional no-error
Функция устанавливает или изменяет сетевой параметр для сетевого процесса
@var{process}.  Допустимые параметры и значения такие же, как для
@code{make-network-process}.  Если @var{no-error} равно не-@code{nil}, функция
возвращает @code{nil} вместо сообщения об ошибке, если @var{option} не поддерживается.
Если функция успешно завершается, возвращается @code{t}.

Текущая установка опции доступна через функцию @code{process-contact}.
@end defun

@node Network Feature Testing
@subsection Проверка Доступности Сетевых Функций

  Чтобы проверить доступность данной сетевой функции, использовать @code{featurep}
следующим образом:

@example
(featurep 'make-network-process '(@var{keyword} @var{value}))
@end example

@noindent
Результатом этой формы будет @code{t}, если работает, указать @var{keyword} со
значением @var{value} в @code{make-network-process}.  Вот некоторые из пар
@var{keyword}---@var{value}, которые можно протестировать таким образом.

@table @code
@item (:nowait t)
не-@code{nil}, если поддерживается неблокирующее соединение.
@item (:type datagram)
не-@code{nil}, если дейтаграммы поддерживаются.
@item (:family local)
не-@code{nil}, если поддерживаются локальные сокеты (также известные как@:
``UNIX domain'').
@item (:family ipv6)
не-@code{nil}, если поддерживается IPv6.
@item (:service t)
не-@code{nil}, если система может выбрать порт для сервера.
@end table

  Чтобы проверить доступность данной сетевой опции, использовать @code{featurep}
следующим образом:

@example
(featurep 'make-network-process '@var{keyword})
@end example

@noindent
Допустимые значения @var{keyword}: @code{:bindtodevice} и так далее.  Для полного
списка @pxref{Network Options}.  Форма возвращает не-@code{nil}, если эта конкретная
сетевая опция поддерживается @code{make-network-process} (или
@code{set-network-process-option}).

@node Misc Network
@section Разное Сетевое Оборудование

  Эти дополнительные функции полезны для создания сетевых подключений и работы с
ними.  Обратить внимание, что они поддерживаются только в некоторых системах.

@defun network-interface-list
Функция возвращает список с описанием сетевых интерфейсов используемой вами машины.
Значение - это список, элементы которого имеют вид
@code{(@var{name} . @var{address})}.  @var{address} имеет ту же форму, что и аргументы
@var{local-address} и @var{remote-address} для @code{make-network-process}.
@end defun

@defun network-interface-info ifname
Функция возвращает информацию о сетевом интерфейсе с именем @var{ifname}.  Значение
представляет собой список вида
@code{(@var{addr} @var{bcast} @var{netmask} @var{hwaddr} @var{flags})}.

@table @var
@item addr
Адрес интернет-протокола.
@item bcast
Широковещательный адрес.
@item netmask
Сетевая маска.
@item hwaddr
Адрес уровня 2 (например, MAC-адрес Ethernet).
@item flags
Текущие флаги интерфейса.
@end table
@end defun

@defun format-network-address address &optional omit-port
Функция преобразует Lisp-представление сетевого адреса в строку.

Пятиэлементный вектор @code{[@var{a} @var{b} @var{c} @var{d} @var{p}]} представляет
IPv4-адрес @var{a}.@var{b}.@var{c}.@var{d} и номер порта @var{p}.
@code{format-network-address} преобразует это в строку
@code{"@var{a}.@var{b}.@var{c}.@var{d}:@var{p}"}.

Вектор
@code{[@var{a} @var{b} @var{c} @var{d} @var{e} @var{f} @var{g} @var{h} @var{p}]} из
девяти элементов представляет IPv6-адрес вместе с номером порта.
@code{format-network-address} преобразует это в строку
@code{"[@var{a}:@var{b}:@var{c}:@var{d}:@var{e}:@var{f}:@var{g}:@var{h}]:@var{p}"}.

Если вектор не включает номер порта @var{p} или если @var{omit-port} равно
не-@code{nil}, результат не будет включать суффикс @code{:@var{p}}.
@end defun

@node Serial Ports
@section Связь с Последовательными Портами
@cindex @file{/dev/tty}
@cindex @file{COM1}
@cindex serial connections

  Emacs может связываться с последовательными портами.  Для интерактивного
использования @kbd{M-x serial-term} открывает окно терминала.  В программе на Lisp
@code{make-serial-process} создает объект процесса.

  Последовательный порт можно настроить во время работы без необходимости его
закрывать и повторно открывать.  Функция @code{serial-process-configure} позволяет
изменять скорость, размер в байтах и другие параметры.  В окне терминала, созданном
@code{serial-term}, можно щелкнуть строку режима для настройки.

  Последовательное соединение представлено объектом процесса, который может
использоваться аналогично подпроцессу или сетевому процессу.  Можно отправлять и
получать данные, а также настраивать последовательный порт.  Однако объект
последовательного процесса не имеет идентификатора процесса, и не выйдет отправлять
ему сигналы, а коды состояния отличаются от других типов процессов.
@code{delete-process} в объекте процесса или @code{kill-buffer} в буфере процесса
закрывает соединение, но это не влияет на устройство, подключенное к
последовательному порту.

  Функция @code{process-type} возвращает символ @code{serial} для объекта процесса,
представляющего соединение через последовательный порт.

  Последовательные порты доступны в системах GNU/Linux, Unix и MS Windows.

@deffn Command serial-term port speed
Запустить эмулятор терминала для последовательного порта в новом буфере.  @var{port} -
это имя последовательного порта для подключения.  Например, в Unix это может быть
@file{/dev/ttyS0}.  В MS Windows это может быть @file{COM1} или @file{\\.\COM10}
(двойная обратная косая черта в строках Lisp).

@c FIXME 9600 по-прежнему является наиболее распространенным значением, или
@c сейчас это 115200? (То же значение, 9600, также отображается ниже.)
@var{speed} - скорость последовательного порта в битах в секунду.  9600 - это обычное
значение.  Буфер находится в режиме Term; смотреть
@ref{Term Mode,,, emacs, The GNU Emacs Manual} для команд, используемых в этом буфере.
Можно изменить скорость и конфигурацию в меню строки режима.
@end deffn

@defun make-serial-process &rest args
Функция создает процесс и буфер.  Аргументы указываются как пары ключевое
слово/аргумент.  Вот список значимых ключевых слов, первые два (@var{port} и
@var{speed}) обязательны:

@table @code
@item :port @var{port}
Имя последовательного порта.  В системах Unix и GNU это имя файла, например
@file{/dev/ttyS0}.  В Windows это может быть @file{COM1} или @file{\\.\COM10} для
портов выше @file{COM9} (двойная обратная косая черта в строках Lisp).

@item :speed @var{speed}
Скорость последовательного порта в битах в секунду.  Функция вызывает
@code{serial-process-configure} для обработки скорости; смотреть следующую
документацию по этой функции для получения более подробной информации.

@item :name @var{name}
Название процесса.  Если @var{name} не указано, @var{port} также будет служить именем
процесса.

@item :buffer @var{buffer}
Буфер, который нужно связать с процессом.  Значение может быть либо буфером, либо
строкой с именем буфера.  Вывод процесса идет в конец этого буфера, если не указан
выходной поток или функцию фильтра для обработки вывода.  Если @var{buffer} не указан,
имя буфера процесса берется из значения ключевого слова @code{:name}.

@item :coding @var{coding}
Если @var{coding} является символом, указывается система кодирования, используемая как
для чтения, так и для записи этого процесса.  Если @var{coding} является
cons-ячейка @code{(@var{decoding} . @var{encoding})}, @var{decoding} используется для
чтения, а @var{encoding} - для записи.  Если не указано иное, по умолчанию системы
кодирования определяются на основе самих данных.

@item :noquery @var{query-flag}
Инициализировать флаг запроса процесса @var{query-flag}.  @xref{Query Before Exit}.
По умолчанию флаги имеют значение @code{nil}, если не указано иное.

@item :stop @var{bool}
Запустить процесс в остановленном состоянии, если @var{bool} равно не-@code{nil}.
В остановленном состоянии последовательный процесс не принимает входящие данные, но
можно отправлять исходящие данные.  Остановленное состояние очищается с помощью
@code{continue-process} и устанавливается с помощью @code{stop-process}.

@item :filter @var{filter}
Установить @var{filter} в качестве технологического фильтра.

@item :sentinel @var{sentinel}
Установить @var{sentinel} в качестве наблюдателя.

@item :plist @var{plist}
Установить @var{plist} в качестве начального списка процесса.

@item :bytesize
@itemx :parity
@itemx :stopbits
@itemx :flowcontrol
Обрабатываются @code{serial-process-configure}, который вызывается
@code{make-serial-process}.
@end table

Исходный список аргументов, возможно, измененный более поздней конфигурацией,
доступен через функцию @code{process-contact}.

Вот пример:

@example
(make-serial-process :port "/dev/ttyS0" :speed 9600)
@end example
@end defun

@defun serial-process-configure &rest args
@cindex baud, in serial connections
@cindex bytesize, in serial connections
@cindex parity, in serial connections
@cindex stopbits, in serial connections
@cindex flowcontrol, in serial connections

Функция настраивает соединение через последовательный порт.  Аргументы указываются как
пары ключевое слово/аргумент.  Атрибуты, которые не указаны, повторно инициализируются
из текущей конфигурации процесса (доступной через функцию @code{process-contact}) или
устанавливаются на разумные значения по умолчанию.  Определены следующие аргументы:

@table @code
@item :process @var{process}
@itemx :name @var{name}
@itemx :buffer @var{buffer}
@itemx :port @var{port}
Любой из этих аргументов может быть использован для идентификации процесса, который
необходимо настроить.  Если ни один из этих аргументов не указан, используется
процесс текущего буфера.

@item :speed @var{speed}
Скорость последовательного порта в битах в секунду, также известная как@:
@dfn{скорость передачи}.  Значение может быть любым числом, но большинство
последовательных портов работают только с несколькими определенными значениями от
1200 до 115200, причем 9600 является наиболее распространенным значением.  Если
@var{speed} равно @code{nil}, функция игнорирует все остальные аргументы и не
настраивает порт.  Это может быть полезно для специальных последовательных портов,
таких как преобразователи Bluetooth в последовательный порт, которые можно настроить
только с помощью команд @samp{AT}, отправляемых через соединение.  Значение @code{nil}
для @var{speed} действительно только для соединений, которые уже были открыты
предыдущим вызовом @code{make-serial-process} или @code{serial-term}.

@item :bytesize @var{bytesize}
Количество бит на байт, которое может быть 7 или 8.  Если @var{bytesize} не задано или
@code{nil}, по умолчанию используется 8.

@item :parity @var{parity}
Значение может быть @code{nil} (не использовать четность), символом @code{odd}
(использовать нечетную четность) или символом @code{even} (использовать четность).
Если @var{parity} не указано, по умолчанию используется значение без четности.

@item :stopbits @var{stopbits}
Количество стоповых битов, используемых для завершения передачи каждого байта.
@var{stopbits} может быть 1 или 2.  Если @var{stopbits} не задано или @code{nil}, по
умолчанию используется 1.

@item :flowcontrol @var{flowcontrol}
Тип управления потоком, который следует использовать для этого соединения: либо
@code{nil} (не использовать управление потоком), либо символ @code{hw} (использовать
аппаратное управление потоком RTS/CTS), либо символ @code{sw} (использовать
программное управление потоком XON/XOFF).  Если @var{flowcontrol} не указано, по
умолчанию управление потоком отсутствует.
@end table

Внутренне @code{make-serial-process} вызывает @code{serial-process-configure} для
начальной настройки последовательного порта.
@end defun

@node Byte Packing
@section Упаковка и Распаковка Массивов Байт
@cindex byte packing and unpacking

  В этом разделе описывается, как упаковывать и распаковывать массивы байтов, обычно
для двоичных сетевых протоколов.  Эти функции преобразуют байтовые массивы в списки и
наоборот.  Массив байтов может быть представлен как однобайтная строка
@c FIXME?  Нет многобайтовой?
или как вектор целых чисел, в то время как список связывает символы либо с объектами
фиксированного размера, либо с рекурсивными подсписками.  Чтобы использовать функции,
упомянутые в этом разделе, загрузить библиотеку @code{bindat}.
@c Никаких автозагрузок у него нет.

@cindex serializing
@cindex deserializing
@cindex packing
@cindex unpacking
  Преобразование байтовых массивов во вложенные списки также известно как
@dfn{десериализация} или @dfn{распаковка}, в то время как переход в противоположном
направлении также известено как @dfn{сериализация} или @dfn{упаковка}.

@menu
* Bindat Spec::         Описание макета данных.
* Bindat Functions::    Распаковка и упаковка.
* Bindat Examples::     Примеры того, что bindat.el может сделать!
@end menu

@node Bindat Spec
@subsection Описание Структур Данных

  Чтобы управлять распаковкой и упаковкой, вы пишется
@dfn{спецификация компоновки данных}, специальный вложенный список, описывающий
именованные и типизированные @dfn{поля}.  Эта спецификация определяет длину каждого
обрабатываемого поля и способ его упаковки или распаковки.  Обычно хранится
спецификации bindat в переменных, имена которых заканчиваются на @samp{-bindat-spec};
такое имя автоматически признается рискованным.

@cindex endianness
@cindex big endian
@cindex little endian
@cindex network byte ordering
  Поле @dfn{type} описывает размер (в байтах) объекта, который представляет поле, и,
в случае многобайтовых полей, порядок байтов в поле.  Два возможных порядка:
@dfn{с прямым порядком байтов} (также известный как ``сетевой порядок байтов'') и
@dfn{обратный порядок байтов}.  Например, число @code{#x23cd} (десятичное 9165) в
обратном порядке байтов будет два байта @code{#x23} @code{#xcd}; и с прямым порядком
байтов @code{#xcd} @code{#x23}.  Вот возможные значения типов:

@table @code
@item u8
@itemx byte
Байт без знака длиной 1.

@item u16
@itemx word
@itemx short
Беззнаковое целое число в сетевом порядке байтов длиной 2.

@item u24
Беззнаковое целое число в сетевом порядке байтов длиной 3.

@item u32
@itemx dword
@itemx long
Беззнаковое целое число в сетевом порядке байтов с длиной 4.  Примечание: Эти
значения могут быть ограничены пределами целочисленной реализации Emacs.

@item u16r
@itemx u24r
@itemx u32r
Беззнаковое целое число с прямым порядком байтов, длиной 2, 3 и 4 соответственно.

@item str @var{len}
Строка длиной @var{len}.

@item strz @var{len}
Строка с нулевым завершением в поле фиксированного размера длиной @var{len}.

@item vec @var{len} [@var{type}]
Вектор элементов @var{len} типа @var{type}, по умолчанию байтов.  @var{type} - это
любой из простых типов, указанных выше, или другой вектор, указанный в виде списка
в форме @code{(vec @var{len} [@var{type}])}.

@item ip
@c FIXME?  IPv6?
Четырехбайтовый вектор, представляющий Интернет-адрес.  Например:
@code{[127 0 0 1]} для localhost.

@item bits @var{len}
Список установленных битов в байтах @var{len}.  Байты берутся в прямом порядке байт,
а биты нумеруются, начиная с @code{8 * @var{len} @minus{} 1} и заканчиваются нулем.
Например: @code{bits 2} распаковывает @code{#x28} @code{#x1c} в @code{(2 3 4 11 13)} и
@code{#x1c} @code{#x28} в @code{(3 5 10 11 12)}.

@item (eval @var{form})
@var{form} - это выражение Lisp, вычисляемое в момент распаковки или упаковки поля.
Результатом оценки должна быть одна из перечисленных выше спецификаций типа.
@end table

Для поля фиксированного размера длина @var{len} задается как целое число,
определяющее количество байтов в поле.

Когда длина поля не фиксирована, она обычно зависит от значения предыдущего поля.
В этом случае длина @var{len} может быть задана либо в виде списка
@code{(@var{name} ...)}, идентифицирующего @dfn{название поля} в формате, указанном
для @code{bindat-get-field} ниже, либо в виде выражения @code{(eval @var{form})}, где
@var{form} должно оцениваться как целое число, определяющее длину поля.

Спецификация поля обычно имеет вид @code{([@var{name}] @var{handler})}, где
@var{name} не является обязательным.  Не использовать имена, которые являются
символами, значимыми в качестве спецификаций типов (выше) или спецификаций
обработчиков (ниже), поскольку это будет неоднозначно.  @var{name} может быть символом
или выражением @code{(eval @var{form})}, и в этом случае @var{form} должно оцениваться
как символ.

@var{handler} описывает, как распаковать или упаковать поле, и может быть одним из
следующих:

@table @code
@item @var{type}
Распаковать/упаковать это поле согласно спецификации типа @var{type}.

@item eval @var{form}
Оценить @var{form}, выражение Lisp, только для побочного эффекта.  Если имя поля
указано, значение привязано к этому имени поля.

@item fill @var{len}
Пропустить @var{len} байт.  В упаковке это оставляет их неизменными, что обычно
означает, что они остаются нулевыми.  При распаковке это означает, что они
игнорируются.

@item align @var{len}
Переход к следующему кратному @var{len} байту.

@item struct @var{spec-name}
Обработать @var{spec-name} как дополнительную спецификацию.  Это описывает структуру,
вложенную в другую структуру.

@item union @var{form} (@var{tag} @var{spec})@dots{}
@c ??? Я не понимаю, как на самом деле это можно было бы использовать.
@c ??? какое выражение было бы полезно для @var{form}?
Вычислить @var{form}, выражение Lisp, найти первый @var{tag}, который ему
соответствует, и обработать связанную с ним спецификацию макета данных @var{spec}.
Соответствие может происходить одним из трех способов:

@itemize
@item
Если @var{tag} имеет форму @code{(eval @var{expr})}, оценить @var{expr} с переменной
@code{tag}, динамически связанной со значением @var{form}.  Результат не-@code{nil}
указывает на совпадение.

@item
@var{tag} совпадает, если @code{equal}, со значением @var{form}.

@item
@var{tag} соответствует безусловно, если это @code{t}.
@end itemize

@item repeat @var{count} @var{field-specs}@dots{}
Обработь @var{field-specs} рекурсивно по порядку, затем повторить, начиная с первого,
обрабатывая все спецификации @var{count} раз в целом.  @var{count} задается с
использованием тех же форматов, что и длина поля --- если используется форма
@code{eval}, она оценивается только один раз.  Для корректной работы каждая
спецификация в @var{field-specs} должна включать имя.
@end table

Для форм @code{(eval @var{form})}, используемых в спецификации bindat, @var{form}
может обращаться к этим динамически связанным переменным и обновлять их во время
оценки:

@table @code
@item last
Значение последнего обработанного поля.

@item bindat-raw
Данные в виде байтового массива.

@item bindat-idx
Текущий индекс (в пределах @code{bindat-raw}) для распаковки или упаковки.

@item struct
Список, содержащий структурированные данные, которые были распакованы на данный
момент, или всю упаковываемую структуру.  Можно использовать @code{bindat-get-field}
для доступа к определенным полям этой структуры.

@item count
@itemx index
Внутри блока @code{repeat} содержится максимальное количество повторений (как указано
параметром @var{count}) и текущее количество повторений (считая от 0).  Установка
@code{count} в ноль завершит самый внутренний блок повторения после завершения
текущего повторения.
@end table

@node Bindat Functions
@subsection Функции для Распаковки и Упаковки Байтов

  В следующей документации @var{spec} относится к спецификации компоновки данных,
@code{bindat-raw} - к байтовому массиву, а @var{struct} - к списку, представляющему
распакованные данные поля.

@defun bindat-unpack spec bindat-raw &optional bindat-idx
@c FIXME?  Опять же многобайтовой нет?
Функция распаковывает данные из однобайтовой строки или байтового массива
@code{bindat-raw} в соответствии с @var{spec}.  Обычно распаковка начинается с начала
массива байтов, но если @var{bindat-idx} имеет значение не-@code{nil}, вместо него
указывается начальная позиция, отсчитываемая от нуля.

Значение представляет собой список или вложенный список, в котором каждый элемент
описывает одно распакованное поле.
@end defun

@defun bindat-get-field struct &rest name
Функция выбирает данные поля из вложенного списка @var{struct}.  Обычно @var{struct}
возвращает @code{bindat-unpack}.  Если @var{name} соответствует только одному
аргументу, это означает извлечение значения поля верхнего уровня.  Несколько
аргументов @var{name} задают повторный поиск подструктур.  Целочисленное имя действует
как индекс массива.

Например, если @var{name} равно @code{(a b 2 c)}, это означает, что в третьем элементе
подполя @code{b} поля @code{a} находится поле @code{c}.  (Это соответствует
@code{struct.a.b[2].c} в C.)
@end defun

  Хотя операции упаковки и распаковки изменяют организацию данных (в памяти), они
сохраняют @dfn{общую длину} данных, которая представляет собой сумму длин всех полей в
байтах.  Это значение обычно не присуще ни спецификации, ни списку; вместо этого обе
части информации участвуют в её расчетах.  Точно так же длина распаковываемой строки
или массива может быть больше, чем общая длина данных, как описано в спецификации.

@defun bindat-length spec struct
Функция возвращает общую длину данных в @var{struct} согласно @var{spec}.
@end defun

@defun bindat-pack spec struct &optional bindat-raw bindat-idx
Функция возвращает массив байтов, упакованный в соответствии с @var{spec}, из данных
в alist @var{struct}.  Обычно создает и заполняет новый массив байтов, начиная с
начала.  Однако, если @var{bindat-raw} равно не-@code{nil}, указывает заранее
выделенную строку или вектор из однобайтов для упаковки.  Если @var{bindat-idx}
не-@code{nil}, указывается начальное смещение для упаковки в @code{bindat-raw}.

При предварительном распределении потребуется убедиться, что
@code{(length @var{bindat-raw})} соответствует общей длине или превышает ее, чтобы
избежать ошибки за пределами допустимого диапазона.
@end defun

@defun bindat-ip-to-string ip
Преобразовать вектор интернет-адресов @var{ip} в строку в обычной записи с точками.
@c FIXME?  Это IPv6?

@example
(bindat-ip-to-string [127 0 0 1])
     @result{} "127.0.0.1"
@end example
@end defun

@node Bindat Examples
@subsection Примеры Распаковки и Упаковки Байтов
@c FIXME?  Это кажется очень длинным примером того, что
@c не используется очень часто. Начиная с 25.2, gdb-mi.el
@c является единственным пользователем bindat.el в Emacs.
@c Возможно, один или оба этих примера следует просто
@c переместить в комментарий на bindat.el.

  Вот два полных примера использования bindat.el.  Первый
показывает простую байтовую упаковку:

@lisp
(require 'bindat)

(defun rfc868-payload ()
  (bindat-pack
   '((now-hi u16)
     (now-lo u16))
   ;; Emacs использует эпоху Unix, а эпоха RFC868
   ;; - это 1900-01-01 00:00:00, что на 2208988800
   ;; (или #x83aa7e80) секунд больше.
   (let ((now (time-add nil '(#x83aa #x7e80))))
     `((now-hi . ,(car now))
       (now-lo . ,(cadr now))))))

(let ((s (rfc868-payload)))
  (list (multibyte-string-p s)
        (mapconcat (lambda (byte)
                     (format "%02x" byte))
                   s " ")
        (current-time-string)))
     @result{} (nil "dc 6d 17 01" "Fri Mar 10 13:13:53 2017")
@end lisp

Ниже приводится пример определения и распаковки сложной структуры.
Рассмотрим следующие структуры C:

@example
struct header @{
    unsigned long    dest_ip;
    unsigned long    src_ip;
    unsigned short   dest_port;
    unsigned short   src_port;
@};

struct data @{
    unsigned char    type;
    unsigned char    opcode;
    unsigned short   length;  /* в сетевом порядке байтов  */
    unsigned char    id[8];   /* строка с завершающим нулем  */
    unsigned char    data[/* (length + 3) & ~3 */];
@};

struct packet @{
    struct header    header;
    unsigned long    counters[2];  /* в порядке обратного порядка байтов  */
    unsigned char    items;
    unsigned char    filler[3];
    struct data      item[/* Предметы */];

@};
@end example

Соответствующая спецификация компоновки данных:

@lisp
(setq header-spec
      '((dest-ip   ip)
        (src-ip    ip)
        (dest-port u16)
        (src-port  u16)))

(setq data-spec
      '((type      u8)
        (opcode    u8)
        (length    u16)  ; сетевой порядок байтов
        (id        strz 8)
        (data      vec (length))
        (align     4)))

(setq packet-spec
      '((header    struct header-spec)
        (counters  vec 2 u32r)   ; порядок обратного порядка байтов
        (items     u8)
        (fill      3)
        (item      repeat (items)
                   (struct data-spec))))
@end lisp

Представление двоичных данных:

@lisp
(setq binary-data
      [ 192 168 1 100 192 168 1 101 01 28 21 32
        160 134 1 0 5 1 0 0 2 0 0 0
        2 3 0 5 ?A ?B ?C ?D ?E ?F 0 0 1 2 3 4 5 0 0 0
        1 4 0 7 ?B ?C ?D ?E ?F ?G 0 0 6 7 8 9 10 11 12 0 ])
@end lisp

The corresponding decoded structure is:

@lisp
(setq decoded (bindat-unpack packet-spec binary-data))
     @result{}
((header
  (dest-ip   . [192 168 1 100])
  (src-ip    . [192 168 1 101])
  (dest-port . 284)
  (src-port  . 5408))
 (counters . [100000 261])
 (items . 2)
 (item ((data . [1 2 3 4 5])
        (id . "ABCDEF")
        (length . 5)
        (opcode . 3)
        (type . 2))
       ((data . [6 7 8 9 10 11 12])
        (id . "BCDEFG")
        (length . 7)
        (opcode . 4)
        (type . 1))))
@end lisp

Пример получения данных из этой структуры:

@lisp
(bindat-get-field decoded 'item 1 'id)
     @result{} "BCDEFG"
@end lisp
