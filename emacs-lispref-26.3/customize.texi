@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1997-2019 Free Software Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Customization
@chapter Пользовательские Настройки

@cindex customization item
  Пользователи Emacs могут настроить переменные и отображение текста
  без написания кода Lisp, с помощью интерфейса Настройки.
  @xref{Easy Customization,,, emacs, The GNU Emacs Manual}.  В этой главе
  описывается, как определить @dfn{элементы настройки}, с помощью которых
  пользователи смогут взаимодействовать с настройкой, используя интерфейс
  Настройки.

  Элементы Настройки включают настраиваемые переменные, которые
  определяются с помощью
@ifinfo
@code{defcustom} макроса (@pxref{Variable Definitions});
@end ifinfo
@ifnotinfo
@code{defcustom} макроса;
@end ifnotinfo
настраиваемое отображение текста, которые определено с @code{defface}
(описаны отдельно в @ref{Defining Faces}) и @dfn{групп настройки},
определяется
@ifinfo
@code{defgroup} (@pxref{Group Definitions}),
@end ifinfo
@ifnotinfo
@code{defgroup},
@end ifnotinfo
которые действуют как контейнеры для групп связанных элементов настройки.

@menu
* Common Keywords::         Общие ключевые слова аргументов всех видов
                            объявления настройки.
* Group Definitions::       Написание определений групп настройки.
* Variable Definitions::    Объявление параметров пользователя.
* Customization Types::     Определение типа пользовательского параметра.
* Applying Customizations:: Функции для применения параметров настройки.
* Custom Themes::           Написание пользовательских тем.
@end menu

@node Common Keywords
@section Общие Ключевые Слова

@cindex customization keywords
  Создание настройки, которое описывается в следующих разделах ---
  @code{defcustom}, @code{defgroup} и так далее.  Принимаются ключевые слова
  в аргументах (@pxref{Constant Variables}) для указания различной
  информации.  В этом разделе описываются ключевые слова, которые относятся
  ко всем определениям типа настройки.

  Все эти ключевые слова, за исключением @code{:tag}, можно использовать
  более чем один раз в определённом элементе.  Каждое использование ключевого
  слова имеет независимый эффект.  Ключевое слово @code{:tag} является
  исключением, потому что любой конкретный элемент может отображать только
  одно имя.

@table @code
@item :tag @var{label}
@kindex tag@r{, customization keyword}
Использует тег @var{label}, строку, вместо имени элемента, для отметки
элемента пункта меню настройки и буферах.   @strong{Не используйте тег,
который существенно отличается от реального имени элемента; это может
вызвать путаницу.}

@kindex group@r{, customization keyword}
@item :group @var{group}
Помещает этот элемент настройки в группу @var{group}.  Если это ключевое
слово отсутствует в элементе настройки, оно будет помещено в ту же группу,
которая была определена последней (в текущем файле).

При использовании @code{:group} в @code{defgroup}, новая группа становится
подгруппой группы @var{group}.

Если использовать это ключевое слово более чем один раз, можно поместить
один элемент в более чем одну группу.  Отображение любой из этих групп будет
показывать этот элемент.  Пожалуйста, не переусердствуйте, так как результат
будет раздражать.

@item :link @var{link-data}
@kindex link@r{, customization keyword}
Включает внешнюю ссылку после строки документации для элемента.  Это
предложение, содержит ссылку для перехода на некоторую другую документацию.

Есть несколько вариантов, которые можно использовать для @var{link-data}:

@table @code
@item (custom-manual @var{info-node})
Ссылка на узел Info; @var{info-node} является строкой, которая определяет
имя узла, как и в @code{"(emacs)Top"}.  Ссылка выглядит как @samp{[Manual]} в
буфере настройки и запускает встроенную программу справки Info, ноду
@var{info-node}.

@item (info-link @var{info-node})
Как @code{custom-manual} за исключением того, что ссылка появляется в
настройках буфера с именем узла Info.

@item (url-link @var{url})
Ссылка на веб-страницу; @var{url} является строкой, которая определяет
@acronym{URL}.  Отображается ссылка в настройках буфера как @var{url} и
вызывает WWW-браузер, указанный в @code{browse-url-browser-function}.

@item (emacs-commentary-link @var{library})
Ссылка на раздел комментариев библиотеки; @var{library} является строкой,
которая определяет имя библиотеки.  @xref{Library Headers}.

@item (emacs-library-link @var{library})
Ссылка на файл библиотеки Emacs Lisp; @var{library} является строкой, которая
определяет имя библиотеки.

@item (file-link @var{file})
Ссылка на файл; @var{file} является строкой, которая определяет имя файла
для посещения с использованием @code{find-file}, когда пользователь вызывает
эту ссылку.

@item (function-link @var{function})
Ссылка на документацию функции; @var{function} является строкой, которая
определяет имя функции, чтобы использовать с @code{describe-function}, когда
пользователь кликает эту ссылку.

@item (variable-link @var{variable})
Ссылка на документацию переменной; @var{variable} является строкой, которая
определяет имя переменной, чтобы использовать с @code{describe-variable},
когда пользователь кликает эту ссылку.

@item (custom-group-link @var{group})
Ссылка на другую группу настройки.  Вызов создает новый буфер настройки
@var{group}.
@end table

Можно задать текст для использования в буфере настройки путем добавления
@code{:tag @var{name}} после первого элемента @var{link-data}; например,
@code{(info-link :tag "foo" "(emacs)Top")} создаёт ссылку на руководство
Emacs, которое появляется в буфере с именем @samp{foo}.

Можно использовать это ключевое слово более чем один раз, чтобы добавить
несколько ссылок.

@item :load @var{file}
@kindex load@r{, customization keyword}
Загрузить файл @var{file} (строку) перед отображением этого элемента
настройки (@pxref{Loading}).  Загрузка выполняется используя @code{load}, и
только если файл ещё не был загружен.

@item :require @var{feature}
@kindex require@r{, customization keyword}
Выполнить @code{(require '@var{feature})} чтобы применить сохраненные
настройки значения этого элемента. @var{feature} должен быть символом.
(ВопросCustomize152)

Наиболее распространенная причина использования @code{:require}, когда
переменная включает функцию, такую как второстепенный режим, и простая
установка переменной не будет иметь никакого эффекта, если не загружен код,
который реализуется загружаемым режимом.

@item :version @var{version}
@kindex version@r{, customization keyword}
Это ключевое слово указывает, что элемент был впервые введен в Emacs в
версии @var{version}, или его значение по умолчанию было изменено в
указанной версии.  Значение @var{version} должно быть строкой.

@item :package-version '(@var{package} . @var{version})
@kindex package-version@r{, customization keyword}
Это ключевое слово указывает, что элемент был впервые введен в пакете
@var{package} с версией @var{version}, или что его значение или значение по
умолчанию было изменено в этой версии.  Это ключевое слово имеет приоритет
над @code{:version}.

@var{package} должно быть официальным названием пакета, как символ
(такой как, @code{MH-E}).  @var{version} должно быть строкой.  Если пакет
@var{package} выпущен как часть Emacs, @var{package} и @var{version} должны
появиться в значении @code{customize-package-emacs-version-alist}.
@end table

Пакеты распространяемые как часть Emacs, использующие ключевое слово
@code{:package-version} длжны также обновлять переменную
@code{customize-package-emacs-version-alist}.

@defvar customize-package-emacs-version-alist
Ассоциативный список обеспечивает отображение связи версий Emacs с версиями
пакета, указанной в @code{:package-version} ключевом слове. Ее элементы:

@example
(@var{package} (@var{pversion} . @var{eversion})@dots{})
@end example

Для каждого пакета @var{package}, который является символом, есть один или
несколько элементов, которые содержат версии пакета @var{pversion} с
соответствующей версии Emacs @var{eversion}.  Эти версии являются строками.
Например, MH-E пакет обновляет этот ассоциативный список с нижеследующим:

@c Должен быть маленьким, а этот еще слишком широк.
@c Исправте: Очевидно, что это устаревший (в коде).
@smallexample
(add-to-list 'customize-package-emacs-version-alist
             '(MH-E ("6.0" . "22.1") ("6.1" . "22.1") ("7.0" . "22.1")
                    ("7.1" . "22.1") ("7.2" . "22.1") ("7.3" . "22.1")
                    ("7.4" . "22.1") ("8.0" . "22.1")))
@end smallexample

Значение @var{package} должно быть уникальным, и должно соответствовать
значению @var{package} появляющегося в  ключевом слове
@code{:package-version}.  Так как пользователь может увидеть в сообщении об
ошибке это значение, хороший выбор официальное название пакета, такое как
MH-E или Gnus.
@end defvar

@node Group Definitions
@section Определение Групп Настройки
@cindex define customization group
@cindex customization groups, defining

  Каждый пакет Emacs Lisp должен иметь одну основную группу настройки,
  которая содержит все варианты, текстовое отображение и другие группы в
  пакете.  Если пакет имеет небольшое количество опций и отображений текста,
  лучше использовать только одну группу и разместить все в ней.  При наличии
  более чем двадцати вариантов и отображений текста, лучше разделить их на
  подгруппы, и поставить подгруппы под основной настройки группы пакета.  Это
  применимо, чтобы расположить некоторые из вариантов и отображений текста
  на одном уровне с основной группой программ пакета вместе с подгруппами.

  Основная или единственная группа пакета должна быть членом одной или
  нескольких стандартных групп настройки.  (Чтобы отобразить полный список,
  используется @kbd{M-x customize}.)  Выберается один или несколько из них
  (но не слишком много), и добавляется группа к каждому из них с помощью
  @code{:group} ключевого слова.

  Способ объявить новые группы настройки с помощью @code{defgroup}.

@defmac defgroup group members doc [keyword value]@dots{}
Объявляет @var{group} в качестве группы настройки, содержащей @var{members}.
Не указывайте символ @var{group}.  Аргумент @var{doc} указывает строку
документации для группы.  (ВопросCustomize236)

Аргумент @var{members} представляет собой список с указанием исходного
набора элементов членов группы настройки.  Тем не менее, чаще всего
@var{members} установлен в @code{nil}, а указываются участники группы,
используя ключевое слово @code{:group} при их определении.

Если требуется указать член группы через @var{members}, каждый элемент должен
иметь вид @code{(@var{name} @var{widget})}.  Здесь @var{name} является
символом, а @var{widget} виджетом типа для редактирования этого символа.
Полезные виджеты для переменных @code{custom-variable}, @code{custom-face}
для отображения текста, и @code{custom-group} для группы.

Когда вводится новая группа настроек в Emacs, используется ключевое слово
@code{:version} в @code{defgroup}; его не нужно использовать для отдельных
членов группы.

В дополнении к (@pxref{Common Keywords}) общим ключевым словам, также можно
использовать это ключевое слово в @code{defgroup}:

@table @code
@item :prefix @var{prefix}
@kindex prefix@r{, @code{defgroup} keyword}
Если имя элемента в группе начинается с @var{prefix} и настраиваемая
переменная @code{custom-unlispify-remove-prefixes} установленна в
не-@code{nil}, тег элемента будет опускать @var{prefix}.  Группа может иметь
любое количество префиксов.
@end table

@cindex @code{custom-group} property
Переменные и подгруппы группы сохраняются в @code{custom-group} свойстве
символа группы.  @xref{Symbol Plists}.  Значение этого свойства представляет
собой список пар, где @code{car} является символом переменной или подгруппы,
а @code{cdr} это либо @code{custom-variable} либо @code{custom-group}.
@end defmac

@defopt custom-unlispify-remove-prefixes
Если эта переменная установленна в не-@code{nil}, префиксы, указанные
ключевым словом @code{:prefix} какой-либо группы опускаются в именах тегов,
когда пользователь настраивает группу.

Значение по умолчанию @code{nil}, т.е. функция отбрасывания префикса имени
отключена.  Это происходит потому, что отбрасывание префикса часто приводит к
запутанным имена опций и отображениям текста.
@end defopt

@node Variable Definitions
@section Определение Переменных Настройки
@cindex define customization options
@cindex customizable variables, how to define
@cindex user options, how to define

  @dfn{Настраиваемые переменные}, называемый также
  @dfn{опциями пользователя}, являются глобальными Lisp переменными,значения
  которых могут быть установлены через интерфейс Настройки.  В отличие от
  других глобальных переменных, которые определяются с использованием
  @code{defvar} (@pxref{Defining Variables}), настраиваемые переменные
  определяются с помощью @code{defcustom} макроса.  Помимо вызова
  @code{defvar} в качестве подпрограммы, @code{defcustom} устанавливает, как
  переменная должна отображаться в интерфейсе Настройка, какие значения
  допускается ей принимать и так далее.

@defmac defcustom option standard doc [keyword value]@dots{}
Макрос объявляет @var{option} в качестве опции пользователя (то есть,
настраиваемый переменной).  Не нужно цитировать @var{option}.

Аргумент @var{standard} содержит выражение, которое задает стандартное
значение для @var{option}.  Оценивая форму @code{defcustom} оценивает
@var{standard}, но не обязательно привязывать опцию к этому значению.  Если
@var{option} уже имеет значение по умолчанию, оно остается неизменным.  Если
пользователь уже сохранил настройки для @var{option}, индивидуальные значения
пользователя устанавливается в качестве значения по умолчанию.  В противном
случае, результат вычисления @var{standard} устанавливается в качестве
значения по умолчанию.

Как и макрос @code{defvar}, этот макрос отмечает @code{option} в качестве
специальной переменной, а это означает, что она должен всегда быть
динамически связана.  Если @var{option} уже лексически связана, то
лексическое связывания остается в силе до выхода из конструкции связывания.
@xref{Variable Scoping}.  (ВопросCustomize315)

Выражение @var{standard} может быть оценено в различных других случаях, очень
часто, когда при настройки объекта необходимо знать @var{option}'s
стандартное значение.  Поэтому обязательно нужно использовать выражение,
которое безвредно для оценки в любое время.  (ВопросCustomize320)

Аргумент @var{doc} указывает строку документации для переменной.

Если @code{defcustom} не определяет @code{:group}, последняя группа,
определенная с использованием @code{defgroup} в том же файле, будет
использована.  Таким образом, в большинстве случаев в @code{defcustom} не
нужно явно задавать @code{:group}.

@cindex @code{eval-defun}, and @code{defcustom} forms
Когда оценивается форма @code{defcustom} с использованием @kbd{C-M-x} в Emacs
Lisp режиме (@code{eval-defun}), специальная функция @code{eval-defun}
безоговорочно установит переменную, не проверяя, является ли её значение
действительным.  (Та же функция применимп км@code{defvar},
@pxref{Defining Variables}.).  Использование @code{eval-defun} в форме
defcustom, с переменной которая уже определена, вызывает функцию @code{:set}
(смотрим ниже).  (ВопросCustomize336)

Если установить @code{defcustom} в предварительно загружаемый Emacs Lisp файл
(@pxref{Building Emacs}), стандартное значение устанавливаемое во время
дампа может быть неправильным, например, потому что другая переменная,
которая влияет на установку, не получила ещё правильное значение.  В этом
случае рекомендуется использовать @code{custom-reevaluate-setting}, описанно
ниже, чтобы повторно оценивать стандартное значение после того, как Emacs
запустится.
@end defmac

  В дополнение к ключевым словам, перечисленных в @ref{Common Keywords},
  этот макрос принимает следующие ключевые слова:

@table @code
@item :type @var{type}
Назначает тип @var{type} как тип данных для этой опции.  Определяет, какие
значения являются допустимыми, и как отображать это значение
(@pxref{Customization Types}).  При каждом использовании @code{defcustom}
требуется указывать значение для этого ключевого слова.

@item :options @var{value-list}
@kindex options@r{, @code{defcustom} keyword}
Указывает список подходящих значений для использования в этой опции.
Пользователь не ограничивается использованием только этих значений, но они
предлагаются в качестве удобных альтернатив.

Это имеет смысл только для определенных типов, в настоящее время в их числе
@code{hook}, @code{plist} и @code{alist}.  Смотреть определение описания
отдельных типов с использованием @code{:options}.

@item :set @var{setfunction}
@kindex set@r{, @code{defcustom} keyword}
Указывает функцию @var{setfunction} используемую для изменения значения этого
параметра при использовании интерфейса Настройки.  Функция @var{setfunction}
должна принимать два аргумента, символ (имя параметра) и новое значение,
также должна сделать все необходимое, чтобы обновить допустимое значение
для этой опции (которое не может означать просто установку параметра в
качестве переменной Lisp); предпочтительно не изменяя свое значение аргумента
деструктивно.  По умолчанию @var{setfunction} установлено в
@code{set-default}.

Если указать это ключевое слово, строка документации переменной должна
описать, как сделать эту же работу самостоятельно написанном коде Lisp.

@item :get @var{getfunction}
@kindex get@r{, @code{defcustom} keyword}
Указывает функцию @var{getfunction} как способ извлечь значение этого
параметра.  Функция @var{getfunction} должна принимать один аргумент, символ,
и должна вернуть все настройки, которые следует использовать в качестве
текущего значения этого символа (которое не обязательно должно быть значением
Lisp символа). По умолчанию @code{default-value}.  (ВопросCustomize387)

Требуется действительно понять работу Настройки, для правильного
использования @code{:get}.  Оно предназначено для значений, которые
рассматриваются в Настройке как переменные, но на самом деле не хранятся в
Lisp как переменные.  Это почти наверняка приведёт к ошибке, указать
@var{getfunction} для значения, которое на самом деле хранится в переменной
Lisp.

@item :initialize @var{function}
@kindex initialize@r{, @code{defcustom} keyword}
@var{function} должно быть функцией, которая используется для инициализации
переменной, когда @code{defcustom} оценивается.  Должна принимать два
аргумента, имя параметра (символ) и значение.  Вот некоторые предопределенные
функции, предназначенные для использования таким образом:

@table @code
@item custom-initialize-set
Используйте функцию @code{:set} для инициализации переменной, но не для
повторной инициализации, если переменная уже не недействительна.

@item custom-initialize-default
Как и @code{custom-initialize-set}, но использует функцию @code{set-default}
для установки переменной, вместо функции @code{:set}.  Это обычный выбор для
переменной, @code{:set} функция включает или выключает второстепенный режим;
если определять переменную таким образом не будет вызываться функция
второстепенного режима, в отличии от настройки переменной.

@item custom-initialize-reset
Всегда используется функция @code{:set} для инициализации переменной.  Если
переменная уже не недействительна, сбросит её с помощью вызова функции
@code{:set} с использованием текущего значения (возвращаемое методом
@code{:get}).  Функция @code{:initialize} по умолчанию.

@item custom-initialize-changed
Используется функция @code{:set} для инициализации переменной, если она уже
установлена или настроена; в противном случае, просто используется
@code{set-default}.

@item custom-initialize-delay
Функция ведет себя как и @code{custom-initialize-set}, но задерживает
фактическую инициализацию до начала следующего запуска Emacs. Это должно быть
использовано в файлах, которые являются предварительно загруженными (или для
автозагружаемых переменных), так что их инициализация выполняется в время
выполнения контекста, а не в контексте времени выполнения.  Это также имеет
побочный эффект, такой как (задержка) выполнение инициализации с помощью
функции @code{:set}.  @xref{Building Emacs}.
@end table

@item :risky @var{value}
@kindex risky@r{, @code{defcustom} keyword}
Установка свойство переменной @code{risky-local-variable} в значение
@var{value} (@pxref{File Local Variables}).

@item :safe @var{function}
@kindex safe@r{, @code{defcustom} keyword}
Установка свойства переменной @code{safe-local-variable} в значение
@var{function} (@pxref{File Local Variables}).

@item :set-after @var{variables}
@kindex set-after@r{, @code{defcustom} keyword}
Установка переменных в соответствии с сохраненными настройками, убедиться,
что переменные @var{variables} уже установлены перед этой; то есть отложить
настройку этой переменной до тех пор, пока не будут обработаны другие.
Использовать @code{:set-after}, если установка этой переменной не зависит от
установленных значений других переменных.
@end table

  Полезно указать ключевое слово @code{:require} для опции, в которой
  установлено определение функции.  Это приводит к тому, что Emacs загрузит
  эту функцию, если она еще не загружена, когда этот параметр будет
  устанавливаться. @xref{Common Keywords}. Вот пример:

@example
(defcustom frobnicate-automatically nil
  "Не-nil значение устанавливает автомотическое сохранение для всех буферов."
  :type 'boolean
  :require 'frobnicate-mode
  :group 'frobnicate)
@end example

Если элемент настройки имеет тип, такой как @code{hook} или @code{alist} и
поддерживает @code{:options}, можно добавить дополнительные значения в список
за пределами объявления @code{defcustom} вызвав функцию
@code{custom-add-frequent-value}.  Например, если определить функцию
@code{my-lisp-mode-initialization} предназначенную для вызова из
@code{emacs-lisp-mode-hook}, можно добавить в список подходящих значений
@code{emacs-lisp-mode-hook}, без редактирования её определения.  Можно
сделать это следующим образом:

@example
(custom-add-frequent-value 'emacs-lisp-mode-hook
   'my-lisp-mode-initialization)
@end example

@defun custom-add-frequent-value symbol value
Опция настройки @var{symbol}, добавление значения @var{value} в список
рекомендуемых значений.

Точный эффект добавления значения зависит от типа настройки @var{symbol}.
@end defun

Внутри @code{defcustom} используется свойство символа @code{standard-value}
записывается выражение для стандартного значения, @code{saved-value}
записывает значение, сохраненное пользователем с помощью буфера настройки, и
@code{customized-value} записывает установленное значение пользователя с
помощью буфера настройки, но без сохранения.  @xref{Symbol Properties}.  Эти
свойства являются списками, @code{car}, которых является выражением,
определяющее значение.

@defun custom-reevaluate-setting symbol
Функция повторно вычисляет стандартное значение @var{symbol}, которое должно
быть объявлено ​​по желанию пользователя с помощью @code{defcustom}.  Если
переменная была настроена, то эта функция переоценивает сохраненное значение.
Затем устанавливается параметр пользователя к этому значению (используя
свойство опции @code{:set}, если это определено).

Это полезно для настраиваемых опций, которые определяются, прежде чем их
значения могут быть вычислены правильно.  Например, во время запуска, Emacs
вызывает эту функцию для некоторых пользовательских параметров, которые были
определены в предварительно загруженных Emacs Lisp файлах, но чьи
первоначальные значения зависят от информации, доступной только во время
выполнения.
@end defun

@defun custom-variable-p arg
Функция возвращает не-@code{nil} если @var{arg} это настраиваемая переменная.
Настраиваемая переменная это переменная, которая имеет свойство
@code{standard-value} или @code{custom-autoload} (как правило, означает, что
она была объявлена ​​с @code{defcustom}) или псевдонимом для другой
настраиваемой переменной.
@end defun

@node Customization Types
@section Настройка Типы

@cindex customization types
  При определении параметра пользователя с использованием @code{defcustom},
  необходимо указать его @dfn{тип настройки}.  То есть:  (1) объект Lisp,
  который описывает допустимые значения и (2) как отображать значение в
  буфере для редактирования настройки.

@kindex type@r{, @code{defcustom} keyword}
  Необходимо указать тип настройки в @code{defcustom} свойству с ключевым
  словом @code{:type}.  Аргумент @code{:type} оценивается один раз, когда
  выполняется @code{defcustom}, так что это не полезно для изменения
  значений.  Обычно используется цитируемая константа. Например:

@example
(defcustom diff-command "diff"
  "Команда, используемая для запуска diff."
  :type '(string)
  :group 'diff)
@end example

  В общем, тип настройки представляет собой список, первый элементом которого
  является символ, одного из имен типов настройки, определенных в следующих
  разделах.  После этого символа следует ряд аргументов, в зависимости от
  указанного символа.  Между символом типа и его аргументами, можно при
  желании написать ключевые пары слово-значение (@pxref{Type Keywords}).

  Некоторые символы типа, не используют аргументы; они называются
  @dfn{простыми типами}.  Для простого типа, если не используется какие-либо
  ключевые пары слово-значение, можно опустить скобки вокруг символа типа.
  Например просто @code{string} как тип настройки эквивалентно
  @code{(string)}.

  Все типы настроек реализованы в виде виджетов; смотреть @ref{Top, ,
Introduction, widget, The Emacs Widget Library}, для деталей.

@menu
* Simple Types::            Простые типы настройки: sexp, integer и т.д..
* Composite Types::         Создание новых типов из других типов или данных.
* Splicing into Lists::     Сращивание элементов в список с @code{:inline}.
* Type Keywords::           Ключевые пары слово-аргумент в типе настройки.
* Defining New Types::      Задайте вашему типу имя.
@end menu

@node Simple Types
@subsection Простые Типы

  В этом разделе описаны все простые типы настройки.  Для некоторых из этих
  типов настройки, настройки виджета обеспечивает встроенное завершение с
  использованием @kbd{C-M-i} или @kbd{M-@key{TAB}}.

@table @code
@item sexp
Значение может быть любым Lisp объект, который можно вывести и прочитать
обратно.  Можно использовать @code{sexp} как запасной вариант для любого
варианта, если нет желания тратить время, чтобы разработать более конкретный
тип для использования.

@item integer
Значение должно быть целым числом.

@item number
Значение должно быть числом (с плавающей точкой или целым числом).

@item float
Значение должно быть с плавающей точкой.

@item string
Значение должно быть строкой. В буфере настройки показывает строку без
цитирования разделительных символов @samp{"} или @samp{\}.
(ВопросCustomize590)

@item regexp
Как и @code{string} за исключением того, что строка должна быть регулярным
выражением.

@item character
Значение должно быть кодом символа.  Код символа на самом деле является целым
числом, и этот тип показывает значение путем вставки символа в буфер, а не
путем вставки числа.

@item file
Значение должно быть именем файла. Виджет обеспечивает завершение.

@item (file :must-match t)
Значение должно быть именем существующего файла.  Виджет обеспечивает
завершение.

@item directory
The value must be a directory.  The widget provides completion.

@item hook
Значение должно быть списком функций.  Этот тип настройки используется для
переменных ловушек.  Можно также использовать ключевое слово @code{:options}
в переменной ловушке в @code{defcustom}, чтобы определить список функций,
рекомендованный для использования в ловушке; @xref{Variable Definitions}.

@item symbol
Значение должно быть символом.  Оно появляется в буфере настройки в качестве
имени символа.  Виджет обеспечивает завершение.

@item function
Значение должно быть либо лямбда-выражением или именем функции.  Виджет
обеспечивает завершение для имён функций.

@item variable
Значение должно быть именем переменной.  Виджет обеспечивает завершение.

@item face
Значение должно быть символом, которое является именем отображения текста.
Виджет обеспечивает завершение.

@item boolean
Булево значение --- либо @code{nil} или @code{t}.  Обратите внимание, что
при использовании @code{choice} и @code{const} вместе (смотрите следующий
раздел), можно указать, что значение должно быть @code{nil} или @code{t}, а
также указать текст для описания каждого значения таким образом, при
выборе конкретного значения альтернативы.  (ВопросCustomize638)

@item key-sequence
Значение представляет собой последовательность клавиш.  Буфер настройки
показывает ключевую последовательность, используя тот же синтаксис, что и
функция @kbd{kbd}.  @xref{Key Sequences}.

@item coding-system
Значение должно быть именем системы кодирования, можно производить завершение
с комбинацией @kbd{M-@key{TAB}}.

@item color
Значение должно быть допустимым именем цвета.  Виджет предусматривает
завершение для названий цветов, а также образец и кнопку для выбора имени
цвета из списка названий цветов, показанных в буфере @file{*Colors*}.
@end table

@node Composite Types
@subsection Составные Типы
@cindex composite types (customization)

  Когда ни один из простых типов не подходит, можно использовать составные
  типы, которые строят новые типы из других типов или уточненных данных.
  Указанные типы или данные называются @dfn{аргументами} составного типа.
  Составной тип обычно выглядит следующим образом:

@example
(@var{constructor} @var{arguments}@dots{})
@end example

@noindent
также можно добавлять пары ключевое слово-значение перед аргументами, как
здесь:

@example
(@var{constructor} @r{@{}@var{keyword} @var{value}@r{@}}@dots{} @var{arguments}@dots{})
@end example

  Вот таблица конструкторов и как использовать их для написания составных
  типов:

@table @code
@item (cons @var{car-type} @var{cdr-type})
Значение должно быть cons-ячецкой , её @sc{car} должен соответствовать
@var{car-type}, и его @sc{cdr} должен соответствовать @var{cdr-type}.
Например, @code{(cons string symbol)} представляет собой тип настройки,
который соответствует значениям, таким как @code{("foo" . foo)}.

В буфере настройки, @sc{car} и @sc{cdr} отображаются и редактируются
отдельно, каждый в соответствии со своим указанным типом.

@item (list @var{element-types}@dots{})
Значение должно быть списком с точно таким количеством элементов, как
заданно в @var{element-types}; и каждый элемент должен соответствовать
каждому своему соответствующему @var{element-type}.

Например, @code{(list integer string function)} описывает список из трех
элементов; первый элемент должен быть целым числом, второй строкай, третий
функцией.

В буфере настройки, каждый элемент отображается и редактируются отдельно, в
зависимости от типа, установленного для него.

@item (group @var{element-types}@dots{})
Это работает как @code{list} за исключением того, что для форматирования
текста используется буфер пользователя.  @code{list} отмечает каждое значение
элемента его тегом; @code{group} нет.

@item (vector @var{element-types}@dots{})
Как и @code{list} за исключением того, что значение должно быть вектором, а
не списком.  Элементы отработают так же, как и в @code{list}.

@item (alist :key-type @var{key-type} :value-type @var{value-type})
Значение должно быть списком cons-ячеек, @sc{car} каждой ячейки,
представлять собой ключ типа настройки @var{key-type} и @sc{cdr} той же
ячейки, представлять значение типа настройки @var{value-type}.  Пользователь
может добавлять и удалять пары ключ/значение, а также редактировать и ключ и
значение каждой пары.

Если этот параметр опущен, @var{key-type} и @var{value-type} по умолчанию
@code{sexp}.

Пользователь может добавить любой ключ, соответствующий указанному типу
ключа, но можно задать некоторым ключам приоритетный режим, указав это с
помощью @code{:options} (смотреть @ref{Variable Definitions}).  Указанные
ключи всегда будут отображаться в буфере настройки (вместе с соответствующим
значением), с помощью флажка, чтобы включить, исключить или отключить пару
ключ/значение из ALIST.  Пользователь не сможет редактировать ключи,
указанные в аргументе с ключевым словом @code{:options}.

Аргумент с ключевым словом @code{:options}, должен быть списком спецификаций
допустимых ключей в ассоциативном списке.  Как правило, это просто атомы,
которые оценивают сами себя. Например:

@example
:options '("foo" "bar" "baz")
@end example

@noindent
указывает на то, что есть три известных ключа, а именно @code{"foo"},
@code{"bar"} и @code{"baz"}, которые всегда будут показаны первыми.

Можете ограничить тип значения для конкретных ключей, например, значение,
связанное с ключом @code{"bar"} может быть только целым числом.  Можете
указать это в списке с помощью списка вместо атома.  Первый элемент будет
указывать ключ, как и раньше, в то время как второй элемент будет указать
тип значения. Например:

@example
:options '("foo" ("bar" integer) "baz")
@end example

Наконец, можно изменить то, как представляется ключ.  По умолчанию ключ
просто представляется как @code{const}, так как пользователь не может
изменить специальные клавиши, указанные с ключевым словом @code{:options}.
Тем не менее, можно использовать более специализированный тип для
представления ключа, как @code{function-item}, если известно, что это символ
с действительной функцией.  Это делается с помощью спецификации типа
настройки вместо символа ключа.

@example
:options '("foo"
           ((function-item some-function) integer)
           "baz")
@end example

Многие ассоциативные списки используют списки с двумя элементами, вместо
cons-ячейки. Например,

@example
(defcustom list-alist
  '(("foo" 1) ("bar" 2) ("baz" 3))
  "Каждый элемент представляет собой список вида (KEY VALUE).")
@end example

@noindent
instead of

@example
(defcustom cons-alist
  '(("foo" . 1) ("bar" . 2) ("baz" . 3))
  "Каждый элемент является cons-ячейкой (KEY . VALUE).")
@end example

Благодаря тому, как реализована работа со списками вместо cons-ячеек, можно
представить @code{list-alist} в приведенном выше примере, как cons-ячейкой
ALIST, где тип значения представляет собой список с одним элементом,
содержащим реальное значение.

@example
(defcustom list-alist '(("foo" 1) ("bar" 2) ("baz" 3))
  "Каждый элемент представляет собой список вида (KEY VALUE)."
  :type '(alist :value-type (group integer)))
@end example

@code{group} виджет здесь используется вместо @code{list} только потому, что
форматирование лучше подходит для этой цели.

Кроме того, можно иметь alists с большим количеством значений, связанными с
каждым ключом, используя вариацию этого трюка:

@example
(defcustom person-data '(("brian"  50 t)
                         ("dorith" 55 nil)
                         ("ken"    52 t))
  "ALIST базовой информации о людях.
Каждый элемент имеет вид (NAME AGE MALE-FLAG)."
  :type '(alist :value-type (group integer boolean)))
@end example

@item (plist :key-type @var{key-type} :value-type @var{value-type})
Этот тип настройки похож на @code{alist} (смотри выше), за исключением того,
что (1) информация хранится в виде списка свойств, (@pxref{Property Lists}),
и (2) @var{key-type}, если не указано, используется по умолчанию
@code{symbol}, а не @code{sexp}.

@item (choice @var{alternative-types}@dots{})
Значение должно соответствовать одному из типов @var{alternative-types}.
Например, @code{(choice integer string)} допускает к использованию целое
число или строку.

В буфере настройки, пользователь выбирает альтернативу с помощью меню, а
затем может изменить значение обычным способом для этой альтернативы.

Обычно строки в этом меню определяется автоматически из вариантов; Однако,
можно задать различные строки для меню, включая @code{:tag} ключевое слово в
альтернативах.  Например, если целое число обозначает количество пробелов, а
строка текста используется дословно, можно написать настройки типа таким
образом,

@example
(choice (integer :tag "Количество мест")
        (string :tag "Дословный текст"))
@end example

@noindent
так что меню будет предлагать @samp{Количество мест} и
@samp{Дословный текст}.  В какой-либо альтернативы, для которых @code{nil}
не является допустимым значением, кроме @code{const}, нужно указать
допустимое значение по умолчанию для этой альтернативы, используя ключевое
слово @code{:value}.  @xref{Type Keywords}.

Если некоторые значения предназначены более чем для одной из альтернатив,
при настройке выберется первый вариант, которому соответствует значение.  Это
означает, что всегда нужно вначале перечислить более конкретные типы, а затем
более общие типы.  Вот пример правильного использования:

@example
(choice (const :tag "Off" nil)
        symbol (sexp :tag "Other"))
@end example

@noindent
Таким образом, как и значение @code{nil}, так другие символы и другие
выражения Lisp не обрабатываются.  (ВопросCustomize852)

@cindex radio, customization types
@item (radio @var{element-types}@dots{})
Это похоже на @code{choice}, за исключением того, что варианты отображается с
помощью с помощью переключателя, а не меню.  Это имеет преимущество
отображения документации для выбора, когда это применимо, и поэтому часто
является хорошим выбором для выбора между постоянными функциями (типы
настройки @code{function-item}).  (ВопросCustomize860)

@item (const @var{value})
Значение должно быть @var{value} --- другое ничего не допускается.

Основное применение @code{const} - это внутри @code{choice}.  Например,
@code{(choice integer (const nil))} допускаем целое число или @code{nil}.

@code{:tag} часто используется с @code{const}, внутри @code{choice}.
Пример,

@example
(choice (const :tag "Да" t)
        (const :tag "Нет" nil)
        (const :tag "Вопрос" foo))
@end example

@noindent
описывает переменную, для которой @code{t} означает ``Да'', @code{nil}
означает ``Нет'', и @code{foo} означает ``Вопрос''.

@item (other @var{value})
Эта альтернатива может соответствовать любому Lisp значению, но если
пользователь выбирает этот вариант, он выбирает значение @var{value}.

Основное применение @code{other} в качестве последнего элемента
@code{choice}.  Например,

@example
(choice (const :tag "Да" t)
        (const :tag "Нет" nil)
        (other :tag "Вопрос" foo))
@end example

@noindent
описывает переменную, для которой @code{t} означает ``Да'', @code{nil}
означает ``Нет'', а всё остальное означает ``Вопрос''.  Если пользователь
выбирает @samp{Вопрос} из меню альтернатив, это задает значение @code{foo};
но любое другое значение (не @code{t}, @code{nil} или @code{foo})
отличное от @samp{Вопрос}, так же, отображается как @code{foo}.
(ВопросCustomize900)

@item (function-item @var{function})
Также Как @code{const}, но используются для значений, которые являются
функциями.  Это показывает строку документации, а также имя функции.  Строка
документации либо задана с @code{:doc} или собственной строкой документации
функции @var{function}.

@item (variable-item @var{variable})
Также как @code{const}, но используется для значений, которые являются
именами переменных.  Это выводит строку документации, а также имя переменной.
Строка документации либо задана с @code{:doc} или собственной строкой
документации переменной @var{variable}.

@item (set @var{types}@dots{})
Значение должно быть списком, и каждый элемент списка должен совпадать с
одним из указанных типов @var{types}.

Это представляется буфере настройки в качестве контрольного списка, где
каждый из типов @var{types} может иметь либо один соответствующий элемент или
либо не иметь ни одного.  Не представляется возможным определить два
различных элемента, которые соответствуют одному и томуже типу в @var{types}.
Например, @code{(set integer symbol)} допускает одно целое число и/или один
символ в списке; не допускается несколько целых чисел или несколько символов.
В результате, редко используются неспецифические типы, такие как
@code{integer} в @code{set}.

Чаще всего, типы @var{types} в @code{set} являются @code{const} типами, как
показано здесь:

@example
(set (const :bold) (const :italic))
@end example

Иногда они описывают возможные элементы в ALIST:

@example
(set (cons :tag "Высота" (const height) integer)
     (cons :tag "Ширина" (const width) integer))
@end example

@noindent
Это позволяет пользователю определить необязательное значение высоты и
необязательное значение ширины.

@item (repeat @var{element-type})
Значение должно быть списком, и каждый элемент которого должен
соответствовать типу @var{element-type}.  Это появляется в буфере настройки в
виде списка элементов, отображаемых с помощью кнопок @samp{[INS]} и
@samp{[DEL]} для добавления дополнительных элементов или удаления элементов.

@cindex restricted-sexp, customization types
@item (restricted-sexp :match-alternatives @var{criteria})
Это самый общий тип составной конструкции.  Значение может быть любым
объектом Lisp, удовлетворяющий одному из условий @var{criteria}.
Условие @var{criteria} должно быть списком, и каждый элемент должен быть один
из этих возможных:

@itemize @bullet
@item
Предикат --- то есть функция одного аргумента, которая возвращает либо
@code{nil} либо не-@code{nil} в соответствии с аргументом.  Использование
предиката в списке говорит о том, что объекты, для которых предикат
возвращает не-@code{nil} являются допустимыми.

@item
Цитируемая константа --- то есть, @code{'@var{object}}.  Этот вид элемента в
списке говорит, что сам объект @var{object} является допустимым значением.
@end itemize

For example,

@example
(restricted-sexp :match-alternatives
                 (integerp 't 'nil))
@end example

@noindent
допускаются целые числа, @code{t} и @code{nil} в качестве значений.

Буфер настройки показывает все допустимые значения, используя их синтаксис
для чтения, и пользователь редактирует их текстуально.
@end table

  Вот таблица из ключевых слов, которые можно использовать в парах
  ключевое слово-значение в составном типе настройки:

@table @code
@item :tag @var{tag}
Использовать тег  @var{tag} как имя альтернативы, для взаимодействия  с
пользователем.  Это полезно для того типа, который появляется внутри
@code{choice}.

@item :match-alternatives @var{criteria}
@kindex match-alternatives@r{, customization keyword}
Использовать условие @var{criteria} для сопоставления с возможными
значениями.  Это используется только в @code{restricted-sexp}.

@item :args @var{argument-list}
@kindex args@r{, customization keyword}
Использовать элементы @var{argument-list} как аргументы типа конструкции.
Например, @code{(const :args (foo))} эквивалентно @code{(const foo)}.  Редко
нужно писать @code{:args} явно, потому что обычно аргументы распознаются
автоматически, как все, что следует за последней парой ключевого
слова-значения.
@end table

@node Splicing into Lists
@subsection Сращивание в Cписки

  Функция @code{:inline} позволяет сращивать переменное число элементов в
  середину списка @code{list} или вектора @code{vector} типа настройки.
  Можно использовать это, добавляя @code{:inline t} к спецификации типа,
  соответствующей спецификации @code{list} или @code{vector}.

  Как правило, каждая запись в спецификации типа @code{list} или
  @code{vector} описывает один элемент типа.  Но когда запись содержит
  @code{:inline t}, соответствующее этому значение объединяется
  непосредственно с содержащейся в ней последовательностью.  Например, если
  запись соответствует списку с тремя элементами, они становятся тремя
  элементами общей последовательности.  Это аналогично @samp{,@@} в
  конструкции обратной кавычки (@pxref{Backquote}).

  Например, чтобы задать список, чей первый элемент должен быть @code{baz} а
  оставшиеся аргументы должны быть необязательно заданны такими как
  @code{foo} и @code{bar}, используется эта настройка типа:

@example
(list (const baz) (set :inline t (const foo) (const bar)))
@end example

(ВопросCustomize1031)
@noindent
Это соответствует таким значениям, как @code{(baz)}, @code{(baz foo)},
@code{(baz bar)} и @code{(baz foo bar)}.

@cindex choice, customization types
  Когда элемент типа является @code{choice}, используется @code{:inline} не
  в самом @code{choice}, а в (самих) альтернативах @code{choice}.  Например,
  чтобы сопоставить список, который должен начинаться с имени файла, за
  которым следует либо символ @code{t} либо две строки, используется этот тип
  настройки:

@example
(list file
      (choice (const t)
              (list :inline t string string)))
@end example

@noindent
Если пользователь выбирает первую альтернативу в выборе, то общий список
содержит два элемента, и второй элемент @code{t}.  Если пользователь выбирает
второй вариант, то общий список состоит из трех элементов, второй и третий
варианты должны быть строки.

@node Type Keywords
@subsection Тип Ключевые Cлова

Можно указать пары ключевых слов аргументов в настройки типа после символа
имени типа.  Вот ключевые слова и их значения, которые можно использовать:

@table @code
@item :value @var{default}
Предоставлять значение по умолчанию.

Если @code{nil} не является допустимым значением для альтернативы, то
необходимо указать действующее значение по умолчанию @code{:value}.

Если используется это для такого типа, который появляется в качестве
альтернативы внутри @code{choice}; тогда, во-первых, определяется значение по
умолчанию для использования, если и когда пользователь выбирает этот вариант
с меню в буфере настройки.

Конечно, если фактическое значение опции соответствует этому варианту, оно
будет отображаться, а не значение по умолчанию @var{default}.

@item :format @var{format-string}
@kindex format@r{, customization keyword}
Строка будет вставлена ​​в буфере для представления значения, соответствующего
типу.  Следующие символы за символом @samp{%}, рассматриваются как
escape-символы и доступны для использования в форматной строке
@var{format-string}:

@table @samp
@item %[@var{button}%]
Отображение текста @var{button} помеченного как кнопка.  Атрибут
@code{:action} указывает, что кнопка будет делать, если пользователь
вызывает кликнет её; значением является функция, которая принимает два
аргумента --- виджет, в котором появляется кнопка и событие.

Там нет никакого способа определить две различные кнопки с различными
действиями. (ВопросCustomize1091)

@item %@{@var{sample}%@}
Показать @var{sample} в специальном отображении указанным
@code{:sample-face}.

@item %v
Подставить значение элемента.  Как представляется значение, зависит от типа
элемента и (для переменных) от типа настройки.

@item %d
Подставить строку документации по элементу.

@item %h
Как и @samp{%d}, но если строка документации состоит более чем из одной
строки, добавить кнопку, для указания показывать ли всю документацию или
только первую строку.

@item %t
Подставить тег здесь. Необходимо указать тег с @code{:tag} ключевым словом.

@item %%
Отобразить буквально @samp{%}.
@end table

@item :action @var{action}
@kindex action@r{, customization keyword}
Выполнить действие @var{action}, если пользователь нажимает на кнопку.

@item :button-face @var{face}
@kindex button-face@r{, customization keyword}
Использовать визуализацию @var{face} (имя визуализации или список имен
визуализаций) для текста кнопки отображаемого с @samp{%[@dots{}%]}.

@item :button-prefix @var{prefix}
@itemx :button-suffix @var{suffix}
@kindex button-prefix@r{, customization keyword}
@kindex button-suffix@r{, customization keyword}
Определяют текст для отображения до и после кнопки. Каждый из них может
быть:

@table @asis
@item @code{nil}
Текст не вставляется.

@item a string
Строка вставляется в буквальном смысле.

@item a symbol
Используется значение символа.
@end table

@item :tag @var{tag}
Использовать @var{tag} (строка) в качестве тега для значения (или части
значения), который соответствует этому типу.

@item :doc @var{doc}
@kindex doc@r{, customization keyword}
Использовать в качестве строки документации @var{doc} для этого значения (или
части значения), которое соответствует этому типу.  Для того, чтобы это
работало, необходимо указать значение для @code{:format}, и использовать
@samp{%d} и @samp{%h} в этом значении.

Обычная причина, чтобы указать строку документации для типа заключается в
предоставлении дополнительной информации о значениях альтернатив внутри типа
@code{:choice} или части какого-либо другого составного типа.

@item :help-echo @var{motion-doc}
@kindex help-echo@r{, customization keyword}
При переходе к этому пункту с @code{widget-forward} или
@code{widget-backward}, будет отображена строка @var{motion-doc} в эхо
области.  Кроме того, @var{motion-doc} используется в качестве ссылки-строки
для мыши @code{help-echo} и может фактически быть функцией или формой,
оценка которой, отрабатывает получение строки помощи.  Если это функция, она
вызывается с одним аргументом - виджетом.

@item :match @var{function}
@kindex match@r{, customization keyword}
Указывает, как решить, соответствует ли значение типу.  Соответствующее
значение, @var{function}, должно быть функцией, которая принимает два
аргумента, виджет и значение; должна возвращить не-@code{nil}, если значение
является приемлемым.

@item :validate @var{function}
Указывает функцию проверки ввода.  @var{function} принимает виджет в качестве
аргумента, и должна возвращать @code{nil}, если текущее значение виджета
действительно для виджета.  В противном случае, должна вернуть виджет,
содержащий недопустимые данные, и установить, @code{:error} свойство
виджета в строку, объясняющее ошибку.

@ignore
@item :indent @var{columns}
Indent this item by @var{columns} columns.  The indentation is used for
@samp{%n}, and automatically for group names, for checklists and radio
buttons, and for editable lists.  It affects the whole of the
item except for the first line.

@item :offset @var{extra}
Indent the subitems of this item @var{extra} columns more than this
item itself.  By default, subitems are indented the same as their
parent.

@item :extra-offset @var{n}
Add @var{n} extra spaces to this item's indentation, compared to its
parent's indentation.

@item :notify @var{function}
Call @var{function} each time the item or a subitem is changed.  The
function gets two or three arguments.  The first argument is the item
itself, the second argument is the item that was changed, and the
third argument is the event leading to the change, if any.

@item :menu-tag @var{tag-string}
Use @var{tag-string} in the menu when the widget is used as an option
in a @code{menu-choice} widget.

@item :menu-tag-get
A function used for finding the tag when the widget is used as an option
in a @code{menu-choice} widget.  By default, the tag used will be either the
@code{:menu-tag} or @code{:tag} property if present, or the @code{princ}
representation of the @code{:value} property if not.

@item :tab-order
Specify the order in which widgets are traversed with
@code{widget-forward} or @code{widget-backward}.  This is only partially
implemented.

@enumerate a
@item
Widgets with tabbing order @code{-1} are ignored.

@item
(Unimplemented) When on a widget with tabbing order @var{n}, go to the
next widget in the buffer with tabbing order @var{n+1} or @code{nil},
whichever comes first.

@item
When on a widget with no tabbing order specified, go to the next widget
in the buffer with a positive tabbing order, or @code{nil}
@end enumerate

@item :parent
The parent of a nested widget (e.g., a @code{menu-choice} item or an
element of a @code{editable-list} widget).

@item :sibling-args
This keyword is only used for members of a @code{radio-button-choice} or
@code{checklist}.  The value should be a list of extra keyword
arguments, which will be used when creating the @code{radio-button} or
@code{checkbox} associated with this item.
@end ignore
@end table

@node Defining New Types
@subsection Определение новых типов
@cindex customization types, define new
@cindex define new customization types

В предыдущих разделах описано, как построить спецификации сложных типов для
@code{defcustom}.  В некоторых случаях можно дать имя такой спецификации
типа.  Очевидный случай, когда используется один и тот же тип для многих
пользовательских параметров: чтобы не повторить спецификации для каждого
варианта, можно задать имя спецификации типа, и использовать это имя в
@code{defcustom}.  Другой случай, когда значение пользовательского параметра
является рекурсивной структурой данных.  Для того, чтобы сделать возможным
типам данных, обращаться к себе, должно быть имя.

Поскольку пользовательские типы реализуются в виде виджетов, способ
определения нового типа подводит к тому, чтобы определить новый виджет.  Не
будем описывать интерфейс виджета здесь подробно, смотреть
@ref{Top, , Introduction, widget, The Emacs Widget Library}, для этого.
Вместо этого демонстрация минимальной функциональности, необходимой для
определения новых типов CUSTOMIZE на простом примере.

@example
(define-widget 'binary-tree-of-string 'lazy
  "Бинарное дерево сделано из cons-ячеек и строк."
  :offset 4
  :tag "Node"
  :type '(choice (string :tag "Leaf" :value "")
                 (cons :tag "Interior"
                       :value ("" . "")
                       binary-tree-of-string
                       binary-tree-of-string)))

(defcustom foo-bar ""
  "Простая переменная, содержащий бинарное дерево строк."
  :type 'binary-tree-of-string)
@end example

Вызывается функция для определения нового виджета @code{define-widget}.
Первый аргумент является символом нового типа виджета.  Второй аргумент
является символ, представляющий существующий виджет, новый виджет будет
определен в терминах отличия от существующего виджета.  С целью определения
новых типов настройки, @code{lazy} виджет идеально подходит, потому что он
принимает аргумент @code{:type} ключевого слова с тем же синтаксисом, как
и аргумент @code{defcustom} принимает ключевое слово с тем же именем.  Третий
аргумент является строкой документации для нового виджета.  Можно увидеть эту
строку с помощью команды
@kbd{M-x widget-browse @key{RET} binary-tree-of-string @key{RET}}.

После этих обязательных аргументов, следуют именованные аргументы.  Наиболее
важным является @code{:type}, который описывает тип данных, соответствующий
этомц виджету.  Здесь @code{binary-tree-of-string} описывается либо как
строка, или cons-ячейка @code{car} и @code{cdr} которой как
@code{binary-tree-of-string}.  Обратить внимание на ссылку на виджет типа,
в настоящее время в процессе определения.  @code{:tag} атрибут представляет
собой строку имени виджета в пользовательском интерфейсе, @code{:offset}
аргумент, чтобы гарантировать, что дочерние узлы будут иметь отступ в четыре
пробела относительно родительского узла, в результате чего структура дерева
проявляется в буфере настройки.  (ВопросCustomize1301)

@code{defcustom} показывает, как новый виджет может быть использован в
качестве обычного типа настройки.

Причина имени @code{lazy} является то, что другие составные виджеты
конвертировать свои подчиненные виджеты во внутреннюю форму, когда виджет
конкретизируются в буфере.  Это преобразование является рекурсивным, поэтому
подчиненные виджеты будут преобразовывать @emph{свои} подчиненные виджеты.
Если структура данных сама по себе рекурсивная, это преобразование породит
бесконечную рекурсию.  @code{lazy} виджет предотвращает рекурсию: преобразует
только единственный его @code{:type} аргумент при необходимости.

@node Applying Customizations
@section Применение Настроек
@cindex applying customizations

Следующие функции отвечают за установку параметров настройки пользователя
для переменных и визуализации, соответственно.  Когда пользователь вызывает
@samp{Сохранить для будущих сессий} в интерфейсе Customize, которое вступает
в силу, написав @code{custom-set-variables} и/или при оценки формы
@code{custom-set-faces} в пользовательском файле, который будет оцениваться
в следующем запуске Emacs.

@defun custom-set-variables &rest args
Функция устанавливает настройки переменных, указанные в @var{args}.  Каждый
аргумент в @var{args} должен иметь вид

@example
(@var{var} @var{expression} [@var{now} [@var{request} [@var{comment}]]])
@end example

@noindent
@var{var} это имя переменной (символа), и @var{expression} это выражение,
которое возвращает требуемое настраиваемое значение.

Если форма @code{defcustom} для @var{var} оценивается до
@code{custom-set-variables} вызова, @var{expression} сразу вычисляется, а
значение переменной устанавливается равное результату.  В противном случае,
@var{expression} сохранится в переменной @code{saved-value}, которая будет
оценена, когда соответствующая форма @code{defcustom} вызовется (обычно,
когда библиотека определения этой переменной загружается в Emacs).

@var{now}, @var{request}, и @var{comment} записи предназначены только для
внутреннего использования, и могут быть опущены.  @var{now}, если
не-@code{nil}, немедленная установка значения переменной, даже если форма
@code{defcustom} этой переменной ещё не была оценена.  @var{request} список
функций, которые будут загружены сразу (@pxref{Named Features}).
@var{comment} является строка, описывающая настройку.
@end defun

@defun custom-set-faces &rest args
Функция устанавливает настройки для визуализации, указанные аргументом
@var{args}.  Каждый аргумент в @var{args} должен иметь вид

@example
(@var{face} @var{spec} [@var{now} [@var{comment}]])
@end example

@noindent
@var{face} это имя визуализации (символ), и @var{spec} индивидуальная
спецификация этой визуализации (@pxref{Defining Faces}).

@var{now} и @var{comment} записи предназначены только для внутреннего
использования, и могут быть опущены.  @var{now}, если не-@code{nil},
указывает немедленную установку спецификации визуализации, даже если форма
@code{defface} не была ещё оценена.  @var{comment} является строка,
описывающая настройку.
@end defun

@node Custom Themes
@section Пользовательские Темы

@cindex custom themes
  @dfn{Пользовательские темы} представляют собой наборы настроек, которые
  могут быть включены или отключены как единое целое.
  @xref{Custom Themes,,, emacs, The GNU Emacs Manual}.  Каждая такая тема
  определяется с помощью источника Emacs Lisp файла, который должен
  соответствовать правилам, описанным в этом разделе.  (Вместо того, чтобы
  писать Пользовательскую тему вручную, можно её создать с помощью
  Customize-подобного интерфейса;
  @pxref{Creating Custom Themes,,, emacs, The GNU Emacs Manual}.)

  Файл пользовательской темы должен быть назван @file{@var{foo}-theme.el},
  где @var{foo} - это название темы.  Первая форма Lisp в файле, должна быть
  вызовом @code{deftheme}, а последняя форма, должна быть вызовом
  @code{provide-theme}.

@defmac deftheme theme &optional doc
Макрос объявляет @var{theme} (символ) в качестве имени пользовательской темы.
Необязательный аргумент @var{doc} должен быть строкой, описывающей тему; Это
описание отображается, когда пользователь вызывает команду
@code{describe-theme} или набирает @kbd{?} в буфере @samp{*Custom Themes*}.

Использование двух специальных названия темы запрещены (их использование
приводит к ошибке): @code{user} является фиктивной темой, которая хранит
прямые настройки пользователя, и @code{changed} является фиктивной темой,
которая сохраняет изменения сделанные вне системы настройки.
@end defmac

@defmac provide-theme theme
Макрос объявляет, что тема, названная @var{theme} была полностью определена.
@end defmac

  Между @code{deftheme} и @code{provide-theme} располагаются Lisp формы,
  задающие настройки темы: как правило, вызовы
  @code{custom-theme-set-variables} и/или вызов
  @code{custom-theme-set-faces}.

@defun custom-theme-set-variables theme &rest args
Функция определяет настройки переменных Пользовательской темы @var{theme}.
@var{theme} должен быть символом.  Каждый аргумент в @var{args} должен быть
списком вида

@example
(@var{var} @var{expression} [@var{now} [@var{request} [@var{comment}]]])
@end example

@noindent
где элементы списка имеют то же значение, что и в
@code{custom-set-variables}.  @xref{Applying Customizations}.
@end defun

@defun custom-theme-set-faces theme &rest args
Функция определяет параметры визуализации Пользовательской темы @var{theme}.
@var{theme} должен быть символом.  Каждый аргумент в @var{args} должен быть
списком вида

@example
(@var{face} @var{spec} [@var{now} [@var{comment}]])
@end example

@noindent
где элементы списка имеют то же значение, как и в @code{custom-set-faces}.
@xref{Applying Customizations}.
@end defun

  В теории, файл темы может также содержать другие формы Lisp, которые будут
  оцениваться при загрузке темы, но это плохой вариант.  Для защиты от
  загрузки темы, содержащих вредоносный код, Emacs отображает исходный файл
  и запрашивает подтверждение от пользователя перед загрузкой любой ещё не
  встроенной темы.  Таким образом, темы обычно не проходят байт-компиляции и
  исходные файлы всегда имеют приоритет, когда Emacs ищет темы для загрузки.

  Следующие функции полезны программного включения и отключения темы:

@defun custom-theme-p theme
Функция возвращает значение не-@code{nil}, если @var{theme} (символ) является
именем пользовательской темы (то есть, настраиваемой темой, которая была
загружена в Emacs, не смотря на то, что включена тема или нет).  В противном
случае возвращается @code{nil}.
@end defun

@defvar custom-known-themes
Значение этой переменной представляет собой перечень тем, загруженных в
Emacs.  Каждая тема представлена ​​символом Lisp (именем темы).  Значение по
умолчанию этой переменной является список, содержащий две фиктивных темы:
@code{(user changed)}. @code{changed} тема хранит настройки, сделанные перед
любыми применяемыми пользовательскими темами (например, переменные,
установленные за пределами системы Настройки).  @code{user} тема хранит
настройки пользователя, которые он настроил и сохранил.  Любые дополнительные
темы, объявленные с @code{deftheme} макросом, добавляются в передней части
этого списка.
@end defvar

@deffn Command load-theme theme &optional no-confirm no-enable
Функция загружает пользовательскую тему с именем @var{theme} из исходного
файла, ищет исходный файл в каталогах, указанных в переменной
@code{custom-theme-load-path}.  @xref{Custom Themes,,, emacs, The GNU Emacs Manual}.  Также @dfn{включает} тему (если дополнительный аргумент
@var{no-enable} не не-@code{nil}), в результате чего настройки переменных и
визуализаций вступают в силу.  Запрашивает у пользователя подтверждение перед
загрузкой темы, если необязательный аргумент @var{no-confirm} установлен в
не не-@code{nil}.
@end deffn

@deffn Command enable-theme theme
Функция загружает Пользовательскую тему с именем @var{theme}.  Это
сигнализирует об ошибке, если не была загружена такая тема.
@end deffn

@deffn Command disable-theme theme
Функция отключает Пользовательскую тему с именем @var{theme}.  Тема остаётся
загруженной, так что последующий вызов @code{enable-theme} повторно включит
её.
@end deffn
