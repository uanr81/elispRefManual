@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2019 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Modes
@chapter Основные и Дополнительные режимы
@cindex mode

  @dfn{Режим} - это набор определений, которые полезными способами
настраивают поведение Emacs.  Есть две разновидности режимов:
@dfn{основной режим}, предоставляет функции, которые пользователи могут
включать и выключать во время редактирования; и @dfn{дополнительный режим},
используется для редактирования или взаимодействия с определенным типом
текста.  Каждый буфер имеет ровно один @dfn{основной режим} за раз.

  В этой главе описывается, как писать как основной, так и вспомогательный
режимы, как указывать их в строке режима и как они запускают обработчики,
предоставленные пользователем.  Для связанных тем, таких как карты ключей и
синтаксические таблицы, смотреть @ref{Keymaps}, и @ref{Syntax Tables}.

@menu
* Hooks::             Как пользоваться перехватчиками; как написать код,
который предоставляет ловушки.
* Major Modes::       Определение основных режимов.
* Minor Modes::       Определение второстепенных режимов.
* Mode Line Format::  Настройка текста, отображаемого в строке режима.
* Imenu::             Предоставление меню определений, сделанных в буфере.
* Font Lock Mode::    Как режимы могут выделять текст в соответствии с
синтаксисом.
* Auto-Indentation::  Как научить Emacs делать отступ для основного режима.
* Desktop Save Mode:: Как режимы могут сохранять состояние буфера между
сеансами Emacs.
@end menu

@node Hooks
@section Ловушки
@cindex hooks

  @dfn{Ловушка} - это переменная, в которой можно сохранить функцию или
функции, которые будут вызываться в конкретном случае существующей
программой.  Emacs предоставляет ловушки для настройки.  Чаще всего
настраиваются в файле инициализации (@pxref{Init File}), но программы Lisp
также могут их устанавливать.  @xref{Standard Hooks} - список некоторых
стандартных переменных ловушки.

@cindex normal hook
  Большинство ловушек в Emacs - это @dfn{стандартные ловушки}.  Эти
переменные содержат списки функций, которые должны быть вызваны без
аргументов.  По соглашению, всякий раз, когда имя ловушки заканчивается на
@samp{-hook}, это означает, что это стандартная ловушка.  Проявляется
старание сделать все ловушки максимально стандартными, чтобы можно было
использовать их единообразно.

  Предполагается, что каждая команда основного режима запускает обычный
обработчик, называемый @dfn{ловушка режима}, в качестве одного из последних
шагов инициализации.  Это упрощает пользователю настройку поведения режима
путем переопределения назначений локальных переменных буфера, уже сделанных
режимом.  Большинство второстепенных функций режима также запускают в конце
обработчик режима.  Но ловушки используются и в других контекстах.
Например, ловушка @code{suspend-hook} запускается непосредственно перед тем,
как Emacs приостанавливает свою работу (@pxref{Suspending Emacs}).

  Рекомендуемый способ добавить функцию перехвата в перехватчик - вызвать
@code{add-hook} (@pxref{Setting Hooks}).  Функции ловушки могут быть любыми
из допустимых типов функций, которые @code{funcall} принимает
(@pxref{What Is a Function}).  Большинство обычных переменных-ловушек
изначально недействительны; @code{add-hook} знает, как с этим бороться.
Можноете добавить ловушки глобально или локально в буфере с помощью
@code{add-hook}.

@cindex abnormal hook
  Если имя переменной ловушки не заканчивается на @samp{-hook}, это
означает, что, вероятно, это @dfn{ненормальная ловушка}.  Это означает, что
функции-перехватчики вызываются с аргументами или каким-то образом
используются их возвращаемые значения.  Документация ловушки говорит, как
вызываются функции.  Можно использовать @code{add-hook} для добавления
функции к ненормальной ловушке, но потребуется написать функцию, чтобы
следовать соглашению о вызове ловушки.  По соглашению, имена ненормальных
ловушек заканчиваются на @samp{-functions}.

@cindex single-function hook
Если имя переменной заканчивается на @samp{-function}, то ее значение - это
просто одна функция, а не список функций.  @code{add-hook} нельзя
использовать для изменения такой @emph{однофункциональной ловушки}, и
потребуется использовать @code{add-function} вместо
(@pxref{Advising Functions}).

@menu
* Running Hooks::    Как запустить ловушку.
* Setting Hooks::    Как поставить функции в ловушки или убрать их.
@end menu

@node Running Hooks
@subsection Запуск Ловушки

  В этом разделе документируется функция @code{run-hooks}, которая
используется для запуска обычной ловушки.  Также документируется функция для
запуска различных видов ненормальных ловушек.

@defun run-hooks &rest hookvars
Функция принимает в качестве аргументов одно или несколько обычных имен
переменных ловушки и запускает каждую ловушку по очереди.  Каждый аргумент
должен быть символом, который является обычной переменной ловушки.  Эти
аргументы обрабатываются в указанном порядке.

Если переменная-ловушка имеет значение не-@code{nil}, это значение должно
быть списком функций.  @code{run-hooks} вызывает все функции одну за другой
без аргументов.

Значение переменной ловушки также может быть одной функцией - либо
лямбда-выражением, либо символом с определением функции, - которую вызывает
@code{run-hooks}.  Но это использование устарело.

Если переменная-ловушка является локальной в буфере, вместо глобальной будет
использоваться переменная, локальная в буфере.  Однако, если локальная
переменная буфера содержит элемент @code{t}, глобальная переменная ловушки
также будет запущена.
@end defun

@defun run-hook-with-args hook &rest args
Эта функция запускает ненормальную ловушку, вызывая все функции ловушки в
@var{hook}, передавая каждой из аргументов @var{args}.
@end defun

@defun run-hook-with-args-until-failure hook &rest args
Функция запускает ненормальную ловушку, вызывая каждую функцию ловушки по
очереди, останавливаясь, если одна из них не работает, возвращая @code{nil}.
Каждой функции ловушки передаются аргументы @var{args}.  Если эта функция
останавливается из-за сбоя одной из функций ловушки, она возвращает
@code{nil}; в противном случае возвращается значение не-@code{nil}.
@end defun

@defun run-hook-with-args-until-success hook &rest args
Функция запускает ненормальную ловушку, вызывая каждую функцию ловушки,
останавливаясь, если одна из них преуспевает, возвращая значение
не-@code{nil}.  Каждой функции ловушки передаются аргументы @var{args}.
Если эта функция останавливается, потому что одна из функций ловушки
возвращает значение не-@code{nil}, она возвращает это значение; в противном
случае возвращается @code{nil}.
@end defun

@node Setting Hooks
@subsection Настройка Ловушек

  Вот пример, который использует обработчик режима для включения режима
Auto Fill в режиме Lisp Interaction:

@example
(add-hook 'lisp-interaction-mode-hook 'auto-fill-mode)
@end example

@defun add-hook hook function &optional append local
Эта функция - удобный способ добавить функцию @var{function} к переменной
@var{hook}.  Можно использовать её как для ненормальных, так и для обычных
ловушек.  @var{function} может быть любой функцией Lisp, которая может
принимать правильное количество аргументов для @var{hook}.  Например,

@example
(add-hook 'text-mode-hook 'my-text-hook-function)
@end example

@noindent
добавляет @code{my-text-hook-function} к ловушке @code{text-mode-hook}.
Если @var{function} уже присутствует в @var{hook} (сравнение с
использованием @code{equal}), то @code{add-hook} не добавляет его второй
раз.

Если @var{function} имеет свойство не-@code{nil}
@code{permanent-local-hook}, то @code{kill-all-local-variables} (или
изменение основных режимов) не удалит её из локального значения переменной
ловушки.

Для обычной ловушки функции ловушки должны быть спроектированы так, чтобы
порядок их выполнения не имел значения.  Любая зависимость от порядка
порождает неприятности.  Однако порядок предсказуем: обычно @var{function}
идет в начале списка ловушек, поэтому она выполняется первой (за исключением
другого вызова @code{add-hook}).  Если необязательный аргумент @var{append}
- не-@code{nil}, новая функция ловушки идет в конец списка ловушек и
выполняется последней.

@code{add-hook} может обрабатывать случаи, когда @var{hook} недействителен
или её значение является единственной функцией; она устанавливает или
изменяет значение списка функций.

Если @var{local} равен не-@code{nil}, это говорит о добавлении
@var{function} в список локальных ловушек буфера, а не в глобальный список
ловушек.  Это делает перехватчик буфера локальным и добавляет @code{t} к
локальному значению буфера.  Последний действует как флаг для запуска
функций ловушки в значении по умолчанию, а также в локальном значении.
@end defun

@defun remove-hook hook function &optional local
Функция удаляет @var{function} из переменной ловушки @var{hook}.  Сравнивает
@var{function} с элементами @var{hook} с помощью @code{equal}, поэтому
работает как для символов, так и для лямбда-выражений.

Если @var{local} равен не-@code{nil}, это говорит об удалении @var{function}
из списка локальных ловушек, а не из глобального списка ловушек.
@end defun

@node Major Modes
@section Основной Режим
@cindex major mode

@cindex major mode command
  Основные режимы специализируются на Emacs для редактирования или
взаимодействия с определенными типами текста.  У каждого буфера одновременно
есть ровно один основной режим.  Каждый основной режим связан с
@dfn{командами основного режима}, имя которого должно заканчиваться на
@samp{-mode}.  Эта команда заботится о переключении в этот режим в текущем
буфере, устанавливая различные локальные переменные буфера, такие как
локальная карта ключей.  @xref{Major Mode Conventions}.  Обратить внимание,
что в отличие от второстепенных режимов нет возможности ``выключения''
основного режима, вместо этого буфер должен быть переключен на другой.

  Наименее специализированный основной режим называется
@dfn{Fundamental mode}, он не имеет специфических для режима определений или
настроек переменных.

@deffn Command fundamental-mode
Это основная режимная команда для основного режима.  В отличие от других
команд режима, @emph{не} запускает любые обработчики режима
(@pxref{Major Mode Conventions}), так как не нужно настраивать этот режим.
@end deffn

  Самый простой способ написать основной режим - использовать макрос
@code{define-derived-mode}, который устанавливает новый режим как вариант
существующего основного режима.  @xref{Derived Modes}.  Рекомендуется
использовать @code{define-derived-mode}, даже если новый режим не является
очевидным производным от другого режима, поскольку он автоматически
обеспечивает соблюдение многих соглашений о кодировании.
@xref{Basic Major Modes}, для получения общих режимов.

  Стандартное дерево каталогов GNU Emacs Lisp содержит код для нескольких
основных режимов в таких файлах, как @file{text-mode.el}, @file{texinfo.el},
@file{lisp-mode.el} и @file{rmail.el}.  Можете изучить эти библиотеки, чтобы
увидеть, как пишутся режимы.

@defopt major-mode
Локальное в буфере значение этой переменной содержит символ текущего
основного режима.  Его значение по умолчанию содержит основной режим по
умолчанию для новых буферов.  Стандартное значение по умолчанию -
@code{fundamental-mode}.

Если значение по умолчанию - @code{nil}, то всякий раз, когда Emacs создает
новый буфер с помощью такой команды, как @kbd{C-x b}
(@code{switch-to-buffer}), новый буфер помещается в основной режим
предыдущего текущего буфера.  В качестве исключения, если основной режим
предыдущего буфера имеет свойство символа @code{mode-class} со значением
@code{special}, новый буфер переводится в основной режим
(@pxref{Major Mode Conventions}).
@end defopt

@menu
* Major Mode Conventions:: Соглашения о кодировании для ключевых карт и т.д.
* Auto Major Mode::         Как Emacs автоматически выбирает основной режим.
* Mode Help::               Узнаем, как использовать режим.
* Derived Modes::           Определение нового основного режима на основе
                                 другого основного режима.
* Basic Major Modes::     Режимы, из которых часто происходят другие режимы.
* Mode Hooks::          Ловушки запускаются в конце основных функций режима.
* Tabulated List Mode:: Родительский режим для буферов, содержащих
                                 табличные данные.
* Generic Modes::           Определение простого основного режима, который
                                 поддерживает синтаксис комментариев и
                                 режим Font Lock.
* Example Major Modes::     Текстовый режим и режимы Lisp.
@end menu

@node Major Mode Conventions
@subsection Условные Обозначения Рсновного Режима
@cindex major mode conventions
@cindex conventions for writing major modes

  Код для каждого основного режима должен соответствовать различным
соглашениям о кодировании, включая соглашения для локальной ключевой карты
и инициализации таблицы синтаксиса, имен функций, переменных и ловушек.

  Если используется макрос @code{define-derived-mode}, он автоматически
позаботится о многих из этих соглашений.  @xref{Derived Modes}.  Также
обратить внимание, что режим Fundamental является исключением из многих этих
соглашений, поскольку он представляет состояние Emacs по умолчанию.

  Следующий список условных обозначений является неполным.  Каждый основной
режим должен быть в целом согласован с другими основными режимами Emacs, так
как это делает Emacs в целом более согласованным.  Здесь невозможно
перечислить все возможные моменты, по которым может возникнуть эта проблема;
если разработчики Emacs указывают на область, в которой основной режим
отличается от обычных соглашений, пожалуйста, сделайте его совместимым.

@itemize @bullet
@item
Определить команду основного режима, имя которой заканчивается на
@samp{-mode}.  При вызове без аргументов эта команда должна переключиться в
новый режим в текущем буфере, установив ключевую карту, таблицу синтаксиса и
локальные переменные буфера в существующем буфере.  Это не должно изменять
содержимое буфера.

@item
Написать строку документации для этой команды, которая описывает специальные
команды, доступные в этом режиме.  @xref{Mode Help}.

Строка документации может включать специальные подстроки документации,
@samp{\[@var{command}]}, @samp{\@{@var{keymap}@}} и @samp{\<@var{keymap}>},
которые позволяют отображению справки автоматически адаптироваться к
собственным привязкам ключей пользователя.  @xref{Keys in Documentation}.

@item
Команда основного режима должна начинаться с вызова
@code{kill-all-local-variables}.  Это запускает обычный обработчик
@code{change-major-mode-hook}, а затем избавляется от локальных в буфере
переменных основного режима, который ранее действовал.
@xref{Creating Buffer-Local}.

@item
Команда основного режима должна установить переменную @code{major-mode} как
символ команды основного режима.  Вот так @code{describe-mode} обнаруживает,
какую документацию печатать.

@item
Команда основного режима должна установить для переменной @code{mode-name}
имя режима, ``достаточно'' обычно строку (но другие возможные формы смотреть
в @ref{Mode Line Data}).  Название режима отображается в строке режима.

@item
Вызов команды основного режима дважды подряд не должен давать сбоев и должен
делать то же самое, что и вызов команды только один раз.  Другими словами,
команда основного режима должна быть идемпотентной.

@item
@cindex functions in modes
Поскольку все глобальные имена находятся в одном пространстве имен, все
глобальные переменные, константы и функции, которые являются частью режима,
должны иметь имена, начинающиеся с основного имени режима (или с его
аббревиатуры, если имя длинное).  @xref{Coding Conventions}.

@item
В основном режиме для редактирования какого-либо структурированного текста,
такого как язык программирования, возможно, будет полезен отступ текста в
соответствии со структурой.  Таким образом, режим должен установить
@code{indent-line-function} на подходящую функцию и, возможно, настроить
другие переменные для отступов.  @xref{Auto-Indentation}.

@item
@cindex keymaps in modes
Основной режим обычно должен иметь свою собственную ключевую карту, которая
используется как локальная ключевая карта во всех буферах в этом режиме.
Команда основного режима должна вызвать @code{use-local-map} для установки
этой локальной карты.  @xref{Active Keymaps}, для получения дополнительной
информации.

Эта карта должна постоянно храниться в глобальной переменной с именем
@code{@var{modename}-mode-map}.  Обычно эту переменную устанавливает
библиотека, определяющая режим.

@xref{Tips for Defining}, совет о том, как написать код для установки
переменной карты режима.

@item
Последовательности ключей, связанные в карте ключей основного режима, обычно
должны начинаться с @kbd{C-c}, за которым следует управляющий символ, цифра,
@kbd{@{}, @kbd{@}}, @kbd{<}, @kbd{>}, @kbd{:} или @kbd{;}. Остальные знаки
пунктуации зарезервированы для второстепенных режимов, а обычные буквы
зарезервированы для пользователей.

Основной режим также может повторно привязать ключи @kbd{M-n}, @kbd{M-p} и
@kbd{M-s}.  Привязки для @kbd{M-n} и @kbd{M-p} обычно должны быть своего
рода движением вперед и назад, но это не обязательно означает движение
курсора.

Для основного режима допустимо повторное связывание стандартной
последовательности ключей, если он предоставляет команду, которая выполняет
ту же работу способом, более подходящим для текста, для которого
используется этот режим.  Например, основной режим редактирования языка
программирования может переопределить @kbd{C-M-a}, чтобы перейти к началу
функции способом, который лучше подходит для этого языка.  Рекомендуемый
способ адаптации @kbd{C-M-a} к потребностям основного режима - установить
@code{beginning-of-defun-function} (@pxref{List Motion}) для вызова функции,
специфичной для этого режима.

Для основного режима также допустимо повторное связывание стандартной
последовательности ключей, стандартное значение которой редко используется в
этом режиме.  Например, режимы минибуфера повторно связывают @kbd{M-r},
стандартное значение которого редко используется в минибуфере.  Основные
режимы, такие как Dired или Rmail, которые не позволяют вставлять текст
самостоятельно, могут разумно переопределить буквы и другие печатные символы
как специальные команды.

@item
Основные режимы редактирования текста не должны определять @key{RET} для
выполнения чего-либо, кроме вставки новой строки.  Однако в
специализированных режимах для текста, которые пользователи не редактируют
напрямую, таких как режимы Dired и Info, можно переопределить @key{RET} для
выполнения чего-то совершенно другого.

@item
Основные режимы не должны изменять параметры, которые в первую очередь
зависят от предпочтений пользователя, например, включен ли режим Auto-Fill.
Оставить это на усмотрение каждого пользователя.  Однако основной режим
должен настраивать другие переменные, чтобы режим Auto-Fill работал с
пользой, @emph{если} пользователь решит его использовать. 

@item
@cindex syntax tables in modes
Режим может иметь свою собственную таблицу синтаксиса или может использовать
её совместно с другими связанными режимами.  Если у него есть собственная
таблица синтаксиса, он должен сохранить ее в переменной с именем
@code{@var{modename}-mode-syntax-table}.  @xref{Syntax Tables}.

@item
Если режим обрабатывает язык, имеющий синтаксис для комментариев, он должен
установить переменные, которые определяют синтаксис комментария.
@xref{Options for Comments,, Options Controlling Comments, emacs, The GNU Emacs Manual}.

@item
@cindex abbrev tables in modes
Режим может иметь свою собственную таблицу сокращений или может
использоваться совместно с другими связанными режимами.  Если у него есть
своя собственная таблица сокращений, он должен сохранить ее в переменной с
именем @code{@var{modename}-mode-abbrev-table}.  Если команда основного
режима сама определяет какие-либо сокращения, она должна передать @code{t}
для аргумента @var{system-flag} в @code{define-abbrev}.
@xref{Defining Abbrevs}.

@item
Режим должен указывать, как делать выделение для режима Font Lock,
устанавливая локальное в буфере значение для переменной
@code{font-lock-defaults} (@pxref{Font Lock Mode}).

@item
Каждое лицо, определяемое режимом, должно, если возможно, наследовать
существующее лицо Emacs.  @xref{Basic Faces} и @ref{Faces for Font Lock}.

@item
Режим должен указывать, как Imenu должен находить определения или разделы
буфера, устанавливая локальное в буфере значение для переменной
@code{imenu-generic-expression}, для двух переменных
@code{imenu-prev-index-position-function} и
@code{imenu-extract-index-name-function} или для переменной
@code{imenu-create-index-function} (@pxref{Imenu}).

@item
Режим может указывать локальное значение для
@code{eldoc-documentation-function}, чтобы сообщить режиму ElDoc, как
обрабатывать этот режим.

@item
Режим может указывать, как заполнять различные ключевые слова, добавляя одну
или несколько локальных в буфере записей в специальный обработчик
@code{completion-at-point-functions}.  @xref{Completion in Buffers}.

@item
@cindex buffer-local variables in modes
Чтобы сделать локальную привязку к буферу для переменной настройки Emacs,
используйте @code{make-local-variable} в команде основного режима, а не
@code{make-variable-buffer-local}.  Последняя функция сделает переменную
локальной для каждого буфера, в котором она впоследствии будет установлена,
что повлияет на буферы, которые не используют этот режим.  Нежелательно,
чтобы режим имел такие глобальные эффекты.  @xref{Buffer-Local Variables}.

За редкими исключениями, единственный разумный способ использовать
@code{make-variable-buffer-local} в пакете Lisp - для переменной, которая
используется только внутри этого пакета.  Использование этого в переменной,
используемой другими пакетами, может помешать им.

@item
@cindex mode hook
@cindex major mode hook
Каждый основной режим должен иметь нормальную @dfn{ловушку режима} с именем
@code{@var{modename}-mode-hook}.  Последнее, что должна сделать основная
команда режима, - это вызвать @code{run-mode-hooks}.  Это запускает
нормальную ловушку @code{change-major-mode-after-body-hook}, ловушку
режима, функцию @code{hack-local-variables} (когда буфер обращается к
файлу), а затем нормальную ловушку @code{after-change-major-mode-hook}.
@xref{Mode Hooks}.

@item
Команда основного режима может начинаться с вызова какой-либо другой команды
основного режима (называемый @dfn{родительским режимом}), а затем изменять
некоторые настройки.  Режим, который делает это, называется
@dfn{производный режим}.  Рекомендуемый способ его определения -
использовать макрос @code{define-derived-mode}, но это не обязательно.
Такой режим должен вызывать команду родительского режима внутри формы
@code{delay-mode-hooks}.  (Использование @code{define-derived-mode} делает
это автоматически.)  @xref{Derived Modes} и @ref{Mode Hooks}.

@item
Если нужно сделать что-то особенное, если пользователь переключает буфер из
этого режима в любой другой основной режим, этот режим может установить
локальное значение буфера для @code{change-major-mode-hook}
(@pxref{Creating Buffer-Local}).

@item
Если этот режим подходит только для специально подготовленного текста,
созданного самим режимом (а не вводом пользователем с клавиатуры или с
помощью внешнего файла), тогда символ команды основного режима должен иметь
свойство с именем @code{mode-class} со значением @code{special}, помещается
следующее:

@kindex mode-class @r{(property)}
@cindex @code{special} modes
@example
(put 'funny-mode 'mode-class 'special)
@end example

@noindent
Это сообщает Emacs, что новые буферы, созданные, пока текущий буфер
находится в режиме Funny, не следует переводить в режим Funny, даже если
значение @code{major-mode} по умолчанию - @code{nil}.  По умолчанию значение
@code{nil} для @code{major-mode} означает использование основного режима
текущего буфера при создании новых буферов (@pxref{Auto Major Mode}), но с
такими режимами @code{special} вместо него используется режим Fundamental.
Такие режимы, как Dired, Rmail, и Buffer List, используют эту функцию.

Функция @code{view-buffer} не включает режим просмотра в буферах, чей класс
режима является особым, потому что такие режимы обычно предоставляют свои
собственные привязки, подобные View.

Макрос @code{define-derived-mode} автоматически помечает производный режим
как особый, если родительский режим особенный.  Специальный режим является
удобным родительским элементом для наследования таких режимов;
@xref{Basic Major Modes}.

@item
Если потребуется сделать новый режим по умолчанию для файлов с определенными
узнаваемыми именами, добавляется элемент в @code{auto-mode-alist}, чтобы
выбрать режим для этих имен файлов (@pxref{Auto Major Mode}).  Если
определяется команда режима для автозагрузки, потребуется добавить этот
элемент в тот же файл, который вызывает @code{autoload}.  Если используется
cookie автозагрузки для команды режима, также возможно использовать cookie
автозагрузки для формы, которая добавляет элемент (@pxref{autoload cookie}).
Если не загружается команда режима автоматически, достаточно добавить
элемент в файл, содержащий определение режима.

@item
@cindex mode loading
Формы верхнего уровня в файле, определяющие режим, должны быть написаны так,
чтобы их можно было оценивать более одного раза без неблагоприятных
последствий.  Например, используется @code{defvar} или @code{defcustom} для
установки переменных, связанных с режимом, чтобы они не
переинициализировались, если они уже имеют значение
(@pxref{Defining Variables}).

@end itemize

@node Auto Major Mode
@subsection Как Emacs Выбирает Основной Режим
@cindex major mode, automatic selection

  Когда Emacs посещает файл, он автоматически выбирает основной режим для
буфера на основе информации в имени файла или в самом файле.  Он также
обрабатывает локальные переменные, указанные в тексте файла.

@deffn Command normal-mode &optional find-file
Функция устанавливает правильный основной режим и привязки переменных к
локальному буферу для текущего буфера.  Она вызывает @code{set-auto-mode}
(смотреть ниже).  Начиная с Emacs 26.1, больше не запускается
@code{hack-local-variables}, теперь это делается в @code{run-mode-hooks} при
инициализации основных режимов (@pxref{Mode Hooks}).

Если аргумент @var{find-file} для @code{normal-mode} равен не-@code{nil},
@code{normal-mode}, предполагается, что его вызывает функция
@code{find-file}.  В этом случае он может обрабатывать локальные переменные
в строке @samp{-*-} или в конце файла.  Переменная
@code{enable-local-variables} определяет, нужно ли это делать.
@xref{File Variables, , Local Variables in Files, emacs, The GNU Emacs Manual},
для синтаксиса раздела локальных переменных файла.

Если запускается @code{normal-mode} в интерактивном режиме, аргумент
@var{find-file} обычно имеет вид @code{nil}.  В этом случае
@code{normal-mode} безоговорочно обрабатывает любые локальные переменные
файла.

Функция вызывает @code{set-auto-mode} для выбора и установки основного
режима.  Если здесь не указан режим, буфер остается в основном режиме,
определяемом значением по умолчанию @code{major-mode} (смотреть ниже).

@cindex file mode specification error
@code{normal-mode} использует @code{condition-case} вокруг вызова команды
основного режима, поэтому ошибки выявляются и сообщаются как
@samp{File mode specification error}, за которым следует исходное сообщение
об ошибке.
@end deffn

@defun set-auto-mode &optional keep-mode-if-same
@cindex visited file mode
  Функция выбирает и устанавливает основной режим, подходящий для текущего
буфера.  Она основывает свое решение (в порядке приоритета) на строке
@w{@samp{-*-}}, на любой локальной переменной @samp{mode:} рядом с концом
файла, на строке @w{@samp{#!}} (используя @code{interpreter-mode-alist}),
на тексте в начале буфера (используя @code{magic-mode-alist}), и, наконец,
по имени посещенного файла (используя @code{auto-mode-alist}).
@xref{Choosing Modes, , How Major Modes are Chosen, emacs, The GNU Emacs Manual}.
Если @code{enable-local-variables} равен @code{nil}, @code{set-auto-mode} не
проверяет строку @w{@samp{-*-}} или около конца файла на наличие тегов
режима.

@vindex inhibit-local-variables-regexps
Существуют некоторые типы файлов, в которых нецелесообразно сканировать
содержимое файла на предмет определения режима.  Например, tar-архив может
содержать ближе к концу файла файл-член, в котором есть секция локальных
переменных, определяющая режим для этого конкретного файла.  Это не должно
применяться к содержащему tar-файлу.  Точно так же файл изображения tiff
может просто содержать первую строку, которая, кажется, соответствует
шаблону @w{@samp{-*-}}.  По этим причинам оба этих расширения файлов входят
в список @code{inhibit-local-variables-regexps}.  Следует добавить шаблоны в
этот список, чтобы Emacs не искал в них локальные переменные любого типа (а
не только спецификаторы режима).

Если @var{keep-mode-if-same} равен не-@code{nil}, эта функция не вызывает
команду режима, если буфер уже находится в правильном основном режиме.
Например, @code{set-visited-file-name} устанавливает это значение в
@code{t}, чтобы избежать уничтожения локальных переменных буфера, которые
мог установить пользователь.
@end defun

@defun set-buffer-major-mode buffer
Функция устанавливает для основного режима @var{buffer} значение по
умолчанию @code{major-mode}; если это @code{nil}, она использует основной
режим текущего буфера (если это подходит).  В виде исключения, если имя
@var{buffer} - @file{*scratch*}, устанавливается режим
@code{initial-major-mode}.

Примитивы низкого уровня для создания буферов не используют эту функцию, но
команды среднего уровня, такие как @code{switch-to-buffer} и
@code{find-file-noselect}, используют ее всякий раз, когда они создают
буферы.
@end defun

@defopt initial-major-mode
@cindex @file{*scratch*}
Значение этой переменной определяет основной режим начального буфера
@file{*scratch*}.  Значение должно быть символом, который является командой
основного режима.  Значение по умолчанию - @code{lisp-interaction-mode}.
@end defopt

@defvar interpreter-mode-alist
Эта переменная определяет основные режимы для использования в сценариях,  которые указывают интерпретатор команд в строке @samp{#!}.  Его значение -
список с элементами вида @code{(@var{regexp} . @var{mode})}; это говорит об
использовании режима @var{mode}, если в файле указан интерпретатор,
соответствующий @code{\`@var{regexp}\'}.  Например, одним из элементов по
умолчанию является @code{("python[0-9.]*" . python-mode)}.
@end defvar

@defvar magic-mode-alist
Значение этой переменной представляет собой список с элементами вида
@code{(@var{regexp} .  @var{function})}, где @var{regexp} - регулярное
выражение, а @var{function} - функция или @code{nil}.  После посещения файла
@code{set-auto-mode} вызывает @var{function}, если текст в начале буфера
совпадает с @var{regexp} и @var{function}, не-@code{nil}; если
@var{function} равен @code{nil}, @code{auto-mode-alist} выбирает режим.
@end defvar

@defvar magic-fallback-mode-alist
Это работает как @code{magic-mode-alist}, за исключением того, что
обрабатывается, только если @code{auto-mode-alist} не указывает режим для
этого файла.
@end defvar

@defvar auto-mode-alist
Эта переменная содержит список ассоциаций шаблонов имен файлов (регулярных
выражений) и соответствующих команд основного режима.  Обычно шаблоны имен
файлов проверяют наличие суффиксов, таких как @samp{.el} и @samp{.c}, но это
не обязательно.  Обычно элемент списка выглядит как
@code{(@var{regexp} .  @var{mode-function})}.

Например,

@smallexample
@group
(("\\`/tmp/fol/" . text-mode)
 ("\\.texinfo\\'" . texinfo-mode)
 ("\\.texi\\'" . texinfo-mode)
@end group
@group
 ("\\.el\\'" . emacs-lisp-mode)
 ("\\.c\\'" . c-mode)
 ("\\.h\\'" . c-mode)
 @dots{})
@end group
@end smallexample

Когда посещается файл, расширенное имя которого
(@pxref{File Name Expansion}) с номерами версий и суффиксами резервных
копий, удаленными с помощью @code{file-name-sans-versions}
(@pxref{File Name Components}), совпадает с @var{regexp},
@code{set-auto-mode} вызывает соответствующий @var{mode-function}.  Эта
функция позволяет Emacs выбрать правильный основной режим для большинства
файлов.

Если элемент @code{auto-mode-alist} имеет форму
@code{(@var{regexp} @var{function} t)}, то после вызова @var{function} Emacs
снова ищет в @code{auto-mode-alist} совпадение с частью имени файла, которая
не совпадала ранее.  Эта функция полезна для пакетов без сжатия: запись в
форме @code{("\.gz\'" @var{function} t)} может распаковать файл, а затем
поместить несжатый файл в соответствующий режим в соответствии с именем
sans @samp{.gz}.

Вот пример того, как добавить несколько пар шаблонов к
@code{auto-mode-alist}.  (Вы можете использовать такое выражение в своем
файле инициализации.)

@smallexample
@group
(setq auto-mode-alist
  (append
   ;; @r{Имя файла (в каталоге) начинается с точки.}
   '(("/\\.[^/]*\\'" . fundamental-mode)
     ;; @r{В имени файла нет точки.}
     ("/[^\\./]*\\'" . fundamental-mode)
     ;; @r{Имя файла заканчивается на @samp{.C}.}
     ("\\.C\\'" . c++-mode))
   auto-mode-alist))
@end group
@end smallexample
@end defvar

@node Mode Help
@subsection Получение Справки по Основному Режиму
@cindex mode help
@cindex help for major mode
@cindex documentation for major mode

  Функция @code{describe-mode} предоставляет информацию об основных режимах.
Обычно привязана к @kbd{C-h m}.  Использует значение переменной
@code{major-mode} (@pxref{Major Modes}), поэтому каждая команда основного
режима должна устанавливать эту переменную.

@deffn Command describe-mode &optional buffer
Команда отображает документацию по основному режиму и второстепенным режимам
текущего буфера.  Использует функцию @code{documentation} для получения
строк документации команд основного и второстепенного режима
(@pxref{Accessing Documentation}).

Если эта функция вызывается из Lisp с аргументом не-@code{nil} @var{buffer},
эта функция отображает документацию для основного и второстепенного режимов
этого буфера, а не для текущего буфера.
@end deffn

@node Derived Modes
@subsection Определение Производных Режимов
@cindex derived mode

  Рекомендуемый способ определения нового основного режима - это
унаследовать его от существующего с помощью @code{define-derived-mode}.
Если тесно связанного режима нет, потребуется унаследовать от
@code{text-mode}, @code{special-mode} или @code{prog-mode}.
@xref{Basic Major Modes}.  Если ни один из них не подходит, можно
унаследовать от @code{fundamental-mode} (@pxref{Major Modes}).

@defmac define-derived-mode variant parent name docstring keyword-args@dots{} body@dots{}
Этот макрос определяет @var{variant} как команду основного режима, используя
@var{name} как строковую форму имени режима.  @var{variant} и @var{parent}
должен быть символами без кавычек.

Новая команда @var{variant} определена для вызова функции @var{parent}, а
затем переопределения определенных аспектов этого родительского режима:

@itemize @bullet
@item
В новом режиме есть собственная разреженная ключевая карта с именем
@code{@var{variant}-map}.  @code{define-derived-mode} делает карту
родительского режима родителем новой карты, если @code{@var{variant}-map}
ещё не установлено и уже есть родитель.

@item
Новый режим имеет свою собственную таблицу синтаксиса, хранящуюся в
переменной @code{@var{variant}-syntax-table}, если не переопределятся это с
помощью ключевого слова @code{:syntax-table} (смотреть ниже).
@code{define-derived-mode} делает таблицу синтаксиса родительского режима
родительской для @code{@var{variant}-syntax-table}, если последняя ещё не
установлена и уже имеется родительский элемент, отличный от стандартной
таблицы синтаксиса.

@item
В новом режиме есть своя собственная таблица сокращений, хранящаяся в
переменной @code{@var{variant}-abbrev-table}, если не переопределено это с
помощью ключевого слова @code{:abbrev-table} (смотреть ниже).

@item
У нового режима есть свой собственный режим, @code{@var{variant}-hook}.
Запускает эту ловушку после запуска ловушек своих предшественников с
@code{run-mode-hooks}, как последнее, что делает, кроме запуска любой формы
@code{:after-hook}, которая имеется.  @xref{Mode Hooks}.
@end itemize

Кроме того, возможно указать, как переопределить другие аспекты @var{parent}
с помощью @var{body}.  Команда @var{variant} оценивает формы в @var{body}
после установки всех своих обычных переопределений, непосредственно перед
запуском обработчиков режима.

Если @var{parent} имеет свойство символа не-@code{nil} @code{mode-class},
тогда @code{define-derived-mode} устанавливает для свойства
@code{mode-class} объекта @var{variant} то же значение.  Это гарантирует,
например, что если @var{parent} является специальным режимом, то
@var{variant} также является специальным режимом
(@pxref{Major Mode Conventions}).

Также возможно указать @code{nil} для @var{parent}.  Это не дает новому
режиму родителя.  Тогда @code{define-derived-mode} ведет себя так, как
описано выше, но, разумеется, пропускает все действия, связанные с
@var{parent}.

Аргумент @var{docstring} указывает строку документации для нового режима.
@code{define-derived-mode} добавляет некоторую общую информацию о ловушке
режима, за которой следует ключевая карта режима, в конце этой строки
документации.  Если опускается @var{docstring}, @code{define-derived-mode}
сгенерирует строку документации.

@var{keyword-args} - это пары ключевых слов и значений.  Значения, кроме
@code{:after-hook}и, оцениваются.  Следующие ключевые слова в настоящее
время поддерживаются:

@table @code
@item :syntax-table
Можно использовать это, чтобы явно указать таблицу синтаксиса для нового
режима.  Если указывается значение @code{nil}, новый режим будет
использовать ту же таблицу синтаксиса, что и @var{parent}, или стандартную
таблицу синтаксиса, если @var{parent} - @code{nil}.  (Обратить внимание, что
при этом @emph{не} следует соглашению, используемому для аргументов без
ключевых слов, что значение @code{nil} эквивалентно без указания аргумента.)

@item :abbrev-table
Можно использовать это, чтобы явно указать таблицу сокращений для нового
режима.  Если указано значение @code{nil}, новый режим будет использовать
ту же таблицу сокращений, что и @var{parent} или
@code{fundamental-mode-abbrev-table}, если @var{parent} равен @code{nil}.
(Опять же, значение @code{nil} @emph{не} эквивалентно отсутствию указания
этого ключевого слова.).

@item :group
Если это указано, значение должно быть группой настройки для этого режима.
(Не во всех основных режимах он есть.)  Использует команда
@code{customize-mode}.  @code{define-derived-mode} действительно ли
@emph{не} автоматически определяет указанную группу настройки.

@item :after-hook
Это необязательное ключевое слово определяет единственную форму Lisp для
оценки как заключительное действие функции режима после того, как были
запущены перехватчики режима.  Его не следует цитировать.  Поскольку форма
может быть оценена после завершения функции режима, она не должна обращаться
ни к какому элементу локального состояния функции режима.  Форма
@code{:after-hook} полезна для настройки аспектов режима, которые зависят от
настроек пользователя, которые, в свою очередь, могли быть изменены в
ловушке режима.
@end table

Вот гипотетический пример:

@example
(defvar hypertext-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map [down-mouse-3] 'do-hyper-link)
    map))

(define-derived-mode hypertext-mode
  text-mode "Hypertext"
  "Основной режим для гипертекста."
  (setq-local case-fold-search nil))
@end example

Не пишисать спецификацию @code{interactive} в определении;
@code{define-derived-mode} делает это автоматически.
@end defmac

@defun derived-mode-p &rest modes
Эта функция возвращает не-@code{nil}, если текущий основной режим является
производным от любого из основных режимов, заданных символами @var{modes}.
@end defun

@node Basic Major Modes
@subsection Основа Основных Режимов

  Помимо основного режима, есть три основных режима, из которых обычно
происходят другие основные режимы: текстовый режим, режим программирования и
специальный режим.  Хотя текстовый режим полезен сам по себе (например, для
редактирования файлов, оканчивающихся на @file{.txt}), режим Prog и
специальный режим существуют в основном для того, чтобы другие режимы могли
быть производными от них.

@vindex prog-mode-hook
  Насколько это возможно, новые основные режимы должны происходить прямо или
косвенно от одного из этих трех режимов.  Одна из причин заключается в том,
что это позволяет пользователям настраивать обработчик одного режима
(например, @code{prog-mode-hook}) для целого семейства соответствующих
режимов (например, всех режимов языка программирования).

@deffn Command text-mode
Текстовый режим - это основной режим редактирования человеческих языков.
Определяет символы @samp{"} и @samp{\} как имеющие синтаксис пунктуации
(@pxref{Syntax Class Table}) и связывает @kbd{M-@key{TAB}} с
@code{ispell-complete-word}
(@pxref{Spelling,,, emacs, The GNU Emacs Manual}).

Примером основного режима, производного от текстового режима, является
режим HTML.
@xref{HTML Mode,,SGML and HTML Modes, emacs, The GNU Emacs Manual}.
@end deffn

@deffn Command prog-mode
Режим Prog - это основной основной режим для буферов, содержащих исходный
код языка программирования.  Большинство основных режимов языка
программирования, встроенных в Emacs, являются производными от него.

Prog mode привязывает @code{parse-sexp-ignore-comments} к @code{t},
(@pxref{Motion via Parsing})@code{bidi-paragraph-direction} и
@code{left-to-right} (@pxref{Bidirectional Display}).
@end deffn

@deffn Command special-mode
Специальный режим - это основной основной режим для буферов, содержащих
текст, который создается Emacs специально, а не непосредственно из файла.
Основные режимы, полученные из специального режима, получают свойство
@code{mode-class} для @code{special}.  (@pxref{Major Mode Conventions}).

Специальный режим устанавливает буфер только для чтения.  Его карта
определяет несколько общих привязок, включая @kbd{q} для @code{quit-window}
и @kbd{g} для @code{revert-buffer}.  (@pxref{Reverting}).

Примером основного режима, производного от специального режима, является
режим Buffer Menu, который используется буфером @file{*Buffer List*}.
@xref{List Buffers,,Listing Existing Buffers, emacs, The GNU Emacs Manual}.
@end deffn

  Кроме того, режимы для буферов табличных данных могут наследоваться от
режима Tabulated List, который, в свою очередь, является производным от
режима Special.  @xref{Tabulated List Mode}.

@node Mode Hooks
@subsection Ловушки Режимов

  Каждая основная команда режима должна заканчиваться запуском независимой
от режима обычной ловушки @code{change-major-mode-after-body-hook}, ловушки
режима и обычной ловушки @code{after-change-major-mode-hook}.  Для этого
вызывается @code{run-mode-hooks}.  Если основной режим является производным
режимом, то есть если вызывает другой основной режим (родительский режим) в
своем теле, должен делать это внутри @code{delay-mode-hooks}, чтобы
родительский объект сам не запускал эти ловушки.  Вместо этого вызов
@code{run-mode-hooks} производного режима также запускает обработчик
родительского режима.  @xref{Major Mode Conventions}.

  В версиях Emacs до Emacs 22 не было @code{delay-mode-hooks}.  Версии до 24
не имели @code{change-major-mode-after-body-hook}.  Когда основные режимы,
реализованные пользователем, не используют @code{run-mode-hooks} и не были
обновлены для использования этих новых функций, не будут полностью следовать
этим соглашениям: могут запустить обработчик родительского режима слишком
рано или не выполнить @code{after-change-major-mode-hook}.  Если столкнутся
с таким основным режимом, исправить его, чтобы следовать этим соглашениям.

  Когда определяется основной режим с помощью @code{define-derived-mode},
он автоматически обеспечивает соблюдение этих соглашений.  Если определяется
основной режим ``рукой'', не используя @code{define-derived-mode},
используются следующие функции для автоматической обработки этих соглашений.

@defun run-mode-hooks &rest hookvars
Основные режимы должны запускать свой обработчик режима, используя эту
функцию.  Похоже на @code{run-hooks} (@pxref{Hooks}), но также запускает
@code{change-major-mode-after-body-hook}, @code{hack-local-variables} (когда
буфер обращается к файлу) (@pxref{File Local Variables}) и
@code{after-change-major-mode-hook}.  Последнее, что делается, это
оцениваются любые формы @code{:after-hook}, объявленные родительскими
режимами (@pxref{Derived Modes}).

Когда функция вызывается во время выполнения формы @code{delay-mode-hooks},
она не запускает ловушки или @code{hack-local-variables} и не оценивает
формы немедленно.  Вместо этого организует следующий вызов
@code{run-mode-hooks} для их запуска.
@end defun

@defmac delay-mode-hooks body@dots{}
Когда одна команда основного режима вызывает другую, должно делаться это
внутри @code{delay-mode-hooks}.

Этот макрос выполняет @var{body}, но сообщает всем вызовам
@code{run-mode-hooks} во время выполнения @var{body} отложить запуск их
ловушек.  Перехватчики фактически сработают во время следующего вызова
@code{run-mode-hooks} после завершения конструкции @code{delay-mode-hooks}.
@end defmac

@defvar change-major-mode-after-body-hook
Это нормальная ловушка, запускаемая @code{run-mode-hooks}.  Запускается до
перехвата режима.
@end defvar

@defvar after-change-major-mode-hook
Это нормальная ловушка, запускаемая @code{run-mode-hooks}.  Запускается в
самом конце каждой правильно написанной команды основного режима.
@end defvar

@node Tabulated List Mode
@subsection Режим Табличного Списка
@cindex Tabulated List mode

  Режим табличного списка - это основной режим для отображения табличных
данных, то есть данных, состоящих из @dfn{записей}, каждая запись занимает
одну строку текста, а ее содержимое разделено на столбцы.  Режим табличного
списка предоставляет возможности для удобной печати строк и столбцов,
сортировки строк в соответствии со значениями в каждом столбце.  Получен из
специального режима (@pxref{Basic Major Modes}).

  Режим табличного списка предназначен для использования в качестве
родительского режима более специализированным основным режимом.  Примеры
включают режим Process Menu (@pxref{Process Information}) и режим Package
Menu (@pxref{Package Menu,,, emacs, The GNU Emacs Manual}).

@findex tabulated-list-mode
  Такой производный режим должен использовать @code{define-derived-mode}
обычным образом, задав @code{tabulated-list-mode} в качестве второго
аргумента (@pxref{Derived Modes}).  В теле формы @code{define-derived-mode}
должен быть указан формат табулированных данных путем присвоения значений
переменным, описанным ниже; при желании может затем вызвать функцию
@code{tabulated-list-init-header}, которая заполнит заголовок именами
столбцов.

  Производный режим также должен определять @dfn{перечисление команды}.  Это
то, что пользователь вызывает, а не команду режима (например,
@kbd{M-x list-processes}).  Команда листинга должна создать буфер или
переключиться на него, включить производный режим, указать табличные данные
и, наконец, вызвать @code{tabulated-list-print} для заполнения буфера.

@defvar tabulated-list-format
Эта локальная в буфере переменная определяет формат данных табличного
списка.  Её значение должно быть вектором.  Каждый элемент вектора
представляет собой столбец данных и должен быть списком
@code{(@var{name} @var{width} @var{sort})}, где

@itemize
@item
@var{name} - имя столбца (строка).

@item
@var{width} - ширина, зарезервированная для столбца (целое число).  Это
бессмысленно для последнего столбца, который идет до конца каждой строки.

@item
@var{sort} указывает, как сортировать записи по столбцу.  Если @code{nil},
столбец нельзя использовать для сортировки.  Если @code{t}, столбец
сортируется путем сравнения строковых значений.  В противном случае это
должна быть функция-предикат для @code{sort} (@pxref{Rearrangement}),
которая принимает два аргумента с той же формой, что и элементы
@code{tabulated-list-entries} (смотреть ниже).
@end itemize
@end defvar

@defvar tabulated-list-entries
Эта локальная в буфере переменная определяет записи, отображаемые в буфере
табличного списка.  Её значение должно быть либо списком, либо функцией.

Если значение является списком, каждый элемент списка соответствует одной
записи и должен иметь форму @w{@code{(@var{id} @var{contents})}}, где

@itemize
@item
@var{id} - это объект @code{nil} или Lisp, который идентифицирует запись.  В
последнем случае курсор остается на той же записи при повторной сортировке
записей.  Сравнение сделано с @code{equal}.

@item
@var{contents} - это вектор с тем же количеством элементов, что и
@code{tabulated-list-format}.  Каждый элемент вектора представляет собой
либо строку, которая вставляется в буфер как есть, либо список
@code{(@var{label} . @var{properties})}, что означает вставку текстовой
кнопки путем вызова @code{insert-text-button} с @var{label} и
@var{properties} в качестве аргументов (@pxref{Making Buttons}).

Ни в одной из этих строк не должно быть новых строк.
@end itemize

В противном случае значение должно быть функцией, которая возвращает список
приведенной выше формы при вызове без аргументов.
@end defvar

@defvar tabulated-list-revert-hook
Эта обычная ловушка запускается перед возвратом буфера табличного списка.
Производный режим может добавить к этой ловушке функцию для переоценки
@code{tabulated-list-entries}.
@end defvar

@defvar tabulated-list-printer
Значение этой переменной - это функция, вызываемая для вставки записи в
точку, включая ее завершающий символ новой строки.  Функция должна принимать
два аргумента @var{id} и @var{contents}, имеющих то же значение, что и в
@code{tabulated-list-entries}.  Значение по умолчанию - это функция, которая
просто вставляет запись; режим, который использует режим Tabulated List
(Табулированный Cписок) более сложным образом, может определять другую
функцию.
@end defvar

@defvar tabulated-list-sort-key
Значение этой переменной определяет текущий ключ сортировки для буфера
Tabulated List.  Если это @code{nil}, сортировка не производится.  В
противном случае должен иметься вид @code{(@var{name} . @var{flip})}, где
@var{name} - это строка, соответствующая одному из имен столбцов в
@code{tabulated-list-format}, а @var{flip}, если не-@code{nil}, означает
инвертировать порядок сортировки.
@end defvar

@defun tabulated-list-init-header
Эта функция вычисляет и устанавливает @code{header-line-format} для буфера
Tabulated List (@pxref{Header Lines}) и назначает ключеую карту строке
заголовка, чтобы разрешить сортировку записей, щелкая заголовки столбцов.

Режимы, производные от режима Tabulated List, должны вызывать это после
установки вышеуказанных переменных (в частности, только после установки
@code{tabulated-list-format}).
@end defun

@defun tabulated-list-print &optional remember-pos update
Эта функция заполняет текущий буфер записями.  Должна вызываться командой
листинга.  Стирается буфер, сортируются записи, указанные в
@code{tabulated-list-entries}, в соответствии с
@code{tabulated-list-sort-key}, затем вызывается функция, указанная в
@code{tabulated-list-printer}, для вставки каждой записи.

Если необязательный аргумент @var{remember-pos} - не-@code{nil}, функция
ищет элемент @var{id} в текущей строке, если таковой имеется, и пытается
перейти к этой записи после (повторной) вставки всех записей.

Если необязательный аргумент @var{update} - не-@code{nil}, функция удалит
или добавит только те записи, которые изменились с момента последней печати.
Это в несколько раз быстрее, если большинство записей не изменилось с
момента последнего вызова этой функции.  Единственная разница в результате
заключается в том, что теги, размещенные через
@code{tabulated-list-put-tag}, не будут удалены из записей, которые не
изменились (обычно удаляются все теги).
@end defun

@defun tabulated-list-delete-entry
Эта функция удаляет запись в точке.

Возвращает список @code{(@var{id} @var{cols})}, где @var{id} - ID удаленной
записи, а @var{cols} - это вектор ее дескрипторов столбца.  Перемещается
точка в начало текущей строки.  Возвращает @code{nil}, если в точке нет
записи.

Обратить внимание, что эта функция изменяет только содержимое буфера; это не
меняет @code{tabulated-list-entries}.
@end defun

@defun tabulated-list-get-id &optional pos
Этот @code{defsubst} возвращает объект ID из @code{tabulated-list-entries}
(если это список) или из списка, возвращаемого @code{tabulated-list-entries}
(если это функция).  Если опущено или @code{nil}, @var{pos} по умолчанию
указывает на точку.
@end defun

@defun tabulated-list-get-entry &optional pos
Этот @code{defsubst} возвращает объект записи из
@code{tabulated-list-entries} (если это список) или из списка, возвращаемого
@code{tabulated-list-entries} (если это функция).  Это будет вектор для
идентификатора в @var{pos}.  Если в @var{pos} нет записи, функция
возвращает @code{nil}.
@end defun

@vindex tabulated-list-use-header-line
@defun tabulated-list-header-overlay-p &optional POS
Этот @code{defsubst} возвращает не-nil, если в @var{pos} есть поддельный
заголовок.  Если @code{tabulated-list-use-header-line} равно @code{nil},
используется поддельный заголовок, чтобы поместить имена столбцов в начало
буфера.  Если опущено или @code{nil}, @var{pos} по умолчанию принимает
значение @code{point-min}.
@end defun

@vindex tabulated-list-padding
@defun tabulated-list-put-tag tag &optional advance
Эта функция помещает @var{tag} в область заполнения текущей строки.  Область
заполнения может быть пустым пространством в начале строки, ширина которого
определяется параметром @code{tabulated-list-padding}.  @var{tag} должен
быть строкой длиной меньше или равной @code{tabulated-list-padding}.  Если
@var{advance} равен не-nil, эта функция перемещает точку на одну строку.
@end defun

@defun tabulated-list-set-col col desc &optional change-entry-data
Эта функция изменяет запись табличного списка в точке, устанавливая
@var{col} на @var{desc}. @var{col} - это номер столбца, который нужно
изменить, или имя столбца, который нужно изменить.  @var{desc} - это новый
дескриптор столбца, который вставляется через
@code{tabulated-list-print-col}.

Если @var{change-entry-data} равен не-nil, эта функция изменяет базовые
данные (обычно дескриптор столбца в списке @code{tabulated-list-entries}),
устанавливая дескриптор столбца вектора на @code{desc}.
@end defun


@node Generic Modes
@subsection Общие Режимы
@cindex generic mode

  @dfn{Общие режимы} - простые основные режимы с базовой поддержкой
синтаксиса комментариев и режима Font Lock.  Чтобы определить общий режим,
используется макрос @code{define-generic-mode}.  В файле @file{generic-x.el}
приведены некоторые примеры использования @code{define-generic-mode}.

@defmac define-generic-mode mode comment-list keyword-list font-lock-list auto-mode-list function-list &optional docstring
Этот макрос определяет универсальную команду режима с именем @var{mode}
(символ, не заключенный в кавычки).  Необязательный аргумент @var{docstring}
- это документация для команды режима.  Если не предоставить,
@code{define-generic-mode} по умолчанию генерирует его.

Аргумент @var{comment-list} - это список, в котором каждый элемент является
либо символом, либо строкой из одного или двух символов, либо cons-ячейкой.
Символ или строка задаются в таблице синтаксиса режима как начало
комментария.  Если запись является cons-ячейкой, @sc{car} настраивается как
средство запуска комментария, а @sc{cdr} - как средство завершения
комментария.  (Используйте @code{nil} для последнего, если требуется, чтобы
комментарии заканчивались в конце строки.).  Обратить внимание, что механизм
таблицы синтаксиса имеет ограничения относительно того, какие начальные и
конечные элементы комментариев фактически возможны.  @xref{Syntax Tables}.

Аргумент @var{keyword-list} - это список ключевых слов, которые нужно
выделить с помощью @code{font-lock-keyword-face}.  Каждое ключевое слово
должно быть строкой.  Между тем, @var{font-lock-list} - это список
дополнительных выражений, которые нужно выделить.  Каждый элемент этого
списка должен иметь ту же форму, что и элемент @code{font-lock-keywords}.
@xref{Search-based Fontification}.

Аргумент @var{auto-mode-list} - это список регулярных выражений, которые
нужно добавить к переменной @code{auto-mode-alist}.  Добавляются при
выполнении формы @code{define-generic-mode}, а не при расширении вызова
макроса.

Наконец, @var{function-list} - это список функций, которые команда режима
вызывает для дополнительной настройки.  Ввызывает эти функции
непосредственно перед запуском переменной ловушки режима
@code{@var{mode}-hook}.
@end defmac

@node Example Major Modes
@subsection Примеры Основных Режимов

  Текстовый режим, пожалуй, самый простой режим, помимо режима Fundamental.
Вот отрывки из @file{text-mode.el}, которые иллюстрируют многие из
перечисленных выше соглашений:

@smallexample
@group
;; @r{Создайть таблицу синтаксиса для этого режима.}
(defvar text-mode-syntax-table
  (let ((st (make-syntax-table)))
    (modify-syntax-entry ?\" ".   " st)
    (modify-syntax-entry ?\\ ".   " st)
    ;; Добавьть 'p', чтобы M-c на 'hello' приводил к 'Hello', а не 'hello'.
    (modify-syntax-entry ?' "w p" st)
    @dots{}
    st)
  "Таблица синтаксиса, используемая в `text-mode'.")
@end group

;; @r{Создайть карту для этого режима.}
@group
(defvar text-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map "\e\t" 'ispell-complete-word)
    @dots{}
    map)
  "Ключевая карта для `text-mode'.
  Многие другие режимы, такие как `mail-mode', `outline-mode' и
  `indented-text-mode', наследуют все команды, определенные на этой карте.")
@end group
@end smallexample

  Вот как теперь определяется фактическая команда режима:

@smallexample
@group
(define-derived-mode text-mode nil "Text"
  "Основной режим редактирования текста, написанного для чтения людьми.
  В этом режиме абзацы разделяются только пустыми или белыми линиями.
  Таким образом, можно получить все преимущества адаптивного заполнения
  (смотреть переменную `adaptive-fill-mode').
  \\@{text-mode-map@}
  Включение текстового режима запускает обычную ловушку `text-mode-hook'."
@end group
@group
  (set (make-local-variable 'text-mode-variant) t)
  (set (make-local-variable 'require-final-newline)
       mode-require-final-newline)
  (set (make-local-variable 'indent-line-function) 'indent-relative))
@end group
@end smallexample

@noindent
(Последняя строка в настоящее время избыточна, поскольку
@code{indent-relative} является значением по умолчанию, и удалена в
будущей версии.)

@cindex @file{lisp-mode.el}
  Три режима Lisp (режим Lisp, режим Emacs Lisp и режим Lisp Interaction)
имеют больше возможностей, чем режим Text, и, соответственно, код более
сложен.  Вот отрывки из @file{lisp-mode.el}, которые иллюстрируют, как
написаны эти режимы.

  Вот как определяются синтаксис режима Lisp и таблицы сокращений:

@cindex syntax table example
@smallexample
@group
;; @r{Создание переменных таблицы для конкретного режима.}
(define-abbrev-table 'lisp-mode-abbrev-table ()
  "Таблица сокращений для режима Lisp.")

(defvar lisp-mode-syntax-table
  (let ((table (make-syntax-table lisp--mode-syntax-table)))
    (modify-syntax-entry ?\[ "_   " table)
    (modify-syntax-entry ?\] "_   " table)
    (modify-syntax-entry ?# "' 14" table)
    (modify-syntax-entry ?| "\" 23bn" table)
    table)
  "Таблица синтаксиса, используемая в `lisp-mode'.")
@end group
@end smallexample

  Три режима Lisp имеют большую часть своего кода.  Например, каждый из них
вызывает следующую функцию для установки различных переменных:

@smallexample
@group
(defun lisp-mode-variables (&optional syntax keywords-case-insensitive elisp)
  (when syntax
    (set-syntax-table lisp-mode-syntax-table))
  @dots{}
@end group
@end smallexample

@noindent
Помимо прочего, эта функция устанавливает переменную @code{comment-start}
для обработки комментариев Lisp.:

@smallexample
@group
  (setq-local comment-start ";")
  @dots{}
@end group
@end smallexample

  Каждый из разных режимов Lisp имеет немного отличающуюся ключевую карту.
Например, режим Lisp связывает @kbd{C-c C-z} с @code{run-lisp}, а другие
режимы Lisp - нет.  Однако все режимы Lisp имеют некоторые общие команды.
Следующий код устанавливает общие команды:

@smallexample
@group
(defvar lisp-mode-shared-map
  (let ((map (make-sparse-keymap)))
    (set-keymap-parent map prog-mode-map)
    (define-key map "\e\C-q" 'indent-sexp)
    (define-key map "\177" 'backward-delete-char-untabify)
    map)
  "Ключевая карта для команд, используемых всеми видами режимов Lisp.")
@end group
@end smallexample

@noindent
А вот код для настройки ключевой карты для режима Lisp:

@smallexample
@group
(defvar lisp-mode-map
  (let ((map (make-sparse-keymap))
        (menu-map (make-sparse-keymap "Lisp")))
    (set-keymap-parent map lisp-mode-shared-map)
    (define-key map "\e\C-x" 'lisp-eval-defun)
    (define-key map "\C-c\C-z" 'run-lisp)
    @dots{}
    map)
  "Ключевая карта для обычного режима Lisp.
  Все команды в `lisp-mode-shared-map' наследуются этой картой.")
@end group
@end smallexample

@noindent
Наконец, вот основная команда режима для режима Lisp:

@smallexample
@group
(define-derived-mode lisp-mode prog-mode "Lisp"
  "Основной режим для редактирования кода Lisp для Lisps, отличного от GNU Emacs Lisp.
  Команды: Удалить - преобразует табуляции в пробелы при перемещении назад.
  Абзацы разделяются пустыми строками.  Комментарии начинаются с точки с
  запятой.
  \\@{lisp-mode-map@}
  Обратить внимание, что `run-lisp' может использоваться либо для запуска
  подчиненного задания Lisp, либо для возврата к существующему."
@end group
@group
  (lisp-mode-variables nil t)
  (setq-local find-tag-default-function 'lisp-find-tag-default)
  (setq-local comment-start-skip
              "\\(\\(^\\|[^\\\\\n]\\)\\(\\\\\\\\\\)*\\)\\(;+\\|#|\\) *")
  (setq imenu-case-fold-search t))
@end group
@end smallexample

@node Minor Modes
@section Второстепенные Режимы
@cindex minor mode

  @dfn{Второстепенный режим} предоставляет дополнительные функции, которые
пользователи могут включать или отключать независимо от выбора основного
режима.  Второстепенные режимы можно включать по отдельности или в
комбинации.

  Большинство второстепенных режимов реализуют функции, которые не зависят
от основного режима, и поэтому могут использоваться с большинством основных
режимов.  Например, режим Auto Fill работает с любым основным режимом, в
котором разрешена вставка текста.  Однако несколько второстепенных режимов
относятся к конкретному основному режиму. Например, режим уточнения
Diff Auto - это второстепенный режим, который предназначен для использования
только с режимом Diff.

  В идеале второстепенный режим должен иметь желаемый эффект независимо от
других действующих второстепенных режимов. Должна быть возможность
активировать и деактивировать второстепенные режимы в любом порядке.

@defvar minor-mode-list
Значение этой переменной представляет собой список всех команд
второстепенного режима.
@end defvar

@menu
* Minor Mode Conventions::      Советы по написанию второстепенного режима.
* Keymaps and Minor Modes::     Как второстепенный режим может имеет свою
ключевая карта.
* Defining Minor Modes::        Удобное средство для определения
второстепенных режимов.
@end menu

@node Minor Mode Conventions
@subsection Условные Обозначения для Написания Второстепенных Режимов
@cindex minor mode conventions
@cindex conventions for writing minor modes

  Существуют соглашения о написании второстепенных режимов так же, как и для
основных режимов (@pxref{Major Modes}).  Эти условные обозначения описаны
ниже.  Самый простой способ следовать им - использовать макрос
@code{define-minor-mode}.  @xref{Defining Minor Modes}.

@itemize @bullet
@item
@cindex mode variable
Определить переменную, имя которой заканчивается на @samp{-mode}.
Называется это @dfn{переменная режима}.  Эту переменную должна установить
команда второстепенного режима.  Значение будет @code{nil}, если режим
отключен, и не-@code{nil}, если режим включен.  Переменная должна быть
локальной для буфера, если второстепенный режим является локальным для
буфера.

Эта переменная используется вместе с @code{minor-mode-alist} для отображения
имени второстепенного режима в строке режима.  Также определяет, активна ли
ключевая карта второстепенного режима, через @code{minor-mode-map-alist}
(@pxref{Controlling Active Maps}).  Отдельные команды или ловушки также
могут проверить его значение.

@item
Определить команду с именем @dfn{команда режима}, имя которой совпадает с
именем переменной режима.  Задача - установить значение переменной режима, а
также все остальное, что необходимо сделать для фактического включения или
отключения функций режима.

Команда режима должна принимать один необязательный аргумент.  Если
вызывается в интерактивном режиме без префиксного аргумента, должен
переключаться режим (т.е. включать, если отключен, и отключать, если
включен).  Если вызывается интерактивно с префиксным аргументом, должен
включать режим, если аргумент положительный, и отключать его в противном
случае.

Если команда режима вызывается из Lisp (т.е. не интерактивно), должна
включить режим, если аргумент опущен или @code{nil}; должна переключать
режим, если аргументом является символ @code{toggle}; в противном случае
должен обрабатывать аргумент так же, как для интерактивного вызова с
аргументом числового префикса, как описано выше.

В следующем примере показано, как реализовать это поведение (он похож на
код, созданный макросом @code{define-minor-mode}):

@example
(interactive (list (or current-prefix-arg 'toggle)))
(let ((enable
       (if (eq arg 'toggle)
           (not foo-mode) ; @r{это переменная режима}
         (> (prefix-numeric-value arg) 0))))
  (if enable
      @var{do-enable}
    @var{do-disable}))
@end example

Причина этого несколько сложного поведения в том, что позволяет
пользователям легко переключать второстепенный режим в интерактивном режиме,
а также позволяет легко включать второстепенный режим в ловушке режима,
например:

@example
(add-hook 'text-mode-hook 'foo-mode)
@end example

@noindent
Это работает правильно, независимо от того, был ли @code{foo-mode} уже
включен, поскольку команда режима @code{foo-mode} безусловно включает
второстепенный режим, когда вызывается из Lisp без аргументов.  Отключение
второстепенного режима в ловушке режима немного уродливее:

@example
(add-hook 'text-mode-hook (lambda () (foo-mode -1)))
@end example

@noindent
Однако это не очень часто делается.

  Включение или отключение второстепенного режима дважды подряд не должно
приводить к сбою и должно делать то же самое, что и включение или отключение
его только один раз.  Другими словами, команда второстепенного режима должна
быть идемпотентной.

@item
Добавьте элемент в @code{minor-mode-alist} для каждого второстепенного
режима (@pxref{Definition of minor-mode-alist}), если потребуется указать
второстепенный режим в строке режима.м Этот элемент должен быть списком
следующего вида:

@smallexample
(@var{mode-variable} @var{string})
@end smallexample

Здесь @var{mode-variable} - это переменная, которая управляет включением
второстепенного режима, а @var{string} - это короткая строка, начинающаяся с
пробела, для представления режима в строке режима.  Эти строки должны быть
короткими, чтобы их хватало сразу для нескольких.

Когда добавляется элемент в @code{minor-mode-alist}, используется
@code{assq} для проверки существующего элемента, чтобы избежать
дублирования.  Например:

@smallexample
@group
(unless (assq 'leif-mode minor-mode-alist)
  (push '(leif-mode " Leif") minor-mode-alist))
@end group
@end smallexample

@noindent
или вот так, используя @code{add-to-list} (@pxref{List Variables}):

@smallexample
@group
(add-to-list 'minor-mode-alist '(leif-mode " Leif"))
@end group
@end smallexample
@end itemize

  Кроме того, несколько основных правил режима
(@pxref{Major Mode Conventions}) применимы и к второстепенным режимам: те,
которые касаются имен глобальных символов, использования ловушки в конце
функции инициализации и использования ключевых карт и других таблиц.

  Дополнительный режим должен, по возможности, поддерживать включение и
отключение с помощью Custom (@pxref{Customization}).  Для этого переменная
режима должна быть определена с помощью @code{defcustom}, обычно с помощью
@code{:type 'boolean}.  Если простой установки переменной недостаточно для
включения режима, следует также указать метод @code{:set}, который включает
режим, вызывая команду режима.  Обратить внимание в строке документации к
переменной, что установка переменной, отличной от Custom, может не вступить
в силу.  Кроме того, отметить определение файлом cookie автозагрузки
(@pxref{autoload cookie}) и указать @code{:require}, чтобы при настройке
переменной загружалась библиотека, определяющая режим.  Например:

@smallexample
@group
;;;###autoload
(defcustom msb-mode nil
  "Toggle msb-mode.
Setting this variable directly does not take effect;
use either \\[customize] or the function `msb-mode'."
  :set 'custom-set-minor-mode
  :initialize 'custom-initialize-default
  :version "20.4"
  :type    'boolean
  :group   'msb
  :require 'msb)
@end group
@end smallexample

@node Keymaps and Minor Modes
@subsection Ключевые Карты и Второстепенные Режимы

  Каждый второстепенный режим может иметь свою собственную ключевую карту,
которая активна, когда режим включен.  Чтобы настроить карту для
второстепенного режима, добавляется элемент в alist
@code{minor-mode-map-alist}.  @xref{Definition of minor-mode-map-alist}.

@cindex @code{self-insert-command}, minor modes
  Одним из способов использования карт вспомогательного режима является
изменение поведения некоторых самовставляющихся символов, чтобы они делали
что-то еще, а также самовставлялись.  (Другой способ настроить
@code{self-insert-command} - через @code{post-self-insert-hook}, смотреть
@ref{Commands for Insertion}.  Помимо этого, возможности настройки
@code{self-insert-command} ограничены специальными случаями,
предназначенными для сокращений и режима автозаполнения.  Не пытаться
заменить стандартное определение @code{self-insert-command} своим
собственным.  Командный цикл редактора обрабатывает эту функцию особым
образом.)

Второстепенные режимы могут связывать команды с последовательностями ключей,
состоящими из @kbd{C-c}, за которым следует символ пунктуации.  Однако
последовательности, состоящие из @kbd{C-c}, за которым следует один из
@kbd{@{@}<>:;}, управляющий символ или цифра, зарезервированы для основных
режимов.  Кроме того, @kbd{C-c @var{letter}} зарезервирован для
пользователей.  @xref{Key Binding Conventions}.

@node Defining Minor Modes
@subsection Определение Второстепенных Режимов

  Макрос @code{define-minor-mode} предлагает удобный способ реализации
режима в одном автономном определении.

@defmac define-minor-mode mode doc [init-value [lighter [keymap]]] keyword-args@dots{} body@dots{}
Этот макрос определяет новый второстепенный режим с именем @var{mode}
(символ).  Определяет команду с именем @var{mode} для переключения
второстепенного режима с @var{doc} в качестве строки документации.

Команда переключения принимает один необязательный (префиксный) аргумент.
Если вызывается в интерактивном режиме без аргументов, включает или
выключает режим.  Положительный аргумент префикса включает режим, любой
другой аргумент префикса отключает его.  Начиная с Lisp, аргумент
@code{toggle} переключает режим, тогда как опущенный аргумент или аргумент
@code{nil} включает режим.  Это упрощает, например, включение
второстепенного режима в ловушке основного режима.  Если @var{doc} -
@code{nil}, макрос предоставляет строку документации по умолчанию,
объясняющую вышеизложенное.

По умолчанию он также определяет переменную с именем @var{mode}, для которой
устанавливается значение @code{t} или @code{nil} путем включения или
отключения режима.  Переменная инициализируется как @var{init-value}.  За
исключением необычных обстоятельств (смотреть ниже), это значение должно
быть @code{nil}.

Строка @var{lighter} говорит, что отображать в строке режима, когда режим
включен; если @code{nil}, режим не отображается в строке режима.

Необязательный аргумент @var{keymap} указывает ключевую карту для
второстепенного режима.  Если не-@code{nil}, это должно быть имя переменной
(значение которой является таблицей ключей), таблица ключей или список формы

@example
(@var{key-sequence} . @var{definition})
@end example

@noindent
где каждый @var{key-sequence} и @var{definition} - аргумент, пригодный для
перехода к @code{define-key} (@pxref{Changing Key Bindings}).  Если
@var{keymap} - это карта или список, это также определяет переменную
@code{@var{mode}-map}.

Приведенные выше три аргумента @var{init-value}, @var{lighter} и
@var{keymap} можно (частично) опустить при использовании @var{keyword-args}.
@var{keyword-args} состоит из ключевых слов, за которыми следуют
соответствующие значения.  Некоторые ключевые слова имеют особое значение:

@table @code
@item :group @var{group}
Пользовательское имя группы для использования во всех сгенерированных формах
@code{defcustom}.  По умолчанию @var{mode} без возможного завершающего
@samp{-mode}.  @strong{Внимание:}, не используется это имя группы по
умолчанию, если не написано @code{defgroup} для правильного определения этой
группы.  @xref{Group Definitions}.

@item :global @var{global}
Если не-@code{nil}, это указывает, что второстепенный режим должен быть
глобальным, а не локальным для буфера.  По умолчанию @code{nil}.

Одним из следствий создания глобального второстепенного режима является то,
что переменная @var{mode} становится переменной настройки.  Переключение её
через интерфейс настройки включает и выключает режим, и её значение может
быть сохранено для будущих сеансов Emacs
(@pxref{Saving Customizations,,, emacs, The GNU Emacs Manual}.  Чтобы
сохраненная переменная работала, потребуется убедиться, что форма
@code{define-minor-mode} вычисляется каждый раз при запуске Emacs; для
пакетов, которые не являются частью Emacs, самый простой способ сделать это
- указать ключевое слово @code{:require}.

@item :init-value @var{init-value}
Это эквивалентно позиционному указанию @var{init-value}.

@item :lighter @var{lighter}
Это эквивалентно позиционному указанию @var{lighter}.

@item :keymap @var{keymap}
Это эквивалентно позиционному указанию @var{keymap}.

@item :variable @var{place}
Это заменяет переменную по умолчанию @var{mode}, используемую для хранения
состояния режима.  Если указано это, переменная @var{mode} не определена, и
любой аргумент @var{init-value} не будет использоваться.  @var{place} может
быть переменной с другим именем (которую потребуется определить
самостоятельно) или чем угодно, что можно использовать с функцией
@code{setf} (@pxref{Generalized Variables}).  @var{place} также может быть
cons ячейкой @code{(@var{get} . @var{set})}, где @var{get} - это выражение,
возвращающее текущее состояние, а @var{set} - это функция одного аргумента
(состояния), который его устанавливает.

@item :after-hook @var{after-hook}
Это определяет единственную форму Lisp, которая оценивается после выполнения
обработчиков режима.  Не следует цитировать.
@end table

Любые другие аргументы ключевого слова передаются непосредственно
@code{defcustom}, сгенерированному для переменной @var{mode}.

Команда с именем @var{mode} сначала выполняет стандартные действия, такие
как установка переменной с именем @var{mode}, а затем выполняет формы
@var{body}, если они есть.  Затем запускает переменную обработчика режима
@code{@var{mode}-hook} и заканчивает вычислением любой формы в
@code{:after-hook}.
@end defmac

  Начальное значение должно быть @code{nil}, за исключением случаев, когда
(1) режим предварительно загружен в Emacs или (2) его безболезненно
загружают, чтобы включить режим, даже если пользователь его не запрашивал.
Например, если режим не действует, если не включено что-то еще, и всегда
будет загружаться к этому времени, включение его по умолчанию безвредно.  Но
это необычные обстоятельства.  Обычно начальное значение должно быть
@code{nil}.

@findex easy-mmode-define-minor-mode
  Имя @code{easy-mmode-define-minor-mode} - это псевдоним для этого макроса.

  Вот пример использования @code{define-minor-mode}:

@smallexample
(define-minor-mode hungry-mode
  "Включите голодный режим.
  Эта команда в интерактивном режиме без аргументов переключает режим.
  Положительный аргумент префикса включает режим, любой другой префиксный
  аргумент отключает его.  Из Lisp аргумент опущен или nil включает режим,
  `toggle' переключает состояние.

Когда включен голодный режим, управляющая клавиша удаления поглощает все
предыдущие пробелы, кроме последнего.
Смотреть команду \\[hungry-electric-delete]."
 ;; Начальное значение.
 nil
 ;; Индикатор строки режима.
 " Hungry"
 ;; Привязки второстепенного режима.
 '(([C-backspace] . hungry-electric-delete))
 :group 'hunger)
@end smallexample

@noindent
Это определяет второстепенный режим с именем ``Hungry mode'', команду с
именем @code{hungry-mode} для его переключения, переменную с именем
@code{hungry-mode}, которая указывает, включен ли режим, и переменную с
именем @code{hungry-mode-map}, которая содержит ключевую карту, которая
активна, когда режим включен.  Инициализирует карту с привязкой клавиш для
@kbd{C-@key{DEL}}.  Помещает переменную @code{hungry-mode} в настраиваемую
группу @code{hunger}.  Форм @var{body} нет - многим второстепенным режимам
они не нужны.

  Вот эквивалентный способ написать это:

@smallexample
(define-minor-mode hungry-mode
  "Переключить режим голодания.
...остальная документация, как и раньше..."
 ;; Начальное значение.
 :init-value nil
 ;; Индикатор строки режима.
 :lighter " Hungry"
 ;; Привязки второстепенного режима.
 :keymap
 '(([C-backspace] . hungry-electric-delete)
   ([C-M-backspace]
    . (lambda ()
        (interactive)
        (hungry-electric-delete t))))
 :group 'hunger)
@end smallexample

@defmac define-globalized-minor-mode global-mode mode turn-on keyword-args@dots{}
Это определяет глобальный переключатель с именем @var{global-mode}, значение
которого состоит в том, чтобы включить или отключить второстепенный
локальный для буфера режим @var{mode} во всех буферах.  Для включения
второстепенного режима в буфере используется функция @var{turn-on}; для
отключения второстепенного режима вызывается @var{mode} с аргументом
@minus{}1.

Глобальное включение режима также влияет на буферы, которые впоследствии
создаются при посещении файлов, и на буферы, которые используют основной
режим, отличный от основного режима; но он не обнаруживает создание нового
буфера в режиме Fundamental.

Это определяет параметр настройки @var{global-mode} (@pxref{Customization}),
который можно переключать в интерфейсе настройки, чтобы включать и выключать
второстепенный режим.  Как и в случае с @code{define-minor-mode},
потребуется убедиться, что форма @code{define-globalized-minor-mode}
оценивается каждый раз при запуске Emacs, например, путем предоставления
ключевого слова @code{:require}.

Используется @code{:group @var{group}} в @var{keyword-args}, чтобы указать
настраиваемую группу для переменной режима глобального второстепенного
режима.

Вообще говоря, когда определяется второстепенный глобализованный режим,
также нужно определять неглобализованную версию, чтобы люди могли
использовать (или отключать) ее в отдельных буферах.  Это также позволяет им
отключать глобально включенный второстепенный режим в конкретном основном
режиме с помощью ловушки этого режима.
@end defmac


@node Mode Line Format
@section Формат Строки Режима
@cindex mode line

  Каждое окно Emacs (кроме окон минибуфера) обычно имеет строку режима
внизу, которая отображает информацию о состоянии буфера, отображаемого в
окне.  Строка режима содержит информацию о буфере, такую как его имя,
связанный файл, глубину рекурсивного редактирования, а также основные и
второстепенные режимы.  Окно также может иметь @dfn{строку заголовка},
который очень похож на строку режима, но отображается в верхней части окна.

  В этом разделе описывается, как управлять содержимым строки режима и
строки заголовка.  Включается это в эту главу, потому что большая часть
информации, отображаемой в строке режима, относится к активированным
основным и второстепенным режимам.

@menu
* Base: Mode Line Basics.       Основные идеи управления строкой режимов.
* Data: Mode Line Data.        Структура данных, управляющая строкой режима.
* Top: Mode Line Top.      Переменная верхнего уровня, формат-строки-режима.
* Mode Line Variables::    Переменные, используемые в этой структуре данных.
* %-Constructs::                Ввод информации в строку режима.
* Properties in Mode::         Использование свойств текста в строке режима.
* Header Lines::                Как строка режима, но вверху.
* Emulating Mode Line::         Форматирование текста как в строке режима.
@end menu

@node Mode Line Basics
@subsection Основные Сведения о Строке Режима

  Содержимое каждой строки режима определяется локальной переменной буфера
@code{mode-line-format} (@pxref{Mode Line Top}).  Эта переменная содержит
@dfn{конструкция строки режима}: шаблон, который управляет тем, что
отображается в строке режима буфера.  Значение @code{header-line-format}
точно так же определяет строку заголовка буфера.  Все окна для одного и того
же буфера используют один и тот же @code{mode-line-format} или
@code{header-line-format}, если для этого окна (@pxref{Window Parameters})
не указан параметр @code{mode-line-format} или @code{header-line-format}.

  Для повышения эффективности Emacs не пересчитывает постоянно строку режима
и строку заголовка каждого окна.  Это происходит, когда обстоятельства
требуют этого - например, если меняется конфигурация окна, переключается
буферы, сужается или расширяется буфер, прокручивается или изменяется буфер.
Если изменяется любая из переменных, на которые ссылаются
@code{mode-line-format} или @code{header-line-format}
(@pxref{Mode Line Variables}), или любые другие структуры данных, которые
влияют на то, как отображается текст (@pxref{Display}), потребуется
использовать функцию @code{force-mode-line-update} для обновления
отображения.

@defun force-mode-line-update &optional all
Эта функция заставляет Emacs обновлять строку режима текущего буфера и
строку заголовка на основе последних значений всех соответствующих
переменных во время следующего цикла повторного отображения.  Если
необязательный аргумент @var{all} - не-@code{nil}, он принудительно
обновляет все строки режима и строки заголовка.

Эта функция также вызывает обновление строки меню и заголовка фрейма.
@end defun

  Строка режима выбранного окна обычно отображается другим цветом с
использованием грани @code{mode-line}.  Вместо этого на отображении
@code{mode-line-inactive} появляются строки режима других окон.
@xref{Faces}.

@node Mode Line Data
@subsection The Структура Данных Строки Режима
@cindex mode line construct

  Содержимое строки режима контролируется структурой данных, называемой
@dfn{построение строки режима}, состоящей из списков, строк, символов и
чисел, хранящихся в локальных переменных буфера.  Каждый тип данных имеет
определенное значение для внешнего вида строки режима, как описано ниже.
Такая же структура данных используется для построения заголовков кадров
(@pxref{Frame Titles}) и строк заголовков (@pxref{Header Lines}).

  Конструкция строки режима может быть такой же простой, как фиксированная
строка текста, но обычно она определяет, как объединить фиксированные строки
со значениями переменных для создания текста.  Многие из этих переменных
сами по себе имеют конструкции строки режима в качестве значений.

  Вот значения различных типов данных как конструкций строки режима:

@table @code
@cindex percent symbol in mode line
@item @var{string}
Строка как конструкция строки режима отображается дословно, за исключением
@dfn{@code{%}-constructs} в ней.  Заменяются другие данные; смотреть
@ref{%-Constructs}.

Если части строки имеют свойства @code{face}, они управляют отображением
текста так же, как если бы они отображали текст в буфере.  Любые символы, не
имеющие свойств @code{face}, по умолчанию отображаются в лице
@code{mode-line} или @code{mode-line-inactive}
(@pxref{Standard Faces,,, emacs, The GNU Emacs Manual}).  Свойства
@code{help-echo} и @code{keymap} в @var{string} имеют особое значение.
@xref{Properties in Mode}.

@item @var{symbol}
Символ в качестве конструкции строки режима обозначает ее значение.
Значение @var{symbol} используется как конструкция строки режима вместо
@var{symbol}.  Однако символы @code{t} и @code{nil} игнорируются, как и
любой символ, значение которого недействительно.

Есть одно исключение: если значение @var{symbol} является строкой, оно
отображается дословно: конструкции @code{%} не распознаются.

Если @var{symbol} не помечен как опасный (т.е. у него есть свойство
не-@code{nil} @code{risky-local-variable}), все текстовые свойства,
указанные в значении @var{symbol}ов, игнорируются.  Сюда входят текстовые
свойства строк в значении @var{symbol}ов, а также все формы @code{:eval} и
@code{:propertize} в нем.  (Причина в безопасности: безопасные переменные
могут быть установлены автоматически из файловых переменных без запроса
пользователя.)

@item (@var{string} @var{rest}@dots{})
@itemx (@var{list} @var{rest}@dots{})
Список, первым элементом которого является строка или список, означает
рекурсивную обработку всех элементов и объединение результатов.  Это
наиболее распространенная форма построения строки режима.

@item (:eval @var{form})
Список, первым элементом которого является символ @code{:eval}, говорит, что
нужно оценить @var{form} и использовать результат в виде строки для
отображения.  Убедиться, что эта оценка не может загрузить какие-либо файлы,
так как это может вызвать бесконечную рекурсию.

@item (:propertize @var{elt} @var{props}@dots{})
Список, первым элементом которого является символ @code{:propertize},
требует рекурсивной обработки конструкции строки режима @var{elt}, а затем
добавить к результату текстовые свойства, указанные в @var{props}.  Аргумент
@var{props} должен состоять из нуля или более пар @var{text-property}
@var{value}.  Если @var{elt} является или производит строку с текстовыми
свойствами, все символы этой строки должны иметь одинаковые свойства, иначе
некоторые из них могут быть удалены @code{:propertize}.

@item (@var{symbol} @var{then} @var{else})
Список, первым элементом которого является символ, не являющийся ключевым
словом, задает условное выражение.  Значение зависит от значения
@var{symbol}.  Если @var{symbol} имеет значение не-@code{nil}, второй
элемент, @var{then}, обрабатывается рекурсивно как конструкция строки
режима.  В противном случае рекурсивно обрабатывается третий элемент
@var{else}.  Можно опустить @var{else}; тогда конструкция строки режима
ничего не отображает, если значение @var{symbol} равно @code{nil} или void.

@item (@var{width} @var{rest}@dots{})
Список, первым элементом которого является целое число, определяет усечение
или заполнение результатов @var{rest}.  Остальные элементы @var{rest}
рекурсивно обрабатываются как конструкции строки режима и объединяются
вместе.  Если @var{width} положительно, результатом будет заполненное
пространство справа, если его ширина меньше @var{width}.  Если @var{width}
отрицательно, результат обрезается справа до столбцов @minus{}@var{width},
если его ширина превышает @minus{}@var{width}.

Например, обычный способ показать, какой процент буфера находится над
верхней частью окна, - это использовать такой список: @code{(-3 "%p")}.
@end table

@node Mode Line Top
@subsection Верхний Уровень Управления Строкой Режима

  Переменная в общем управлении строкой режима - @code{mode-line-format}.

@defopt mode-line-format
Значение переменной - конструкция строки режима, которая управляет
содержимым строки режима.  Всегда является локальным для всех буферов.

Если установить для этой переменной значение @code{nil} в буфере, этот буфер
не будет иметь строки режима.  (Окно высотой всего в одну строку также не
отображает строку режима.)
@end defopt

  Значение по умолчанию @code{mode-line-format} предназначено для
использования значений других переменных, таких как
@code{mode-line-position} и @code{mode-line-modes} (которые, в свою очередь,
включают значения переменных @code{mode-name} и @code{minor-mode-alist}).
Очень немногие режимы нуждаются в изменении самого @code{mode-line-format}.
Для большинства целей достаточно изменить некоторые переменные, на которые
прямо или косвенно ссылается @code{mode-line-format}.

  Если изменить сам @code{mode-line-format}, новое значение должно
использовать те же переменные, которые появляются в значении по умолчанию
(@pxref{Mode Line Variables}), а не дублировать их содержимое или отображать
информацию другим способом.  Таким образом, настройки, сделанные
пользователем или программами Lisp (такими как @code{display-time} и
основные режимы) посредством изменений этих переменных, остаются в силе.

  Вот гипотетический пример @code{mode-line-format}, который может быть
полезен для режима Shell (на самом деле режим Shell не устанавливает
@code{mode-line-format}):

@example
@group
(setq mode-line-format
  (list "-"
   'mode-line-mule-info
   'mode-line-modified
   'mode-line-frame-identification
   "%b--"
@end group
@group
   ;; @r{Обратить внимание, что это оценивается при составлении списка.}
   ;; @r{Создается конструкция строки режима, представляет собой строку.}
   (getenv "HOST")
@end group
   ":"
   'default-directory
   "   "
   'global-mode-string
   "   %[("
   '(:eval (mode-line-mode-name))
   'mode-line-process
   'minor-mode-alist
   "%n"
   ")%]--"
@group
   '(which-func-mode ("" which-func-format "--"))
   '(line-number-mode "L%l--")
   '(column-number-mode "C%c--")
   '(-3 "%p")))
@end group
@end example

@noindent
(Переменные @code{line-number-mode}, @code{column-number-mode} и
@code{which-func-mode} включают определенные второстепенные режимы; как
обычно, эти имена переменных также являются именами команд второстепенного
режима.)

@node Mode Line Variables
@subsection Переменные, Используемые в Строке Режима

  В этом разделе описаны переменные, включенные стандартным значением
@code{mode-line-format} в текст строки режима.  В этих переменных нет ничего
особенного; любые другие переменные могут иметь такие же эффекты в строке
режима, если значение @code{mode-line-format} изменяется для их
использования.  Однако различные части Emacs устанавливают эти переменные,
понимая, что они будут управлять частями строки режима; поэтому с
практической точки зрения важно, чтобы модовая линия использовала их.
Смотреть также @ref{Optional Mode Line,,, emacs, The GNU Emacs Manual}.

@defvar mode-line-mule-info
Эта переменная содержит значение конструкции строки режима, которая
отображает информацию о языковой среде, системе кодирования буфера и текущем
методе ввода.  @xref{Non-ASCII Characters}.
@end defvar

@defvar mode-line-modified
Эта переменная содержит значение конструкции строки режима, которая
показывает, был ли изменен текущий буфер.  Его значение по умолчанию
отображает @samp{**}, если буфер изменен, @samp{--}, если буфер не изменен,
@samp{%%}, если буфер только для чтения, и @samp{%*}, если буфер только для
чтения и изменения.

Изменение этой переменной не приводит к обновлению строки режима.
@end defvar

@defvar mode-line-frame-identification
Эта переменная определяет текущий кадр.  Её значение по умолчанию отображает
@code{" "}, если используется оконная система, которая может отображать
несколько кадров, или @code{"-%F "} на обычном терминале, который показывает
только один кадр за раз.
@end defvar

@defvar mode-line-buffer-identification
Эта переменная определяет буфер, отображаемый в окне.  Её значение по
умолчанию отображает имя буфера, дополненное пробелами как минимум до 12
столбцов.
@end defvar

@defvar mode-line-position
Эта переменная указывает позицию в буфере.  Её значение по умолчанию
отображает процент буфера и, необязательно, размер буфера, номер строки и
номер столбца.
@end defvar

@defopt mode-line-percent-position
Эта опция используется в @code{mode-line-position}.  Её значение определяет
как отображается процент буфера (один из @code{nil}, @code{"%o"},
@code{"%p"}, @code{"%P"} или @code{"%q"}, @pxref{%-Constructs}), так и
ширину для заполнения или усечения.  Рекомендуется устанавливать эту опцию с
помощью средства @code{customize-variable}.
@end defopt

@defvar vc-mode
Переменная @code{vc-mode}, local-buffer в каждом буфере, записывает,
поддерживается ли посещенный файл буфера с контролем версий, и если да, то
какого типа.  Её значение - строка, которая появляется в строке режима, или
@code{nil}, если контроль версий отсутствует.
@end defvar

@defvar mode-line-modes
Эта переменная отображает основной и второстепенный режимы буфера.  Её
значение по умолчанию также отображает уровень рекурсивного редактирования,
информацию о состоянии процесса и о том, действует ли сужение.
@end defvar

@defvar mode-line-remote
Эта переменная используется, чтобы показать, является ли
@code{default-directory} для текущего буфера удаленной.
@end defvar

@defvar mode-line-client
Эта переменная используется для идентификации кадров @code{emacsclient}.
@end defvar

  Следующие три переменные используются в @code{mode-line-modes}:

@defvar mode-name
Эта локальная в буфере переменная содержит имя основного режима текущего
буфера.  Каждый основной режим должен устанавливать эту переменную, чтобы
имя режима отображалось в строке режима.  Значение не обязательно должно
быть строкой, но может использовать любой из типов данных, допустимых в
конструкции строки режима (@pxref{Mode Line Data}).  Чтобы вычислить строку,
которая будет определять имя режима в строке режима, используется
@code{format-mode-line} (@pxref{Emulating Mode Line}).
@end defvar

@defvar mode-line-process
Эта локальная в буфере переменная содержит информацию строки режима о
состоянии процесса в режимах, используемых для связи с подпроцессами.  Она
отображается сразу после названия основного режима, без пробелов.  Например,
её значение в буфере @file{*shell*} - @code{(":%s")}, что позволяет оболочке
отображать свой статус вместе с основным режимом как: @samp{(Shell:run)}.
Обычно это переменная @code{nil}..
@end defvar

@defvar mode-line-front-space
Эта переменная отображается в начале строки режима.  По умолчанию эта
конструкция отображается прямо в начале строки режима, за исключением того,
что если есть сообщение о заполнении памяти, она отображается первой.
@end defvar

@defvar mode-line-end-spaces
Эта переменная отображается в конце строки режима.
@end defvar

@defvar mode-line-misc-info
Конструкция строки режима для различной информации.  По умолчанию это
показывает информацию, указанную @code{global-mode-string}.
@end defvar

@defvar minor-mode-alist
@anchor{Definition of minor-mode-alist}
Эта переменная содержит список ассоциаций, элементы которого определяют, как
строка режима должна указывать, что второстепенный режим активен.  Каждый
элемент @code{minor-mode-alist} должен быть двухэлементным списком:

@example
(@var{minor-mode-variable} @var{mode-line-string})
@end example

В более общем смысле @var{mode-line-string} может быть любой конструкцией
строки режима.  Появляется в строке режима, когда значение
@var{minor-mode-variable} равно не-@code{nil}, и никак иначе.  Эти строки
должны начинаться с пробелов, чтобы они не сливались.  Обычно
@var{minor-mode-variable} для определенного режима устанавливается на
значение не-@code{nil}, когда этот второстепенный режим активирован.

Сам @code{minor-mode-alist} не является локальным для буфера.  Каждая
переменная, упомянутая в списке, должна быть локальной для буфера, если ее
второстепенный режим можно включить отдельно в каждом буфере.
@end defvar

@defvar global-mode-string
Эта переменная содержит конструкцию строки режима, которая по умолчанию
появляется в строке режима сразу после второстепенного режима
@code{which-func-mode}, если он установлен, иначе после
@code{mode-line-modes}.  Команда @code{display-time} устанавливает
@code{global-mode-string} для ссылки на переменную
@code{display-time-string}, которая содержит строку, содержащую время и
информацию о загрузке.

Конструкция @samp{%M} заменяет значение @code{global-mode-string}, но это
устарело, поскольку переменная включена в строку режима из
@code{mode-line-format}.
@end defvar

Вот упрощенная версия значения по умолчанию @code{mode-line-format}.
Настоящее значение по умолчанию также определяет добавление текстовых
свойств.

@example
@group
("-"
 mode-line-mule-info
 mode-line-modified
 mode-line-frame-identification
 mode-line-buffer-identification
@end group
 "   "
 mode-line-position
 (vc-mode vc-mode)
 "   "
@group
 mode-line-modes
 (which-func-mode ("" which-func-format "--"))
 (global-mode-string ("--" global-mode-string))
 "-%-")
@end group
@end example

@node %-Constructs
@subsection @code{%}-Конструкции в Строке Режима

  Строки, используемые как конструкции строки режима, могут использовать
определенные конструкции @code{%} для замены различных типов данных.  Ниже
приводится список определенных @code{%}-конструкций и их значение.

  В любой конструкции, кроме @samp{%%}, можно добавить десятичное целое
число после @samp{%}, чтобы указать минимальную ширину поля.  Если ширина
меньше, поле дополняется до этой ширины.  Чисто числовые конструкции
(@samp{c}, @samp{i}, @samp{I} и @samp{l}) дополняются пробелами слева, а
другие дополняются пробелами справа.

@table @code
@item %b
Имя текущего буфера, полученное с помощью функции @code{buffer-name}.
@xref{Buffer Names}.

@item %c
Текущее количество точек в столбце, считая с нуля, начиная с левого края
окна.

@item %C
Текущее количество точек в столбце, считая от единицы, начиная с левого
края окна.

@item %e
Когда в Emacs почти не хватает памяти для объектов Lisp, об этом сообщается
кратким сообщением.  В противном здесь пусто.

@item %f
Имя посещенного файла, полученное с помощью функции @code{buffer-file-name}.
@xref{Buffer File Name}.

@item %F
Заголовок (только в оконной системе) или имя выбранного фрейма.
@xref{Basic Parameters}.

@item %i
Размер доступной части текущего буфера; в основном
@code{(- (point-max) (point-min))}.

@item %I
Аналогично @samp{%i}, но размер печатается более читаемым способом,
используя @samp{k} для 10^3, @samp{M} для 10^6, @samp{G} для 10^9 и т. д.
Для сокращения.

@item %l
Текущий номер строки точки, считая в пределах доступной части буфера.

@item %n
@samp{Сужение} при действии сужения; ничего иначе (смотреть
@code{narrow-to-region} в @ref{Narrowing}).

@item %o
Степень @dfn{прохождения} окна через (видимую часть) буфера, то есть
размер текста над верхней частью окна, выраженный в процентах от всего
текста за пределами окна, или @samp{Top}, @samp{Bottom} или @samp{All}.

@item %p
Процент буфера текста над @strong{top} окна или @samp{Top}, @samp{Bottom}
или @samp{All}.  Обратить внимание, что конструкция строки режима по
умолчанию усекает это до трех символов.

@item %P
Процент текста буфера, который находится над @strong{bottom} окна (который
включает текст, видимый в окне, а также текст над верхом), плюс @samp{Top},
если верх буфера виден на экране; или @samp{Bottom} или @samp{All}.

@item %q
Процентное соотношение текста над @strong{top} и @strong{bottom} окна,
разделенное @samp{-} или @samp{All}.

@item %s
Статус подпроцесса, принадлежащего текущему буферу, полученный с помощью
@code{process-status}.  @xref{Process Information}.

@item %z
Мнемоника систем кодирования клавиатуры, терминала и буфера.

@item %Z
Как @samp{%z}, но включая формат конца строки.

@item %*
@samp{%}, если буфер доступен только для чтения (смотреть
@code{buffer-read-only}); @*
@samp{*}, если буфер изменен (смотреть @code {buffer-modified-p}); @*
@samp{-} в другом случае.  @xref{Buffer Modification}.

@item %+
@samp{*}, если буфер изменен (@code{buffer-modified-p}); @*
@samp{%}, если буфер доступен только для чтения
(@code{buffer-read-only}); @*
@samp{-} иначе.  Это отличается от @samp{%*} только для модифицированного
буфера только для чтения.  @xref{Buffer Modification}.

@item %&
@samp{*}, если буфер изменен, и @samp{-} в противном случае.

@item %[
Индикация глубины уровней рекурсивного редактирования (не считая уровней
минибуфера): по одному @samp{[} для каждого уровня редактирования.
@xref{Recursive Editing}.

@item %]
По одному @samp{]} для каждого уровня рекурсивного редактирования (не считая
уровней минибуфера).

@item %-
Дефисов достаточно, чтобы заполнить оставшуюся часть строки режима.

@item %%
Символ @samp{%} --- так можно включить литерал @samp{%} в строку, в которой
разрешены конструкции @code{%}.
@end table

Следующие две конструкции @code{%} все еще поддерживаются, но они устарели,
так как вы можно получить те же результаты с переменными @code{mode-name} и
@code{global-mode-string}.

@table @code
@item %m
Значение для @code{mode-name}.

@item %M
Значение для @code{global-mode-string}.
@end table

@node Properties in Mode
@subsection Свойства в Строке Режима
@cindex text properties in the mode line

  Некоторые свойства текста имеют значение в строке режима.  Свойство
@code{face} влияет на внешний вид текста; свойство @code{help-echo}
связывает справочные строки с текстом, а @code{keymap} может сделать текст
чувствительным к мыши.

  Есть четыре способа указать свойства текста для текста в строке режима.:

@enumerate
@item
Поместить строку с текстовым свойством непосредственно в структуру данных
строки режима.

@item
Поместить текстовое свойство в строку режима %-конструкции, например
@samp{%12b}; тогда расширение %-конструкции будет иметь то же свойство
текста.

@item
Использовать конструкцию @code{(:propertize @var{elt} @var{props}@dots{})},
чтобы дать @var{elt} текстовое свойство, заданное @var{props}.

@item
Использовать список, содержащий @code{:eval @var{form}} в структуре данных
строки режима, и заставить @var{form} вычислить строку, имеющую свойство
text.
@end enumerate

  Можно использовать свойство @code{keymap} для указания ключевой карты.
Эта карта действует только при щелчках мышью; привязка к ней символьных и
функциональных клавиш не имеет никакого эффекта, поскольку невозможно
переместить точку в строку режима.

  Когда строка режима ссылается на переменную, у которой нет свойства
не-@code{nil} @code{risky-local-variable}, любые текстовые свойства,
заданные или указанные в значениях этой переменной, игнорируются.  Это
связано с тем, что в противном случае такие свойства могли бы указывать
функции, которые должны быть вызваны, и эти функции могли бы поступать из
локальных переменных файла.

@node Header Lines
@subsection Строки Заголовка Окна
@cindex header line (of a window)
@cindex window header line

  Окно может иметь @dfn{строку заголовка} вверху, так же как оно может иметь
строку режима внизу.  Функция строки заголовка работает так же, как функция
строки режима, за исключением того, что она контролируется
@code{header-line-format}:

@defvar header-line-format
Эта переменная, локальная в каждом буфере, определяет, как отображать строку
заголовка для окон, отображающих буфер.  Формат значения такой же, как для
@code{mode-line-format} (@pxref{Mode Line Data}).  Обычно это @code{nil},
так что обычные буферы не имеют строки заголовка.
@end defvar

@defun window-header-line-height &optional window
Эта функция возвращает высоту в пикселях строки заголовка @var{window}он.
@var{window} должно быть активным окном, и по умолчанию используется
выбранное окно.
@end defun

  Окно высотой всего в одну строку никогда не отображает строку заголовка.
Окно высотой в две строки не может одновременно отображать строку режима и
строку заголовка; если у него есть строка режима, тогда не отображает строку
заголовка.

@node Emulating Mode Line
@subsection Форматирование Строки в Режиме Эмуляции

  Можно использовать функцию @code{format-mode-line} для вычисления текста,
который будет отображаться в строке режима или строке заголовка на основе
определенной конструкции строки режима.

@defun format-mode-line format &optional face window buffer
Эта функция форматирует строку текста в соответствии с @var{format}, как
если бы она генерировала строку режима для @var{window}, но также возвращает
текст в виде строки.  Аргумент @var{window} по умолчанию соответствует
выбранному окну.  Если @var{buffer} - не-@code{nil}, вся используемая
информация берется из @var{buffer}; по умолчанию это поступает из буфера
@var{window}он.

Строка значения обычно имеет текстовые свойства, соответствующие внешним
видам, ключевым картам и т. д., которые должна иметь строка режима.  Любой
символ, для которого свойство @code{face} не указано в @var{format},
получает значение по умолчанию, определяемое @var{face}.  Если @var{face} -
@code{t}, это означает либо @code{mode-line}, если выбран @var{window}, либо
@code{mode-line-inactive}.  Если @var{face} равен @code{nil} или опущен, это
означает внешний вид по умолчанию.  Если @var{face} является целым числом,
значение, возвращаемое этой функцией, не будет иметь текстовых свойств.

Также можно указать другие допустимые внешние виды в качестве значения
@var{face}.  Если указано, предоставляет свойство @code{face} для символв,
вид которых не указан в @var{format}.

Обратить внимание, что использование @code{mode-line},
@code{mode-line-inactive} или @code{header-line} как @var{face} фактически
повторно отобразит строку режима или строку заголовка, соответственно, с
использованием текущих определений соответствующего вида в дополнение к
возврату отформатированной строки.  (Другие виды не вызывают повторного
отображения.)

Например, @code{(format-mode-line header-line-format)} возвращает текст,
который будет отображаться в строке заголовка выбранного окна (@code{""},
если у него нет строки заголовка).
@code{(format-mode-line header-line-format 'header-line)} возвращает тот же
текст, при этом каждый символ несет вид, который будет иметь в самой строке
заголовка, а также перерисовывает строку заголовка.
@end defun

@node Imenu
@section Imenu

@cindex Imenu
  @dfn{Imenu} - это функция, которая позволяет пользователям выбрать
определение или раздел в буфере из меню, в котором перечислены все из них,
чтобы перейти непосредственно к этому месту в буфере.  Imenu работает путем
создания индекса буфера, который перечисляет имена и позиции в буфере
определений или других именованных частей буфера; затем пользователь может
выбрать один из них и переместить на него точку.  В основных режимах можно
добавить элемент строки меню для использования Imenu с помощью
@code{imenu-add-to-menubar}.

@deffn Command imenu-add-to-menubar name
Эта функция определяет элемент локальной строки меню с именем @var{name} для
запуска Imenu.
@end deffn

  Команды пользовательского уровня для использования Imenu описаны в
Руководстве по Emacs (@pxref{Imenu,, Imenu, emacs, the Emacs Manual}).  В
этом разделе объясняется, как настроить метод Imenu поиска определений или
частей буфера для определенного основного режима.

  Обычный и самый простой способ - установить переменную
@code{imenu-generic-expression}:

@defvar imenu-generic-expression
Эта переменная, если не-@code{nil}, представляет собой список, который
определяет регулярные выражения для поиска определений для Imenu.  Простые
элементы @code{imenu-generic-expression} выглядят так:

@example
(@var{menu-title} @var{regexp} @var{index})
@end example

Здесь, если @var{menu-title} равен не-@code{nil}, это означает, что
совпадения для этого элемента должны идти в подменю индекса буфера;
@var{menu-title} сам определяет имя подменю.  Если @var{menu-title} -
@code{nil}, совпадения для этого элемента идут непосредственно на верхний
уровень индекса буфера.

Второй элемент в списке @var{regexp} - это регулярное выражение
(@pxref{Regular Expressions}); все в буфере, которому оно соответствует,
считается определением, что-то, что следует упомянуть в индексе буфера.
Третий элемент, @var{index}, является неотрицательным целым числом,
указывающим, какое подвыражение в @var{regexp} соответствует имени
определения.

Элемент также может выглядеть так:

@example
(@var{menu-title} @var{regexp} @var{index} @var{function} @var{arguments}@dots{})
@end example

Каждое совпадение для этого элемента создает элемент индекса, и когда
элемент индекса выбирается пользователем, он вызывает @var{function} с
аргументами, состоящими из имени элемента, позиции в буфере и
@var{arguments}.

Для режима Emacs Lisp @code{imenu-generic-expression} может выглядеть так:

@c should probably use imenu-syntax-alist and \\sw rather than [-A-Za-z0-9+]
@example
@group
((nil "^\\s-*(def\\(un\\|subst\\|macro\\|advice\\)\
\\s-+\\([-A-Za-z0-9+]+\\)" 2)
@end group
@group
 ("*Vars*" "^\\s-*(def\\(var\\|const\\)\
\\s-+\\([-A-Za-z0-9+]+\\)" 2)
@end group
@group
 ("*Types*"
  "^\\s-*\
(def\\(type\\|struct\\|class\\|ine-condition\\)\
\\s-+\\([-A-Za-z0-9+]+\\)" 2))
@end group
@end example

Установка этой переменной делает его локальной в текущем буфере.
@end defvar

@defvar imenu-case-fold-search
Эта переменная определяет, учитывается ли регистр при сопоставлении с
регулярными выражениями в значении @code{imenu-generic-expression}:
@code{t}, значение по умолчанию, означает, что при сопоставлении регистр
не учитывается.

Установка этой переменной делает его локальной в текущем буфере.
@end defvar

@defvar imenu-syntax-alist
Эта переменная представляет собой список модификаторов таблицы синтаксиса,
используемых при обработке @code{imenu-generic-expression}, чтобы
переопределить таблицу синтаксиса текущего буфера.  Каждый элемент должен
иметь такую форму:

@example
(@var{characters} . @var{syntax-description})
@end example

@sc{car}, @var{characters}, может быть как символом, так и строкой.  Элемент
говорит, что нужно дать этому символу или символам синтаксис, указанный в
@var{syntax-description}, который передается в @code{modify-syntax-entry}
(@pxref{Syntax Table Functions}).

Эта функция обычно используется для придания синтаксиса слов символам,
которые обычно имеют синтаксис символа, и, таким образом, упрощают
@code{imenu-generic-expression} и ускоряют сопоставление.  Например, режим
Fortran использует это так:

@example
(setq imenu-syntax-alist '(("_$" . "w")))
@end example

Тогда регулярные выражения @code{imenu-generic-expression} могут
использовать @samp{\sw+} вместо @samp{\(\sw\|\s_\)+}.  Обратить внимание,
что этот метод может быть неудобным, когда режим должен ограничить начальный
символ имени меньшим набором символов, чем разрешено в остальной части
имени.

Установка этой переменной делает ее локальной в текущем буфере.
@end defvar

  Другой способ настроить Imenu для основного режима - установить переменные
@code{imenu-prev-index-position-function} и
@code{imenu-extract-index-name-function}.:

@defvar imenu-prev-index-position-function
Если эта переменная - не-@code{nil}, ее значение должно быть функцией,
которая находит следующее определение для размещения в индексе буфера,
просматривая в обратном направлении буфер от точки.  Должна вернуть
@code{nil}, если не находит другое определение перед точкой.  В противном
случае должна оставить точку в том месте, где находит определение, и вернуть
любое значение не-@code{nil}.

Установка этой переменной делает её локальной в текущем буфере.
@end defvar

@defvar imenu-extract-index-name-function
Если эта переменная - не-@code{nil}, ее значение должно быть функцией,
возвращающей имя для определения, при условии, что точка находится в этом
определении, поскольку функция @code{imenu-prev-index-position-function}
оставит его.

Установка этой переменной делает ее локальной в текущем буфере.
@end defvar

  Последний способ настроить Imenu для основного режима - установить
переменную @code{imenu-create-index-function}:

@defvar imenu-create-index-function
Эта переменная определяет функцию, используемую для создания индекса буфера.
Функция не должна принимать аргументов и возвращать список индексов для
текущего буфера.  Она вызывается внутри @code{save-excursion}, поэтому, где
оставляет точку, не имеет значения.

Список индексов может иметь три типа элементов.  Простые элементы выглядят
так:

@example
(@var{index-name} . @var{index-position})
@end example

Выбор простого элемента приводит к перемещению в позицию
@var{index-position} в буфере.  Специальные элементы выглядят так:

@example
(@var{index-name} @var{index-position} @var{function} @var{arguments}@dots{})
@end example

Выбор специального элемента выполняет:

@example
(funcall @var{function}
         @var{index-name} @var{index-position} @var{arguments}@dots{})
@end example

Вложенный элемент вспомогательного списка выглядит так:

@example
(@var{menu-title} . @var{sub-alist})
@end example

Создает подменю @var{menu-title}, заданное параметром @var{sub-alist}.

Значение по умолчанию @code{imenu-create-index-function} -
@code{imenu-default-create-index-function}.  Эта функция вызывает значение
@code{imenu-prev-index-position-function} и значение
@code{imenu-extract-index-name-function} для создания списка индексов.
Однако, если одна из этих двух переменных - @code{nil}, функция по умолчанию
использует вместо этого @code{imenu-generic-expression}.

Установка этой переменной делает ее локальной в текущем буфере.
@end defvar

@node Font Lock Mode
@section Режим Блокировки Шрифта
@cindex Font Lock mode

  @dfn{Режим блокировки шрифта} - это второстепенный локальный режим буфера,
который автоматически прикрепляет свойства @code{face} к определенным
частям буфера в зависимости от их синтаксической роли.  Как анализирует
буфер, зависит от основного режима; большинство основных режимов определяют
синтаксические критерии того, какие внешние виды использовать в каком
контексте.  В этом разделе объясняется, как настроить блокировку шрифта для
определенного основного режима.

  В режиме Font Lock текст для выделения выделяется двумя способами:
посредством синтаксического анализа на основе таблицы синтаксиса и
посредством поиска (обычно для регулярных выражений).  Сначала происходит
синтаксическая фонификация; находит комментарии и строковые константы и
выделяет их.  Во-вторых, фонтификация на основе поиска.

@menu
* Font Lock Basics::            Обзор настройки Font Lock.
* Search-based Fontification::  Фонтификация на основе регулярных выражений.
* Customizing Keywords::        Настройка фонетизации на основе поиска.
* Other Font Lock Variables::   Дополнительные возможности настройки.
* Levels of Font Lock::         Каждый режим может определять альтернативные
                                  уровни, чтобы пользователь мог выбрать
                                  большие или меньшие уровни.
* Precalculated Fontification::  Как программы Lisp, которые создают
                                    содержимое буфера, также могут
                                    указывать, как его фонировать.
* Faces for Font Lock::         Специальные грани специально для Font Lock.
* Syntactic Font Lock::        Фонтификация на основе синтаксических таблиц.
* Multiline Font Lock::         Как заставить Font Lock правильно выделять
                                    многострочные конструкции.
@end menu

@node Font Lock Basics
@subsection Font Lock Basics

  The Font Lock functionality is based on several basic functions.
Each of these calls the function specified by the corresponding
variable.  This indirection allows major and minor modes to modify the
way fontification works in the buffers of that mode, and even use the
Font Lock mechanisms for features that have nothing to do with
fontification.  (This is why the description below says ``should''
when it describes what the functions do: the mode can customize the
values of the corresponding variables to do something entirely
different.)  The variables mentioned below are described in @ref{Other
Font Lock Variables}.

@ftable @code
@item font-lock-fontify-buffer
This function should fontify the current buffer's accessible portion,
by calling the function specified by
@code{font-lock-fontify-buffer-function}.

@item font-lock-unfontify-buffer
Used when turning Font Lock off to remove the fontification.  Calls
the function specified by @code{font-lock-unfontify-buffer-function}.

@item font-lock-fontify-region beg end &optional loudly
Should fontify the region between @var{beg} and @var{end}.  If
@var{loudly} is не-@code{nil}, should display status messages while
fontifying.  Calls the function specified by
@code{font-lock-fontify-region-function}.

@item font-lock-unfontify-region beg end
Should remove fontification from the region between @var{beg} and
@var{end}.  Calls the function specified by
@code{font-lock-unfontify-region-function}.

@item font-lock-flush &optional beg end
This function should mark the fontification of the region between
@var{beg} and @var{end} as outdated.  If not specified or @code{nil},
@var{beg} and @var{end} default to the beginning and end of the
buffer's accessible portion.  Calls the function specified by
@code{font-lock-flush-function}.

@item font-lock-ensure &optional beg end
This function should make sure the region between @var{beg} and
@var{end} has been fontified.  The optional arguments @var{beg} and
@var{end} default to the beginning and the end of the buffer's
accessible portion.  Calls the function specified by
@code{font-lock-ensure-function}.
@end ftable

  There are several variables that control how Font Lock mode highlights
text.  But major modes should not set any of these variables directly.
Instead, they should set @code{font-lock-defaults} as a buffer-local
variable.  The value assigned to this variable is used, if and when Font
Lock mode is enabled, to set all the other variables.

@defvar font-lock-defaults
This variable is set by modes to specify how to fontify text in that
mode.  It automatically becomes buffer-local when set.  If its value
is @code{nil}, Font Lock mode does no highlighting, and you can use
the @samp{Faces} menu (under @samp{Edit} and then @samp{Text
Properties} in the menu bar) to assign faces explicitly to text in the
buffer.

If не-@code{nil}, the value should look like this:

@example
(@var{keywords} [@var{keywords-only} [@var{case-fold}
 [@var{syntax-alist} @var{other-vars}@dots{}]]])
@end example

The first element, @var{keywords}, indirectly specifies the value of
@code{font-lock-keywords} which directs search-based fontification.
It can be a symbol, a variable or a function whose value is the list
to use for @code{font-lock-keywords}.  It can also be a list of
several such symbols, one for each possible level of fontification.
The first symbol specifies the @samp{mode default} level of
fontification, the next symbol level 1 fontification, the next level 2,
and so on.  The @samp{mode default} level is normally the same as level
1.  It is used when @code{font-lock-maximum-decoration} has a @code{nil}
value.  @xref{Levels of Font Lock}.

The second element, @var{keywords-only}, specifies the value of the
variable @code{font-lock-keywords-only}.  If this is omitted or
@code{nil}, syntactic fontification (of strings and comments) is also
performed.  If this is не-@code{nil}, syntactic fontification is not
performed.  @xref{Syntactic Font Lock}.

The third element, @var{case-fold}, specifies the value of
@code{font-lock-keywords-case-fold-search}.  If it is не-@code{nil},
Font Lock mode ignores case during search-based fontification.

If the fourth element, @var{syntax-alist}, is не-@code{nil}, it should
be a list of cons cells of the form @code{(@var{char-or-string}
. @var{string})}.  These are used to set up a syntax table for syntactic
fontification; the resulting syntax table is stored in
@code{font-lock-syntax-table}.  If @var{syntax-alist} is omitted or
@code{nil}, syntactic fontification uses the syntax table returned by
the @code{syntax-table} function.  @xref{Syntax Table Functions}.

All the remaining elements (if any) are collectively called
@var{other-vars}.  Each of these elements should have the form
@code{(@var{variable} . @var{value})}---which means, make
@var{variable} buffer-local and then set it to @var{value}.  You can
use these @var{other-vars} to set other variables that affect
fontification, aside from those you can control with the first five
elements.  @xref{Other Font Lock Variables}.
@end defvar

  If your mode fontifies text explicitly by adding
@code{font-lock-face} properties, it can specify @code{(nil t)} for
@code{font-lock-defaults} to turn off all automatic fontification.
However, this is not required; it is possible to fontify some things
using @code{font-lock-face} properties and set up automatic
fontification for other parts of the text.

@node Search-based Fontification
@subsection Search-based Fontification

  The variable which directly controls search-based fontification is
@code{font-lock-keywords}, which is typically specified via the
@var{keywords} element in @code{font-lock-defaults}.

@defvar font-lock-keywords
The value of this variable is a list of the keywords to highlight.  Lisp
programs should not set this variable directly.  Normally, the value is
automatically set by Font Lock mode, using the @var{keywords} element in
@code{font-lock-defaults}.  The value can also be altered using the
functions @code{font-lock-add-keywords} and
@code{font-lock-remove-keywords} (@pxref{Customizing Keywords}).
@end defvar

  Each element of @code{font-lock-keywords} specifies how to find
certain cases of text, and how to highlight those cases.  Font Lock mode
processes the elements of @code{font-lock-keywords} one by one, and for
each element, it finds and handles all matches.  Ordinarily, once
part of the text has been fontified already, this cannot be overridden
by a subsequent match in the same text; but you can specify different
behavior using the @var{override} element of a @var{subexp-highlighter}.

  Each element of @code{font-lock-keywords} should have one of these
forms:

@table @code
@item @var{regexp}
Highlight all matches for @var{regexp} using
@code{font-lock-keyword-face}.  For example,

@example
;; @r{Highlight occurrences of the word @samp{foo}}
;; @r{using @code{font-lock-keyword-face}.}
"\\<foo\\>"
@end example

Be careful when composing these regular expressions; a poorly written
pattern can dramatically slow things down!  The function
@code{regexp-opt} (@pxref{Regexp Functions}) is useful for calculating
optimal regular expressions to match several keywords.

@item @var{function}
Find text by calling @var{function}, and highlight the matches
it finds using @code{font-lock-keyword-face}.

When @var{function} is called, it receives one argument, the limit of
the search; it should begin searching at point, and not search beyond the
limit.  It should return не-@code{nil} if it succeeds, and set the
match data to describe the match that was found.  Returning @code{nil}
indicates failure of the search.

Fontification will call @var{function} repeatedly with the same limit,
and with point where the previous invocation left it, until
@var{function} fails.  On failure, @var{function} need not reset point
in any particular way.

@item (@var{matcher} . @var{subexp})
In this kind of element, @var{matcher} is either a regular
expression or a function, as described above.  The @sc{cdr},
@var{subexp}, specifies which subexpression of @var{matcher} should be
highlighted (instead of the entire text that @var{matcher} matched).

@example
;; @r{Highlight the @samp{bar} in each occurrence of @samp{fubar},}
;; @r{using @code{font-lock-keyword-face}.}
("fu\\(bar\\)" . 1)
@end example

If you use @code{regexp-opt} to produce the regular expression
@var{matcher}, you can use @code{regexp-opt-depth} (@pxref{Regexp
Functions}) to calculate the value for @var{subexp}.

@item (@var{matcher} . @var{facespec})
In this kind of element, @var{facespec} is an expression whose value
specifies the face to use for highlighting.  In the simplest case,
@var{facespec} is a Lisp variable (a symbol) whose value is a face
name.

@example
;; @r{Highlight occurrences of @samp{fubar},}
;; @r{using the face which is the value of @code{fubar-face}.}
("fubar" . fubar-face)
@end example

However, @var{facespec} can also evaluate to a list of this form:

@example
(face @var{face} @var{prop1} @var{val1} @var{prop2} @var{val2}@dots{})
@end example

@noindent
to specify the face @var{face} and various additional text properties
to put on the text that matches.  If you do this, be sure to add the
other text property names that you set in this way to the value of
@code{font-lock-extra-managed-props} so that the properties will also
be cleared out when they are no longer appropriate.  Alternatively,
you can set the variable @code{font-lock-unfontify-region-function} to
a function that clears these properties.  @xref{Other Font Lock
Variables}.

@item (@var{matcher} . @var{subexp-highlighter})
In this kind of element, @var{subexp-highlighter} is a list
which specifies how to highlight matches found by @var{matcher}.
It has the form:

@example
(@var{subexp} @var{facespec} [@var{override} [@var{laxmatch}]])
@end example

The @sc{car}, @var{subexp}, is an integer specifying which subexpression
of the match to fontify (0 means the entire matching text).  The second
subelement, @var{facespec}, is an expression whose value specifies the
face, as described above.

The last two values in @var{subexp-highlighter}, @var{override} and
@var{laxmatch}, are optional flags.  If @var{override} is @code{t},
this element can override existing fontification made by previous
elements of @code{font-lock-keywords}.  If it is @code{keep}, then
each character is fontified if it has not been fontified already by
some other element.  If it is @code{prepend}, the face specified by
@var{facespec} is added to the beginning of the @code{font-lock-face}
property.  If it is @code{append}, the face is added to the end of the
@code{font-lock-face} property.

If @var{laxmatch} is не-@code{nil}, it means there should be no error
if there is no subexpression numbered @var{subexp} in @var{matcher}.
Obviously, fontification of the subexpression numbered @var{subexp} will
not occur.  However, fontification of other subexpressions (and other
regexps) will continue.  If @var{laxmatch} is @code{nil}, and the
specified subexpression is missing, then an error is signaled which
terminates search-based fontification.

Here are some examples of elements of this kind, and what they do:

@smallexample
;; @r{Highlight occurrences of either @samp{foo} or @samp{bar}, using}
;; @r{@code{foo-bar-face}, even if they have already been highlighted.}
;; @r{@code{foo-bar-face} should be a variable whose value is a face.}
("foo\\|bar" 0 foo-bar-face t)

;; @r{Highlight the first subexpression within each occurrence}
;; @r{that the function @code{fubar-match} finds,}
;; @r{using the face which is the value of @code{fubar-face}.}
(fubar-match 1 fubar-face)
@end smallexample

@item (@var{matcher} . @var{anchored-highlighter})
In this kind of element, @var{anchored-highlighter} specifies how to
highlight text that follows a match found by @var{matcher}.  So a
match found by @var{matcher} acts as the anchor for further searches
specified by @var{anchored-highlighter}.  @var{anchored-highlighter}
is a list of the following form:

@example
(@var{anchored-matcher} @var{pre-form} @var{post-form}
                        @var{subexp-highlighters}@dots{})
@end example

Here, @var{anchored-matcher}, like @var{matcher}, is either a regular
expression or a function.  After a match of @var{matcher} is found,
point is at the end of the match.  Now, Font Lock evaluates the form
@var{pre-form}.  Then it searches for matches of
@var{anchored-matcher} and uses @var{subexp-highlighters} to highlight
these.  A @var{subexp-highlighter} is as described above.  Finally,
Font Lock evaluates @var{post-form}.

The forms @var{pre-form} and @var{post-form} can be used to initialize
before, and cleanup after, @var{anchored-matcher} is used.  Typically,
@var{pre-form} is used to move point to some position relative to the
match of @var{matcher}, before starting with @var{anchored-matcher}.
@var{post-form} might be used to move back, before resuming with
@var{matcher}.

After Font Lock evaluates @var{pre-form}, it does not search for
@var{anchored-matcher} beyond the end of the line.  However, if
@var{pre-form} returns a buffer position that is greater than the
position of point after @var{pre-form} is evaluated, then the position
returned by @var{pre-form} is used as the limit of the search instead.
It is generally a bad idea to return a position greater than the end
of the line; in other words, the @var{anchored-matcher} search should
not span lines.

For example,

@smallexample
;; @r{Highlight occurrences of the word @samp{item} following}
;; @r{an occurrence of the word @samp{anchor} (on the same line)}
;; @r{in the value of @code{item-face}.}
("\\<anchor\\>" "\\<item\\>" nil nil (0 item-face))
@end smallexample

Here, @var{pre-form} and @var{post-form} are @code{nil}.  Therefore
searching for @samp{item} starts at the end of the match of
@samp{anchor}, and searching for subsequent instances of @samp{anchor}
resumes from where searching for @samp{item} concluded.

@item (@var{matcher} @var{highlighters}@dots{})
This sort of element specifies several @var{highlighter} lists for a
single @var{matcher}.  A @var{highlighter} list can be of the type
@var{subexp-highlighter} or @var{anchored-highlighter} as described
above.

For example,

@smallexample
;; @r{Highlight occurrences of the word @samp{anchor} in the value}
;; @r{of @code{anchor-face}, and subsequent occurrences of the word}
;; @r{@samp{item} (on the same line) in the value of @code{item-face}.}
("\\<anchor\\>" (0 anchor-face)
                ("\\<item\\>" nil nil (0 item-face)))
@end smallexample

@item (eval . @var{form})
Here @var{form} is an expression to be evaluated the first time
this value of @code{font-lock-keywords} is used in a buffer.
Its value should have one of the forms described in this table.
@end table

@strong{Warning:} Do not design an element of @code{font-lock-keywords}
to match text which spans lines; this does not work reliably.
For details, @pxref{Multiline Font Lock}.

You can use @var{case-fold} in @code{font-lock-defaults} to specify
the value of @code{font-lock-keywords-case-fold-search} which says
whether search-based fontification should be case-insensitive.

@defvar font-lock-keywords-case-fold-search
не-@code{nil} means that regular expression matching for the sake of
@code{font-lock-keywords} should be case-insensitive.
@end defvar

@node Customizing Keywords
@subsection Customizing Search-Based Fontification

  You can use @code{font-lock-add-keywords} to add additional
search-based fontification rules to a major mode, and
@code{font-lock-remove-keywords} to remove rules.

@defun font-lock-add-keywords mode keywords &optional how
This function adds highlighting @var{keywords}, for the current buffer
or for major mode @var{mode}.  The argument @var{keywords} should be a
list with the same format as the variable @code{font-lock-keywords}.

If @var{mode} is a symbol which is a major mode command name, such as
@code{c-mode}, the effect is that enabling Font Lock mode in
@var{mode} will add @var{keywords} to @code{font-lock-keywords}.
Calling with a не-@code{nil} value of @var{mode} is correct only in
your @file{~/.emacs} file.

If @var{mode} is @code{nil}, this function adds @var{keywords} to
@code{font-lock-keywords} in the current buffer.  This way of calling
@code{font-lock-add-keywords} is usually used in mode hook functions.

By default, @var{keywords} are added at the beginning of
@code{font-lock-keywords}.  If the optional argument @var{how} is
@code{set}, they are used to replace the value of
@code{font-lock-keywords}.  If @var{how} is any other не-@code{nil}
value, they are added at the end of @code{font-lock-keywords}.

Some modes provide specialized support you can use in additional
highlighting patterns.  See the variables
@code{c-font-lock-extra-types}, @code{c++-font-lock-extra-types},
and @code{java-font-lock-extra-types}, for example.

@strong{Warning:} Major mode commands must not call
@code{font-lock-add-keywords} under any circumstances, either directly
or indirectly, except through their mode hooks.  (Doing so would lead to
incorrect behavior for some minor modes.)  They should set up their
rules for search-based fontification by setting
@code{font-lock-keywords}.
@end defun

@defun font-lock-remove-keywords mode keywords
This function removes @var{keywords} from @code{font-lock-keywords}
for the current buffer or for major mode @var{mode}.  As in
@code{font-lock-add-keywords}, @var{mode} should be a major mode
command name or @code{nil}.  All the caveats and requirements for
@code{font-lock-add-keywords} apply here too.  The argument
@var{keywords} must exactly match the one used by the corresponding
@code{font-lock-add-keywords}.
@end defun

  For example, the following code adds two fontification patterns for C
mode: one to fontify the word @samp{FIXME}, even in comments, and
another to fontify the words @samp{and}, @samp{or} and @samp{not} as
keywords.

@smallexample
(font-lock-add-keywords 'c-mode
 '(("\\<\\(FIXME\\):" 1 font-lock-warning-face prepend)
   ("\\<\\(and\\|or\\|not\\)\\>" . font-lock-keyword-face)))
@end smallexample

@noindent
This example affects only C mode proper.  To add the same patterns to C
mode @emph{and} all modes derived from it, do this instead:

@smallexample
(add-hook 'c-mode-hook
 (lambda ()
  (font-lock-add-keywords nil
   '(("\\<\\(FIXME\\):" 1 font-lock-warning-face prepend)
     ("\\<\\(and\\|or\\|not\\)\\>" .
      font-lock-keyword-face)))))
@end smallexample

@node Other Font Lock Variables
@subsection Other Font Lock Variables

  This section describes additional variables that a major mode can
set by means of @var{other-vars} in @code{font-lock-defaults}
(@pxref{Font Lock Basics}).

@defvar font-lock-mark-block-function
If this variable is не-@code{nil}, it should be a function that is
called with no arguments, to choose an enclosing range of text for
refontification for the command @kbd{M-o M-o}
(@code{font-lock-fontify-block}).

The function should report its choice by placing the region around it.
A good choice is a range of text large enough to give proper results,
but not too large so that refontification becomes slow.  Typical values
are @code{mark-defun} for programming modes or @code{mark-paragraph} for
textual modes.
@end defvar

@defvar font-lock-extra-managed-props
This variable specifies additional properties (other than
@code{font-lock-face}) that are being managed by Font Lock mode.  It
is used by @code{font-lock-default-unfontify-region}, which normally
only manages the @code{font-lock-face} property.  If you want Font
Lock to manage other properties as well, you must specify them in a
@var{facespec} in @code{font-lock-keywords} as well as add them to
this list.  @xref{Search-based Fontification}.
@end defvar

@defvar font-lock-fontify-buffer-function
Function to use for fontifying the buffer.  The default value is
@code{font-lock-default-fontify-buffer}.
@end defvar

@defvar font-lock-unfontify-buffer-function
Function to use for unfontifying the buffer.  This is used when
turning off Font Lock mode.  The default value is
@code{font-lock-default-unfontify-buffer}.
@end defvar

@defvar font-lock-fontify-region-function
Function to use for fontifying a region.  It should take two
arguments, the beginning and end of the region, and an optional third
argument @var{verbose}.  If @var{verbose} is не-@code{nil}, the
function should print status messages.  The default value is
@code{font-lock-default-fontify-region}.
@end defvar

@defvar font-lock-unfontify-region-function
Function to use for unfontifying a region.  It should take two
arguments, the beginning and end of the region.  The default value is
@code{font-lock-default-unfontify-region}.
@end defvar

@defvar font-lock-flush-function
Function to use for declaring that a region's fontification is out of
date.  It takes two arguments, the beginning and end of the region.
The default value of this variable is
@code{font-lock-after-change-function}.
@end defvar

@defvar font-lock-ensure-function
Function to use for making sure a region of the current buffer has
been fontified.  It is called with two arguments, the beginning and
end of the region.  The default value of this variable is a function
that calls @code{font-lock-default-fontify-buffer} if the buffer is
not fontified; the effect is to make sure the entire accessible
portion of the buffer is fontified.
@end defvar

@defun jit-lock-register function &optional contextual
This function tells Font Lock mode to run the Lisp function
@var{function} any time it has to fontify or refontify part of the
current buffer.  It calls @var{function} before calling the default
fontification functions, and gives it two arguments, @var{start} and
@var{end}, which specify the region to be fontified or refontified.

The optional argument @var{contextual}, if не-@code{nil}, forces Font
Lock mode to always refontify a syntactically relevant part of the
buffer, and not just the modified lines.  This argument can usually be
omitted.
@end defun

@defun jit-lock-unregister function
If @var{function} was previously registered as a fontification
function using @code{jit-lock-register}, this function unregisters it.
@end defun

@node Levels of Font Lock
@subsection Levels of Font Lock

  Some major modes offer three different levels of fontification.  You
can define multiple levels by using a list of symbols for @var{keywords}
in @code{font-lock-defaults}.  Each symbol specifies one level of
fontification; it is up to the user to choose one of these levels,
normally by setting @code{font-lock-maximum-decoration} (@pxref{Font
Lock,,, emacs, the GNU Emacs Manual}).  The chosen level's symbol value
is used to initialize @code{font-lock-keywords}.

  Here are the conventions for how to define the levels of
fontification:

@itemize @bullet
@item
Level 1: highlight function declarations, file directives (such as include or
import directives), strings and comments.  The idea is speed, so only
the most important and top-level components are fontified.

@item
Level 2: in addition to level 1, highlight all language keywords,
including type names that act like keywords, as well as named constant
values.  The idea is that all keywords (either syntactic or semantic)
should be fontified appropriately.

@item
Level 3: in addition to level 2, highlight the symbols being defined in
function and variable declarations, and all builtin function names,
wherever they appear.
@end itemize

@node Precalculated Fontification
@subsection Precalculated Fontification

  Some major modes such as @code{list-buffers} and @code{occur}
construct the buffer text programmatically.  The easiest way for them
to support Font Lock mode is to specify the faces of text when they
insert the text in the buffer.

  The way to do this is to specify the faces in the text with the
special text property @code{font-lock-face} (@pxref{Special
Properties}).  When Font Lock mode is enabled, this property controls
the display, just like the @code{face} property.  When Font Lock mode
is disabled, @code{font-lock-face} has no effect on the display.

  It is ok for a mode to use @code{font-lock-face} for some text and
also use the normal Font Lock machinery.  But if the mode does not use
the normal Font Lock machinery, it should not set the variable
@code{font-lock-defaults}.  In this case the @code{face} property will
not be overriden, so using the @code{face} property could work too.
However, using @code{font-lock-face} is generally preferable as it
allows the user to control the fontification by toggling
@code{font-lock-mode}, and lets the code work regardless of whether
the mode uses Font Lock machinery or not.

@node Faces for Font Lock
@subsection Faces for Font Lock
@cindex faces for font lock
@cindex font lock faces

  Font Lock mode can highlight using any face, but Emacs defines several
faces specifically for Font Lock to use to highlight text.  These
@dfn{Font Lock faces} are listed below.  They can also be used by major
modes for syntactic highlighting outside of Font Lock mode (@pxref{Major
Mode Conventions}).

  Each of these symbols is both a face name, and a variable whose
default value is the symbol itself.  Thus, the default value of
@code{font-lock-comment-face} is @code{font-lock-comment-face}.

  The faces are listed with descriptions of their typical usage, and in
order of greater to lesser prominence.  If a mode's syntactic
categories do not fit well with the usage descriptions, the faces can be
assigned using the ordering as a guide.

@table @code
@item font-lock-warning-face
@vindex font-lock-warning-face
for a construct that is peculiar, or that greatly changes the meaning of
other text, like @samp{;;;###autoload} in Emacs Lisp and @samp{#error}
in C.

@item font-lock-function-name-face
@vindex font-lock-function-name-face
for the name of a function being defined or declared.

@item font-lock-variable-name-face
@vindex font-lock-variable-name-face
for the name of a variable being defined or declared.

@item font-lock-keyword-face
@vindex font-lock-keyword-face
for a keyword with special syntactic significance, like @samp{for} and
@samp{if} in C.

@item font-lock-comment-face
@vindex font-lock-comment-face
for comments.

@item font-lock-comment-delimiter-face
@vindex font-lock-comment-delimiter-face
for comments delimiters, like @samp{/*} and @samp{*/} in C@.  On most
terminals, this inherits from @code{font-lock-comment-face}.

@item font-lock-type-face
@vindex font-lock-type-face
for the names of user-defined data types.

@item font-lock-constant-face
@vindex font-lock-constant-face
for the names of constants, like @samp{NULL} in C.

@item font-lock-builtin-face
@vindex font-lock-builtin-face
for the names of built-in functions.

@item font-lock-preprocessor-face
@vindex font-lock-preprocessor-face
for preprocessor commands.  This inherits, by default, from
@code{font-lock-builtin-face}.

@item font-lock-string-face
@vindex font-lock-string-face
for string constants.

@item font-lock-doc-face
@vindex font-lock-doc-face
for documentation strings in the code.  This inherits, by default, from
@code{font-lock-string-face}.

@item font-lock-negation-char-face
@vindex font-lock-negation-char-face
for easily-overlooked negation characters.
@end table

@node Syntactic Font Lock
@subsection Syntactic Font Lock
@cindex syntactic font lock

Syntactic fontification uses a syntax table (@pxref{Syntax Tables}) to
find and highlight syntactically relevant text.  If enabled, it runs
prior to search-based fontification.  The variable
@code{font-lock-syntactic-face-function}, documented below, determines
which syntactic constructs to highlight.  There are several variables
that affect syntactic fontification; you should set them by means of
@code{font-lock-defaults} (@pxref{Font Lock Basics}).

  Whenever Font Lock mode performs syntactic fontification on a stretch
of text, it first calls the function specified by
@code{syntax-propertize-function}.  Major modes can use this to apply
@code{syntax-table} text properties to override the buffer's syntax
table in special cases.  @xref{Syntax Properties}.

@defvar font-lock-keywords-only
If the value of this variable is не-@code{nil}, Font Lock does not do
syntactic fontification, only search-based fontification based on
@code{font-lock-keywords}.  It is normally set by Font Lock mode based
on the @var{keywords-only} element in @code{font-lock-defaults}.
@end defvar

@defvar font-lock-syntax-table
This variable holds the syntax table to use for fontification of
comments and strings.  It is normally set by Font Lock mode based on the
@var{syntax-alist} element in @code{font-lock-defaults}.  If this value
is @code{nil}, syntactic fontification uses the buffer's syntax table
(the value returned by the function @code{syntax-table}; @pxref{Syntax
Table Functions}).
@end defvar

@defvar font-lock-syntactic-face-function
If this variable is не-@code{nil}, it should be a function to determine
which face to use for a given syntactic element (a string or a comment).
The value is normally set through an @var{other-vars} element in
@code{font-lock-defaults}.

The function is called with one argument, the parse state at point
returned by @code{parse-partial-sexp}, and should return a face.  The
default value returns @code{font-lock-comment-face} for comments and
@code{font-lock-string-face} for strings (@pxref{Faces for Font Lock}).
@end defvar

@node Multiline Font Lock
@subsection Multiline Font Lock Constructs
@cindex multiline font lock

  Normally, elements of @code{font-lock-keywords} should not match
across multiple lines; that doesn't work reliably, because Font Lock
usually scans just part of the buffer, and it can miss a multi-line
construct that crosses the line boundary where the scan starts.  (The
scan normally starts at the beginning of a line.)

  Making elements that match multiline constructs work properly has
two aspects: correct @emph{identification} and correct
@emph{rehighlighting}.  The first means that Font Lock finds all
multiline constructs.  The second means that Font Lock will correctly
rehighlight all the relevant text when a multiline construct is
changed---for example, if some of the text that was previously part of
a multiline construct ceases to be part of it.  The two aspects are
closely related, and often getting one of them to work will appear to
make the other also work.  However, for reliable results you must
attend explicitly to both aspects.

  There are three ways to ensure correct identification of multiline
constructs:

@itemize
@item
Add a function to @code{font-lock-extend-region-functions} that does
the @emph{identification} and extends the scan so that the scanned
text never starts or ends in the middle of a multiline construct.
@item
Use the @code{font-lock-fontify-region-function} hook similarly to
extend the scan so that the scanned text never starts or ends in the
middle of a multiline construct.
@item
Somehow identify the multiline construct right when it gets inserted
into the buffer (or at any point after that but before font-lock
tries to highlight it), and mark it with a @code{font-lock-multiline}
which will instruct font-lock not to start or end the scan in the
middle of the construct.
@end itemize

  There are three ways to do rehighlighting of multiline constructs:

@itemize
@item
Place a @code{font-lock-multiline} property on the construct.  This
will rehighlight the whole construct if any part of it is changed.  In
some cases you can do this automatically by setting the
@code{font-lock-multiline} variable, which see.
@item
Make sure @code{jit-lock-contextually} is set and rely on it doing its
job.  This will only rehighlight the part of the construct that
follows the actual change, and will do it after a short delay.
This only works if the highlighting of the various parts of your
multiline construct never depends on text in subsequent lines.
Since @code{jit-lock-contextually} is activated by default, this can
be an attractive solution.
@item
Place a @code{jit-lock-defer-multiline} property on the construct.
This works only if @code{jit-lock-contextually} is used, and with the
same delay before rehighlighting, but like @code{font-lock-multiline},
it also handles the case where highlighting depends on
subsequent lines.
@end itemize

@menu
* Font Lock Multiline::         Marking multiline chunks with a text property.
* Region to Refontify::         Controlling which region gets refontified
                                  after a buffer change.
@end menu

@node Font Lock Multiline
@subsubsection Font Lock Multiline

  One way to ensure reliable rehighlighting of multiline Font Lock
constructs is to put on them the text property @code{font-lock-multiline}.
It should be present and не-@code{nil} for text that is part of a
multiline construct.

  When Font Lock is about to highlight a range of text, it first
extends the boundaries of the range as necessary so that they do not
fall within text marked with the @code{font-lock-multiline} property.
Then it removes any @code{font-lock-multiline} properties from the
range, and highlights it.  The highlighting specification (mostly
@code{font-lock-keywords}) must reinstall this property each time,
whenever it is appropriate.

  @strong{Warning:} don't use the @code{font-lock-multiline} property
on large ranges of text, because that will make rehighlighting slow.

@defvar font-lock-multiline
If the @code{font-lock-multiline} variable is set to @code{t}, Font
Lock will try to add the @code{font-lock-multiline} property
automatically on multiline constructs.  This is not a universal
solution, however, since it slows down Font Lock somewhat.  It can
miss some multiline constructs, or make the property larger or smaller
than necessary.

For elements whose @var{matcher} is a function, the function should
ensure that submatch 0 covers the whole relevant multiline construct,
even if only a small subpart will be highlighted.  It is often just as
easy to add the @code{font-lock-multiline} property by hand.
@end defvar

  The @code{font-lock-multiline} property is meant to ensure proper
refontification; it does not automatically identify new multiline
constructs.  Identifying them requires that Font Lock mode operate on
large enough chunks at a time.  This will happen by accident on many
cases, which may give the impression that multiline constructs magically
work.  If you set the @code{font-lock-multiline} variable
не-@code{nil}, this impression will be even stronger, since the
highlighting of those constructs which are found will be properly
updated from then on.  But that does not work reliably.

  To find multiline constructs reliably, you must either manually place
the @code{font-lock-multiline} property on the text before Font Lock
mode looks at it, or use @code{font-lock-fontify-region-function}.

@node Region to Refontify
@subsubsection Region to Fontify after a Buffer Change

  When a buffer is changed, the region that Font Lock refontifies is
by default the smallest sequence of whole lines that spans the change.
While this works well most of the time, sometimes it doesn't---for
example, when a change alters the syntactic meaning of text on an
earlier line.

  You can enlarge (or even reduce) the region to refontify by setting
the following variable:

@defvar font-lock-extend-after-change-region-function
This buffer-local variable is either @code{nil} or a function for Font
Lock mode to call to determine the region to scan and fontify.

The function is given three parameters, the standard @var{beg},
@var{end}, and @var{old-len} from @code{after-change-functions}
(@pxref{Change Hooks}).  It should return either a cons of the
beginning and end buffer positions (in that order) of the region to
fontify, or @code{nil} (which means choose the region in the standard
way).  This function needs to preserve point, the match-data, and the
current restriction.  The region it returns may start or end in the
middle of a line.

Since this function is called after every buffer change, it should be
reasonably fast.
@end defvar

@node Auto-Indentation
@section Automatic Indentation of code

For programming languages, an important feature of a major mode is to
provide automatic indentation.  There are two parts: one is to decide what
is the right indentation of a line, and the other is to decide when to
reindent a line.  By default, Emacs reindents a line whenever you
type a character in @code{electric-indent-chars}, which by default only
includes Newline.  Major modes can add chars to @code{electric-indent-chars}
according to the syntax of the language.

Deciding what is the right indentation is controlled in Emacs by
@code{indent-line-function} (@pxref{Mode-Specific Indent}).  For some modes,
the @emph{right} indentation cannot be known reliably, typically because
indentation is significant so several indentations are valid but with different
meanings.  In that case, the mode should set @code{electric-indent-inhibit} to
make sure the line is not constantly re-indented against the user's wishes.

Writing a good indentation function can be difficult and to a large extent it
is still a black art.  Many major mode authors will start by writing a simple
indentation function that works for simple cases, for example by comparing with
the indentation of the previous text line.  For most programming languages that
are not really line-based, this tends to scale very poorly: improving
such a function to let it handle more diverse situations tends to become more
and more difficult, resulting in the end with a large, complex, unmaintainable
indentation function which nobody dares to touch.

A good indentation function will usually need to actually parse the
text, according to the syntax of the language.  Luckily, it is not
necessary to parse the text in as much detail as would be needed
for a compiler, but on the other hand, the parser embedded in the
indentation code will want to be somewhat friendly to syntactically
incorrect code.

Good maintainable indentation functions usually fall into two categories:
either parsing forward from some safe starting point until the
position of interest, or parsing backward from the position of interest.
Neither of the two is a clearly better choice than the other: parsing
backward is often more difficult than parsing forward because
programming languages are designed to be parsed forward, but for the
purpose of indentation it has the advantage of not needing to
guess a safe starting point, and it generally enjoys the property
that only a minimum of text will be analyzed to decide the indentation
of a line, so indentation will tend to be less affected by syntax errors in
some earlier unrelated piece of code.  Parsing forward on the other hand
is usually easier and has the advantage of making it possible to
reindent efficiently a whole region at a time, with a single parse.

Rather than write your own indentation function from scratch, it is
often preferable to try and reuse some existing ones or to rely
on a generic indentation engine.  There are sadly few such
engines.  The CC-mode indentation code (used with C, C++, Java, Awk
and a few other such modes) has been made more generic over the years,
so if your language seems somewhat similar to one of those languages,
you might try to use that engine.  @c FIXME: documentation?
Another one is SMIE which takes an approach in the spirit
of Lisp sexps and adapts it to non-Lisp languages.

@menu
* SMIE::                        A simple minded indentation engine.
@end menu

@node SMIE
@subsection Simple Minded Indentation Engine
@cindex SMIE

SMIE is a package that provides a generic navigation and indentation
engine.  Based on a very simple parser using an operator precedence
grammar, it lets major modes extend the sexp-based navigation of Lisp
to non-Lisp languages as well as provide a simple to use but reliable
auto-indentation.

Operator precedence grammar is a very primitive technology for parsing
compared to some of the more common techniques used in compilers.
It has the following characteristics: its parsing power is very limited,
and it is largely unable to detect syntax errors, but it has the
advantage of being algorithmically efficient and able to parse forward
just as well as backward.  In practice that means that SMIE can use it
for indentation based on backward parsing, that it can provide both
@code{forward-sexp} and @code{backward-sexp} functionality, and that it
will naturally work on syntactically incorrect code without any extra
effort.  The downside is that it also means that most programming
languages cannot be parsed correctly using SMIE, at least not without
resorting to some special tricks (@pxref{SMIE Tricks}).

@menu
* SMIE setup::                  SMIE setup and features.
* Operator Precedence Grammars::  A very simple parsing technique.
* SMIE Grammar::                Defining the grammar of a language.
* SMIE Lexer::                  Defining tokens.
* SMIE Tricks::                 Working around the parser's limitations.
* SMIE Indentation::            Specifying indentation rules.
* SMIE Indentation Helpers::    Helper functions for indentation rules.
* SMIE Indentation Example::    Sample indentation rules.
* SMIE Customization::          Customizing indentation.
@end menu

@node SMIE setup
@subsubsection SMIE Setup and Features

SMIE is meant to be a one-stop shop for structural navigation and
various other features which rely on the syntactic structure of code, in
particular automatic indentation.  The main entry point is
@code{smie-setup} which is a function typically called while setting
up a major mode.

@defun smie-setup grammar rules-function &rest keywords
Setup SMIE navigation and indentation.
@var{grammar} is a grammar table generated by @code{smie-prec2->grammar}.
@var{rules-function} is a set of indentation rules for use on
@code{smie-rules-function}.
@var{keywords} are additional arguments, which can include the following
keywords:
@itemize
@item
@code{:forward-token} @var{fun}: Specify the forward lexer to use.
@item
@code{:backward-token} @var{fun}: Specify the backward lexer to use.
@end itemize
@end defun

Calling this function is sufficient to make commands such as
@code{forward-sexp}, @code{backward-sexp}, and @code{transpose-sexps} be
able to properly handle structural elements other than just the paired
parentheses already handled by syntax tables.  For example, if the
provided grammar is precise enough, @code{transpose-sexps} can correctly
transpose the two arguments of a @code{+} operator, taking into account
the precedence rules of the language.

Calling @code{smie-setup} is also sufficient to make @key{TAB}
indentation work in the expected way, extends
@code{blink-matching-paren} to apply to elements like
@code{begin...end}, and provides some commands that you can bind in
the major mode keymap.

@deffn Command smie-close-block
This command closes the most recently opened (and not yet closed) block.
@end deffn

@deffn Command smie-down-list &optional arg
This command is like @code{down-list} but it also pays attention to
nesting of tokens other than parentheses, such as @code{begin...end}.
@end deffn

@node Operator Precedence Grammars
@subsubsection Operator Precedence Grammars

SMIE's precedence grammars simply give to each token a pair of
precedences: the left-precedence and the right-precedence.  We say
@code{T1 < T2} if the right-precedence of token @code{T1} is less than
the left-precedence of token @code{T2}.  A good way to read this
@code{<} is as a kind of parenthesis: if we find @code{... T1 something
T2 ...}  then that should be parsed as @code{... T1 (something T2 ...}
rather than as @code{... T1 something) T2 ...}.  The latter
interpretation would be the case if we had @code{T1 > T2}.  If we have
@code{T1 = T2}, it means that token T2 follows token T1 in the same
syntactic construction, so typically we have @code{"begin" = "end"}.
Such pairs of precedences are sufficient to express left-associativity
or right-associativity of infix operators, nesting of tokens like
parentheses and many other cases.

@c Let's leave this undocumented to leave it more open for change!
@c @defvar smie-grammar
@c The value of this variable is an alist specifying the left and right
@c precedence of each token.  It is meant to be initialized by using one of
@c the functions below.
@c @end defvar

@defun smie-prec2->grammar table
This function takes a @emph{prec2} grammar @var{table} and returns an
alist suitable for use in @code{smie-setup}.  The @emph{prec2}
@var{table} is itself meant to be built by one of the functions below.
@end defun

@defun smie-merge-prec2s &rest tables
This function takes several @emph{prec2} @var{tables} and merges them
into a new @emph{prec2} table.
@end defun

@defun smie-precs->prec2 precs
This function builds a @emph{prec2} table from a table of precedences
@var{precs}.  @var{precs} should be a list, sorted by precedence (for
example @code{"+"} will come before @code{"*"}), of elements of the form
@code{(@var{assoc} @var{op} ...)}, where each @var{op} is a token that
acts as an operator; @var{assoc} is their associativity, which can be
either @code{left}, @code{right}, @code{assoc}, or @code{nonassoc}.
All operators in a given element share the same precedence level
and associativity.
@end defun

@defun smie-bnf->prec2 bnf &rest resolvers
This function lets you specify the grammar using a BNF notation.
It accepts a @var{bnf} description of the grammar along with a set of
conflict resolution rules @var{resolvers}, and
returns a @emph{prec2} table.

@var{bnf} is a list of nonterminal definitions of the form
@code{(@var{nonterm} @var{rhs1} @var{rhs2} ...)} where each @var{rhs}
is a (non-empty) list of terminals (aka tokens) or non-terminals.

Not all grammars are accepted:
@itemize
@item
An @var{rhs} cannot be an empty list (an empty list is never needed,
since SMIE allows all non-terminals to match the empty string anyway).
@item
An @var{rhs} cannot have 2 consecutive non-terminals: each pair of
non-terminals needs to be separated by a terminal (aka token).
This is a fundamental limitation of operator precedence grammars.
@end itemize

Additionally, conflicts can occur:
@itemize
@item
The returned @emph{prec2} table holds constraints between pairs of tokens, and
for any given pair only one constraint can be present: T1 < T2,
T1 = T2, or T1 > T2.
@item
A token can be an @code{opener} (something similar to an open-paren),
a @code{closer} (like a close-paren), or @code{neither} of the two
(e.g., an infix operator, or an inner token like @code{"else"}).
@end itemize

Precedence conflicts can be resolved via @var{resolvers}, which
is a list of @emph{precs} tables (see @code{smie-precs->prec2}): for
each precedence conflict, if those @code{precs} tables
specify a particular constraint, then the conflict is resolved by using
this constraint instead, else a conflict is reported and one of the
conflicting constraints is picked arbitrarily and the others are
simply ignored.
@end defun

@node SMIE Grammar
@subsubsection Defining the Grammar of a Language
@cindex SMIE grammar
@cindex grammar, SMIE

The usual way to define the SMIE grammar of a language is by
defining a new global variable that holds the precedence table by
giving a set of BNF rules.
For example, the grammar definition for a small Pascal-like language
could look like:
@example
@group
(require 'smie)
(defvar sample-smie-grammar
  (smie-prec2->grammar
   (smie-bnf->prec2
@end group
@group
    '((id)
      (inst ("begin" insts "end")
            ("if" exp "then" inst "else" inst)
            (id ":=" exp)
            (exp))
      (insts (insts ";" insts) (inst))
      (exp (exp "+" exp)
           (exp "*" exp)
           ("(" exps ")"))
      (exps (exps "," exps) (exp)))
@end group
@group
    '((assoc ";"))
    '((assoc ","))
    '((assoc "+") (assoc "*")))))
@end group
@end example

@noindent
A few things to note:

@itemize
@item
The above grammar does not explicitly mention the syntax of function
calls: SMIE will automatically allow any sequence of sexps, such as
identifiers, balanced parentheses, or @code{begin ... end} blocks
to appear anywhere anyway.
@item
The grammar category @code{id} has no right hand side: this does not
mean that it can match only the empty string, since as mentioned any
sequence of sexps can appear anywhere anyway.
@item
Because non terminals cannot appear consecutively in the BNF grammar, it
is difficult to correctly handle tokens that act as terminators, so the
above grammar treats @code{";"} as a statement @emph{separator} instead,
which SMIE can handle very well.
@item
Separators used in sequences (such as @code{","} and @code{";"} above)
are best defined with BNF rules such as @code{(foo (foo "separator" foo) ...)}
which generate precedence conflicts which are then resolved by giving
them an explicit @code{(assoc "separator")}.
@item
The @code{("(" exps ")")} rule was not needed to pair up parens, since
SMIE will pair up any characters that are marked as having paren syntax
in the syntax table.  What this rule does instead (together with the
definition of @code{exps}) is to make it clear that @code{","} should
not appear outside of parentheses.
@item
Rather than have a single @emph{precs} table to resolve conflicts, it is
preferable to have several tables, so as to let the BNF part of the
grammar specify relative precedences where possible.
@item
Unless there is a very good reason to prefer @code{left} or
@code{right}, it is usually preferable to mark operators as associative,
using @code{assoc}.  For that reason @code{"+"} and @code{"*"} are
defined above as @code{assoc}, although the language defines them
formally as left associative.
@end itemize

@node SMIE Lexer
@subsubsection Defining Tokens
@cindex SMIE lexer
@cindex defining tokens, SMIE

SMIE comes with a predefined lexical analyzer which uses syntax tables
in the following way: any sequence of characters that have word or
symbol syntax is considered a token, and so is any sequence of
characters that have punctuation syntax.  This default lexer is
often a good starting point but is rarely actually correct for any given
language.  For example, it will consider @code{"2,+3"} to be composed
of 3 tokens: @code{"2"}, @code{",+"}, and @code{"3"}.

To describe the lexing rules of your language to SMIE, you need
2 functions, one to fetch the next token, and another to fetch the
previous token.  Those functions will usually first skip whitespace and
comments and then look at the next chunk of text to see if it
is a special token.  If so it should skip the token and
return a description of this token.  Usually this is simply the string
extracted from the buffer, but it can be anything you want.
For example:
@example
@group
(defvar sample-keywords-regexp
  (regexp-opt '("+" "*" "," ";" ">" ">=" "<" "<=" ":=" "=")))
@end group
@group
(defun sample-smie-forward-token ()
  (forward-comment (point-max))
  (cond
   ((looking-at sample-keywords-regexp)
    (goto-char (match-end 0))
    (match-string-no-properties 0))
   (t (buffer-substring-no-properties
       (point)
       (progn (skip-syntax-forward "w_")
              (point))))))
@end group
@group
(defun sample-smie-backward-token ()
  (forward-comment (- (point)))
  (cond
   ((looking-back sample-keywords-regexp (- (point) 2) t)
    (goto-char (match-beginning 0))
    (match-string-no-properties 0))
   (t (buffer-substring-no-properties
       (point)
       (progn (skip-syntax-backward "w_")
              (point))))))
@end group
@end example

Notice how those lexers return the empty string when in front of
parentheses.  This is because SMIE automatically takes care of the
parentheses defined in the syntax table.  More specifically if the lexer
returns @code{nil} or an empty string, SMIE tries to handle the corresponding
text as a sexp according to syntax tables.

@node SMIE Tricks
@subsubsection Living With a Weak Parser

The parsing technique used by SMIE does not allow tokens to behave
differently in different contexts.  For most programming languages, this
manifests itself by precedence conflicts when converting the
BNF grammar.

Sometimes, those conflicts can be worked around by expressing the
grammar slightly differently.  For example, for Modula-2 it might seem
natural to have a BNF grammar that looks like this:

@example
  ...
  (inst ("IF" exp "THEN" insts "ELSE" insts "END")
        ("CASE" exp "OF" cases "END")
        ...)
  (cases (cases "|" cases)
         (caselabel ":" insts)
         ("ELSE" insts))
  ...
@end example

But this will create conflicts for @code{"ELSE"}: on the one hand, the
IF rule implies (among many other things) that @code{"ELSE" = "END"};
but on the other hand, since @code{"ELSE"} appears within @code{cases},
which appears left of @code{"END"}, we also have @code{"ELSE" > "END"}.
We can solve the conflict either by using:
@example
  ...
  (inst ("IF" exp "THEN" insts "ELSE" insts "END")
        ("CASE" exp "OF" cases "END")
        ("CASE" exp "OF" cases "ELSE" insts "END")
        ...)
  (cases (cases "|" cases) (caselabel ":" insts))
  ...
@end example
or
@example
  ...
  (inst ("IF" exp "THEN" else "END")
        ("CASE" exp "OF" cases "END")
        ...)
  (else (insts "ELSE" insts))
  (cases (cases "|" cases) (caselabel ":" insts) (else))
  ...
@end example

Reworking the grammar to try and solve conflicts has its downsides, tho,
because SMIE assumes that the grammar reflects the logical structure of
the code, so it is preferable to keep the BNF closer to the intended
abstract syntax tree.

Other times, after careful consideration you may conclude that those
conflicts are not serious and simply resolve them via the
@var{resolvers} argument of @code{smie-bnf->prec2}.  Usually this is
because the grammar is simply ambiguous: the conflict does not affect
the set of programs described by the grammar, but only the way those
programs are parsed.  This is typically the case for separators and
associative infix operators, where you want to add a resolver like
@code{'((assoc "|"))}.  Another case where this can happen is for the
classic @emph{dangling else} problem, where you will use @code{'((assoc
"else" "then"))}.  It can also happen for cases where the conflict is
real and cannot really be resolved, but it is unlikely to pose a problem
in practice.

Finally, in many cases some conflicts will remain despite all efforts to
restructure the grammar.  Do not despair: while the parser cannot be
made more clever, you can make the lexer as smart as you want.  So, the
solution is then to look at the tokens involved in the conflict and to
split one of those tokens into 2 (or more) different tokens.  E.g., if
the grammar needs to distinguish between two incompatible uses of the
token @code{"begin"}, make the lexer return different tokens (say
@code{"begin-fun"} and @code{"begin-plain"}) depending on which kind of
@code{"begin"} it finds.  This pushes the work of distinguishing the
different cases to the lexer, which will thus have to look at the
surrounding text to find ad-hoc clues.

@node SMIE Indentation
@subsubsection Specifying Indentation Rules
@cindex indentation rules, SMIE

Based on the provided grammar, SMIE will be able to provide automatic
indentation without any extra effort.  But in practice, this default
indentation style will probably not be good enough.  You will want to
tweak it in many different cases.

SMIE indentation is based on the idea that indentation rules should be
as local as possible.  To this end, it relies on the idea of
@emph{virtual} indentation, which is the indentation that a particular
program point would have if it were at the beginning of a line.
Of course, if that program point is indeed at the beginning of a line,
its virtual indentation is its current indentation.  But if not, then
SMIE uses the indentation algorithm to compute the virtual indentation
of that point.  Now in practice, the virtual indentation of a program
point does not have to be identical to the indentation it would have if
we inserted a newline before it.  To see how this works, the SMIE rule
for indentation after a @code{@{} in C does not care whether the
@code{@{} is standing on a line of its own or is at the end of the
preceding line.  Instead, these different cases are handled in the
indentation rule that decides how to indent before a @code{@{}.

Another important concept is the notion of @emph{parent}: The
@emph{parent} of a token, is the head token of the nearest enclosing
syntactic construct.  For example, the parent of an @code{else} is the
@code{if} to which it belongs, and the parent of an @code{if}, in turn,
is the lead token of the surrounding construct.  The command
@code{backward-sexp} jumps from a token to its parent, but there are
some caveats: for @emph{openers} (tokens which start a construct, like
@code{if}), you need to start with point before the token, while for
others you need to start with point after the token.
@code{backward-sexp} stops with point before the parent token if that is
the @emph{opener} of the token of interest, and otherwise it stops with
point after the parent token.

SMIE indentation rules are specified using a function that takes two
arguments @var{method} and @var{arg} where the meaning of @var{arg} and the
expected return value depend on @var{method}.

@var{method} can be:
@itemize
@item
@code{:after}, in which case @var{arg} is a token and the function
should return the @var{offset} to use for indentation after @var{arg}.
@item
@code{:before}, in which case @var{arg} is a token and the function
should return the @var{offset} to use to indent @var{arg} itself.
@item
@code{:elem}, in which case the function should return either the offset
to use to indent function arguments (if @var{arg} is the symbol
@code{arg}) or the basic indentation step (if @var{arg} is the symbol
@code{basic}).
@item
@code{:list-intro}, in which case @var{arg} is a token and the function
should return не-@code{nil} if the token is followed by a list of
expressions (not separated by any token) rather than an expression.
@end itemize

When @var{arg} is a token, the function is called with point just before
that token.  A return value of @code{nil} always means to fallback on the
default behavior, so the function should return @code{nil} for arguments it
does not expect.

@var{offset} can be:
@itemize
@item
@code{nil}: use the default indentation rule.
@item
@code{(column . @var{column})}: indent to column @var{column}.
@item
@var{number}: offset by @var{number}, relative to a base token which is
the current token for @code{:after} and its parent for @code{:before}.
@end itemize

@node SMIE Indentation Helpers
@subsubsection Helper Functions for Indentation Rules

SMIE provides various functions designed specifically for use in the
indentation rules function (several of those functions break if used in
another context).  These functions all start with the prefix
@code{smie-rule-}.

@defun smie-rule-bolp
Return не-@code{nil} if the current token is the first on the line.
@end defun

@defun smie-rule-hanging-p
Return не-@code{nil} if the current token is @emph{hanging}.
A token is @emph{hanging} if it is the last token on the line
and if it is preceded by other tokens: a lone token on a line is not
hanging.
@end defun

@defun smie-rule-next-p &rest tokens
Return не-@code{nil} if the next token is among @var{tokens}.
@end defun

@defun smie-rule-prev-p &rest tokens
Return не-@code{nil} if the previous token is among @var{tokens}.
@end defun

@defun smie-rule-parent-p &rest parents
Return не-@code{nil} if the current token's parent is among @var{parents}.
@end defun

@defun smie-rule-sibling-p
Return не-@code{nil} if the current token's parent is actually a
sibling.  This is the case for example when the parent of a @code{","}
is just the previous @code{","}.
@end defun

@defun smie-rule-parent &optional offset
Return the proper offset to align the current token with the parent.
If не-@code{nil}, @var{offset} should be an integer giving an
additional offset to apply.
@end defun

@defun smie-rule-separator method
Indent current token as a @emph{separator}.

By @emph{separator}, we mean here a token whose sole purpose is to
separate various elements within some enclosing syntactic construct, and
which does not have any semantic significance in itself (i.e., it would
typically not exist as a node in an abstract syntax tree).

Such a token is expected to have an associative syntax and be closely
tied to its syntactic parent.  Typical examples are @code{","} in lists
of arguments (enclosed inside parentheses), or @code{";"} in sequences
of instructions (enclosed in a @code{@{...@}} or @code{begin...end}
block).

@var{method} should be the method name that was passed to
@code{smie-rules-function}.
@end defun

@node SMIE Indentation Example
@subsubsection Sample Indentation Rules

Here is an example of an indentation function:

@example
(defun sample-smie-rules (kind token)
  (pcase (cons kind token)
    (`(:elem . basic) sample-indent-basic)
    (`(,_ . ",") (smie-rule-separator kind))
    (`(:after . ":=") sample-indent-basic)
    (`(:before . ,(or `"begin" `"(" `"@{")))
     (if (smie-rule-hanging-p) (smie-rule-parent)))
    (`(:before . "if")
     (and (not (smie-rule-bolp)) (smie-rule-prev-p "else")
          (smie-rule-parent)))))
@end example

@noindent
A few things to note:

@itemize
@item
The first case indicates the basic indentation increment to use.
If @code{sample-indent-basic} is @code{nil}, then SMIE uses the global
setting @code{smie-indent-basic}.  The major mode could have set
@code{smie-indent-basic} buffer-locally instead, but that
is discouraged.

@item
The rule for the token @code{","} make SMIE try to be more clever when
the comma separator is placed at the beginning of lines.  It tries to
outdent the separator so as to align the code after the comma; for
example:

@example
x = longfunctionname (
        arg1
      , arg2
    );
@end example

@item
The rule for indentation after @code{":="} exists because otherwise
SMIE would treat @code{":="} as an infix operator and would align the
right argument with the left one.

@item
The rule for indentation before @code{"begin"} is an example of the use
of virtual indentation:  This rule is used only when @code{"begin"} is
hanging, which can happen only when @code{"begin"} is not at the
beginning of a line.  So this is not used when indenting
@code{"begin"} itself but only when indenting something relative to this
@code{"begin"}.  Concretely, this rule changes the indentation from:

@example
    if x > 0 then begin
            dosomething(x);
        end
@end example
to
@example
    if x > 0 then begin
        dosomething(x);
    end
@end example

@item
The rule for indentation before @code{"if"} is similar to the one for
@code{"begin"}, but where the purpose is to treat @code{"else if"}
as a single unit, so as to align a sequence of tests rather than indent
each test further to the right.  This function does this only in the
case where the @code{"if"} is not placed on a separate line, hence the
@code{smie-rule-bolp} test.

If we know that the @code{"else"} is always aligned with its @code{"if"}
and is always at the beginning of a line, we can use a more efficient
rule:
@example
((equal token "if")
 (and (not (smie-rule-bolp))
      (smie-rule-prev-p "else")
      (save-excursion
        (sample-smie-backward-token)
        (cons 'column (current-column)))))
@end example

The advantage of this formulation is that it reuses the indentation of
the previous @code{"else"}, rather than going all the way back to the
first @code{"if"} of the sequence.
@end itemize

@c In some sense this belongs more in the Emacs manual.
@node SMIE Customization
@subsubsection Customizing Indentation

If you are using a mode whose indentation is provided by SMIE, you can
customize the indentation to suit your preferences.  You can do this
on a per-mode basis (using the option @code{smie-config}), or a
per-file basis (using the function @code{smie-config-local} in a
file-local variable specification).

@defopt smie-config
This option lets you customize indentation on a per-mode basis.
It is an alist with elements of the form @code{(@var{mode} . @var{rules})}.
For the precise form of rules, see the variable's documentation; but
you may find it easier to use the command @code{smie-config-guess}.
@end defopt

@deffn Command smie-config-guess
This command tries to work out appropriate settings to produce
your preferred style of indentation.  Simply call the command while
visiting a file that is indented with your style.
@end deffn

@deffn Command smie-config-save
Call this command after using @code{smie-config-guess}, to save your
settings for future sessions.
@end deffn

@deffn Command smie-config-show-indent &optional move
This command displays the rules that are used to indent the current
line.
@end deffn

@deffn Command smie-config-set-indent
This command adds a local rule to adjust the indentation of the current line.
@end deffn

@defun smie-config-local rules
This function adds @var{rules} as indentation rules for the current buffer.
These add to any mode-specific rules defined by the @code{smie-config} option.
To specify custom indentation rules for a specific file, add an entry
to the file's local variables of the form:
@code{eval: (smie-config-local '(@var{rules}))}.
@end defun


@node Desktop Save Mode
@section Desktop Save Mode
@cindex desktop save mode

@dfn{Desktop Save Mode} is a feature to save the state of Emacs from
one session to another.  The user-level commands for using Desktop
Save Mode are described in the GNU Emacs Manual (@pxref{Saving Emacs
Sessions,,, emacs, the GNU Emacs Manual}).  Modes whose buffers visit
a file, don't have to do anything to use this feature.

For buffers not visiting a file to have their state saved, the major
mode must bind the buffer local variable @code{desktop-save-buffer} to
a не-@code{nil} value.

@defvar desktop-save-buffer
If this buffer-local variable is не-@code{nil}, the buffer will have
its state saved in the desktop file at desktop save.  If the value is
a function, it is called at desktop save with argument
@var{desktop-dirname}, and its value is saved in the desktop file along
with the state of the buffer for which it was called.  When file names
are returned as part of the auxiliary information, they should be
formatted using the call

@example
(desktop-file-name @var{file-name} @var{desktop-dirname})
@end example

@end defvar

For buffers not visiting a file to be restored, the major mode must
define a function to do the job, and that function must be listed in
the alist @code{desktop-buffer-mode-handlers}.

@defvar desktop-buffer-mode-handlers
Alist with elements

@example
(@var{major-mode} . @var{restore-buffer-function})
@end example

The function @var{restore-buffer-function} will be called with
argument list

@example
(@var{buffer-file-name} @var{buffer-name} @var{desktop-buffer-misc})
@end example

and it should return the restored buffer.
Here @var{desktop-buffer-misc} is the value returned by the function
optionally bound to @code{desktop-save-buffer}.
@end defvar
