@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2019 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Lists
@chapter Списки
@cindex lists
@cindex element (of list)

  @dfn{Список} представляет собой последовательность из нуля или более
  элементов (которые могут быть любыми объектами Lisp).  Важное различие
  между списками и векторами состоит в том, что два или более списков могут
  совместно использовать части своей структуры; кроме того, можно вставлять
  или удалять элементы в списке, не копируя весь список.

@menu
* Cons Cells::          Как списки собраны из cons-ячеек.
* List-related Predicates::        Объект список? Сравнение двух списков.
* List Elements::       Извлечение частей списка.
* Building Lists::      Создание структуры списка.
* List Variables::      Изменение списков, хранящихся в переменных.
* Modifying Lists::     Сохранение новых частей в существующий список.
* Sets And Lists::      Список как конечный математический набор.
* Association Lists::   Список как конечное отношение или отображение.
* Property Lists::      Список спаренных элементов.
@end menu

@node Cons Cells
@section Списки и Cons Ячецки
@cindex lists and cons cells

  Списки в Lisp не примитивный тип данных; они построены из @dfn{cons ячеек}
  (@pxref{Cons Cell Type}).  Cons ячейка представляет собой объект данных,
  который представляет упорядоченную пару.  То есть, имеется два слота, и
  каждый слот @dfn{содержит}, или @dfn{ссылается} на какой-либо Lisp объект.
  Один слот известен как @sc{car}, а другой известен как @sc{cdr}.  (Эти
  названия являются традиционными, см @ref{Cons Cell Type}.)  @sc{cdr}
  произносится как ``could-er''.

  Мы говорим, что ``@sc{car} cons ячейки'' тот объект, который в данный
  момент находиться в слоте @sc{car} ячейки, и тоже для @sc{cdr}.

  Список представляет собой последовательность cons ячеек соединеных друг с
  другом, так что каждая ячейка ссылается на следующую.  Для каждого элемента
  списка существует одна cons ячейка.  По соглашению, @sc{car} в cons ячейки
  содержит элемент списка, а @sc{cdr} используются для получения цепи списка
  (эта асимметрия между @sc{car} и @sc{cdr} полностью условна; на уровне
  cons ячеек слоты @sc{car} и @sc{cdr} обладают сходными свойствами).
  Следовательно, @sc{cdr} слот каждой cons ячейки списка, содержит ссылку на
  следующую cons ячейку.

@cindex proper list
@cindex true list
  Кроме того, по соглашению, @sc{cdr} последней cons ячейки в списке
  @code{nil}.  Мы называем такую ​​структуру, @code{nil}-концевой
  @dfn{правильным списком}@footnote{Иногда также упоминается как
  @dfn{истинный список}, но мы не используем эту терминологию в данном
  руководстве.}.  В Emacs Lisp, символ @code{nil} является одновременно и
  символом и пустым списком без элементов.  Для удобства считается, что
  символ @code{nil} имеет @code{nil} для его @sc{cdr} (а также для
  его @sc{car}).

  Следовательно, @sc{cdr} правильного списка всегда правильный список.
  @sc{cdr} непустого правильного списка правильный список, содержащий все
  элементы, кроме первого.

@cindex dotted list
@cindex circular list
  Если @sc{cdr} последней cons ячейки списка является некоторым значением,
  отличным от @code{nil}, мы называем такую структуру
  @dfn{точечный список}, так как его печатное представление будет
  использовать натоцию точечной пары (@pxref{Dotted Pair Notation}).
  Существует еще одна возможность: @sc{cdr} некоторой cons ячейки может
  на одну из предыдущих cons ячеек того же списка.  Мы называем такую
  структуру, @dfn{круговой список}.

  Для некоторых целей, не имеет значения, является ли список правильным,
  круглым или точечным списком.  Если программа не погружается достаточно
  далеко вниз по списку, чтобы увидеть @sc{cdr} конечной cons ячейки списка,
  ей всё равно какой это список.  Тем не менее, некоторые функции, которые
  работают со списками требуют правильных списков и сигнализируют, если
  задан точечный список. Большинство функций, которые пытаются найти конец
  списка входят в бесконечный цикл, если задан круговой список.

@cindex list structure
  Поскольку большинство cons ячеек используются как части списка, мы
  называем любую такую структуру, состоящую из cons ячеек,
  @dfn{структурой списка}.

@node List-related Predicates
@section Предикаты в Списках
@cindex predicates for lists
@cindex list predicates

  Следующие предикаты проверяют, является ли объект Lisp атомом, является ли
  cons-ячейкой, представляет собой список или является выделенным объектом
  @code{nil}.  (Многие из этих предикатов могут быть определены в других
  терминах, но они используются так часто, что стоит отметить их.)

@defun consp object
Функция возвращает @code{t} если @var{object} является cons-ячейкой,
@code{nil} в противном случае.  @code{nil} не cons-ячейка, хотя @emph{это}
список.
@end defun

@defun atom object
Функция возвращает @code{t} если @var{object} является атом, @code{nil}
в противном случае.  Все объекты, кроме cons-чейки являются атомами.  Символ
@code{nil} представляет собой и атом и список; это единственный Lisp объект,
который является и тем и другим одновременно.

@example
(atom @var{object}) @equiv{} (not (consp @var{object}))
@end example
@end defun

@defun listp object
Функция возвращает @code{t} если @var{object} является cons-ячейка или
@code{nil}.  В противном случае она возвращает @code{nil}.

@example
@group
(listp '(1))
     @result{} t
@end group
@group
(listp '())
     @result{} t
@end group
@end example
@end defun

@defun nlistp object
Функция обратная @code{listp}: возвращает @code{t} если @var{object} не
является списком.  В противном случае возвращает @code{nil}.

@example
(listp @var{object}) @equiv{} (not (nlistp @var{object}))
@end example
@end defun

@defun null object
Функция возвращает @code{t} если @var{object} является @code{nil}, и
возвращает @code{nil} в противном случае.  Эта функция идентична @code{not},
но для ясности мы используем @code{null} когда @var{object} рассматривается
как список и @code{not}, когда он считается значением истинности
(see @code{not} в @ref{Combining Conditions}).

@example
@group
(null '(1))
     @result{} nil
@end group
@group
(null '())
     @result{} t
@end group
@end example
@end defun


@node List Elements
@section Доступ к Элементам Списка
@cindex list elements

@defun car cons-cell
Функция возвращает значение, указанное в первом слоте cons-ячейки
@var{cons-cell}.  Другими словами, она возвращает @sc{car} из
@var{cons-cell}.

В частном случае, если @var{cons-cell} является @code{nil}, функция
возвращает @code{nil}.  Таким образом, любой список является допустимым
аргументом.  Сигнализируется ошибка, если аргумент не является cons-ячейкой
или @code{nil}.

@example
@group
(car '(a b c))
     @result{} a
@end group
@group
(car '())
     @result{} nil
@end group
@end example
@end defun

@defun cdr cons-cell
Функция возвращает значение, указанное во втором слоте cons-ячейки
@var{cons-cell}.  Другими словами, она возвращает @sc{cdr} из
@var{cons-cell}.

В частном случае, если @var{cons-cell} является @code{nil}, функция
возвращает @code{nil}; Поэтому, любой список является допустимым аргументом.
Сигнализируется ошибка, если аргумент не является cons-ячейкой или
@code{nil}.

@example
@group
(cdr '(a b c))
     @result{} (b c)
@end group
@group
(cdr '())
     @result{} nil
@end group
@end example
@end defun

@defun car-safe object
Функция позволяет принимать @sc{car} cons-ячейки, избегая ошибки для других
типов данных.  Возвращает @sc{car} из @var{object} если @var{object}
является cons-ячейка, @code{nil} в противном случае.  В этом отличие от
@code{car}, который сигнализирует об ошибке, если @var{object} не
является списком.

@example
@group
(car-safe @var{object})
@equiv{}
(let ((x @var{object}))
  (if (consp x)
      (car x)
    nil))
@end group
@end example
@end defun

@defun cdr-safe object
Функция позволяет принимать @sc{cdr} cons-ячейки, избегая ошибки для других
типов данных.  Возвращает @sc{cdr} из @var{object} если @var{object} является
cons-ячейкой, @code{nil} в противном случае.  В этом отличие от @code{cdr},
которая сигнализирует об ошибке, если @var{object} не является списком.

@example
@group
(cdr-safe @var{object})
@equiv{}
(let ((x @var{object}))
  (if (consp x)
      (cdr x)
    nil))
@end group
@end example
@end defun

@defmac pop listname
Макрос обеспечивает удобный способ для изучения @sc{car} списка и
сразу удалить его из списка.  Работает со списком хранящимся в
@var{listname}.  Удаляет первый элемент из списка, сохраняет @sc{cdr} в
@var{listname}, а затем возвращает удаленный элемент.

В простейшем случае, @var{listname} является символом не экранированым
кавычкой; в этом случае макрос эквивалентен @w{@code{(prog1 (car listname) (setq listname (cdr listname)))}}.

@example
x
     @result{} (a b c)
(pop x)
     @result{} a
x
     @result{} (b c)
@end example

В более общем плане, @var{listname} может быть обобщённой переменной.  В этом
случае макрос сохраняется в @var{listname} используя @code{setf}.
@xref{Generalized Variables}.

Для @code{push} макроса, который добавляет элемент в список,
@xref{List Variables}.
@end defmac

@defun nth n list
@anchor{Definition of nth}
Функция возвращает @var{n}-ый элемент @var{list}.  Элементы пронумерованы
начиная с нуля, так что @sc{car} из @var{list} является элементом с номером
ноль.  Если длина @var{list} является @var{n} или меньше, возвращается
значение @code{nil}.

@c Поведение при -ve n не определено, так как 2013/08; see bug#15059.
@ignore
Если @var{n} отрицательный, @code{nth} возвращает первый элемент @var{list}.
@end ignore

@example
@group
(nth 2 '(1 2 3 4))
     @result{} 3
@end group
@group
(nth 10 '(1 2 3 4))
     @result{} nil

(nth n x) @equiv{} (car (nthcdr n x))
@end group
@end example

Функция @code{elt} аналогична, но применима к любому виду последовательности.
По историческим причинам, берет свои аргументы в обратном порядке.
@xref{Sequence Functions}.
@end defun

@defun nthcdr n list
Функция возвращает @var{n}-ый @sc{cdr} из @var{list}.  Другими словами,
пропускается первых @var{n} звеньев @var{list} и возвращает то, что
следует далее.

@c "или отрицательный" удалено 2013/08; see bug#15059.
Если @var{n} равен нулю, @code{nthcdr} возвращает весь @var{list}.  Если
длина @var{list} является @var{n} или менее, @code{nthcdr} возвращает
@code{nil}.

@example
@group
(nthcdr 1 '(1 2 3 4))
     @result{} (2 3 4)
@end group
@group
(nthcdr 10 '(1 2 3 4))
     @result{} nil
@end group
@group
(nthcdr 0 '(1 2 3 4))
     @result{} (1 2 3 4)
@end group
@end example
@end defun

@defun last list &optional n
Функция возвращает последнее звено @var{list}.  @code{car} этой связи
является последним элементом списка.  Если длина @var{list} имеет нулевое
значение, возвращается @code{nil}.  Если @var{n} установлен в не-@code{nil},
ссылка @var{n}-ый-от-последнего возвращается, или весь @var{list} если
@var{n} больше, чем длина @var{list}.
@end defun

@defun safe-length list
@anchor{Definition of safe-length}
Функция возвращает длину @var{list}, без риска ошибки либо входа в
бесконечный цикл.  Как правило, возвращается количество отдельных cons-ячеек
в списке.  Тем не менее, для круговых списков, значением является только
верхняя граница; часто бывает слишком большим.

Если @var{list} не @code{nil} или cons-ячейка, @code{safe-length} возвращает
0.
@end defun

  Наиболее распространенный способ вычислить длину списка, когда нет
  беспокойства, что он может быть круговой, это использовать @code{length}.
  @xref{Sequence Functions}.

@defun caar cons-cell
Это то же самое, что и @code{(car (car @var{cons-cell}))}.
@end defun

@defun cadr cons-cell
Это то же самое, что и @code{(car (cdr @var{cons-cell}))}
или @code{(nth 1 @var{cons-cell})}.
@end defun

@defun cdar cons-cell
Это то же самое, что и @code{(cdr (car @var{cons-cell}))}.
@end defun

@defun cddr cons-cell
Это то же самое, что и @code{(cdr (cdr @var{cons-cell}))}
или @code{(nthcdr 2 @var{cons-cell})}.
@end defun

@findex caaar
@findex caadr
@findex cadar
@findex caddr
@findex cdaar
@findex cdadr
@findex cddar
@findex cdddr
@findex caaaar
@findex caaadr
@findex caadar
@findex caaddr
@findex cadaar
@findex cadadr
@findex caddar
@findex cadddr
@findex cdaaar
@findex cdaadr
@findex cdadar
@findex cdaddr
@findex cddaar
@findex cddadr
@findex cdddar
@findex cddddr
В дополнение к вышесказанному, 24 дополнительные композиции @code{car} и
@code{cdr} определяются как @code{c@var{xxx}r} и @code{c@var{xxxx}r}, где
каждый @code{@var{x}} является либо @code{a} или @code{d}.  @code{cadr},
@code{caddr}, и @code{cadddr} указывает выбрать вторые, третьи или четвертые
элементы списка, соответственно.  @file{cl-lib} предоставляет то же с именами
@code{cl-second}, @code{cl-third}, и @code{cl-fourth}.  @xref{List Functions,,, cl, Common Lisp
Extensions}.

@defun butlast x &optional n
Функция возвращает список @var{x} без последнего  или @var{n}
последними элементами.  Если @var{n} больше нуля, создаётся копия
списка, чтобы не повредить первоначальный список.  В общем,
@code{(append (butlast @var{x} @var{n}) (last @var{x} @var{n}))} возвращают
равные списки @var{x}. (Вопрос lists408)
@end defun

@defun nbutlast x &optional n
Версия @code{butlast}, которая работает путём деструктивной модификации
@code{cdr} соответствующего элемента, а не путём создания копии списка.
@end defun

@node Building Lists
@section Создание Cons Ячеек и Списков
@cindex cons cells
@cindex building lists

  Многие функции создают списки, так как списки находятся в самом сердце
  Lisp.  @code{cons} фундаментальная функция построения списков; однако,
  интересно отметить, что @code{list} используется больше раз в исходном коде
  Emacs чем @code{cons}.

@defun cons object1 object2
Функция является самой основной функцией для создания новой структуры списка.
Создаётся новая cons-ячейка, получая @var{object1} в @sc{car}, и
@var{object2} в @sc{cdr}.  Затем возвращается новая cons-ячейка.  Аргументы
@var{object1} и @var{object2} могут быть любые объекты Lisp, но чаще всего
@var{object2} это список.

@example
@group
(cons 1 '(2))
     @result{} (1 2)
@end group
@group
(cons 1 '())
     @result{} (1)
@end group
@group
(cons 1 2)
     @result{} (1 . 2)
@end group
@end example

@cindex consing
@code{cons} часто используется для добавления одного элемента к голове
списка. Это называется @dfn{включение элемента в список}.
@footnote{Не существует строго эквивалентного способа добавить элемент в
конец списка.  Может использоваться
@code{(append @var{listname} (list @var{newelt}))}, что создаст совершенно
новый список, скопировав @var{listname} и добавив @var{newelt} в конец
списка. Или вы можете использовать
@code{(nconc @var{listname} (list @var{newelt}))}, который деструктивно
модифицирует @var{listname} присоединив все @var{newelt} в @sc{cdr}
@var{listname}, заменив завершающий @code{nil}.  Сравните это с @code{cons}
добавлением элемента в начало , которое не копирует ни модифицирует список.}
For example:

@example
(setq list (cons newelt list))
@end example

Следует отметить, что не существует конфликта между переменной с именем
@code{list}, используемой в этом примере, и функцией с именем @code{list},
описанной ниже; любой символ может служить сразу обеим целям.
@end defun

@defun list &rest objects
Функция создает список с @var{objects} в качестве ее элементов. Полученный
список всегда @code{nil}-закнчивающийся.  Если @var{objects} не указаны,
Возвращается пустой список.

@example
@group
(list 1 2 3 4 5)
     @result{} (1 2 3 4 5)
@end group
@group
(list 1 2 '(3 4 5) 'foo)
     @result{} (1 2 (3 4 5) foo)
@end group
@group
(list)
     @result{} nil
@end group
@end example
@end defun

@defun make-list length object
Функция создает список из @var{length} колличества элементов @var{object},
в котором каждый элемент является @var{object}.  Для сравнения
функции @code{make-list} с функцией @code{make-string}
(@pxref{Creating Strings}).

@example
@group
(make-list 3 'свинья)
     @result{} (свинья свинья свинья)
@end group
@group
(make-list 0 'свинья)
     @result{} nil
@end group
@group
(setq l (make-list 3 '(a b)))
     @result{} ((a b) (a b) (a b))
(eq (car l) (cadr l))
     @result{} t
@end group
@end example
@end defun

@defun append &rest sequences
@cindex copying lists
Функция возвращает список, содержащий все элементы последовательностей
@var{sequences}.  Последовательности @var{sequences} могут быть списками,
векторами, BOOL-векторами, или строками, но последний элемент должен обычно
быть списком.  Все аргументы, кроме последнего, копируются, поэтому ни один
из аргументов не изменяется.  (Смотреть @code{nconc} в @ref{Rearrangement},
способы объединения списков, без копирования.)  (Вопросlists523)

В более общем смысле, окончательный аргумент @code{append} может быть любым
объектом Lisp.  Последний аргумент не копируется и не преобразовывается; он
становится @sc{cdr} последней cons-ячейкой в новом списке.  Если последний
аргумент сам  по себе список, то его элементы становятся фактическими
элементами в результирующем списке.  Если последний элемент не является
списком, то в результате будет получен точечный список, поскольку его
последний элемент содержит в своём @sc{cdr} не @code{nil}
(@pxref{Cons Cells}).
@end defun

  Ниже приведен пример использования @code{append}:

@example
@group
(setq деревья '(сосна дуб))
     @result{} (сосна дуб)
(setq ещё-деревья (append '(клен береза) деревья))
     @result{} (клен береза ​​сосна дуб)
@end group

@group
trees
     @result{} (сосна дуб)
ещё-деревья
     @result{} (клен береза ​​сосна дуб)
@end group
@group
(eq деревья (cdr (cdr ещё-деревья)))
     @result{} t
@end group
@end example

  Можно увидеть, как работает @code{append}, исследуя прямоугольную
  диаграмму.  Переменная @code{деревья} указывает на список
  @code{(сосна дуб)},  а переменная @code{ещё-деревья} указывает на список
  @code{(клен береза ​​сосна дуб)}.  Однако, переменная @code{trees}
  продолжает ссылаться на первоначальный список:

@smallexample
@group
ещё-деревья              деревья
|                           |
|     --- ---      --- ---   -> --- ---      --- ---
 --> |   |   |--> |   |   |--> |   |   |--> |   |   |--> nil
      --- ---      --- ---      --- ---      --- ---
       |            |            |            |
       |            |            |            |
        --> клен     -->береза    --> сосна    --> дуб
@end group
@end smallexample

  Пустая последовательность не влияет на значение, возвращаемое функцией
  @code{append}.  Как следствие этого, последний аргумент @code{nil}
  закрывает копию предыдущего аргумента:

@example
@group
деревья
     @result{} (сосна дуб)
@end group
@group
(setq дерево (append деревья nil))
     @result{} (сосна дуб)
@end group
@group
дерево
     @result{} (сосна дуб)
@end group
@group
(eq дерево деревья)
     @result{} nil
@end group
@end example

@noindent
Это когда-то был обычный способ копирования списка, прежде чем функция
@code{copy-sequence} была изобретена.  @xref{Sequences Arrays Vectors}.

  Здесь показывается использование векторов и строк в качестве аргументов
  @code{append}:

@example
@group
(append [a b] "cd" nil)
     @result{} (a b 99 100)
@end group
@end example

  С помощью @code{apply} (@pxref{Calling Functions}), можно добавить
  все списки в список списков: (Вопросlists614)

@example
@group
(apply 'append '((a b c) nil (x y z) nil))
     @result{} (a b c x y z)
@end group
@end example

  Если последовательности @var{sequences} не заданы, возвращается @code{nil}:

@example
@group
(append)
     @result{} nil
@end group
@end example

  Вот некоторые примеры, когда последний аргумент не является списком:

@example
(append '(x y) 'z)
     @result{} (x y . z)
(append '(x y) [z])
     @result{} (x y . [z])
@end example

@noindent
Второй пример показывает, что, когда последний аргумент представляет собой
последовательность, но не список, элементы последовательности не становятся
элементами результирующего списка.  Вместо этого, последовательность
становится конечным @sc{cdr}, как и любой другой не-список в последнем
аргументе.  (Вопросlists646)

@defun copy-tree tree &optional vecp
Эта функция возвращает копию дерева @var{tree}.  Если @var{tree} является
cons-ячейка, это создаёт новую cons-ячейку с тем же @sc{car} и @sc{cdr},
затем рекурсивно копирует @sc{car} и @sc{cdr} таким же образом.

Обычно, когда @var{tree} не cons-ячейка, @code{copy-tree} просто возвращает
@var{tree}.  Однако, если @var{vecp} установлен в не-@code{nil}, копируются
векторы (и работает рекурсивно с их элементами). (ВопросыLists655)
@end defun

@defun number-sequence from &optional to separation
Возвращает список чисел, с первым элементом числом @var{from} и с каждым
последующим увеличиным на @var{separation} и заканчивающимся перед числом со
значением @var{to}.  @var{separation} может быть положительным или
отрицательным, и по умолчанию 1.  Если @var{to} установлен в @code{nil} или
численно равен @var{from}, возвращаемое значение будет списком из одного
элемента @code{(@var{from})}.  Если @var{to} меньше @var{from} при
положительном @var{separation} или если @var{to} больше @var{from} при
отрицательном @var{separation}, возвращается значение @code{nil}, потому что
при таких аргументах задаются пустые последовательности.

Если @var{separation} является 0 и @var{to} ни @code{nil} и численно равен
@var{from}, @code{number-sequence} сигнализирует об ошибке, поскольку эти
аргументы задают бесконечную последовательность.  (Вопросlists671)

Все аргументы являются числами.
Аргументы с числом с плавающей точкой, могут быть сложными для обработки,
потому что арифметика с плавающей точкой неточна.  Например, в зависимости от
машины, может вполне случиться, что @code{(number-sequence 0.4 0.6 0.2)},
вернёт список из одного элемента @code{(0.4)}, в то время как
@code{(number-sequence 0.4 0.8 0.2)} вернёт список с тремя элементами.
@var{n}-й элемент списка вычисляется по точной формуле
@code{(+ @var{from} (* @var{n} @var{separation}))}.  Таким образом, если
требуется убедиться, что @var{to} включен в список, передаётся выражение
этого конкретного типа для @var{to}.  В качестве альтернативы, можно заменить
значение @var{to} большим значением (или меньшим отрицательным, если
@var{separation} отрицательный).(Вопросlists684)

Несколько примеров:

@example
(number-sequence 4 9)
     @result{} (4 5 6 7 8 9)
(number-sequence 9 4 -1)
     @result{} (9 8 7 6 5 4)
(number-sequence 9 4 -2)
     @result{} (9 7 5)
(number-sequence 8)
     @result{} (8)
(number-sequence 8 5)
     @result{} nil
(number-sequence 5 8 -1)
     @result{} nil
(number-sequence 1.5 6 2)
     @result{} (1.5 3.5 5.5)
@end example
@end defun

@node List Variables
@section Modifying List Variables
@cindex modify a list
@cindex list modification

  Эти функции, и один макрос, обеспечивают удобный способ для изменения
  списка, который хранится в переменной.

@defmac push element listname
Макрос создает новый список, @sc{car} которого @var{element} и чей @sc{cdr}
список в аргументе @var{listname}, и сохраняет этот список в @var{listname}.
В простейшем случае, @var{listname} является символом не заключённый в
кавычки, и этот макрос эквивалентен
@w{@code{(setq @var{listname} (cons @var{element} @var{listname}))}}.

@example
(setq l '(a b))
     @result{} (a b)
(push 'c l)
     @result{} (c a b)
l
     @result{} (c a b)
@end example

В более общем смысле, @code{listname} может быть обобщённой переменной.
В этом случае макрос будет эквивалентен
@w{@code{(setf @var{listname} (cons @var{element} @var{listname}))}}.
@xref{Generalized Variables}.

Макрос @code{pop}, который удаляет первый элемент из списка,
@xref{List Elements}.
@end defmac

  Две функции изменения списков, которые являются значениями переменных.

@defun add-to-list symbol element &optional append compare-fn
Функция устанавливает переменной @var{symbol} объединённое значение
@var{element} и своего прежднего значения, если @var{element} ещё не был
членом прежднего значения.  Возвращается получившийся список, обновлённый
или нет.  Значение @var{symbol} должно быть списком ещё до вызова функции.
@code{add-to-list} использует @var{compare-fn} для сравнения @var{element}
с существующими элементами списка; если @var{compare-fn} установлен в
@code{nil}, используется @code{equal}.

Добавление @var{element}, приводит к появлению его в передней части списка
@var{symbol}, но если дополнительный аргумент @var{append} установлен в
не-@code{nil}, добавление приводит к появлению нового элемента в конце
списка.

Аргумент @var{symbol} явно заключается в кавычки; @code{add-to-list} это
обычная функция, как @code{set}, в отличие от @code{setq}.  Процитируйте
аргумент @var{symbol} сами, если эт нужно.
@end defun

Вот сценарий, показывающий, как использовать @code{add-to-list}:

@example
(setq foo '(a b))
     @result{} (a b)

(add-to-list 'foo 'c)     ;; @r{Добавление @code{c}.}
     @result{} (c a b)

(add-to-list 'foo 'b)     ;; @r{Нет эффекта.}
     @result{} (c a b)

foo                       ;; @r{@code{foo} был изменен.}
     @result{} (c a b)
@end example

  Эквивалентное выражение для
  @code{(add-to-list '@var{var} @var{value})}:

@example
(or (member @var{value} @var{var})
    (setq @var{var} (cons @var{value} @var{var})))
@end example

@defun add-to-ordered-list symbol element &optional order
Функция устанавливает переменной @var{symbol} объединённое значение
@var{element} с её преждним значением, которое должно быть списком, в
позиции, согласно указанной сортировки @var{order}.  Если @var{element} уже
состоит в списке, его позиция в списке устанавливается в соответствии с
сортировкой @var{order}.  Членство проверяется с использованием @code{eq}.
Функция возвращает результирующий список независимо от того, обновлен список
или нет.

@var{order} обычно представляет собой число (целое или с плавающей точкой),
а элементы списка сортируются в возврастающем порядке.

@var{order} также можно опустить или установить в @code{nil}.  Тогда числовой
порядок @var{element} остается неизменным, если у него он уже есть; в
противном случае, @var{element} не имеет числового порядка.  Элементы без
числового порядка списка помещаются в конце списка, в произвольном порядке.
(ВопросLists800)

Любое другое значение для @var{order} удаляет числовой порядок @var{element},
если у него уже есть; в противном случае, это эквивалентно указанию
@code{nil}.

Аргумент @var{symbol} нужно явно заключать в кавычки;
@code{add-to-ordered-list} является обычной функцией, как @code{set}, в
отличие от @code{setq}.  Цитируйте этот аргумент самостоятельно, если это
необходимо.

Информация для @var{symbol} хранится в хэш-таблице свойств @code{list-order}.
@end defun

Вот сценарий, показывающий, как использовать @code{add-to-ordered-list}:

@example
(setq foo '())
     @result{} nil

(add-to-ordered-list 'foo 'a 1)     ;; @r{Добавить @code{a}.}
     @result{} (a)

(add-to-ordered-list 'foo 'c 3)     ;; @r{Добавить @code{c}.}
     @result{} (a c)

(add-to-ordered-list 'foo 'b 2)     ;; @r{Добавить @code{b}.}
     @result{} (a b c)

(add-to-ordered-list 'foo 'b 4)     ;; @r{Переместить @code{b}.}
     @result{} (a c b)

(add-to-ordered-list 'foo 'd)       ;; @r{Всавить @code{d}.}
     @result{} (a c b d)

(add-to-ordered-list 'foo 'e)       ;; @r{Добавить @code{e}}.
     @result{} (a c b e d)

foo                       ;; @r{@code{foo} был изменен.}
     @result{} (a c b e d)
@end example

@node Modifying Lists
@section Изменение Существующей Структуры Списка
@cindex destructive list operations

  Вы можете изменять содержимое @sc{car} и @sc{cdr} cons-ячейки с помощью
  @code{setcar} и @code{setcdr} примитивов.  Эти разрушительные действия,
  потому что они меняют существующую структуру списка.

@cindex CL note---@code{rplaca} vs @code{setcar}
@quotation
@findex rplaca
@findex rplacd
@b{Common Lisp примечание:} Common Lisp использует функцию @code{rplaca} и
@code{rplacd} для изменения структуры списка; они меняют структуру так же,
как @code{setcar} и @code{setcdr}, но функции Common Lisp возвращают
cons-ячейку в то время как @code{setcar} и @code{setcdr} возвращают новый
@sc{car} или @sc{cdr}.
@end quotation

@menu
* Setcar::          Замена элемента в списке.
* Setcdr::          Замена частей основы списка. Это может быть использовано
                    для удаления или добавления элементов.
* Rearrangement::   Упорядочивание элементов в списке; объединения списков.
@end menu

@node Setcar
@subsection Изменение Элементов Списка Используя @code{setcar}
@cindex replace list element
@cindex list, replace element

  Изменение @sc{car} в cons-ячейки делается с помощью @code{setcar}.  При
  использовании для списка, @code{setcar} заменяет один элемент списка другим
  элементом.

@defun setcar cons object
Функция устанавливает @var{object} как новый @sc{car} для @var{cons},
заменив его предыдущий @sc{car}.  Другими словами, изменяется слот @sc{car}
из @var{cons} чтобы тот ссылался на @var{object}.   Возвращается значение
@var{object}.  Например:

@example
@group
(setq x '(1 2))
     @result{} (1 2)
@end group
@group
(setcar x 4)
     @result{} 4
@end group
@group
x
     @result{} (4 2)
@end group
@end example
@end defun

  Когда cons-ячейка является частью общей структуры нескольких списков,
  сохранение нового значения @sc{car} в cons-ячейки влияет на каждый этот
  элемент из этих списков. Вот пример:

@example
@group
;; @r{Создать два списка, с совместным доступом.}
(setq x1 '(a b c))
     @result{} (a b c)
(setq x2 (cons 'z (cdr x1)))
     @result{} (z b c)
@end group

@group
;; @r{Заменить @sc{car} по разделяемой ссылке.}
(setcar (cdr x1) 'foo)
     @result{} foo
x1                           ; @r{Оба списка изменены.}
     @result{} (a foo c)
x2
     @result{} (z foo c)
@end group

@group
;; @r{Заменить @sc{car} по неразделяемой ссылке.}
(setcar x1 'baz)
     @result{} baz
x1                           ; @r{Только один список изменился.}
     @result{} (baz foo c)
x2
     @result{} (z foo c)
@end group
@end example

  Вот графическое изображение общей структуры двух списков в переменных
  @code{x1} и @code{x2}, показывающее, почему замена @code{b} меняет их
  обоих:

@example
@group
        --- ---        --- ---      --- ---
x1---> |   |   |----> |   |   |--> |   |   |--> nil
        --- ---        --- ---      --- ---
         |        -->   |            |
         |       |      |            |
          --> a  |       --> b        --> c
                 |
       --- ---   |
x2--> |   |   |--
       --- ---
        |
        |
         --> z
@end group
@end example

  Вот альтернативная форма в виде прямоугольной диаграммы, показывающая
  такую ​​же зависимость:

@example
@group
x1:
 --------------       --------------       --------------
| car   | cdr  |     | car   | cdr  |     | car   | cdr  |
|   a   |   o------->|   b   |   o------->|   c   |  nil |
|       |      |  -->|       |      |     |       |      |
 --------------  |    --------------       --------------
                 |
x2:              |
 --------------  |
| car   | cdr  | |
|   z   |   o----
|       |      |
 --------------
@end group
@end example

@node Setcdr
@subsection Изменение CDR Cписка
@cindex replace part of list

  Нижний уровень примитива для модификации @sc{cdr} является @code{setcdr}:

@defun setcdr cons object
Эта функция сохраняет @var{object} как новый @sc{cdr} из @var{cons},
заменив его предыдущий @sc{cdr}. Другими словами, он изменяет слот @sc{cdr}
из @var{cons} ссылаться на @var{object}. Она возвращает значение
@var{object}.
@end defun

  Ниже приведен пример замены @sc{cdr} списка другим списком.  Всё, кроме
  первого элемента списка удаляются в пользу другой последовательности
  элементов.  Первый элемент остается неизменным, потому что он находится в
  @sc{car} списке, и не будет достигнут через @sc{cdr}.

@example
@group
(setq x '(1 2 3))
     @result{} (1 2 3)
@end group
@group
(setcdr x '(4))
     @result{} (4)
@end group
@group
x
     @result{} (1 4)
@end group
@end example

  Вы можете удалить элементы из середины списка, изменяя @sc{cdr} в
  нужной cons-ячейки списка.  Например, здесь мы удалим второй
  элемент, @code{b}, из списка @code{(a b c)}, путем изменения @sc{cdr}
  первой cons-ячейки:

@example
@group
(setq x1 '(a b c))
     @result{} (a b c)
(setcdr x1 (cdr (cdr x1)))
     @result{} (c)
x1
     @result{} (a c)
@end group
@end example

  Вот наглядный результат в прямоугольной нотации:

@smallexample
@group
                   --------------------
                  |                    |
 --------------   |   --------------   |    --------------
| car   | cdr  |  |  | car   | cdr  |   -->| car   | cdr  |
|   a   |   o-----   |   b   |   o-------->|   c   |  nil |
|       |      |     |       |      |      |       |      |
 --------------       --------------        --------------
@end group
@end smallexample

@noindent
Вторая cons-ячейка, которую ранее занимал элемент @code{b}, по-прежнему
существует и её @sc{car} всё ещё @code{b}, но она больше не является частью
этого списка.

  Столь же легко вставить новый элемент, изменив @sc{cdr}:

@example
@group
(setq x1 '(a b c))
     @result{} (a b c)
(setcdr x1 (cons 'd (cdr x1)))
     @result{} (d b c)
x1
     @result{} (a d b c)
@end group
@end example

  Вот этот результат для наглядности в прямоугольной нотации:

@smallexample
@group
 --------------        -------------       -------------
| car  | cdr   |      | car  | cdr  |     | car  | cdr  |
|   a  |   o   |   -->|   b  |   o------->|   c  |  nil |
|      |   |   |  |   |      |      |     |      |      |
 --------- | --   |    -------------       -------------
           |      |
     -----         --------
    |                      |
    |    ---------------   |
    |   | car   | cdr   |  |
     -->|   d   |   o------
        |       |       |
         ---------------
@end group
@end smallexample

@node Rearrangement
@subsection Функции Реорганизации Списка
@cindex rearrangement of lists
@cindex reordering, of elements in lists
@cindex modification of lists

  Вот некоторые функции, которые деструктивно переупорядочивают список,
  путем изменения @sc{cdr} их составляющих cons-ячеек.  Эти функции
  деструдиктивны, потому что они перехватывают исходные списки, переданные
  им в качестве аргументов, связывая свои cons-ячейки для формирования нового
  списка, который высткпает в роли возвращаемого значения.

@ifnottex
  Смотри @code{delq}, в @ref{Sets And Lists}, другую функцию, которая
  модифицирует cons-ячейки.
@end ifnottex
@iftex
   Функция @code{delq} в следующем разделе является еще одним примером
   деструктивной манипуляции со списком.
@end iftex

@defun nconc &rest lists
@cindex concatenating lists
@cindex joining lists
Функция возвращает список, содержащий все элементы @var{lists}.  В отличие от
@code{append} (@pxref{Building Lists}), @var{lists} @emph{не} копируются.
Вместо этого, последний @sc{cdr} каждого из @var{lists} изменяется, чтобы
ссылаться к следующему элементу списка.  Последний из @var{lists} не
изменяется.
Например:

@example
@group
(setq x '(1 2 3))
     @result{} (1 2 3)
@end group
@group
(nconc x '(4 5))
     @result{} (1 2 3 4 5)
@end group
@group
x
     @result{} (1 2 3 4 5)
@end group
@end example

   Так как последний аргумент @code{nconc} сами по себе не изменяется, то
   разумно использовать постоянный список, например, @code{'(4 5)}, как в
   приведенном выше примере. По этой же причине, последний аргумент не
   обязательно должен быть списком:

@example
@group
(setq x '(1 2 3))
     @result{} (1 2 3)
@end group
@group
(nconc x 'z)
     @result{} (1 2 3 . z)
@end group
@group
x
     @result{} (1 2 3 . z)
@end group
@end example

Тем не менее, другие аргументы (все, кроме последнего) должны быть спиками.

Типичная ошибка является использование цитируемого списка как в качестве
не последнего аргумента @code{nconc}.  Если вы это сделаете, ваша программа
будет меняться каждый раз, когда вы запустите её!  Вот что происходит:

@smallexample
@group
(defun add-foo (x)            ; @r{Мы хотим, чтобы функция, добавляла
       (nconc '(foo) x))      ; @code{foo} к передней части своего аргумента}

@end group

@group
(symbol-function 'add-foo)
     @result{} (lambda (x) (nconc (quote (foo)) x))
@end group

@group
(setq xx (add-foo '(1 2)))    ; @r{Это похоже работает.}
     @result{} (foo 1 2)
@end group
@group
(setq xy (add-foo '(3 4)))    ; @r{Что произошло?}
     @result{} (foo 1 2 3 4)
@end group
@group
(eq xx xy)
     @result{} t
@end group

@group
(symbol-function 'add-foo)
     @result{} (lambda (x) (nconc (quote (foo 1 2 3 4) x)))
@end group
@end smallexample
@end defun

@node Sets And Lists
@section Использование Списка как Множества
@cindex lists as sets
@cindex sets

  Список может представлять собой неупорядоченное математическое множество -
  просто считается значение элементом множества, если значение появляется в
  списке где игнорируется порядок списка.  Для того, чтобы сформировать
  объединение двух множеств, используется @code{append} (до тех пор, пока
  нет возражений относительно дубликатов элементов).  Есть возможность
  удалить дубликаты по признаку @code{equal} с помощью @code{delete-dups}.
  Другие полезные функции для множеств это @code{memq} и @code{delq} и их
  версии @code{equal}, @code{member} и @code{delete}.

@cindex CL note---lack @code{union}, @code{intersection}
@quotation
@b {Common Lisp Примечание:} Common Lisp имеет функции @code{union} (что
позволяет избежать дублирования элементов) и @code{intersection} для операций
над множествами.  Хотя стандарт GNU Emacs Lisp не имеет их, библиотека
@file{cl-lib} предоставляет аналогичную версию.
@xref{Lists as Sets,,, cl, Common Lisp Extensions}.
@end quotation

@defun memq object list
@cindex membership in a list
Функция проверяет, является ли @var{object} членом @var{list}.  Если это так,
@code{memq} возвращает список, начинающийся с первого появления @var{object}.
В противном случае возвращается @code{nil}.  Буква @samp{q} в @code{memq}
означает, что используется @code{eq} для сравнения @var{object} с элементами
списка. Например:

@example
@group
(memq 'b '(a b c b a))
     @result{} (b c b a)
@end group
@group
(memq '(2) '((1) (2))) ; @r{@code{(2)} и @code{(2)} не удовлетворяют
                       ; @code{eq}.}
     @result{} nil
@end group
@end example
@end defun

@defun delq object list
@cindex deleting list elements
Функцией деструктивно удаляются все элементы из @var{list} , которые
удовлетворяют @code{eq} к заданному @var{object}, и возвращается полученный
список.  Буква @samp{q} в @code{delq} означает, что используется @code{eq}
для сравнения @var{object} с элементами списка, как @code{memq} и
@code{remq}.

Как правило, при вызове @code{delq}, вы должны использовать возвращаемое
значение, для присваивания его переменной, которая содержала первоначальный
список.  Причина этого объясняется ниже.
@end defun

Функцией @code{delq} удаляются элементы из передней части списка, просто
продвигаясь вниз по списку, и возвращается подсписок, который начинается
после этих элементов. Например:

@example
@group
(delq 'a '(a b c)) @equiv{} (cdr '(a b c))
@end group
@end example

@noindent
Когда элемент, который будет удален, появится в середине списка, его удаление
предполагает изменение @sc{cdr}-ов (@pxref{Setcdr}).

@example
@group
(setq sample-list '(a b c (4)))
     @result{} (a b c (4))
@end group
@group
(delq 'a sample-list)
     @result{} (b c (4))
@end group
@group
sample-list
     @result{} (a b c (4))
@end group
@group
(delq 'c sample-list)
     @result{} (a b (4))
@end group
@group
sample-list
     @result{} (a b (4))
@end group
@end example

Обратите внимание, что в @code{(delq 'c sample-list)} модифицируется
@code{sample-list} для сращивания, начиная с третьего элемента, а в
@code{(delq 'a sample-list)} не сращивается ничего---просто возвращается
обрезанный список.  Не думайте, что переменная, которая ранее удерживала
аргумент @var{list} теперь имеет меньше элементов, или, что всё ещё
существует первоначальный список!  Вместо этого, сохраняйте результат
@code{delq} и используйте его.  Чаще всего сохраняется результат обратно в
переменную, которая держала первоначальный список:

@example
(setq цветы (delq 'роза цветы))
@end example

В следующем примере, с @code{delq} задаётся значение @code{(4)} для
сравнения, но @code{(4)} не удовлетворяет @code{eq} элементам
@code{sample-list} :

@example
@group
(delq '(4) sample-list)
     @result{} (a c (4))
@end group
@end example

Если требуется удалить элементы, которые удовлетворяют @code{equal} к
заданному значению, используется функция @code{delete} (смотри ниже).

@defun remq object list
Функция возвращает копию @var{list}, без всех элементов, которые
удовлетворяют @code{eq} заданному значению @var{object}.  Буква @samp{q} в
@code{remq} означает использование @code{eq} для сравнения заданному
@var{object} с элементами @code{list}.

@example
@group
(setq sample-list '(a b c a b c))
     @result{} (a b c a b c)
@end group
@group
(remq 'a sample-list)
     @result{} (b c b c)
@end group
@group
sample-list
     @result{} (a b c a b c)
@end group
@end example
@end defun

@defun memql object list
Функцией @code{memql} проверяется, присутствует ли @var{object} в числе
@var{list}, путём сопоставления каждого присутствующего на удовлетворение
@code{eql} с @var{object}, так что элементы @var{list}, представляющие числа
с плавающей точкой, сравниваются по значению.  Если @var{object} состоит в
@var{list}, @code{memql} возвращается список, который начинается с первого
вхождения @var{object} в @var{list}.  В противном случае возвращается
@code{nil}.

Для сравнения с @code{memq}:

@example
@group
(memql 1.2 '(1.1 1.2 1.3))  ; @r{@code{1.2} и @code{1.2} удовлетворяет
                            ; @code{eql}.}
     @result{} (1.2 1.3)
@end group
@group
(memq 1.2 '(1.1 1.2 1.3))  ; @r{@code{1.2} и @code{1.2} не удовлетворяет
                           ; @code{eq}.}
     @result{} nil
@end group
@end example
@end defun

Следующие три функции, @code{memq}, @code{delq} и @code{remq}, используют
@code{equal}, вместо @code{eq} для сравнения элементов.
@xref{Equality Predicates}.

@defun member object list
Функцией @code{member} проверяется, входит ли @var{object} в @var{list},
по условию @code{equal}.  Если @var{object} входит в @var{list},
@code{member} возвращается список, начинающийся с его первого вхождения в
@var{list}.  В противном случае возвращается @code{nil}.

Для сравнения с @code{memq}:

@example
@group
(member '(2) '((1) (2)))  ; @r{@code{(2)} и @code{(2)} удовлетворяет
                          ; @code{equal}.}
     @result{} ((2))
@end group
@group
(memq '(2) '((1) (2)))    ; @r{@code{(2)} и @code{(2)} не удовлетворяет
                          ; @code{eq}.}
     @result{} nil
@end group
@group
;; @r{Две строки с одинаковым содержимым удовлетворяют @code{equal}.}
(member "foo" '("foo" "bar"))
     @result{} ("foo" "bar")
@end group
@end example
@end defun

@defun delete object sequence
Функцией удаляются все элементы, удовлетворяющие @code{equal} к @var{object}
из @var{sequence} и возвращается результирующая последовательность.

Если @var{sequence} представляет собой список, @code{delete} отличается от
@code{delq} как @code{member} отличается от @code{memq}: используется
условие @code{equal} для сравнения элементов с @var{object}, как в функции
@code{member}; когда находится совпадающий элемент, список разрезается именно
так, как с использованием @code{delq}.  Как и в случае использования
@code{delq}, нужно, как правило, использовать возвращаемое значение,
присвоив его переменной, которая содержала первоначальный список.

Если @code{sequence} представляет собой вектор или строку, @code{delete}
возвращается копия @code{sequence}, без элементов, удалённых по условию
@code{equal} к заданному значению @code{object}.

For example:

@example
@group
(setq l '((2) (1) (2)))
(delete '(2) l)
     @result{} ((1))
l
     @result{} ((2) (1))
;; @r{Если требуется изменить @code{l} точно,}
;; @r{записывается @code{(setq l (delete '(2) l))}.}
@end group
@group
(setq l '((2) (1) (2)))
(delete '(1) l)
     @result{} ((2) (2))
l
     @result{} ((2) (2))
;; @r{В этом случае, не имеет никакого значения, установлен ли @code{l},}
;; @r{но нужно использовать это ради другого случая.}
@end group
@group
(delete '(2) [(2) (1) (2)])
     @result{} [(1)]
@end group
@end example
@end defun

@defun remove object sequence
Функция представляет собой неразрушающий аналог функции @code{delete}.
Возвращается копия @code{sequence}, списка, вектора, или строки, без
элементов, удалённых по условию @code{equal} с заданным значением
@code{object}.  Например:

@example
@group
(remove '(2) '((2) (1) (2)))
     @result{} ((1))
@end group
@group
(remove '(2) [(2) (1) (2)])
     @result{} [(1)]
@end group
@end example
@end defun

@quotation
@b{Common Lisp примечание:} Функции @code{member}, @code{delete} и
@code{remove} в GNU Emacs Lisp являются производными от Maclisp, а не
Common Lisp.  Версии Common Lisp не используют @code{equal} для сравнения
элементов.
@end quotation

@defun member-ignore-case object list
Функция подобна @code{member}, за исключением того, что @var{object} должен
быть строкой, и игнорируются различия написания регистра букв и текстового
представления: буквы верхнего-регистра и нижнего-регистра, рассматриваются
как равные, и однобайтные строки преобразуются в многобайтовый до сравнения.
@end defun

@defun delete-dups list
Функция деструктивно удаляет все дубликаты из @var{list}, удовлетворяющие
условию @code{equal}, результат сохраняется в @var{list} и он же
возвращается.  Из нескольких вхождений элемента в @var{list}, попадающих под
условие @code{equal}, @code{delete-dups} оставляет только первый.
@end defun

  Смотрите также функцию @code{add-to-list}, в @ref{List Variables},
  способ, чтобы добавить элемент в список хранящийся в переменной и
  используемый в качестве коллекции.

@node Association Lists
@section Ассоциативные Списки
@cindex association list
@cindex alist

  @dfn{Ассоциативный список} или @dfn{alist} для краткости, имеет отображение
  ключей к значениям.  Это список из cons-ячеек называемыми
  @dfn{ассоциациями}: для каждой такой cons-ячейки слот @sc{car}---это
  @dfn{ключ}, а слот @sc{cdr}---её @dfn{ассоциативное значение}.@footnote{
  Такое использование ``ключ'' не связано с термином ``ключевая
  последовательность''; которое предназначено для поиска элемента в таблице.
  В данном случае таблица представляется ассоциативным списком, а ассоциации
  списка - это его элементы.}

  Ниже приведен пример ALIST.  Ключ @code{сосна} связан со значением
  @code{шишки}; ключ @code{дуб} связан с @code{жёлудь}; а ключ
  @code{клён} связан с @code{семя}.

@example
@group
((сосна . шишки)
 (дуб . жёлудь)
 (клён . семя))
@end group
@end example

  И значения и ключи в ассоциативном списке, могут быть любыми объектами
  Lisp.  Например, в следующем ALIST, символ @code{a} связан с числом
  @code{1}, а строка @code{"b"} связана с @emph{списком} @code{(2 3)},
  который является @sc{cdr} элемента ALIST:

@example
((a . 1) ("b" 2 3))
@end example

  Иногда требуется разработать ассоциативный список, который хранит
  соответствующее значение в @sc{car} а не в @sc{cdr} элемента.  Ниже
  приведен пример такого ALIST:

@example
((роза красная) (лилия белая) (лютик желтый))
@end example

@noindent
Здесь рассматривается @code{красная} как значение, связанное с @code{роза}.
Одним из преимуществ такого рода ALIST является то, что вы можете хранить
другую сопутствующую информацию---даже список других элементов---@sc{cdr}
в @sc{cdr} (ВопросLists1514).  Одним из недостатков этого то, что нет
возможности использовать @code{rassq} (смотри ниже), чтобы найти элемент,
содержащий заданное значение.  Когда это не принципиально, выбор - дело
вкуса, если придерживаться такого подхода для определённого такого списка.

  Тот же ALIST, показаный выше, можно рассматривать как имеющий связаные
  значения в @sc{cdr} элемента; значение, связанное с @code{роза} будет
  список @code{(красная)}. 

  Ассоциативные списки часто используются для записи информации, которая
  представляется как стек, така ка новые ассоциации могут быть легко
  добавлены в передней части списка.  При поиске по ассоциативному списку
  ассоциации с определённым ключом, возвращается первая найденная ассоциация,
  если одинаковых ключей больше одного.

  В Emacs Lisp, это @emph{не} ошибка, если элемент ассоциативного списка не
  cons-ячейка.  Функции поиска в alist, просто игнорируют такие элементы.
  Многие другие версии Lisp сигнализируют ошибку в таких случаях.

  Обратите внимание, что списки свойств аналогичны ассоциативным спискам в
  нескольких отношениях.  Список свойств ведет себя как ассоциативный список,
  в котором каждый ключ гарантировано присутствует один раз.
  @xref{Property Lists}, для сравнения списков свойств и списков ассоциаций.

@defun assoc key alist &optional testfn
Функция возвращает первую ассоциацию @var{key} в @var{alist}, сравнивая
@var{key} с элементами ALIST с помощью функции @var{testfn} предоставляющей
условие, если не указано не-@code{nil} и используя условие @code{equal} в
противном случае (@pxref{Equality Predicates}).  Возвращается @code{nil},
если ни одна ассоциация в @var{alist} не имеет слота @sc{car} сопоставимому
с @var{key}. Например:

@smallexample
(setq деревья '((сосна . шишки) (дуб . жёлудь) (клён . семя)))
     @result{} ((сосна . шишки) (дуб . жёлудь) (клён . семя))
(assoc 'дуб деревья)
     @result{} (дуб . жёлудь)
(cdr (assoc 'дуб деревья))
     @result{} жёлудь
(assoc 'береза деревья)
     @result{} nil
@end smallexample

Вот еще один пример, в котором ключи и значения не являются символами:

@smallexample
(setq игл-на-кластер
      '((2 "Австрийская Сосна" "Красная Сосна")
        (3 "Смоляная Сосна")
        (5 "Белая Сосна")))

(cdr (assoc 3 игл-на-кластер))
     @result{} ("Смоляная Сосна")
(cdr (assoc 2 игл-на-кластер))
     @result{} ("Австрийская Сосна" "Красная Сосна")
@end smallexample
@end defun

  Функция @code{assoc-string} очень похожа на @code{assoc} кроме того, что
  игнорирует определенные различия между строками.  @xref{Text Comparison}.

@defun rassoc value alist
Функция возвращает первую найденную ассоциацию со значением @var{value} в
@var{alist}.  Возвращается @code{nil}, если ни одна ассоциация в @var{alist}
не имеет слот @sc{cdr} удовлетворяющий условию @code{equal} к @var{value}.

@code{rassoc}, имеет сходство с @code{assoc} за исключением того, что
сравнивается @sc{cdr} каждой ассоциации в @var{alist} вместо каждого
@sc{car}.  Можно рассматривать это как обратное @code{assoc}, поиск ключа для
заданного значения.
@end defun

@defun assq key alist
Функция подобна @code{assoc} в том, что возвращается первая ассоциация
с ключём @var{key} в @var{alist}, но сравнение выполняется с помощью
@code{eq}.  @code{assq} возвращает @code{nil}, если ни одна ассоциация в
@var{alist} не имеет слота @sc{car} подходящего условию @code{eq} к
@var{key}.  Эта функция используется чаще, чем @code{assoc}, так как
@code{eq} быстрее, чем @code{equal} и большинство alists используют
символы в качестве ключей.  @xref{Equality Predicates}.

@smallexample
(setq деревья '((сосна . шишки) (дуб . жёлуди) (клён . семя)))
     @result{} ((сосна . шишки) (дуб . жёлуди) (клён . семя))
(assq 'сосна деревья)
     @result{} (сосна . шишки)
@end smallexample

С другой стороны, @code{assq} не используется в ассоциативных списках, где
ключи могут быть не символами:

@smallexample
(setq листья
      '(("простые листья" . дуб)
        ("сложные листья" . конский каштан)))

(assq "простые листья" листья)
     @result{} nil
(assoc "простые листья" листья)
     @result{} ("простые листья" . дуб)
@end smallexample
@end defun

@defun alist-get key alist &optional default remove testfn
Функция аналогична @code{assq}.  Находит первую ассоциацию
@w{@code{(@var{key} . @var{value})}} сравнивая @var{key} с @code{car}
каждого элемента @var{alist} и, если обнаружено совпадение, возвращается
@var{value} этой ассоциации.  Если ни одна ассоциация не найдена, функция
возвращает @var{default}.  Сравнение @var{key} для элементов @var{alist}
использует функцию, заданную с помощью @var{testfn}, по умолчанию @code{eq}.

This is a generalized variable (@pxref{Generalized Variables})
that can be used to change a value with @code{setf}.  When
using it to set a value, optional argument @var{remove} non-@code{nil}
means to remove @var{key}'s association from @var{alist} if the new
value is @code{eql} to @var{default}.
@end defun

@defun rassq value alist
This function returns the first association with value @var{value} in
@var{alist}.  It returns @code{nil} if no association in @var{alist} has
a @sc{cdr} @code{eq} to @var{value}.

@code{rassq} is like @code{assq} except that it compares the @sc{cdr} of
each @var{alist} association instead of the @sc{car}.  You can think of
this as reverse @code{assq}, finding the key for a given value.

For example:

@smallexample
(setq trees '((pine . cones) (oak . acorns) (maple . seeds)))

(rassq 'acorns trees)
     @result{} (oak . acorns)
(rassq 'spores trees)
     @result{} nil
@end smallexample

@code{rassq} cannot search for a value stored in the @sc{car}
of the @sc{cdr} of an element:

@smallexample
(setq colors '((rose red) (lily white) (buttercup yellow)))

(rassq 'white colors)
     @result{} nil
@end smallexample

In this case, the @sc{cdr} of the association @code{(lily white)} is not
the symbol @code{white}, but rather the list @code{(white)}.  This
becomes clearer if the association is written in dotted pair notation:

@smallexample
(lily white) @equiv{} (lily . (white))
@end smallexample
@end defun

@defun assoc-default key alist &optional test default
This function searches @var{alist} for a match for @var{key}.  For each
element of @var{alist}, it compares the element (if it is an atom) or
the element's @sc{car} (if it is a cons) against @var{key}, by calling
@var{test} with two arguments: the element or its @sc{car}, and
@var{key}.  The arguments are passed in that order so that you can get
useful results using @code{string-match} with an alist that contains
regular expressions (@pxref{Regexp Search}).  If @var{test} is omitted
or @code{nil}, @code{equal} is used for comparison.

If an alist element matches @var{key} by this criterion,
then @code{assoc-default} returns a value based on this element.
If the element is a cons, then the value is the element's @sc{cdr}.
Otherwise, the return value is @var{default}.

If no alist element matches @var{key}, @code{assoc-default} returns
@code{nil}.
@end defun

@defun copy-alist alist
@cindex copying alists
This function returns a two-level deep copy of @var{alist}: it creates a
new copy of each association, so that you can alter the associations of
the new alist without changing the old one.

@smallexample
@group
(setq needles-per-cluster
      '((2 . ("Austrian Pine" "Red Pine"))
        (3 . ("Pitch Pine"))
@end group
        (5 . ("White Pine"))))
@result{}
((2 "Austrian Pine" "Red Pine")
 (3 "Pitch Pine")
 (5 "White Pine"))

(setq copy (copy-alist needles-per-cluster))
@result{}
((2 "Austrian Pine" "Red Pine")
 (3 "Pitch Pine")
 (5 "White Pine"))

(eq needles-per-cluster copy)
     @result{} nil
(equal needles-per-cluster copy)
     @result{} t
(eq (car needles-per-cluster) (car copy))
     @result{} nil
(cdr (car (cdr needles-per-cluster)))
     @result{} ("Pitch Pine")
@group
(eq (cdr (car (cdr needles-per-cluster)))
    (cdr (car (cdr copy))))
     @result{} t
@end group
@end smallexample

  This example shows how @code{copy-alist} makes it possible to change
the associations of one copy without affecting the other:

@smallexample
@group
(setcdr (assq 3 copy) '("Martian Vacuum Pine"))
(cdr (assq 3 needles-per-cluster))
     @result{} ("Pitch Pine")
@end group
@end smallexample
@end defun

@defun assq-delete-all key alist
This function deletes from @var{alist} all the elements whose @sc{car}
is @code{eq} to @var{key}, much as if you used @code{delq} to delete
each such element one by one.  It returns the shortened alist, and
often modifies the original list structure of @var{alist}.  For
correct results, use the return value of @code{assq-delete-all} rather
than looking at the saved value of @var{alist}.

@example
(setq alist '((foo 1) (bar 2) (foo 3) (lose 4)))
     @result{} ((foo 1) (bar 2) (foo 3) (lose 4))
(assq-delete-all 'foo alist)
     @result{} ((bar 2) (lose 4))
alist
     @result{} ((foo 1) (bar 2) (lose 4))
@end example
@end defun

@defun assoc-delete-all key alist
This function deletes from @var{alist} all the elements whose @sc{car}
is @code{equal} to @var{key}.  It works like @code{assq-delete-all},
except for the predicate used for comparing alist elements with
@var{key}.
@end defun

@defun rassq-delete-all value alist
This function deletes from @var{alist} all the elements whose @sc{cdr}
is @code{eq} to @var{value}.  It returns the shortened alist, and
often modifies the original list structure of @var{alist}.
@code{rassq-delete-all} is like @code{assq-delete-all} except that it
compares the @sc{cdr} of each @var{alist} association instead of the
@sc{car}.
@end defun

@node Property Lists
@section Property Lists
@cindex property list
@cindex plist

  A @dfn{property list} (@dfn{plist} for short) is a list of paired
elements.  Each of the pairs associates a property name (usually a
symbol) with a property or value.  Here is an example of a property
list:

@example
(pine cones numbers (1 2 3) color "blue")
@end example

@noindent
This property list associates @code{pine} with @code{cones},
@code{numbers} with @code{(1 2 3)}, and @code{color} with
@code{"blue"}.  The property names and values can be any Lisp objects,
but the names are usually symbols (as they are in this example).

  Property lists are used in several contexts.  For instance, the
function @code{put-text-property} takes an argument which is a
property list, specifying text properties and associated values which
are to be applied to text in a string or buffer.  @xref{Text
Properties}.

  Another prominent use of property lists is for storing symbol
properties.  Every symbol possesses a list of properties, used to
record miscellaneous information about the symbol; these properties
are stored in the form of a property list.  @xref{Symbol Properties}.

@menu
* Plists and Alists::           Comparison of the advantages of property
                                  lists and association lists.
* Plist Access::                Accessing property lists stored elsewhere.
@end menu

@node Plists and Alists
@subsection Property Lists and Association Lists
@cindex plist vs. alist
@cindex alist vs. plist

@cindex property lists vs association lists
  Association lists (@pxref{Association Lists}) are very similar to
property lists.  In contrast to association lists, the order of the
pairs in the property list is not significant, since the property
names must be distinct.

  Property lists are better than association lists for attaching
information to various Lisp function names or variables.  If your
program keeps all such information in one association list, it will
typically need to search that entire list each time it checks for an
association for a particular Lisp function name or variable, which
could be slow.  By contrast, if you keep the same information in the
property lists of the function names or variables themselves, each
search will scan only the length of one property list, which is
usually short.  This is why the documentation for a variable is
recorded in a property named @code{variable-documentation}.  The byte
compiler likewise uses properties to record those functions needing
special treatment.

  However, association lists have their own advantages.  Depending on
your application, it may be faster to add an association to the front of
an association list than to update a property.  All properties for a
symbol are stored in the same property list, so there is a possibility
of a conflict between different uses of a property name.  (For this
reason, it is a good idea to choose property names that are probably
unique, such as by beginning the property name with the program's usual
name-prefix for variables and functions.)  An association list may be
used like a stack where associations are pushed on the front of the list
and later discarded; this is not possible with a property list.

@node Plist Access
@subsection Property Lists Outside Symbols
@cindex plist access
@cindex accessing plist properties

  The following functions can be used to manipulate property lists.
They all compare property names using @code{eq}.

@defun plist-get plist property
This returns the value of the @var{property} property stored in the
property list @var{plist}.  It accepts a malformed @var{plist}
argument.  If @var{property} is not found in the @var{plist}, it
returns @code{nil}.  For example,

@example
(plist-get '(foo 4) 'foo)
     @result{} 4
(plist-get '(foo 4 bad) 'foo)
     @result{} 4
(plist-get '(foo 4 bad) 'bad)
     @result{} nil
(plist-get '(foo 4 bad) 'bar)
     @result{} nil
@end example
@end defun

@defun plist-put plist property value
This stores @var{value} as the value of the @var{property} property in
the property list @var{plist}.  It may modify @var{plist} destructively,
or it may construct a new list structure without altering the old.  The
function returns the modified property list, so you can store that back
in the place where you got @var{plist}.  For example,

@example
(setq my-plist '(bar t foo 4))
     @result{} (bar t foo 4)
(setq my-plist (plist-put my-plist 'foo 69))
     @result{} (bar t foo 69)
(setq my-plist (plist-put my-plist 'quux '(a)))
     @result{} (bar t foo 69 quux (a))
@end example
@end defun

@defun lax-plist-get plist property
Like @code{plist-get} except that it compares properties
using @code{equal} instead of @code{eq}.
@end defun

@defun lax-plist-put plist property value
Like @code{plist-put} except that it compares properties
using @code{equal} instead of @code{eq}.
@end defun

@defun plist-member plist property
This returns non-@code{nil} if @var{plist} contains the given
@var{property}.  Unlike @code{plist-get}, this allows you to distinguish
between a missing property and a property with the value @code{nil}.
The value is actually the tail of @var{plist} whose @code{car} is
@var{property}.
@end defun
