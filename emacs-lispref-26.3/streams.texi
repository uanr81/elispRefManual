@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1994, 1998-1999, 2001-2019 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Read and Print
@chapter Чтение и Печатное Представление Lisp Объектов

  @dfn{Печать} и @dfn{чтение} Lisp объектов являются операциями
  преобразования Lisp объектов в текстовую форму и наоборот. Они
  используют печатные представления и синтаксис чтения, описанный
  в @ref{Lisp Data Types}.

  В этой главе описываются функции Lisp для чтения и печати. Здесь
  также описываются @dfn{потоки}, которые определяют, где получить
  текст (при чтении) или куда поместить его (если печать).

@menu
* Streams Intro::     Обзор потоков, чтение и печать.
* Input Streams::     Различные типы данных, которые можно использовать как входные потоки.
* Input Functions::   Функции для чтения Lisp объектов из текста.
* Output Streams::    Различные типы данных, которые можно использовать как выходные потоки.
* Output Functions::  Функции для печати объектов Lisp в виде текста.
* Output Variables::  Переменные, контролирующие функции печати.
@end menu

@node Streams Intro
@section Введение в чтение и печать
@cindex Lisp reader
@cindex printing
@cindex reading

  @dfn{Чтение} Lisp объекта означает синтаксический анализ
  Lisp выражения в текстовой форме и создание соответствующего
  объекта Lisp. Вот как создаются программы на Lisp из файлов
  Lisp кода. Мы называем текст @dfn{чтение синтаксиса} объекта.
  Например, текст @samp{(a .@: 5)} - это синтаксис чтения для
  cons-ячейки, у которой @sc{car} указывает на @code{a} и
  @sc{cdr} указывает на 5.

  @dfn{Печать} Lisp объекта это средство, продуцирующие текст,
  которым представляется этот объект --- преобразования объекта
  в его @dfn{печатное преобразование} (@pxref{Printed Representation}).
  Печать cons-ячейки, описанной выше, даёт текст @samp{(a .@: 5)}.

  Чтение и печать - это более или менее обратимые операции:
  печать печатного представления объекта, обычно производит один и
  тот же отрывок текста, при чтении таких фрагментов текста,
  представляющие результат вывода на печать печатного представления объекта,
  обычно производит подобный вид объекта.  Например, печать
  символа @code{foo} производит текст @samp{foo}, и чтение этого
  текста - возвращает символ @code{foo}.  Печать списка, элементами которого
  являются @code{a} и @code{b} производит текст @samp{(a b)}, а при чтении
  этот текст дает список (это не тот же список) с элементами @code{a} и @code{b}.

  Тем не менее, эти две операции не точно обратными друг другу.
  Есть три вида исключений:

@itemize @bullet
@item
Печать может производить текст, который не может быть прочитан.
Например, буферы, окна, фреймы, подпроцессы и маркеры печатаются как
текст, который начинается с @samp{#}; если вы пытаетесь прочитать
этот текст, вы получите сообщение об ошибке.  Нет никакого способа,
чтобы прочитать эти типы данных.

@item
Один объект может иметь несколько текстовых представлений. Например,
@samp{1} и @samp{01} представляют собой одно и то же целое число,
и @samp{(a b)} и @samp{(a .@: (b))} представляют один и тот же список.
Чтение будет принимать любой из альтернатив, но при печати необходимо
выбрать один из них.

@item
Комментарии могут появляться в определенных точках в промежутках
последовательности чтения объектов, не влияя на результат чтения.
@end itemize

@node Input Streams
@section Входные потоки
@cindex stream (for reading)
@cindex input stream

  Большинство функций Lisp для чтения текста принимают @dfn{входной поток}
  в качестве аргумента. Входной поток указывает, где и как получить символы
  текста для чтения. Вот возможные типы входного потока:

@table @asis
@item @var{буфер}
@cindex buffer input stream
Входные символы считываются из @var{буфера}, начиная с символа сразу
после точки. Точка перемещается вперёд по мере чтения символов.

@item @var{маркер}
@cindex marker input stream
Входные символы считываются из буфера, в котором находится @var{маркер},
начиная с символа сразу после маркера. Положение маркера сдвигается по мере
считывания символов. Значение точки в буфере не имеет никакого эффекта,
когда поток является маркером.

@item @var{строка}
@cindex string input stream
Входные символы берутся из @var{строки}, начиная с первого символа
в строке и используя столько символов, сколько требуется.

@item @var{функция}
@cindex function input stream
Входные символы генерируются @var{функцией}, которая должна поддерживать
два типа вызовов:

@itemize @bullet
@item
Когда она вызывается без аргументов, то она должна
возвращать следующий символ.

@item
Когда она вызывается с одним аргументом (всегда символ), @var{функция} должна
сохранить аргумент и организовать его возврат при следующем вызове.  Это
называется @dfn{непрочитанием} символа; это происходит, когда читатель Lisp
слишком часто читает один символ, и хочет, положить его туда, откуда
он пришел. В этом случае, не имеет значения, какое значение @var{функция}
возвращает.
@end itemize

@item @code{t}
@cindex @code{t} input stream
@code{t} в качестве потока, означает использовать считываемый из минибуфера
входной сигнал. На самом деле, минибуфер вызывается один раз, и текст,
предоставленный пользователем, преобразуется в строку, которая затем
используется в качестве входного потока. Если Emacs работает в пакетном режиме,
стандартный ввод используется вместо минибуфера. Например,
@example
(message "%s" (read t))
@end example
будет читать выражение Lisp из стандартного ввода и выводить результат
на стандартный вывод.

@item @code{nil}
@cindex @code{nil} input stream
@code{nil} предоставленный в качестве входного потока означает использование
значение @code{стандартного ввода} вместо этого значения; это значение
является @dfn{поток ввода по умолчанию}, и должен быть входной поток не-@code{nil}.

@item @var{symbol}
Символ в качестве входного потока эквивалентно определению
символа как функции (если таковые имеются).
@end table

  Ниже приведен пример чтения из потока, который представляет
  собой буфер, показывающий, где точка находится до и
  после:

@example
@group
---------- Буфер: foo ----------
Здесь@point{} некоторое содержимое буфера foo.
---------- Буфер: foo ----------
@end group

@group
(read (get-buffer "foo"))
     @result{} некоторое
@end group
@group
(read (get-buffer "foo"))
     @result{} содержимое
@end group

@group
---------- Буфер: foo ----------
Здесь некоторое содержимое@point{} буфера foo.
---------- Буфер: foo ----------
@end group
@end example

@noindent
Обратите внимание, что при первом чтение пропускает пробел. При чтение
пропускается любое количество пробелов перед значимым текстом.

  Ниже приведен пример чтения из потока, который является маркером,
  изначально расположеным в начале показанного буфера. Считываемое значение -
  является символом @code{Здесь}.

@example
@group

---------- Buffer: foo ----------
Здесь некоторое содержимое буфера foo.
---------- Buffer: foo ----------
@end group

@group
(setq m (set-marker (make-marker) 1 (get-buffer "foo")))
     @result{} #<marker at 1 in foo>
@end group
@group
(read m)
     @result{} Здесь
@end group
@group
m
     @result{} #<marker at 6 in foo>   ;; @r{Перед первым пробелом.}
@end group
@end example

  Здесь мы читаем содержимое строки:

@example
@group
(read "(Когда в) курсе")
     @result{} (Когда в)
@end group
@end example

  В следующем примере выполняется чтение из минибуфера.
  Подчсказка: @w{@samp{Lisp expression: }}. (Это приглашение
  используется всегда когда чтение из потока @code{t}.) Ввод
  пользователя отображается после приглашения.

@example
@group
(read t)
     @result{} 23 (#o27, #x17, ?\C-w)
---------- Буфер: Minibuffer ----------
Lisp expression: @kbd{23 @key{RET}}
---------- Буфер: Minibuffer ----------
@end group
@end example

  Наконец, вот пример потока, который является функцией, с именем
  @code{useless-stream}. Перед тем, как использовать этот поток,
  мы инициализируем переменную @code{useless-list} списком символов.
  Затем каждый вызов функции @code{useless-stream} получает следующий
  символ в списке или нечитаемый символ, добавив его в передней части
  списка.

@example
@group
(setq useless-list (append "XY()" nil))
     @result{} (88 89 40 41)
@end group

@group
(defun useless-stream (&optional unread)
  (if unread
      (setq useless-list (cons unread useless-list))
    (prog1 (car useless-list)
           (setq useless-list (cdr useless-list)))))
     @result{} useless-stream
@end group
@end example

@noindent
Теперь мы читаем, используя построенный таким образом поток:

@example
@group
(read 'useless-stream)
     @result{} XY
@end group

@group
useless-list
     @result{} (40 41)
@end group
@end example

@noindent
Обратите внимание, что открывающая и закрывающая скобки
остаются в списке.  Читатель Lisp обнаружил открытую скобку,
решил, что она завершает ввод, и не прочитал его. Еще одна
попытка чтения из потока в этой точке будет читать
@samp{()} и вернёт @code{nil}.

@node Input Functions
@section Функции Ввода

  В этом разделе описаны функции и переменные Lisp, которые относятся к чтению.

  В приведенных ниже функций, @var{поток} означает входной поток
  (см. предыдущий раздел). Если @var{поток} @code{nil} или опущен,
  то по умолчанию значению @code{standard-input} (стандартный ввод).

@kindex end-of-file
  Сообщение @code{end-of-file} об ошибке выдаётся, если при чтении встречается
  незаконченный список, вектор или строка.

@defun read &optional stream
Эта функция считывает одно текстовое выражение Lisp из @var{потока}, возвращая
его как объект Lisp. Это основная функция ввода Lisp.
@end defun

@defun read-from-string string &optional start end
@cindex string to object
Эта функция читает первое текстовое выражение Lisp из текста в @var{string}.
Она возвращает cons-ячейку, @sc{car} которой является этим выражением, а
@sc{cdr} представляет собой целое число, задающего позицию следующего
оставшегося символа в строке (то есть, первого не прочитанного).

Если задан аргумент @var{start}, то чтение начинается с индекса @var{start}
в строке (где первый символ с индексом 0). Если задан @var{end}, то считывание
остановиться как раз перед этим индексом, как будто остальной строки там не было.

Например:

@example
@group
(read-from-string "(setq x 55) (setq y 5)")
     @result{} ((setq x 55) . 11)
@end group
@group
(read-from-string "\"Здесь короткая строка\"")
     @result{} ("Здесь короткая строка" . 23)
@end group

@group
;; @r{Читать, начиная с первого символа.}
(read-from-string "(список 112)" 0)
     @result{} ((list 112) . 12)
@end group
@group
;; @r{Читать, начиная со второго символа.}
(read-from-string "(список 112)" 1)
     @result{} (список . 7)
@end group
@group
;; @r{Читать, начиная с седьмого символа,}
;;   @r{и остановиться на девятом.}
(read-from-string "(список 112)" 6 8)
     @result{} (к . 7)
@end group
@group
;; @r{Читать, начиная с седьмого символа,}
;;   @r{и остановиться на девятом.}
(read-from-string "(списочек 112)" 6 8)
     @result{} (че . 8)
@end group
@end example
@end defun

@defvar standard-input
Эта переменная содержит входной поток по умолчанию --- поток, который
использует @code{чтатель Lisp}, когда аргумент @var{потока} указывает на @code{nil}.
По умолчанию @code{t}, то есть используется минибуфер.
@end defvar

@defvar read-circle
Если эта переменная установлена в не-@code{nil}, позволяет чтение циклических
и общих структур. @xref{Circular Objects}. Его значение по умолчанию
@code{t}.
@end defvar

@cindex binary I/O in batch mode
При чтении или записи из стандартного ввода/вывода потоков процесса Emacs
в пакетном режиме, иногда требуется убедиться, что произвольные двоичные
данные будут прочитаны/записаны дословно, и что учитывается присутствие
пар CR-LF (перевод строки и/ или возврат корректки). Эта проблема не
существует для POSIX хостов, только для MS-Windows и MS-DOS@. Следующая
функция позволяет управлять режимом I/O любого стандартного потока процесса
Emacs.

@defun set-binary-mode stream mode
Переключение потока @var{stream} в режим  двоичного или текстового
ввода/вывода. Если @var{mode} является не-@code{nil}, переключиться в
двоичный режиме, в противном случае перейти в текстовый режим. Значение
потока @var{stream} может быть одним из @code{stdin}, @code{stdout} или
@code{stderr}. Эта функция сбрасывает все ожидающие выходные данные
потока @var{stream} в качестве побочного эффекта, и возвращает предыдущее
значение режима ввода/вывода для потока @var{stream}. На POSIX хостах,
всегда возвращается значение не-@code{nil} и не делается ничего, кроме
сброса ожидающих данных.
@end defun

@node Output Streams
@section Выходные потоки
@cindex stream (for printing)
@cindex output stream

  Выходной поток указывает, что делать с символами, полученными при
  печати. Большинство функций печати принимают выходной поток в качестве
  необязательного аргумента. Вот возможные типы выходного потока:

@table @asis
@item @var{buffer}
@cindex buffer output stream
Выходные символы вставляются в @var{buffer} в точке. Точка продвигается
вперёд по мере вставки символов.

@item @var{marker}
@cindex marker output stream
Выходные символы вставляются в буфер, в позицию  на который указывает
@var{marker}. Зачение маркера увеличивается по мере вставки символов.
Значение точки в буфере не имеет никакого эффекта на печать, когда
поток является маркером, и этот вид печати не перемещает точку
(кроме того, если маркер указывает на позицию точки или же на позицию
до точки).

@item @var{function}
@cindex function output stream
Выходные символы передаются @var{function}, которая отвечает за их хранение.
Она вызывается с одним символом в качестве аргумента, столько раз, сколько
символов для вывода, и отвечает за сохранение символов в любом месте,
где вы хотите их поместить.

@item @code{t}
@cindex @code{t} output stream
Выходные символы отображаются в эхо-области.

@item @code{nil}
@cindex @code{nil} output stream
@code{nil} в качестве выходного потока, указывает использовать значение
@code{standard-output}; это значение является
@dfn{потоком вывода по умолчанию}, и не должно быть @code{nil}.

@item @var{symbol}
Символ в качестве выходного потока эквивалентно определению
символа функции (если таковые имеются).
@end table

  Многие допустимые выходные потоки также действительны как входные
  потоки. Таким образом, разница между входными и выходными потоками
  больше зависит от того, как вы используете объект Lisp, чем
  от типа объекта.

  Ниже приведен пример буфера, используемого в качестве выходного потока.
  Точка изначально находится, как показано непосредственно перед первым @samp{а}
  в @samp{файла}. В конце концов, точка расположена непосредственно перед
  тем же @samp{а}.

@cindex print example
@example
@group
---------- Буфер: foo ----------
Это полное содержимое ф@point{}айла foo.
---------- Буфер: foo ----------
@end group

(print "Это то что на выходе" (get-buffer "foo"))
     @result{} "Это то что на выходе"

@group
---------- Буфер: foo ----------
Это полное содержимое ф
"Это то что на выходе"
@point{}айла foo.
---------- Буфер: foo ----------
@end group
@end example

  Теперь мы покажем использование маркера в качестве выходного потока.
  Изначально маркер находиться в буфере @code{foo} между @samp{к} и
  @samp{с} в слове @samp{текст}. В итоге, маркер продвинулся
  вперед вставленного текста, таким образом, он по-прежнему позиционируется
  перед тем же @samp{с}. Обратите внимание, что расположение точки, как
  показано обычным способом, не изменилось.

@example
@group
---------- Буфер: foo ----------
@point{}Здесь текст для выхода 
---------- Буфер: foo ----------
@end group

@group
(setq m (copy-marker 10))
     @result{} #<marker at 10 in foo>
@end group

@group
(print "Ещё выход для foo." m)
     @result{} "Ещё выход для foo."
@end group

@group
---------- Буфер: foo ----------
@point{}Здесь тек
"Ещё выход для foo."
cт для выхода
---------- Буфер: foo ----------
@end group

@group
m
     @result{} #<marker at 32 in foo>
@end group
@end example

  Следующий вывод в области эха примера показывает:

@example
@group
(print "Выход Эхо Область" t)
     @result{} "Выход Эхо Область"
---------- Эхо Область ----------
"Echo Area output"
---------- Эхо Область ----------
@end group
@end example

  Наконец, мы покажем, использование функции в качестве выходного потока. Функция
  @code{eat-output} принимает каждый заданный символ, и помещает его в начало
  списка @code{last-output} (@pxref{Building Lists}). В конце концов, список
  содержит все символы вывода, но в обратном порядке.

@example
@group
(setq last-output nil)
     @result{} nil
@end group

@group
(defun eat-output (c)
  (setq last-output (cons c last-output)))
     @result{} eat-output
@end group

@group
(print "Это пример вывода" #'eat-output)
     @result{} "Это пример вывода"
@end group

@group
last-output
     @result{} (10 34 1072 1076 1086 1074 1099 1074 32 1088 1077 1084 ...)
@end group
@end example

@noindent
Теперь мы можем расположить вывод в правильном порядке, путем обращения списка:

@example
@group
(concat (nreverse last-output))
     @result{} "
\"Это пример вывода\"
"
@end group
@end example

@noindent
Вызов @code{concat} преобразует список в строку,
чтобы вы могли видеть его содержимое более четко.

@cindex @code{stderr} stream, use for debugging
@anchor{external-debugging-output}
@defun external-debugging-output character
Эта функция может быть полезна в качестве выходного потока при
отладке. Она записывает @var{character} в стандартный поток ошибок.

Например
@example
@group
(print "Это данные вывода" #'external-debugging-output)
@print{} Это данные вывода
@result{} "Это данные вывода"
@end group
@end example
@end defun

@node Output Functions
@section Функции Вывода

  В этом разделе описаны функции Lisp для печати Lisp объектов --- преобразование
  объектов в их печатное представление.

@cindex @samp{"} in printing
@cindex @samp{\} in printing
@cindex quoting characters in printing
@cindex escape characters in printing
  Некоторые функции печати Emacs добавляют символы кавычек,
  когда это необходимо, чтобы можно было правильно читать.
  Используются символы цитирования @samp{"} и @samp{\};
  они различают строки из символов, а также предотвращают
  использование знаков препинания в строках и символах
  в качестве разделителей при чтении. @xref{Printed Representation},
  для получения полной информации. Вы указываете цитирование или
  его отсутствие при выборе функции печати.

  Если текст должен быть обратно считан в Lisp, то вы должны напечатать с
  кавычками, чтобы избежать двусмысленности. Точно так же, если цель
  состоит в том, чтобы описать объект Lisp явно для Lisp программиста.
  Однако, если цель вывода хорошо выглядеть для людей, то,
  как правило, лучше печатать без кавычек.

  Объекты Lisp могут ссылаться на самих себя.  Обычная Печать такого объекта обычным
  способом потребовало бы бесконечное количество текста, а попытка может привести к
  бесконечной рекурсии. Emacs обнаруживает такую ​​рекурсию и печатает @samp{#@var{level}}
  вместо рекурсивной печати уже напечатаного объекта. Например, здесь @samp{#0}
  указывает на рекурсивную ссылку на объект на уровне 0 текущей операции печати:

@example
(setq foo (list nil))
     @result{} (nil)
(setcar foo foo)
     @result{} (#0)
@end example

  В приведенных ниже функциях, @var{stream} обозначает выходной поток.
  (В предыдущем разделе для описания выходных потоков. Благодаря
  @xref{external-debugging-output}, полезное значение потока для отладки).
  Если @var{stream} @code{nil} или опущен, то по умолчанию значениt
  @code{standard-output}.

@defun print object &optional stream
@cindex Lisp printer
@code{print} функция представляет собой удобный способ печати. Она
выдает печатное представление @var{object} в @var{stream}, в
дополнение печатая новую строку перед @var{object} и ещё одну
после него.  Используются кавычки. @code{print} возвращает
@var{object}. Например:

@example
@group
(progn (print 'Наш\ кот\ в)
       (print "любимой шляпе")
       (print " уже вернулся"))
     @print{}
     @print{} Наш\ кот\ в
     @print{}
     @print{} "любимой шляпе"
     @print{}
     @print{} " уже вернулся"
     @result{} " уже вернулся"
@end group
@end example
@end defun

@defun prin1 object &optional stream
Эта функция выводит печатное представление @var{object} в
@var{stream}. Она не печатает пустые строки для разделения вывода,
как это делает @code{print}, но использует символы кавычек точно так же,
как @code{print}. Она возвращает @var{object}.

@example
@group
(progn (prin1 'Наш\ кот\ в)
       (prin1 "любимой шляпе")
       (prin1 " уже вернулся"))
     @print{} Наш\ кот\ в"любимой шляпе"" уже вернулся"" уже вернулся"
     @result{} " уже вернулся"
@end group
@end example
@end defun

@defun princ object &optional stream
Эта функция выводит печатное представление @var{object} в @var{stream}.
Она возвращает @var{object}.

Эта функция предназначена для создания вывода, доступного для чтения людьми,
а не @code{read}, поэтому она не вставляет символы кавычек и не помещает в
двойные кавычки содержимого строк. Она не добавляет интервал между вызовами.

@example
@group
(progn
  (princ 'Наш\ кот)
  (princ " в любимой \"шляпе\""))
     @print{} Наш кот в любимой "шляпе"
     @result{} " в любимой \"шляпе\""
@end group
@end example
@end defun

@defun terpri &optional stream ensure
@cindex newline in print
Эта функция выводит символ новой строки в @var{stream}. Название
расшифровывается как ``завершить печать''. Если @var{ensure} является
не-@code{nil}, новая строка не печатается, если @var{stream} уже в начале
строки. Обратите внимание в этом случае @var{stream} не может быть
функцией и сигнализируется ошибка, если это так. Эта функция возвращает
@code{t}, если новая строка выводится.
@end defun

@defun write-char character &optional stream
Эта функция выводит @var{character} в @var{stream}. Она возвращает
@var{character}.
@end defun

@defun prin1-to-string object &optional noescape
@cindex object to string
Эта функция возвращает строку, содержащую текст, который
@code{prin1} бы напечатала для того же аргумента.

@example
@group
(prin1-to-string 'foo)
     @result{} "foo"
@end group
@group
(prin1-to-string (mark-marker))
     @result{} "#<marker at 2773 in strings.texi>"
@end group
@end example

Если @var{noescape} является не-@code{nil}, это запрещает использование
кавычек в выводе. (Этот аргумент поддерживается в Emacs версии 19 и более поздних версий).

@example
@group
(prin1-to-string "foo")
     @result{} "\"foo\""
@end group
@group
(prin1-to-string "foo" t)
     @result{} "foo"
@end group
@end example

См @code{format}, в @ref{Formatting Strings}, для других способов получить
печатное представление объекта Lisp в виде строки.
@end defun

@defmac with-output-to-string body@dots{}
Этот макрос выполняет форму @var{body}  с @code{standard-output} настройкой
для подачи вывода в строку. Затем он возвращает эту строку.

Например, если имя текущего буфера @samp{foo},

@example
(with-output-to-string
  (princ "Имя этого буфера ")
  (princ (buffer-name)))
@end example

@noindent
returns @code{"Имя этого буфера foo"}.
@end defmac

@defun pp object &optional stream
Эта функция выводит @var{object} в @var{stream}, так же, как @code{prin1},
но делает это более красивым образом. То есть, будет отступ и заполнение
объекта, чтобы сделать его более читабельным для людей.
@end defun

Если вам нужно использовать двоичный I/O в пакетном режиме, например,
используйте функции, описанные в этом разделе, чтобы записать произвольные
двоичные данные или избегайте преобразования символов новой строки на не-POSIX
хостах см @ref{Input Functions, set-binary-mode}.

@node Output Variables
@section Переменные, влияющие на вывод
@cindex output-controlling variables

@defvar standard-output
Значение этой переменной выходной поток по умолчанию --- поток, который
используют функции печати, когда аргумент @var{stream} @code{nil}.
По умолчанию @code{t}, то есть отображение в эхо-области.
@end defvar

@defvar print-quoted
Если это переменная не-@code{nil}, это означает печать цитируемых форм с
использованием сокращенного синтаксиса читателя, например, @code{(quote foo)}
печатает как @code{'foo} и @code{(function foo)} как @code{#'foo}.
@end defvar

@defvar print-escape-newlines
@cindex @samp{\n} in print
@cindex escape characters
Если эта переменная не-@code{nil}, то символы новой строки в строках
печатаются как @samp{\n} и печатается символ перевода страницы, как @samp{\f}.
Обычно эти символы печатаются как фактические символы перевода строки и
перевода страницы.

Эта переменная влияет на функции печати @code{prin1} и @code{print}, печать с
экранированием. Это не влияет на @code{princ}. Ниже приведен пример
использования @code{prin1}:

@example
@group
(prin1 "a\nb")
     @print{} "a
     @print{} b"
     @result{} "a
b"
@end group

@group
(let ((print-escape-newlines t))
  (prin1 "a\nb"))
     @print{} "a\nb"
     @result{} "a
b"
@end group
@end example

@noindent
Во втором выражении, локальное связывание @code{print-escape-newlines}
действует во время вызова @code{prin1}, но не во время печати результата.
@end defvar

@defvar print-escape-control-characters
Если эта переменная не-@code{nil}, управляющие символы в строках выводятся
в виде последовательности с предшествующей обратной косой черты функцией
печати @code{prin1} и выводятся заключёнными в кавычках функцией @code{print}.
Если и эта переменная и переменная @code{print-escape-newlines} обе не-@code{nil},
последняя принимает приоритет для символов переноса строк и символов перевода
страниц.
@end defvar

@defvar print-escape-nonascii
Если эта переменная не-@code{nil}, то однобайтовые не-@acronym{ASCII} символы  в
строках безоговорочно печатаются с обратными косыми чертами последовательностей
функцией печати @code{prin1} и в кавычках функцией @code{print}.

Эти функции также используют последовательности обратной косой черты для
однобайтных не-@acronym{ASCII} символов, независимо от значения этой
переменной, когда указанный выходной поток представляет собой
многобайтовой буфер или маркер.
@end defvar

@defvar print-escape-multibyte
Если эта переменная не-@code{nil}, то многобайтовые не-@acronym{ASCII} символы в
строках безоговорочно печатаются как последовательности  с предшествующей
обратной косой чертой функцией печати @code{prin1} и печатаются заключенными
в кавычки функцией @code{print}.

Эти функции также используют последовательности обратной косой черты для многобайтовых
не-@acronym{ASCII} символов, независимо от значения этой переменной, когда выходной
поток представляет собой однобайтовый буфер или маркер.
@end defvar

@defvar print-length
@cindex printing limits
Значение этой переменной является максимальное количество элементов для печати в
любой список, вектор или BOOL-вектор. Если печатаемый объект имеет большее количество
элементов, превышенный вывод сокращается с многоточием.

Если значение @code{nil} (по умолчанию), то нет никаких ограничений.

@example
@group
(setq print-length 2)
     @result{} 2
@end group
@group
(print '(1 2 3 4 5))
     @print{} (1 2 ...)
     @result{} (1 2 ...)
@end group
@end example
@end defvar

@defvar print-level
Значение этой переменной определяет максимальную глубину вложенности круглых и
квадратных скобок при печати. Любой список или вектор на глубине, превышающей
этот предел, обозначается многоточием. Значение @code{nil} (значение по умолчанию)
означает, что нет предела.
@end defvar

@defopt eval-expression-print-length
@defoptx eval-expression-print-level
Эти значения @code{print-length} и @code{print-level}, используются для
@code{eval-expression}, и, таким образом, косвенно, многими интерактивными
командами оценки (@pxref{Lisp Eval,, Evaluating Emacs-Lisp Expressions, emacs, The GNU Emacs Manual}).
@end defopt

  Эти переменные используются для обнаружения цикличности
  и составления отчетности общей структуры:

@defvar print-circle
Если не-@code{nil}, эта переменная позволяет обнаруживать циклическую
и общую структуру при печати. @xref{Circular Objects}.
@end defvar

@defvar print-gensym
Если не-@code{nil}, эта переменная позволяет обнаруживать uninterned символы
(@pxref{Creating Symbols}) при печати. Когда эта опция включена,
uninterned символы печати с приставкой @samp{#:}, которая указывает читателю
Lisp создать uninterned символ.
@end defvar

@defvar print-continuous-numbering
Если не-@code{nil}, это означает, что число вызовов печати постоянно. Это влияет
на количество отпечатанных для @samp{#@var{n}=} этикеток и ссылок @samp{#@var{m}#}.
Не устанавливайте эту переменную используя @code{setq}; Вы должны только связать
её временно @code{t} с @code{let}. Когда вы сделаете это, вы должны также
привязать @code{print-number-table} к @code{nil}.
@end defvar

@defvar print-number-table
Эта переменная содержит вектор, используемый для внутренней печати для реализации
функции @code{print-circle}. Вы не должны использовать её, за исключением привязки
её к @code{nil}, когда вы связываете @code{print-continuous-numbering}.
@end defvar

@defvar float-output-format
Эта переменная определяет, как печатать числа с плавающей точкой. По умолчанию
@code{nil}, то есть самый короткий вывод, который представляет собой
число без потери информации.

Для того, чтобы контролировать формат вывода более точно, вы можете поместить
строку в эту переменную. Строка должна содержать @samp{%}-спецификации, которые
будут использоваться в функции С @code{sprintf}. Дополнительные ограничения,
которые вы можете использовать, смотрите в строке документации переменной.
@end defvar
