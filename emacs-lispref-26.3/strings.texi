@c -*- mode: texinfo; coding: utf-8 -*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2019 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Strings and Characters
@chapter Строки и символы
@cindex strings
@cindex character arrays
@cindex characters
@cindex bytes

  Строка в Emacs Lisp представляет собой массив, содержащий упорядоченную
  последовательность символов.  Строки используются в качестве имен
  символов, буферов и файлов; для отправки сообщения пользователям; для
  хранения текста копируемого между буферами; и для многих других целей.
  Поскольку строки настолько важны, Emacs Lisp имеет множество функций
  специально предназначенных для работы с ними.  Emacs Lisp программа
  использует строки чаще, чем отдельные символы.

  @xref{Strings of Events}, особые соображения по поводу строк событий
  символов клавиатуры.

@menu
* Basics: String Basics.      Основные свойства строк и символов.
* Predicates for Strings::    Проверка того, объект строка или символ.
* Creating Strings::          Функции для выделения новых строк.
* Modifying Strings::         Изменение содержимого существующей строки.
* Text Comparison::           Сравнение символов или строк.
* String Conversion::         Преобразование символов в строку и обратно.
* Formatting Strings::        @code{format}: аналог Emacs С @code{printf}.
* Case Conversion::           Функции преобразования регистра.
* Case Tables::               Настройка преобразования регистра.
@end menu

@node String Basics
@section Строки и Символы Основы

  Символ --- это объект Lisp, который представляет собой одиночный символ
  текста.  В Emacs Lisp символы --- это просто целые числа; является ли
  целое число, символ или нет, определяется только тем, как оно используется.
  @xref{Character Codes}, для получения подробной информации о представлении
  символов в Emacs.

  Строка --- это фиксированная последовательностью символов.  Это тип
  последовательности называется @dfn{массивом} и означает, что его длина
  фиксирована и не может быть изменена после его создания
  (@pxref{Sequences Arrays Vectors}).  В отличие от C, Emacs Lisp строки
  @emph{not} имеют кода символа завершения строки.

  Поскольку строки являются массивами, а значит, и последовательностямии,
  вы можете работать с ними с помощью общих функций для массивов и
  последовательностей, описанных в @ref{Sequences Arrays Vectors}.  Например,
  вы можете получить доступ к отдельным символам строки или изменить их с
  помощью функций @code{aref} и @code{aset} (@pxref{Array Functions}).  Тем
  не менее, отметим, что @code{length} @emph{not} должна быть использована
  для вычисления ширины строки на дисплее; используется @code{string-width}
  (@pxref{Size of Displayed Text}) вместо этого.

  Есть два текстовых представлений для не-@acronym{ASCII} символов в строках
  Emacs (и в буферах): однобайтные и многобайтовые.  Для большей части Lisp
  программирования, вам не нужно беспокоится об этих двух представлениях.
  @xref{Text Representations}, для деталей.

  Иногда ключевые последовательности представлены в виде однобайтовых строк.
  Когда однобайтная строка является ключевой последовательностью, строковые
  элементы в диапазоне от 128 до 255 представляют собой мета-символы (которые
  являются большими целыми числами), а не кодами символов в диапазоне от 128
  до 255.  Строки не может содержать символы с модификаторами hyper, super
  или alt; они могут держать управляющие символы @acronym{ASCII}, но не могут
  содержать никакие другие управляющие символы.  Они не различают регистр
  @acronym{ASCII} управляющих символов.  Если вы хотите сохранить такие
  символы в последовательности, такой как последовательность клавиш, вы
  должны использовать вектор вместо строки.  @xref{Character Type}, для
  получения дополнительной информации о вводе символов с клавиатуры.

  Строки могут быть использованы для хранения регулярных выражений.  Вы
  можете также сопоставить регулярное выражение со строкой используя
  @code{string-match} (@pxref{Regexp Search}).  Функции @code{match-string}
  (@pxref{Simple Match Data}) и @code{replace-match}
  (@pxref{Replacing Match}) полезны для разложения и изменения строк после
  согласования с ними регулярных выражений.

  Подобно буферу, строка может содержать, помимо самих символов, текстовые
  свойства символов.  @xref{Text Properties}.  Все Lisp примитивы,
  копирующие текст из строк в буферы или другие строки, также копируют
  свойство копируемых символов.

  @xref{Text}, для получения информации о функциях, отображающих строки или
  копирующих строки в буфер.  @xref{Character Type}, и @ref{String Type}, для
  получения информации о синтаксисе символов и строк.
  @xref{Non-ASCII Characters}, для функций преобразования между текстовым
  представлением и кодирования и декодирования кодов символов.

@node Predicates for Strings
@section Предикаты Строк
@cindex predicates for strings
@cindex string predicates

Для получения дополнительной информации об общих предикатах
последовательностей и предикатах массивов,
see @ref{Sequences Arrays Vectors}, и @ref{Arrays}.

@defun stringp object
Функция возвращает @code{t} если @var{object} является строкой,
@code{nil} в противном случае.
@end defun

@defun string-or-null-p object
Функция возвращает @code{t} если @var{object} является строкой или
@code{nil}.  Возвращает @code{nil} в противном случае.
@end defun

@defun char-or-string-p object
Функция возвращает @code{t}, если @var{object} является строкой или символом
(т.е., целым числом), в противном случае возвращается @code{nil}.
@end defun

@node Creating Strings
@section Создание Строк
@cindex creating strings
@cindex string creation

  Следующие функции создают строки, либо с нуля, либо путем объединения
  или раделения строк.

@defun make-string count character
Функция возвращает строку, состоящую из @var{count} повторений
@var{character}.  Если @var{count} отрицательный, сигнализируется об ошибке.

@example
(make-string 5 ?x)
     @result{} "xxxxx"
(make-string 0 ?x)
     @result{} ""
@end example

  Другие функции для сравнения с этой @code{make-vector} (@pxref{Vectors}) и
  @code{make-list} (@pxref{Building Lists}).
@end defun

@defun string &rest characters
Функция возвращает строку, содержащую символы @var{characters}.

@example
(string ?a ?b ?c)
     @result{} "abc"
@end example
@end defun

@defun substring string &optional start end
Функция возвращает новую строку, состоящую из символов @var{string} в
диапазоне от (включая) символ c индексом @var{start} до (не включая) символ
с индексом @var{end}.  Первый символ имеет нулевой индекс.  С одним
аргументом, эта функция просто копирует @var{string}.

@example
@group
(substring "abcdefg" 0 3)
     @result{} "abc"
@end group
@end example

@noindent
В приведенном выше примере, индекс для @samp{a} равен 0, индекс для @samp{b}
равен 1, а индекс для @samp{c} равен 2.  Индекс 3--- с четвертой позицией
символа в строке --- отмечает позицию символа, до которого подстрока
копируется.  Таким образом, @samp{abc} копируется из строки @code{"abcdefg"}.

Отрицательное значение подсчитывает позицию символа от конца строки, так что
@minus{}1 означает индекс последнего символа строки. Например:

@example
@group
(substring "abcdefg" -3 -1)
     @result{} "ef"
@end group
@end example

@noindent
В этом примере, индекс для @samp{e} является @minus{}3, индекс для @samp{f}
является @minus{}2, а индекс для @samp{g} является @minus{}1.  Поэтому
символы @samp{e} и @samp{f} включены, и @samp{g} исключается.

Когда @code{nil} используется для аргумента @var{end}, это означает до длинны
строки. Таким образом,

@example
@group
(substring "abcdefg" -3 nil)
     @result{} "efg"
@end group
@end example

Опущенный аргумент @var{end} эквивалентен заданому в @code{nil}.  Отсюда
следует, что @code{(substring @var{string} 0)} возвращает копию всех
символов @var{string}.

@example
@group
(substring "abcdefg" 0)
     @result{} "abcdefg"
@end group
@end example

@noindent
Рекомендуется @code{copy-sequence} для такой задачи
(@pxref{Sequence Functions}).

Если символы, скопированные из @var{string} имеют текстовые свойства,
свойства также копируются в новую строку.  @xref{Text Properties}.

@code{substring} также принимает вектор в качестве своего первого аргумента.
Например:

@example
(substring [a b (c) "d"] 1 3)
     @result{} [b (c)]
@end example

Ошибка @code{wrong-type-argument} сигнализируется, если @var{start} не
является целым числом, или если @var{end} не является ни целым числом, ни
@code{nil}.  Ошибка @code{args-out-of-range} сигнализируется, если
@var{start} указывает на символ, следующий @var{end}, или если указано
любое значение целого числа, которое находится вне допустимого диапазона
для @var{string}.

Сравните эту функцию с @code{buffer-substring} (@pxref{Buffer Contents}),
которая возвращает строку, содержащую часть текста в текущем буфере.  Начало
строки имеет индекс 0, а начало буфера индекс 1.
@end defun

@defun substring-no-properties string &optional start end
Функция работает как @code{substring} но отбрасывает все значения свойств
текста.  Кроме того, @var{start} можно опускать или устанавливать в
@code{nil}, что эквивалентно 0.  Таким образом,
@w{@code{(substring-no-properties @var{string})}} возвращает копию
@var{string}, без свойств текста.
@end defun

@defun concat &rest sequences
@cindex copying strings
@cindex concatenating strings
Функция возвращает новую строку, состоящую из символов, переданных ей
аргументами (вместе с их свойствами текста, если таковые имеются).  Аргументы
могут быть строки, списки или векторы чисел; сами передеанные в аргументах
данные не изменяются.  Если @code{concat} не передаётся никаких аргументов,
возвращается пустая строка.

@example
(concat "abc" "-def")
     @result{} "abc-def"
(concat "abc" (list 120 121) [122])
     @result{} "abcxyz"
;; @r{@code{nil} пустая последовательность.}
(concat "abc" nil "-def")
     @result{} "abc-def"
(concat "Это " " очень шустрая " "лиса.")
     @result{} "Это очень шустрая лиса."
(concat)
     @result{} ""
@end example

@noindent
Функция всегда создает новую строку, которая не @code{eq} к любой
существующей строке, кроме случаев, когда результатом является пустая строка
(для экономии места, Emacs создаёт только одну многобайтовую пустую строку).

Для получения информации о других функциях конкатенации, смотрите описание
@code{mapconcat} в @ref{Mapping Functions}, @code{vconcat} в
@ref{Vector Functions} и @code{append} в @ref{Building Lists}.  Для
конкатенации аргументов командной строки в строку, которая будет
использоваться в качестве команды оболочки, смотри
@ref{Shell Arguments, combine-and-quote-strings}.
@end defun

@defun split-string string &optional separators omit-nulls trim
Функция разбивает @var{string} на подстроки на основе регулярного выражения
@var{separators} (@pxref{Regular Expressions}).  Каждое соответствие
для @var{separators} определяет точку расделения; подстроки между точками
разделения объединяются в список, который возвращается.

Если @var{separators} установлен в @code{nil} (или опущен), то по умолчанию
используется значение @code{split-string-default-separators} и функция ведет
себя так, как если бы @var{omit-nulls} были установлены в @code{t}.

Если @var{omit-nulls} установлен в @code{nil} (или опущен), то результат
будет содержать пустые строки всякий раз, когда есть два последовательных
совпадения для @var{separators}, или совпадение примыкает к началу или концу
@var{string}.  Если @var{omit-nulls} установлен в @code{t}, эти пустые строки
будут исключены из результата.

Если необязательный аргумент @var{trim} установлен в не-@code{nil}, это
должно быть регулярным выражением для сопоставления тексту для брезки от
начала и до конца каждой подстроки.  Если обрезка делает подстроку пустой,
это трактуется как null.

Если вам нужно разбить строку на список аргументов командной строки,
пригодный для @code{call-process} или @code{start-process},
смотри @ref{Shell Arguments, split-string-and-unquote}.

Примеры:

@example
(split-string "  два слова ")
     @result{} ("два" "слова")
@end example

Результатом будет не @code{("" "два" "слова" "")}, который редко бывает
полезным.  Если вам нужен такой результат, используйте явное значение для
@var{separators}:

@example
(split-string "  два слова "
              split-string-default-separators)
     @result{} ("" "два" "слова" "")
@end example

@example
(split-string "Слово гиппопотомомонстросесквиппедалиофобия" "п")
     @result{} ("Слово ги" "" "о" "отомомонстросескви" "" "едалиофобия")
(split-string "Слово гиппопотомомонстросесквиппедалиофобия" "п" t)
     @result{} ("Слово ги" "о" "отомомонстросескви" "едалиофобия")
(split-string "Слово гиппопотомомонстросесквиппедалиофобия" "п+")
     @result{} ("Слово ги" "о" "отомомонстросескви" "едалиофобия")
@end example

Необязательные сопоставления учитываются, за исключением того, что
@code{split-string} не будет брать во внимание конечное необязательное
сопоставление, когда уже достигнут конец строки, при использовании
необязательного совпадения или когда @var{string} пустая строка:

@example
(split-string "aooob" "o*")
     @result{} ("" "a" "" "b" "")
(split-string "ooaboo" "o*")
     @result{} ("" "" "a" "b" "")
(split-string "" "")
     @result{} ("")
@end example

Однако, когда @var{separators} может соответствовать пустой строке,
@var{omit-nulls} обычно устанавливают в @code{t}, так что тонкости в трех
предыдущих примерах редко актуальны:

@example
(split-string "Soup is good food" "o*" t)
     @result{} ("S" "u" "p" " " "i" "s" " " "g" "d" " " "f" "d")
(split-string "Nice doggy!" "" t)
     @result{} ("N" "i" "c" "e" " " "d" "o" "g" "g" "y" "!")
(split-string "" "" t)
     @result{} nil
@end example

Несколько странно, но предсказуемое поведение может иметь место для
определенных ``не-жадных'' значений @var{separators}, которые могут
предпочесть пустые совпадения над непустыми.  Опять же, такие значения редко
встречаются на практике:

@example
(split-string "ooo" "o*" t)
     @result{} nil
(split-string "ooo" "\\|o+" t)
     @result{} ("o" "o" "o")
@end example
@end defun

@defvar split-string-default-separators
Значение по умолчанию @var{separators} @code{split-string}. Его обычное
значение @w{@code{"[ \f\t\n\r\v]+"}}.
@end defvar

@node Modifying Strings
@section Изменение Строк
@cindex modifying strings
@cindex string modification

  Самый простой способ изменить содержимое существующей строки---использовать
  @code{aset} (@pxref{Array Functions}).
  @code{(aset @var{string} @var{idx} @var{char})} сохраняет @var{char} в
  @var{string} позиции с индексом @var{idx}.  Каждый символ занимает один
  или несколько байтов, и если @var{char} символ имеет другое количество
  байтов, уже присутствующих в позиции по этому индексу, @code{aset}
  сигнализирует об ошибке.

  Более эффективная функция @code{store-substring}:

@defun store-substring string idx obj
Функция изменяет часть содержимого строки @var{string}, сохраняя @var{obj},
начиная с индексом @var{idx}.  Аргумент @var{obj} может быть либо символом
либо (меньшего размера) строкой.

Так как невозможно изменить длину существующей строки, произойдёт ошибка,
если @var{obj} не вписывается в фактическую длину @var{string}, или если
какой-либо новый символ требует другое количество байт чем имеет заменяемый
символ в текущей позиции @var{string}.
@end defun

  Чтобы очистить строку, которая содержала пароль, используется
@code{clear-string}:

@defun clear-string string
Сделает @var{string} строку однобайтовой и очистит её содержимое до нуля.
Это также может изменить длину @var{string}.
@end defun

@need 2000
@node Text Comparison
@section Сравнение Символов и Строк
@cindex string equality
@cindex text comparison

@defun char-equal character1 character2
Функция возвращает @code{t} если аргументы представляют собой один и тот же
символ, @code{nil} в противном случае.  Функция игнорирует регистр, если
переменная @code{case-fold-search} установленявлена в не-@code{nil}.

@example
(char-equal ?x ?x)
     @result{} t
(let ((case-fold-search nil))
  (char-equal ?x ?X))
     @result{} nil
@end example
@end defun

@defun string= string1 string2
Функция возвращает @code{t}, если символы двух строк точно совпадать.
Символы также допускаются в качестве аргументов, в этом случае используются
имена символов.  Регистр всегда имеет значение, независимо от
@code{case-fold-search}.

Функция эквивалентна @code{equal} для сравнения двух строк
(@pxref{Equality Predicates}).  В частности, текстовые свойства двух строк
игнорируются; используется @code{equal-including-properties}, если нужно
различать строки, которые отличаются только по их свойствах текста.  Однако,
в отличие от @code{equal}, если один из аргументов не является строкой или
символ, @code{string=} сигнализирует об ошибке.

@example
(string= "abc" "abc")
     @result{} t
(string= "abc" "ABC")
     @result{} nil
(string= "ab" "ABC")
     @result{} nil
@end example

По техническим причинам однобайтная и многобайтовая строка являются
@code{equal} тогда и только тогда, когда они содержат одну и ту же
последовательность кодов символов, и все эти коды находятся либо в диапазоне
от 0 до 127 (@acronym{ASCII}) либо от 160 до 255 (@code{eight-bit-graphic}).
Однако, когда однобайтная строка преобразуются в многобайтовую строку все
символы с кодами в диапазоне от 160 до 255, преобразуются в символы с более
большими значениями кодов, тогда как @acronym{ASCII} символы остаются
неизменными.  Таким образом, однобайтная строка и ее преобразование в
многобайтовую возможно только с @code{equal}, если вся строка содержит только
@acronym{ASCII} символы.  Символьные коды от 160 до 255 не совсем подходят
для многобайтового текста, несмотря на то, что они могут там встречаться.
Как следствие, ситуация, когда однобайтные и многобайтовая строка являются
@code{equal} без того, чтобы обе состояли лиш из @acronym{ASCII} символов
является техническим курьезом, с которой когда либо сталкивались очень
немногие Emacs Lisp программисты.  @xref{Text Representations}.
@end defun

@defun string-equal string1 string2
@code{string-equal} другое название @code{string=}.
@end defun

@cindex locale-dependent string equivalence
@defun string-collate-equalp string1 string2 &optional locale ignore-case
Эта функция возвращает @code{t} если @var{string1} и @var{string2} равны по
отношению к правилам сортировки.  Правило сортировки определяется не только
лексикографическим порядком символов, содержащихся в @var{string1} и
@var{string2}, но и дополнительными правилами об отношениях между этими
символами.  Обычно это определяется @var{локалью} в которой исполняется
Emacs.

Например, символы с разным кодированием, но с одинаковым значении могут
считаться равными, как различные символы с грависом Unicode:

@example
@group
(string-collate-equalp (string ?\uFF40) (string ?\u1FEF))
     @result{} t
@end group
@end example

Необязательный аргумент @var{locale} --- это строка, переопределяет настройки
вашего текущего идентификатора языка для сопоставления.  Значение зависит от
системы; @var{locale} @code{"en_US.UTF-8"} применим в системах POSIX, в то
время как это было бы, например, @code{"enu_USA.1252"} в системах MS-Windows.

Если @var{ignore-case} установлен в не-@code{nil}, символы преобразуются в
нижний регистр, прежде чем сравнивать их.

@vindex w32-collate-ignore-punctuation
Для эмуляции Unicode-совместимых параметров сортировки в системах MS-Windows,
привяжите @code{w32-collate-ignore-punctuation} к значению не-@code{nil},
поскольку часть кодового набора не может быть @code{"UTF-8"} на MS-Windows.

Если ваша система не поддерживает локаль, эта функция ведет себя как
@code{string-equal}.

@emph{Не} используйте эту функцию, для сравнивнения имён файлов, так как
файловые системы, как правило, не выполняют лингвистическую эквивалентность
строк, сортировки орудий. (ВопросКакихТакихОрудий strings507)
@end defun

@cindex lexical comparison of strings
@defun string< string1 string2
@c (findex string< вызывает проблемы для переставленного индекса !!)
Функция сравнивает две строки посимвольно.  Сканирует обе строки
одновременно, чтобы найти первую несоответствующую пару.  Если меньшее
значение кода символа принадлежит @var{string1}, тогда @var{string1} меньше
@var{string2}, и возвращается @code{t}.  Если меньший код символа принадлежит
@var{string2}, тогда @var{string1} больше @var{string2}, и возвращается
@code{nil}.  Если две строки совпадают полностью, то возвращается значение
@code{nil}.

Пары символов сравниваются в соответствии с их кодами символов. Имейте в
виду, что строчные буквы имеют более высокие числовые значения в наборе
символов @acronym{ASCII}, чем их аналоги верхнего регистра; цифры и многие
знаки препинания имеют более низкое числовое значение, чем заглавные буквы.
Код @acronym{ASCII} символа меньше любого кода не-@acronym{ASCII} символа;
однобайтный не-@acronym{ASCII} символ всегда меньше, чем любой многобайтный
не-@acronym{ASCII} символ (@pxref{Text Representations}).

@example
@group
(string< "abc" "abd")
     @result{} t
(string< "abd" "abc")
     @result{} nil
(string< "123" "abc")
     @result{} t
@end group
@end example

Когда строки имеют разную длину, и они совпадают до длинны @var{string1}, то
результат будет @code{t}.  Если они совпадают с длиной @var{string2},
результатом будет @code{nil}. Строка без символов меньше, чем любая другая
строка.

@example
@group
(string< "" "abc")
     @result{} t
(string< "ab" "abc")
     @result{} t
(string< "abc" "")
     @result{} nil
(string< "abc" "ab")
     @result{} nil
(string< "" "")
     @result{} nil
@end group
@end example

Символы также допускаются в качестве аргументов, в этом случае сравниваются
их печатное представление имени.
@end defun

@defun string-lessp string1 string2
@code{string-lessp} это другое название @code{string<}.
@end defun

@defun string-greaterp string1 string2
Функция возвращает результат сравнения @var{string1} и @var{string2} в
обратном порядке, т.е., это эквивалентно вызову
@code{(string-lessp @var{string2} @var{string1})}.
@end defun

@cindex locale-dependent string comparison
@defun string-collate-lessp string1 string2 &optional locale ignore-case
Функция возвращает @code{t} если @var{string1} меньше @var{string2} в
порядке сортировки.  Результат сопоставления определяются не только
лексикографическим порядком символов, содержащиеся в @var{string1} и
@var{string2}, но и дополнительными правилами относительно отношений между
этими символами.  Обычно это определяет @var{локаль}, в которой работает
Emacs.

Например, знаки препинания и пробелы могут быть проигнорированы при
сортировке (@pxref{Sequence Functions}):

@example
@group
(sort '("11" "12" "1 1" "1 2" "1.1" "1.2") 'string-collate-lessp)
     @result{} ("11" "1 1" "1.1" "12" "1 2" "1.2")
@end group
@end example

Это поведение зависит от системы; например, знаки препинания и пробелы не
будут игнорироваться на Cygwin, независимо от локали.

Необязательный аргумент @var{locale}, строка, переопределяет настройки
вашего текущего идентификатора локали для сортировки.  Значение зависит от
системы; @var{locale} @code{"en_US.UTF-8"} применим в системах POSIX, в то
время как это было бы, например, в системах @code{"enu_USA.1252"}
MS-Windows.  @var{locale} значение @code{"POSIX"} или @code{"C"} позволяет
@code{string-collate-lessp} вести себя как @code{string-lessp}:

@example
@group
(sort '("11" "12" "1 1" "1 2" "1.1" "1.2")
      (lambda (s1 s2) (string-collate-lessp s1 s2 "POSIX")))
     @result{} ("1 1" "1 2" "1.1" "1.2" "11" "12")
@end group
@end example

Если @var{ignore-case} является не-@code{nil}, символы преобразуются в
нижний регистр перед их сравнением.

Для эмуляции Unicode-совместимых систем сортировки на MS-Windows,
@code{w32-collate-ignore-punctuation} связывается со значением не-@code{nil},
поскольку часть кодового набора языкового стандарта @code{"UTF-8"} не может
быть установлена на MS-Windows.

Если ваша система не поддерживает локализованную среду, эта функция ведет
себя как @code{string-lessp}.
@end defun

@defun string-version-lessp string1 string2
Функция сравнивает строки лексикографически, за исключением того, что
обрабатываются последовательности цифровых символов, как если бы они
составляли десятичное число, а затем сравниваются числа.  Так @samp{foo2.png}
``меньше'' чем @samp{foo12.png} согласно этому предикату, даже если
@samp{12} лексикографически ``меньше'' чем @samp{2}.
@end defun

@defun string-prefix-p string1 string2 &optional ignore-case
Функция возвращает не-@code{nil} если @var{string1} является префиксом
@var{string2}; т.е., если @var{string2} начинается с @var{string1}.  Если
необязательный аргумент @var{ignore-case} установлен в не-@code{nil},
сравнение не учитывает регистр букв.
@end defun

@defun string-suffix-p suffix string &optional ignore-case
Функция возвращает не-@code{nil} если @var{suffix} является суффиксом
@var{string}; т.е., если @var{string} заканчивается на @var{suffix}.  Если
необязательный аргумент @var{ignore-case} установлен в не-@code{nil},
сравнение не учитывает регистр букв.
@end defun

@defun compare-strings string1 start1 end1 string2 start2 end2 &optional ignore-case
Функция сравнивает определённую часть @var{string1} с определенной частью
@var{string2}.  Часть @var{string1} начинается с индекса @var{start1}
(включая) и заканчивается индексом @var{end1} (исключая); @code{nil} для
@var{start1} означает брать часть с начала строки, в то время как @code{nil}
для @var{end1} означает до длинны всей строки.  Точно так же задаётся часть
@var{string2} от индекса @var{start2} до индекса @var{end2}.

Строки сравниваются по числовым значениям своих символов.  Например,
@var{str1} считается меньше чем @var{str2}, если её первый отличаяющийся
символ имеет меньшее числовое значение.  Если @var{ignore-case} установлена в
не-@code{nil}, символы преобразуются в верхний регистр перед их сравнением.
Однобайтные строки преобразуются в многобайтовые для сравнения
(@pxref{Text Representations}), так что однобайтновая и её преобразование в
многобайтовую всегда считаются равными.

Если указанные участки двух строк совпадают, возвращается значение @code{t}.
В противном случае, значение представляет собой целое число, которое
указывает, сколько ведущих символов согласовано, и какая строка меньше.  Его
абсолютная величина равна единице плюс количество символов, которые
согласованы в начале двух строк.  Отрицательный знак, признак того, что
@var{string1} (или её определенная часть) меньше.
@end defun

@defun assoc-string key alist &optional case-fold
Функция работает как @code{assoc}, за исключением того, что @var{key} должен
быть строкой или символом, и сравнение выполняется с помощью
@code{compare-strings}.  Символы преобразуются в строки перед тестированием.
Если @var{case-fold} установлен в не-@code{nil}, @var{key} и элементы
@var{alist} преобразуются в верхний регистр перед сравнением.  В отличие от
@code{assoc}, эта функция может также сопоставлять элементы ALIST, которые
являются строками или символами, а не conses (ВопросStrings676).  В
частности, @var{alist} может быть списком строк или символов, а не
фактическим списком(ВопросStrings678).
@xref{Association Lists}.
@end defun

  Смотрите также функцию @code{compare-buffer-substrings} в
  @ref{Comparing Text}, способ сравнения текста в буфере.  Функция
  @code{string-match}, которая сопоставляет регулярное выражение со строкой,
  может быть использована для своего рода сравнения строк; смотри
@ref{Regexp Search}.

@node String Conversion
@section Преобразование Символов и Строк
@cindex conversion of strings

  В этом разделе описаны функции для преобразования между символами, строками
  и целыми числами.  @code{format} (@pxref{Formatting Strings}) и
  @code{prin1-to-string} (@pxref{Output Functions}) также могут
  преобразовывать Lisp объекты в строки.  @code{read-from-string}
  (@pxref{Input Functions}) может преобразовать строковое представление
  объекта Lisp в объект.  Функции @code{string-to-multibyte} и
  @code{string-to-unibyte} преобразовывают текстовое представление строки
  (@pxref{Converting Representations}).

  @xref{Documentation}, о функциях, которые производят текстовые описания
  текстовых символов и общих событий ввода (ВопросStrings702)
  (@code{single-key-description} и @code{text-char-description}).  Они
  используются в основном для получения справочных сообщений.

@defun number-to-string number
@cindex integer to string
@cindex integer to decimal
Функция возвращает строку, состоящую из печатанного представления десятичного
@var{number}.  Возвращаемое значение начинается со знаком минус, если
аргумент отрицателеный.

@example
(number-to-string 256)
     @result{} "256"
@group
(number-to-string -23)
     @result{} "-23"
@end group
(number-to-string -23.5)
     @result{} "-23.5"
@end example

@cindex @code{int-to-string}
@code{int-to-string} полу-устаревший псевдоним функции
@code{number-to-string} описанной выше.

Смотри также функцию @code{format} в @ref{Formatting Strings}.
@end defun

@defun string-to-number string &optional base
@cindex string to number
Функция возвращает численное количество символов в @var{string}.  Если
@var{base} установлено в не-@code{nil}, оно должно быть целым числом от 2 до
16 (включительно), а также целые числа преобразуются по этой базе.  Если
@var{base} установлено в @code{nil}, то используется основание десять.
Преобразование с плавающей точкой работает только с десятичным основанием;
не реализовано других типов преобразований для чисел с плавающей точкой,
потому что это требует огромной работы, и не кажется полезным.  Если
@var{string} выглядит как целое число, но его значение слишком велико, чтобы
поместиться в целое число Lisp, @code{string-to-number} возвращает в
результате число с плавающей точкой.

При синтаксическом разборе пропускаются пробелы и символы табуляции в начале
@var{string}, затем читает столько @var{string}, сколько это может быть
интерпретировано как число в данной базе.  (В некоторых системах игнорируются
другие пробелы в начале, а не только пробелы и табуляция.)  Если @var{string}
не может быть интерпретировано как число, то эта функция возвращает 0.

@example
(string-to-number "256")
     @result{} 256
(string-to-number "25 is a perfect square.")
     @result{} 25
(string-to-number "X256")
     @result{} 0
(string-to-number "-4.5")
     @result{} -4.5
(string-to-number "1e5")
     @result{} 100000.0
@end example

@findex string-to-int
@code{string-to-int} это устаревший псевдоним функции @code{string-to-number}
описанной выше.
@end defun

@defun char-to-string character
@cindex character to string
Функция возвращает новую строку, содержащую один символ, @var{character}.
Функция является полу-устаревшей, так как функция @code{string} является
более общей.  @xref{Creating Strings}.
@end defun

@defun string-to-char string
  Функция возвращает первый символ в @var{string}.  Это в основном идентично
  @code{(aref string 0)}, за исключением того, что возвращается значение 0,
  если строка пуста.  (Значение также 0, когда первый символ @var{string}
  является нулевым символом, @acronym{ASCII} код 0.)  Функция может быть
  исключена в будущем, если не представится достаточно полезной для
  сохранения.
@end defun

  Вот некоторые другие функции, которые могут преобразовать в строку и
  обратно из строки:

@table @code
@item concat
Функция преобразует вектор или список в строку.
@xref{Creating Strings}.

@item vconcat
Функция преобразует строку в вектор.  @xref{Vector Functions}.

@item append
Функция преобразует строку в список.  @xref{Building Lists}.

@item byte-to-string
Функция преобразует данные байтов символов в однобайтную строку.
@xref{Converting Representations}.
@end table

@node Formatting Strings
@section Форматирование Строк
@cindex formatting strings
@cindex strings, formatting them

  @dfn{Форматирование} означает построение строки путем подстановки
  вычисленных значений в определённых местах в подстановочной строке.  Эта
  строка контролирует, как и где значения печатаются; это называется
  @dfn{форматной строкой}.

  Форматирование часто бывает полезно для создания отображаемых
  сообщений.  В самом деле, функции @code{message} и @code{error}
  обеспечивают такое же форматирование, описанные здесь; они отличаются от
  @code{format-message} только тем, как используют результат форматирования.

@defun format string &rest objects
Функция возвращает строку, равную @var{string}, заменив все соответствующие
спецификаторы формата определёнными в @var{objects} кодировками.
Аргументы @var{objects} являются вычисленными значениями для форматирования.

Символы в @var{string}, кроме спецификаторов формата, копируется
непосредственно в вывод, в том числе с их текстовыми свойствами, если
таковые имеются.  Любые текстовые свойства спецификаторов формата, копируется
к добавляемым строковым представлениям аргументов @var{objects}.

Выходную строка не нужно снова модифицировать.  Например, если @code{x}
является строкой @code{"foo"}, то выражения @code{(eq x (format x))} и
@code{(eq x (format "%s" x))} на выходе имеют вывод @code{t}.
@end defun

@defun format-message string &rest objects
@cindex curved quotes, in formatted messages
@cindex curly quotes, in formatted messages
Функция действует как @code{format}, за исключением того, также преобразует
любой серьезный (@t{`}) акцент и апостроф (@t{'}) в @var{string} согласно
значению @code{text-quoting-style}.

Как правило, серъёзный акцент и апостроф при форматировании переводятся в
соответствующие изогнутые кавычки, например, @t{"Missing `%s'"} может
привести к @t{"Missing ‘foo’"}.  @xref{Text Quoting Style}, о том, как
влиять или игнорировать форматирование.
@end defun

@cindex @samp{%} in format
@cindex format specification
  Спецификаторы формата представляет собой последовательность символов,
  начинающиеся с @samp{%}.  Таким образом, если есть @samp{%d} в
  @var{string}, функция @code{format} заменяет печатное представление
  требуемого спецификатора, нужным отформатированым аргументом(один из
  @var{objects}) аргументов. Например:

@example
@group
(format "Значение для заполнения-столбца %d." fill-column)
     @result{} "Значение для заполнения-столбца 72."
@end group
@end example

  Поскольку @code{format} интерпретирует @samp{%} символ как спецификатор
  формата, вы не должны @emph{никогда} передавать произвольную строку в
  качестве первого аргумента.  Это особенно верно, когда строка порождается
  некоторым Lisp кодом.  Если строка не @emph{известна}, она не должна
  включают в себя @samp{%} символы, для передачи @code{"%s"}, как описано
  ниже, в качестве первого аргумента и строки в качестве второго, как это:

@example
  (format "%s" @var{arbitrary-string})
@end example

  Для некоторых спецификаторов формата требуются значения конкретных типов.
  Если поставить значение, которое не соответствует этим требованиям,
  сигнализируется об ошибке.

  Ниже приведена таблица допустимых спецификаторов формата:

@table @samp
@item %s
Cпецификатор печатного представления объекта, вывод без заключения в
кавычки (то есть, используя @code{princ}, не
@code{prin1}---@pxref{Output Functions}).  Таким образом, строки
представляются своим содержимым, без символов @samp{"} и экранированных
символом @samp{\} символов.

Если объект является строкой, текстовые свойства этой строки
копируются в вывод.  Текстовые свойства самого спецификатора @samp{%s} также
копируются, но свойства объекта имеют приоритет.

@item %S
Спецификатор печатного представлением объекта, вывод заключитается в кавычки
(то есть, используя @code{prin1}---@pxref{Output Functions}).  Таким образом,
строки заключаются в символы @samp{"} и выводятся специальные символы
экранированные символом @samp{\}. (ВопросStrings894)

@item %o
@cindex integer to octal
Спецификатор вывода печатного представления целого числа без знака с
основанием восемь.

@item %d
Спецификатор вывода печатного представления целого числа с основанием десять.

@item %x
@itemx %X
@cindex integer to hexadecimal
Спецификакатор вывода печатного представления целого числа без знака с
основанием шестнадцать.  @samp{%x} вывод в нижнем регистре и @samp{%X} вывод
в верхнем регистре.

@item %c
Спецификатор вывода печатного представления символа по его коду значения.

@item %e
Спецификатор вывода печатного представления записи числа с плавающей точкой.

@item %f
Спецификатор вывода печатного представления числа с плавающей точкой в виде
числа с десятичной запятой.

@item %g
Cпецификатор вывода нотации числа с плавающей точкой, с использованием
либо экспоненциальной либо десятичной формы записи нотации.  Экспоненциальная
запись выводится, если показатель степени меньше, чем @minus{}4 или больше
или равно в точности (по умолчанию: 6). (ВопросStrings925)  По умолчанию,
конечные нули удаляются из дробной части результата а знак десятичной запятой
появляется только если за ним следует цифра.

@item %%
Спецификатор вывода печатного представления одного символа @samp{%}.  Этот
спецификация формата является необычным в том, что его единственная форма это
@samp{%%} и что он не использует значение.  Например,
@code{(format "%% %d" 30)} возвращает @code{"% 30"}.
@end table

  Использования любого другого символа с этим спецификатором формата
  приведёт к ошибке @samp{Invalid format operation}.

  Вот несколько примеров, предполагаются типичные настройки
  @code{text-quoting-style}:

@example
@group
(format "Восьмеричное значение %d это %o,
         а шестнадцатеричное значение это %x." 18 18 18)
     @result{} "Восьмеричное значение 18 это 22,
         а шестнадцатеричное значение это 12."

(format-message
 "Имя этого буфера ‘%s’." (buffer-name))
     @result{} "Имя этого буфера ‘strings.texi’."

(format-message
 "Объект буфера печатается как `%s'." (current-buffer))
     @result{} "Объект буфера печатается как ‘strings.texi’."
@end group
@end example

  По умолчанию, спецификаторы формата соответствует последовательным
  значениям из @var{objects}.  Таким образом, первый спецификатор формата в
  @var{string} использует первое такое значение, второй использует второе
  такое значение, и так далее.  Любые дополнительные спецификаторы формата
  (те, для которых нет соответствующих значений) вызывает ошибку.  Любые
  дополнительные значения, которым не достанутся спецификаторы игнорируются.

@cindex field numbers in format spec
  Спецификатор формата может иметь @dfn{номер поля}, которое представляет
  собой десятичное число сразу после первого @samp{%}, а затем буквальный
  знак доллара @samp{$}.  Это приводит к тому, спецификатор формата относится
  к аргументу с указанным порядковым номером, вместо следующего аргумента.
  Номера полей начинаются с 1.  Формат может быть либо нумерованный либо
  ненумерованный, но не оба, за исключением того, что @samp{%%} может быть
  смешан с пронумерованными спецификаторами.

@example
(format "%2$s, %3$s, %%, %1$s" "x" "y" "z")
     @result{} "y, z, %, x"
@end example

@cindex flags in format specifications
  После @samp{%} и указанного номера поля, вы можете поместить определенные
  @dfn{символы флаги}.

  Флаг @samp{+} вставляет знак плюс перед положительным числом, так что он
  всегда имеет знак.  Символ пробела как флаг вставляет пробел перед
  положительным числом.  (В противном случае положительные числа начинаются
  с первой цифрой.)  Эти флаги полезны для обеспечения того, чтобы
  положительные и отрицательные числа использовали одинаковое количество
  столбцов.  Они игнорируются @samp{%d}, @samp{%e}, @samp{%f}, @samp{%g}
  за исключением, если используются оба флага, @samp{+} имеет преимущество.

  Флаг @samp{#} определяет альтернативную форму, которая зависит от
  используемого формата.  Для @samp{%o}, это гарантирует, что результат
  начинается с @samp{0}.  Для @samp{%x} и @samp{%X}, добавятся префиксы
  к результату @samp{0x} или @samp{0X}.  Для @samp{%e} и @samp{%f}, включение
  флага @samp{#} добавят к выводу десятичную точку, даже если точность равна
  нулю.  Для @samp{%g}, к выводу всегда включается десятичная точка, а также
  заставляет выводить конечные нули после десятичной точки, которые могли
  быть удалены.

  Флаг @samp{0} гарантирует, что заполнение будет состоять из символов
  @samp{0} вместо пробелов.  Этот флаг игнорируется для нечисловых символов
  спецификаторов @samp{%s}, @samp{%S} и @samp{%c}.  Эти символы
  спецификаторов принимают флаг @samp{0}, но по-прежнему заполнением будет
  символ @emph{пробел}.

  Флаг @samp{-} вызывает вставку заполнения по ширине, если указан, чтобы
  вставка была справа, а не слева.  Если оба @samp{-} и @samp{0}
  присутствуют, флаг @samp{0} игнорируется.

@example
@group
(format "%06d дополняется слева нулями" 123)
     @result{} "000123 дополняется слева нулями"

(format "'%-6d' дополнительный отступ справа" 123)
     @result{} "'123   ' дополнительный отступ справа"

(format "Слово '%-7s' на самом деле имеет %d буквы."
        "foo" (length "foo"))
     @result{} "Слово 'foo    ' на самом деле имеет 3 буквы."
@end group
@end example

@cindex field width
@cindex padding
  Спецификатор формата может иметь @dfn{ширину}, которая представляет собой
  десятичное число, которое появляется после любого номера поля или флага.
  Если печатное представление объекта содержит меньше символов, чем указаная
  ширина, @code{format} расширяет его вставкой.  Любая вставка по ширине, как
  правило, состоит из пробелов, вставленных слева:

@example
(format "%5d дополняется слева пробелами" 123)
     @result{} "  123 дополняется слева пробелами"
@end example

@noindent
Если ширина слишком мала, @code{format} не обрежет печатанное представление
объекта.  Таким образом, вы можете использовать ширину, чтобы задать
минимальный интервал между столбцами без риска потери информации.  В
следующих двух примерах, @samp{%7s} определяет минимальную ширину 7.  В
первом случае, вставляемая строка выводится спецификатором @samp{%7s} и имеет
три буквы, и дополняется 4 пробелами, как заполнение.  Во втором случае,
строка @code{"спецификация"} содержит 12 букв в ширину, но не обрезается.

@example
@group
(format "Слово '%7s' имеет %d буквы."
        "foo" (length "foo"))
     @result{} "Слово '    foo' имеет 3 буквы."
(format "Слово '%7s' имеет %d букв."
        "спецификация" (length "спецификация"))
     @result{} "Слово 'спецификация' имеет 12 букв."
@end group
@end example

@cindex precision in format specifications
  Все спецификаторы позволяют дополнительно указать @dfn{точность} после
  номера поля, флагов и ширины, если таковая имеется.  Точность указывается
  после десятичной точки @samp{.} с последующей цифровой строкой.  Для
  (@samp{%e} и @samp{%f}) спецификаторов формата числа с плавающей точкой,
  точность определяет, сколько цифр после десятичной точки требуется вывести;
  Если точность равна нулю, то сама по себе десятичная точка также
  опускается.  Для @samp{%g}, точность определяет, сколько отображаемых
  значащих цифр (значащие цифры --- это первая цифра до десятичной точки и
  все цифры после неё ВопросStrings1067).  Если точность %g равно нулю или
  не указана, она рассматривается как 1.  Для @samp{%s} и @samp{%S}, точность
  усекает строку до заданной ширины, поэтому @samp{%.3s} показывает только
  первые три символа представления @var{object}.  Для других символов
  спецификаторов формата, эффект точности является то, что производят
  локальные библиотечные функции семейства @code{printf}.

@node Case Conversion
@section Преобразование Регистра в Lisp
@cindex upper case
@cindex lower case
@cindex character case
@cindex case conversion in Lisp

  Функции регистров символов изменяют регистр отдельных символов или
  содержимого строк.  Функции обычно конвертируют только буквенные символы
  (буквы @samp{A} и @samp{Z} в @samp{a} и @samp{z}, а также
  не-@acronym{ASCII} буквы); другие символы не изменяются.  Вы можете указать
  другое сопоставление отображения преобразования регистра, указав таблицу
  вариантов (@pxref{Case Tables}).

  Эти функции не изменяют строки, которые передаются им в качестве
  аргументов.

  Приведенные ниже примеры используют символы @samp{X} и @samp{x} которые
  имеют @acronym{ASCII} коды 88 и 120 соответственно.

@defun downcase string-or-char
Функция преобразует @var{string-or-char}, что должно быть либо символ либо
строкой, в нижний регистр.

Когда @var{string-or-char} строка, то функция возвращает новую
строку, в которой каждая буква аргумента, имеющая верхний регистр,
преобразуется в нижний регистр.  Когда @var{string-or-char} символ, функция
возвращает соответствующий символ нижнего регистра (целое число); если
исходный символ в нижнем регистре, или представляет собой не букву, то
возвращаемое значение равно исходному символу.

@example
(downcase "Кот в шляпе")
     @result{} "кот в шляпе"

(downcase ?X)
     @result{} 120
@end example
@end defun

@defun upcase string-or-char
Функция преобразует @var{string-or-char}, которое должно быть либо символ
либо строка, в верхний регистр.

Когда @var{string-or-char} строка, функция возвращает новую строку, в которой
каждая буква аргумента, имеющая нижний регистр преобразуется в верхний
регистр.  Когда @var{string-or-char} символ, функция возвращает
соответствующий символ верхнего регистра (целое число); если исходный символ
в верхнем регистре, или представляет собой не букву, то возвращаемое
значение равно исходному символу.

@example
(upcase "Кот в шляпе")
     @result{} "КОТ В ШЛЯПЕ"

(upcase ?x)
     @result{} 88
@end example
@end defun

@defun capitalize string-or-char
@cindex capitalization
Функция заглавной строки или символа.  Если @var{string-or-char} строка, то
функция возвращает новую строку, содержимое которой являются копией
@var{string-or-char}, в котором каждое слово начинается с заглавной буквы.
Это означает, что первый символ каждого слова преобразуется в верхний
регистр, а остальные преобразуются в нижний регистр.

Определение слова это любая последовательность последовательности символов,
которая присвоена классу синтаксиса, составляющая слово, в текущей таблице
синтаксиса (@pxref{Syntax Class Table}).

Когда @var{string-or-char} символ, функция делает то же самое, что и
@code{upcase}.

@example
@group
(capitalize "кот в шляпе")
     @result{} "Кот В Шляпе"
@end group

@group
(capitalize "77-й кот в шляпе")
     @result{} "77th-Кот В Шляпе"
@end group

@group
(capitalize ?x)
     @result{} 88
@end group
@end example
@end defun

@defun upcase-initials string-or-char
Если @var{string-or-char} строка, функция использует заглавные буквы слов
в @var{string-or-char}, без изменения каких-либо букв, кроме инициалов.
Возвращает новую строку, содержимое которой являются копией
@var{string-or-char}, в которой каждое слово имеет свою начальную букву в
верхнем регистре.

Определение слова это любая последовательность последовательности символов,
которая присвоена классу синтаксиса слова, в текущей таблице синтаксиса
(@pxref{Syntax Class Table}).

Когда аргумент @code{upcase-initials} символ, @code{upcase-initials} имеет
тот же результат, что и @code{upcase}.

@example
@group
(upcase-initials "КОт в шЛЯпе")
     @result{} "КОт В ШЛЯпе"
@end group
@end example
@end defun

  Следует отметить, что преобразование регистра не является
  взаимно-однозначным отображением кодовых значений и длина результата может
  отличаться от длины аргумента.  Кроме того, передача символа заставляет
  возвращаемый тип быть символом, функции не могут выполнять надлежащую
  замену и результат может отличаться по сравнению с обработкой строки из
  одного символа. (ВопросStrings1194) Например:

@ifnottex
@example
@group
(upcase "ﬁ")  ; Примечание: один символ, лигатура "fi"
     @result{} "FI"
@end group
@group
(upcase ?ﬁ)
     @result{} 64257  ; то есть ?ﬁ
@end group
@end example
@end ifnottex
@iftex
@example
@group
(upcase "@r{fi}")  ; Примечание: один символ, лигатура "fi"
     @result{} "FI"
@end group
@group
(upcase ?@r{fi})
     @result{} 64257  ; то есть ?@r{fi}
@end group
@end example
@end iftex

  Чтобы избежать этого, символ сначала должен быть преобразован в строку,
  используя функцию @code{string}, перед передачей одной из функций
  преобразования регистра.  Конечно, нет никаких предположений о
  продолжительности результата (ВопросStrings1224 длина или время).

  Отображение для таких особых случаев, взяты из
@code{special-uppercase}, @code{special-lowercase} и
@code{special-titlecase} @xref{Character Properties}.

  @xref{Text Comparison}, функции сравнения строк; некоторые из них
  игнорируют различия регистра, или имеют возможность управлять
  игнорированием регистра.

@node Case Tables
@section Таблица Регистра

  Можно настроить преобразование регистра, установив специальную
  @dfn{таблицу регистра}.  Таблица регистра задает отображение между верхним
  и нижним регистром букв.  Это затрагивает функции преобразования регистра
  для объектов Lisp (смотрите предыдущий раздел), и те, которые относятся к
  тексту в буфере (@pxref{Case Changes}).  У кажддого буфера есть таблица
  регистра; есть также стандартная таблица регистра, которая используется
  для инициализации таблицы регистра новых буферов.

  Таблица регистра --- это символ-таблица (@pxref{Char-Tables}) подтип
  которой @code{case-table}.  Эта символ-таблица отображает каждый символ в
  соответствующий ему символ нижнего регистра.  Она имеет три дополнительных
  слота, которые удерживают связанные таблицы:

@table @var
@item upcase
Таблица отображает каждый символ в соответствующий символ верхнего регистра.
@item canonicalize
Таблица канонической формы отображает все символы из набора, связанные в
частности с регистром, в конкретный член этого набора. (ВопросStrings1255)
@item equivalences
Таблица эквивалентностей отображает каждый из набора символов, связанных
с регистром, в следующий символ в этом наборе.
@end table

  В простых случаях, все, что вам необходимо указать --- это преобразование в
  нижний регистр; три связанные таблицы будут рассчитаны на основе этой
  автоматически.

  Для некоторых языков буквы верхнего и нижнего регистра букв не находятся во
  взаимно однозначном соответствии.  Могут быть две разные строчные буквы с
  одним и темже эквивалентом в верхнем регистре.  В этих случаях необходимо
  определить карты как для нижнего, так и верхнего регистров.

  Дополнительная таблица @var{canonicalize} отображает каждый символ в его
  канонический эквивалент; любые два символа, которые связаны прецедентном
  преобразования регистра, имеют один и тот же канонический эквивалентный
  символ.  Например, так как @samp{a} и @samp{A} связаны преобразованием
  регистра, они должны иметь один и тот же канонический эквивалентный символ
  (который должен быть либо @samp{a} для них обоих, либо @samp{A}, опять же
  для них обоих).

  Дополнительная таблица @var{equivalences} представляет собой карту,
  которая циклически переставляет каждый класс эквивалентности (символов с
  тем же каноническим эквивалентом).  (Для обычного символа @acronym{ASCII},
  эта карта будет отображать @samp{a} в @samp{A} и @samp{A} в @samp{a}, а
  также для каждого эквивалентного символа этого набора.)

  При построении таблицы регистра, можете предоставить @code{nil} для
  @var{canonicalize}; тогда Emacs заполняет этот слот отображением нижнего
  и верхнего регистров.  Вы также можете предоставить @code{nil} для
  @var{equivalences}; тогда Emacs заполняет этот слот из таблицы
  @var{canonicalize}.  В фактически используемой таблице регистра, эти
  компоненты установлены в не-@code{nil}.  Не пытайтесь задать
  @var{equivalences}, не указав также @var{canonicalize}.

  Вот функции для работы с тематическими таблицами:

@defun case-table-p object
Предикат возвращает не-@code{nil} если @var{object} является допустимой
таблицей регистра.
@end defun

@defun set-standard-case-table table
Функция создаёт стандартную таблицу регистра @var{table}, так что она будет
использоваться в любых буферах, созданных впоследствии.
@end defun

@defun standard-case-table
Возвращает стандартную таблицу регистра.
@end defun

@defun current-case-table
Функция возвращает таблицу регистра текущего буфера.
@end defun

@defun set-case-table table
Устанавливает таблицу регистра текущего буфера из @var{table}.
@end defun

@defmac with-case-table table body@dots{}
@code{with-case-table} макрос сохраняет текущую таблицу регистра, делает
@var{table} текущей таблицей регистра, оценивает форму @var{body}, и,
наконец, восстанавливает таблицу регистра.  Возвращаемое значение --- это
значение последней оценённой формы в @var{body}.  Таблица регистра
восстанавливается ​​даже в случае аварийного выхода через @code{throw} или
ошибки (@pxref{Nonlocal Exits}).
@end defmac

  Некоторые языковые среды изменяют преобразование регистра @acronym{ASCII}
  символов; например, в среде турецкого языка, заглавная буква I
  в @acronym{ASCII} преобразована в турецкую i без точки (@samp{ı}).  Это
  может помешать работе кода, который требует обычного преобразования
  регистра @acronym{ASCII}, например реализации  сетевых протоколов
  основанных на @acronym{ASCII}.  В этом случае используйте
  @code{with-case-table} макрос с переменной @var{ascii-case-table}, которая
  хранит неизмененную таблицу регистра для набора @acronym{ASCII} символов.

@defvar ascii-case-table
Таблица регистра для @acronym{ASCII} набора символов. Это не должно менятся
никакими настройками языковой среды.
@end defvar

  Следующие три функции являются удобными подпрограммами для пакетов, которые
  определяют не-@acronym{ASCII} наборы символов.  Модифицируют указанную
  таблицу регистра @var{case-table}; также изменяют стандартную таблицу
  синтаксиса.  @xref{Syntax Tables}.  Обычно функции используются, чтобы
  изменить стандартную таблицу регистра.

@defun set-case-syntax-pair uc lc case-table
Функция определяет пару соответствующих букв, одну верхнего и одну нижнего
регистра.
@end defun

@defun set-case-syntax-delims l r case-table
Функция делает символы @var{l} и @var{r} сопряжённой парой, не зависящей
от регистра.  (ВопросStrings1352).
@end defun

@defun set-case-syntax char syntax case-table
Функция делает @var{char} безразличным к регистру, с синтаксисом
@var{syntax}.
@end defun

@deffn Command describe-buffer-case-table
Команда выводит на экран описание содержимого таблицы регистра текущего
буфера.
@end deffn
