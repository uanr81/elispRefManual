@c -*- mode: texinfo; coding: utf-8 -*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2019 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Strings and Characters
@chapter Строки и символы
@cindex strings
@cindex character arrays
@cindex characters
@cindex bytes

  Строка в Emacs Lisp представляет собой массив, содержащий упорядоченную
  последовательность символов.  Строки используются в качестве имен
  символов, буферов и файлов; для отправки сообщения пользователям; для
  хранения текста копируемого между буферами; и для многих других целей.
  Поскольку строки настолько важны, Emacs Lisp имеет множество функций
  специально предназначенных для работы с ними.  Emacs Lisp программа
  использует строки чаще, чем отдельные символы.

  @xref{Strings of Events}, особые соображения по поводу строк событий
  символов клавиатуры.

@menu
* Basics: String Basics.      Основные свойства строк и символов.
* Predicates for Strings::    Проверка того, объект строка или символ.
* Creating Strings::          Функции для выделения новых строк.
* Modifying Strings::         Изменение содержимого существующей строки.
* Text Comparison::           Сравнение символов или строк.
* String Conversion::         Преобразование символов в строку и обратно.
* Formatting Strings::        @code{format}: аналог Emacs С @code{printf}.
* Case Conversion::           Функции преобразования регистра.
* Case Tables::               Настройка преобразования регистра.
@end menu

@node String Basics
@section Строки и Символы Основы

  Символ --- это объект Lisp, который представляет собой одиночный символ
  текста.  В Emacs Lisp символы --- это просто целые числа; является ли
  целое число, символ или нет, определяется только тем, как оно используется.
  @xref{Character Codes}, для получения подробной информации о представлении
  символов в Emacs.

  Строка --- это фиксированная последовательностью символов.  Это тип
  последовательности называется @dfn{массивом} и означает, что его длина
  фиксирована и не может быть изменена после его создания
  (@pxref{Sequences Arrays Vectors}).  В отличие от C, Emacs Lisp строки
  @emph{not} имеют кода символа завершения строки.

  Поскольку строки являются массивами, а значит, и последовательностямии,
  вы можете работать с ними с помощью общих функций для массивов и
  последовательностей, описанных в @ref{Sequences Arrays Vectors}.  Например,
  вы можете получить доступ к отдельным символам строки или изменить их с
  помощью функций @code{aref} и @code{aset} (@pxref{Array Functions}).  Тем
  не менее, отметим, что @code{length} @emph{not} должна быть использована
  для вычисления ширины строки на дисплее; используется @code{string-width}
  (@pxref{Size of Displayed Text}) вместо этого.

  Есть два текстовых представлений для не-@acronym{ASCII} символов в строках
  Emacs (и в буферах): однобайтные и многобайтовые.  Для большей части Lisp
  программирования, вам не нужно беспокоится об этих двух представлениях.
  @xref{Text Representations}, для деталей.

  Иногда ключевые последовательности представлены в виде однобайтовых строк.
  Когда однобайтная строка является ключевой последовательностью, строковые
  элементы в диапазоне от 128 до 255 представляют собой мета-символы (которые
  являются большими целыми числами), а не кодами символов в диапазоне от 128
  до 255.  Строки не может содержать символы с модификаторами hyper, super
  или alt; они могут держать управляющие символы @acronym{ASCII}, но не могут
  содержать никакие другие управляющие символы.  Они не различают регистр
  @acronym{ASCII} управляющих символов.  Если вы хотите сохранить такие
  символы в последовательности, такой как последовательность клавиш, вы
  должны использовать вектор вместо строки.  @xref{Character Type}, для
  получения дополнительной информации о вводе символов с клавиатуры.

  Строки могут быть использованы для хранения регулярных выражений.  Вы
  можете также сопоставить регулярное выражение со строкой используя
  @code{string-match} (@pxref{Regexp Search}).  Функции @code{match-string}
  (@pxref{Simple Match Data}) и @code{replace-match}
  (@pxref{Replacing Match}) полезны для разложения и изменения строк после
  согласования с ними регулярных выражений.

  Подобно буферу, строка может содержать, помимо самих символов, текстовые
  свойства символов.  @xref{Text Properties}.  Все Lisp примитивы,
  копирующие текст из строк в буферы или другие строки, также копируют
  свойство копируемых символов.

  @xref{Text}, для получения информации о функциях, отображающих строки или
  копирующих строки в буфер.  @xref{Character Type}, и @ref{String Type}, для
  получения информации о синтаксисе символов и строк.
  @xref{Non-ASCII Characters}, для функций преобразования между текстовым
  представлением и кодирования и декодирования кодов символов.

@node Predicates for Strings
@section Предикаты Строк
@cindex predicates for strings
@cindex string predicates

Для получения дополнительной информации об общих предикатах
последовательностей и предикатах массивов,
see @ref{Sequences Arrays Vectors}, и @ref{Arrays}.

@defun stringp object
Функция возвращает @code{t} если @var{object} является строкой,
@code{nil} в противном случае.
@end defun

@defun string-or-null-p object
Функция возвращает @code{t} если @var{object} является строкой или
@code{nil}.  Возвращает @code{nil} в противном случае.
@end defun

@defun char-or-string-p object
Функция возвращает @code{t}, если @var{object} является строкой или символом
(т.е., целым числом), в противном случае возвращается @code{nil}.
@end defun

@node Creating Strings
@section Создание Строк
@cindex creating strings
@cindex string creation

  Следующие функции создают строки, либо с нуля, либо путем объединения
  или раделения строк.

@defun make-string count character
Функция возвращает строку, состоящую из @var{count} повторений
@var{character}.  Если @var{count} отрицательный, сигнализируется об ошибке.

@example
(make-string 5 ?x)
     @result{} "xxxxx"
(make-string 0 ?x)
     @result{} ""
@end example

  Другие функции для сравнения с этой @code{make-vector} (@pxref{Vectors}) и
  @code{make-list} (@pxref{Building Lists}).
@end defun

@defun string &rest characters
Функция возвращает строку, содержащую символы @var{characters}.

@example
(string ?a ?b ?c)
     @result{} "abc"
@end example
@end defun

@defun substring string &optional start end
Функция возвращает новую строку, состоящую из символов @var{string} в
диапазоне от (включая) символ c индексом @var{start} до (не включая) символ
с индексом @var{end}.  Первый символ имеет нулевой индекс.  С одним
аргументом, эта функция просто копирует @var{string}.

@example
@group
(substring "abcdefg" 0 3)
     @result{} "abc"
@end group
@end example

@noindent
В приведенном выше примере, индекс для @samp{a} равен 0, индекс для @samp{b}
равен 1, а индекс для @samp{c} равен 2.  Индекс 3--- с четвертой позицией
символа в строке --- отмечает позицию символа, до которого подстрока
копируется.  Таким образом, @samp{abc} копируется из строки @code{"abcdefg"}.

Отрицательное значение подсчитывает позицию символа от конца строки, так что
@minus{}1 означает индекс последнего символа строки. Например:

@example
@group
(substring "abcdefg" -3 -1)
     @result{} "ef"
@end group
@end example

@noindent
В этом примере, индекс для @samp{e} является @minus{}3, индекс для @samp{f}
является @minus{}2, а индекс для @samp{g} является @minus{}1.  Поэтому
символы @samp{e} и @samp{f} включены, и @samp{g} исключается.

Когда @code{nil} используется для аргумента @var{end}, это означает до длинны
строки. Таким образом,

@example
@group
(substring "abcdefg" -3 nil)
     @result{} "efg"
@end group
@end example

Опущенный аргумент @var{end} эквивалентен заданому в @code{nil}.  Отсюда
следует, что @code{(substring @var{string} 0)} возвращает копию всех
символов @var{string}.

@example
@group
(substring "abcdefg" 0)
     @result{} "abcdefg"
@end group
@end example

@noindent
Рекомендуется @code{copy-sequence} для такой задачи
(@pxref{Sequence Functions}).

Если символы, скопированные из @var{string} имеют текстовые свойства,
свойства также копируются в новую строку.  @xref{Text Properties}.

@code{substring} также принимает вектор в качестве своего первого аргумента.
Например:

@example
(substring [a b (c) "d"] 1 3)
     @result{} [b (c)]
@end example

Ошибка @code{wrong-type-argument} сигнализируется, если @var{start} не
является целым числом, или если @var{end} не является ни целым числом, ни
@code{nil}.  Ошибка @code{args-out-of-range} сигнализируется, если
@var{start} указывает на символ, следующий @var{end}, или если указано
любое значение целого числа, которое находится вне допустимого диапазона
для @var{string}.

Сравните эту функцию с @code{buffer-substring} (@pxref{Buffer Contents}),
которая возвращает строку, содержащую часть текста в текущем буфере.  Начало
строки имеет индекс 0, а начало буфера индекс 1.
@end defun

@defun substring-no-properties string &optional start end
Функция работает как @code{substring} но отбрасывает все значения свойств
текста.  Кроме того, @var{start} можно опускать или устанавливать в
@code{nil}, что эквивалентно 0.  Таким образом,
@w{@code{(substring-no-properties @var{string})}} возвращает копию
@var{string}, без свойств текста.
@end defun

@defun concat &rest sequences
@cindex copying strings
@cindex concatenating strings
Функция возвращает новую строку, состоящую из символов, переданных ей
аргументами (вместе с их свойствами текста, если таковые имеются).  Аргументы
могут быть строки, списки или векторы чисел; сами передеанные в аргументах
данные не изменяются.  Если @code{concat} не передаётся никаких аргументов,
возвращается пустая строка.

@example
(concat "abc" "-def")
     @result{} "abc-def"
(concat "abc" (list 120 121) [122])
     @result{} "abcxyz"
;; @r{@code{nil} пустая последовательность.}
(concat "abc" nil "-def")
     @result{} "abc-def"
(concat "Это " " очень шустрая " "лиса.")
     @result{} "Это очень шустрая лиса."
(concat)
     @result{} ""
@end example

@noindent
Функция всегда создает новую строку, которая не @code{eq} к любой
существующей строке, кроме случаев, когда результатом является пустая строка
(для экономии места, Emacs создаёт только одну многобайтовую пустую строку).

Для получения информации о других функциях конкатенации, смотрите описание
@code{mapconcat} в @ref{Mapping Functions}, @code{vconcat} в
@ref{Vector Functions} и @code{append} в @ref{Building Lists}.  Для
конкатенации аргументов командной строки в строку, которая будет
использоваться в качестве команды оболочки, смотри
@ref{Shell Arguments, combine-and-quote-strings}.
@end defun

@defun split-string string &optional separators omit-nulls trim
Функция разбивает @var{string} на подстроки на основе регулярного выражения
@var{separators} (@pxref{Regular Expressions}).  Каждое соответствие
для @var{separators} определяет точку расделения; подстроки между точками
разделения объединяются в список, который возвращается.

Если @var{separators} установлен в @code{nil} (или опущен), то по умолчанию
используется значение @code{split-string-default-separators} и функция ведет
себя так, как если бы @var{omit-nulls} были установлены в @code{t}.

Если @var{omit-nulls} установлен в @code{nil} (или опущен), то результат
будет содержать пустые строки всякий раз, когда есть два последовательных
совпадения для @var{separators}, или совпадение примыкает к началу или концу
@var{string}.  Если @var{omit-nulls} установлен в @code{t}, эти пустые строки
будут исключены из результата.

Если необязательный аргумент @var{trim} установлен в не-@code{nil}, это
должно быть регулярным выражением для сопоставления тексту для брезки от
начала и до конца каждой подстроки.  Если обрезка делает подстроку пустой,
это трактуется как null.

Если вам нужно разбить строку на список аргументов командной строки,
пригодный для @code{call-process} или @code{start-process},
смотри @ref{Shell Arguments, split-string-and-unquote}.

Примеры:

@example
(split-string "  два слова ")
     @result{} ("два" "слова")
@end example

Результатом будет не @code{("" "два" "слова" "")}, который редко бывает
полезным.  Если вам нужен такой результат, используйте явное значение для
@var{separators}:

@example
(split-string "  два слова "
              split-string-default-separators)
     @result{} ("" "два" "слова" "")
@end example

@example
(split-string "Слово гиппопотомомонстросесквиппедалиофобия" "п")
     @result{} ("Слово ги" "" "о" "отомомонстросескви" "" "едалиофобия")
(split-string "Слово гиппопотомомонстросесквиппедалиофобия" "п" t)
     @result{} ("Слово ги" "о" "отомомонстросескви" "едалиофобия")
(split-string "Слово гиппопотомомонстросесквиппедалиофобия" "п+")
     @result{} ("Слово ги" "о" "отомомонстросескви" "едалиофобия")
@end example

Необязательные сопоставления учитываются, за исключением того, что
@code{split-string} не будет брать во внимание конечное необязательное
сопоставление, когда уже достигнут конец строки, при использовании
необязательного совпадения или когда @var{string} пустая строка:

@example
(split-string "aooob" "o*")
     @result{} ("" "a" "" "b" "")
(split-string "ooaboo" "o*")
     @result{} ("" "" "a" "b" "")
(split-string "" "")
     @result{} ("")
@end example

Однако, когда @var{separators} может соответствовать пустой строке,
@var{omit-nulls} обычно устанавливают в @code{t}, так что тонкости в трех
предыдущих примерах редко актуальны:

@example
(split-string "Soup is good food" "o*" t)
     @result{} ("S" "u" "p" " " "i" "s" " " "g" "d" " " "f" "d")
(split-string "Nice doggy!" "" t)
     @result{} ("N" "i" "c" "e" " " "d" "o" "g" "g" "y" "!")
(split-string "" "" t)
     @result{} nil
@end example

Несколько странно, но предсказуемое поведение может иметь место для
определенных ``не-жадных'' значений @var{separators}, которые могут
предпочесть пустые совпадения над непустыми.  Опять же, такие значения редко
встречаются на практике:

@example
(split-string "ooo" "o*" t)
     @result{} nil
(split-string "ooo" "\\|o+" t)
     @result{} ("o" "o" "o")
@end example
@end defun

@defvar split-string-default-separators
Значение по умолчанию @var{separators} @code{split-string}. Его обычное
значение @w{@code{"[ \f\t\n\r\v]+"}}.
@end defvar

@node Modifying Strings
@section Изменение Строк
@cindex modifying strings
@cindex string modification

  Самый простой способ изменить содержимое существующей строки---использовать
  @code{aset} (@pxref{Array Functions}).
  @code{(aset @var{string} @var{idx} @var{char})} сохраняет @var{char} в
  @var{string} позиции с индексом @var{idx}.  Каждый символ занимает один
  или несколько байтов, и если @var{char} символ имеет другое количество
  байтов, уже присутствующих в позиции по этому индексу, @code{aset}
  сигнализирует об ошибке.

  Более эффективная функция @code{store-substring}:

@defun store-substring string idx obj
Функция изменяет часть содержимого строки @var{string}, сохраняя @var{obj},
начиная с индексом @var{idx}.  Аргумент @var{obj} может быть либо символом
либо (меньшего размера) строкой.

Так как невозможно изменить длину существующей строки, произойдёт ошибка,
если @var{obj} не вписывается в фактическую длину @var{string}, или если
какой-либо новый символ требует другое количество байт чем имеет заменяемый
символ в текущей позиции @var{string}.
@end defun

  Чтобы очистить строку, которая содержала пароль, используется
@code{clear-string}:

@defun clear-string string
Сделает @var{string} строку однобайтовой и очистит её содержимое до нуля.
Это также может изменить длину @var{string}.
@end defun

@need 2000
@node Text Comparison
@section Сравнение Символов и Строк
@cindex string equality
@cindex text comparison

@defun char-equal character1 character2
Функция возвращает @code{t} если аргументы представляют собой один и тот же
символ, @code{nil} в противном случае.  Функция игнорирует регистр, если
переменная @code{case-fold-search} установленявлена в не-@code{nil}.

@example
(char-equal ?x ?x)
     @result{} t
(let ((case-fold-search nil))
  (char-equal ?x ?X))
     @result{} nil
@end example
@end defun

@defun string= string1 string2
Функция возвращает @code{t}, если символы двух строк точно совпадать.
Символы также допускаются в качестве аргументов, в этом случае используются
имена символов.  Регистр всегда имеет значение, независимо от
@code{case-fold-search}.

Функция эквивалентна @code{equal} для сравнения двух строк
(@pxref{Equality Predicates}).  В частности, текстовые свойства двух строк
игнорируются; используется @code{equal-including-properties}, если нужно
различать строки, которые отличаются только по их свойствах текста.  Однако,
в отличие от @code{equal}, если один из аргументов не является строкой или
символ, @code{string=} сигнализирует об ошибке.

@example
(string= "abc" "abc")
     @result{} t
(string= "abc" "ABC")
     @result{} nil
(string= "ab" "ABC")
     @result{} nil
@end example

По техническим причинам однобайтная и многобайтовая строка являются
@code{equal} тогда и только тогда, когда они содержат одну и ту же
последовательность кодов символов, и все эти коды находятся либо в диапазоне
от 0 до 127 (@acronym{ASCII}) либо от 160 до 255 (@code{eight-bit-graphic}).
Однако, когда однобайтная строка преобразуются в многобайтовую строку все
символы с кодами в диапазоне от 160 до 255, преобразуются в символы с более
большими значениями кодов, тогда как @acronym{ASCII} символы остаются
неизменными.  Таким образом, однобайтная строка и ее преобразование в
многобайтовую возможно только с @code{equal}, если вся строка содержит только
@acronym{ASCII} символы.  Символьные коды от 160 до 255 не совсем подходят
для многобайтового текста, несмотря на то, что они могут там встречаться.
Как следствие, ситуация, когда однобайтные и многобайтовая строка являются
@code{equal} без того, чтобы обе состояли лиш из @acronym{ASCII} символов
является техническим курьезом, с которой когда либо сталкивались очень
немногие Emacs Lisp программисты.  @xref{Text Representations}.
@end defun

@defun string-equal string1 string2
@code{string-equal} другое название @code{string=}.
@end defun

@cindex locale-dependent string equivalence
@defun string-collate-equalp string1 string2 &optional locale ignore-case
Эта функция возвращает @code{t} если @var{string1} и @var{string2} равны по
отношению к правилам сортировки.  Правило сортировки определяется не только
лексикографическим порядком символов, содержащихся в @var{string1} и
@var{string2}, но и дополнительными правилами об отношениях между этими
символами.  Обычно это определяется @var{локалью} в которой исполняется
Emacs.

Например, символы с разным кодированием, но с одинаковым значении могут
считаться равными, как различные символы с грависом Unicode:

@example
@group
(string-collate-equalp (string ?\uFF40) (string ?\u1FEF))
     @result{} t
@end group
@end example

Необязательный аргумент @var{locale} --- это строка, переопределяет настройки
вашего текущего идентификатора языка для сопоставления.  Значение зависит от
системы; @var{locale} @code{"en_US.UTF-8"} применим в системах POSIX, в то
время как это было бы, например, @code{"enu_USA.1252"} в системах MS-Windows.

Если @var{ignore-case} установлен в не-@code{nil}, символы преобразуются в
нижний регистр, прежде чем сравнивать их.

@vindex w32-collate-ignore-punctuation
Для эмуляции Unicode-совместимых параметров сортировки в системах MS-Windows,
привяжите @code{w32-collate-ignore-punctuation} к значению не-@code{nil},
поскольку часть кодового набора не может быть @code{"UTF-8"} на MS-Windows.

Если ваша система не поддерживает локаль, эта функция ведет себя как
@code{string-equal}.

@emph{Не} используйте эту функцию, для сравнивнения имён файлов, так как
файловые системы, как правило, не выполняют лингвистическую эквивалентность
строк, сортировки орудий. (ВопросКакихТакихОрудий strings507)
@end defun

@cindex lexical comparison of strings
@defun string< string1 string2
@c (findex string< вызывает проблемы для переставленного индекса !!)
Функция сравнивает две строки посимвольно.  Сканирует обе строки
одновременно, чтобы найти первую несоответствующую пару.  Если меньшее
значение кода символа принадлежит @var{string1}, тогда @var{string1} меньше
@var{string2}, и возвращается @code{t}.  Если меньший код символа принадлежит
@var{string2}, тогда @var{string1} больше @var{string2}, и возвращается
@code{nil}.  Если две строки совпадают полностью, то возвращается значение
@code{nil}.

Пары символов сравниваются в соответствии с их кодами символов. Имейте в
виду, что строчные буквы имеют более высокие числовые значения в наборе
символов @acronym{ASCII}, чем их аналоги верхнего регистра; цифры и многие
знаки препинания имеют более низкое числовое значение, чем заглавные буквы.
Код @acronym{ASCII} символа меньше любого кода не-@acronym{ASCII} символа;
однобайтный не-@acronym{ASCII} символ всегда меньше, чем любой многобайтный
не-@acronym{ASCII} символ (@pxref{Text Representations}).

@example
@group
(string< "abc" "abd")
     @result{} t
(string< "abd" "abc")
     @result{} nil
(string< "123" "abc")
     @result{} t
@end group
@end example

Когда строки имеют разную длину, и они совпадают до длинны @var{string1}, то
результат будет @code{t}.  Если они совпадают с длиной @var{string2},
результатом будет @code{nil}. Строка без символов меньше, чем любая другая
строка.

@example
@group
(string< "" "abc")
     @result{} t
(string< "ab" "abc")
     @result{} t
(string< "abc" "")
     @result{} nil
(string< "abc" "ab")
     @result{} nil
(string< "" "")
     @result{} nil
@end group
@end example

Символы также допускаются в качестве аргументов, в этом случае сравниваются
их печатное представление имени.
@end defun

@defun string-lessp string1 string2
@code{string-lessp} это другое название @code{string<}.
@end defun

@defun string-greaterp string1 string2
Функция возвращает результат сравнения @var{string1} и @var{string2} в
обратном порядке, т.е., это эквивалентно вызову
@code{(string-lessp @var{string2} @var{string1})}.
@end defun

@cindex locale-dependent string comparison
@defun string-collate-lessp string1 string2 &optional locale ignore-case
Функция возвращает @code{t} если @var{string1} меньше @var{string2} в
порядке сортировки.  Результат сопоставления определяются не только
лексикографическим порядком символов, содержащиеся в @var{string1} и
@var{string2}, но и дополнительными правилами относительно отношений между
этими символами.  Обычно это определяет @var{локаль}, в которой работает
Emacs.

Например, знаки препинания и пробелы могут быть проигнорированы при
сортировке (@pxref{Sequence Functions}):

@example
@group
(sort '("11" "12" "1 1" "1 2" "1.1" "1.2") 'string-collate-lessp)
     @result{} ("11" "1 1" "1.1" "12" "1 2" "1.2")
@end group
@end example

Это поведение зависит от системы; например, знаки препинания и пробелы не
будут игнорироваться на Cygwin, независимо от локали.

Необязательный аргумент @var{locale}, строка, переопределяет настройки
вашего текущего идентификатора локали для сортировки.  Значение зависит от
системы; @var{locale} @code{"en_US.UTF-8"} применим в системах POSIX, в то
время как это было бы, например, в системах @code{"enu_USA.1252"}
MS-Windows.  @var{locale} значение @code{"POSIX"} или @code{"C"} позволяет
@code{string-collate-lessp} вести себя как @code{string-lessp}:

@example
@group
(sort '("11" "12" "1 1" "1 2" "1.1" "1.2")
      (lambda (s1 s2) (string-collate-lessp s1 s2 "POSIX")))
     @result{} ("1 1" "1 2" "1.1" "1.2" "11" "12")
@end group
@end example

Если @var{ignore-case} является не-@code{nil}, символы преобразуются в
нижний регистр перед их сравнением.

Для эмуляции Unicode-совместимых систем сортировки на MS-Windows,
@code{w32-collate-ignore-punctuation} связывается со значением не-@code{nil},
поскольку часть кодового набора языкового стандарта @code{"UTF-8"} не может
быть установлена на MS-Windows.

Если ваша система не поддерживает локализованную среду, эта функция ведет
себя как @code{string-lessp}.
@end defun

@defun string-version-lessp string1 string2
Функция сравнивает строки лексикографически, за исключением того, что
обрабатываются последовательности цифровых символов, как если бы они
составляли десятичное число, а затем сравниваются числа.  Так @samp{foo2.png}
``меньше'' чем @samp{foo12.png} согласно этому предикату, даже если
@samp{12} лексикографически ``меньше'' чем @samp{2}.
@end defun

@defun string-prefix-p string1 string2 &optional ignore-case
Функция возвращает не-@code{nil} если @var{string1} является префиксом
@var{string2}; т.е., если @var{string2} начинается с @var{string1}.  Если
необязательный аргумент @var{ignore-case} установлен в не-@code{nil},
сравнение не учитывает регистр букв.
@end defun

@defun string-suffix-p suffix string &optional ignore-case
Функция возвращает не-@code{nil} если @var{suffix} является суффиксом
@var{string}; т.е., если @var{string} заканчивается на @var{suffix}.  Если
необязательный аргумент @var{ignore-case} установлен в не-@code{nil},
сравнение не учитывает регистр букв.
@end defun

@defun compare-strings string1 start1 end1 string2 start2 end2 &optional ignore-case
Функция сравнивает определённую часть @var{string1} с определенной частью
@var{string2}.  Часть @var{string1} начинается с индекса @var{start1}
(включая) и заканчивается индексом @var{end1} (исключая); @code{nil} для
@var{start1} означает брать часть с начала строки, в то время как @code{nil}
для @var{end1} означает до длинны всей строки.  Точно так же задаётся часть
@var{string2} от индекса @var{start2} до индекса @var{end2}.

Строки сравниваются по числовым значениям своих символов.  Например,
@var{str1} считается меньше чем @var{str2}, если её первый отличаяющийся
символ имеет меньшее числовое значение.  Если @var{ignore-case} установлена в
не-@code{nil}, символы преобразуются в верхний регистр перед их сравнением.
Однобайтные строки преобразуются в многобайтовые для сравнения
(@pxref{Text Representations}), так что однобайтновая и её преобразование в
многобайтовую всегда считаются равными.

Если указанные участки двух строк совпадают, возвращается значение @code{t}.
В противном случае, значение представляет собой целое число, которое
указывает, сколько ведущих символов согласовано, и какая строка меньше.  Его
абсолютная величина равна единице плюс количество символов, которые
согласованы в начале двух строк.  Отрицательный знак, признак того, что
@var{string1} (или её определенная часть) меньше.
@end defun

@defun assoc-string key alist &optional case-fold
Функция работает как @code{assoc}, за исключением того, что @var{key} должен
быть строкой или символом, и сравнение выполняется с помощью
@code{compare-strings}.  Символы преобразуются в строки перед тестированием.
Если @var{case-fold} установлен в не-@code{nil}, @var{key} и элементы
@var{alist} преобразуются в верхний регистр перед сравнением.  В отличие от
@code{assoc}, эта функция может также сопоставлять элементы ALIST, которые
являются строками или символами, а не conses (ВопросStrings676).  В
частности, @var{alist} может быть списком строк или символов, а не
фактическим списком(ВопросStrings678).
@xref{Association Lists}.
@end defun

  Смотрите также функцию @code{compare-buffer-substrings} в
  @ref{Comparing Text}, способ сравнения текста в буфере.  Функция
  @code{string-match}, которая сопоставляет регулярное выражение со строкой,
  может быть использована для своего рода сравнения строк; смотри
@ref{Regexp Search}.

@node String Conversion
@section Преобразование Символов и Строк
@cindex conversion of strings

  В этом разделе описаны функции для преобразования между символами, строками
  и целыми числами.  @code{format} (@pxref{Formatting Strings}) и
  @code{prin1-to-string} (@pxref{Output Functions}) также могут
  преобразовывать Lisp объекты в строки.  @code{read-from-string}
  (@pxref{Input Functions}) может преобразовать строковое представление
  объекта Lisp в объект.  Функции @code{string-to-multibyte} и
  @code{string-to-unibyte} преобразовывают текстовое представление строки
  (@pxref{Converting Representations}).

  @xref{Documentation}, о функциях, которые производят текстовые описания
  текстовых символов и общих событий ввода (ВопросStrings702)
  (@code{single-key-description} и @code{text-char-description}).  Они
  используются в основном для получения справочных сообщений.

@defun number-to-string number
@cindex integer to string
@cindex integer to decimal
Функция возвращает строку, состоящую из печатанного представления десятичного
@var{number}.  Возвращаемое значение начинается со знаком минус, если
аргумент отрицателеный.

@example
(number-to-string 256)
     @result{} "256"
@group
(number-to-string -23)
     @result{} "-23"
@end group
(number-to-string -23.5)
     @result{} "-23.5"
@end example

@cindex @code{int-to-string}
@code{int-to-string} полу-устаревший псевдоним для @code{number-to-string}.

Смотри также функцию @code{format} в @ref{Formatting Strings}.
@end defun

@defun string-to-number string &optional base
@cindex string to number
This function returns the numeric value of the characters in
@var{string}.  If @var{base} is non-@code{nil}, it must be an integer
between 2 and 16 (inclusive), and integers are converted in that base.
If @var{base} is @code{nil}, then base ten is used.  Floating-point
conversion only works in base ten; we have not implemented other
radices for floating-point numbers, because that would be much more
work and does not seem useful.  If @var{string} looks like an integer
but its value is too large to fit into a Lisp integer,
@code{string-to-number} returns a floating-point result.

The parsing skips spaces and tabs at the beginning of @var{string},
then reads as much of @var{string} as it can interpret as a number in
the given base.  (On some systems it ignores other whitespace at the
beginning, not just spaces and tabs.)  If @var{string} cannot be
interpreted as a number, this function returns 0.

@example
(string-to-number "256")
     @result{} 256
(string-to-number "25 is a perfect square.")
     @result{} 25
(string-to-number "X256")
     @result{} 0
(string-to-number "-4.5")
     @result{} -4.5
(string-to-number "1e5")
     @result{} 100000.0
@end example

@findex string-to-int
@code{string-to-int} is an obsolete alias for this function.
@end defun

@defun char-to-string character
@cindex character to string
This function returns a new string containing one character,
@var{character}.  This function is semi-obsolete because the function
@code{string} is more general.  @xref{Creating Strings}.
@end defun

@defun string-to-char string
  This function returns the first character in @var{string}.  This
mostly identical to @code{(aref string 0)}, except that it returns 0
if the string is empty.  (The value is also 0 when the first character
of @var{string} is the null character, @acronym{ASCII} code 0.)  This
function may be eliminated in the future if it does not seem useful
enough to retain.
@end defun

  Here are some other functions that can convert to or from a string:

@table @code
@item concat
This function converts a vector or a list into a string.
@xref{Creating Strings}.

@item vconcat
This function converts a string into a vector.  @xref{Vector
Functions}.

@item append
This function converts a string into a list.  @xref{Building Lists}.

@item byte-to-string
This function converts a byte of character data into a unibyte string.
@xref{Converting Representations}.
@end table

@node Formatting Strings
@section Formatting Strings
@cindex formatting strings
@cindex strings, formatting them

  @dfn{Formatting} means constructing a string by substituting
computed values at various places in a constant string.  This constant
string controls how the other values are printed, as well as where
they appear; it is called a @dfn{format string}.

  Formatting is often useful for computing messages to be displayed.  In
fact, the functions @code{message} and @code{error} provide the same
formatting feature described here; they differ from @code{format-message} only
in how they use the result of formatting.

@defun format string &rest objects
This function returns a string equal to @var{string}, replacing any format
specifications with encodings of the corresponding @var{objects}.  The
arguments @var{objects} are the computed values to be formatted.

The characters in @var{string}, other than the format specifications,
are copied directly into the output, including their text properties,
if any.  Any text properties of the format specifications are copied
to the produced string representations of the argument @var{objects}.

The output string need not be newly-allocated.  For example, if
@code{x} is the string @code{"foo"}, the expressions @code{(eq x
(format x))} and @code{(eq x (format "%s" x))} might both yield
@code{t}.
@end defun

@defun format-message string &rest objects
@cindex curved quotes, in formatted messages
@cindex curly quotes, in formatted messages
This function acts like @code{format}, except it also converts any
grave accents (@t{`}) and apostrophes (@t{'}) in @var{string} as per the
value of @code{text-quoting-style}.

Typically grave accent and apostrophe in the format translate to
matching curved quotes, e.g., @t{"Missing `%s'"} might result in
@t{"Missing ‘foo’"}.  @xref{Text Quoting Style}, for how to influence
or inhibit this translation.
@end defun

@cindex @samp{%} in format
@cindex format specification
  A format specification is a sequence of characters beginning with a
@samp{%}.  Thus, if there is a @samp{%d} in @var{string}, the
@code{format} function replaces it with the printed representation of
one of the values to be formatted (one of the arguments @var{objects}).
For example:

@example
@group
(format "The value of fill-column is %d." fill-column)
     @result{} "The value of fill-column is 72."
@end group
@end example

  Since @code{format} interprets @samp{%} characters as format
specifications, you should @emph{never} pass an arbitrary string as
the first argument.  This is particularly true when the string is
generated by some Lisp code.  Unless the string is @emph{known} to
never include any @samp{%} characters, pass @code{"%s"}, described
below, as the first argument, and the string as the second, like this:

@example
  (format "%s" @var{arbitrary-string})
@end example

  Certain format specifications require values of particular types.  If
you supply a value that doesn't fit the requirements, an error is
signaled.

  Here is a table of valid format specifications:

@table @samp
@item %s
Replace the specification with the printed representation of the object,
made without quoting (that is, using @code{princ}, not
@code{prin1}---@pxref{Output Functions}).  Thus, strings are represented
by their contents alone, with no @samp{"} characters, and symbols appear
without @samp{\} characters.

If the object is a string, its text properties are
copied into the output.  The text properties of the @samp{%s} itself
are also copied, but those of the object take priority.

@item %S
Replace the specification with the printed representation of the object,
made with quoting (that is, using @code{prin1}---@pxref{Output
Functions}).  Thus, strings are enclosed in @samp{"} characters, and
@samp{\} characters appear where necessary before special characters.

@item %o
@cindex integer to octal
Replace the specification with the base-eight representation of an
unsigned integer.

@item %d
Replace the specification with the base-ten representation of a signed
integer.

@item %x
@itemx %X
@cindex integer to hexadecimal
Replace the specification with the base-sixteen representation of an
unsigned integer.  @samp{%x} uses lower case and @samp{%X} uses upper
case.

@item %c
Replace the specification with the character which is the value given.

@item %e
Replace the specification with the exponential notation for a
floating-point number.

@item %f
Replace the specification with the decimal-point notation for a
floating-point number.

@item %g
Replace the specification with notation for a floating-point number,
using either exponential notation or decimal-point notation.  The
exponential notation is used if the exponent would be less than @minus{}4 or
greater than or equal to the precision (default: 6).  By default,
trailing zeros are removed from the fractional portion of the result
and a decimal-point character appears only if it is followed by a
digit.

@item %%
Replace the specification with a single @samp{%}.  This format
specification is unusual in that its only form is plain
@samp{%%} and that it does not use a value.  For example,
@code{(format "%% %d" 30)} returns @code{"% 30"}.
@end table

  Any other format character results in an @samp{Invalid format
operation} error.

  Here are several examples, which assume the typical
@code{text-quoting-style} settings:

@example
@group
(format "The octal value of %d is %o,
         and the hex value is %x." 18 18 18)
     @result{} "The octal value of 18 is 22,
         and the hex value is 12."

(format-message
 "The name of this buffer is ‘%s’." (buffer-name))
     @result{} "The name of this buffer is ‘strings.texi’."

(format-message
 "The buffer object prints as `%s'." (current-buffer))
     @result{} "The buffer object prints as ‘strings.texi’."
@end group
@end example

  By default, format specifications correspond to successive values from
@var{objects}.  Thus, the first format specification in @var{string}
uses the first such value, the second format specification uses the
second such value, and so on.  Any extra format specifications (those
for which there are no corresponding values) cause an error.  Any
extra values to be formatted are ignored.

@cindex field numbers in format spec
  A format specification can have a @dfn{field number}, which is a
decimal number immediately after the initial @samp{%}, followed by a
literal dollar sign @samp{$}.  It causes the format specification to
convert the argument with the given number instead of the next
argument.  Field numbers start at 1.  A format can contain either
numbered or unnumbered format specifications but not both, except that
@samp{%%} can be mixed with numbered specifications.

@example
(format "%2$s, %3$s, %%, %1$s" "x" "y" "z")
     @result{} "y, z, %, x"
@end example

@cindex flags in format specifications
  After the @samp{%} and any field number, you can put certain
@dfn{flag characters}.

  The flag @samp{+} inserts a plus sign before a positive number, so
that it always has a sign.  A space character as flag inserts a space
before a positive number.  (Otherwise, positive numbers start with the
first digit.)  These flags are useful for ensuring that positive
numbers and negative numbers use the same number of columns.  They are
ignored except for @samp{%d}, @samp{%e}, @samp{%f}, @samp{%g}, and if
both flags are used, @samp{+} takes precedence.

  The flag @samp{#} specifies an alternate form which depends on
the format in use.  For @samp{%o}, it ensures that the result begins
with a @samp{0}.  For @samp{%x} and @samp{%X}, it prefixes the result
with @samp{0x} or @samp{0X}.  For @samp{%e} and @samp{%f}, the
@samp{#} flag means include a decimal point even if the precision is
zero.  For @samp{%g}, it always includes a decimal point, and also
forces any trailing zeros after the decimal point to be left in place
where they would otherwise be removed.

  The flag @samp{0} ensures that the padding consists of @samp{0}
characters instead of spaces.  This flag is ignored for non-numerical
specification characters like @samp{%s}, @samp{%S} and @samp{%c}.
These specification characters accept the @samp{0} flag, but still pad
with @emph{spaces}.

  The flag @samp{-} causes any padding inserted by the width,
if specified, to be inserted on the right rather than the left.
If both @samp{-} and @samp{0} are present, the @samp{0} flag is
ignored.

@example
@group
(format "%06d is padded on the left with zeros" 123)
     @result{} "000123 is padded on the left with zeros"

(format "'%-6d' is padded on the right" 123)
     @result{} "'123   ' is padded on the right"

(format "The word '%-7s' actually has %d letters in it."
        "foo" (length "foo"))
     @result{} "The word 'foo    ' actually has 3 letters in it."
@end group
@end example

@cindex field width
@cindex padding
  A specification can have a @dfn{width}, which is a decimal number
that appears after any field number and flags.  If the printed
representation of the object contains fewer characters than this
width, @code{format} extends it with padding.  Any padding introduced by
the width normally consists of spaces inserted on the left:

@example
(format "%5d is padded on the left with spaces" 123)
     @result{} "  123 is padded on the left with spaces"
@end example

@noindent
If the width is too small, @code{format} does not truncate the
object's printed representation.  Thus, you can use a width to specify
a minimum spacing between columns with no risk of losing information.
In the following two examples, @samp{%7s} specifies a minimum width
of 7.  In the first case, the string inserted in place of @samp{%7s}
has only 3 letters, and needs 4 blank spaces as padding.  In the
second case, the string @code{"specification"} is 13 letters wide but
is not truncated.

@example
@group
(format "The word '%7s' has %d letters in it."
        "foo" (length "foo"))
     @result{} "The word '    foo' has 3 letters in it."
(format "The word '%7s' has %d letters in it."
        "specification" (length "specification"))
     @result{} "The word 'specification' has 13 letters in it."
@end group
@end example

@cindex precision in format specifications
  All the specification characters allow an optional @dfn{precision}
after the field number, flags and width, if present.  The precision is
a decimal-point @samp{.} followed by a digit-string.  For the
floating-point specifications (@samp{%e} and @samp{%f}), the
precision specifies how many digits following the decimal point to
show; if zero, the decimal-point itself is also omitted.  For
@samp{%g}, the precision specifies how many significant digits to show
(significant digits are the first digit before the decimal point and
all the digits after it).  If the precision of %g is zero or
unspecified, it is treated as 1.  For @samp{%s} and @samp{%S}, the
precision truncates the string to the given width, so @samp{%.3s}
shows only the first three characters of the representation for
@var{object}.  For other specification characters, the effect of
precision is what the local library functions of the @code{printf}
family produce.

@node Case Conversion
@section Case Conversion in Lisp
@cindex upper case
@cindex lower case
@cindex character case
@cindex case conversion in Lisp

  The character case functions change the case of single characters or
of the contents of strings.  The functions normally convert only
alphabetic characters (the letters @samp{A} through @samp{Z} and
@samp{a} through @samp{z}, as well as non-@acronym{ASCII} letters); other
characters are not altered.  You can specify a different case
conversion mapping by specifying a case table (@pxref{Case Tables}).

  These functions do not modify the strings that are passed to them as
arguments.

  The examples below use the characters @samp{X} and @samp{x} which have
@acronym{ASCII} codes 88 and 120 respectively.

@defun downcase string-or-char
This function converts @var{string-or-char}, which should be either a
character or a string, to lower case.

When @var{string-or-char} is a string, this function returns a new
string in which each letter in the argument that is upper case is
converted to lower case.  When @var{string-or-char} is a character,
this function returns the corresponding lower case character (an
integer); if the original character is lower case, or is not a letter,
the return value is equal to the original character.

@example
(downcase "The cat in the hat")
     @result{} "the cat in the hat"

(downcase ?X)
     @result{} 120
@end example
@end defun

@defun upcase string-or-char
This function converts @var{string-or-char}, which should be either a
character or a string, to upper case.

When @var{string-or-char} is a string, this function returns a new
string in which each letter in the argument that is lower case is
converted to upper case.  When @var{string-or-char} is a character,
this function returns the corresponding upper case character (an
integer); if the original character is upper case, or is not a letter,
the return value is equal to the original character.

@example
(upcase "The cat in the hat")
     @result{} "THE CAT IN THE HAT"

(upcase ?x)
     @result{} 88
@end example
@end defun

@defun capitalize string-or-char
@cindex capitalization
This function capitalizes strings or characters.  If
@var{string-or-char} is a string, the function returns a new string
whose contents are a copy of @var{string-or-char} in which each word
has been capitalized.  This means that the first character of each
word is converted to upper case, and the rest are converted to lower
case.

The definition of a word is any sequence of consecutive characters that
are assigned to the word constituent syntax class in the current syntax
table (@pxref{Syntax Class Table}).

When @var{string-or-char} is a character, this function does the same
thing as @code{upcase}.

@example
@group
(capitalize "The cat in the hat")
     @result{} "The Cat In The Hat"
@end group

@group
(capitalize "THE 77TH-HATTED CAT")
     @result{} "The 77th-Hatted Cat"
@end group

@group
(capitalize ?x)
     @result{} 88
@end group
@end example
@end defun

@defun upcase-initials string-or-char
If @var{string-or-char} is a string, this function capitalizes the
initials of the words in @var{string-or-char}, without altering any
letters other than the initials.  It returns a new string whose
contents are a copy of @var{string-or-char}, in which each word has
had its initial letter converted to upper case.

The definition of a word is any sequence of consecutive characters that
are assigned to the word constituent syntax class in the current syntax
table (@pxref{Syntax Class Table}).

When the argument to @code{upcase-initials} is a character,
@code{upcase-initials} has the same result as @code{upcase}.

@example
@group
(upcase-initials "The CAT in the hAt")
     @result{} "The CAT In The HAt"
@end group
@end example
@end defun

  Note that case conversion is not a one-to-one mapping of codepoints
and length of the result may differ from length of the argument.
Furthermore, because passing a character forces return type to be
a character, functions are unable to perform proper substitution and
result may differ compared to treating a one-character string.  For
example:

@ifnottex
@example
@group
(upcase "ﬁ")  ; note: single character, ligature "fi"
     @result{} "FI"
@end group
@group
(upcase ?ﬁ)
     @result{} 64257  ; i.e. ?ﬁ
@end group
@end example
@end ifnottex
@iftex
@example
@group
(upcase "@r{fi}")  ; note: single character, ligature "fi"
     @result{} "FI"
@end group
@group
(upcase ?@r{fi})
     @result{} 64257  ; i.e. ?@r{fi}
@end group
@end example
@end iftex

  To avoid this, a character must first be converted into a string,
using @code{string} function, before being passed to one of the casing
functions.  Of course, no assumptions on the length of the result may
be made.

  Mapping for such special cases are taken from
@code{special-uppercase}, @code{special-lowercase} and
@code{special-titlecase} @xref{Character Properties}.

  @xref{Text Comparison}, for functions that compare strings; some of
them ignore case differences, or can optionally ignore case differences.

@node Case Tables
@section The Case Table

  You can customize case conversion by installing a special @dfn{case
table}.  A case table specifies the mapping between upper case and lower
case letters.  It affects both the case conversion functions for Lisp
objects (see the previous section) and those that apply to text in the
buffer (@pxref{Case Changes}).  Each buffer has a case table; there is
also a standard case table which is used to initialize the case table
of new buffers.

  A case table is a char-table (@pxref{Char-Tables}) whose subtype is
@code{case-table}.  This char-table maps each character into the
corresponding lower case character.  It has three extra slots, which
hold related tables:

@table @var
@item upcase
The upcase table maps each character into the corresponding upper
case character.
@item canonicalize
The canonicalize table maps all of a set of case-related characters
into a particular member of that set.
@item equivalences
The equivalences table maps each one of a set of case-related characters
into the next character in that set.
@end table

  In simple cases, all you need to specify is the mapping to lower-case;
the three related tables will be calculated automatically from that one.

  For some languages, upper and lower case letters are not in one-to-one
correspondence.  There may be two different lower case letters with the
same upper case equivalent.  In these cases, you need to specify the
maps for both lower case and upper case.

  The extra table @var{canonicalize} maps each character to a canonical
equivalent; any two characters that are related by case-conversion have
the same canonical equivalent character.  For example, since @samp{a}
and @samp{A} are related by case-conversion, they should have the same
canonical equivalent character (which should be either @samp{a} for both
of them, or @samp{A} for both of them).

  The extra table @var{equivalences} is a map that cyclically permutes
each equivalence class (of characters with the same canonical
equivalent).  (For ordinary @acronym{ASCII}, this would map @samp{a} into
@samp{A} and @samp{A} into @samp{a}, and likewise for each set of
equivalent characters.)

  When constructing a case table, you can provide @code{nil} for
@var{canonicalize}; then Emacs fills in this slot from the lower case
and upper case mappings.  You can also provide @code{nil} for
@var{equivalences}; then Emacs fills in this slot from
@var{canonicalize}.  In a case table that is actually in use, those
components are non-@code{nil}.  Do not try to specify
@var{equivalences} without also specifying @var{canonicalize}.

  Here are the functions for working with case tables:

@defun case-table-p object
This predicate returns non-@code{nil} if @var{object} is a valid case
table.
@end defun

@defun set-standard-case-table table
This function makes @var{table} the standard case table, so that it will
be used in any buffers created subsequently.
@end defun

@defun standard-case-table
This returns the standard case table.
@end defun

@defun current-case-table
This function returns the current buffer's case table.
@end defun

@defun set-case-table table
This sets the current buffer's case table to @var{table}.
@end defun

@defmac with-case-table table body@dots{}
The @code{with-case-table} macro saves the current case table, makes
@var{table} the current case table, evaluates the @var{body} forms,
and finally restores the case table.  The return value is the value of
the last form in @var{body}.  The case table is restored even in case
of an abnormal exit via @code{throw} or error (@pxref{Nonlocal
Exits}).
@end defmac

  Some language environments modify the case conversions of
@acronym{ASCII} characters; for example, in the Turkish language
environment, the @acronym{ASCII} capital I is downcased into
a Turkish dotless i (@samp{ı}).  This can interfere with code that requires
ordinary @acronym{ASCII} case conversion, such as implementations of
@acronym{ASCII}-based network protocols.  In that case, use the
@code{with-case-table} macro with the variable @var{ascii-case-table},
which stores the unmodified case table for the @acronym{ASCII}
character set.

@defvar ascii-case-table
The case table for the @acronym{ASCII} character set.  This should not be
modified by any language environment settings.
@end defvar

  The following three functions are convenient subroutines for packages
that define non-@acronym{ASCII} character sets.  They modify the specified
case table @var{case-table}; they also modify the standard syntax table.
@xref{Syntax Tables}.  Normally you would use these functions to change
the standard case table.

@defun set-case-syntax-pair uc lc case-table
This function specifies a pair of corresponding letters, one upper case
and one lower case.
@end defun

@defun set-case-syntax-delims l r case-table
This function makes characters @var{l} and @var{r} a matching pair of
case-invariant delimiters.
@end defun

@defun set-case-syntax char syntax case-table
This function makes @var{char} case-invariant, with syntax
@var{syntax}.
@end defun

@deffn Command describe-buffer-case-table
This command displays a description of the contents of the current
buffer's case table.
@end deffn
