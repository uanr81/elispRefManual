@c -*- mode: texinfo; coding: utf-8 -*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1994, 1998-2019 Free Software Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Keymaps
@chapter Ключевые Карты
@cindex keymap

  Привязки команд входных событий записываются в структуры
данных, называемые @dfn{keymaps (ключевая карта)}.  Каждая
запись такой карты связывает (или @dfn{binds}) отдельный
тип события либо с другой картой, либо с командой.  Когда тип
события привязан к карте, эта карта используется для поиска
следующего события ввода; это продолжается до тех пор, пока
не будет найдена команда.  Весь процесс называется @dfn{key lookup (поиском ключа)}.

@menu
* Key Sequences::               Ключевые карты как объекты Lisp.
* Keymap Basics::               Основные понятия ключевой карты.
* Format of Keymaps::           Представление ключевой карты как объект Lisp.
* Creating Keymaps::            Функции для создания и копирования ключевых карт.
* Inheritance and Keymaps::     Как одна ключевая карта может наследовать привязки другой карты.
* Prefix Keys::                 Определение ключа с помощью ключевой карты в качестве его определения.
* Active Keymaps::              Как Emacs ищет в активных таблицах ключей привязку клавиш.
* Searching Keymaps::           Псевдо-Lisp-сводка поиска активных карт.
* Controlling Active Maps::     Каждый буфер имеет локальную карту ключей для переопределения стандартных (глобальных) привязок.  Второстепенный режим также может их отменять.
* Key Lookup::                  Нахождение привязки ключа в одной ключевой карте.
* Functions for Key Lookup::    Как запросить поиск ключа.
* Changing Key Bindings::       Переопределение ключа в ключевой карте.
* Remapping Commands::          Ключевая карта может переопределить одну команду в другую.
* Translation Keymaps::         Ключевые карты для перевода последовательностей событий.
* Key Binding Commands::        Интерактивные интерфейсы для переопределения ключей.
* Scanning Keymaps::            Сканирование ключевых карт, вывод справки.
* Menu Keymaps::                Определение меню как ключевой карты.
@end menu

@node Key Sequences
@section Ключевая Последовательнасть
@cindex key
@cindex keystroke
@cindex key sequence

  @dfn{Ключевая последовательность}, или для краткости
@dfn{ключ}, представляет собой последовательность из одного
или нескольких входных событий, образующих единое целое.
Входные события включают символы, функциональные клавиши,
действия мыши или системные события, внешние по отношению к
Emacs, такие как @code{iconify-frame} (@pxref{Input Events}).
Для Emacs Lisp представление ключевой последовательности -
это строка или вектор.  Если не указано иное, любая функция
Emacs Lisp, которая принимает ключевую последовательность в
качестве аргумента, может обрабатывать оба представления.

  В строковом представлении буквенно-цифровые символы обычно
обозначают сами себя; например, @code{"a"} представляет
@kbd{a}, а @code{"2"} представляет @kbd{2}.  Символы
управляющих событий имеют префикс подстроки @code{"\C-"}, а
метасимволы - @code{"\M-"}; например, @code{"\C-x"}
представляет собой ключ @kbd{\-x}.  Кроме того, события
@key{TAB}, @key{RET}, @key{ESC}, и @key{DEL} представлены
соответственно @code{"\t"}, @code{"\r"}, @code{"\e"} и
@code{"\d"}.  Строковое представление полной ключевой
последовательности - это конкатенация строковых представлений
составляющих событий; таким образом, @code{"\C-xl"}
представляет собой последовательность клавиш @kbd{C-x l}.

  Последовательности клавиш, содержащие функциональные
клавиши, события кнопок мыши, системные события или символы
не-@acronym{ASCII}, такие как @kbd{C-=} или @kbd{H-a}, не
могут быть представлены в виде строк; они должны быть
представлены в виде векторов.

  В векторном представлении каждый элемент вектора
представляет входное событие в его форме Lisp.
@xref{Input Events}.  Например, вектор @code{[?\C-x ?l]}
представляет собой последовательность клавиш @kbd{C-x l}.

  Примеры последовательностей клавиш, записанных в строковом
и векторном представлениях., @ref{Init Rebinding,,, emacs, Руководство GNU Emacs Manual}.

@defun kbd keyseq-text
Эта функция преобразует текст @var{keyseq-text} (строковую
константу) в ключевую последовательность (строковую или
векторную константу).  Содержимое @var{keyseq-text} должно
использовать тот же синтаксис, что и в буфере, вызываемом
командой @kbd{C-x C-k @key{RET}} (@code{kmacro-edit-macro});
в частности, имена функциональных клавиш должны быть
заключены в @samp{<@dots{}>}.  @xref{Edit Keyboard Macro,,, emacs, The GNU Emacs Manual}.

@example
(kbd "C-x") @result{} "\C-x"
(kbd "C-x C-f") @result{} "\C-x\C-f"
(kbd "C-x 4 C-f") @result{} "\C-x4\C-f"
(kbd "X") @result{} "X"
(kbd "RET") @result{} "\^M"
(kbd "C-c SPC") @result{} "\C-c@ "
(kbd "<f1> SPC") @result{} [f1 32]
(kbd "C-M-<down>") @result{} [C-M-down]
@end example
@end defun

@node Keymap Basics
@section Ключевые Карты Основы
@cindex key binding
@cindex binding of a key
@cindex complete key
@cindex undefined key

  Ключевая карта - это структура данных Lisp, которая
определяет @dfn{key bindings} для различных
последовательностей ключей.

  Единая ключевая карта напрямую определяет определения для
  отдельных событий.  Когда карта состоит из одного события,
  ее привязка ключа в карте является ее определением для
  этого события.  Связывание более длинной ключевой
  последовательности обнаруживается итеративным процессом:
  сначала находится определение первого события (которое само
  должно быть картой); затем ищется определение второго
  события в этой карте и так далее, пока все события
  ключевой последовательности карты не будут обработаны.

  Если привязка ключевой последовательности является ключевой
картой, эта последовательность ключей называется
@dfn{prefix key (префиксным ключем)}.  В противном случае это
называется @dfn{complete key (полный ключ)} (потому что к
нему нельзя добавлять больше событий).  Если привязка -
@code{nil}, ключ называется @dfn{undefined (неопределенным)}.
Примеры префиксных ключей: @kbd{C-c}, @kbd{C-x} и
@kbd{C-x 4}.  Примеры определенных полных ключей: @kbd{X},
@key{RET}, и @kbd{C-x 4 C-f}.  Примеры неопределенных полных
ключей: @kbd{C-x C-g} и @kbd{C-c 3}. @xref{Prefix Keys}, для
деталей.

  Правило поиска привязки ключевой последовательности
предполагает, что все промежуточные привязки (найденные для
событий перед последним) представляют собой ключевые карты;
если это не так, последовательность событий не образует
единое целое - на самом деле это не одна ключевая
последовательность.  Другими словами, удаление одного или
нескольких событий из конца любой допустимой
последовательности ключей всегда должно давать префиксный
ключ.  Например, @kbd{C-f C-n} не является ключевой
последовательностью; @kbd{C-f} не является префиксным ключом,
поэтому более длинная последовательность, начинающаяся с
@kbd{C-f}, не может быть ключевой последовательностью.

  Набор возможных ключевых последовательностей с несколькими
событиями зависит от привязки префиксных ключей;
следовательно, он может быть разным для разных ключевых карт
и может меняться при изменении привязок.  Однако
последовательность из одного события всегда является ключевой
последовательностью, потому что ее правильность не зависит
от каких-либо префиксных ключей.

  В любое время несколько первичных ключевых карт являются
@dfn{active (активными)} --- то есть используются для
поиска привязок ключей.  Это
@dfn{global map (глобальная карта)}, используется всеми
буферами; @dfn{local keymap (локальная ключевая карта)},
которая обычно связана с определенным основным режимом; и
ноль или более @dfn{minor mode keymaps} (ключевых карт
дополнительных режимов), которые относятся к текущим
включенным второстепенным режимам.  (Не все второстепенные
режимы имеют ключевые карты.)  Привязки локальной ключевой
затеняют (тоесть имеют приоритет) соответствующим глобальным
привязкам.  Ключевые карты вспомогательного режима затеняют
как локальные, так и глобальные ключевые карты.
@xref{Active Keymaps}, для деталей.

@node Format of Keymaps
@section Формат Ключевых Карт
@cindex format of keymaps
@cindex keymap format
@cindex full keymap
@cindex sparse keymap

  Каждая ключевая карта - это список, в котором @sc{car}
является символом @code{keymap}.  Остальные элементы списка
определяют ключевые привязки ключевой карты.  Символ, чьим
определением функции является ключевая карта, также является
ключевой картой.  Используйте функцию @code{keymapp} (см.
Ниже), чтобы проверить, является ли объект ключевой картой.

  После символа @code{keymap}, с которого она начинается, в
ключевой карте могут появиться несколько видов элементов:

@table @code
@item (@var{type} .@: @var{binding})
Это указывает одну привязку для событий типа @var{type}.
Каждая обычная привязка применяется к событиям определенного
@dfn{event type}, который всегда является символом или
символом.  @xref{Classifying Events}.  В этом виде привязки
@var{binding} - это команда.

@item (@var{type} @var{item-name} .@: @var{binding})
Это определяет привязку, которая также является простым
пунктом меню, который отображается в меню как
@var{item-name}.  @xref{Simple Menu Items}.

@item (@var{type} @var{item-name} @var{help-string} .@: @var{binding})
Это простой пункт меню со строкой справки @var{help-string}.

@item (@var{type} menu-item .@: @var{details})
Это указывает привязку, которая также является элементом
расширенного меню.  Это позволяет использовать другие
функции.  @xref{Extended Menu Items}.

@item (t .@: @var{binding})
@cindex default key binding
Это указывает @dfn{default key binding}; любому событию, не
связанному с другими элементами раскладки клавиатуры,
проводится @var{binding} в качестве привязки.  Привязки по
умолчанию позволяют ключевой карте связывать все возможные
типы событий без необходимости перечислять их все.  Ключевая
карта с привязкой по умолчанию полностью маскирует любую
ключевую карту с более низким приоритетом, за исключением
событий, явно привязанных к @code{nil} (см. Ниже).

@item @var{char-table}
Если элемент ключевой карты является символьной таблицей, он
считается удерживающим привязки для всех событий символов без
битов модификатора (@pxref{modifier bits}): элемент с
индексом @var{c} является привязкой для символа @var{c}.  Это
компактный способ записать множество привязок.  Ключевая
карта с такой символьной таблицей называется
@dfn{full keymap (полная ключевая карта)}.  Другие карты
называются @dfn{sparse keymaps (разреженные ключевые карты)}.

@item @var{vector}
Этот тип элементов похож на символьную таблицу: элемент с
индексом @var{c} является привязкой для символа @var{c}.
Поскольку диапазон символов, которые могут быть связаны таким
образом, ограничен размером вектора, а создание вектора
выделяет пространство для всех кодов символов от 0, этот
формат не следует использовать, за исключением создания
ключевых карт меню (@pxref{Menu Keymaps}), где сами привязки
не используются значение установленное в @code{t}.

@item @var{string}
@cindex keymap prompt string
@cindex overall prompt string
@cindex prompt string of keymap
Помимо элементов, которые задают ключевые привязки, ключевая
карта может иметь строку в качестве элемента.  Это называется
@dfn{overall prompt string (общая строка приглашения)} и
позволяет использовать ключевую карту в качестве меню.
@xref{Defining Menus}.

@item (keymap @dots{})
Если элемент ключевой карты сам по себе является ключевой
картой, он считается так, как если эта внутренняя карта была
встроена во внешнюю карту.  Это используется для
множественного наследования, например, в
@code{make-composed-keymap}.
@end table

Когда привязка - @code{nil}, она не является определением, но
имеет приоритет над привязкой по умолчанию или привязкой в
родительской ключевой карте.  С другой стороны, привязка
@code{nil} действительно @emph{not} переопределяет ключевых
карт с более низким приоритетом; таким образом, если
локальная карта дает привязку @code{nil}, Emacs использует
привязку из глобальной карты.

@cindex meta characters lookup
  Ключевые карты не записывают напрямую привязки для
метасимволов.  Вместо этого метасимволы рассматриваются в
целях поиска по ключу как последовательности из двух
символов, первый из которых - @key{ESC} (или любое другое
значение, которое в настоящее время является значением
@code{meta-prefix-char}).  Таким образом, ключ @kbd{M-a}
внутренне представлен как @kbd{@key{ESC} a}, а его глобальная
привязка находится в слоте для @kbd{a} в @code{esc-map}.
(@pxref{Prefix Keys}).

  Это преобразование применяется только к символам, а не к
функциональным клавишам или другим событиям ввода; таким
образом, @kbd{M-@key{end}} не имеет ничего общего с
@kbd{@key{ESC} @key{end}}.

  Вот как пример - локальная ключевая карта для режима Lisp,
разреженная ключевая карта.  Она определяет привязки для
@key{DEL}, @kbd{C-c C-z}, @kbd{C-M-q}, и @kbd{C-M-x}
(фактическое значение также содержит привязку меню, которая
здесь для краткости опущено).

@example
@group
lisp-mode-map
@result{}
@end group
@group
(keymap
 (3 keymap
    ;; @kbd{C-c C-z}
    (26 . run-lisp))
@end group
@group
 (27 keymap
     ;; @r{@kbd{C-M-x}, treated as @kbd{@key{ESC} C-x}}
     (24 . lisp-send-defun))
@end group
@group
 ;; @r{Эта часть унаследована от @code{lisp-mode-shared-map}.}
 keymap
 ;; @key{DEL}
 (127 . backward-delete-char-untabify)
@end group
@group
 (27 keymap
     ;; @r{@kbd{C-M-q}, рассматриваемый как @kbd{@key{ESC} C-q}}
     (17 . indent-sexp)))
@end group
@end example

@defun keymapp object
Эта функция возвращает @code{t}, если @var{object} - это
ключевая карта и @code{nil} в противном случае.  Точнее, эта
функция проверяет список, @sc{car} которого равен
@code{keymap} или символом, определение функции которого
удовлетворяет @code{keymapp}.

@example
@group
(keymapp '(keymap))
    @result{} t
@end group
@group
(fset 'foo '(keymap))
(keymapp 'foo)
    @result{} t
@end group
@group
(keymapp (current-global-map))
    @result{} t
@end group
@end example
@end defun

@node Creating Keymaps
@section Создание Ключевых Карт
@cindex creating keymaps

  Здесь описываются функции для создания ключевых карт.

@defun make-sparse-keymap &optional prompt
Эта функция создает и возвращает новую разреженную ключевую
карту без записей.  (Разреженная ключевая карта - это тип
ключевой карты, который обычно требуется.)  Новая ключевая
карта не содержит символ-таблицы, в отличие от
@code{make-keymap}, и не связывает никаких событий.

@example
@group
(make-sparse-keymap)
    @result{} (keymap)
@end group
@end example

Если указано @var{prompt}, это будет общей строкой
приглашения для ключевой карты.  Требуется указать это только
для ключевых карт меню (@pxref{Defining Menus}).  Ключевая
карта с общей строкой приглашения всегда будет представлять
меню мыши или меню клавиатуры, если она активна для поиска
следующего события ввода.  Не указывайте общую строку
приглашения для основной карты основного или второстепенного
режима, потому что это приведет к тому, что цикл команд будет
каждый раз отображать клавиатурное меню.
@end defun

@defun make-keymap &optional prompt
Эта функция создает и возвращает новую полную ключевую карту.
Эта карта содержит символ-таблицу (@pxref{Char-Tables}) со
слотами для всех символов без модификаторов.  Новая карта
изначально связывает все эти символы с @code{nil} и не
связывает никаких других событий.  Аргумент @var{prompt}
указывает строку приглашения, как и в
@code{make-sparse-keymap}.

@c Этот пример кажется бессмысленным, но я предполагаю, что
@c он служит для сравнения результата с make-sparse-keymap
@c описаной выше.
@example
@group
(make-keymap)
    @result{} (keymap #^[nil nil keymap nil nil nil @dots{}])
@end group
@end example

Полная ключевая карта более эффективна, чем разреженная,
когда содержит много привязок; иногда лучше использовать
разреженную ключевую карту.
@end defun

@defun copy-keymap keymap
Эта функция возвращает копию @var{keymap}.  В этом почти
никогда не бывает необходимости.  Если требуется карта,
схожая с другой, но с некоторыми изменениями, следует
использовать наследование карты, а не копирование.  То есть
что-то вроде:

@example
@group
(let ((map (make-sparse-keymap)))
  (set-keymap-parent map <theirmap>)
  (define-key map ...)
  ...)
@end group
@end example

При выполнении @code{copy-keymap} любые ключевые карты,
которые появляются непосредственно как привязки в
@var{keymap}, также рекурсивно копируются и так далее на
любое количество уровней.  Однако рекурсивное копирование не
происходит, если определение символа является символом,
определение функции которого является картой; тот же символ
появляется в новой копии.
@c Характерная черта для Emacs 19

@example
@group
(setq map (copy-keymap (current-local-map)))
@result{} (keymap
@end group
@group
     ;; @r{(Это реализует мета-символы.)}
     (27 keymap
         (83 . center-paragraph)
         (115 . center-line))
     (9 . tab-to-tab-stop))
@end group

@group
(eq map (current-local-map))
    @result{} nil
@end group
@group
(equal map (current-local-map))
    @result{} t
@end group
@end example
@end defun

@node Inheritance and Keymaps
@section Наследование и Ключевые Карты
@cindex keymap inheritance
@cindex inheritance, keymap

  Ключевая карта может наследовать привязки другой ключевой
карты, которая называется
@dfn{parent keymap (родительской ключевой картой)}.  Такая
ключевая карта выглядит так:

@example
(keymap @var{elements}@dots{} . @var{parent-keymap})
@end example

@noindent
Эффект состоит в том, что эта карта наследует все привязки
@var{parent-keymap} (родительской карты), какими бы они ни
были во время поиска ключа, но может добавлять к ним или
отменять их с помощью @var{elements}.

Если меняется привязка в @var{parent-keymap} с помощью
@code{define-key} или других функций привязки ключей, эти
измененные привязки будут видны в наследующей ключевой карте,
если только они не затенены привязками, сделанными
@var{elements}.  Обратное неверно: если используется
@code{define-key} для изменения привязок в наследующей
ключевой карте, эти изменения записываются в @var{elements},
но не влияют на @var{parent-keymap}.

Правильный способ создания ключевой карты с родительской -
использовать @code{set-keymap-parent}; если есть код, который
напрямую создает ключевую корту с родителем, пожалуйста,
преобразуйте программу, чтобы вместо этого использовать
@code{set-keymap-parent}.

@defun keymap-parent keymap
Это возвращает родительскую ключевую карту @var{keymap}.
Если @var{keymap} не имеет родителя, @code{keymap-parent}
возвращает @code{nil}.
@end defun

@defun set-keymap-parent keymap parent
Это устанавливает родительскую карту @var{parent} для карты
@var{keymap} и возвращает @var{parent}.  Если @var{parent}
равно @code{nil}, эта функция не устанавливает @var{keymap}
никакого родителя.

Если @var{keymap} имеет вложенные карты (привязки для
префиксных ключей), они также получают новые родительские
ключевые карты, которые отражают то, на что указывает
@var{parent} для этих префиксных ключей.
@end defun

   Вот пример, показывающий, как создать ключевую карту,
унаследованную от @code{text-mode-map}:

@example
(let ((map (make-sparse-keymap)))
  (set-keymap-parent map text-mode-map)
  map)
@end example

  У не разреженной карты тоже может быть родитель, но это не
очень полезно.  Неразрезанная карта всегда указывает что-то в
качестве привязки для каждого числового кода символа без
битов модификатора, даже если это @code{nil}, поэтому
привязки этих символов никогда не наследуются от родительской
карты.

@cindex keymap inheritance from multiple maps
  Иногда нужно создать ключевую карту, унаследованную от
более чем одной карты.  Для этого можно использовать функцию
@code{make-composed-keymap}.

@defun make-composed-keymap maps &optional parent
Эта функция возвращает новую ключевую карту, состоящую из
существующих карт @var{maps}, и необязательно наследующую от
родительской карты @var{parent}.  @var{maps} может быть одной
картой или списком из более чем одной.  При поиске ключа в
получившейся новой карте Emacs ищет по очереди в каждой из
@var{maps}, а затем в @var{parent}, останавливаясь на первом
совпадении.  Привязка @code{nil} в любой из @var{maps}
отменяет любую привязку в @var{parent}, но не отменяет
привязку не-@code{nil} в любой другой @var{maps}.
@end defun

@noindent Например, вот как Emacs устанавливает родителя
@code{help-mode-map}, так что он наследуется от
@code{button-buffer-map} и @code{special-mode-map}:

@example
(defvar help-mode-map
  (let ((map (make-sparse-keymap)))
    (set-keymap-parent map
      (make-composed-keymap button-buffer-map special-mode-map))
    ... map) ... )
@end example


@node Prefix Keys
@section Префиксные Ключи
@cindex prefix key

  @dfn{prefix key} - это последовательность ключей, привязкой
которой является ключевая карта.  Ключевая карта определяет,
что делать с последовательностями ключей, расширяющими
префиксный ключ.  Например, @kbd{C-x} - это префиксный ключ,
и он использует ключевую карту, которая также хранится в
переменной @code{ctl-x-map}.  Эта карта определяет привязки
для последовательностей ключей, начинающихся с @kbd{C-x}.

  Некоторые из стандартных префиксных ключей Emacs используют
ключевые карты, которые также находятся в переменных Lisp:

@itemize @bullet
@item
@vindex esc-map
@findex ESC-prefix
@code{esc-map} - это глобальная ключевая карта для
префиксного ключа @key{ESC}.  Таким образом, здесь можно
найти глобальные определения всех метасимволов.  Эта карта
также является определением функции @code{ESC-prefix}.

@item
@cindex @kbd{C-h}
@code{help-map} - это глобальная ключевая карта для
префиксного ключа @kbd{C-h}.

@item
@cindex @kbd{C-c}
@vindex mode-specific-map
@code{mode-specific-map} - это глобальная ключевая карта для
префиксного ключа @kbd{C-c}.  Эта карта на самом деле
является глобальной, а не зависящей от режима, но ее имя
предоставляет полезную информацию об @kbd{C-c} в выводе
@kbd{C-h b} (@code{display-bindings}), поскольку в основном
этот префиксный ключ используется для привязок, зависящих от
режима.

@item
@cindex @kbd{C-x}
@vindex ctl-x-map
@findex Control-X-prefix
@code{ctl-x-map} - это глобальная карта, используемая для
префиксного ключа @kbd{C-x}.  Эта карта находится через
функциональную ячейку символа @code{Control-X-prefix}.

@item
@cindex @kbd{C-x @key{RET}}
@vindex mule-keymap
@code{mule-keymap} - это глобальная карта, используемая для
префиксного ключа @kbd{C-x @key{RET}}.

@item
@cindex @kbd{C-x 4}
@vindex ctl-x-4-map
@code{ctl-x-4-map} - это глобальная карта, используемая для
префиксного ключа @kbd{C-x 4}.

@item
@cindex @kbd{C-x 5}
@vindex ctl-x-5-map
@code{ctl-x-5-map} - это глобальная карта, используемая для
префиксного ключа @kbd{C-x 5}.

@item
@cindex @kbd{C-x 6}
@vindex 2C-mode-map
@code{2C-mode-map} - это глобальная карта, используемая для
префиксного ключа @kbd{C-x 6}.

@item
@cindex @kbd{C-x v}
@vindex vc-prefix-map
@code{vc-prefix-map} - это глобальная карта, используемая для
префиксного ключа @kbd{C-x v}.

@item
@cindex @kbd{M-g}
@vindex goto-map
@code{goto-map} - это глобальная карта, используемая для
префиксного ключа @kbd{M-g}.

@item
@cindex @kbd{M-s}
@vindex search-map
@code{search-map} - это глобальная карта, используемая для
префиксного ключа @kbd{M-s}.

@item
@cindex @kbd{M-o}
@vindex facemenu-keymap
@code{facemenu-keymap} - это глобальная карта, используемая
для префиксного ключа @kbd{M-o}.

@item
Другие префиксные ключи Emacs - @kbd{C-x @@}, @kbd{C-x a i},
@kbd{C-x @key{ESC}} и @kbd{@key{ESC} @key{ESC}}.  Они
используют ключевые карты, у которых нет специальных имен.
@end itemize

  Привязка префиксного ключа к карте используется для поиска
события, следующего за префиксным ключом.  (Вместо этого это
может быть символ, определение функции которого является
ключевой картой.  Эффект тот же, но символ служит именем для
префиксного ключа).  Таким образом, привязка @kbd{C-x} - это
символ @code{Control-X-prefix}, функциональная ячейка
которого содержит ключевую карту для команд @kbd{C-x}.  (Та
же самая карта также является значением @code{ctl-x-map}.)

  Определения префиксных ключей могут отображаться в любой
активной ключевой карте.  Определения @kbd{C-c}, @kbd{C-x},
@kbd{C-h} и @key{ESC} как префиксных ключей появляются на
глобальной карте, поэтому эти префиксные ключи всегда
доступны.  Основной и второстепенный режимы могут
переопределить ключ как префикс, поместив определение
префиксного ключа для него в локальную карту или карту
второстепенного режима.  @xref{Active Keymaps}.

  Если ключ определен как префикс более чем в одной активной
карте, то его различные определения фактически объединяются:
сначала идут команды, определенные в ключевых картах
второстепенного режима, за ними следуют команды в определении
префикса локальной карты, а затем - команды из глобальной
карты.

  В следующем примере делается @kbd{C-p} префиксным ключом в
локальной таблице ключей таким образом, чтобы @kbd{C-p} был
идентичен @kbd{C-x}.  Тогда привязкой для @kbd{C-p C-f} будет
функция @code{find-file}, как и для @kbd{C-x C-f}.
Последовательность ключей @kbd{C-p 6} не найдена ни в одной
активной ключевой карте.

@example
@group
(use-local-map (make-sparse-keymap))
    @result{} nil
@end group
@group
(local-set-key "\C-p" ctl-x-map)
    @result{} nil
@end group
@group
(key-binding "\C-p\C-f")
    @result{} find-file
@end group

@group
(key-binding "\C-p6")
    @result{} nil
@end group
@end example

@defun define-prefix-command symbol &optional mapvar prompt
@cindex prefix command
@anchor{Definition of define-prefix-command}
Эта функция подготавливает @var{symbol} для использования в
качестве привязки префиксного ключа: она создает разреженную
ключевую карту и сохраняет ее как определение функции
@var{symbol}'s.  Последующее связывание ключевой
последовательности с @var{symbol} превратит эту ключевую
последовательность в префиксный ключ.  Возвращаемое значение
- @code{symbol}.

Эта функция также устанавливает @var{symbol} как переменную
со значением ключевой карты.  Но если @var{mapvar} равен
не-@code{nil}, вместо этого он устанавливает @var{mapvar} в
качестве переменной.

Если @var{prompt} равен не-@code{nil}, это становится общей
строкой приглашения для ключевой карты.  Строка подсказки
должна быть дана для раскладки меню (@pxref{Defining Menus}).
@end defun

@node Active Keymaps
@section Активные Ключевые Карты
@cindex active keymap

  Emacs содержит много ключевых карт, но в любой момент
только несколько карт являются активными @dfn{active}.  Когда
Emacs получает ввод пользователя, он переводит событие ввода
(@pxref{Translation Keymaps}) и ищет привязку ключа в
активных ключевых картах.

  Обычно активными ключевыми картами являются: (i) -
карта, заданная свойством @code{keymap}, (ii) - карта
задействованных второстепенных режимов, (iii) - локальная
карта текущего буфера и (iv) - глобальная карта, в указанном
порядке.  Emacs ищет каждую последовательность ключей ввода
во всех этих картах.

  Из этих обычных ключевых карт наивысший приоритет задается
с помощью свойства @code{keymap} text или overlay в точке,
если таковые имеются.  (Для события ввода мыши Emacs
использует позицию события вместо точки;
@iftex
подробности в следующем разделе.)
@end iftex
@ifnottex
@pxref{Searching Keymaps}.)
@end ifnottex

  Следующими по приоритету идут ключевые карты, заданные
включенными второстепенными режимами.
Эти карты, если они есть, задаются переменными
@code{emulation-mode-map-alists},
@code{minor-mode-overriding-map-alist} и
@code{minor-mode-map-alist}.  @xref{Controlling Active Maps}.

@cindex local keymap
  Следующим по приоритету идет локальная карта буфера
@dfn{local keymap}, содержащая привязки ключей, специфичных
для этого буфера.  В минибуфере также есть локальная ключевая
карта (@pxref{Intro to Minibuffers}).  Если в точке есть
текст @code{local-map} или свойство наложения, которое
определяет используемую локальную ключевую карту вместо
локальной ключевой карты по умолчанию.

@cindex major mode keymap
  Локальная ключевая карта обычно устанавливается основным режимом буфера, и
каждый буфер с таким же основным режимом использует одну и ту же локальную
карту.  Следовательно, если вызывается @code{local-set-key}
(@pxref{Key Binding Commands}) для изменения локальной карты в одном буфере,
это также влияет на локальные ключевые карты в других буферах с таким же
основным режимом.

@cindex global keymap
  Наконец, @dfn{global keymap} содержит привязки ключей, которые
определяются независимо от текущего буфера, например @kbd{C-f}.  Это
действует всегда и привязано к переменной @code{global-map}.

  Помимо вышеуказанных обычных привязок ключей, Emacs предоставляет
программам специальные способы сделать другие привязки активными.
Во-первых, переменная @code{overriding-local-map} указывает привязку ключей,
которая заменяет обычные активные привязки, за исключением глобальной
привязки ключей.  Во-вторых, локальная для терминала переменная
@code{overriding-terminal-local-map} указывает карту ключей, которая имеет
приоритет над @emph{всеми} другими картами ключей (включая
@code{overriding-local-map}); обычно это используется для
модальных/временных привязок ключей (функция @code{set-transient-map}
предоставляет для этого удобный интерфейс).  @xref{Controlling Active Maps},
для деталей.

  Активизация ключевой карты - не единственный способ её использования.
Карты также используются и другими способами, например, для перевода событий
в @code{read-key-sequence}.  @xref{Translation Keymaps}.

  @xref{Standard Keymaps}, для списка некоторых стандартных раскладок.

@defun current-active-maps &optional olp position
Это возвращает список активных ключевых карт, которые будут использоваться
циклом команд в текущих обстоятельствах для поиска последовательности
ключей.  Обычно игнорирует @code{overriding-local-map} и
@code{overriding-terminal-local-map}, но если @var{olp} равен не-@code{nil},
обращается на них внимание.  @var{position} может быть либо позицией
события, возвращаемой @code{event-start}, либо позицией буфера, и может
изменять привязку ключей, как описано для @code{key-binding}.
@end defun

@defun key-binding key &optional accept-defaults no-remap position
Эта функция возвращает привязку для @var{key} в соответствии с текущими
активными ключевыми картами.  Результатом будет @code{nil}, если @var{key}
не определен в ключевой карте.

Аргумент @var{accept-defaults} управляет проверкой привязок по умолчанию,
как в @code{lookup-key} (@pxref{Functions for Key Lookup}).

Когда команды переназначены (@pxref{Remapping Commands}), @code{key-binding}
обычно обрабатывает переназначения команд, чтобы вернуть переназначенную
команду, которая будет фактически выполнена.  Однако, если @var{no-remap}
установлено в не-@code{nil}, @code{key-binding} игнорирует переназначения и
возвращает привязку, прямо заданную для @var{key}.

Если @var{key} начинается с события мыши (возможно, после префиксного
события), карты, к которым следует обращаться, определяются на основе
положения события.  В противном случае они определяются на основе оценки
стоимимости.  Однако можно переопределить любой из них, указав
@var{position}.  Если @var{position} установлено в не-@code{nil}, это должна
быть позиция в буфере или позиция события, такая как значение
@code{event-start}.  Затем используемые карты определяются на основе
@var{position}.

Emacs сигнализирует об ошибке, если @var{key} не является строкой или
вектором.

@example
@group
(key-binding "\C-x\C-f")
    @result{} find-file
@end group
@end example
@end defun

@node Searching Keymaps
@section Поиск Активных Ключевых Карт
@cindex searching active keymaps for keys

Вот краткое изложение кода псевдо-Lisp, описывающий как Emacs ищет активные
ключевые карты:

@lisp
(or (if overriding-terminal-local-map
        (@var{find-in} overriding-terminal-local-map))
    (if overriding-local-map
        (@var{find-in} overriding-local-map)
      (or (@var{find-in} (get-char-property (point) 'keymap))
          (@var{find-in-any} emulation-mode-map-alists)
          (@var{find-in-any} minor-mode-overriding-map-alist)
          (@var{find-in-any} minor-mode-map-alist)
          (if (get-text-property (point) 'local-map)
              (@var{find-in} (get-char-property (point) 'local-map))
            (@var{find-in} (current-local-map)))))
    (@var{find-in} (current-global-map)))
@end lisp

@noindent
Здесь @var{find-in} и @var{find-in-any} - это псевдофункции, выполняющие
поиск по одной ключевой карте и по списку карт соответственно.  Обратите
внимание, что функция @code{set-transient-map} работает, устанавливая
@code{overriding-terminal-local-map} (@pxref{Controlling Active Maps}).

  В приведенном выше псевдокоде, если последовательность ключей начинается с
события мыши (@pxref{Mouse Events}), позиция этого события используется
вместо точки, а буфер события используется вместо текущего буфера.  В
частности, это влияет на поиск свойств @code{keymap} и @code{local-map}.
Если событие мыши происходит в строке, содержащей свойство @code{display},
@code{before-string} или @code{after-string} (@pxref{Special Properties}), и
строка имеет свойство не-@code{nil} для  @code{keymap} или @code{local-map},
которое переопределяет соответствующее свойство в тексте базового буфера
(т. е. Свойство, указанное в базовом тексте, игнорируется).

  Когда привязка ключа обнаружена в одной из активных ключевых карт, и эта
привязка является командой, поиск завершается - команда выполняется.
Однако, если привязка является символом со значением или строкой, Emacs
заменяет входные последовательности ключей значением переменной или строкой
и перезапускает поиск активных ключевых таблиц.  @xref{Key Lookup}.

  Наконец, найденную команду можно переназначить.
@xref{Remapping Commands}.

@node Controlling Active Maps
@section Управление Активными Ключевыми Картами
@cindex active keymap, controlling

@defvar global-map
Эта переменная содержит глобальную ключевую карту по умолчанию, которая
сопоставляет ввод с клавиатуры Emacs командам.  Глобальная карта ключей
обычно является этой картой.  Глобальная ключевая карта по умолчанию - это
полная карта, которая связывает @code{self-insert-command} со всеми
печатными символами.

Изменение привязки в глобальной ключевой карте является нормальной
практикой, но не нужно присваивать этой переменной какое-либо значение,
кроме ключевой карты, с которой всё начинается.
@end defvar

@defun current-global-map
Эта функция возвращает текущую глобальную ключевую карту.  Это то же самое,
что и значение @code{global-map}, если не изменено одно или другое.
Возвращаемое значение является ссылкой, а не копией; если используется
@code{define-key} или другие функции, изменяются глобальные привязки.

@example
@group
(current-global-map)
@result{} (keymap [set-mark-command beginning-of-line @dots{}
            delete-backward-char])
@end group
@end example
@end defun

@defun current-local-map
Эта функция возвращает локальную ключевую карту текущего буфера или
@code{nil}, если ее нет.  В следующем примере карта ключей для буфера
@file{*scratch*} (с использованием режима взаимодействия с Lisp)
представляет собой разреженную карту ключей, в которой запись для @key{ESC},
код 27 @acronym{ASCII}, является еще одной разреженной ключевой картой.

@example
@group
(current-local-map)
@result{} (keymap
    (10 . eval-print-last-sexp)
    (9 . lisp-indent-line)
    (127 . backward-delete-char-untabify)
@end group
@group
    (27 keymap
        (24 . eval-defun)
        (17 . indent-sexp)))
@end group
@end example
@end defun

@code{current-local-map} возвращает ссылку на локальную ключевую карту, а не
ее копию; если используется @code{define-key} или другие функции, изменяются
локальные привязки.

@defun current-minor-mode-maps
Эта функция возвращает список ключевых карт включенных в данный момент
второстепенными режимами.
@end defun

@defun use-global-map keymap
Эта функция делает @var{keymap} новой текущей глобальной картой.  Возвращает
@code{nil}.

Очень необычно менять глобальную ключевую карту.
@end defun

@defun use-local-map keymap
Эта функция делает @var{keymap} новой локальной ключевой картой текущего
буфера.  Если @var{keymap} установлено в @code{nil}, то в буфере нет
локальной ключевой карты.  @code{use-local-map} возвращает @code{nil}.
Большинство команд основного режима используют эту функцию.
@end defun

@defvar minor-mode-map-alist
@anchor{Definition of minor-mode-map-alist}
Эта переменная представляет собой список, описывающий карты ключей, которые
могут быть или не быть активными в соответствии со значениями определенных
переменных.  Его элементы выглядят так:

@example
(@var{variable} . @var{keymap})
@end example

Карта @var{keymap} активна всякий раз, когда @var{variable} имеет значение
не-@code{nil}.  Обычно @var{variable} - это переменная, которая включает или
отключает второстепенный режим.  @xref{Keymaps and Minor Modes}.

Обратите внимание, что элементы @code{minor-mode-map-alist} не имеют такой
же структуры, как элементы @code{minor-mode-alist}.  Карта должна быть
@sc{cdr} элемента; список с картой в качестве второго элемента не годится.
@sc{cdr} может быть ключевой картой (списком) или символом, с ячейкой
функции определением которой - ключевая карта.

Когда активна более чем одна карта ключей вспомогательного режима, более
ранняя в @code{minor-mode-map-alist} имеет приоритет.  Требуется разработать
второстепенные режимы так, чтобы они не мешали друг другу.  Если сделано это
правильно, порядок не будет иметь значения.

Смотреть @ref{Keymaps and Minor Modes}, для получения дополнительной
информации о второстепенных режимах.  See also @code{minor-mode-key-binding} (@pxref{Functions for Key Lookup}).
@end defvar

@defvar minor-mode-overriding-map-alist
Эта переменная позволяет основным режимам отменять привязки ключей для
определенных второстепенных режимов.  Элементы этого списка выглядят как
элементы @code{minor-mode-map-alist}:
@code{(@var{variable} . @var{keymap})}.

Если переменная появляется как элемент
@code{minor-mode-overriding-map-alist}, карта, указанная этим элементом,
полностью заменяет любую карту, указанную для той же переменной в
@code{minor-mode-map-alist}.

@code{minor-mode-overriding-map-alist} автоматически является локальным для
всех буферов.
@end defvar

@defvar overriding-local-map
Если установлена в не-@code{nil}, эта переменная содержит ключевую карту для
использования вместо локальной ключевой карты буфера, любого текстового
свойства или ключевой карты, а также любых карт вспомогательного режима.
Эта карта, если указана, отменяет все другие карты, которые были активными,
кроме текущей глобальной карты.
@end defvar

@defvar overriding-terminal-local-map
Если non-@code{nil}, эта переменная содержит ключевую карту для
использования вместо @code{overriding-local-map}, локальных карт ключей
буфера, текстовых свойств или налаживающихся ключевых карт, а также все
карты вспомогательного режима.

Эта переменная всегда является локальной для текущего терминала и не может
быть локальной для буфера.  @xref{Multiple Terminals}.  Она используется для
реализации режима инкрементного поиска.
@end defvar

@defvar overriding-local-map-menu-flag
Если эта переменная - не-@code{nil}, значение @code{overriding-local-map}
или @code{overriding-terminal-local-map} может повлиять на отображение строк
и меню.  Значение по умолчанию - @code{nil}, поэтому эти переменные карт
не влияют на строку меню.

Обратите внимание, что эти две переменные карт действительно влияют на
выполнение последовательностей ключей, вводимых с помощью строки меню, даже
если они не влияют на отображение строки меню.  Поэтому, если появляется
последовательность ключей в строке меню, требуется очистить переменные,
прежде чем искать и выполнять эту последовательность ключей.  Режимы, в
которых используются переменные, обычно делают это в любом случае; обычно
реагируют на события, которые не обрабатывают, путем не чтения ``unreading''
их и выхода.
@end defvar

@defvar special-event-map
Эта переменная содержит ключевую карту для особых событий.  Если тип события
имеет привязку в этой карте, то оно особенно, и привязка для события
запускается непосредственно @code{read-event}.  @xref{Special Events}.
@end defvar

@defvar emulation-mode-map-alists
Эта переменная содержит список списков раскладок для использования в режимах
эмуляции.  Она предназначен для режимов или пакетов, использующих несколько
карт вспомогательных режимов.  Каждый элемент представляет собой список
ключевой карты, который имеет тот же формат и значение, что и
@code{minor-mode-map-alist}, или символ с привязкой переменных, который
является таким списком.  Активные карты ключей в каждом списке используются
перед @code{minor-mode-map-alist} и @code{minor-mode-overriding-map-alist}.
@end defvar

@cindex transient keymap
@defun set-transient-map keymap &optional keep-pred on-exit
Эта функция добавляет @var{keymap} в качестве ключевой карты
@dfn{transient}, которая имеет приоритет над другими картами для одного (или
нескольких) последующих ключей.

Обычно @var{keymap} используется только один раз, чтобы найти следующий
ключ.  Если необязательный аргумент @var{keep-pred} - @code{t}, карта
остается активной, пока пользователь вводит ключи, определенные в
@var{keymap}; когда пользователь вводит ключ, которого нет в @var{keymap},
временная карта ключей деактивируется и для этого ключа продолжается обычный
поиск ключа.

Аргумент @var{keep-pred} также может быть функцией.  В этом случае функция
вызывается без аргументов перед запуском каждой команды, пока @var{keymap}
активен; это должно вернуть не-@code{nil}, в случае если @var{keymap}
остаётся в активном состоянии.

Необязательный аргумент @var{on-exit}, если не-@code{nil}, указывает
функцию, которая вызывается без аргументов после деактивации @var{keymap}.

Эта функция работает, добавляя и удаляя @var{keymap} из переменной
@code{overriding-terminal-local-map}, которая имеет приоритет над всеми
другими активными раскладками (@pxref{Searching Keymaps}).
@end defun

@node Key Lookup
@section Ключевой Поиск
@cindex key lookup
@cindex keymap entry

  @dfn{Key lookup (Key lookup)} - это процесс поиска привязки ключевой
последовательности из заданной ключевой карты.  Выполнение или использование
привязки не является частью поиска ключа.

  Поиск ключа использует только тип события каждого события в
последовательности ключей; остальная часть события игнорируется.
Фактически, последовательность ключей, используемая для поиска ключа, может
обозначать событие мыши только с его типами (символ) вместо всего события
(список).  @xref{Input Events}.  Такой последовательности ключей
недостаточно для запуска @code{command-execute}, но ее достаточно для поиска
или повторной привязки ключа.

  Когда последовательность ключей состоит из нескольких событий, поиск
ключей обрабатывает события последовательно: обнаруживается привязка первого
события, и оно должно быть картой ключей; затем в этой карте будет найдена
привязка второго события, и так до тех пор, пока не будут израсходованы все
события в последовательности ключей.  (Обнаруженная таким образом привязка
для последнего события может быть, а может и не быть ключевой картой). Таким
образом, процесс поиска ключа определяется в терминах более простого
процесса поиска одного события в карте ключей.  Как это делается, зависит от
типа объекта, связанного с событием в этой карте.

  Давайте использовать термин @dfn{keymap entry} для описания значения,
найденного при поиске типа события в карте ключей.  (Это не включает строку
элемента и другие дополнительные элементы в элементе ключевой карты для
пункта меню, потому что @code{lookup-key} и другие функции поиска ключей не
включают их в возвращаемое значение).  Хотя любой объект Lisp может
храниться в ключевой карте как запись ключевой карты, не все имеют смысл для
поиска ключа.  Вот таблица значимых типов записей ключевой карты:

@table @asis
@item @code{nil}
@cindex @code{nil} in keymap
@code{nil} означает, что события, использованные до сих пор в поиске,
образуют неопределенный ключ.  Когда в ключевой карте вообще не упоминается
тип события и нет привязки по умолчанию, это эквивалентно привязке
@code{nil} для этого типа события.

@item @var{command}
@cindex command in keymap
События, используемые до сих пор в поиске, образуют полный ключ, а
@var{command} является его привязкой.  @xref{What Is a Function}.

@item @var{array}
@cindex string in keymap
Массив (строка или вектор) - это макрос клавиатуры.  События, использованные
до сих пор в поиске, образуют полный ключ, а массив является его привязкой.
Смотреть @ref{Keyboard Macros}, для детальной информации.

@item @var{keymap}
@cindex keymap in keymap
События, использованные до сих пор в поиске, образуют префиксный ключ.
Следующее событие ключевой последовательности ищется в @var{keymap}.

@item @var{list}
@cindex list in keymap
Значение списка зависит от того, что он содержит:

@itemize @bullet
@item
Если @sc{car} для @var{list} является символом @code{keymap}, то список
является ключевой картой и рассматривается как карта (см. выше).

@item
@cindex @code{lambda} in keymap
Если @sc{car} для @var{list} - @code{lambda}, то список является
лямбда-выражением.  Предполагается, что это функция, и она рассматривается
как таковая (см. выше).  Чтобы правильно выполнять ключевую привязку, эта
функция должна быть командой - она должна иметь спецификацию
@code{interactive}.  @xref{Defining Commands}.
@end itemize

@item @var{symbol}
@cindex symbol in keymap
Определение функции @var{symbol} используется вместо @var{symbol}.  Если это
тоже символ, то этот процесс повторяется любое количество раз.  В конечном
итоге это должно привести к объекту, который является ключевой картой,
командой или макросом клавиатуры.

Обратите внимание, что ключевая карта и макросы клавиатуры (строки и
векторы) не являются допустимыми функциями, поэтому символ с картой, строкой
или вектором в качестве определения функции недействителен как функция.
Однако он действителен как привязка ключа.  Если определение является
клавиатурным макросом, то символ также действителен как аргумент для
@code{command-execute} (@pxref{Interactive Call}).

@cindex @code{undefined} in keymap
Особого упоминания заслуживает символ @code{undefined}: он означает, что
ключ считается неопределенным.  Строго говоря, ключ определен, а его
привязка - это команда @code{undefined}; но эта команда делает то же самое,
что автоматически делается для неопределенного ключа: она вызывает сигнал
колокольчик (вызывая @code{ding}), но не сигнализирует об ошибке.

@cindex preventing prefix key
@code{undefined} используется в локальных катах ключей, чтобы переопределить
привязку глобального ключа и сделать ключ неопределенным локально.
Локальная привязка @code{nil} не сможет этого сделать, потому что она не
переопределит глобальную привязку.

@item @var{anything else}
Если обнаружен какой-либо другой тип объекта, события, использованные до
сих пор в поиске, образуют полный ключ, а объект является его привязкой, но
привязка не может быть выполнена как команда.
@end table

  Короче говоря, запись ключевой карты может быть картой, командой, макросом
клавиатуры, символом, который ведет к одному из них, или @code{nil}.

@node Functions for Key Lookup
@section Функции Поиска Ключей

  Вот функции и переменные, относящиеся к поиску ключей.

@defun lookup-key keymap key &optional accept-defaults
Эта функция возвращает определение @var{key} в @var{keymap}.  Все другие
функции, описанные в этой главе, которые используют ключи поиска, используют
@code{lookup-key}.  Вот примеры:

@example
@group
(lookup-key (current-global-map) "\C-x\C-f")
    @result{} find-file
@end group
@group
(lookup-key (current-global-map) (kbd "C-x C-f"))
    @result{} find-file
@end group
@group
(lookup-key (current-global-map) "\C-x\C-f12345")
    @result{} 2
@end group
@end example

Если строка или вектор @var{key} не является допустимой последовательностью
ключей в соответствии с префиксными ключами, указанными в @var{keymap}, она
должна быть слишком длинной и иметь дополнительные события в конце, которые
не помещаются в одну последовательность ключей.  Тогда значение - это число,
количество событий перед @var{key}, которые составляют полный ключ.

@c Emacs 19 feature
Если @var{accept-defaults} равен не-@code{nil}, то @code{lookup-key}
учитывает привязки по умолчанию, а также привязки для определенных событий в
@var{key}.  В противном случае @code{lookup-key} сообщает только привязки
для конкретной последовательности @var{key}, игнорируя привязки по
умолчанию, кроме случаев, когда вы явно спрашиваете о них. (Для этого
поставьте @code{t} как элемент @var{key}; see @ref{Format of Keymaps}.)

Если @var{key} содержит метасимвол (не функциональную клавишу), этот символ
неявно заменяется двухсимвольной последовательностью: значением
@code{meta-prefix-char}, за которым следует соответствующий немета-символ.
Таким образом, первый пример ниже обрабатывается путем преобразования во
второй пример.

@example
@group
(lookup-key (current-global-map) "\M-f")
    @result{} forward-word
@end group
@group
(lookup-key (current-global-map) "\ef")
    @result{} forward-word
@end group
@end example

В отличие от @code{read-key-sequence}, эта функция не изменяет указанные
события способами, которые отбрасывают информацию
(@pxref{Key Sequence Input}).  В частности, он не преобразует буквы в нижний
регистр и не изменяет события перетаскивания на щелчки.
@end defun

@deffn Command undefined
Используется в картах для отмены определения ключей.  Вызывает @code{ding},
но не вызывает ошибки.
@end deffn

@defun local-key-binding key &optional accept-defaults
Эта функция возвращает привязку для @var{key} в текущей локальной карте
ключей или @code{nil}, если она там не определена.

@c Emacs 19 feature
Аргумент @var{accept-defaults} управляет проверкой привязок по умолчанию,
как в @code{lookup-key} (выше).
@end defun

@defun global-key-binding key &optional accept-defaults
Эта функция возвращает привязку для команды @var{key} в текущей глобальной
карте ключей или @code{nil}, если она там не определена.

@c Emacs 19 feature
Аргумент @var{accept-defaults} управляет проверкой привязок по умолчанию,
как в @code{lookup-key} (выше).
@end defun

@c Emacs 19 feature
@defun minor-mode-key-binding key &optional accept-defaults
Эта функция возвращает список всех активных привязок второстепенного режима
@var{key}.  Точнее, возвращает список пар
@code{(@var{modename} . @var{binding})}, где @var{modename} - это
переменная, которая включает второстепенный режим, а @var{binding} -
привязка @var{key} в этом режиме.  Если @var{key} не имеет привязок
второстепенного режима, значение будет @code{nil}..

Если первая найденная привязка не является определением префикса (карта
ключей или символ, определенный как ключевая карта), все последующие
привязки из других второстепенных режимов опускаются, поскольку они будут
полностью затенены.  Точно так же в списке отсутствуют привязки без
префикса, следующие за привязками префикса.

Аргумент @var{accept-defaults} управляет проверкой привязок по умолчанию,
как в @code{lookup-key} (выше).
@end defun

@defopt meta-prefix-char
@cindex @key{ESC}
Эта переменная представляет собой код символа мета-префикса.  Используется
для преобразования метасимвола в двухсимвольную последовательность, чтобы
его можно было найти в карте ключей.  Для получения полезных результатов
значение должно быть префиксом события (@pxref{Prefix Keys}).  Значение по
умолчанию - 27, это код @acronym{ASCII} для @key{ESC}.

Пока значение @code{meta-prefix-char} остается равным 27, поиск по ключу
преобразует @kbd{M-b} в @kbd{@key{ESC} b}, который обычно определяется как
команда @code{backward-word}.  Однако, если уставливается для
@code{meta-prefix-char} значение 24, код для @kbd{C-x}, то Emacs переведет
@kbd{M-b} в @kbd{C-x b}, стандартной привязкой которого является команда
@code{switch-to-buffer}.  (На самом деле не делайте этого!) Вот иллюстрация
того, что произойдет:

@smallexample
@group
meta-prefix-char                    ; @r{Значение по умолчанию.}
     @result{} 27
@end group
@group
(key-binding "\M-b")
     @result{} backward-word
@end group
@group
?\C-x                               ; @r{Печатное представление}
     @result{} 24                          ;   @r{символа.}
@end group
@group
(setq meta-prefix-char 24)
     @result{} 24
@end group
@group
(key-binding "\M-b")
     @result{} switch-to-buffer            ; @r{Теперь ввод @kbd{M-b} }
                                    ;   @r{похож на ввод @kbd{C-x b}.}

(setq meta-prefix-char 27)          ; @r{Избежать путаницы!}
     @result{} 27                  ; @r{Восстановить значение по умолчанию!}
@end group
@end smallexample

Такое преобразование одного события в два происходит только для сиволов, а
не для других типов событий ввода.  Таким образом, @kbd{M-@key{F1}},
функциональный ключ, не преобразуется в @kbd{@key{ESC} @key{F1}}.
@end defopt

@node Changing Key Bindings
@section Изменение Привязки Ключей
@cindex changing key bindings
@cindex rebinding

  Способ перепривязки ключей - изменить ее запись в ключевой карте.  Если 
изменяется привязка в глобальной ключевой карте, изменение будет действовать
во всех буферах (хотя оно не имеет прямого эффекта в буферах, которые
затеняют глобальную привязку локальной).  Если изменяется локальная карта
текущего буфера, это обычно влияет на все буферы, использующие один и тот же
основной режим.  Функции @code{global-set-key} и @code{local-set-key}
являются удобными интерфейсами для этих операций
(@pxref{Key Binding Commands}).  Также можно использовать @code{define-key},
более общую функцию; только потребуется явно указать карту, которую нужно
изменить.

  При выборе последовательностей ключей для повторной привязки программ
  Lisp, лучше, придерживаться соглашениям Emacs по использованию различных
  ключей (@pxref{Key Binding Conventions}).

@cindex meta character key constants
@cindex control character key constants
  При написании ключевой последовательности для повторной привязки хорошо
использовать специальные escape-последовательности для управляющих и
метасимволов (@pxref{String Type}).
Синтаксис @samp{\C-} означает, что следующий символ является управляющим, а @samp{\M-} означает, что следующий символ является метасимволом. Таким образом, строка @code{"\M-x"} читается как содержащая единственный @kbd{M-x}, @code{"\C-f"}, читается как содержащая единственный @kbd{C-f}, и
@code{"\M-\C-x"}, а @code{"\C-\M-x"} читается как содержащая единственный
@kbd{C-M-x}.  Также можно использовать этот escape-синтаксис в векторах, а
также там, где не разрешено в строках; один пример -
@samp{[?\C-\H-x home]}.  @xref{Character Type}.

  Функции определения ключа и поиска принимают альтернативный синтаксис для
типов событий в последовательности ключей, которая является вектором: можно
использовать список, содержащий имена модификаторов плюс одно базовое
событие (имя символа или функционального ключа).  Например,
@code{(control ?a)} эквивалентно @code{?\C-a}, а @code{(hyper control left)}
эквивалентно @code{C-H-left}.  Одним из преимуществ таких списков является
то, что точные числовые коды для битов модификатора не отображаются в
скомпилированных файлах.

  Приведенные ниже функции сигнализируют об ошибке, если @var{keymap} не
является ключевой картой или если @var{key} не является строкой или
вектором, представляющим ключевую последовательность.  Можно использовать
типы событий (символы) как сокращение для событий, которые являются
списками.  @code{kbd} функция (@pxref{Key Sequences}) - удобный способ
указать ключевую последовательность.

@defun define-key keymap key binding
Эта функция устанавливает привязку для @var{key} в @var{keymap}.  (Если
@var{key} имеет длину более одного события, изменение фактически выполняется
в другой ключевой карте, полученной из @var{keymap}).  Аргумент
@var{binding} может быть любым объектом Lisp, но только определенные типы
имеют смысл.  (Список значимых типов смотри в @ref{Key Lookup}).  Значение,
возвращаемое @code{define-key}, - @var{binding}.

Если @var{key} - @code{[t]}, это устанавливает привязку по умолчанию в
@var{keymap}.  Когда событие не имеет собственной привязки, командный цикл
Emacs использует привязку по умолчанию для карты ключей, если таковая
имеется.

@cindex invalid prefix key error
@cindex key sequence error
Каждый префикс @var{key} должен быть префиксным ключом (т. е. привязанным к
ключевой карте) или быть неопределенным; в противном случае сигнализируется
ошибка.  Если какой-то префиксный @var{key} не определен, то
@code{define-key} определяет его как префиксный ключ, так что остальная
часть @var{key} может быть определена как указано.

Если ранее в @var{keymap} не было привязки для @var{key}, новая привязка
добавляется в начало @var{keymap}.  Порядок привязок в ключевой карте не
имеет значения для ключевой карты, но имеет значение для карт меню
(@pxref{Menu Keymaps}).
@end defun

  В этом примере создается разреженная ключевая карта и выполняется
  ряд привязок к ней:

@smallexample
@group
(setq map (make-sparse-keymap))
    @result{} (keymap)
@end group
@group
(define-key map "\C-f" 'forward-char)
    @result{} forward-char
@end group
@group
map
    @result{} (keymap (6 . forward-char))
@end group

@group
;;@r{Создайте разреженную подкарту для @kbd{C-x} и привяжите к ней @kbd{f}.}
(define-key map (kbd "C-x f") 'forward-word)
    @result{} forward-word
@end group
@group
map
@result{} (keymap
    (24 keymap                ; @kbd{C-x}
        (102 . forward-word)) ;      @kbd{f}
    (6 . forward-char))       ; @kbd{C-f}
@end group

@group
;; @r{Привязать @kbd{C-p} к @code{ctl-x-map}}.
(define-key map (kbd "C-p") ctl-x-map)
;; @code{ctl-x-map}
@result{} [nil @dots{} find-file @dots{} backward-kill-sentence]
@end group

@group
;; @r{Привязать @kbd{C-f} к @code{foo} в @code{ctl-x-map}.}
(define-key map (kbd "C-p C-f") 'foo)
@result{} 'foo
@end group
@group
map
@result{} (keymap  ; @r{Обратите внимание на @code{foo} в @code{ctl-x-map}.}
    (16 keymap [nil @dots{} foo @dots{} backward-kill-sentence])
    (24 keymap
        (102 . forward-word))
    (6 . forward-char))
@end group
@end smallexample

@noindent
Обратите внимание, что сохранение новой привязки для @kbd{C-p C-f} на самом
деле работает путем изменения записи в @code{ctl-x-map}, и это имеет эффект
изменения привязок как @kbd{C-p C-f}, так и @kbd{C-x C-f} на глобальной
карте по умолчанию.

  Функция @code{substitute-key-definition} сканирует ключевую карту на
предмет ключей с определенной привязкой и повторно связывает их с другой
привязкой.  Еще одна функция, более понятная и часто приводящая к тем же
результатам, - переназначение одной команды на другую
(@pxref{Remapping Commands}).

@defun substitute-key-definition olddef newdef keymap &optional oldmap
@cindex replace bindings
Эта функция заменяет @var{olddef} на @var{newdef} для любых ключей в
@var{keymap}, которые были привязаны к @var{olddef}.  Другими словами,
@var{olddef} заменяется на @var{newdef} везде, где это появляется.  Функция
возвращает @code{nil}.

Например, это переопределяет @kbd{C-x C-f}, если вы делаете это в Emacs со
стандартными привязками:

@smallexample
@group
(substitute-key-definition
 'find-file 'find-file-read-only (current-global-map))
@end group
@end smallexample

@c Emacs 19 feature
Если @var{oldmap} равен не-@code{nil}, это меняет поведение
@code{substitute-key-definition}: привязки в @var{oldmap} определяют, какие
ключи нужно повторно привязать.  Повторные привязки по-прежнему происходят
в @var{keymap}, а не в @var{oldmap}.  Таким образом, можно изменять одну
карту под управлением привязок в другой.  Например,

@smallexample
(substitute-key-definition
  'delete-backward-char 'my-funny-delete
  my-map global-map)
@end smallexample

@noindent
помещает специальную команду удаления в @code{my-map} для тех ключей,
которые глобально привязаны к стандартной команде удаления.

Вот пример, показывающий ключевую карту до и после замены:

@smallexample
@group
(setq map '(keymap
            (?1 . olddef-1)
            (?2 . olddef-2)
            (?3 . olddef-1)))
@result{} (keymap (49 . olddef-1) (50 . olddef-2) (51 . olddef-1))
@end group

@group
(substitute-key-definition 'olddef-1 'newdef map)
@result{} nil
@end group
@group
map
@result{} (keymap (49 . newdef) (50 . olddef-2) (51 . newdef))
@end group
@end smallexample
@end defun

@defun suppress-keymap keymap &optional nodigits
@cindex @code{self-insert-command} override
Эта функция изменяет содержимое полной ключевой карты @var{keymap} путем
переназначения @code{self-insert-command} на команду @code{undefined}
(@pxref{Remapping Commands}).  Это приводит к отмене определения всех
печатных символов, что делает невозможным обычную вставку текста.
@code{suppress-keymap} возвращает @code{nil}.

Если @var{nodigits} равен @code{nil}, тогда @code{suppress-keymap}
определяет цифры для запуска @code{digit-argument}, а @kbd{-} - для
@code{negative-argument}.  В противном случае он делает их неопределенными,
как и остальные печатные символы.

@cindex yank suppression
@cindex @code{quoted-insert} suppression
Функция @code{suppress-keymap} не делает невозможным изменение буфера, так
как не подавляет такие команды, как @code{yank} и @code{quoted-insert}.
Чтобы предотвратить любую модификацию буфера, сделайте его доступным только
для чтения (@pxref{Read Only Buffers}).

Поскольку эта функция изменяет @var{keymap}, обычно используют ее для вновь
созданной ключевой карты.  Работа с существующей ключевой картой, которая
используется для других целей, может вызвать проблемы; например, подавление
@code{global-map} сделало бы невозможным в большинстве использование Emacs.

Эта функция может использоваться для инициализации локальной ключевой карты
основного режима, для которого вставка текста нежелательна.  Но обычно такой
режим должен быть производным от @code{special-mode}
(@pxref{Basic Major Modes}); тогда его карта будет автоматически
унаследована от @code{special-mode-map}, который уже подавлен.  Вот как
определяется @code{special-mode-map}:

@smallexample
@group
(defvar special-mode-map
  (let ((map (make-sparse-keymap)))
    (suppress-keymap map)
    (define-key map "q" 'quit-window)
    @dots{}
    map))
@end group
@end smallexample
@end defun

@node Remapping Commands
@section Команды Переназначения
@cindex remapping commands

  Для преобразования одной команды в другую можно использовать особый вид
привязки ключей, не обращаясь к последовательности (последовательностям)
ключей, привязанной к исходной команде.  Чтобы использовать эту функцию,
сделайте привязку ключей для последовательности ключей, которая начинается с
фиктивного события @code{remap}, за которым следует имя команды, которую вы
хотите переназначить; для привязки укажите новое определение (обычно имя
команды, но возможно любое другое допустимое определение для привязки
ключа).

  Например, предположим, что в моем режиме есть специальная команда
@code{my-kill-line}, которую нужно вызывать вместо @code{kill-line}.  Чтобы
установить это, его карта режима должна содержать следующее переназначение:

@smallexample
(define-key my-mode-map [remap kill-line] 'my-kill-line)
@end smallexample

@noindent
Затем, всякий раз, когда @code{my-mode-map} активен, если пользователь
вводит @kbd{C-k} (последовательность глобальных ключей по умолчанию для
@code{kill-line}), Emacs вместо этого запускает @code{my-kill-line}).

  Обратите внимание, что переназначение происходит только через активные
ключевые карты; например, повторное отображение в префиксной ключевой карте,
такой как @code{ctl-x-map}, обычно не имеет никакого эффекта, поскольку
такие карты сами по себе не активны.  Кроме того, переназначение работает
только на одном уровне; в следующем примере,

@smallexample
(define-key my-mode-map [remap kill-line] 'my-kill-line)
(define-key my-mode-map [remap my-kill-line] 'my-other-kill-line)
@end smallexample

@noindent
@code{kill-line} - это @emph{not}, преобразованный в
@code{my-other-kill-line}.  Вместо этого, если обычная ключевая привязка
@code{kill-line}, она преобразуется в @code{my-kill-line}; если обычная
привязка указывает @code{my-kill-line}, она преобразуется в
@code{my-other-kill-line}.

Чтобы отменить переназначение команды, переназначьте ее на @code{nil};

@smallexample
(define-key my-mode-map [remap kill-line] nil)
@end smallexample

@defun command-remapping command &optional position keymaps
Эта функция возвращает переназначение для @var{command} (символа), учитывая
текущие активные ключевые карты.  Если @var{command} не переназначено (что
является обычной ситуацией) или не является символом, функция возвращает
@code{nil}.  @code{position} может дополнительно указывать позицию в буфере
или позицию события для определения используемых ключевых карт, как в
@code{key-binding}.

Если необязательный аргумент @code{keymaps} - не-@code{nil}, он задает
список таблиц ключей для поиска.  Этот аргумент игнорируется, если
@code{position} - не-@code{nil}.
@end defun

@node Translation Keymaps
@section Карты для Трансляции Последовательностей Событий
@cindex translation keymap
@cindex keymaps for translating events

  Когда функция @code{read-key-sequence} считывает последовательность ключей
(@pxref{Key Sequence Input}), она использует @dfn{translation keymaps} для
преобразования одних последовательностей событий в другие.  Карты
преобразования - @code{input-decode-map}, @code{local-function-key-map} и
@code{key-translation-map} (в порядке приоритета).

  Ключевые карты трансляции имеют ту же структуру, что и другие карты
ключей, но используются по-другому: они определяют переводы, которые
необходимо сделать при чтении последовательностей ключей, а не привязки для
полных последовательностей ключей.  При чтении каждой ключевой
последовательности она проверяется на соответствие каждой карты перевода.
Если одна из карт трансляции связывает @var{k} с вектором @var{v}, то всякий
раз, когда @var{k} появляется как подпоследовательность @emph{anywhere} в
ключевой последовательности, эта подпоследовательность заменяется событиями
в @var{v}.

  Например, терминалы VT100 отправляют @kbd{@key{ESC} O P} при нажатии на
клавиатуре клавиши @key{PF1}. На таких терминалах Emacs должен преобразовать
эту последовательность событий в одно событие @code{pf1}.  Это делается
привязкой @kbd{@key{ESC} O P} к @code{[pf1]} в @code{input-decode-map}.
Таким образом, когда вводитя @kbd{C-c @key{PF1}} на терминале, терминал
выдает последовательность символов @kbd{C-c @key{ESC} O P}, а
@code{read-key-sequence} переводит ее обратно в @kbd{C-c @key{PF1}} и
возвращает его как вектор @code{[?\C-c pf1]}.

  Карты трансляции вступают в силу только после того, как Emacs декодирует
ввод с клавиатуры (через систему кодирования ввода, заданную параметром
@code{keyboard-coding-system}).  @xref{Terminal I/O Encoding}.

@defvar input-decode-map
Эта переменная содержит ключевую карьу, которая описывает последовательности
символов, отправляемые функциональными клавишами на обычном символьном
терминале.

Значение @code{input-decode-map} обычно устанавливается автоматически в
соответствии с записью Terminfo или Termcap терминала, но иногда им нужна
помощь из файлов Lisp, специфичных для терминала.  Emacs поставляется со
специфическими для терминала файлами для многих общих терминалов; их
основная цель - делать записи в @code{input-decode-map} помимо тех, которые
можно вывести из Termcap и Terminfo.  @xref{Terminal-Specific}.
@end defvar

@defvar local-function-key-map
Эта переменная содержит ключевую карту, аналогичную @code{input-decode-map},
за исключением того, что она описывает последовательности ключей, которые
должны быть переведены в альтернативные интерпретации, которые обычно
предпочтительнее.  Применяется после @code{input-decode-map} и до
@code{key-translation-map}.

Записи в @code{local-function-key-map} игнорируются, если они конфликтуют с
привязками, сделанными в второстепенном режиме, локальных или глобальных
ключевых картах.  То есть переназначение применяется только в том случае,
если исходная последовательность ключей в противном случае не имела бы
привязки.

@code{local-function-key-map} наследуется от @code{function-key-map}, но
последний не следует использовать напрямую.
@end defvar

@defvar key-translation-map
Эта переменная - еще одна карта, используемая так же, как
@code{input-decode-map}, для преобразования событий ввода в другие события.
Это отличается от @code{input-decode-map} тем, что начинает работать после
завершения @code{local-function-key-map}, а не до него; получаются
результаты перевода по @code{local-function-key-map}.

Как и @code{input-decode-map}, но в отличие от
@code{local-function-key-map}, эта карта применяется независимо от того,
имеет ли входная последовательность ключей нормальную привязку.  Однако
обратите внимание, что фактические привязки ключей могут влиять на
@code{key-translation-map}, даже если они там переопределяются.
Действительно, фактические привязки ключей переопределяют
@code{local-function-key-map} и, таким образом, могут изменять
последовательность ключей, которую получает @code{key-translation-map}.
Ясно, что таких ситуаций лучше избегать.

Назначение @code{key-translation-map} состоит в том, чтобы пользователи
отображали один набор символов в другой, включая обычные символы, обычно
связанные с @code{self-insert-command}.
@end defvar

@cindex key translation function
Вы можете использовать @code{input-decode-map},
@code{local-function-key-map} и @code{key-translation-map} не только для
простых псевдонимов, используя функцию вместо ключевой последовательности в
качестве перевода ключей.  Затем эта функция вызывается для вычисления
перевода этого ключа.

Функция трансляции клавиш принимает один аргумент, который представляет
собой приглашение, указанное в @code{read-key-sequence}---или @code{nil},
если последовательность ключей считывается циклом команд редактора.  В
большинстве случаев можно игнорировать значение подсказки.

Если функция сама считывает ввод, это может повлиять на изменение
последующего события.  Например, вот как определить @kbd{C-c h}, чтобы
превратить следующий за ним символ в гипер-символ:

@example
@group
(defun hyperify (prompt)
  (let ((e (read-event)))
    (vector (if (numberp e)
                (logior (lsh 1 24) e)
              (if (memq 'hyper (event-modifiers e))
                  e
                (add-event-modifier "H-" e))))))

(defun add-event-modifier (string e)
  (let ((symbol (if (symbolp e) e (car e))))
    (setq symbol (intern (concat string
                                 (symbol-name symbol))))
    (if (symbolp e)
        symbol
      (cons symbol (cdr e)))))

(define-key local-function-key-map "\C-ch" 'hyperify)
@end group
@end example

@subsection Взаимодействие с Обычными Ключевыми Картами

Конец последовательности ключей обнаруживается, когда эта последовательность
ключей либо привязана к команде, либо когда Emacs определяет, что никакое
дополнительное событие не может привести к последовательности, связанной с
командой.

Это означает, что хотя @code{input-decode-map} и @code{key-translation-map}
применяются независимо от того, будет ли исходная последовательность ключей
иметь привязку, наличие такой привязки все же может препятствовать
выполнению трансляции.  Например, давайте вернемся к нашему примеру с VT100
выше и добавим привязку для @kbd{C-c @key{ESC}} к глобальной карте; теперь,
когда пользователь нажимает @kbd{C-c @key{PF1}}, Emacs не сможет
декодировать @kbd{C-c @key{ESC} O P} в @kbd{C-c @key{PF1}}, потому что он
перестанет читать ключи сразу после @kbd{C-x @key{ESC}}, оставив @kbd{O P}
на потом.  Это в случае, если пользователь действительно нажал
@kbd{C-c @key{ESC}}, и в этом случае Emacs не должен ждать следующего ключа,
чтобы решить, действительно ли пользователь нажал @kbd{@key{ESC}} или
@kbd{@key{PF1}}.

По этой причине лучше избегать привязки команд к последовательностям ключей,
в которых конец ключевой последовательности является префиксом трансляции
ключей.  Основными такими проблемными суффиксами/префиксами являются
@kbd{@key{ESC}}, @kbd{M-O} (который на самом деле является @kbd{@key{ESC} O}
) и @kbd{M-[} (который на самом деле является @kbd{@key{ESC} [}).

@node Key Binding Commands
@section Команды для Привязки Ключей

  В этом разделе описаны некоторые удобные интерактивные интерфейсы для
изменения привязки ключей.  Они работают, вызывая @code{define-key}.

  Люди часто используют @code{global-set-key} в своих файлах инициализации
(@pxref{Init File}) для простой настройки. Например,

@smallexample
(global-set-key (kbd "C-x C-\\") 'next-line)
@end smallexample

@noindent
или

@smallexample
(global-set-key [?\C-x ?\C-\\] 'next-line)
@end smallexample

@noindent
или

@smallexample
(global-set-key [(control ?x) (control ?\\)] 'next-line)
@end smallexample

@noindent
переопределяет @kbd{C-x C-\} для перемещения вниз по строке.

@smallexample
(global-set-key [M-mouse-1] 'mouse-set-point)
@end smallexample

@noindent
переопределяет первую (крайнюю левую) кнопку мыши, введенную с помощью
клавиши Meta, для установки точки, в которой вы щелкаете.

@cindex non-@acronym{ASCII} text in keybindings
  Будьте осторожны при использовании текстовых символов не-@acronym{ASCII} в
спецификациях Lisp ключей для связывания.  Если они читаются как
многобайтовый текст, как это обычно бывает в Lisp-файле
(@pxref{Loading Non-ASCII}), потребуется вводить ключи как многобайтовые.
Например, если использовать это:

@smallexample
(global-set-key "ö" 'my-function) ; связать о-умлаут
@end smallexample

@noindent
или

@smallexample
(global-set-key ?ö 'my-function) ; связать о-умлаут
@end smallexample

@noindent
а ваша языковая среда - многобайтовая Latin-1, эти команды фактически
связывают многобайтовый символ с кодом 246, а не с байтовым кодом 246
(@kbd{M-v}), отправленным терминалом Latin-1.  Чтобы использовать эту
привязку, потребуется научить Emacs декодировать клавиатуру, используя
соответствующий метод ввода
(@pxref{Input Methods, , Input Methods, emacs, The GNU Emacs Manual}).

@deffn Command global-set-key key binding
Эта функция устанавливает привязку @var{key} в текущей глобальной карте к
@var{binding}.

@smallexample
@group
(global-set-key @var{key} @var{binding})
@equiv{}
(define-key (current-global-map) @var{key} @var{binding})
@end group
@end smallexample
@end deffn

@deffn Command global-unset-key key
@cindex unbinding keys
Эта функция удаляет привязку @var{key} из текущей глобальной карты.

Одно из применений этой функции - подготовка к определению более длинного
ключа, который использует @var{key} в качестве префикса, что было бы
запрещено, если @var{key} имеет привязку без префикса. Например:

@smallexample
@group
(global-unset-key "\C-l")
    @result{} nil
@end group
@group
(global-set-key "\C-l\C-l" 'redraw-display)
    @result{} nil
@end group
@end smallexample

Эта функция эквивалентна использованию @code{define-key} следующим образом:

@smallexample
@group
(global-unset-key @var{key})
@equiv{}
(define-key (current-global-map) @var{key} nil)
@end group
@end smallexample
@end deffn

@deffn Command local-set-key key binding
Эта функция устанавливает привязку @var{key} в текущей локальной ключевой
карте к @var{binding}.

@smallexample
@group
(local-set-key @var{key} @var{binding})
@equiv{}
(define-key (current-local-map) @var{key} @var{binding})
@end group
@end smallexample
@end deffn

@deffn Command local-unset-key key
Эта функция удаляет привязку @var{key} из текущей локальной карты.

@smallexample
@group
(local-unset-key @var{key})
@equiv{}
(define-key (current-local-map) @var{key} nil)
@end group
@end smallexample
@end deffn

@node Scanning Keymaps
@section Сканирование Ключевых Карт
@cindex scanning keymaps
@cindex keymaps, scanning

  В этом разделе описываются функции, используемые для сканирования всех
текущих ключевых карт с целью вывода справочной информации.

@defun accessible-keymaps keymap &optional prefix
Эта функция возвращает список всех ключевых карт, которые могут быть
достигнуты (через ноль или более префиксных ключей) из @var{keymap}.
Значение представляет собой ассоциативный список с элементами формы
@code{(@var{key} .@: @var{map})}, где @var{key} - это префиксный ключ,
определение которого в @var{keymap} - @var{map}.

Элементы списка упорядочены так, что длина @var{key} увеличивается.  Первым
элементом всегда является @code{([] .@: @var{keymap})}, потому что указанная
ключевая карта доступна сама по себе с префиксом отсутствия событий.

Если задано @var{prefix}, это должно быть последовательностью префиксных
ключей; тогда @code{accessible-keymaps} включает только подкарты, префиксы
которых начинаются с @var{prefix}.  Эти элементы выглядят точно так же, как
и в значении @code{(accessible-keymaps)}; единственная разница в том, что
некоторые элементы опущены.

В приведенном ниже примере возвращенный список указывает, что ключ
@key{ESC}, который отображается как @samp{^[}, является префиксным ключом,
определение которого - разреженная карта ключей
@code{(keymap (83 .@: center-paragraph) (115 .@: foo))}.

@smallexample
@group
(accessible-keymaps (current-local-map))
@result{}(([] keymap
      (27 keymap   ; @r{Обратите внимание, что эта ключевая карта для @key{ESC} повторяется ниже.}
          (83 . center-paragraph)
          (115 . center-line))
      (9 . tab-to-tab-stop))
@end group

@group
   ("^[" keymap
    (83 . center-paragraph)
    (115 . foo)))
@end group
@end smallexample

В следующем примере @kbd{C-h} - это префиксный ключ, который использует
разреженную ключевую карту, начинающуюся с
@code{(keymap (118 . describe-variable)@dots{})}.  Другой префикс,
@kbd{C-x 4}, использует ключевую карту, которая также является значением
переменной @code{ctl-x-4-map}.  Событие @code{mode-line} - одно из
нескольких фиктивных событий, используемых в качестве префиксов для действий
мыши в определенных частях окна.

@smallexample
@group
(accessible-keymaps (current-global-map))
@result{} (([] keymap [set-mark-command beginning-of-line @dots{}
                   delete-backward-char])
@end group
@group
    ("^H" keymap (118 . describe-variable) @dots{}
     (8 . help-for-help))
@end group
@group
    ("^X" keymap [x-flush-mouse-queue @dots{}
     backward-kill-sentence])
@end group
@group
    ("^[" keymap [mark-sexp backward-sexp @dots{}
     backward-kill-word])
@end group
    ("^X4" keymap (15 . display-buffer) @dots{})
@group
    ([mode-line] keymap
     (S-mouse-2 . mouse-split-window-horizontally) @dots{}))
@end group
@end smallexample

@noindent
Это не все ключевые карты, которые можно увидеть на самом деле.
@end defun

@defun map-keymap function keymap
Функция @code{map-keymap} вызывает @var{function} один раз для каждой
привязки в @var{keymap}.  Она передает два аргумента: тип события и значение
привязки.  Если @var{keymap} имеет родителя, привязки родителя также
включаются.  Это работает рекурсивно: если у родителя есть сам родитель,
тогда также включаются привязки дедушки и бабушки и так далее.

Эта функция - самый чистый способ проверить все привязки в ключевой карте.
@end defun

@defun where-is-internal command &optional keymap firstonly noindirect no-remap
Эта функция - подпрограмма, используемая командой @code{where-is}
(@pxref{Help, , Help, emacs,The GNU Emacs Manual}).  Она возвращает список
всех ключевых последовательностей (любой длины), которые привязаны к
@var{command} в наборе ключевых карт.

Аргументом @var{command} может быть любой объект; он сравнивается со всеми
записями карты ключей с помощью @code{eq}.

Если @var{keymap} - @code{nil}, то используемые карты - это текущие активные
ключевые карты, не учитывая @code{overriding-local-map} (то есть
притворяясь, что его значение - @code{nil}).  Если @var{keymap} - это карта,
то ищутся карты @var{keymap} и глобальная карта.  Если @var{keymap} - это
список раскладок, поиск выполняется только по этим раскладкам.

Обычно лучше использовать @code{overriding-local-map} как выражение для
@var{keymap}.  Затем @code{where-is-internal} ищет именно активные ключевые
карты.  Чтобы искать только глобальную карту, передайте значение
@code{(keymap)} (пустая ключевая карта) как @var{keymap}.

Если @var{firstonly} - @code{не-ascii}, то значение представляет собой
единственный вектор, представляющий первую найденную ключевую
последовательность, а не список всех возможных ключевых последовательностей.
Если @var{firstonly} равен @code{t}, то значение является первой ключевой
последовательностью, за исключением того, что последовательности ключей,
состоящие полностью из символов @acronym{ASCII} (или мета-вариантов символов
@acronym{ASCII}), предпочтительнее всех других последовательностей ключей и
что возвращаемое значение никогда не может быть привязкой меню.

Если @var{noindirect} равен не-@code{nil}, @code{where-is-internal} не
заглядывает внутрь menu-items, чтобы найти свои команды.  Это дает
возможность искать непосредственно сам menu-item.

Пятый аргумент, @var{no-remap}, определяет, как эта функция обрабатывает
переназначения команд (@pxref{Remapping Commands}). Есть два интересных
случая:

@table @asis
@item Если команда @var{other-command} переназначена на @var{command}:
Если @var{no-remap} равен @code{nil}, найдите привязки для
@var{other-command} и относитесь к ним так, как будто они также являются
привязками для @var{command}.  Если @var{no-remap} равен не-@code{nil},
включите вектор @code{[remap @var{other-command}]} в список возможных
ключевых последовательностей вместо поиска этих привязок.

@item Если @var{command} переназначен на @var{other-command}:
Если @var{no-remap} равен @code{nil}, верните привязки для
@var{other-command}, а не для @var{command}.  Если @var{no-remap} -
не-@code{nil}, вернуть привязки для @var{command}, игнорируя тот факт, что
он переназначен.
@end table
@end defun

@deffn Command describe-bindings &optional prefix buffer-or-name
Эта функция создает список всех текущих привязок ключей и отображает его в
буфере с именем @file{*Help*}.  Текст сгруппирован по режимам - сначала
второстепенные режимы, затем основной режим, затем глобальные привязки.

Если @var{prefix} равен не-@code{nil}, это должен быть префиксный ключ; то
список включает только ключи, начинающиеся с @var{prefix}.

Когда несколько символов с последовательными кодами @acronym{ASCII} имеют
одинаковое определение, они отображаются вместе как
@samp{@var{firstchar}..@var{lastchar}}.  В этом случае вам нужно знать коды
@acronym{ASCII}, чтобы понять, какие символы это означает.  Например, в
глобальной карте по умолчанию символы @samp{@key{SPC} ..@: ~} описываются
одной строкой.  @key{SPC} - @acronym{ASCII} 32, @kbd{~} -
@acronym{ASCII} 126, а символы между ними включают все обычные печатные
символы (например, буквы, цифры, знаки препинания и т. д. @:); все эти
символы привязаны к @code{self-insert-command}.

Если @var{buffer-or-name} - не-@code{nil}, это должен быть буфер или имя
буфера.  Затем @code{describe-bindings} выводит список привязок этого буфера
вместо текущего буфера.
@end deffn

@node Menu Keymaps
@section Меню Ключевых Карт
@cindex menu keymaps

Ключевая карта может работать как меню, а также определять привязки клавиш
клавиатуры и кнопок мыши.  Меню обычно запускаются с помощью мыши, но они
также могут работать с клавиатурой.  Если раскладка меню активна для
следующего события ввода, это активирует функцию меню клавиатуры.

@menu
* Defining Menus::     Как сделать карту, определяющую меню.
* Mouse Menus::        Как пользователи запускают меню с помощью мыши.
* Keyboard Menus::     Как пользователи запускают меню с клавиатуры.
* Menu Example::       Делаем простое меню.
* Menu Bar::           Как настроить строку меню.
* Tool Bar::           Панель инструментов представляет собой ряд изображений.
* Modifying Menus::    Как добавить новые пункты в меню.
* Easy Menu::      Удобный макрос для создания меню.
@end menu

@node Defining Menus
@subsection Определение Меню
@cindex defining menus
@cindex menu prompt string
@cindex prompt string (of menu)
@cindex menu item

Ключевая карта действует как меню, если она имеет
@dfn{общую строку приглашения}, который представляет собой строку, которая
появляется как элемент ключевой карты.  (@xref{Format of Keymaps}).  Строка
должна описывать назначение команд меню.  Emacs отображает общую строку
приглашения как заголовок меню в некоторых случаях, в зависимости от
инструментария (если есть), используемого для отображения меню.@footnote{Это требуется для меню, в котором не используется набор инструментов, например, в текстовом терминале.}.  В карте меню также отображается общая строка
подсказки.

Самый простой способ создать ключевую карту со строкой приглашения - указать
эту строку в качестве аргумента при вызове @code{make-keymap},
@code{make-sparse-keymap} (@pxref{Creating Keymaps}) или
@code{define-prefix-command} (@pxref{Definition of define-prefix-command}).
Если не требуется, чтобы ключевая карта работала как меню, не указывайте для
нее строку приглашения.

@defun keymap-prompt keymap
Эта функция возвращает общую строку приглашения @var{keymap} или
@code{nil}, если ее нет.
@end defun

Пункты меню - это привязки в ключевой карте.  Каждая привязка связывает тип
события с определением, но типы событий не имеют значения для внешнего вида
меню.  (Обычно используются псевдособытия, символы, которые клавиатура не
может сгенерировать, в качестве типов событий для привязок пунктов меню.).
Меню полностью создается из привязок, которые соответствуют этим событиям в
ключевой карте.

Порядок пунктов в меню такой же, как порядок привязок в ключевой карте.
Поскольку @code{define-key} помещает новые привязки впереди, требуется
определять пункты меню, начиная с нижней части меню и заканчивая
перемещением вверх, если важен порядок.  Когда добавляете элемент в
существующее меню, требуется его положение в меню с помощью
@code{define-key-after} (@pxref{Modifying Menus}).

@menu
* Simple Menu Items::       Простой вид привязки ключей пунктам меню.
* Extended Menu Items::     Более сложные определения пунктов меню.
* Menu Separators::         Проведение горизонтальной линии через меню.
* Alias Menu Items::        Использование псевдонимов команд в пунктах меню.
@end menu

@node Simple Menu Items
@subsubsection Простые Пункты Меню

  Более простой (и оригинальный) способ определить пункт меню - это
привязать некоторый тип события (неважно, какой тип события) в такой
форме привязки:

@example
(@var{item-string} . @var{real-binding})
@end example

@noindent
@sc{car}, @var{item-string} - строка, отображаемая в меню.  Должна быть
короткой - предпочтительно от одного до трех слов.  Должен описывать
действие команды, которой соответствует.  Обратите внимание, что не все
графические инструменты могут отображать текст не-@acronym{ASCII} в меню
(будет работать для меню клавиатуры и будет работать в значительной степени
с набором инструментов GTK+).

  Также можете указать вторую строку, называемую строкой справки, как
  показано ниже.:

@example
(@var{item-string} @var{help} . @var{real-binding})
@end example

@noindent
@var{help} задает строку help-echo, отображаемую, когда указатель мыши
находится на этом элементе, точно так же, как текстовые свойства
@code{help-echo} (@pxref{Help display}).

  Что касается @code{define-key}, @var{item-string} и @var{help-string}
являются частью привязки события.  Однако @code{lookup-key} возвращает
только @var{real-binding}, и только @var{real-binding} используется для
выполнения ключа.

  Если @var{real-binding} равен @code{nil}, то @var{item-string} появляется
в меню, но не может быть выбран.

  Если @var{real-binding} является символом и имеет свойство @code{menu-enable} установленное в не-@code{nil} , это свойство является выражением,
которое определяет, включен ли пункт меню.  Каждый раз, когда ключевая карта
используется для отображения меню, Emacs оценивает выражение и активирует
пункт меню только в том случае, если значение выражения - не-@code{nil}.
Когда пункт меню отключен, он отображается недоступным и не может быть
выбран.

  Строка меню не пересчитывает, какие элементы включены каждый раз, когда
просматривается меню.  Это связано с тем, что инструментарий X требует
заранее получить всё дерево меню.  Чтобы принудительно пересчитать строку
меню, вызывается @code{force-mode-line-update} (@pxref{Mode Line Format}).

@node Extended Menu Items
@subsubsection Пункты Расширенного Меню
@kindex menu-item
@cindex extended menu item

  Пункт меню расширенного формата является более гибкой и более чистой
альтернативой простому формату.  Определяется тип события с привязкой к
списку, начинающемуся с символа @code{menu-item}.  Для невыбираемой строки
привязка выглядит так:

@example
(menu-item @var{item-name})
@end example

@noindent
Строка, начинающаяся с двух или более дефисов, определяет разделительную
линию; смотреть. @ref{Menu Separators}.

  Чтобы определить реальный пункт меню, который можно выбрать, привязка
  расширенного формата выглядит так:

@example
(menu-item @var{item-name} @var{real-binding}
    . @var{item-property-list})
@end example

@noindent
Здесь @var{item-name} - это выражение, вычисляющее строку пункта меню.
Таким образом, строка не обязательно должна быть константой.  Третий
элемент, @var{real-binding}, - это команда для выполнения.  Конец списка,
@var{item-property-list}, имеет форму списка свойств, который содержит
другую информацию.

  Вот таблица поддерживаемых свойств:

@table @code
@item :enable @var{form}
Результат оценки @var{form} определяет, включен ли элемент (не-@code{nil}
означает да).  Если элемент не включен, вы не можете щелкнуть по нему.

@item :visible @var{form}
Результат оценки @var{form} определяет, должен ли элемент действительно
отображаться в меню (не-@code{nil} означает да).  Если элемент не
отображается, то меню отображается так, как если бы этот элемент вообще не
был определен.

@item :help @var{help}
Значение этого свойства, @var{help}, указывает строку всплывающей справки,
отображаемую, пока указатель мыши находится на этом элементе.  Отображается
так же, как текстовые свойства @code{help-echo} (@pxref{Help display}).
Обратите внимание, что это должна быть строка константа, в отличие от
свойства @code{help-echo} для текста и наложений.

@item :button (@var{type} . @var{selected})
Это свойство позволяет определять переключатели и кнопки.  @sc{car},
@var{type}, говорит, что: это должно быть @code{:toggle} или @code{:radio}.
@sc{cdr}, @var{selected}, должна быть форма; результат оценки которой
говорит о том, выбрана ли эта кнопка в данный момент.

@dfn{toggle} - это пункт меню, который помечается как «включено» или
«выключено» в зависимости от значения @var{selected}.  Сама команда должна
переключать @var{selected}, устанавливая для него @code{t}, если это
@code{nil}, и @code{nil}, если это @code{t}.  Вот как определяется пункт
меню для переключения флага @code{debug-on-error}:

@example
(menu-item "Отладка при ошибке" toggle-debug-on-error
           :button (:toggle
                    . (and (boundp 'debug-on-error)
                           debug-on-error)))
@end example

@noindent
Это работает, потому что @code{toggle-debug-on-error} определяется как
команда, которая переключает переменную @code{debug-on-error}.

@dfn{Radio buttons} - это группа пунктов меню, в которой в любой момент
выбирается только один.  Должна быть переменная, значение которой указывает,
какая из них будет выбрана в любой момент.  @var{selected} форма для каждого
переключателя в группе должна проверять, имеет ли переменная правильное
значение для выбора этой кнопки.  Нажатие на кнопку должно установить
переменную так, чтобы кнопка, на которую вы нажали, стала выбранной.

@item :key-sequence @var{key-sequence}
Это свойство указывает, какая последовательность ключей, вероятно, будет
связана с той же командой, вызываемой этим пунктом меню.  Если указать
правильную последовательность ключей, это значительно ускорит подготовку
меню к отображению.

Если указать неправильную последовательность ключей, это не повлияет;
прежде чем Emacs отобразит @var{key-sequence} в меню, он проверяет, что
@var{key-sequence} действительно эквивалентен этому пункту меню.

@item :key-sequence nil
Это свойство указывает, что обычно нет привязки ключа, эквивалентного этому
пункту меню.  Использование этого свойства экономит время при подготовке
меню к отображению, поскольку Emacs не нуждается в поиске в ключевой карте
эквивалента для этого пункта меню.

Однако, если пользователь повторно связал определение этого элемента с
последовательностью ключей, Emacs игнорирует свойство @code{:keys} и все
равно находит эквивалент ключа.

@item :keys @var{string}
Это свойство указывает, что @var{string} - это строка, отображаемая как
эквивалент ключа для этого пункта меню.  Можно использовать конструкцию
документации @samp{\\[...]} в @var{string}.

@item :filter @var{filter-fn}
Это свойство обеспечивает способ динамического вычисления пункта меню.
Значение свойства @var{filter-fn} должно быть функцией одного аргумента;
когда он вызывается, его аргумент будет @var{real-binding}.  Функция должна
вернуть привязку для использования.

Emacs может вызвать эту функцию в любое время, когда она повторно отображает
или работает со структурами данных меню, поэтому вы должны написать ее,
чтобы ее можно было безопасно вызывать в любое время.
@end table

@node Menu Separators
@subsubsection Разделители Меню
@cindex menu separators

  Разделитель меню - это своего рода элемент меню, который не отображает
никакого текста - вместо этого он разделяет меню на части с помощью
горизонтальной линии.  В ключевой карте разделитель выглядит так:

@example
(menu-item @var{separator-type})
@end example

@noindent
где @var{separator-type} - строка, начинающаяся с двух или более дефисов.

  В простейшем случае @var{separator-type} состоит только из тире.  Это
определяет тип разделителя по умолчанию.  (Для совместимости @code{""} и
@code{-} также считается разделителем.)

  Некоторые другие значения @var{separator-type} определяют другой стиль
разделителя.  Вот их таблица:

@table @code
@item "--no-line"
@itemx "--space"
Дополнительное вертикальное пространство без реальной линии.

@item "--single-line"
Одна строка в цвете переднего плана меню.

@item "--double-line"
Двойная линия в цвете переднего плана меню.

@item "--single-dashed-line"
Одиночная пунктирная линия в цвете переднего плана меню.

@item "--double-dashed-line"
Двойная пунктирная линия в цвете переднего плана меню.

@item "--shadow-etched-in"
Одиночная линия с трехмерным углублением.  По умолчанию используются
разделители, состоящие только из тире.

@item "--shadow-etched-out"
Одиночная линия с выпуклым трехмерным изображением.

@item "--shadow-etched-in-dash"
Одиночная пунктирная линия с трехмерным углублением.

@item "--shadow-etched-out-dash"
Одиночная пунктирная линия с выпуклым трехмерным изображением.

@item "--shadow-double-etched-in"
Две линии с трехмерным углублением.

@item "--shadow-double-etched-out"
Две линии с трехмерным рельефом.

@item "--shadow-double-etched-in-dash"
Две пунктирные линии с трехмерным изображением углубления.

@item "--shadow-double-etched-out-dash"
Две пунктирные линии с выпуклым трехмерным изображением.
@end table

  Вы также можете указать эти имена в другом стиле, добавив двоеточие после
двойного тире и заменив каждое одиночное тире заглавными буквами следующего
слова.  Таким образом, @code{"--:singleLine"}, эквивалентно
@code{"--single-line"}.

  Вы можете использовать более длинную форму, чтобы указать ключевые слова,
такие как @code{:enable} и @code{:visible} для разделителя меню:

@code{(menu-item @var{separator-type} nil . @var{item-property-list})}

Например:

@example
(menu-item "--" nil :visible (boundp 'foo))
@end example

  Некоторые системы и наборы инструментов отображения на самом деле не
поддерживают все эти типы разделителей.  Если вы используете
неподдерживаемый тип, в меню отображается разделитель аналогичного типа,
который поддерживается.

@node Alias Menu Items
@subsubsection Псевдонимы Пунктов Меню

  Иногда бывает полезно создавать пункты меню, которые используют одну и ту
же команду, но с разными условиями включения.  Лучший способ сделать это в
Emacs сейчас - использовать расширенные пункты меню; до того, как эта
функция существовала, это можно было сделать, задав псевдонимы команд и
используя их в пунктах меню.  Вот пример, который создает два псевдонима для
@code{read-only-mode} и задает им разные условия включения:

@example
(defalias 'make-read-only 'read-only-mode)
(put 'make-read-only 'menu-enable '(not buffer-read-only))
(defalias 'make-writable 'read-only-mode)
(put 'make-writable 'menu-enable 'buffer-read-only)
@end example

При использовании псевдонимов в меню часто бывает полезно отображать
эквивалентные привязки ключей для реального имени команды, а не псевдонимы
(которые обычно не имеют привязок клавиш, кроме самого меню).  Чтобы
запросить это, присвойте псевдониму свойство не-@code{nil}
@code{menu-alias}.  Таким образом,

@example
(put 'make-read-only 'menu-alias t)
(put 'make-writable 'menu-alias t)
@end example

@noindent
заставляет пункты меню для @code{make-read-only} и @code{make-writable}
отображать привязки клавиатуры для @code{read-only-mode}.

@node Mouse Menus
@subsection Меню и Мышь

  Обычный способ заставить карту меню создавать меню - сделать ее
определением префиксным ключём.  (Программа Lisp может явно вызывать меню и
получать выбор пользователя --- смотреть @ref{Pop-Up Menus}).

  Если префиксный ключ оканчивается событием мыши, Emacs обрабатывает
карту меню, открывая видимое меню, так что пользователь может выбрать выбор
с помощью мыши.  Когда пользователь щелкает по пункту меню, генерируется
событие - любой символ или символ, имеющий привязку, которая привела к этому
пункту меню.  (Пункт меню может генерировать серию событий, если меню имеет
несколько уровней или происходит из строки меню).

  Часто для запуска меню лучше использовать событие нажатия кнопки.  Затем
пользователь может выбрать пункт меню, отпустив кнопку.

@cindex submenu
  Если карта меню содержит привязку к вложенной ключевой карте, вложенная
карта указывает @dfn{submenu}.  Там будет пункт меню, помеченный строкой
элемента вложенной ключевой карты, и щелчок по этому пункту автоматически
вызывает указанное подменю.  В качестве особого исключения, если карта меню
содержит одну вложенную ключевую карту и никаких других пунктов меню, в меню
отображается содержимое вложенной ключевой карты напрямую, а не как подменю.

  Однако, если Emacs скомпилирован без поддержки X toolkit или на текстовых
терминалах, подменю не поддерживаются.  Каждая вложенная карта отображается
как пункт меню, но щелчок по ней не вызывает автоматически подменю.  Если
требуется имитировать эффект подменю, можно сделать это, задав для вложенной
карты строку элемента, которая начинается с @samp{@@}.  Это заставляет Emacs
отображать вложенную карту с использованием отдельного @dfn{menu pane};
остальная часть строки элемента после @samp{@@} - это метка панели.  Если
Emacs скомпилирован без поддержки X toolkit, или если меню отображается в
текстовом терминале, панели меню не используются; в этом случае @samp{@@} в
начале строки элемента опускается, когда отображается метка меню, и не имеет
никакого другого эффекта.

@node Keyboard Menus
@subsection Меню и Клавиатура

  Когда префиксный ключ, оканчивается событием клавиатуры (символом или
функциональным ключём), имеет определение, которое является ключевой картой
меню, он действует как меню клавиатуры; пользователь указывает следующее
событие, выбирая пункт меню с помощью клавиатуры.

  Emacs отображает меню клавиатуры с общей строкой подсказки карты, за
которой следуют альтернативы (строки элементов привязок карты) в
эхо-области.  Если не все привязки подходят одновременно, пользователь может
ввести @key{SPC}, чтобы увидеть следующую строку альтернатив.
Последовательное использование @key{SPC} в конечном итоге приводит к концу
меню, а затем циклически возвращается к началу.  (Переменная
@code{menu-prompt-more-char} указывает, какой символ используется для этого;
@key{SPC} используется по умолчанию.)

  Когда пользователь нашел желаемую альтернативу в меню, он или она должны
ввести соответствующий символ - тот, чья привязка является этой
альтернативой.

@defvar menu-prompt-more-char
Эта переменная определяет символ, который будет использоваться для запроса
перехода к следующей строке меню.  Его начальное значение - 32, код для
@key{SPC}.
@end defvar

@node Menu Example
@subsection Пример Меню
@cindex menu definition example

  Вот полный пример определения карты меню.  Это определение подменю
@samp{Replace} в меню @samp{Edit} в строке меню, и оно использует
расширенный формат пункта меню (@pxref{Extended Menu Items}).  Сначала мы
создаем карту клавиатуры и даем ей имя:

@smallexample
(defvar menu-bar-replace-menu (make-sparse-keymap "Replace"))
@end smallexample

@noindent
Далее мы определяем пункты меню:

@smallexample
(define-key menu-bar-replace-menu [tags-repl-continue]
  '(menu-item "Continue Replace" tags-loop-continue
              :help "Continue last tags replace operation"))
(define-key menu-bar-replace-menu [tags-repl]
  '(menu-item "Replace in tagged files" tags-query-replace
              :help "Interactively replace a regexp in all tagged files"))
(define-key menu-bar-replace-menu [separator-replace-tags]
  '(menu-item "--"))
;; @r{@dots{}}
@end smallexample

@noindent
Обратите внимание на символы, для которых сделаны привязки; они появляются в
квадратных скобках в определяемой последовательности ключей.  В некоторых
случаях этот символ совпадает с именем команды; иногда бывает иначе.  Эти
символы рассматриваются как функциональные ключи, но они не являются
настоящими функциональными ключами на клавиатуре.  Они не влияют на работу
самого меню, но они отражаются в эхо-области, когда пользователь выбирает
из меню, и появляются в выводе @code{where-is} и @code{apropos}.

  Меню в этом примере предназначено для использования с мышью.  Если меню
предназначено для использования с клавиатурой, то есть если оно привязано к
последовательности клавиш, заканчивающейся событием клавиатуры, то элементы
меню должны быть привязаны к символам или реальным функциональным клавишам,
которые можно вводить с клавиатуры.

  Привязка, определение которой - @code{("--")}, является разделительной
линией.  Как и в реальном пункте меню, разделитель имеет символ ключа, в
данном случае @code{separator-replace-tags}.  Если в одном меню есть два
разделителя, они должны иметь два разных символа ключей.

  Вот как мы делаем это меню как элемент в родительском меню:

@example
(define-key menu-bar-edit-menu [replace]
  (list 'menu-item "Replace" menu-bar-replace-menu))
@end example

@noindent
Обратите внимание, что это включает в себя карту подменю, которая
представляет собой значение переменной @code{menu-bar-replace-menu}, а не
сам символ @code{menu-bar-replace-menu}.  Использование этого символа в
родительском пункте меню было бы бессмысленным, потому что
@code{menu-bar-replace-menu} не является командой.

  Если хотите прикрепить то же меню замены к щелчку мыши, можете сделать это
следующим образом:

@example
(define-key global-map [C-S-down-mouse-1]
   menu-bar-replace-menu)
@end example

@node Menu Bar
@subsection Бар Меню
@cindex menu bar

  Emacs обычно показывает @dfn{menu bar} вверху каждого кадра.
@xref{Menu Bars,,,emacs, The GNU Emacs Manual}.  Пункты Бар меню - это
подкоманды фальшивого функционального ключа @key{MENU-BAR}, как определено в
активных картах ключей.

  Чтобы добавить элемент в строку меню, придумайте собственный фальшивый
функциональный ключ (назовем его @var{key}) и сделайте привязку для
последовательности ключей @code{[menu-bar @var{key}]}.  Чаще всего привязка
- это карта меню, так что нажатие кнопки в элементе строки меню приводит к
другому меню.

  Когда несколько активных карт определяют один и тот же функциональный ключ
для строки меню, элемент появляется только один раз.  Если пользователь
щелкает этот элемент строки меню, появляется единое комбинированное меню,
содержащее все подкоманды этого элемента - глобальные подкоманды, локальные
подкоманды и подкоманды второстепенного режима.

  Переменная @code{overriding-local-map} обычно игнорируется при определении
содержимого строки меню.  То есть строка меню вычисляется из карты ключей,
которые были бы активны, если бы @code{overriding-local-map} был @code{nil}.
@xref{Active Keymaps}.

  Вот пример настройки элемента строки меню:

@example
@group
;; @r{Создайте карту меню (со строкой подсказки)}
;; @r{ и сделайте ее элементом определения строки меню.}
(define-key global-map [menu-bar words]
  (cons "Words" (make-sparse-keymap "Words")))
@end group

@group
;; @r{Определите определенные подкоманды в этом меню.}
(define-key global-map
  [menu-bar words forward]
  '("Forward word" . forward-word))
@end group
@group
(define-key global-map
  [menu-bar words backward]
  '("Backward word" . backward-word))
@end group
@end example

  Локальная ключевая карта может отменить пункт строки меню, созданный
глобальной картой, путем повторного связывания того же фальшивого
функционального ключа с @code{undefined} в качестве привязки.  Например, вот
так Dired подавляет пункт меню @samp{Edit}:

@example
(define-key dired-mode-map [menu-bar edit] 'undefined)
@end example

@noindent
Здесь @code{edit} - это символ, созданный поддельным функциональным ключом,
он используется глобальной картой для пункта строки меню @samp{Edit}.
Основная причина подавления элемента глобальной строки меню - освободить
место для элементов, зависящих от режима.

@defvar menu-bar-final-items
Обычно в строке меню отображаются глобальные элементы, за которыми следуют
элементы, определенные локальными картами.

Эта переменная содержит список поддельных функциональных ключей для
элементов, отображаемых в конце строки меню, а не в обычной
последовательности.  Значение по умолчанию - @code{(help-menu)}; таким
образом, пункт меню @samp{Help} обычно появляется в конце строки меню после
пунктов локального меню.
@end defvar

@defvar menu-bar-update-hook
Эта обычная ловушка запускается при повторном отображении для обновления
содержимого строки меню перед повторным отображением строки меню.  Можете
использовать его для обновления меню, содержание которого должно отличаться.
Поскольку этот перехватчик запускается часто, советуем вам убедиться, что
вызываемые им функции не занимают много времени в обычном случае.
@end defvar

Рядом с каждым элементом строки меню Emacs отображает ключевую привязку,
которая запускает ту же команду (если такая привязка ключа существует).  Это
служит удобной подсказкой для пользователей, которые не знают привязки клавиш.  Если команда имеет несколько привязок, Emacs обычно отображает первую
найденную.  Можете указать одну конкретную привязку ключа, назначив символу
команды свойство @code{:advertised-binding}.  @xref{Keys in Documentation}.

@node Tool Bar
@subsection Tool bars
@cindex tool bar

  @dfn{tool bar} - это ряд интерактивных значков в верхней части фрейма,
чуть ниже строки меню.  @xref{Tool Bars,,,emacs, The GNU Emacs Manual}.
Emacs обычно показывает панель инструментов на графических дисплеях.

  В каждом кадре параметр кадра @code{tool-bar-lines} определяет, сколько
строк в высоту следует зарезервировать для панели инструментов.  Нулевое
значение подавляет панель инструментов.  Если значение не равно нулю и
@code{auto-resize-tool-bars} равно не-@code{nil}, панель инструментов
автоматически расширяется и сжимается, чтобы удерживать указанное
содержимое.  Если значение равно @code{grow-only}, панель инструментов
расширяется автоматически, но не сужается автоматически.

  Содержимое панели инструментов контролируется раскладкой меню,
прикрепленной к фальшивой функциональной клавише @key{TOOL-BAR} (очень
похоже на то, как управляется полоса меню).  Итак, определяете элемент
панели инструментов с помощью @code{define-key}, например:

@example
(define-key global-map [tool-bar @var{key}] @var{item})
@end example

@noindent
где @var{key} - это фальшивый функциональный ключ, позволяющий отличать этот
элемент от других элементов, а @var{item} - это привязка клавиши пункта меню
(@pxref{Extended Menu Items}), которая говорит, как отображать этот элемент
и как он себя ведет.

  Обычные свойства элемента карты меню, @code{:visible}, @code{:enable},
@code{:button}, и @code{:filter}, полезны в привязках панели инструментов и
имеют свое обычное значение.  @var{real-binding} в элементе должна быть
командой, а не картой; Другими словами, определение значка панели
инструментов в качестве префиксного ключа не работает.

  Свойство @code{:help} определяет строку эхо-справки, отображаемую, когда
указатель мыши находится на этом элементе.  Отображается так же, как
текстовые свойства @code{help-echo}.  (@pxref{Help display}).

  Кроме того, потребуется использовать свойство @code{:image}; так
указывается изображение для отображения на панели инструментов:

@table @code
@item :image @var{image}
@var{image} - это либо спецификация одного изображения (@pxref{Images}),
либо вектор из четырех спецификаций изображения.  Если используется вектор
из четырех спецмфикаций, в зависимости от обстоятельств используется один из
них:

@table @asis
@item item 0
Используется, когда элемент включен и выбран.
@item item 1
Используется, когда элемент включен и не выбран.
@item item 2
Используется, когда элемент отключен и выбран.
@item item 3
Используется, когда элемент отключен и не выбран.
@end table
@end table

Версии Emacs GTK+ и NS игнорируют пункты с 1 по 3, потому что отключенные
и/или невыбранные изображения автоматически вычисляются из элемента 0.

Если @var{image} - это спецификация одного изображения, Emacs рисует кнопку
панели инструментов в отключенном состоянии, применяя алгоритм обнаружения
границ к изображению.

Свойство @code{:rtl} указывает альтернативное изображение для языков с
письмом справа налево.  В настоящее время это поддерживает только версия
Emacs для GTK+.

Как и строка меню, панель инструментов может отображать разделители
(@pxref{Menu Separators}).  Однако разделители панели инструментов являются
вертикальными, а не горизонтальными, и поддерживается только один стиль.
Они представлены в ключевой карте панели инструментов записями
@code{(menu-item "--")}; такие свойства, как @code{:visible}, не
поддерживаются для разделителей панели инструментов.  Разделители изначально
отображаются на панелях инструментов GTK + и Nextstep; в остальных случаях
они визуализируются с использованием изображения вертикальной линии.

Панель инструментов по умолчанию определена так, что элементы, относящиеся к
редактированию, не отображаются для основных режимов, символ команды которых
имеет свойство @code {mode-class} @code{special}
(@pxref{Major Mode Conventions}).  В основных режимах можно добавлять
элементы на глобальную панель путем привязки @code{[tool-bar @var{foo}]} к
их локальной карте.  В некоторых основных режимах имеет смысл полностью
заменить элементы панели инструментов по умолчанию, поскольку не многие из
них могут быть удобно размещены, а привязки по умолчанию упрощают это,
используя косвенное обращение через @code{tool-bar-map}.

@defvar tool-bar-map
По умолчанию глобальная карта связывает @code{[tool-bar]} следующим образом:

@example
(global-set-key [tool-bar]
                `(menu-item ,(purecopy "tool bar") ignore
                            :filter tool-bar-make-keymap))
@end example

@noindent
Функция @code{tool-bar-make-keymap}, в свою очередь, динамически извлекает
фактическую карту панели инструментов из значения переменной
@code{tool-bar-map}.  Следовательно, потребуется настраивать стандартную
(глобальную) панель инструментов, изменяя эту карту.  Некоторые основные
режимы, такие как режим информации, полностью заменяют глобальную панель
инструментов, делая @code{tool-bar-map} буферным локальным и устанавливая
для него другую карту.
@end defvar

Есть две удобные функции для определения элементов панели инструментов, как
показано ниже.

@defun tool-bar-add-item icon def key &rest props
Эта функция добавляет элемент на панель инструментов, изменяя
@code{tool-bar-map}.  Используемое изображение определяется параметром
@var{icon}, который является базовым именем файла изображения XPM, XBM или
PBM, который нужно найти с помощью @code{find-image}.  Если задано значение
@samp{"exit"}, скажем, @file{exit.xpm}, @file{exit.pbm} и @file{exit.xbm}
будет искать в этом порядке на цветном дисплее.  На монохромном дисплее
порядок поиска составляет @samp{.pbm}, @samp{.xbm} и @samp{.xpm}.
Используемая привязка - это команда @var{def}, и @var{key} - символ
фальшивого функционального ключа в префиксной ключевой карте.  Остальные
аргументы @var{props} - это дополнительные элементы списка свойств, которые
нужно добавить в спецификацию пункта меню.

Чтобы определить элементы на некоторой локальной карте, свяжите
@code{tool-bar-map} с @code{let} вокруг вызовов этой функции:
@example
(defvar foo-tool-bar-map
  (let ((tool-bar-map (make-sparse-keymap)))
    (tool-bar-add-item @dots{})
    @dots{}
    tool-bar-map))
@end example
@end defun

@defun tool-bar-add-item-from-menu command icon &optional map &rest props
Эта функция удобна для определения элементов панели инструментов, которые
согласуются с существующими привязками строки меню.  Привязка @var{command}
ищется в строке меню в @var{map} (по умолчанию @code{global-map}) и
модифицируется, чтобы добавить спецификацию изображения для @var{icon},
которая находится так же, как и @code{tool-bar-add-item}.  Полученная
привязка затем помещается в @code{tool-bar-map}, поэтому используйте эту
функцию только для глобальных элементов панели инструментов.

@var{map} должен содержать соответствующую ключевую карту, привязанную к
@code{[menu-bar]}.  Остальные аргументы @var{props} - это дополнительные
элементы списка свойств, которые нужно добавить в спецификацию пункта меню.
@end defun

@defun tool-bar-local-item-from-menu command icon in-map &optional from-map &rest props
Эта функция используется для создания неглобальных элементов панели
инструментов.  Используйте её как @code{tool-bar-add-item-from-menu}, за
исключением того, что @var{in-map} указывает локальную карту для
определения.  Аргумент @var{from-map} похож на аргумент @var{map} для
@code{tool-bar-add-item-from-menu}.
@end defun

@defvar auto-resize-tool-bars
Если эта переменная - не-@code{nil}, панель инструментов автоматически
изменяет размер, чтобы показать все определенные элементы панели
инструментов, но не больше четверти высоты фрейма.

Если значение равно @code{grow-only}, панель инструментов расширяется
автоматически, но не сужается автоматически.  Чтобы свернуть панель
инструментов, пользователь должен перерисовать рамку, введя @kbd{C-l}.

Если Emacs собран с GTK+ или Nextstep, панель инструментов может отображать
только одну строку, поэтому эта переменная не имеет никакого эффекта.
@end defvar

@defvar auto-raise-tool-bar-buttons
Если эта переменная - не-@code{nil}, элементы панели инструментов
отображаются в выпуклой форме при наведении на них указателя мыши.
@end defvar

@defvar tool-bar-button-margin
Эта переменная определяет дополнительное поле для добавления вокруг
элементов панели инструментов.  Значение - целое число, количество пикселей.
По умолчанию - 4.
@end defvar

@defvar tool-bar-button-relief
Эта переменная определяет ширину тени для элементов панели инструментов.
Значение - целое число, количество пикселей.  По умолчанию 1.
@end defvar

@defvar tool-bar-border
Эта переменная определяет высоту границы, нарисованной под областью панели
инструментов.  Целое число определяет высоту как количество пикселей.  Если
значение равно @code{internal-border-width} (по умолчанию) или
@code{border-width}, высота границы панели инструментов соответствует
соответствующему параметру кадра.
@end defvar

  Можно определить особое значение для нажатия на элемент панели
инструментов с помощью модификаторов shift, control, meta, и т. д.  Делается
это, настраивая дополнительные элементы, которые связаны с исходным
элементом, с помощью поддельных функциональных ключей.  В частности,
дополнительные элементы должны использовать модифицированные версии того же
фальшивого функционального ключа, который использовался для наименования
исходного элемента.

  Таким образом, если исходный элемент был определен таким образом,

@example
(define-key global-map [tool-bar shell]
  '(menu-item "Shell" shell
              :image (image :type xpm :file "shell.xpm")))
@end example

@noindent
то вот как можно определить нажатие на то же изображение панели инструментов
с модификатором сдвига:

@example
(define-key global-map [tool-bar S-shell] 'some-command)
@end example

@xref{Function Keys}, для получения дополнительной информации о том, как
добавлять модификаторы к функциональным ключам.

@node Modifying Menus
@subsection Модификация Меню
@cindex menu modification

  Когда вставляется новый элемент в существующее меню, вероятно, захочется
поместить его в определенное место среди существующих пунктов меню.  Если
используете @code{define-key} для добавления элемента, он обычно находится в
начале меню.  Чтобы поместить его в другое место в меню, используйте
@code{define-key-after}:

@defun define-key-after map key binding &optional after
Определите привязку в @var{map} для @var{key} со значением @var{binding},
как и @code{define-key}, но поместите привязку в @var{map} после привязки
для события @var{after}.  Аргумент @var{key} должен иметь длину один -
вектор или строку с одним элементом.  Но @var{after} должен быть
единственным типом события - символом, а не ключевой последовательностью.
Новая привязка идет после привязки для @var{after}.  Если @var{after} равен
@code{t} или не указан, то новая привязка идет последней, в конце карты.
Однако новые привязки добавляются перед любой унаследованной ключевой
картой.

Вот пример:

@example
(define-key-after my-menu [drink]
  '("Drink" . drink-command) 'eat)
@end example

@noindent
делает привязку для поддельной функциональной клавиши @key{DRINK} и помещает
ее сразу после привязки для @key{EAT}.

Вот как вставить пункт @samp{Work} в меню @samp{Signals} режима Shell после
пункта @code{break}:

@example
(define-key-after
  (lookup-key shell-mode-map [menu-bar signals])
  [work] '("Work" . work-command) 'break)
@end example
@end defun

@node Easy Menu
@subsection Простое Меню

  Следующий макрос обеспечивает удобный способ определения всплывающих
  меню и/или меню строки меню.

@defmac easy-menu-define symbol maps doc menu
Этот макрос определяет всплывающее меню и/или подменю строки меню,
содержание которых задается @var{menu}.

Если @var{symbol} равен не-@code{nil}, это должен быть символ; тогда этот
макрос определяет @var{symbol} как функцию для вызова меню
(@pxref{Pop-Up Menus}) с @var{doc} в качестве строки документации.
@var{symbol} не следует цитировать.

Независимо от значения @var{symbol}, если @var{maps} - это ключевая карта,
меню добавляется к этой карте как меню верхнего уровня для строки меню
(@pxref{Menu Bar}).  Это также может быть список ключевых карт, и в этом
случае меню добавляется отдельно к каждой из этих раскладок.

Первым элементом @var{menu} должна быть строка, которая служит меткой меню.
За ним может следовать любое количество следующих пар ключевое
слово-аргумент:

@table @code
@item :filter @var{function}
@var{function} должна быть функцией, которая при вызове с одним аргументом
--- списком других пунктов меню --- возвращает фактические пункты, которые
будут отображаться в меню.

@item :visible @var{include}
@var{include} - выражение; если он оценивается как @code{nil}, меню
становится невидимым.  @code{:included} - это псевдоним @code{:visible}.

@item :active @var{enable}
@var{enable} - выражение; если он оценивается как @code{nil}, меню нельзя
выбрать.  @code{:enable} - это псевдоним @code{:active}.
@end table

Остальные элементы в @var{menu} - это пункты меню.

Пункт меню может быть вектором из трех элементов, @code{[@var{name}
@var{callback} @var{enable}]}.  @var{name} - название пункта меню (строка).
@var{callback} - это команда для запуска или выражение для оценки при выборе
элемента.  @var{enable} - выражение; если он оценивается как @code{nil},
элемент недоступен для выбора.

В качестве альтернативы, пункт меню может иметь форму:

@smallexample
   [ @var{name} @var{callback} [ @var{keyword} @var{arg} ]... ]
@end smallexample

@noindent
где @var{name} и @var{callback} имеют то же значение, что и выше, и каждая
необязательная пара @var{keyword} и @var{arg} должна быть одним из
следующих:

@table @code
@item :keys @var{keys}
@var {keys} - это клавиатурный эквивалент пункта меню (строки).  Обычно в
этом нет необходимости, поскольку эквиваленты ключей вычисляются
автоматически.  @var{keys} расширяется до @code{substitute-command-keys}
перед отображением (@pxref{Keys in Documentation}).

@item :key-sequence @var{keys}
@var{keys} - это подсказка для ускорения первого отображения меню в Emacs.
Это должно быть @code{nil}, если знаете, что у пункта меню нет эквивалента
ключа; в противном случае это должна быть строка или вектор, определяющий
ключевой эквивалент пункта меню.

@item :active @var{enable}
@var{enable} - выражение; если он принимает значение @code{nil}, элемент
становится недоступным для выбора.  @code{:enable} - это псевдоним для
@code{:active}.

@item :visible @var{include}
@var{include} - выражение; если он оценивается как @code{nil}, элемент
становится невидимым.  @code{:included} - это псевдоним @code{:visible}.

@item :label @var{form}
@var{form} - это выражение, которое вычисляется для получения значения,
которое служит меткой пункта меню (по умолчанию @var{name}).

@item :suffix @var{form}
@var{form} - это выражение, которое вычисляется динамически и значение
которого объединяется с меткой пункта меню.

@item :style @var{style}
@var{style} - символ, описывающий тип пункта меню; это должен быть
@code{toggle} (флажок), @code{radio} (переключатель) или что-то еще
(имеется в виду обычный пункт меню).

@item :selected @var{selected}
@var{selected} - выражение; флажок или переключатель устанавливается всякий
раз, когда значение выражения - не-@code{nil}.

@item :help @var{help}
@var{help} - строка, описывающая пункт меню.
@end table

Как вариант, пункт меню может быть строкой.  Затем эта строка появляется в
меню в виде невыбираемого текста.  Строка, состоящая из тире, отображается
как разделитель (@pxref{Menu Separators}).

В качестве альтернативы, пункт меню может быть списком с тем же форматом,
что и @var{menu}.  Это подменю.
@end defmac

Вот пример использования @code{easy-menu-define} для определения меню,
аналогичного тому, которое определено в примере в @ref{Menu Bar}:

@example
(easy-menu-define words-menu global-map
  "Меню для команд навигации по словам."
  '("Words"
     ["Следующее слово" forward-word]
     ["Предыдущее слово" backward-word]))
@end example
