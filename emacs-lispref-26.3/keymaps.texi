@c -*- mode: texinfo; coding: utf-8 -*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1994, 1998-2019 Free Software Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Keymaps
@chapter Ключевые Карты
@cindex keymap

  Привязки команд входных событий записываются в структуры
данных, называемые @dfn{keymaps (ключевая карта)}.  Каждая
запись такой карты связывает (или @dfn{binds}) отдельный
тип события либо с другой картой, либо с командой.  Когда тип
события привязан к карте, эта карта используется для поиска
следующего события ввода; это продолжается до тех пор, пока
не будет найдена команда.  Весь процесс называется @dfn{key lookup (поиском ключа)}.

@menu
* Key Sequences::               Ключевые карты как объекты Lisp.
* Keymap Basics::               Основные понятия ключевой карты.
* Format of Keymaps::           Представление ключевой карты как объект Lisp.
* Creating Keymaps::            Функции для создания и копирования ключевых карт.
* Inheritance and Keymaps::     Как одна ключевая карта может наследовать привязки другой карты.
* Prefix Keys::                 Определение ключа с помощью ключевой карты в качестве его определения.
* Active Keymaps::              Как Emacs ищет в активных таблицах ключей привязку клавиш.
* Searching Keymaps::           Псевдо-Lisp-сводка поиска активных карт.
* Controlling Active Maps::     Каждый буфер имеет локальную карту ключей для переопределения стандартных (глобальных) привязок.  Второстепенный режим также может их отменять.
* Key Lookup::                  Нахождение привязки ключа в одной ключевой карте.
* Functions for Key Lookup::    Как запросить поиск ключа.
* Changing Key Bindings::       Переопределение ключа в ключевой карте.
* Remapping Commands::          Ключевая карта может переопределить одну команду в другую.
* Translation Keymaps::         Ключевые карты для перевода последовательностей событий.
* Key Binding Commands::        Интерактивные интерфейсы для переопределения ключей.
* Scanning Keymaps::            Сканирование ключевых карт, вывод справки.
* Menu Keymaps::                Определение меню как ключевой карты.
@end menu

@node Key Sequences
@section Ключевая Последовательнасть
@cindex key
@cindex keystroke
@cindex key sequence

  @dfn{Ключевая последовательность}, или для краткости
@dfn{ключ}, представляет собой последовательность из одного
или нескольких входных событий, образующих единое целое.
Входные события включают символы, функциональные клавиши,
действия мыши или системные события, внешние по отношению к
Emacs, такие как @code{iconify-frame} (@pxref{Input Events}).
Для Emacs Lisp представление ключевой последовательности -
это строка или вектор.  Если не указано иное, любая функция
Emacs Lisp, которая принимает ключевую последовательность в
качестве аргумента, может обрабатывать оба представления.

  В строковом представлении буквенно-цифровые символы обычно
обозначают сами себя; например, @code{"a"} представляет
@kbd{a}, а @code{"2"} представляет @kbd{2}.  Символы
управляющих событий имеют префикс подстроки @code{"\C-"}, а
метасимволы - @code{"\M-"}; например, @code{"\C-x"}
представляет собой ключ @kbd{\-x}.  Кроме того, события
@key{TAB}, @key{RET}, @key{ESC}, и @key{DEL} представлены
соответственно @code{"\t"}, @code{"\r"}, @code{"\e"} и
@code{"\d"}.  Строковое представление полной ключевой
последовательности - это конкатенация строковых представлений
составляющих событий; таким образом, @code{"\C-xl"}
представляет собой последовательность клавиш @kbd{C-x l}.

  Последовательности клавиш, содержащие функциональные
клавиши, события кнопок мыши, системные события или символы
не-@acronym{ASCII}, такие как @kbd{C-=} или @kbd{H-a}, не
могут быть представлены в виде строк; они должны быть
представлены в виде векторов.

  В векторном представлении каждый элемент вектора
представляет входное событие в его форме Lisp.
@xref{Input Events}.  Например, вектор @code{[?\C-x ?l]}
представляет собой последовательность клавиш @kbd{C-x l}.

  Примеры последовательностей клавиш, записанных в строковом
и векторном представлениях., @ref{Init Rebinding,,, emacs, Руководство GNU Emacs Manual}.

@defun kbd keyseq-text
Эта функция преобразует текст @var{keyseq-text} (строковую
константу) в ключевую последовательность (строковую или
векторную константу).  Содержимое @var{keyseq-text} должно
использовать тот же синтаксис, что и в буфере, вызываемом
командой @kbd{C-x C-k @key{RET}} (@code{kmacro-edit-macro});
в частности, имена функциональных клавиш должны быть
заключены в @samp{<@dots{}>}.  @xref{Edit Keyboard Macro,,, emacs, The GNU Emacs Manual}.

@example
(kbd "C-x") @result{} "\C-x"
(kbd "C-x C-f") @result{} "\C-x\C-f"
(kbd "C-x 4 C-f") @result{} "\C-x4\C-f"
(kbd "X") @result{} "X"
(kbd "RET") @result{} "\^M"
(kbd "C-c SPC") @result{} "\C-c@ "
(kbd "<f1> SPC") @result{} [f1 32]
(kbd "C-M-<down>") @result{} [C-M-down]
@end example
@end defun

@node Keymap Basics
@section Ключевые Карты Основы
@cindex key binding
@cindex binding of a key
@cindex complete key
@cindex undefined key

  Ключевая карта - это структура данных Lisp, которая
определяет @dfn{key bindings} для различных
последовательностей ключей.

  Единая ключевая карта напрямую определяет определения для
  отдельных событий.  Когда карта состоит из одного события,
  ее привязка ключа в карте является ее определением для
  этого события.  Связывание более длинной ключевой
  последовательности обнаруживается итеративным процессом:
  сначала находится определение первого события (которое само
  должно быть картой); затем ищется определение второго
  события в этой карте и так далее, пока все события
  ключевой последовательности карты не будут обработаны.

  Если привязка ключевой последовательности является ключевой
картой, эта последовательность ключей называется
@dfn{prefix key (префиксным ключем)}.  В противном случае это
называется @dfn{complete key (полный ключ)} (потому что к
нему нельзя добавлять больше событий).  Если привязка -
@code{nil}, ключ называется @dfn{undefined (неопределенным)}.
Примеры префиксных ключей: @kbd{C-c}, @kbd{C-x} и
@kbd{C-x 4}.  Примеры определенных полных ключей: @kbd{X},
@key{RET}, и @kbd{C-x 4 C-f}.  Примеры неопределенных полных
ключей: @kbd{C-x C-g} и @kbd{C-c 3}. @xref{Prefix Keys}, для
деталей.

  Правило поиска привязки ключевой последовательности
предполагает, что все промежуточные привязки (найденные для
событий перед последним) представляют собой ключевые карты;
если это не так, последовательность событий не образует
единое целое - на самом деле это не одна ключевая
последовательность.  Другими словами, удаление одного или
нескольких событий из конца любой допустимой
последовательности ключей всегда должно давать префиксный
ключ.  Например, @kbd{C-f C-n} не является ключевой
последовательностью; @kbd{C-f} не является префиксным ключом,
поэтому более длинная последовательность, начинающаяся с
@kbd{C-f}, не может быть ключевой последовательностью.

  Набор возможных ключевых последовательностей с несколькими
событиями зависит от привязки префиксных ключей;
следовательно, он может быть разным для разных ключевых карт
и может меняться при изменении привязок.  Однако
последовательность из одного события всегда является ключевой
последовательностью, потому что ее правильность не зависит
от каких-либо префиксных ключей.

  В любое время несколько первичных ключевых карт являются
@dfn{active (активными)} --- то есть используются для
поиска привязок ключей.  Это
@dfn{global map (глобальная карта)}, используется всеми
буферами; @dfn{local keymap (локальная ключевая карта)},
которая обычно связана с определенным основным режимом; и
ноль или более @dfn{minor mode keymaps} (ключевых карт
дополнительных режимов), которые относятся к текущим
включенным второстепенным режимам.  (Не все второстепенные
режимы имеют ключевые карты.)  Привязки локальной ключевой
затеняют (тоесть имеют приоритет) соответствующим глобальным
привязкам.  Ключевые карты вспомогательного режима затеняют
как локальные, так и глобальные ключевые карты.
@xref{Active Keymaps}, для деталей.

@node Format of Keymaps
@section Формат Ключевых Карт
@cindex format of keymaps
@cindex keymap format
@cindex full keymap
@cindex sparse keymap

  Каждая ключевая карта - это список, в котором @sc{car}
является символом @code{keymap}.  Остальные элементы списка
определяют ключевые привязки ключевой карты.  Символ, чьим
определением функции является ключевая карта, также является
ключевой картой.  Используйте функцию @code{keymapp} (см.
Ниже), чтобы проверить, является ли объект ключевой картой.

  После символа @code{keymap}, с которого она начинается, в
ключевой карте могут появиться несколько видов элементов:

@table @code
@item (@var{type} .@: @var{binding})
Это указывает одну привязку для событий типа @var{type}.
Каждая обычная привязка применяется к событиям определенного
@dfn{event type}, который всегда является символом или
символом.  @xref{Classifying Events}.  В этом виде привязки
@var{binding} - это команда.

@item (@var{type} @var{item-name} .@: @var{binding})
Это определяет привязку, которая также является простым
пунктом меню, который отображается в меню как
@var{item-name}.  @xref{Simple Menu Items}.

@item (@var{type} @var{item-name} @var{help-string} .@: @var{binding})
Это простой пункт меню со строкой справки @var{help-string}.

@item (@var{type} menu-item .@: @var{details})
Это указывает привязку, которая также является элементом
расширенного меню.  Это позволяет использовать другие
функции.  @xref{Extended Menu Items}.

@item (t .@: @var{binding})
@cindex default key binding
Это указывает @dfn{default key binding}; любому событию, не
связанному с другими элементами раскладки клавиатуры,
проводится @var{binding} в качестве привязки.  Привязки по
умолчанию позволяют ключевой карте связывать все возможные
типы событий без необходимости перечислять их все.  Ключевая
карта с привязкой по умолчанию полностью маскирует любую
ключевую карту с более низким приоритетом, за исключением
событий, явно привязанных к @code{nil} (см. Ниже).

@item @var{char-table}
Если элемент ключевой карты является символьной таблицей, он
считается удерживающим привязки для всех событий символов без
битов модификатора (@pxref{modifier bits}): элемент с
индексом @var{c} является привязкой для символа @var{c}.  Это
компактный способ записать множество привязок.  Ключевая
карта с такой символьной таблицей называется
@dfn{full keymap (полная ключевая карта)}.  Другие карты
называются @dfn{sparse keymaps (разреженные ключевые карты)}.

@item @var{vector}
Этот тип элементов похож на символьную таблицу: элемент с
индексом @var{c} является привязкой для символа @var{c}.
Поскольку диапазон символов, которые могут быть связаны таким
образом, ограничен размером вектора, а создание вектора
выделяет пространство для всех кодов символов от 0, этот
формат не следует использовать, за исключением создания
ключевых карт меню (@pxref{Menu Keymaps}), где сами привязки
не используются значение установленное в @code{t}.

@item @var{string}
@cindex keymap prompt string
@cindex overall prompt string
@cindex prompt string of keymap
Помимо элементов, которые задают ключевые привязки, ключевая
карта может иметь строку в качестве элемента.  Это называется
@dfn{overall prompt string (общая строка приглашения)} и
позволяет использовать ключевую карту в качестве меню.
@xref{Defining Menus}.

@item (keymap @dots{})
Если элемент ключевой карты сам по себе является ключевой
картой, он считается так, как если эта внутренняя карта была
встроена во внешнюю карту.  Это используется для
множественного наследования, например, в
@code{make-composed-keymap}.
@end table

Когда привязка - @code{nil}, она не является определением, но
имеет приоритет над привязкой по умолчанию или привязкой в
родительской ключевой карте.  С другой стороны, привязка
@code{nil} действительно @emph{not} переопределяет ключевых
карт с более низким приоритетом; таким образом, если
локальная карта дает привязку @code{nil}, Emacs использует
привязку из глобальной карты.

@cindex meta characters lookup
  Ключевые карты не записывают напрямую привязки для
метасимволов.  Вместо этого метасимволы рассматриваются в
целях поиска по ключу как последовательности из двух
символов, первый из которых - @key{ESC} (или любое другое
значение, которое в настоящее время является значением
@code{meta-prefix-char}).  Таким образом, ключ @kbd{M-a}
внутренне представлен как @kbd{@key{ESC} a}, а его глобальная
привязка находится в слоте для @kbd{a} в @code{esc-map}.
(@pxref{Prefix Keys}).

  Это преобразование применяется только к символам, а не к
функциональным клавишам или другим событиям ввода; таким
образом, @kbd{M-@key{end}} не имеет ничего общего с
@kbd{@key{ESC} @key{end}}.

  Вот как пример - локальная ключевая карта для режима Lisp,
разреженная ключевая карта.  Она определяет привязки для
@key{DEL}, @kbd{C-c C-z}, @kbd{C-M-q}, и @kbd{C-M-x}
(фактическое значение также содержит привязку меню, которая
здесь для краткости опущено).

@example
@group
lisp-mode-map
@result{}
@end group
@group
(keymap
 (3 keymap
    ;; @kbd{C-c C-z}
    (26 . run-lisp))
@end group
@group
 (27 keymap
     ;; @r{@kbd{C-M-x}, treated as @kbd{@key{ESC} C-x}}
     (24 . lisp-send-defun))
@end group
@group
 ;; @r{Эта часть унаследована от @code{lisp-mode-shared-map}.}
 keymap
 ;; @key{DEL}
 (127 . backward-delete-char-untabify)
@end group
@group
 (27 keymap
     ;; @r{@kbd{C-M-q}, рассматриваемый как @kbd{@key{ESC} C-q}}
     (17 . indent-sexp)))
@end group
@end example

@defun keymapp object
Эта функция возвращает @code{t}, если @var{object} - это
ключевая карта и @code{nil} в противном случае.  Точнее, эта
функция проверяет список, @sc{car} которого равен
@code{keymap} или символом, определение функции которого
удовлетворяет @code{keymapp}.

@example
@group
(keymapp '(keymap))
    @result{} t
@end group
@group
(fset 'foo '(keymap))
(keymapp 'foo)
    @result{} t
@end group
@group
(keymapp (current-global-map))
    @result{} t
@end group
@end example
@end defun

@node Creating Keymaps
@section Создание Ключевых Карт
@cindex creating keymaps

  Здесь описываются функции для создания ключевых карт.

@defun make-sparse-keymap &optional prompt
Эта функция создает и возвращает новую разреженную ключевую
карту без записей.  (Разреженная ключевая карта - это тип
ключевой карты, который обычно требуется.)  Новая ключевая
карта не содержит символ-таблицы, в отличие от
@code{make-keymap}, и не связывает никаких событий.

@example
@group
(make-sparse-keymap)
    @result{} (keymap)
@end group
@end example

Если указано @var{prompt}, это будет общей строкой
приглашения для ключевой карты.  Требуется указать это только
для ключевых карт меню (@pxref{Defining Menus}).  Ключевая
карта с общей строкой приглашения всегда будет представлять
меню мыши или меню клавиатуры, если она активна для поиска
следующего события ввода.  Не указывайте общую строку
приглашения для основной карты основного или второстепенного
режима, потому что это приведет к тому, что цикл команд будет
каждый раз отображать клавиатурное меню.
@end defun

@defun make-keymap &optional prompt
Эта функция создает и возвращает новую полную ключевую карту.
Эта карта содержит символ-таблицу (@pxref{Char-Tables}) со
слотами для всех символов без модификаторов.  Новая карта
изначально связывает все эти символы с @code{nil} и не
связывает никаких других событий.  Аргумент @var{prompt}
указывает строку приглашения, как и в
@code{make-sparse-keymap}.

@c Этот пример кажется бессмысленным, но я предполагаю, что
@c он служит для сравнения результата с make-sparse-keymap
@c описаной выше.
@example
@group
(make-keymap)
    @result{} (keymap #^[nil nil keymap nil nil nil @dots{}])
@end group
@end example

Полная ключевая карта более эффективна, чем разреженная,
когда содержит много привязок; иногда лучше использовать
разреженную ключевую карту.
@end defun

@defun copy-keymap keymap
Эта функция возвращает копию @var{keymap}.  В этом почти
никогда не бывает необходимости.  Если требуется карта,
схожая с другой, но с некоторыми изменениями, следует
использовать наследование карты, а не копирование.  То есть
что-то вроде:

@example
@group
(let ((map (make-sparse-keymap)))
  (set-keymap-parent map <theirmap>)
  (define-key map ...)
  ...)
@end group
@end example

При выполнении @code{copy-keymap} любые ключевые карты,
которые появляются непосредственно как привязки в
@var{keymap}, также рекурсивно копируются и так далее на
любое количество уровней.  Однако рекурсивное копирование не
происходит, если определение символа является символом,
определение функции которого является картой; тот же символ
появляется в новой копии.
@c Характерная черта для Emacs 19

@example
@group
(setq map (copy-keymap (current-local-map)))
@result{} (keymap
@end group
@group
     ;; @r{(Это реализует мета-символы.)}
     (27 keymap
         (83 . center-paragraph)
         (115 . center-line))
     (9 . tab-to-tab-stop))
@end group

@group
(eq map (current-local-map))
    @result{} nil
@end group
@group
(equal map (current-local-map))
    @result{} t
@end group
@end example
@end defun

@node Inheritance and Keymaps
@section Наследование и Ключевые Карты
@cindex keymap inheritance
@cindex inheritance, keymap

  Ключевая карта может наследовать привязки другой ключевой
карты, которая называется
@dfn{parent keymap (родительской ключевой картой)}.  Такая
ключевая карта выглядит так:

@example
(keymap @var{elements}@dots{} . @var{parent-keymap})
@end example

@noindent
Эффект состоит в том, что эта карта наследует все привязки
@var{parent-keymap} (родительской карты), какими бы они ни
были во время поиска ключа, но может добавлять к ним или
отменять их с помощью @var{elements}.

Если меняется привязка в @var{parent-keymap} с помощью
@code{define-key} или других функций привязки ключей, эти
измененные привязки будут видны в наследующей ключевой карте,
если только они не затенены привязками, сделанными
@var{elements}.  Обратное неверно: если используется
@code{define-key} для изменения привязок в наследующей
ключевой карте, эти изменения записываются в @var{elements},
но не влияют на @var{parent-keymap}.

Правильный способ создания ключевой карты с родительской -
использовать @code{set-keymap-parent}; если есть код, который
напрямую создает ключевую корту с родителем, пожалуйста,
преобразуйте программу, чтобы вместо этого использовать
@code{set-keymap-parent}.

@defun keymap-parent keymap
Это возвращает родительскую ключевую карту @var{keymap}.
Если @var{keymap} не имеет родителя, @code{keymap-parent}
возвращает @code{nil}.
@end defun

@defun set-keymap-parent keymap parent
Это устанавливает родительскую карту @var{parent} для карты
@var{keymap} и возвращает @var{parent}.  Если @var{parent}
равно @code{nil}, эта функция не устанавливает @var{keymap}
никакого родителя.

Если @var{keymap} имеет вложенные карты (привязки для
префиксных ключей), они также получают новые родительские
ключевые карты, которые отражают то, на что указывает
@var{parent} для этих префиксных ключей.
@end defun

   Вот пример, показывающий, как создать ключевую карту,
унаследованную от @code{text-mode-map}:

@example
(let ((map (make-sparse-keymap)))
  (set-keymap-parent map text-mode-map)
  map)
@end example

  У не разреженной карты тоже может быть родитель, но это не
очень полезно.  Неразрезанная карта всегда указывает что-то в
качестве привязки для каждого числового кода символа без
битов модификатора, даже если это @code{nil}, поэтому
привязки этих символов никогда не наследуются от родительской
карты.

@cindex keymap inheritance from multiple maps
  Иногда нужно создать ключевую карту, унаследованную от
более чем одной карты.  Для этого можно использовать функцию
@code{make-composed-keymap}.

@defun make-composed-keymap maps &optional parent
Эта функция возвращает новую ключевую карту, состоящую из
существующих карт @var{maps}, и необязательно наследующую от
родительской карты @var{parent}.  @var{maps} может быть одной
картой или списком из более чем одной.  При поиске ключа в
получившейся новой карте Emacs ищет по очереди в каждой из
@var{maps}, а затем в @var{parent}, останавливаясь на первом
совпадении.  Привязка @code{nil} в любой из @var{maps}
отменяет любую привязку в @var{parent}, но не отменяет
привязку не-@code{nil} в любой другой @var{maps}.
@end defun

@noindent Например, вот как Emacs устанавливает родителя
@code{help-mode-map}, так что он наследуется от
@code{button-buffer-map} и @code{special-mode-map}:

@example
(defvar help-mode-map
  (let ((map (make-sparse-keymap)))
    (set-keymap-parent map
      (make-composed-keymap button-buffer-map special-mode-map))
    ... map) ... )
@end example


@node Prefix Keys
@section Префиксные Ключи
@cindex prefix key

  @dfn{prefix key} - это последовательность ключей, привязкой
которой является ключевая карта.  Ключевая карта определяет,
что делать с последовательностями ключей, расширяющими
префиксный ключ.  Например, @kbd{C-x} - это префиксный ключ,
и он использует ключевую карту, которая также хранится в
переменной @code{ctl-x-map}.  Эта карта определяет привязки
для последовательностей ключей, начинающихся с @kbd{C-x}.

  Некоторые из стандартных префиксных ключей Emacs используют
ключевые карты, которые также находятся в переменных Lisp:

@itemize @bullet
@item
@vindex esc-map
@findex ESC-prefix
@code{esc-map} - это глобальная ключевая карта для
префиксного ключа @key{ESC}.  Таким образом, здесь можно
найти глобальные определения всех метасимволов.  Эта карта
также является определением функции @code{ESC-prefix}.

@item
@cindex @kbd{C-h}
@code{help-map} - это глобальная ключевая карта для
префиксного ключа @kbd{C-h}.

@item
@cindex @kbd{C-c}
@vindex mode-specific-map
@code{mode-specific-map} - это глобальная ключевая карта для
префиксного ключа @kbd{C-c}.  Эта карта на самом деле
является глобальной, а не зависящей от режима, но ее имя
предоставляет полезную информацию об @kbd{C-c} в выводе
@kbd{C-h b} (@code{display-bindings}), поскольку в основном
этот префиксный ключ используется для привязок, зависящих от
режима.

@item
@cindex @kbd{C-x}
@vindex ctl-x-map
@findex Control-X-prefix
@code{ctl-x-map} - это глобальная карта, используемая для
префиксного ключа @kbd{C-x}.  Эта карта находится через
функциональную ячейку символа @code{Control-X-prefix}.

@item
@cindex @kbd{C-x @key{RET}}
@vindex mule-keymap
@code{mule-keymap} - это глобальная карта, используемая для
префиксного ключа @kbd{C-x @key{RET}}.

@item
@cindex @kbd{C-x 4}
@vindex ctl-x-4-map
@code{ctl-x-4-map} - это глобальная карта, используемая для
префиксного ключа @kbd{C-x 4}.

@item
@cindex @kbd{C-x 5}
@vindex ctl-x-5-map
@code{ctl-x-5-map} - это глобальная карта, используемая для
префиксного ключа @kbd{C-x 5}.

@item
@cindex @kbd{C-x 6}
@vindex 2C-mode-map
@code{2C-mode-map} - это глобальная карта, используемая для
префиксного ключа @kbd{C-x 6}.

@item
@cindex @kbd{C-x v}
@vindex vc-prefix-map
@code{vc-prefix-map} - это глобальная карта, используемая для
префиксного ключа @kbd{C-x v}.

@item
@cindex @kbd{M-g}
@vindex goto-map
@code{goto-map} - это глобальная карта, используемая для
префиксного ключа @kbd{M-g}.

@item
@cindex @kbd{M-s}
@vindex search-map
@code{search-map} - это глобальная карта, используемая для
префиксного ключа @kbd{M-s}.

@item
@cindex @kbd{M-o}
@vindex facemenu-keymap
@code{facemenu-keymap} - это глобальная карта, используемая
для префиксного ключа @kbd{M-o}.

@item
Другие префиксные ключи Emacs - @kbd{C-x @@}, @kbd{C-x a i},
@kbd{C-x @key{ESC}} и @kbd{@key{ESC} @key{ESC}}.  Они
используют ключевые карты, у которых нет специальных имен.
@end itemize

  Привязка префиксного ключа к карте используется для поиска
события, следующего за префиксным ключом.  (Вместо этого это
может быть символ, определение функции которого является
ключевой картой.  Эффект тот же, но символ служит именем для
префиксного ключа).  Таким образом, привязка @kbd{C-x} - это
символ @code{Control-X-prefix}, функциональная ячейка
которого содержит ключевую карту для команд @kbd{C-x}.  (Та
же самая карта также является значением @code{ctl-x-map}.)

  Определения префиксных ключей могут отображаться в любой
активной ключевой карте.  Определения @kbd{C-c}, @kbd{C-x},
@kbd{C-h} и @key{ESC} как префиксных ключей появляются на
глобальной карте, поэтому эти префиксные ключи всегда
доступны.  Основной и второстепенный режимы могут
переопределить ключ как префикс, поместив определение
префиксного ключа для него в локальную карту или карту
второстепенного режима.  @xref{Active Keymaps}.

  Если ключ определен как префикс более чем в одной активной
карте, то его различные определения фактически объединяются:
сначала идут команды, определенные в ключевых картах
второстепенного режима, за ними следуют команды в определении
префикса локальной карты, а затем - команды из глобальной
карты.

  В следующем примере делается @kbd{C-p} префиксным ключом в
локальной таблице ключей таким образом, чтобы @kbd{C-p} был
идентичен @kbd{C-x}.  Тогда привязкой для @kbd{C-p C-f} будет
функция @code{find-file}, как и для @kbd{C-x C-f}.
Последовательность ключей @kbd{C-p 6} не найдена ни в одной
активной ключевой карте.

@example
@group
(use-local-map (make-sparse-keymap))
    @result{} nil
@end group
@group
(local-set-key "\C-p" ctl-x-map)
    @result{} nil
@end group
@group
(key-binding "\C-p\C-f")
    @result{} find-file
@end group

@group
(key-binding "\C-p6")
    @result{} nil
@end group
@end example

@defun define-prefix-command symbol &optional mapvar prompt
@cindex prefix command
@anchor{Definition of define-prefix-command}
Эта функция подготавливает @var{symbol} для использования в
качестве привязки префиксного ключа: она создает разреженную
ключевую карту и сохраняет ее как определение функции
@var{symbol}'s.  Последующее связывание ключевой
последовательности с @var{symbol} превратит эту ключевую
последовательность в префиксный ключ.  Возвращаемое значение
- @code{symbol}.

Эта функция также устанавливает @var{symbol} как переменную
со значением ключевой карты.  Но если @var{mapvar} равен
не-@code{nil}, вместо этого он устанавливает @var{mapvar} в
качестве переменной.

Если @var{prompt} равен не-@code{nil}, это становится общей
строкой приглашения для ключевой карты.  Строка подсказки
должна быть дана для раскладки меню (@pxref{Defining Menus}).
@end defun

@node Active Keymaps
@section Активные Ключевые Карты
@cindex active keymap

  Emacs содержит много ключевых карт, но в любой момент
только несколько карт являются активными @dfn{active}.  Когда
Emacs получает ввод пользователя, он переводит событие ввода
(@pxref{Translation Keymaps}) и ищет привязку ключа в
активных ключевых картах.

  Обычно активными ключевыми картами являются: (i) -
карта, заданная свойством @code{keymap}, (ii) - карта
задействованных второстепенных режимов, (iii) - локальная
карта текущего буфера и (iv) - глобальная карта, в указанном
порядке.  Emacs ищет каждую последовательность ключей ввода
во всех этих картах.

  Из этих обычных ключевых карт наивысший приоритет задается
с помощью свойства @code{keymap} text или overlay в точке,
если таковые имеются.  (Для события ввода мыши Emacs
использует позицию события вместо точки;
@iftex
подробности в следующем разделе.)
@end iftex
@ifnottex
@pxref{Searching Keymaps}.)
@end ifnottex

  Следующими по приоритету идут ключевые карты, заданные
включенными второстепенными режимами.
Эти карты, если они есть, задаются переменными
@code{emulation-mode-map-alists},
@code{minor-mode-overriding-map-alist} и
@code{minor-mode-map-alist}.  @xref{Controlling Active Maps}.

@cindex local keymap
  Следующим по приоритету идет локальная карта буфера
@dfn{local keymap}, содержащая привязки ключей, специфичных
для этого буфера.  В минибуфере также есть локальная ключевая
карта (@pxref{Intro to Minibuffers}).  Если в точке есть
текст @code{local-map} или свойство наложения, которое
определяет используемую локальную ключевую карту вместо
локальной ключевой карты по умолчанию.

@cindex major mode keymap
  Локальная ключевая карта обычно устанавливается основным режимом буфера, и
каждый буфер с таким же основным режимом использует одну и ту же локальную
карту.  Следовательно, если вызывается @code{local-set-key}
(@pxref{Key Binding Commands}) для изменения локальной карты в одном буфере,
это также влияет на локальные ключевые карты в других буферах с таким же
основным режимом.

@cindex global keymap
  Наконец, @dfn{global keymap} содержит привязки ключей, которые
определяются независимо от текущего буфера, например @kbd{C-f}.  Это
действует всегда и привязано к переменной @code{global-map}.

  Помимо вышеуказанных обычных привязок ключей, Emacs предоставляет
программам специальные способы сделать другие привязки активными.
Во-первых, переменная @code{overriding-local-map} указывает привязку ключей,
которая заменяет обычные активные привязки, за исключением глобальной
привязки ключей.  Во-вторых, локальная для терминала переменная
@code{overriding-terminal-local-map} указывает карту ключей, которая имеет
приоритет над @emph{всеми} другими картами ключей (включая
@code{overriding-local-map}); обычно это используется для
модальных/временных привязок ключей (функция @code{set-transient-map}
предоставляет для этого удобный интерфейс).  @xref{Controlling Active Maps},
для деталей.

  Активизация ключевой карты - не единственный способ её использования.
Карты также используются и другими способами, например, для перевода событий
в @code{read-key-sequence}.  @xref{Translation Keymaps}.

  @xref{Standard Keymaps}, для списка некоторых стандартных раскладок.

@defun current-active-maps &optional olp position
Это возвращает список активных ключевых карт, которые будут использоваться
циклом команд в текущих обстоятельствах для поиска последовательности
ключей.  Обычно игнорирует @code{overriding-local-map} и
@code{overriding-terminal-local-map}, но если @var{olp} равен не-@code{nil},
обращается на них внимание.  @var{position} может быть либо позицией
события, возвращаемой @code{event-start}, либо позицией буфера, и может
изменять привязку ключей, как описано для @code{key-binding}.
@end defun

@defun key-binding key &optional accept-defaults no-remap position
Эта функция возвращает привязку для @var{key} в соответствии с текущими
активными ключевыми картами.  Результатом будет @code{nil}, если @var{key}
не определен в ключевой карте.

Аргумент @var{accept-defaults} управляет проверкой привязок по умолчанию,
как в @code{lookup-key} (@pxref{Functions for Key Lookup}).

Когда команды переназначены (@pxref{Remapping Commands}), @code{key-binding}
обычно обрабатывает переназначения команд, чтобы вернуть переназначенную
команду, которая будет фактически выполнена.  Однако, если @var{no-remap}
установлено в не-@code{nil}, @code{key-binding} игнорирует переназначения и
возвращает привязку, прямо заданную для @var{key}.

Если @var{key} начинается с события мыши (возможно, после префиксного
события), карты, к которым следует обращаться, определяются на основе
положения события.  В противном случае они определяются на основе оценки
стоимимости.  Однако можно переопределить любой из них, указав
@var{position}.  Если @var{position} установлено в не-@code{nil}, это должна
быть позиция в буфере или позиция события, такая как значение
@code{event-start}.  Затем используемые карты определяются на основе
@var{position}.

Emacs сигнализирует об ошибке, если @var{key} не является строкой или
вектором.

@example
@group
(key-binding "\C-x\C-f")
    @result{} find-file
@end group
@end example
@end defun

@node Searching Keymaps
@section Поиск Активных Ключевых Карт
@cindex searching active keymaps for keys

Вот краткое изложение кода псевдо-Lisp, описывающий как Emacs ищет активные
ключевые карты:

@lisp
(or (if overriding-terminal-local-map
        (@var{find-in} overriding-terminal-local-map))
    (if overriding-local-map
        (@var{find-in} overriding-local-map)
      (or (@var{find-in} (get-char-property (point) 'keymap))
          (@var{find-in-any} emulation-mode-map-alists)
          (@var{find-in-any} minor-mode-overriding-map-alist)
          (@var{find-in-any} minor-mode-map-alist)
          (if (get-text-property (point) 'local-map)
              (@var{find-in} (get-char-property (point) 'local-map))
            (@var{find-in} (current-local-map)))))
    (@var{find-in} (current-global-map)))
@end lisp

@noindent
Здесь @var{find-in} и @var{find-in-any} - это псевдофункции, выполняющие
поиск по одной ключевой карте и по списку карт соответственно.  Обратите
внимание, что функция @code{set-transient-map} работает, устанавливая
@code{overriding-terminal-local-map} (@pxref{Controlling Active Maps}).

  В приведенном выше псевдокоде, если последовательность ключей начинается с
события мыши (@pxref{Mouse Events}), позиция этого события используется
вместо точки, а буфер события используется вместо текущего буфера.  В
частности, это влияет на поиск свойств @code{keymap} и @code{local-map}.
Если событие мыши происходит в строке, содержащей свойство @code{display},
@code{before-string} или @code{after-string} (@pxref{Special Properties}), и
строка имеет свойство не-@code{nil} для  @code{keymap} или @code{local-map},
которое переопределяет соответствующее свойство в тексте базового буфера
(т. е. Свойство, указанное в базовом тексте, игнорируется).

  Когда привязка ключа обнаружена в одной из активных ключевых карт, и эта
привязка является командой, поиск завершается - команда выполняется.
Однако, если привязка является символом со значением или строкой, Emacs
заменяет входные последовательности ключей значением переменной или строкой
и перезапускает поиск активных ключевых таблиц.  @xref{Key Lookup}.

  Наконец, найденную команду можно переназначить.
@xref{Remapping Commands}.

@node Controlling Active Maps
@section Управление Активными Ключевыми Картами
@cindex active keymap, controlling

@defvar global-map
Эта переменная содержит глобальную ключевую карту по умолчанию, которая
сопоставляет ввод с клавиатуры Emacs командам.  Глобальная карта ключей
обычно является этой картой.  Глобальная ключевая карта по умолчанию - это
полная карта, которая связывает @code{self-insert-command} со всеми
печатными символами.

Изменение привязки в глобальной ключевой карте является нормальной
практикой, но не нужно присваивать этой переменной какое-либо значение,
кроме ключевой карты, с которой всё начинается.
@end defvar

@defun current-global-map
Эта функция возвращает текущую глобальную ключевую карту.  Это то же самое,
что и значение @code{global-map}, если не изменено одно или другое.
Возвращаемое значение является ссылкой, а не копией; если используется
@code{define-key} или другие функции, изменяются глобальные привязки.

@example
@group
(current-global-map)
@result{} (keymap [set-mark-command beginning-of-line @dots{}
            delete-backward-char])
@end group
@end example
@end defun

@defun current-local-map
Эта функция возвращает локальную ключевую карту текущего буфера или
@code{nil}, если ее нет.  В следующем примере карта ключей для буфера
@file{*scratch*} (с использованием режима взаимодействия с Lisp)
представляет собой разреженную карту ключей, в которой запись для @key{ESC},
код 27 @acronym{ASCII}, является еще одной разреженной ключевой картой.

@example
@group
(current-local-map)
@result{} (keymap
    (10 . eval-print-last-sexp)
    (9 . lisp-indent-line)
    (127 . backward-delete-char-untabify)
@end group
@group
    (27 keymap
        (24 . eval-defun)
        (17 . indent-sexp)))
@end group
@end example
@end defun

@code{current-local-map} возвращает ссылку на локальную ключевую карту, а не
ее копию; если используется @code{define-key} или другие функции, изменяются
локальные привязки.

@defun current-minor-mode-maps
Эта функция возвращает список ключевых карт включенных в данный момент
второстепенными режимами.
@end defun

@defun use-global-map keymap
Эта функция делает @var{keymap} новой текущей глобальной картой.  Возвращает
@code{nil}.

Очень необычно менять глобальную ключевую карту.
@end defun

@defun use-local-map keymap
Эта функция делает @var{keymap} новой локальной ключевой картой текущего
буфера.  Если @var{keymap} установлено в @code{nil}, то в буфере нет
локальной ключевой карты.  @code{use-local-map} возвращает @code{nil}.
Большинство команд основного режима используют эту функцию.
@end defun

@defvar minor-mode-map-alist
@anchor{Definition of minor-mode-map-alist}
Эта переменная представляет собой список, описывающий карты ключей, которые
могут быть или не быть активными в соответствии со значениями определенных
переменных.  Его элементы выглядят так:

@example
(@var{variable} . @var{keymap})
@end example

Карта @var{keymap} активна всякий раз, когда @var{variable} имеет значение
не-@code{nil}.  Обычно @var{variable} - это переменная, которая включает или
отключает второстепенный режим.  @xref{Keymaps and Minor Modes}.

Обратите внимание, что элементы @code{minor-mode-map-alist} не имеют такой
же структуры, как элементы @code{minor-mode-alist}.  Карта должна быть
@sc{cdr} элемента; список с картой в качестве второго элемента не годится.
@sc{cdr} может быть ключевой картой (списком) или символом, с ячейкой
функции определением которой - ключевая карта.

Когда активна более чем одна карта ключей вспомогательного режима, более
ранняя в @code{minor-mode-map-alist} имеет приоритет.  Требуется разработать
второстепенные режимы так, чтобы они не мешали друг другу.  Если сделано это
правильно, порядок не будет иметь значения.

Смотреть @ref{Keymaps and Minor Modes}, для получения дополнительной
информации о второстепенных режимах.  See also @code{minor-mode-key-binding} (@pxref{Functions for Key Lookup}).
@end defvar

@defvar minor-mode-overriding-map-alist
Эта переменная позволяет основным режимам отменять привязки ключей для
определенных второстепенных режимов.  Элементы этого списка выглядят как
элементы @code{minor-mode-map-alist}:
@code{(@var{variable} . @var{keymap})}.

Если переменная появляется как элемент
@code{minor-mode-overriding-map-alist}, карта, указанная этим элементом,
полностью заменяет любую карту, указанную для той же переменной в
@code{minor-mode-map-alist}.

@code{minor-mode-overriding-map-alist} автоматически является локальным для
всех буферов.
@end defvar

@defvar overriding-local-map
Если установлена в не-@code{nil}, эта переменная содержит ключевую карту для
использования вместо локальной ключевой карты буфера, любого текстового
свойства или ключевой карты, а также любых карт вспомогательного режима.
Эта карта, если указана, отменяет все другие карты, которые были активными,
кроме текущей глобальной карты.
@end defvar

@defvar overriding-terminal-local-map
Если non-@code{nil}, эта переменная содержит ключевую карту для
использования вместо @code{overriding-local-map}, локальных карт ключей
буфера, текстовых свойств или налаживающихся ключевых карт, а также все
карты вспомогательного режима.

Эта переменная всегда является локальной для текущего терминала и не может
быть локальной для буфера.  @xref{Multiple Terminals}.  Она используется для
реализации режима инкрементного поиска.
@end defvar

@defvar overriding-local-map-menu-flag
Если эта переменная - не-@code{nil}, значение @code{overriding-local-map}
или @code{overriding-terminal-local-map} может повлиять на отображение строк
и меню.  Значение по умолчанию - @code{nil}, поэтому эти переменные карт
не влияют на строку меню.

Обратите внимание, что эти две переменные карт действительно влияют на
выполнение последовательностей ключей, вводимых с помощью строки меню, даже
если они не влияют на отображение строки меню.  Поэтому, если появляется
последовательность ключей в строке меню, требуется очистить переменные,
прежде чем искать и выполнять эту последовательность ключей.  Режимы, в
которых используются переменные, обычно делают это в любом случае; обычно
реагируют на события, которые не обрабатывают, путем не чтения ``unreading''
их и выхода.
@end defvar

@defvar special-event-map
Эта переменная содержит ключевую карту для особых событий.  Если тип события
имеет привязку в этой карте, то оно особенно, и привязка для события
запускается непосредственно @code{read-event}.  @xref{Special Events}.
@end defvar

@defvar emulation-mode-map-alists
Эта переменная содержит список списков раскладок для использования в режимах
эмуляции.  Она предназначен для режимов или пакетов, использующих несколько
карт вспомогательных режимов.  Каждый элемент представляет собой список
ключевой карты, который имеет тот же формат и значение, что и
@code{minor-mode-map-alist}, или символ с привязкой переменных, который
является таким списком.  Активные карты ключей в каждом списке используются
перед @code{minor-mode-map-alist} и @code{minor-mode-overriding-map-alist}.
@end defvar

@cindex transient keymap
@defun set-transient-map keymap &optional keep-pred on-exit
Эта функция добавляет @var{keymap} в качестве ключевой карты
@dfn{transient}, которая имеет приоритет над другими картами для одного (или
нескольких) последующих ключей.

Обычно @var{keymap} используется только один раз, чтобы найти следующий
ключ.  Если необязательный аргумент @var{keep-pred} - @code{t}, карта
остается активной, пока пользователь вводит ключи, определенные в
@var{keymap}; когда пользователь вводит ключ, которого нет в @var{keymap},
временная карта ключей деактивируется и для этого ключа продолжается обычный
поиск ключа.

Аргумент @var{keep-pred} также может быть функцией.  В этом случае функция
вызывается без аргументов перед запуском каждой команды, пока @var{keymap}
активен; это должно вернуть не-@code{nil}, в случае если @var{keymap}
остаётся в активном состоянии.

Необязательный аргумент @var{on-exit}, если не-@code{nil}, указывает
функцию, которая вызывается без аргументов после деактивации @var{keymap}.

Эта функция работает, добавляя и удаляя @var{keymap} из переменной
@code{overriding-terminal-local-map}, которая имеет приоритет над всеми
другими активными раскладками (@pxref{Searching Keymaps}).
@end defun

@node Key Lookup
@section Ключевой Поиск
@cindex key lookup
@cindex keymap entry

  @dfn{Key lookup (Key lookup)} - это процесс поиска привязки ключевой
последовательности из заданной ключевой карты.  Выполнение или использование
привязки не является частью поиска ключа.

  Поиск ключа использует только тип события каждого события в
последовательности ключей; остальная часть события игнорируется.
Фактически, последовательность ключей, используемая для поиска ключа, может
обозначать событие мыши только с его типами (символ) вместо всего события
(список).  @xref{Input Events}.  Такой последовательности ключей
недостаточно для запуска @code{command-execute}, но ее достаточно для поиска
или повторной привязки ключа.

  Когда последовательность ключей состоит из нескольких событий, поиск
ключей обрабатывает события последовательно: обнаруживается привязка первого
события, и оно должно быть картой ключей; затем в этой карте будет найдена
привязка второго события, и так до тех пор, пока не будут израсходованы все
события в последовательности ключей.  (Обнаруженная таким образом привязка
для последнего события может быть, а может и не быть ключевой картой). Таким
образом, процесс поиска ключа определяется в терминах более простого
процесса поиска одного события в карте ключей.  Как это делается, зависит от
типа объекта, связанного с событием в этой карте.

  Давайте использовать термин @dfn{keymap entry} для описания значения,
найденного при поиске типа события в карте ключей.  (Это не включает строку
элемента и другие дополнительные элементы в элементе ключевой карты для
пункта меню, потому что @code{lookup-key} и другие функции поиска ключей не
включают их в возвращаемое значение).  Хотя любой объект Lisp может
храниться в ключевой карте как запись ключевой карты, не все имеют смысл для
поиска ключа.  Вот таблица значимых типов записей ключевой карты:

@table @asis
@item @code{nil}
@cindex @code{nil} in keymap
@code{nil} означает, что события, использованные до сих пор в поиске,
образуют неопределенный ключ.  Когда в ключевой карте вообще не упоминается
тип события и нет привязки по умолчанию, это эквивалентно привязке
@code{nil} для этого типа события.

@item @var{command}
@cindex command in keymap
События, используемые до сих пор в поиске, образуют полный ключ, а
@var{command} является его привязкой.  @xref{What Is a Function}.

@item @var{array}
@cindex string in keymap
Массив (строка или вектор) - это макрос клавиатуры.  События, использованные
до сих пор в поиске, образуют полный ключ, а массив является его привязкой.
Смотреть @ref{Keyboard Macros}, для детальной информации.

@item @var{keymap}
@cindex keymap in keymap
События, использованные до сих пор в поиске, образуют префиксный ключ.
Следующее событие ключевой последовательности ищется в @var{keymap}.

@item @var{list}
@cindex list in keymap
Значение списка зависит от того, что он содержит:

@itemize @bullet
@item
Если @sc{car} для @var{list} является символом @code{keymap}, то список
является ключевой картой и рассматривается как карта (см. выше).

@item
@cindex @code{lambda} in keymap
Если @sc{car} для @var{list} - @code{lambda}, то список является
лямбда-выражением.  Предполагается, что это функция, и она рассматривается
как таковая (см. выше).  Чтобы правильно выполнять ключевую привязку, эта
функция должна быть командой - она должна иметь спецификацию
@code{interactive}.  @xref{Defining Commands}.
@end itemize

@item @var{symbol}
@cindex symbol in keymap
Определение функции @var{symbol} используется вместо @var{symbol}.  Если это
тоже символ, то этот процесс повторяется любое количество раз.  В конечном
итоге это должно привести к объекту, который является ключевой картой,
командой или макросом клавиатуры.

Обратите внимание, что ключевая карта и макросы клавиатуры (строки и
векторы) не являются допустимыми функциями, поэтому символ с картой, строкой
или вектором в качестве определения функции недействителен как функция.
Однако он действителен как привязка ключа.  Если определение является
клавиатурным макросом, то символ также действителен как аргумент для
@code{command-execute} (@pxref{Interactive Call}).

@cindex @code{undefined} in keymap
Особого упоминания заслуживает символ @code{undefined}: он означает, что
ключ считается неопределенным.  Строго говоря, ключ определен, а его
привязка - это команда @code{undefined}; но эта команда делает то же самое,
что автоматически делается для неопределенного ключа: она вызывает сигнал
колокольчик (вызывая @code{ding}), но не сигнализирует об ошибке.

@cindex preventing prefix key
@code{undefined} используется в локальных катах ключей, чтобы переопределить
привязку глобального ключа и сделать ключ неопределенным локально.
Локальная привязка @code{nil} не сможет этого сделать, потому что она не
переопределит глобальную привязку.

@item @var{anything else}
Если обнаружен какой-либо другой тип объекта, события, использованные до
сих пор в поиске, образуют полный ключ, а объект является его привязкой, но
привязка не может быть выполнена как команда.
@end table

  Короче говоря, запись ключевой карты может быть картой, командой, макросом
клавиатуры, символом, который ведет к одному из них, или @code{nil}.

@node Functions for Key Lookup
@section Функции Поиска Ключей

  Вот функции и переменные, относящиеся к поиску ключей.

@defun lookup-key keymap key &optional accept-defaults
Эта функция возвращает определение @var{key} в @var{keymap}.  Все другие
функции, описанные в этой главе, которые используют ключи поиска, используют
@code{lookup-key}.  Вот примеры:

@example
@group
(lookup-key (current-global-map) "\C-x\C-f")
    @result{} find-file
@end group
@group
(lookup-key (current-global-map) (kbd "C-x C-f"))
    @result{} find-file
@end group
@group
(lookup-key (current-global-map) "\C-x\C-f12345")
    @result{} 2
@end group
@end example

Если строка или вектор @var{key} не является допустимой последовательностью
ключей в соответствии с префиксными ключами, указанными в @var{keymap}, она
должна быть слишком длинной и иметь дополнительные события в конце, которые
не помещаются в одну последовательность ключей.  Тогда значение - это число,
количество событий перед @var{key}, которые составляют полный ключ.

@c Emacs 19 feature
Если @var{accept-defaults} равен не-@code{nil}, то @code{lookup-key}
учитывает привязки по умолчанию, а также привязки для определенных событий в
@var{key}.  В противном случае @code{lookup-key} сообщает только привязки
для конкретной последовательности @var{key}, игнорируя привязки по
умолчанию, кроме случаев, когда вы явно спрашиваете о них. (Для этого
поставьте @code{t} как элемент @var{key}; see @ref{Format of Keymaps}.)

Если @var{key} содержит метасимвол (не функциональную клавишу), этот символ
неявно заменяется двухсимвольной последовательностью: значением
@code{meta-prefix-char}, за которым следует соответствующий немета-символ.
Таким образом, первый пример ниже обрабатывается путем преобразования во
второй пример.

@example
@group
(lookup-key (current-global-map) "\M-f")
    @result{} forward-word
@end group
@group
(lookup-key (current-global-map) "\ef")
    @result{} forward-word
@end group
@end example

В отличие от @code{read-key-sequence}, эта функция не изменяет указанные
события способами, которые отбрасывают информацию
(@pxref{Key Sequence Input}).  В частности, он не преобразует буквы в нижний
регистр и не изменяет события перетаскивания на щелчки.
@end defun

@deffn Command undefined
Используется в картах для отмены определения ключей.  Вызывает @code{ding},
но не вызывает ошибки.
@end deffn

@defun local-key-binding key &optional accept-defaults
Эта функция возвращает привязку для @var{key} в текущей локальной карте
ключей или @code{nil}, если она там не определена.

@c Emacs 19 feature
Аргумент @var{accept-defaults} управляет проверкой привязок по умолчанию,
как в @code{lookup-key} (выше).
@end defun

@defun global-key-binding key &optional accept-defaults
Эта функция возвращает привязку для команды @var{key} в текущей глобальной
карте ключей или @code{nil}, если она там не определена.

@c Emacs 19 feature
Аргумент @var{accept-defaults} управляет проверкой привязок по умолчанию,
как в @code{lookup-key} (выше).
@end defun

@c Emacs 19 feature
@defun minor-mode-key-binding key &optional accept-defaults
Эта функция возвращает список всех активных привязок второстепенного режима
@var{key}.  Точнее, возвращает список пар
@code{(@var{modename} . @var{binding})}, где @var{modename} - это
переменная, которая включает второстепенный режим, а @var{binding} -
привязка @var{key} в этом режиме.  Если @var{key} не имеет привязок
второстепенного режима, значение будет @code{nil}..

Если первая найденная привязка не является определением префикса (карта
ключей или символ, определенный как ключевая карта), все последующие
привязки из других второстепенных режимов опускаются, поскольку они будут
полностью затенены.  Точно так же в списке отсутствуют привязки без
префикса, следующие за привязками префикса.

Аргумент @var{accept-defaults} управляет проверкой привязок по умолчанию,
как в @code{lookup-key} (выше).
@end defun

@defopt meta-prefix-char
@cindex @key{ESC}
Эта переменная представляет собой код символа мета-префикса.  Используется
для преобразования метасимвола в двухсимвольную последовательность, чтобы
его можно было найти в карте ключей.  Для получения полезных результатов
значение должно быть префиксом события (@pxref{Prefix Keys}).  Значение по
умолчанию - 27, это код @acronym{ASCII} для @key{ESC}.

Пока значение @code{meta-prefix-char} остается равным 27, поиск по ключу
преобразует @kbd{M-b} в @kbd{@key{ESC} b}, который обычно определяется как
команда @code{backward-word}.  Однако, если уставливается для
@code{meta-prefix-char} значение 24, код для @kbd{C-x}, то Emacs переведет
@kbd{M-b} в @kbd{C-x b}, стандартной привязкой которого является команда
@code{switch-to-buffer}.  (На самом деле не делайте этого!) Вот иллюстрация
того, что произойдет:

@smallexample
@group
meta-prefix-char                    ; @r{Значение по умолчанию.}
     @result{} 27
@end group
@group
(key-binding "\M-b")
     @result{} backward-word
@end group
@group
?\C-x                               ; @r{Печатное представление}
     @result{} 24                          ;   @r{символа.}
@end group
@group
(setq meta-prefix-char 24)
     @result{} 24
@end group
@group
(key-binding "\M-b")
     @result{} switch-to-buffer            ; @r{Теперь ввод @kbd{M-b} }
                                    ;   @r{похож на ввод @kbd{C-x b}.}

(setq meta-prefix-char 27)          ; @r{Избежать путаницы!}
     @result{} 27                  ; @r{Восстановить значение по умолчанию!}
@end group
@end smallexample

Такое преобразование одного события в два происходит только для сиволов, а
не для других типов событий ввода.  Таким образом, @kbd{M-@key{F1}},
функциональный ключ, не преобразуется в @kbd{@key{ESC} @key{F1}}.
@end defopt

@node Changing Key Bindings
@section Изменение Привязки Ключей
@cindex changing key bindings
@cindex rebinding

  Способ перепривязки ключей - изменить ее запись в ключевой карте.  Если 
изменяется привязка в глобальной ключевой карте, изменение будет действовать
во всех буферах (хотя оно не имеет прямого эффекта в буферах, которые
затеняют глобальную привязку локальной).  Если изменяется локальная карта
текущего буфера, это обычно влияет на все буферы, использующие один и тот же
основной режим.  Функции @code{global-set-key} и @code{local-set-key}
являются удобными интерфейсами для этих операций
(@pxref{Key Binding Commands}).  Также можно использовать @code{define-key},
более общую функцию; только потребуется явно указать карту, которую нужно
изменить.

  При выборе последовательностей ключей для повторной привязки программ
  Lisp, лучше, придерживаться соглашениям Emacs по использованию различных
  ключей (@pxref{Key Binding Conventions}).

@cindex meta character key constants
@cindex control character key constants
  При написании ключевой последовательности для повторной привязки хорошо
использовать специальные escape-последовательности для управляющих и
метасимволов (@pxref{String Type}).
Синтаксис @samp{\C-} означает, что следующий символ является управляющим, а @samp{\M-} означает, что следующий символ является метасимволом. Таким образом, строка @code{"\M-x"} читается как содержащая единственный @kbd{M-x}, @code{"\C-f"}, читается как содержащая единственный @kbd{C-f}, и
@code{"\M-\C-x"}, а @code{"\C-\M-x"} читается как содержащая единственный
@kbd{C-M-x}.  Также можно использовать этот escape-синтаксис в векторах, а
также там, где не разрешено в строках; один пример -
@samp{[?\C-\H-x home]}.  @xref{Character Type}.

  Функции определения ключа и поиска принимают альтернативный синтаксис для
типов событий в последовательности ключей, которая является вектором: можно
использовать список, содержащий имена модификаторов плюс одно базовое
событие (имя символа или функционального ключа).  Например,
@code{(control ?a)} эквивалентно @code{?\C-a}, а @code{(hyper control left)}
эквивалентно @code{C-H-left}.  Одним из преимуществ таких списков является
то, что точные числовые коды для битов модификатора не отображаются в
скомпилированных файлах.

  Приведенные ниже функции сигнализируют об ошибке, если @var{keymap} не
является ключевой картой или если @var{key} не является строкой или
вектором, представляющим ключевую последовательность.  Можно использовать
типы событий (символы) как сокращение для событий, которые являются
списками.  @code{kbd} функция (@pxref{Key Sequences}) - удобный способ
указать ключевую последовательность.

@defun define-key keymap key binding
Эта функция устанавливает привязку для @var{key} в @var{keymap}.  (Если
@var{key} имеет длину более одного события, изменение фактически выполняется
в другой ключевой карте, полученной из @var{keymap}).  Аргумент
@var{binding} может быть любым объектом Lisp, но только определенные типы
имеют смысл.  (Список значимых типов смотри в @ref{Key Lookup}).  Значение,
возвращаемое @code{define-key}, - @var{binding}.

Если @var{key} - @code{[t]}, это устанавливает привязку по умолчанию в
@var{keymap}.  Когда событие не имеет собственной привязки, командный цикл
Emacs использует привязку по умолчанию для карты ключей, если таковая
имеется.

@cindex invalid prefix key error
@cindex key sequence error
Каждый префикс @var{key} должен быть префиксным ключом (т. е. привязанным к
ключевой карте) или быть неопределенным; в противном случае сигнализируется
ошибка.  Если какой-то префиксный @var{key} не определен, то
@code{define-key} определяет его как префиксный ключ, так что остальная
часть @var{key} может быть определена как указано.

Если ранее в @var{keymap} не было привязки для @var{key}, новая привязка
добавляется в начало @var{keymap}.  Порядок привязок в ключевой карте не
имеет значения для ключевой карты, но имеет значение для карт меню
(@pxref{Menu Keymaps}).
@end defun

  В этом примере создается разреженная ключевая карта и выполняется
  ряд привязок к ней:

@smallexample
@group
(setq map (make-sparse-keymap))
    @result{} (keymap)
@end group
@group
(define-key map "\C-f" 'forward-char)
    @result{} forward-char
@end group
@group
map
    @result{} (keymap (6 . forward-char))
@end group

@group
;;@r{Создайте разреженную подкарту для @kbd{C-x} и привяжите к ней @kbd{f}.}
(define-key map (kbd "C-x f") 'forward-word)
    @result{} forward-word
@end group
@group
map
@result{} (keymap
    (24 keymap                ; @kbd{C-x}
        (102 . forward-word)) ;      @kbd{f}
    (6 . forward-char))       ; @kbd{C-f}
@end group

@group
;; @r{Привязать @kbd{C-p} к @code{ctl-x-map}}.
(define-key map (kbd "C-p") ctl-x-map)
;; @code{ctl-x-map}
@result{} [nil @dots{} find-file @dots{} backward-kill-sentence]
@end group

@group
;; @r{Привязать @kbd{C-f} к @code{foo} в @code{ctl-x-map}.}
(define-key map (kbd "C-p C-f") 'foo)
@result{} 'foo
@end group
@group
map
@result{} (keymap  ; @r{Обратите внимание на @code{foo} в @code{ctl-x-map}.}
    (16 keymap [nil @dots{} foo @dots{} backward-kill-sentence])
    (24 keymap
        (102 . forward-word))
    (6 . forward-char))
@end group
@end smallexample

@noindent
Обратите внимание, что сохранение новой привязки для @kbd{C-p C-f} на самом
деле работает путем изменения записи в @code{ctl-x-map}, и это имеет эффект
изменения привязок как @kbd{C-p C-f}, так и @kbd{C-x C-f} на глобальной
карте по умолчанию.

  Функция @code{substitute-key-definition} сканирует ключевую карту на
предмет ключей с определенной привязкой и повторно связывает их с другой
привязкой.  Еще одна функция, более понятная и часто приводящая к тем же
результатам, - переназначение одной команды на другую
(@pxref{Remapping Commands}).

@defun substitute-key-definition olddef newdef keymap &optional oldmap
@cindex replace bindings
Эта функция заменяет @var{olddef} на @var{newdef} для любых ключей в
@var{keymap}, которые были привязаны к @var{olddef}.  Другими словами,
@var{olddef} заменяется на @var{newdef} везде, где это появляется.  Функция
возвращает @code{nil}.

Например, это переопределяет @kbd{C-x C-f}, если вы делаете это в Emacs со
стандартными привязками:

@smallexample
@group
(substitute-key-definition
 'find-file 'find-file-read-only (current-global-map))
@end group
@end smallexample

@c Emacs 19 feature
Если @var{oldmap} равен не-@code{nil}, это меняет поведение
@code{substitute-key-definition}: привязки в @var{oldmap} определяют, какие
ключи нужно повторно привязать.  Повторные привязки по-прежнему происходят
в @var{keymap}, а не в @var{oldmap}.  Таким образом, можно изменять одну
карту под управлением привязок в другой.  Например,

@smallexample
(substitute-key-definition
  'delete-backward-char 'my-funny-delete
  my-map global-map)
@end smallexample

@noindent
помещает специальную команду удаления в @code{my-map} для тех ключей,
которые глобально привязаны к стандартной команде удаления.

Вот пример, показывающий ключевую карту до и после замены:

@smallexample
@group
(setq map '(keymap
            (?1 . olddef-1)
            (?2 . olddef-2)
            (?3 . olddef-1)))
@result{} (keymap (49 . olddef-1) (50 . olddef-2) (51 . olddef-1))
@end group

@group
(substitute-key-definition 'olddef-1 'newdef map)
@result{} nil
@end group
@group
map
@result{} (keymap (49 . newdef) (50 . olddef-2) (51 . newdef))
@end group
@end smallexample
@end defun

@defun suppress-keymap keymap &optional nodigits
@cindex @code{self-insert-command} override
Эта функция изменяет содержимое полной ключевой карты @var{keymap} путем
переназначения @code{self-insert-command} на команду @code{undefined}
(@pxref{Remapping Commands}).  Это приводит к отмене определения всех
печатных символов, что делает невозможным обычную вставку текста.
@code{suppress-keymap} возвращает @code{nil}.

Если @var{nodigits} равен @code{nil}, тогда @code{suppress-keymap}
определяет цифры для запуска @code{digit-argument}, а @kbd{-} - для
@code{negative-argument}.  В противном случае он делает их неопределенными,
как и остальные печатные символы.

@cindex yank suppression
@cindex @code{quoted-insert} suppression
Функция @code{suppress-keymap} не делает невозможным изменение буфера, так
как не подавляет такие команды, как @code{yank} и @code{quoted-insert}.
Чтобы предотвратить любую модификацию буфера, сделайте его доступным только
для чтения (@pxref{Read Only Buffers}).

Поскольку эта функция изменяет @var{keymap}, обычно используют ее для вновь
созданной ключевой карты.  Работа с существующей ключевой картой, которая
используется для других целей, может вызвать проблемы; например, подавление
@code{global-map} сделало бы невозможным в большинстве использование Emacs.

Эта функция может использоваться для инициализации локальной ключевой карты
основного режима, для которого вставка текста нежелательна.  Но обычно такой
режим должен быть производным от @code{special-mode}
(@pxref{Basic Major Modes}); тогда его карта будет автоматически
унаследована от @code{special-mode-map}, который уже подавлен.  Вот как
определяется @code{special-mode-map}:

@smallexample
@group
(defvar special-mode-map
  (let ((map (make-sparse-keymap)))
    (suppress-keymap map)
    (define-key map "q" 'quit-window)
    @dots{}
    map))
@end group
@end smallexample
@end defun

@node Remapping Commands
@section Команды Переназначения
@cindex remapping commands

  Для преобразования одной команды в другую можно использовать особый вид
привязки ключей, не обращаясь к последовательности (последовательностям)
ключей, привязанной к исходной команде.  Чтобы использовать эту функцию,
сделайте привязку ключей для последовательности ключей, которая начинается с
фиктивного события @code{remap}, за которым следует имя команды, которую вы
хотите переназначить; для привязки укажите новое определение (обычно имя
команды, но возможно любое другое допустимое определение для привязки
ключа).

  Например, предположим, что в моем режиме есть специальная команда
@code{my-kill-line}, которую нужно вызывать вместо @code{kill-line}.  Чтобы
установить это, его карта режима должна содержать следующее переназначение:

@smallexample
(define-key my-mode-map [remap kill-line] 'my-kill-line)
@end smallexample

@noindent
Затем, всякий раз, когда @code{my-mode-map} активен, если пользователь
вводит @kbd{C-k} (последовательность глобальных ключей по умолчанию для
@code{kill-line}), Emacs вместо этого запускает @code{my-kill-line}).

  Обратите внимание, что переназначение происходит только через активные
ключевые карты; например, повторное отображение в префиксной ключевой карте,
такой как @code{ctl-x-map}, обычно не имеет никакого эффекта, поскольку
такие карты сами по себе не активны.  Кроме того, переназначение работает
только на одном уровне; в следующем примере,

@smallexample
(define-key my-mode-map [remap kill-line] 'my-kill-line)
(define-key my-mode-map [remap my-kill-line] 'my-other-kill-line)
@end smallexample

@noindent
@code{kill-line} - это @emph{not}, преобразованный в
@code{my-other-kill-line}.  Вместо этого, если обычная ключевая привязка
@code{kill-line}, она преобразуется в @code{my-kill-line}; если обычная
привязка указывает @code{my-kill-line}, она преобразуется в
@code{my-other-kill-line}.

Чтобы отменить переназначение команды, переназначьте ее на @code{nil};

@smallexample
(define-key my-mode-map [remap kill-line] nil)
@end smallexample

@defun command-remapping command &optional position keymaps
Эта функция возвращает переназначение для @var{command} (символа), учитывая
текущие активные ключевые карты.  Если @var{command} не переназначено (что
является обычной ситуацией) или не является символом, функция возвращает
@code{nil}.  @code{position} может дополнительно указывать позицию в буфере
или позицию события для определения используемых ключевых карт, как в
@code{key-binding}.

Если необязательный аргумент @code{keymaps} - не-@code{nil}, он задает
список таблиц ключей для поиска.  Этот аргумент игнорируется, если
@code{position} - не-@code{nil}.
@end defun

@node Translation Keymaps
@section Карты для Трансляции Последовательностей Событий
@cindex translation keymap
@cindex keymaps for translating events

  Когда функция @code{read-key-sequence} считывает последовательность ключей
(@pxref{Key Sequence Input}), она использует @dfn{translation keymaps} для
преобразования одних последовательностей событий в другие.  Карты
преобразования - @code{input-decode-map}, @code{local-function-key-map} и
@code{key-translation-map} (в порядке приоритета).

  Ключевые карты трансляции имеют ту же структуру, что и другие карты
ключей, но используются по-другому: они определяют переводы, которые
необходимо сделать при чтении последовательностей ключей, а не привязки для
полных последовательностей ключей.  При чтении каждой ключевой
последовательности она проверяется на соответствие каждой карты перевода.
Если одна из карт трансляции связывает @var{k} с вектором @var{v}, то всякий
раз, когда @var{k} появляется как подпоследовательность @emph{anywhere} в
ключевой последовательности, эта подпоследовательность заменяется событиями
в @var{v}.

  Например, терминалы VT100 отправляют @kbd{@key{ESC} O P} при нажатии на
клавиатуре клавиши @key{PF1}. На таких терминалах Emacs должен преобразовать
эту последовательность событий в одно событие @code{pf1}.  Это делается
привязкой @kbd{@key{ESC} O P} к @code{[pf1]} в @code{input-decode-map}.
Таким образом, когда вводитя @kbd{C-c @key{PF1}} на терминале, терминал
выдает последовательность символов @kbd{C-c @key{ESC} O P}, а
@code{read-key-sequence} переводит ее обратно в @kbd{C-c @key{PF1}} и
возвращает его как вектор @code{[?\C-c pf1]}.

  Карты трансляции вступают в силу только после того, как Emacs декодирует
ввод с клавиатуры (через систему кодирования ввода, заданную параметром
@code{keyboard-coding-system}).  @xref{Terminal I/O Encoding}.

@defvar input-decode-map
Эта переменная содержит ключевую карьу, которая описывает последовательности
символов, отправляемые функциональными клавишами на обычном символьном
терминале.

Значение @code{input-decode-map} обычно устанавливается автоматически в
соответствии с записью Terminfo или Termcap терминала, но иногда им нужна
помощь из файлов Lisp, специфичных для терминала.  Emacs поставляется со
специфическими для терминала файлами для многих общих терминалов; их
основная цель - делать записи в @code{input-decode-map} помимо тех, которые
можно вывести из Termcap и Terminfo.  @xref{Terminal-Specific}.
@end defvar

@defvar local-function-key-map
Эта переменная содержит ключевую карту, аналогичную @code{input-decode-map},
за исключением того, что она описывает последовательности ключей, которые
должны быть переведены в альтернативные интерпретации, которые обычно
предпочтительнее.  Применяется после @code{input-decode-map} и до
@code{key-translation-map}.

Записи в @code{local-function-key-map} игнорируются, если они конфликтуют с
привязками, сделанными в второстепенном режиме, локальных или глобальных
ключевых картах.  То есть переназначение применяется только в том случае,
если исходная последовательность ключей в противном случае не имела бы
привязки.

@code{local-function-key-map} наследуется от @code{function-key-map}, но
последний не следует использовать напрямую.
@end defvar

@defvar key-translation-map
Эта переменная - еще одна карта, используемая так же, как
@code{input-decode-map}, для преобразования событий ввода в другие события.
Это отличается от @code{input-decode-map} тем, что начинает работать после
завершения @code{local-function-key-map}, а не до него; получаются
результаты перевода по @code{local-function-key-map}.

Как и @code{input-decode-map}, но в отличие от
@code{local-function-key-map}, эта карта применяется независимо от того,
имеет ли входная последовательность ключей нормальную привязку.  Однако
обратите внимание, что фактические привязки ключей могут влиять на
@code{key-translation-map}, даже если они там переопределяются.
Действительно, фактические привязки ключей переопределяют
@code{local-function-key-map} и, таким образом, могут изменять
последовательность ключей, которую получает @code{key-translation-map}.
Ясно, что таких ситуаций лучше избегать.

Назначение @code{key-translation-map} состоит в том, чтобы пользователи
отображали один набор символов в другой, включая обычные символы, обычно
связанные с @code{self-insert-command}.
@end defvar

@cindex key translation function
You can use @code{input-decode-map}, @code{local-function-key-map},
and @code{key-translation-map} for more than simple aliases, by using
a function, instead of a key sequence, as the translation of a
key.  Then this function is called to compute the translation of that
key.

The key translation function receives one argument, which is the prompt
that was specified in @code{read-key-sequence}---or @code{nil} if the
key sequence is being read by the editor command loop.  In most cases
you can ignore the prompt value.

If the function reads input itself, it can have the effect of altering
the event that follows.  For example, here's how to define @kbd{C-c h}
to turn the character that follows into a Hyper character:

@example
@group
(defun hyperify (prompt)
  (let ((e (read-event)))
    (vector (if (numberp e)
                (logior (lsh 1 24) e)
              (if (memq 'hyper (event-modifiers e))
                  e
                (add-event-modifier "H-" e))))))

(defun add-event-modifier (string e)
  (let ((symbol (if (symbolp e) e (car e))))
    (setq symbol (intern (concat string
                                 (symbol-name symbol))))
    (if (symbolp e)
        symbol
      (cons symbol (cdr e)))))

(define-key local-function-key-map "\C-ch" 'hyperify)
@end group
@end example

@subsection Interaction with normal keymaps

The end of a key sequence is detected when that key sequence either is bound
to a command, or when Emacs determines that no additional event can lead
to a sequence that is bound to a command.

This means that, while @code{input-decode-map} and @code{key-translation-map}
apply regardless of whether the original key sequence would have a binding, the
presence of such a binding can still prevent translation from taking place.
For example, let us return to our VT100 example above and add a binding for
@kbd{C-c @key{ESC}} to the global map; now when the user hits @kbd{C-c
@key{PF1}} Emacs will fail to decode @kbd{C-c @key{ESC} O P} into @kbd{C-c
@key{PF1}} because it will stop reading keys right after @kbd{C-x @key{ESC}},
leaving @kbd{O P} for later.  This is in case the user really hit @kbd{C-c
@key{ESC}}, in which case Emacs should not sit there waiting for the next key
to decide whether the user really pressed @kbd{@key{ESC}} or @kbd{@key{PF1}}.

For that reason, it is better to avoid binding commands to key sequences where
the end of the key sequence is a prefix of a key translation.  The main such
problematic suffixes/prefixes are @kbd{@key{ESC}}, @kbd{M-O} (which is really
@kbd{@key{ESC} O}) and @kbd{M-[} (which is really @kbd{@key{ESC} [}).

@node Key Binding Commands
@section Commands for Binding Keys

  This section describes some convenient interactive interfaces for
changing key bindings.  They work by calling @code{define-key}.

  People often use @code{global-set-key} in their init files
(@pxref{Init File}) for simple customization.  For example,

@smallexample
(global-set-key (kbd "C-x C-\\") 'next-line)
@end smallexample

@noindent
or

@smallexample
(global-set-key [?\C-x ?\C-\\] 'next-line)
@end smallexample

@noindent
or

@smallexample
(global-set-key [(control ?x) (control ?\\)] 'next-line)
@end smallexample

@noindent
redefines @kbd{C-x C-\} to move down a line.

@smallexample
(global-set-key [M-mouse-1] 'mouse-set-point)
@end smallexample

@noindent
redefines the first (leftmost) mouse button, entered with the Meta key, to
set point where you click.

@cindex non-@acronym{ASCII} text in keybindings
  Be careful when using non-@acronym{ASCII} text characters in Lisp
specifications of keys to bind.  If these are read as multibyte text, as
they usually will be in a Lisp file (@pxref{Loading Non-ASCII}), you
must type the keys as multibyte too.  For instance, if you use this:

@smallexample
(global-set-key "ö" 'my-function) ; bind o-umlaut
@end smallexample

@noindent
or

@smallexample
(global-set-key ?ö 'my-function) ; bind o-umlaut
@end smallexample

@noindent
and your language environment is multibyte Latin-1, these commands
actually bind the multibyte character with code 246, not the byte
code 246 (@kbd{M-v}) sent by a Latin-1 terminal.  In order to use this
binding, you need to teach Emacs how to decode the keyboard by using an
appropriate input method (@pxref{Input Methods, , Input Methods, emacs, The GNU
Emacs Manual}).

@deffn Command global-set-key key binding
This function sets the binding of @var{key} in the current global map
to @var{binding}.

@smallexample
@group
(global-set-key @var{key} @var{binding})
@equiv{}
(define-key (current-global-map) @var{key} @var{binding})
@end group
@end smallexample
@end deffn

@deffn Command global-unset-key key
@cindex unbinding keys
This function removes the binding of @var{key} from the current
global map.

One use of this function is in preparation for defining a longer key
that uses @var{key} as a prefix---which would not be allowed if
@var{key} has a non-prefix binding.  For example:

@smallexample
@group
(global-unset-key "\C-l")
    @result{} nil
@end group
@group
(global-set-key "\C-l\C-l" 'redraw-display)
    @result{} nil
@end group
@end smallexample

This function is equivalent to using @code{define-key} as follows:

@smallexample
@group
(global-unset-key @var{key})
@equiv{}
(define-key (current-global-map) @var{key} nil)
@end group
@end smallexample
@end deffn

@deffn Command local-set-key key binding
This function sets the binding of @var{key} in the current local
keymap to @var{binding}.

@smallexample
@group
(local-set-key @var{key} @var{binding})
@equiv{}
(define-key (current-local-map) @var{key} @var{binding})
@end group
@end smallexample
@end deffn

@deffn Command local-unset-key key
This function removes the binding of @var{key} from the current
local map.

@smallexample
@group
(local-unset-key @var{key})
@equiv{}
(define-key (current-local-map) @var{key} nil)
@end group
@end smallexample
@end deffn

@node Scanning Keymaps
@section Scanning Keymaps
@cindex scanning keymaps
@cindex keymaps, scanning

  This section describes functions used to scan all the current keymaps
for the sake of printing help information.

@defun accessible-keymaps keymap &optional prefix
This function returns a list of all the keymaps that can be reached (via
zero or more prefix keys) from @var{keymap}.  The value is an
association list with elements of the form @code{(@var{key} .@:
@var{map})}, where @var{key} is a prefix key whose definition in
@var{keymap} is @var{map}.

The elements of the alist are ordered so that the @var{key} increases
in length.  The first element is always @code{([] .@: @var{keymap})},
because the specified keymap is accessible from itself with a prefix of
no events.

If @var{prefix} is given, it should be a prefix key sequence; then
@code{accessible-keymaps} includes only the submaps whose prefixes start
with @var{prefix}.  These elements look just as they do in the value of
@code{(accessible-keymaps)}; the only difference is that some elements
are omitted.

In the example below, the returned alist indicates that the key
@key{ESC}, which is displayed as @samp{^[}, is a prefix key whose
definition is the sparse keymap @code{(keymap (83 .@: center-paragraph)
(115 .@: foo))}.

@smallexample
@group
(accessible-keymaps (current-local-map))
@result{}(([] keymap
      (27 keymap   ; @r{Note this keymap for @key{ESC} is repeated below.}
          (83 . center-paragraph)
          (115 . center-line))
      (9 . tab-to-tab-stop))
@end group

@group
   ("^[" keymap
    (83 . center-paragraph)
    (115 . foo)))
@end group
@end smallexample

In the following example, @kbd{C-h} is a prefix key that uses a sparse
keymap starting with @code{(keymap (118 . describe-variable)@dots{})}.
Another prefix, @kbd{C-x 4}, uses a keymap which is also the value of
the variable @code{ctl-x-4-map}.  The event @code{mode-line} is one of
several dummy events used as prefixes for mouse actions in special parts
of a window.

@smallexample
@group
(accessible-keymaps (current-global-map))
@result{} (([] keymap [set-mark-command beginning-of-line @dots{}
                   delete-backward-char])
@end group
@group
    ("^H" keymap (118 . describe-variable) @dots{}
     (8 . help-for-help))
@end group
@group
    ("^X" keymap [x-flush-mouse-queue @dots{}
     backward-kill-sentence])
@end group
@group
    ("^[" keymap [mark-sexp backward-sexp @dots{}
     backward-kill-word])
@end group
    ("^X4" keymap (15 . display-buffer) @dots{})
@group
    ([mode-line] keymap
     (S-mouse-2 . mouse-split-window-horizontally) @dots{}))
@end group
@end smallexample

@noindent
These are not all the keymaps you would see in actuality.
@end defun

@defun map-keymap function keymap
The function @code{map-keymap} calls @var{function} once
for each binding in @var{keymap}.  It passes two arguments,
the event type and the value of the binding.  If @var{keymap}
has a parent, the parent's bindings are included as well.
This works recursively: if the parent has itself a parent, then the
grandparent's bindings are also included and so on.

This function is the cleanest way to examine all the bindings
in a keymap.
@end defun

@defun where-is-internal command &optional keymap firstonly noindirect no-remap
This function is a subroutine used by the @code{where-is} command
(@pxref{Help, , Help, emacs,The GNU Emacs Manual}).  It returns a list
of all key sequences (of any length) that are bound to @var{command} in a
set of keymaps.

The argument @var{command} can be any object; it is compared with all
keymap entries using @code{eq}.

If @var{keymap} is @code{nil}, then the maps used are the current active
keymaps, disregarding @code{overriding-local-map} (that is, pretending
its value is @code{nil}).  If @var{keymap} is a keymap, then the
maps searched are @var{keymap} and the global keymap.  If @var{keymap}
is a list of keymaps, only those keymaps are searched.

Usually it's best to use @code{overriding-local-map} as the expression
for @var{keymap}.  Then @code{where-is-internal} searches precisely
the keymaps that are active.  To search only the global map, pass the
value @code{(keymap)} (an empty keymap) as @var{keymap}.

If @var{firstonly} is @code{non-ascii}, then the value is a single
vector representing the first key sequence found, rather than a list of
all possible key sequences.  If @var{firstonly} is @code{t}, then the
value is the first key sequence, except that key sequences consisting
entirely of @acronym{ASCII} characters (or meta variants of @acronym{ASCII}
characters) are preferred to all other key sequences and that the
return value can never be a menu binding.

If @var{noindirect} is non-@code{nil}, @code{where-is-internal} doesn't look
inside menu-items to find their commands.  This makes it possible to search for
a menu-item itself.

The fifth argument, @var{no-remap}, determines how this function
treats command remappings (@pxref{Remapping Commands}).  There are two
cases of interest:

@table @asis
@item If a command @var{other-command} is remapped to @var{command}:
If @var{no-remap} is @code{nil}, find the bindings for
@var{other-command} and treat them as though they are also bindings
for @var{command}.  If @var{no-remap} is non-@code{nil}, include the
vector @code{[remap @var{other-command}]} in the list of possible key
sequences, instead of finding those bindings.

@item If @var{command} is remapped to @var{other-command}:
If @var{no-remap} is @code{nil}, return the bindings for
@var{other-command} rather than @var{command}.  If @var{no-remap} is
non-@code{nil}, return the bindings for @var{command}, ignoring the
fact that it is remapped.
@end table
@end defun

@deffn Command describe-bindings &optional prefix buffer-or-name
This function creates a listing of all current key bindings, and
displays it in a buffer named @file{*Help*}.  The text is grouped by
modes---minor modes first, then the major mode, then global bindings.

If @var{prefix} is non-@code{nil}, it should be a prefix key; then the
listing includes only keys that start with @var{prefix}.

When several characters with consecutive @acronym{ASCII} codes have the
same definition, they are shown together, as
@samp{@var{firstchar}..@var{lastchar}}.  In this instance, you need to
know the @acronym{ASCII} codes to understand which characters this means.
For example, in the default global map, the characters @samp{@key{SPC}
..@: ~} are described by a single line.  @key{SPC} is @acronym{ASCII} 32,
@kbd{~} is @acronym{ASCII} 126, and the characters between them include all
the normal printing characters, (e.g., letters, digits, punctuation,
etc.@:); all these characters are bound to @code{self-insert-command}.

If @var{buffer-or-name} is non-@code{nil}, it should be a buffer or a
buffer name.  Then @code{describe-bindings} lists that buffer's bindings,
instead of the current buffer's.
@end deffn

@node Menu Keymaps
@section Menu Keymaps
@cindex menu keymaps

A keymap can operate as a menu as well as defining bindings for
keyboard keys and mouse buttons.  Menus are usually actuated with the
mouse, but they can function with the keyboard also.  If a menu keymap
is active for the next input event, that activates the keyboard menu
feature.

@menu
* Defining Menus::     How to make a keymap that defines a menu.
* Mouse Menus::        How users actuate the menu with the mouse.
* Keyboard Menus::     How users actuate the menu with the keyboard.
* Menu Example::       Making a simple menu.
* Menu Bar::           How to customize the menu bar.
* Tool Bar::           A tool bar is a row of images.
* Modifying Menus::    How to add new items to a menu.
* Easy Menu::      A convenience macro for making menus.
@end menu

@node Defining Menus
@subsection Defining Menus
@cindex defining menus
@cindex menu prompt string
@cindex prompt string (of menu)
@cindex menu item

A keymap acts as a menu if it has an @dfn{overall prompt string},
which is a string that appears as an element of the keymap.
(@xref{Format of Keymaps}.)  The string should describe the purpose of
the menu's commands.  Emacs displays the overall prompt string as the
menu title in some cases, depending on the toolkit (if any) used for
displaying menus.@footnote{It is required for menus which do not use a
toolkit, e.g., on a text terminal.}  Keyboard menus also display the
overall prompt string.

The easiest way to construct a keymap with a prompt string is to
specify the string as an argument when you call @code{make-keymap},
@code{make-sparse-keymap} (@pxref{Creating Keymaps}), or
@code{define-prefix-command} (@pxref{Definition of
define-prefix-command}).  If you do not want the keymap to operate as
a menu, don't specify a prompt string for it.

@defun keymap-prompt keymap
This function returns the overall prompt string of @var{keymap},
or @code{nil} if it has none.
@end defun

The menu's items are the bindings in the keymap.  Each binding
associates an event type to a definition, but the event types have no
significance for the menu appearance.  (Usually we use pseudo-events,
symbols that the keyboard cannot generate, as the event types for menu
item bindings.)  The menu is generated entirely from the bindings that
correspond in the keymap to these events.

The order of items in the menu is the same as the order of bindings in
the keymap.  Since @code{define-key} puts new bindings at the front, you
should define the menu items starting at the bottom of the menu and
moving to the top, if you care about the order.  When you add an item to
an existing menu, you can specify its position in the menu using
@code{define-key-after} (@pxref{Modifying Menus}).

@menu
* Simple Menu Items::       A simple kind of menu key binding.
* Extended Menu Items::     More complex menu item definitions.
* Menu Separators::         Drawing a horizontal line through a menu.
* Alias Menu Items::        Using command aliases in menu items.
@end menu

@node Simple Menu Items
@subsubsection Simple Menu Items

  The simpler (and original) way to define a menu item is to bind some
event type (it doesn't matter what event type) to a binding like this:

@example
(@var{item-string} . @var{real-binding})
@end example

@noindent
The @sc{car}, @var{item-string}, is the string to be displayed in the
menu.  It should be short---preferably one to three words.  It should
describe the action of the command it corresponds to.  Note that not
all graphical toolkits can display non-@acronym{ASCII} text in menus
(it will work for keyboard menus and will work to a large extent with
the GTK+ toolkit).

  You can also supply a second string, called the help string, as follows:

@example
(@var{item-string} @var{help} . @var{real-binding})
@end example

@noindent
@var{help} specifies a help-echo string to display while the mouse
is on that item in the same way as @code{help-echo} text properties
(@pxref{Help display}).

  As far as @code{define-key} is concerned, @var{item-string} and
@var{help-string} are part of the event's binding.  However,
@code{lookup-key} returns just @var{real-binding}, and only
@var{real-binding} is used for executing the key.

  If @var{real-binding} is @code{nil}, then @var{item-string} appears in
the menu but cannot be selected.

  If @var{real-binding} is a symbol and has a non-@code{nil}
@code{menu-enable} property, that property is an expression that
controls whether the menu item is enabled.  Every time the keymap is
used to display a menu, Emacs evaluates the expression, and it enables
the menu item only if the expression's value is non-@code{nil}.  When a
menu item is disabled, it is displayed in a fuzzy fashion, and
cannot be selected.

  The menu bar does not recalculate which items are enabled every time you
look at a menu.  This is because the X toolkit requires the whole tree
of menus in advance.  To force recalculation of the menu bar, call
@code{force-mode-line-update} (@pxref{Mode Line Format}).

@node Extended Menu Items
@subsubsection Extended Menu Items
@kindex menu-item
@cindex extended menu item

  An extended-format menu item is a more flexible and also cleaner
alternative to the simple format.  You define an event type with a
binding that's a list starting with the symbol @code{menu-item}.
For a non-selectable string, the binding looks like this:

@example
(menu-item @var{item-name})
@end example

@noindent
A string starting with two or more dashes specifies a separator line;
see @ref{Menu Separators}.

  To define a real menu item which can be selected, the extended format
binding looks like this:

@example
(menu-item @var{item-name} @var{real-binding}
    . @var{item-property-list})
@end example

@noindent
Here, @var{item-name} is an expression which evaluates to the menu item
string.  Thus, the string need not be a constant.  The third element,
@var{real-binding}, is the command to execute.  The tail of the list,
@var{item-property-list}, has the form of a property list which contains
other information.

  Here is a table of the properties that are supported:

@table @code
@item :enable @var{form}
The result of evaluating @var{form} determines whether the item is
enabled (non-@code{nil} means yes).  If the item is not enabled,
you can't really click on it.

@item :visible @var{form}
The result of evaluating @var{form} determines whether the item should
actually appear in the menu (non-@code{nil} means yes).  If the item
does not appear, then the menu is displayed as if this item were
not defined at all.

@item :help @var{help}
The value of this property, @var{help}, specifies a help-echo string
to display while the mouse is on that item.  This is displayed in the
same way as @code{help-echo} text properties (@pxref{Help display}).
Note that this must be a constant string, unlike the @code{help-echo}
property for text and overlays.

@item :button (@var{type} . @var{selected})
This property provides a way to define radio buttons and toggle buttons.
The @sc{car}, @var{type}, says which: it should be @code{:toggle} or
@code{:radio}.  The @sc{cdr}, @var{selected}, should be a form; the
result of evaluating it says whether this button is currently selected.

A @dfn{toggle} is a menu item which is labeled as either on or off
according to the value of @var{selected}.  The command itself should
toggle @var{selected}, setting it to @code{t} if it is @code{nil},
and to @code{nil} if it is @code{t}.  Here is how the menu item
to toggle the @code{debug-on-error} flag is defined:

@example
(menu-item "Debug on Error" toggle-debug-on-error
           :button (:toggle
                    . (and (boundp 'debug-on-error)
                           debug-on-error)))
@end example

@noindent
This works because @code{toggle-debug-on-error} is defined as a command
which toggles the variable @code{debug-on-error}.

@dfn{Radio buttons} are a group of menu items, in which at any time one
and only one is selected.  There should be a variable whose value
says which one is selected at any time.  The @var{selected} form for
each radio button in the group should check whether the variable has the
right value for selecting that button.  Clicking on the button should
set the variable so that the button you clicked on becomes selected.

@item :key-sequence @var{key-sequence}
This property specifies which key sequence is likely to be bound to the
same command invoked by this menu item.  If you specify the right key
sequence, that makes preparing the menu for display run much faster.

If you specify the wrong key sequence, it has no effect; before Emacs
displays @var{key-sequence} in the menu, it verifies that
@var{key-sequence} is really equivalent to this menu item.

@item :key-sequence nil
This property indicates that there is normally no key binding which is
equivalent to this menu item.  Using this property saves time in
preparing the menu for display, because Emacs does not need to search
the keymaps for a keyboard equivalent for this menu item.

However, if the user has rebound this item's definition to a key
sequence, Emacs ignores the @code{:keys} property and finds the keyboard
equivalent anyway.

@item :keys @var{string}
This property specifies that @var{string} is the string to display
as the keyboard equivalent for this menu item.  You can use
the @samp{\\[...]} documentation construct in @var{string}.

@item :filter @var{filter-fn}
This property provides a way to compute the menu item dynamically.
The property value @var{filter-fn} should be a function of one argument;
when it is called, its argument will be @var{real-binding}.  The
function should return the binding to use instead.

Emacs can call this function at any time that it does redisplay or
operates on menu data structures, so you should write it so it can
safely be called at any time.
@end table

@node Menu Separators
@subsubsection Menu Separators
@cindex menu separators

  A menu separator is a kind of menu item that doesn't display any
text---instead, it divides the menu into subparts with a horizontal line.
A separator looks like this in the menu keymap:

@example
(menu-item @var{separator-type})
@end example

@noindent
where @var{separator-type} is a string starting with two or more dashes.

  In the simplest case, @var{separator-type} consists of only dashes.
That specifies the default kind of separator.  (For compatibility,
@code{""} and @code{-} also count as separators.)

  Certain other values of @var{separator-type} specify a different
style of separator.  Here is a table of them:

@table @code
@item "--no-line"
@itemx "--space"
An extra vertical space, with no actual line.

@item "--single-line"
A single line in the menu's foreground color.

@item "--double-line"
A double line in the menu's foreground color.

@item "--single-dashed-line"
A single dashed line in the menu's foreground color.

@item "--double-dashed-line"
A double dashed line in the menu's foreground color.

@item "--shadow-etched-in"
A single line with a 3D sunken appearance.  This is the default,
used separators consisting of dashes only.

@item "--shadow-etched-out"
A single line with a 3D raised appearance.

@item "--shadow-etched-in-dash"
A single dashed line with a 3D sunken appearance.

@item "--shadow-etched-out-dash"
A single dashed line with a 3D raised appearance.

@item "--shadow-double-etched-in"
Two lines with a 3D sunken appearance.

@item "--shadow-double-etched-out"
Two lines with a 3D raised appearance.

@item "--shadow-double-etched-in-dash"
Two dashed lines with a 3D sunken appearance.

@item "--shadow-double-etched-out-dash"
Two dashed lines with a 3D raised appearance.
@end table

  You can also give these names in another style, adding a colon after
the double-dash and replacing each single dash with capitalization of
the following word.  Thus, @code{"--:singleLine"}, is equivalent to
@code{"--single-line"}.

  You can use a longer form to specify keywords such as @code{:enable}
and @code{:visible} for a menu separator:

@code{(menu-item @var{separator-type} nil . @var{item-property-list})}

For example:

@example
(menu-item "--" nil :visible (boundp 'foo))
@end example

  Some systems and display toolkits don't really handle all of these
separator types.  If you use a type that isn't supported, the menu
displays a similar kind of separator that is supported.

@node Alias Menu Items
@subsubsection Alias Menu Items

  Sometimes it is useful to make menu items that use the same
command but with different enable conditions.  The best way to do this
in Emacs now is with extended menu items; before that feature existed,
it could be done by defining alias commands and using them in menu
items.  Here's an example that makes two aliases for
@code{read-only-mode} and gives them different enable conditions:

@example
(defalias 'make-read-only 'read-only-mode)
(put 'make-read-only 'menu-enable '(not buffer-read-only))
(defalias 'make-writable 'read-only-mode)
(put 'make-writable 'menu-enable 'buffer-read-only)
@end example

When using aliases in menus, often it is useful to display the
equivalent key bindings for the real command name, not the aliases
(which typically don't have any key bindings except for the menu
itself).  To request this, give the alias symbol a non-@code{nil}
@code{menu-alias} property.  Thus,

@example
(put 'make-read-only 'menu-alias t)
(put 'make-writable 'menu-alias t)
@end example

@noindent
causes menu items for @code{make-read-only} and @code{make-writable} to
show the keyboard bindings for @code{read-only-mode}.

@node Mouse Menus
@subsection Menus and the Mouse

  The usual way to make a menu keymap produce a menu is to make it the
definition of a prefix key.  (A Lisp program can explicitly pop up a
menu and receive the user's choice---see @ref{Pop-Up Menus}.)

  If the prefix key ends with a mouse event, Emacs handles the menu keymap
by popping up a visible menu, so that the user can select a choice with
the mouse.  When the user clicks on a menu item, the event generated is
whatever character or symbol has the binding that brought about that
menu item.  (A menu item may generate a series of events if the menu has
multiple levels or comes from the menu bar.)

  It's often best to use a button-down event to trigger the menu.  Then
the user can select a menu item by releasing the button.

@cindex submenu
  If the menu keymap contains a binding to a nested keymap, the nested
keymap specifies a @dfn{submenu}.  There will be a menu item, labeled
by the nested keymap's item string, and clicking on this item
automatically pops up the specified submenu.  As a special exception,
if the menu keymap contains a single nested keymap and no other menu
items, the menu shows the contents of the nested keymap directly, not
as a submenu.

  However, if Emacs is compiled without X toolkit support, or on text
terminals, submenus are not supported.  Each nested keymap is shown as
a menu item, but clicking on it does not automatically pop up the
submenu.  If you wish to imitate the effect of submenus, you can do
that by giving a nested keymap an item string which starts with
@samp{@@}.  This causes Emacs to display the nested keymap using a
separate @dfn{menu pane}; the rest of the item string after the
@samp{@@} is the pane label.  If Emacs is compiled without X toolkit
support, or if a menu is displayed on a text terminal, menu panes are
not used; in that case, a @samp{@@} at the beginning of an item string
is omitted when the menu label is displayed, and has no other effect.

@node Keyboard Menus
@subsection Menus and the Keyboard

  When a prefix key ending with a keyboard event (a character or
function key) has a definition that is a menu keymap, the keymap
operates as a keyboard menu; the user specifies the next event by
choosing a menu item with the keyboard.

  Emacs displays the keyboard menu with the map's overall prompt
string, followed by the alternatives (the item strings of the map's
bindings), in the echo area.  If the bindings don't all fit at once,
the user can type @key{SPC} to see the next line of alternatives.
Successive uses of @key{SPC} eventually get to the end of the menu and
then cycle around to the beginning.  (The variable
@code{menu-prompt-more-char} specifies which character is used for
this; @key{SPC} is the default.)

  When the user has found the desired alternative from the menu, he or
she should type the corresponding character---the one whose binding is
that alternative.

@defvar menu-prompt-more-char
This variable specifies the character to use to ask to see
the next line of a menu.  Its initial value is 32, the code
for @key{SPC}.
@end defvar

@node Menu Example
@subsection Menu Example
@cindex menu definition example

  Here is a complete example of defining a menu keymap.  It is the
definition of the @samp{Replace} submenu in the @samp{Edit} menu in
the menu bar, and it uses the extended menu item format
(@pxref{Extended Menu Items}).  First we create the keymap, and give
it a name:

@smallexample
(defvar menu-bar-replace-menu (make-sparse-keymap "Replace"))
@end smallexample

@noindent
Next we define the menu items:

@smallexample
(define-key menu-bar-replace-menu [tags-repl-continue]
  '(menu-item "Continue Replace" tags-loop-continue
              :help "Continue last tags replace operation"))
(define-key menu-bar-replace-menu [tags-repl]
  '(menu-item "Replace in tagged files" tags-query-replace
              :help "Interactively replace a regexp in all tagged files"))
(define-key menu-bar-replace-menu [separator-replace-tags]
  '(menu-item "--"))
;; @r{@dots{}}
@end smallexample

@noindent
Note the symbols which the bindings are made for; these appear
inside square brackets, in the key sequence being defined.  In some
cases, this symbol is the same as the command name; sometimes it is
different.  These symbols are treated as function keys, but they are
not real function keys on the keyboard.  They do not affect the
functioning of the menu itself, but they are echoed in the echo area
when the user selects from the menu, and they appear in the output of
@code{where-is} and @code{apropos}.

  The menu in this example is intended for use with the mouse.  If a
menu is intended for use with the keyboard, that is, if it is bound to
a key sequence ending with a keyboard event, then the menu items
should be bound to characters or real function keys, that can be
typed with the keyboard.

  The binding whose definition is @code{("--")} is a separator line.
Like a real menu item, the separator has a key symbol, in this case
@code{separator-replace-tags}.  If one menu has two separators, they
must have two different key symbols.

  Here is how we make this menu appear as an item in the parent menu:

@example
(define-key menu-bar-edit-menu [replace]
  (list 'menu-item "Replace" menu-bar-replace-menu))
@end example

@noindent
Note that this incorporates the submenu keymap, which is the value of
the variable @code{menu-bar-replace-menu}, rather than the symbol
@code{menu-bar-replace-menu} itself.  Using that symbol in the parent
menu item would be meaningless because @code{menu-bar-replace-menu} is
not a command.

  If you wanted to attach the same replace menu to a mouse click, you
can do it this way:

@example
(define-key global-map [C-S-down-mouse-1]
   menu-bar-replace-menu)
@end example

@node Menu Bar
@subsection The Menu Bar
@cindex menu bar

  Emacs usually shows a @dfn{menu bar} at the top of each frame.
@xref{Menu Bars,,,emacs, The GNU Emacs Manual}.  Menu bar items are
subcommands of the fake function key @key{MENU-BAR}, as defined
in the active keymaps.

  To add an item to the menu bar, invent a fake function key of your
own (let's call it @var{key}), and make a binding for the key sequence
@code{[menu-bar @var{key}]}.  Most often, the binding is a menu keymap,
so that pressing a button on the menu bar item leads to another menu.

  When more than one active keymap defines the same function key
for the menu bar, the item appears just once.  If the user clicks on
that menu bar item, it brings up a single, combined menu containing
all the subcommands of that item---the global subcommands, the local
subcommands, and the minor mode subcommands.

  The variable @code{overriding-local-map} is normally ignored when
determining the menu bar contents.  That is, the menu bar is computed
from the keymaps that would be active if @code{overriding-local-map}
were @code{nil}.  @xref{Active Keymaps}.

  Here's an example of setting up a menu bar item:

@example
@group
;; @r{Make a menu keymap (with a prompt string)}
;; @r{and make it the menu bar item's definition.}
(define-key global-map [menu-bar words]
  (cons "Words" (make-sparse-keymap "Words")))
@end group

@group
;; @r{Define specific subcommands in this menu.}
(define-key global-map
  [menu-bar words forward]
  '("Forward word" . forward-word))
@end group
@group
(define-key global-map
  [menu-bar words backward]
  '("Backward word" . backward-word))
@end group
@end example

  A local keymap can cancel a menu bar item made by the global keymap by
rebinding the same fake function key with @code{undefined} as the
binding.  For example, this is how Dired suppresses the @samp{Edit} menu
bar item:

@example
(define-key dired-mode-map [menu-bar edit] 'undefined)
@end example

@noindent
Here, @code{edit} is the symbol produced by a fake function key, it is
used by the global map for the @samp{Edit} menu bar item.  The main
reason to suppress a global menu bar item is to regain space for
mode-specific items.

@defvar menu-bar-final-items
Normally the menu bar shows global items followed by items defined by the
local maps.

This variable holds a list of fake function keys for items to display at
the end of the menu bar rather than in normal sequence.  The default
value is @code{(help-menu)}; thus, the @samp{Help} menu item normally appears
at the end of the menu bar, following local menu items.
@end defvar

@defvar menu-bar-update-hook
This normal hook is run by redisplay to update the menu bar contents,
before redisplaying the menu bar.  You can use it to update menus
whose contents should vary.  Since this hook is run frequently, we
advise you to ensure that the functions it calls do not take much time
in the usual case.
@end defvar

Next to every menu bar item, Emacs displays a key binding that runs
the same command (if such a key binding exists).  This serves as a
convenient hint for users who do not know the key binding.  If a
command has multiple bindings, Emacs normally displays the first one
it finds.  You can specify one particular key binding by assigning an
@code{:advertised-binding} symbol property to the command.  @xref{Keys
in Documentation}.

@node Tool Bar
@subsection Tool bars
@cindex tool bar

  A @dfn{tool bar} is a row of clickable icons at the top of a frame,
just below the menu bar.  @xref{Tool Bars,,,emacs, The GNU Emacs
Manual}.  Emacs normally shows a tool bar on graphical displays.

  On each frame, the frame parameter @code{tool-bar-lines} controls
how many lines' worth of height to reserve for the tool bar.  A zero
value suppresses the tool bar.  If the value is nonzero, and
@code{auto-resize-tool-bars} is non-@code{nil}, the tool bar expands
and contracts automatically as needed to hold the specified contents.
If the value is @code{grow-only}, the tool bar expands automatically,
but does not contract automatically.

  The tool bar contents are controlled by a menu keymap attached to a
fake function key called @key{TOOL-BAR} (much like the way the menu
bar is controlled).  So you define a tool bar item using
@code{define-key}, like this:

@example
(define-key global-map [tool-bar @var{key}] @var{item})
@end example

@noindent
where @var{key} is a fake function key to distinguish this item from
other items, and @var{item} is a menu item key binding (@pxref{Extended
Menu Items}), which says how to display this item and how it behaves.

  The usual menu keymap item properties, @code{:visible},
@code{:enable}, @code{:button}, and @code{:filter}, are useful in
tool bar bindings and have their normal meanings.  The @var{real-binding}
in the item must be a command, not a keymap; in other words, it does not
work to define a tool bar icon as a prefix key.

  The @code{:help} property specifies a help-echo string to display
while the mouse is on that item.  This is displayed in the same way as
@code{help-echo} text properties (@pxref{Help display}).

  In addition, you should use the @code{:image} property;
this is how you specify the image to display in the tool bar:

@table @code
@item :image @var{image}
@var{image} is either a single image specification (@pxref{Images}) or
a vector of four image specifications.  If you use a vector of four,
one of them is used, depending on circumstances:

@table @asis
@item item 0
Used when the item is enabled and selected.
@item item 1
Used when the item is enabled and deselected.
@item item 2
Used when the item is disabled and selected.
@item item 3
Used when the item is disabled and deselected.
@end table
@end table

The GTK+ and NS versions of Emacs ignores items 1 to 3, because disabled and/or
deselected images are autocomputed from item 0.

If @var{image} is a single image specification, Emacs draws the tool bar
button in disabled state by applying an edge-detection algorithm to the
image.

The @code{:rtl} property specifies an alternative image to use for
right-to-left languages.  Only the GTK+ version of Emacs supports this
at present.

Like the menu bar, the tool bar can display separators (@pxref{Menu
Separators}).  Tool bar separators are vertical rather than
horizontal, though, and only a single style is supported.  They are
represented in the tool bar keymap by @code{(menu-item "--")} entries;
properties like @code{:visible} are not supported for tool bar
separators.  Separators are rendered natively in GTK+ and Nextstep
tool bars; in the other cases, they are rendered using an image of a
vertical line.

The default tool bar is defined so that items specific to editing do not
appear for major modes whose command symbol has a @code{mode-class}
property of @code{special} (@pxref{Major Mode Conventions}).  Major
modes may add items to the global bar by binding @code{[tool-bar
@var{foo}]} in their local map.  It makes sense for some major modes to
replace the default tool bar items completely, since not many can be
accommodated conveniently, and the default bindings make this easy by
using an indirection through @code{tool-bar-map}.

@defvar tool-bar-map
By default, the global map binds @code{[tool-bar]} as follows:

@example
(global-set-key [tool-bar]
                `(menu-item ,(purecopy "tool bar") ignore
                            :filter tool-bar-make-keymap))
@end example

@noindent
The function @code{tool-bar-make-keymap}, in turn, derives the actual
tool bar map dynamically from the value of the variable
@code{tool-bar-map}.  Hence, you should normally adjust the default
(global) tool bar by changing that map.  Some major modes, such as
Info mode, completely replace the global tool bar by making
@code{tool-bar-map} buffer-local and setting it to a different keymap.
@end defvar

There are two convenience functions for defining tool bar items, as
follows.

@defun tool-bar-add-item icon def key &rest props
This function adds an item to the tool bar by modifying
@code{tool-bar-map}.  The image to use is defined by @var{icon}, which
is the base name of an XPM, XBM or PBM image file to be located by
@code{find-image}.  Given a value @samp{"exit"}, say, @file{exit.xpm},
@file{exit.pbm} and @file{exit.xbm} would be searched for in that order
on a color display.  On a monochrome display, the search order is
@samp{.pbm}, @samp{.xbm} and @samp{.xpm}.  The binding to use is the
command @var{def}, and @var{key} is the fake function key symbol in the
prefix keymap.  The remaining arguments @var{props} are additional
property list elements to add to the menu item specification.

To define items in some local map, bind @code{tool-bar-map} with
@code{let} around calls of this function:
@example
(defvar foo-tool-bar-map
  (let ((tool-bar-map (make-sparse-keymap)))
    (tool-bar-add-item @dots{})
    @dots{}
    tool-bar-map))
@end example
@end defun

@defun tool-bar-add-item-from-menu command icon &optional map &rest props
This function is a convenience for defining tool bar items which are
consistent with existing menu bar bindings.  The binding of
@var{command} is looked up in the menu bar in @var{map} (default
@code{global-map}) and modified to add an image specification for
@var{icon}, which is found in the same way as by
@code{tool-bar-add-item}.  The resulting binding is then placed in
@code{tool-bar-map}, so use this function only for global tool bar
items.

@var{map} must contain an appropriate keymap bound to
@code{[menu-bar]}.  The remaining arguments @var{props} are additional
property list elements to add to the menu item specification.
@end defun

@defun tool-bar-local-item-from-menu command icon in-map &optional from-map &rest props
This function is used for making non-global tool bar items.  Use it
like @code{tool-bar-add-item-from-menu} except that @var{in-map}
specifies the local map to make the definition in.  The argument
@var{from-map} is like the @var{map} argument of
@code{tool-bar-add-item-from-menu}.
@end defun

@defvar auto-resize-tool-bars
If this variable is non-@code{nil}, the tool bar automatically resizes to
show all defined tool bar items---but not larger than a quarter of the
frame's height.

If the value is @code{grow-only}, the tool bar expands automatically,
but does not contract automatically.  To contract the tool bar, the
user has to redraw the frame by entering @kbd{C-l}.

If Emacs is built with GTK+ or Nextstep, the tool bar can only show one
line, so this variable has no effect.
@end defvar

@defvar auto-raise-tool-bar-buttons
If this variable is non-@code{nil}, tool bar items display
in raised form when the mouse moves over them.
@end defvar

@defvar tool-bar-button-margin
This variable specifies an extra margin to add around tool bar items.
The value is an integer, a number of pixels.  The default is 4.
@end defvar

@defvar tool-bar-button-relief
This variable specifies the shadow width for tool bar items.
The value is an integer, a number of pixels.  The default is 1.
@end defvar

@defvar tool-bar-border
This variable specifies the height of the border drawn below the tool
bar area.  An integer specifies height as a number of pixels.
If the value is one of @code{internal-border-width} (the default) or
@code{border-width}, the tool bar border height corresponds to the
corresponding frame parameter.
@end defvar

  You can define a special meaning for clicking on a tool bar item with
the shift, control, meta, etc., modifiers.  You do this by setting up
additional items that relate to the original item through the fake
function keys.  Specifically, the additional items should use the
modified versions of the same fake function key used to name the
original item.

  Thus, if the original item was defined this way,

@example
(define-key global-map [tool-bar shell]
  '(menu-item "Shell" shell
              :image (image :type xpm :file "shell.xpm")))
@end example

@noindent
then here is how you can define clicking on the same tool bar image with
the shift modifier:

@example
(define-key global-map [tool-bar S-shell] 'some-command)
@end example

@xref{Function Keys}, for more information about how to add modifiers to
function keys.

@node Modifying Menus
@subsection Modifying Menus
@cindex menu modification

  When you insert a new item in an existing menu, you probably want to
put it in a particular place among the menu's existing items.  If you
use @code{define-key} to add the item, it normally goes at the front of
the menu.  To put it elsewhere in the menu, use @code{define-key-after}:

@defun define-key-after map key binding &optional after
Define a binding in @var{map} for @var{key}, with value @var{binding},
just like @code{define-key}, but position the binding in @var{map} after
the binding for the event @var{after}.  The argument @var{key} should be
of length one---a vector or string with just one element.  But
@var{after} should be a single event type---a symbol or a character, not
a sequence.  The new binding goes after the binding for @var{after}.  If
@var{after} is @code{t} or is omitted, then the new binding goes last, at
the end of the keymap.  However, new bindings are added before any
inherited keymap.

Here is an example:

@example
(define-key-after my-menu [drink]
  '("Drink" . drink-command) 'eat)
@end example

@noindent
makes a binding for the fake function key @key{DRINK} and puts it
right after the binding for @key{EAT}.

Here is how to insert an item called @samp{Work} in the @samp{Signals}
menu of Shell mode, after the item @code{break}:

@example
(define-key-after
  (lookup-key shell-mode-map [menu-bar signals])
  [work] '("Work" . work-command) 'break)
@end example
@end defun

@node Easy Menu
@subsection Easy Menu

  The following macro provides a convenient way to define pop-up menus
and/or menu bar menus.

@defmac easy-menu-define symbol maps doc menu
This macro defines a pop-up menu and/or menu bar submenu, whose
contents are given by @var{menu}.

If @var{symbol} is non-@code{nil}, it should be a symbol; then this
macro defines @var{symbol} as a function for popping up the menu
(@pxref{Pop-Up Menus}), with @var{doc} as its documentation string.
@var{symbol} should not be quoted.

Regardless of the value of @var{symbol}, if @var{maps} is a keymap,
the menu is added to that keymap, as a top-level menu for the menu bar
(@pxref{Menu Bar}).  It can also be a list of keymaps, in which case
the menu is added separately to each of those keymaps.

The first element of @var{menu} must be a string, which serves as the
menu label.  It may be followed by any number of the following
keyword-argument pairs:

@table @code
@item :filter @var{function}
@var{function} must be a function which, if called with one
argument---the list of the other menu items---returns the actual items
to be displayed in the menu.

@item :visible @var{include}
@var{include} is an expression; if it evaluates to @code{nil}, the
menu is made invisible.  @code{:included} is an alias for
@code{:visible}.

@item :active @var{enable}
@var{enable} is an expression; if it evaluates to @code{nil}, the menu
is not selectable.  @code{:enable} is an alias for @code{:active}.
@end table

The remaining elements in @var{menu} are menu items.

A menu item can be a vector of three elements, @code{[@var{name}
@var{callback} @var{enable}]}.  @var{name} is the menu item name (a
string).  @var{callback} is a command to run, or an expression to
evaluate, when the item is chosen.  @var{enable} is an expression; if
it evaluates to @code{nil}, the item is disabled for selection.

Alternatively, a menu item may have the form:

@smallexample
   [ @var{name} @var{callback} [ @var{keyword} @var{arg} ]... ]
@end smallexample

@noindent
where @var{name} and @var{callback} have the same meanings as above,
and each optional @var{keyword} and @var{arg} pair should be one of
the following:

@table @code
@item :keys @var{keys}
@var{keys} is a keyboard equivalent to the menu item (a string).  This
is normally not needed, as keyboard equivalents are computed
automatically.  @var{keys} is expanded with
@code{substitute-command-keys} before it is displayed (@pxref{Keys in
Documentation}).

@item :key-sequence @var{keys}
@var{keys} is a hint for speeding up Emacs's first display of the
menu.  It should be @code{nil} if you know that the menu item has no keyboard
equivalent; otherwise it should be a string or vector specifying a
keyboard equivalent for the menu item.

@item :active @var{enable}
@var{enable} is an expression; if it evaluates to @code{nil}, the item
is make unselectable..  @code{:enable} is an alias for @code{:active}.

@item :visible @var{include}
@var{include} is an expression; if it evaluates to @code{nil}, the
item is made invisible.  @code{:included} is an alias for
@code{:visible}.

@item :label @var{form}
@var{form} is an expression that is evaluated to obtain a value which
serves as the menu item's label (the default is @var{name}).

@item :suffix @var{form}
@var{form} is an expression that is dynamically evaluated and whose
value is concatenated with the menu entry's label.

@item :style @var{style}
@var{style} is a symbol describing the type of menu item; it should be
@code{toggle} (a checkbox), or @code{radio} (a radio button), or
anything else (meaning an ordinary menu item).

@item :selected @var{selected}
@var{selected} is an expression; the checkbox or radio button is
selected whenever the expression's value is non-@code{nil}.

@item :help @var{help}
@var{help} is a string describing the menu item.
@end table

Alternatively, a menu item can be a string.  Then that string appears
in the menu as unselectable text.  A string consisting of dashes is
displayed as a separator (@pxref{Menu Separators}).

Alternatively, a menu item can be a list with the same format as
@var{menu}.  This is a submenu.
@end defmac

Here is an example of using @code{easy-menu-define} to define a menu
similar to the one defined in the example in @ref{Menu Bar}:

@example
(easy-menu-define words-menu global-map
  "Menu for word navigation commands."
  '("Words"
     ["Forward word" forward-word]
     ["Backward word" backward-word]))
@end example
