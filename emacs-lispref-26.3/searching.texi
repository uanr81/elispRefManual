@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2019 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Searching and Matching
@chapter Поиск и Cопоставление
@cindex searching

  GNU Emacs предоставляет два способа поиска указанного текста в буфере:
точный поиск по строке и поиск по регулярному выражению.  После поиска по
регулярному выражению можно изучить
@dfn{match data (сопоставленные данные)}, чтобы определить, какой текст
соответствует всему регулярному выражению или его различным частям.

@menu
* String Search::         Найти точное совпадение.
* Searching and Case::    Поиск без учета регистра или с учетом регистра.
* Regular Expressions::   Описание классов строк.
* Regexp Search::         Поиск совпадения с регулярным выражением.
* POSIX Regexps::         Поиск самого длинного совпадения в стиле POSIX.
* Match Data::            Выявление совпадающей части текста после поиска
                              по строке или регулярному выражению.
* Search and Replace::    Команды, которые зацикливаются, ищут и заменяют.
* Standard Regexps::      Полезные регулярные выражения для поиска
                              предложений, страниц ...
@end menu

  Функции @samp{skip-chars@dots{}} также выполняют своего рода поиск.
@xref{Skipping Characters}.  Для поиска изменений в свойствах символа,
смотреть @ref{Property Search}.

@node String Search
@section Поиск Строк
@cindex string search

  Это примитивные функции для поиска текста в буфере.  Предназначены для
использования в программах, но можно вызывать их в интерактивном режиме.
Если делается, запрашивается строка поиска; аргументы @var{limit} и
@var{noerror} - @code{nil}, а @var{repeat} - 1.  Подробнее об интерактивном
поиске -
@pxref{Search,, Searching and Replacement, emacs, The GNU Emacs Manual}.

  Эти функции поиска преобразуют строку поиска в многобайтовую, если буфер
многобайтовый; они преобразуют строку поиска в однобайтовую, если буфер
однобайтовый.  @xref{Text Representations}.

@deffn Command search-forward string &optional limit noerror count
Функция ищет в прямом направлении от точки точное совпадение для
@var{string}.  В случае успеха устанавливается точка в конец найденного
вхождения и возвращает новое значение точки.  Если совпадений не найдено,
значение и побочные эффекты зависят от @var{noerror} (смотреть ниже).

В следующем примере точка изначально находится в начале строки.  Затем
@code{(search-forward "fox")} перемещает точку после последней буквы
@samp{fox}:

@example
@group
---------- Buffer: foo ----------
@point{}The quick brown fox jumped over the lazy dog.
---------- Buffer: foo ----------
@end group

@group
(search-forward "fox")
     @result{} 20

---------- Buffer: foo ----------
The quick brown fox@point{} jumped over the lazy dog.
---------- Buffer: foo ----------
@end group
@end example

Аргумент @var{limit} указывает привязку к поиску и должен быть позицией в
текущем буфере.  Никакие совпадения после этой позиции не принимаются.  Если
@var{limit} опущен или @code{nil}, по умолчанию используется конец доступной
части буфера.

@kindex search-failed
Что произойдет, если поиск не удастся, зависит от значения @var{noerror}.
Если @var{noerror} равняется @code{nil}, выдается сообщение об ошибке
@code{search-failed}.  Если @var{noerror} равняется @code{t},
@code{search-forward} возвращает @code{nil} и ничего не делает.  Если
@var{noerror} не является ни @code{nil}, ни @code{t}, то
@code{search-forward} перемещает точку на верхнюю границу и возвращает
@code{nil}.
@c Я не вижу перспектив, что это когда-либо изменится, и, честно говоря,
@c текущее поведение кажется лучше, поэтому, похоже, нет необходимости
@c упоминать об этом.
@ignore
(В этом случае было бы более последовательно возвращать новую позицию точки,
но некоторые существующие программы могут зависеть от значения @code{nil}.)
@end ignore

Аргумент @var{noerror} влияет только на допустимые поиски, которые не могут
найти совпадения.  Неверные аргументы вызывают ошибки независимо от
@var{noerror}.

Если @var{count} - положительное число @var{n}, поиск выполняется @var{n}
раза; каждый последующий поиск начинается в конце предыдущего совпадения.
Если все эти последовательные поиски успешны, вызов функции завершается
успешно, точка перемещается и возвращается ее новое значение.  В противном
случае вызов функции завершится неудачно, и результаты будут зависеть от
значения @var{noerror}, как описано выше.  Если @var{count} - отрицательное
число @minus{}@var{n}, поиск выполняется @var{n} раз в обратном (обратном)
направлении.
@end deffn

@deffn Command search-backward string &optional limit noerror count
Функция ищет @var{string} в обратном направлении от точки.  Это похоже на
@code{search-forward}, за исключением того, что ищет назад, а не вперед.
Поиск назад оставляет точку в начале соответствия.
@end deffn

@deffn Command word-search-forward string &optional limit noerror count
Функция ищет вперед от точки совпадение слова для @var{string}.  Если
находит совпадение, устанавливается точка в конец найденного совпадения и
возвращается новое значение точки.

При сопоставлении слов @var{string} рассматривается как последовательность
слов без учета знаков препинания, разделяющих их.  Ищется в буфере та же
последовательность слов.  Каждое слово в буфере должно отличаться (поиск
слова @samp{ball} не соответствует слову @samp{balls}), но детали
пунктуации и пробелов игнорируются (поиск @samp{ball boy} соответствует
@samp{ball.  Boy!}).

В этом примере точка изначально находится в начале буфера; поиск оставляет
её между @samp{y} и @samp{!}.

@example
@group
---------- Buffer: foo ----------
@point{}He said "Please!  Find
the ball boy!"
---------- Buffer: foo ----------
@end group

@group
(word-search-forward "Please find the ball, boy.")
     @result{} 39

---------- Buffer: foo ----------
He said "Please!  Find
the ball boy@point{}!"
---------- Buffer: foo ----------
@end group
@end example

Если @var{limit} равно не-@code{nil}, это должна быть позиция в текущем
буфере; определяет верхнюю границу поиска.  Найденное совпадение не должно
продолжаться после этой позиции.

Если @var{noerror} равно @code{nil}, то @code{word-search-forward}
сигнализирует об ошибке, если поиск не удался.  Если @var{noerror} равно
@code{t}, то вместо сообщения об ошибке возвращается @code{nil}.  Если
@var{noerror} не является ни @code{nil}, ни @code{t}, перемещается точка в
@var{limit} (или конец доступной части буфера) и возвращает @code{nil}.

Если @var{count} - положительное число, оно указывает, сколько
последовательных вхождений нужно искать.  Точка находится в конце последнего
соответствия.  Если @var{count} - отрицательное число, поиск выполняется в
обратном направлении, и точка помещается в начало последнего совпадения.

@findex word-search-regexp
Внутри @code{word-search-forward} и связанные функции используют функцию
@code{word-search-regexp} для преобразования @var{string} в регулярное
выражение, игнорирующее знаки препинания.
@end deffn

@deffn Command word-search-forward-lax string &optional limit noerror count
Команда идентична @code{word-search-forward}, за исключением того, что
начало или конец @var{string} не обязательно должны совпадать с границей
слова, если только @var{string} не начинается или не заканчивается пробелом.
Например, поиск @samp{ball boy} соответствует @samp{ball boyee}, но не
соответствует @samp{balls boy}.
@end deffn

@deffn Command word-search-backward string &optional limit noerror count
Функция ищет в обратном направлении от точки совпадение слова до
@var{string}.  Эта функция аналогична @code{word-search-forward}, за
исключением того, что она выполняет поиск в обратном направлении и обычно
оставляет точку в начале совпадения.
@end deffn

@deffn Command word-search-backward-lax string &optional limit noerror count
Команда идентична @code{word-search-backward}, за исключением того, что
начало или конец @var{string} не обязательно должны совпадать с границей
слова, если только @var{string} не начинается или не заканчивается пробелом.
@end deffn

@node Searching and Case
@section Поиск и Регистр
@cindex searching and case

  По умолчанию поиск в Emacs игнорирует регистр текста, в котором
выполняется поиск; если указывается поиск @samp{FOO}, то @samp{Foo} или
@samp{foo} также будет считаться совпадением.  Это относится и к регулярным
выражениям; таким образом, @samp{[aB]} будет соответствовать @samp{a} или
@samp{A} или @samp{b} или @samp{B}.

  Если не нужна эта функция, устанавливается для переменной
@code{case-fold-search} значение @code{nil}.  Тогда все буквы должны
совпадать, включая регистр.  Это переменная локального буфера; изменение
переменной влияет только на текущий буфер.  (@xref{Intro to Buffer-Local}.)
Также можно изменить значение по умолчанию.  В коде Lisp чаще будет
использоваться @code{let} для привязки @code{case-fold-search} к желаемому
значению.

  Обратить внимание, что функция инкрементного поиска на уровне пользователя
по-разному обрабатывает регистр символов.  Когда строка поиска содержит
только буквы нижнего регистра, поиск игнорирует регистр, но когда строка
поиска содержит одну или несколько букв верхнего регистра, поиск становится
чувствительным к регистру.  Но это не имеет ничего общего с функциями
поиска, используемыми в коде Lisp.
@xref{Incremental Search,,, emacs, Руководство GNU Emacs}.

@defopt case-fold-search
Эта локальная в буфере переменная определяет, должен ли поиск игнорировать
регистр.  Если переменная - @code{nil}, они не игнорируют регистр; в
противном случае (и по умолчанию) регистр игнорируется.
@end defopt

@defopt case-replace
Переменная определяет, должны ли функции замены более высокого уровня
сохранять регистр.  Если переменная - @code{nil}, это означает дословно
использовать заменяющий текст.  Значение не-@code{nil} означает
преобразование регистра заменяемого текста в соответствии с заменяемым
текстом.

Переменная используется путем передачи ее в качестве аргумента функции
@code{replace-match}.  @xref{Replacing Match}.
@end defopt

@node Regular Expressions
@section Регулярные Выражения
@cindex regular expression
@cindex regexp

  @dfn{Регулярное выражение}, или сокращенно @dfn{regexp}, - это шаблон,
обозначающий (возможно, бесконечный) набор строк.  Поиск совпадений для
регулярного выражения - очень мощная операция.  В этом разделе объясняется,
как писать регулярные выражения; в следующем разделе рассказывается, как с
их помощью искать.

@findex re-builder
@cindex regular expressions, developing
  Для интерактивной разработки регулярных выражений можно использовать
команду @kbd{M-x re-builder}.  Это предоставляет удобный интерфейс для
создания регулярных выражений, обеспечивая немедленную визуальную обратную
связь в отдельном буфере.  Когда редактируется регулярное выражение, все его
совпадения в целевом буфере выделяются.  Каждое заключенное в скобки
подвыражение регулярного выражения отображается отдельным отображением, что
упрощает проверку даже очень сложных регулярных выражений.

@menu
* Syntax of Regexps::       Правила написания регулярных выражений.
* Regexp Example::          Иллюстрирация синтаксиса регулярных выражений.
* Regexp Functions::        Функции для работы с регулярными выражениями.
@end menu

@node Syntax of Regexps
@subsection Синтаксис Регулярных Выражений
@cindex regexp syntax
@cindex syntax of regular expressions

  Регулярные выражения имеют синтаксис, в котором несколько символов
являются специальными конструкциями, а остальные - @dfn{обычными}.  Обычный
символ - это простое регулярное выражение, которое соответствует этому
символу и ничему другому.  Специальные символы: @samp{.}, @samp{*},
@samp{+}, @samp{?}, @samp{[}, @samp{^}, @samp{$} и @samp{\}; в будущем не
будут определяться новые специальные символы.  Символ @samp{]} является
особенным, если он завершает символ альтернативы (смотреть ниже).  Внутри
симвла альтернативы символ @samp{-} является особенным.  @samp{[:} и
сбалансированный @samp{:]} заключают символьный класс в символьную
альтернативу.  Любой другой символ, появляющийся в регулярном выражении,
является обычным, если ему не предшествует @samp{\}.

  Например, @samp{f} не является специальным символом, поэтому он обычный, и
поэтому @samp{f} является регулярным выражением, которое соответствует
строке @samp{f} и никакой другой строке.  (Он действительно @emph{не}
соответствует строке @samp{fg}, но соответствует @emph{части} этой строки.)
Аналогично, @samp{o} - это регулярное выражение, которое соответствует
только @samp{o}.

  Любые два регулярных выражения @var{a} и @var{b} можно объединить.
Результатом является регулярное выражение, которое соответствует строке,
если @var{a} соответствует некоторому количеству начала этой строки, а
@var{b} соответствует остальной части строки.

  В качестве простого примера можно объединить регулярные выражения @samp{f}
и @samp{o}, чтобы получить регулярное выражение @samp{fo}, которое
соответствует только строке @samp{fo}.  Все еще тривиально.  Чтобы сделать
что-то более мощное, потребуется использовать одну из специальных
конструкций регулярных выражений.

@menu
* Regexp Special::      Специальные символы в регулярных выражениях.
* Char Classes::      Классы символов, используемые в регулярных выражениях.
* Regexp Backslash::    Обратные косые черты в регулярных выражениях.
@end menu

@node Regexp Special
@subsubsection Специальные Символы в Регулярных Выражениях
@cindex regexp, special characters in

  Вот список специальных символов в регулярном выражении.

@need 800
@table @asis
@item @samp{.}@: @r{(Period)}
@cindex @samp{.} в регулярном выражении
это специальный символ, который соответствует любому одиночному символу,
кроме новой строки.  Используя конкатенацию, мы можем создавать регулярные
выражения, такие как @samp{a.b}, который соответствует любой трехсимвольной
строке, которая начинается с @samp{a} и заканчивается @samp{b}.

@item @samp{*}
@cindex @samp{*} в регулярном выражении
не является конструкцией сама по себе; это постфиксный оператор, который
означает повторное сопоставление предыдущего регулярного выражения столько
раз, сколько возможно.  Таким образом, @samp{o*} соответствует любому
количеству @samp{o} (включая отсутствие @samp{o}).

@samp{*} всегда применяется к возможному @emph{самому маленькому}
предыдущему выражению.  Таким образом, @samp{fo*} имеет повторяющийся
@samp{o}, а не повторяющийся @samp{fo}.  Соответствует @samp{f}, @samp{fo},
@samp{foo} и так далее.

@cindex backtracking and regular expressions
Средство сопоставления обрабатывает конструкцию @samp{*}, немедленно
сопоставляя столько повторений, сколько может быть найдено.  Затем переходит
к остальной части шаблона.  Если это не удается, происходит откат назад,
отбрасываются некоторые совпадения конструкции, измененными @samp{*},
в надежде, что это позволит сопоставить остальную часть шаблона.  Например,
при сопоставлении @samp{ca*ar} со строкой @samp{caaar}, @samp{a*} сначала
пытается сопоставить все три @samp{a}; но остальная часть шаблона -
@samp{ar}, и остается только @samp{r} для сопоставления, поэтому эта попытка
не удалась.  Следующая альтернатива - для @samp{a*} соответствовать только
двум @samp{a}.  При таком выборе остальная часть регулярного выражения
соответствует успешно.

@strong{Предупреждение:} Вложенные операторы повторения могут работать
бесконечно долго, если они приводят к неоднозначному сопоставлению.
Например, попытка сопоставить регулярное выражение @samp{\(x+y*\)*a} со
строкой @samp{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxz} может занять несколько
часов, прежде чем окончательно потерпит неудачу.  Emacs должен попробовать
все способы группировки @samp{x}, прежде чем сделать вывод, что ни один из
них не может работать.  Хуже того, @samp{\(x*\)*} может соответствовать
нулевой строке бесконечным количеством способов, поэтому он вызывает
бесконечный цикл.  Чтобы избежать этих проблем, внимательно проверьте
вложенные повторы, чтобы убедиться, что они не вызывают комбинаторных
взрывов при возврате.

@item @samp{+}
@cindex @samp{+} в регулярном выражении
это постфиксный оператор, похожий на @samp{*}, за исключением того, что он
должен соответствовать предыдущему выражению хотя бы один раз.  Так,
например, @samp{ca+r} соответствует строкам @samp{car} и @samp{caaaar}, но
не строке @samp{cr}, тогда как @samp{ca*r} соответствует всем трем строкам.

@item @samp{?}
@cindex @samp{?} в регулярном выражении
это постфиксный оператор, похожий на @samp{*}, за исключением того, что он
должен совпадать с предыдущим выражением либо один раз, либо не совпадать
вовсе.  Например, @samp{ca?r} соответствует @samp{car} или @samp{cr}; ничего
больше.

@item @samp{*?}, @samp{+?}, @samp{??}
@cindex non-greedy repetition characters in regexp
Это @dfn{не жадные} варианты операторов @samp{*}, @samp{+} и @samp{?}.  Если
эти операторы соответствуют максимально возможной подстроке (согласованно с
сопоставлением всего содержащего выражения), нежадные варианты соответствуют
наименьшей возможной подстроке (согласованно с сопоставлением всего
содержащего выражения).

Например, регулярное выражение @samp{c[ad]*a} при применении к строке
@samp{cdaaada} соответствует всей строке; но регулярное выражение
@samp{c[ad]*?a}, примененное к той же строке, соответствует только
@samp{cda}.  (Наименьшее возможное совпадение здесь для @samp{[ad]*?},
которое разрешает совпадение всего выражения, - @samp{d}.)

@item @samp{[ @dots{} ]}
@cindex character alternative (in regexp)
@cindex @samp{[} in regexp
@cindex @samp{]} in regexp
это @dfn{альтернатива символа}, который начинается с @samp{[} и
заканчивается @samp{]}.  В простейшем случае символы между двумя скобками -
это то, чему может соответствовать эта альтернатива символов.

Таким образом, @samp{[ad]} соответствует либо одному @samp{a}, либо одному
@samp{d}, а @samp{[ad]*} соответствует любой строке, состоящей только из
@samp{a} и @samp{d} (включая пустую строку).  Следовательно, @samp{c[ad]*r}
соответствует @samp{cr}, @samp{car}, @samp{cdr}, @samp{caddaar} и так далее.

Также возможно включить диапазоны символов в альтернативу символов, написав
начальный и конечный символы с @samp{-} между ними.  Таким образом,
@samp{[a-z]} соответствует любой строчной букве @acronym{ASCII}.  Диапазоны
могут свободно смешиваться с отдельными символами, как в @samp{[a-z$%.]},
которое соответствует любой строчной букве @acronym{ASCII}, @samp{$},
@samp{%} или точке.  Однако конечный символ одного диапазона не должен быть
начальной точкой другого; например, следует избегать @samp{[a-m-z]}.

Обычные специальные символы регулярного выражения не являются специальными
внутри альтернативы символов.  Внутри альтернативы символов есть совершенно
другой набор символов: @samp{]}, @samp{-} и @samp{^}.

Чтобы включить @samp{]} в альтернативу символа, потребуется сделать его
первым символом.  Например, @samp{[]a]} соответствует @samp{]} или @samp{a}.
Чтобы включить @samp{-}, напишите @samp{-} как первый или последний символ
альтернативы символа или как верхнюю границу диапазона.  Таким образом,
@samp{[]-]} соответствует обоим @samp{]} и @samp{-}.  (Как объясняется ниже,
не выйдет использовать @samp{\]} для включения @samp{]} в альтернативе
символа, поскольку @samp{\} там не является особенным.)

Чтобы включить @samp{^} в альтернативу символа, поместите его где угодно, но
не в начало.

Следующие аспекты диапазонов специфичны для Emacs, поскольку POSIX
позволяет, но не требует такого поведения, а программы, отличные от Emacs,
могут вести себя по-другому:

@enumerate
@item
Если @code{case-fold-search} равен не-@code{nil}, тогда @samp{[a-z]}, то так
же соответствуют заглавные буквы.

@item
На диапазон не влияет последовательность сопоставления языкового стандарта:
он всегда представляет набор символов с кодовыми точками, находящимися между
его границами, так что @samp{[a-z]} соответствует только буквам ASCII, даже
за пределами языкового стандарта C или POSIX.

@item
В качестве особого случая, если одна из границ диапазона является
необработанным 8-битным байтом, другая граница должна быть однобайтным
символом, а диапазон соответствует только однобайтовым символам.

@item
Если нижняя граница диапазона больше, чем его верхняя граница, диапазон пуст
и не представляет никаких символов.  Таким образом, @samp{[b-a]} всегда не
соответствует, а @samp{[^b-a]} соответствует любому символу, включая новую
строку.  Однако нижняя граница должна быть не более чем на единицу больше
верхней границы; например, следует избегать @samp{[c-a]}.
@end enumerate

Альтернатива символов также может указывать именованные классы символов
(@pxref{Char Classes}).  Это особенность POSIX.  Например,
@samp{[[:ascii:]]} соответствует любому символу @acronym{ASCII}.
Использование класса символов эквивалентно упоминанию каждого из символов
этого класса; но последнее невозможно на практике, поскольку некоторые
классы включают тысячи различных символов.  Класс символов не должен
отображаться как нижняя или верхняя граница диапазона.

@item @samp{[^ @dots{} ]}
@cindex @samp{^} в регулярном выражении
начинающимся с @samp{[^} в @dfn{дополнительной альтернативе символа}.  Это
соответствует любому символу, кроме указанных.  Таким образом,
@samp{[^a-z0-9A-Z]} соответствует всем символам @emph{кроме} букв и цифр.

@samp{^} не является особенным в альтернативе символа, если он не является
первым символом.  Символ, следующий за @samp{^}, рассматривается как первый
(другими словами, @samp{-} и @samp{]} здесь не особенные).  Альтернативный
вариант дополненного символа может соответствовать новой строке, если новая
строка не указана как один из символов, которые не должны совпадать.  Это
отличается от обработки регулярных выражений в таких программах, как
@code{grep}.

Можно указать именованные классы символов, как и в альтернативных вариантах
символов.  Например, @samp{[^[:ascii:]]} соответствует любому
не-@acronym{ASCII} символу.  @xref{Char Classes}.

@item @samp{^}
@cindex beginning of line in regexp
При сопоставлении буфера @samp{^} соответствует пустой строке, но только в
начале строки в сопоставляемом тексте (или начале доступной части буфера).
В противном случае ничему не соответствует.  Таким образом, @samp{^foo}
соответствует @samp{foo}, который встречается в начале строки.

При сопоставлении строки вместо буфера @samp{^}, соответствует началу строки
или после символа новой строки.

По причинам исторической совместимости @samp{^} можно использовать только в
начале регулярного выражения или после @samp{\(}, @samp{\(?:} или
@samp{\|}.

@item @samp{$}
@cindex @samp{$} in regexp
@cindex end of line in regexp
похоже на @samp{^}, но соответствует только в конце строки (или  в конце
доступной части буфера).  Таким образом, @samp{x+$} соответствует строке из
одного @samp{x} или более в конце строки.

При сопоставлении строки вместо буфера @samp{$} соответствует концу строки
или перед символом новой строки.

По причинам исторической совместимости @samp{$} можно использовать только в
конце регулярного выражения или перед @samp{\)} или @samp{\|}.

@item @samp{\}
@cindex @samp{\} in regexp
имеет две функции: заключает в кавычки специальные символы (включая
@samp{\}) и вводит дополнительные специальные конструкции.

Поскольку @samp{\} заключает в кавычки специальные символы, @samp{\$} - это
регулярное выражение, которое соответствует только @samp{$}, а @samp{\[} -
регулярное выражение, которое соответствует только @samp{[}, и так далее.

Обратить внимание, что @samp{\} также имеет особое значение в синтаксисе
чтения строк Lisp (@pxref{String Type}) и должен заключаться в кавычки с
@samp{\}.  Например, регулярное выражение, соответствующее символу
@samp{\}, - @samp{\\}.  Чтобы написать строку Lisp, содержащую символы
@samp{\\}, синтаксис Lisp требует, каждый символ @samp{\} процитировать
другим @samp{\}.  Следовательно, синтаксис чтения для регулярного
выражения, с соответствующими @samp{\}, - @code{"\\\\"}.
@end table

@strong{Пожалуйста, обратить внимание:} Для исторической совместимости
специальные символы рассматриваются как обычные, если они находятся в
контексте, в котором их особые значения не имеют смысла.  Например,
@samp{*foo} рассматривает @samp{*} как обычный, поскольку нет предыдущего
выражения, на которое @samp{*} мог бы действовать.  Полагаться на такое
поведение - плохая практика; в любом случае лучше процитировать специальный
символ независимо от того, где он появляется.

Поскольку @samp{\} не является особенным внутри альтернативы символа, он
никогда не может удалить особое значение @samp{-} или @samp{]}.  Поэтому не
следует цитировать эти символы, если они не имеют особого значения.  Это
ничего не проясняет, поскольку обратная косая черта может законно
предшествовать этим символам, где они @emph{имеют} специальное значение, как
в @samp{[^\]} (@code{"[^\\]"} для синтаксиса строки Lisp), который
соответствует любому одиночному символу, кроме обратной косой черты.

На практике большинство @samp{]}, которые встречаются в регулярных
выражениях, закрывают символьную альтернативу и, следовательно, являются
особенными.  Однако иногда регулярное выражение может пытаться сопоставить
сложный шаблон литерала @samp{[} и @samp{]}.  В таких ситуациях иногда может
потребоваться тщательно проанализировать регулярное выражение с самого
начала, чтобы определить, какие квадратные скобки заключают альтернативный
символ.  Например, @samp{[^][]]} состоит из альтернативного дополненного
символа @samp{[^][]} (который соответствует любому одиночному символу, кроме
квадратной скобки), за которым следует литерал @samp{]}.

Точные правила таковы, что в начале регулярного выражения @samp{[} является
специальным, а @samp{]} - нет.  Это длится до первого не цитированного
@samp{[}, после чего происходит переход к альтернативе символа; @samp{[}
больше не является особенным (кроме случаев, когда он запускает класс
символов), но @samp{]} является особенным, если только он не следует сразу
за специальным @samp{[} или @samp{[}, за которым следует @samp{^}.  Это
длится до следующего специального @samp{]}, который не завершает класс
символа.  На этом заканчивается альтернатива символа и восстанавливается
обычный синтаксис регулярных выражений; не цитированный @samp{[} снова
является особенным, а @samp{]} - нет.

@node Char Classes
@subsubsection Классы Символов
@cindex character classes in regexp

  Вот таблица классов, которые можно использовать в качестве альтернативы
символа, и что они означают:

@table @samp
@item [:ascii:]
Соответствует любому символу @acronym{ASCII} (код 0-127).
@item [:alnum:]
Соответствует любой букве или цифре.  Для многобайтовых символов
соответствует символам, у которых свойство Unicode @samp{общая категория}
(@pxref{Character Properties}) указывает, что они являются символами
алфавита или десятичного числа.
@item [:alpha:]
Соответствует любой букве.  Для многобайтовых символов соответствует
символам, для которых свойство Unicode @samp{общая категория}
(@pxref{Character Properties}) указывает, что они являются алфавитными
символами.
@item [:blank:]
Это соответствует горизонтальному пробелу, как определено в Приложении C
Технического стандарта Unicode № 18.  В частности, сопоставляет пробелы,
табуляции и другие символы, свойство (@pxref{Character Properties}) Unicode
@samp{общая категория} которых указывает, что они являются пробельными
разделителями.
@item [:cntrl:]
Это соответствует любому управляющему символу @acronym{ASCII}.
@item [:digit:]
Это соответствует @samp{0} - @samp{9}.  Таким образом, @samp{[-+[:digit:]]}
соответствует любой цифре, @samp{+} и @samp{-}.
@item [:graph:]
Это соответствует графическим символам - всем, кроме пробелов, управляющих
@acronym{ASCII} и не-@acronym{ASCII} символам, суррогатов и кодовых точек,
не назначенных Unicode, как указано в свойстве Unicode
@samp{общей категории} (@pxref{Character Properties}).
@item [:lower:]
Это соответствует любой строчной букве, как определено в текущей таблице
регистра (@pxref{Case Tables}).  Если @code{case-fold-search} равно
не-@code{nil}, это также соответствует любой заглавной букве.
@item [:multibyte:]
Соответствует любому многобайтовому символу (@pxref{Text Representations}).
@item [:nonascii:]
Соответствует любому не-@acronym{ASCII} символу.
@item [:print:]
Это соответствует любому печатному символу - либо пробелу, либо графическому
символу, соответствующему @samp{[:graph:]}.
@item [:punct:]
Соответствует любому знаку пунктуации.  (В настоящее время для многобайтовых
символов он соответствует всем, что не имеет синтаксиса слов.)
@item [:space:]
Это соответствует любому символу с синтаксисом пробелов
(@pxref{Syntax Class Table}).
@item [:unibyte:]
Соответствует любому однобайтовому символу (@pxref{Text Representations}).
@item [:upper:]
Это соответствует любой заглавной букве, как определено в текущей таблице
регистров (@pxref{Case Tables}).  Если @code{case-fold-search} равно
не-@code{nil}, это также соответствует любой строчной букве.
@item [:word:]
Это соответствует любому символу, имеющему синтаксис слова
(@pxref{Syntax Class Table}).
@item [:xdigit:]
Это соответствует шестнадцатеричным цифрам: от @samp{0} до @samp{9},
от @samp{a} до @samp{f} и от @samp{A} до @samp{F}.
@end table

@node Regexp Backslash
@subsubsection Конструкции с Обратной Косой Чертой в Регулярных Выражениях
@cindex backslash in regular expressions

  По большей части @samp{\}, за которым следует любой символ, соответствует
только этому символу.  Однако есть несколько исключений: определенные
последовательности, начинающиеся с @samp{\}, которые имеют особое значение.
Вот таблица специальных конструкций @samp{\}.

@table @samp
@item \|
@cindex @samp{|} in regexp
@cindex regexp alternative
указывает альтернативу.
Два регулярных выражения @var{a} и @var{b} с @samp{\|} между ними образуют
выражение, которое соответствует всему, что соответствует @var{a} или
@var{b}.

Таким образом, @samp{foo\|bar} соответствует либо @samp{foo} или @samp{bar},
но ни одной другой строке.

@samp{\|} применяется к максимально возможным окружающим выражениям.  Только
окружающая группировка @samp{\( @dots{} \р)} может ограничивать
группирующую способность @samp{\|}.

Если нужна возможность полного обратного отслеживания для обработки
многократного использования @samp{\|}, использовать функции регулярного
выражения POSIX (@pxref{POSIX Regexps}).

@item \@{@var{m}\@}
- постфиксный оператор, который повторяет предыдущий шаблон точно @var{m}
раз.  Таким образом, @samp{x\@{5\@}} соответствует строке @samp{xxxxx} и
ничему другому.  @samp{c[ad]\@{3\@}r} соответствует строке, например
@samp{caaar}, @samp{cdddr}, @samp{cadar} и так далее.

@item \@{@var{m},@var{n}\@}
- это более общий постфиксный оператор, который задает повторение с
минимальным количеством повторов @var{m} и максимальным количеством повторов
@var{n}.  Если @var{m} опущен, минимум равен 0; если @var{n} опущен,
максимума нет.  Для обеих форм @var{m} и @var{n}, если указано, не может
быть больше, чем
@ifnottex
2**15 @minus{} 1
@end ifnottex
@tex
@math{2^{15}-1}
@end tex
.

Например, @samp{c[ad]\@{1,2\@}r} соответствует строкам @samp{car},
@samp{cdr}, @samp{caar}, @samp{cadr}, @samp{cdar} и @samp{cddr} и ничему
более.@*
@samp{\@{0,1\@}} или @samp{\@{,1\@}} - эквивалентно @samp{?}.@*
@samp{\@{0,\@}} или @samp{\@{,\@}} - эквивалентно @samp{*}.@*
@samp{\@{1,\@}} - эквивалентно @samp{+}.

@item \( @dots{} \)
@cindex @samp{(} in regexp
@cindex @samp{)} in regexp
@cindex regexp grouping
представляет собой группирующую конструкцию, которая служит трем целям:

@enumerate
@item
Приложить набор альтернатив @samp{\|} для других операций.  Таким образом,
регулярное выражение @samp{\(foo\|bar\)x} соответствует либо @samp{foox}
либо @samp{barx}.

@item
Заключить сложное выражение для операторов постфикса @samp{*}, @samp{+} и
@samp{?}.  Таким образом, @samp{ba\(na\)*} соответствует @samp{ba},
@samp{bana}, @samp{banana}, @samp{bananana} и так далее.  Любому количеству
(нулю или более) строк @samp{na}.

@item
Чтобы записать совпавшую подстроку для использования в будущем с помощью
@samp{\@var{digit}} (смотреть ниже).
@end enumerate

Это последнее приложение не является следствием идеи группировки в скобках;
это отдельная функция, которая была назначена в качестве второго значения
той же конструкции @samp{\( @dots{} \)}, потому что на практике обычно не
было конфликта между двумя значениями.  Но иногда случаются конфликты, и это
приводит к появлению застенчивых групп.

@item \(?: @dots{} \)
@cindex shy groups
@cindex non-capturing group
@cindex unnumbered group
@cindex @samp{(?:} in regexp
это конструкция @dfn{застенчивая группа}.  Стеснительная группа служит
первым двум целям обычной группы (контроль вложенности других операторов),
но она не получает числа, поэтому не можно вернуться к ее значению с помощью
@samp{\@var{digit}}.  Shy-группы особенно полезны для механически
построенных регулярных выражений, потому что они могут добавляться
автоматически без изменения нумерации обычных, не-shy групп.

Стеснительные группы также называются @dfn{не захватывающими} или
@dfn{ненумерованными группами}.

@item \(?@var{num}: @dots{} \)
это конструкция @dfn{явно нумерованная группа}.  Нормальные группы получают
свое количество неявно, исходя из своего положения, что может быть неудобно.
Эта конструкция позволяет вам задать конкретный номер группы.  Особых
ограничений на нумерацию нет, например, у вас может быть несколько групп с
одинаковым номером, и в этом случае победит последняя из совпавших (то есть
крайнее правое совпадение).  Неявно пронумерованные группы всегда получают
наименьшее целое число больше, чем у любой предыдущей группы.

@item \@var{digit}
соответствует тому же тексту, который соответствует @var{digit} вхождению
конструкции grouping (@samp{\( @dots{} \)}).

Другими словами, после окончания группы сопоставитель запоминает начало и
конец текста, сопоставленного этой группой.  Позже в регулярном выражении
можно использовать @samp{\}, а затем @var{digit}, чтобы найти тот же текст,
каким бы он ни был.

Строкам, соответствующим первым девяти конструкциям группировки,
появляющимся во всем регулярном выражении, переданном в функцию поиска или
сопоставления, присваиваются номера от 1 до 9 в том порядке, в котором
открытые скобки появляются в регулярном выражении.  Таким образом, можно
использовать @samp{\1} - @samp{\9} для ссылки на текст, сопоставленный
соответствующими конструкциями группировки.

Например, @samp{\(.*\)\1} соответствует любой строке без новой строки,
состоящей из двух идентичных половин.  @samp{\(.*\)} соответствует первой
половине, которая может быть чем угодно, но следующее @samp{\1} должно
соответствовать тому же самому тексту.

Если конструкция @samp{\(@dots{}\)} соответствует более одного раза
(что может произойти, например, если за ней следует @samp{*}), записывается
только последнее совпадение.

Если конкретная конструкция группировки в регулярном выражении никогда не
была сопоставлена - например, если она появляется внутри альтернативы,
которая не использовалась, или внутри повторения, которое повторяется ноль
раз - тогда соответствующая конструкция @samp{\@var{digit}} никогда не
соответствует чему-нибудь.  Используя искусственный пример,
@samp{\(foo\(b*\)\|lose\)\} не может соответствовать @samp{lose}: вторая
альтернатива внутри большей группы соответствует єтому, но тогда @samp{\2}
не определено и не может ничему сопоставиться.  Но может соответствовать
@samp{foobb}, потому что первая альтернатива соответствует @samp{foob}, а
@samp{\2} соответствует @samp{b}.

@item \w
@cindex @samp{\w} in regexp
соответствует любому символу, составляющему слово.  Таблица синтаксиса
редактора определяет, какие это символы.  @xref{Syntax Tables}.

@item \W
@cindex @samp{\W} in regexp
соответствует любому символу, не входящему в состав слова.

@item \s@var{code}
@cindex @samp{\s} in regexp
соответствует любому символу с синтаксисом @var{code}.  Здесь @var{code} -
это символ, представляющий синтаксический код: таким образом, @samp{w} для
составляющей слова, @samp{-} для пробелов, @samp{(} для открытых скобок и
так далее.  Для представления синтаксиса пробелов используйте либо @samp{-},
либо пробел.  @xref{Syntax Class Table}, для списка кодов синтаксиса и
символов, которые их обозначают.

@item \S@var{code}
@cindex @samp{\S} in regexp
соответствует любому символу, синтаксис которого не является @var{code}.

@cindex category, regexp search for
@item \c@var{c}
соответствует любому символу с категорией @var{c}.  Здесь @var{c} - это
символ, представляющий категорию: таким образом, @samp{c} для китайских
символов или @samp{g} для греческих символов в стандартной таблице
категорий.  Можно увидеть список всех определенных в настоящее время
категорий с помощью @kbd{M-x describe-categories @key{RET}}.  Также можно
определить свои собственные категории в дополнение к стандартным, используя
функцию @code{define-category} (@pxref{Categories}).

@item \C@var{c}
соответствует любому символу, категория которого не является @var{c}.
@end table

  Следующие конструкции регулярных выражений соответствуют пустой строке -
то есть они не используют никаких символов - но их соответствие зависит от
контекста.  Для всех начало и конец доступной части буфера обрабатываются
так, как если бы они были фактическим началом и концом буфера.

@table @samp
@item \`
@cindex @samp{\`} in regexp
совпадает с пустой строкой, но только в начале сравниваемого буфера или
строки.

@item \'
@cindex @samp{\'} in regexp
совпадает с пустой строкой, но только в конце буфера или строки, с которой
сопоставляется.

@item \=
@cindex @samp{\=} in regexp
соответствует пустой строке, но только в точке.  (Эта конструкция не
определяется при сопоставлении со строкой.)

@item \b
@cindex @samp{\b} in regexp
соответствует пустой строке, но только в начале или в конце слова.  Таким
образом, @samp{\bfoo\b} соответствует любому появлению @samp{foo} как
отдельного слова.  @samp{\bballs?\b} соответствует @samp{ball} или
@samp{balls} как отдельное слово.

@samp{\b} соответствует началу или концу буфера (или строки) независимо от
того, какой текст появляется рядом с ним.

@item \B
@cindex @samp{\B} in regexp
соответствует пустой строке, но @emph{не} в начале или конце слова, а также
в начале или конце буфера (или строки).

@item \<
@cindex @samp{\<} in regexp
соответствует пустой строке, но только в начале слова.  @samp{\<}
соответствует началу буфера (или строки), только если за ним следует символ,
составляющий слово.

@item \>
@cindex @samp{\>} in regexp
соответствует пустой строке, но только в конце слова. @samp{\>}
соответствует концу буфера (или строки), только если содержимое
заканчивается символом, составляющим слово.

@item \_<
@cindex @samp{\_<} in regexp
соответствует пустой строке, но только в начале символа.  Символ - это
последовательность из одного или нескольких символов, составляющих слово или символ.
@samp{\_<} соответствует началу буфера (или строки), только если за ним следует
символ, составляющий символ.

@item \_>
@cindex @samp{\_>} in regexp
соответствует пустой строке, но только в конце символа.  @samp{obr_>} соответствует
концу буфера (или строки), только если содержимое заканчивается символом,
составляющим символ.
@end table

@kindex invalid-regexp
  Не каждая строка является допустимым регулярным выражением.  Например, строка,
которая заканчивается внутри альтернативного символа без завершающего @samp{]},
недействительна, как и строка, которая заканчивается одним @samp{\}.  Если в любую из
функций поиска передается недопустимое регулярное выражение, выдается сигнал об ошибке
@code{invalid-regexp}.

@node Regexp Example
@subsection Пример Сложного Регулярного Выражения

  Вот сложное регулярное выражение, которое раньше использовалось Emacs для
распознавания конца предложения вместе с любыми последующими пробелами.  (В настоящее
время Emacs использует похожее, но более сложное регулярное выражение по умолчанию,
созданное функцией @code{sentence-end}.  @xref{Standard Regexps}.)

  Ниже сначала показывается регулярное выражение как строка в синтаксисе Lisp (чтобы
отличить пробелы от символов табуляции), а затем результат его вычисления.  Строковая
константа начинается и заканчивается двойными кавычками.  @samp{\"} означает двойные
кавычки как часть строки, @samp{\\} для обратной косой черты как части строки,
@samp{\t} для табуляции и @samp{\n} для новой строки.

@example
@group
"[.?!][]\"')@}]*\\($\\| $\\|\t\\|@ @ \\)[ \t\n]*"
     @result{} "[.?!][]\"')@}]*\\($\\| $\\|  \\|@ @ \\)[
]*"
@end group
@end example

@noindent
В выводе табуляция и новая строка отображаются сами по себе.

  Это регулярное выражение состоит из четырех частей подряд и может быть расшифровано
следующим образом:

@table @code
@item [.?!]
Первая часть шаблона - это альтернативный символ, который соответствует любому из
трех символов: точка, вопросительный знак и восклицательный знак.  Сопоставление
должно начинаться с одного из этих трех символов.  (Это тот момент, когда новое
регулярное выражение по умолчанию, используемое Emacs, отличается от старого.  Новое
значение также допускает некоторые символы не-@acronym{ASCII}, которые заканчивают
предложение без следующих пробелов.)

@item []\"')@}]*
Вторая часть шаблона соответствует любым закрывающим скобкам и кавычкам, нулю или
более, которые могут следовать за точкой, вопросительным знаком или восклицательным
знаком.  @code{\"} - это синтаксис Lisp для двойных кавычек в строке.  @samp{*} в
конце указывает, что непосредственно предшествующее регулярное выражение (в данном
случае альтернативный символ) может повторяться ноль или более раз.

@item \\($\\|@ $\\|\t\\|@ @ \\)
Третья часть шаблона соответствует пробелу, который следует за концом предложения:
конец строки (необязательно с пробелом), табуляция или два пробела.  Двойные обратные
косые черты экранируют круглые скобки и вертикальные полосы как синтаксис регулярного
выражения; круглые скобки ограничивают группу, а вертикальные полосы отделяют
альтернативы.  Знак доллара используется для обозначения конца строки.

@item [ \t\n]*
Наконец, последняя часть шаблона соответствует любому дополнительному пробелу сверх
минимума, необходимого для завершения предложения.
@end table

@node Regexp Functions
@subsection Функции Регулярных Выражений

  Эти функции работают с регулярными выражениями.

@cindex quote special characters in regexp
@defun regexp-quote string
Функция возвращает регулярное выражение, единственное точное совпадение которого
- @var{string}.  Использование этого регулярного выражения в @code{looking-at} будет
успешным, только если следующие символы в буфере будут @var{string}; использование его
в функции поиска будет успешным, если искомый текст содержит @var{string}.
@xref{Regexp Search}.

Это позволяет запрашивать точное совпадение строки или поиск при вызове функции,
которая требует регулярного выражения.

@example
@group
(regexp-quote "^The cat$")
     @result{} "\\^The cat\\$"
@end group
@end example

Одно из применений @code{regexp-quote} - объединение точного совпадения строки с
контекстом, описываемым как регулярное выражение.  Например, выполняется поиск строки,
являющейся значением @var{string}, окруженной пробелами:

@example
@group
(re-search-forward
 (concat "\\s-" (regexp-quote string) "\\s-"))
@end group
@end example
@end defun

@cindex optimize regexp
@defun regexp-opt strings &optional paren
Функция возвращает эффективное регулярное выражение, которое будет соответствовать
любой из строк в списке @var{strings}.  Это полезно, когда нужно выполнить
сопоставление или поиск как можно быстрее - например, для режима Font Lock@footnote{
Обратите внимание, что @code{regexp-opt} не гарантирует, что его результат будет
абсолютно наиболее эффективным из возможных.  Регулярное выражение, настроенное
вручную, иногда может быть немного более эффективным, но почти никогда не стоит
затраченных усилий.}.
@c E.g., see https://debbugs.gnu.org/2816

Необязательный аргумент @var{paren} может быть любым из следующих:

@table @asis
@item a string
Получившемуся регулярному выражению предшествует @var{paren}, а за ним - @samp{\)},
например используйте @samp{"\\(?1:"} для создания явно пронумерованной группы.

@item @code{words}
Результирующее регулярное выражение окружено @samp{\<\(} и @samp{\)\>}.

@item @code{symbols}
Результирующее регулярное выражение окружено @samp{\_<\(} и @samp{\)\_>} (это часто
уместно при сопоставлении ключевых слов языка программирования и тому подобному).

@item не-@code{nil}
Результирующее регулярное выражение окружено @samp{\(} и @samp{\)}.

@item @code{nil}
Результирующее регулярное выражение окружено @samp{\(?:} и @samp{\)}, если необходимо
гарантировать, что добавленный к нему постфиксный оператор будет применяться ко всему
выражению.
@end table

Результирующее регулярное выражение @code{regexp-opt} эквивалентно, но обычно более
эффективно, чем у упрощенной версии:

@example
(defun simplified-regexp-opt (strings &optional paren)
 (let ((parens
        (cond
         ((stringp paren)       (cons paren "\\)"))
         ((eq paren 'words)    '("\\<\\(" . "\\)\\>"))
         ((eq paren 'symbols) '("\\_<\\(" . "\\)\\_>"))
         ((null paren)          '("\\(?:" . "\\)"))
         (t                       '("\\(" . "\\)")))))
   (concat (car parens)
           (mapconcat 'regexp-quote strings "\\|")
           (cdr parens))))
@end example
@end defun

@defun regexp-opt-depth regexp
Функция возвращает общее количество группирующих конструкций (выражений в скобках) в
@var{regexp}.  Сюда не входят застенчивые группы. (@pxref{Regexp Backslash}).
@end defun

@c Предположительно внутренняя функция regexp-opt, table.el хотя бы ее использует.
@defun regexp-opt-charset chars
Функция возвращает регулярное выражение, соответствующее символу в списке символов
@var{chars}.

@example
(regexp-opt-charset '(?a ?b ?c ?d ?e))
     @result{} "[a-e]"
@end example
@end defun

@c Внутренние функции: regexp-opt-group

@node Regexp Search
@section Поиск с Использованием Регулярных Выражений
@cindex regular expression searching
@cindex regexp searching
@cindex searching for regexp

  В GNU Emacs можно искать следующее совпадение для регулярного выражения
(@pxref{Syntax of Regexps}) либо постепенно, либо нет.  Для команд инкрементного
поиска, смотреть @ref{Regexp Search, , Regular Expression Search, emacs, The GNU Emacs
Manual}.  Здесь описываются только функции поиска, полезные в программах.  Главная
- @code{re-search-forward}.

  Эти функции поиска преобразуют регулярное выражение в многобайтовое, если буфер
многобайтовый; преобразуют регулярное выражение в однобайтовое, если буфер
однобайтовый.  @xref{Text Representations}.

@deffn Command re-search-forward regexp &optional limit noerror count
Функция ищет в текущем буфере строку текста, которая соответствует регулярному
выражению @var{regexp}.  Функция пропускает любой объем текста, который не
соответствует @var{regexp}, и оставляет точку в конце первого найденного совпадения.
Возвращает новое значение точки.

Если @var{limit} равен не-@code{nil}, это должно быть позицией в текущем буфере.
Определяет верхнюю границу поиска.  Никакие совпадения после этой позиции не
принимаются.  Если @var{limit} опущено или @code{nil}, по умолчанию используется конец
доступной части буфера.

Что делает @code{re-search-forward} при неудачном поиске, зависит от значения
@var{noerror}:

@table @asis
@item @code{nil}
Сигнализировать об ошибке @code{search-failed}.
@item @code{t}
Ничего не делать и вернуть @code{nil}.
@item anything else
Переместить точку в @var{limit} (или конец доступной части буфера) и вернуть
@code{nil}.
@end table

Аргумент @var{noerror} влияет только на допустимые поиски, которые не
могут найти совпадения.  Неверные аргументы вызывают ошибки независимо
от @var{noerror}.

Если @var{count} - положительное число @var{n}, поиск выполняется @var{n}
раз; каждый последующий поиск начинается в конце предыдущего совпадения.
Если все эти последовательные поиски успешны, вызов функции завершается
успешно, точка перемещается и возвращается новое значение.  В противном
случае вызов функции завершится неудачно, и результаты будут зависеть от
значения @var{noerror}, как описано выше.  Если @var{count} - отрицательное
число @minus{}@var{n}, поиск выполняется @var{n} раз в обратном (обратном)
направлении.

В следующем примере точка изначально находится перед @samp{T}.  Оценка
поискового вызова перемещает точку в конец этой строки (между @samp{t}
@samp{hat} и новой строкой).

@example
@group
---------- Buffer: foo ----------
I read "@point{}The cat in the hat
comes back" twice.
---------- Buffer: foo ----------
@end group

@group
(re-search-forward "[a-z]+" nil t 5)
     @result{} 27

---------- Buffer: foo ----------
I read "The cat in the hat@point{}
comes back" twice.
---------- Buffer: foo ----------
@end group
@end example
@end deffn

@c На эту привязку ссылается строка документации re-search-backward.
@anchor{re-search-backward}
@deffn Command re-search-backward regexp &optional limit noerror count
Функция ищет в текущем буфере строку текста, совпадающую с регулярным
выражением @var{regexp}, в обратном направлении, оставляя точку в начале
первого найденного текста.

Функция аналогична @code{re-search-forward}, но это не просто зеркальное отображение.
@code{re-search-forward} находит совпадение, начало которого максимально близко к
начальной точке.  Если бы @code{re-search-backward} было идеальным зеркальным
отображением, нашло бы совпадение, конец которого находится как можно ближе.
Однако на самом деле находит совпадение, начало которого максимально близко
(и все же заканчивается до начальной точки).  Причина этого в том, что
сопоставление регулярного выражения в заданном месте всегда работает
от начала до конца и начинается с указанной начальной позиции.

Истинное зеркальное отображение @code{re-search-forward} потребует
специальной функции для сопоставления регулярных выражений от начала
до конца.  Не стоит пытаться реализовать это.
@end deffn

@defun string-match regexp string &optional start
Функция возвращает индекс начала первого совпадения для регулярного
выражения @var{regexp} в @var{string} или @code{nil}, если совпадений нет.
Если @var{start} равно не-@code{nil}, поиск начинается с этого индекса в
@var{string}.

Пример,

@example
@group
(string-match
 "quick" "The quick brown fox jumped quickly.")
     @result{} 4
@end group
@group
(string-match
 "quick" "The quick brown fox jumped quickly." 8)
     @result{} 27
@end group
@end example

@noindent
Индекс первого символа строки равен 0, индекс второго символа
равен 1 и так далее.

Если функция находит совпадение, индекс первого символа после
совпадения доступен как @code{(match-end 0)}.  @xref{Match Data}.

@example
@group
(string-match
 "quick" "The quick brown fox jumped quickly." 8)
     @result{} 27
@end group

@group
(match-end 0)
     @result{} 32
@end group
@end example
@end defun

@defun string-match-p regexp string &optional start
Функция предиката делает то же, что и @code{string-match}, но
избегает изменения данных соответствия.
@end defun

@defun looking-at regexp
Функция определяет, соответствует ли текст в текущем буфере,
следующий сразу за точкой, регулярному выражению @var{regexp}.
``Непосредственно после'' означает именно это: поиск ведется по
``якорю'', и он может быть успешным только начиная с первого
символа, следующего за точкой.  Если да, то результатом будет
@code{t}, в противном случае - @code{nil}.

Функция не перемещает точку, но обновляет данные соответствия.
@xref{Match Data}.  Если нужно проверить соответствие без
изменения данных соответствия, используется @code{looking-at-p},
как описано ниже.

В этом примере точка расположена непосредственно перед @samp{T}.
Если бы это было где-то еще, результатом было бы @code{nil}.

@example
@group
---------- Buffer: foo ----------
I read "@point{}The cat in the hat
comes back" twice.
---------- Buffer: foo ----------

(looking-at "The cat in the hat$")
     @result{} t
@end group
@end example
@end defun

@defun looking-back regexp limit &optional greedy
Функция возвращает @code{t}, если @var{regexp} соответствует
тексту непосредственно перед точкой (то есть заканчивается в точке),
и @code{nil} в противном случае.

Поскольку сопоставление регулярных выражений работает только в
прямом направлении, это реализуется путем поиска в обратном
направлении от точки совпадения, которое заканчивается в точке.
Это может быть довольно медленным, если ему нужно искать на
большом расстоянии.  Можно ограничить требуемое время, указав
значение не-@code{nil} для @var{limit}, которое запрещает поиск
до @var{limit}.  В этом случае найденное совпадение должно
начинаться с @var{limit} или после него.  Вот пример:

@example
@group
---------- Buffer: foo ----------
I read "@point{}The cat in the hat
comes back" twice.
---------- Buffer: foo ----------

(looking-back "read \"" 3)
     @result{} t
(looking-back "read \"" 4)
     @result{} nil
@end group
@end example

Если @var{greedy} равен не-@code{nil}, функция расширяет
совпадение в обратном направлении, насколько это возможно,
останавливаясь, когда один дополнительный предыдущий символ
не может быть частью совпадения для @var{regexp}.  Когда совпадение
продлевается, его начальная позиция может находиться до @var{limit}.

@c https://debbugs.gnu.org/5689
В качестве общей рекомендации старайться по возможности избегать
использования @code{looking-back}, поскольку это медленно.  По
этой причине не планируется добавлять функцию @code{looking-back-p}.
@end defun

@defun looking-at-p regexp
Функция предиката работает как @code{looking-at}, но без обновления
данных соответствия.
@end defun

@defvar search-spaces-regexp
Если эта переменная - не-@code{nil}, это должно быть регулярное
выражение, которое говорит, как искать пробелы.  В этом случае
любая группа пробелов в поисковом регулярном выражении означает
использование этого регулярного выражения.  Однако на пробелы
внутри таких конструкций, как @samp{[@dots{}]} и @samp{*},
@samp{+}, @samp{?}, @code{search-spaces-regexp} не влияет.

Поскольку эта переменная влияет на все конструкции поиска и
сопоставления регулярных выражений, вам следует временно привязать
ее к как можно меньшей части кода.
@end defvar

@node POSIX Regexps
@section POSIX Поисковые Регулярные Выражения

@cindex backtracking and POSIX regular expressions
  Обычные функции регулярных выражений выполняют обратный поиск,
когда это необходимо для обработки конструкций @samp{\|} и повторения,
но они продолжают это только до тех пор, пока не найдут @emph{некоторое}
совпадение.  Затем они добиваются успеха и сообщают о первом
найденном совпадении.

  В этом разделе описаны альтернативные функции поиска, которые
выполняют полное отслеживание с возвратом, указанное стандартом
POSIX для сопоставления регулярных выражений.  Они продолжают
поиск с возвратом, пока не испробуют все возможности и не найдут
все совпадения, чтобы сообщить о самом длинном совпадении, как
того требует POSIX@.  Это намного медленнее, поэтому используйте
эти функции только тогда, когда вам действительно нужно самое
длинное совпадение.

  Функции поиска и сопоставления POSIX не поддерживают должным
образом нежадные операторы повторения (@pxref{Regexp Special, non-greedy}).
Это связано с тем, что обратное отслеживание POSIX конфликтует
с семантикой нежадного повторения.

@deffn Command posix-search-forward regexp &optional limit noerror count
Это похоже на @code{re-search-forward}, за исключением того,
что выполняет полный поиск с возвратом, указанный стандартом POSIX
для сопоставления регулярных выражений.
@end deffn

@deffn Command posix-search-backward regexp &optional limit noerror count
Это похоже на @code{re-search-backward}, за исключением того, что
выполняется полный поиск с возвратом, указанный стандартом POSIX
для сопоставления регулярных выражений.
@end deffn

@defun posix-looking-at regexp
Это похоже на @code{looking-at}, за исключением того, что выполняется
полный поиск с возвратом, указанный стандартом POSIX для сопоставления
регулярных выражений.
@end defun

@defun posix-string-match regexp string &optional start
Это похоже на @code{string-match}, за исключением того, что
выполняется полный поиск с возвратом, указанный стандартом POSIX
для сопоставления регулярных выражений.
@end defun

@node Match Data
@section Данные Соответствия
@cindex match data

  Emacs отслеживает начальную и конечную позиции сегментов текста,
найденных во время поиска; это называется @dfn{Данные Соответствия
(match data)}.  Благодаря данным соответствия можно искать сложный
шаблон, например дату в почтовом сообщении, а затем извлекать части
совпадения под контролем шаблона.

  Поскольку данные соответствия обычно описывают только самый последний
поиск, потребуется осторожнасть, чтобы случайно не выполнить другой
поиск между поиском, к которому требуется вернуться, с использованием
данных соответствия.  Если не выходит избежать другого промежуточного
поиска, потребуется сохранить и восстановить данные совпадений вокруг
него, чтобы предотвратить их перезапись.

  Обратить внимание, что всем функциям разрешено перезаписывать данные
соответствия, если это явно не задокументировано.  Как следствие,
функции, которые запускаются неявно в фоновом режиме (@pxref{Timers},
and @ref{Idle Timers}), скорее всего, должны явно сохранять и
восстанавливать данные соответствия.

@menu
* Replacing Match::       Замена совпавшей подстроки.
* Simple Match Data::     Доступ к отдельным элементам данных соответствия,
                              например, где началось конкретное подвыражение.
* Entire Match Data::     Одновременный доступ ко всем данным соответствия
                              в виде списка.
* Saving Match Data::     Сохранение и восстановление данных соответствия.
@end menu

@node Replacing Match
@subsection Замена Совпадающего Текста
@cindex replace matched text

  функция заменяет весь или часть текста, найденного при
последнем поиске.  Рработает с помощью данных соответствия.

@cindex case in replacements
@defun replace-match replacement &optional fixedcase literal string subexp
Функция выполняет операцию замены буфера или строки.

Если выполнялся последний поиск в буфере, потребуется опустить
аргумент @var{string} или указать для него @code{nil} и убедиться,
что текущий буфер - это тот, в котором выполнялся последний поиск.
Затем эта функция редактирует буфер, заменяя совпадающий текст на
@var{replacement}.  Оставляет точку в конце текста замены.

Если выполнялся последний поиск в строке, передаётся та же строка,
что и в @var{string}.  Затем эта функция возвращает новую строку,
в которой совпавший текст заменен на @var{replacement}.

Если @var{fixedcase} равно не-@code{nil}, то @code{replace-match}
используется заменяющий текст без преобразования регистра; в противном
случае преобразуется заменяемый текст в зависимости от использования
заглавных букв в заменяемом тексте.  Если исходный текст написан
полностью в верхнем регистре, это преобразует замещающий текст в
верхний регистр.  Если все слова исходного текста пишутся с заглавной
буквы, все слова заменяющего текста пишутся с заглавной буквы.  Если
все слова состоят из одной буквы и все в верхнем регистре, они
рассматриваются как слова с заглавной буквы, а не как слова с
прописными буквами.

Если @var{literal} равно не-@code{nil}, то @var{replacement}
вставляется точно так, как есть, единственные изменения - это
изменение регистра по мере необходимости.  Если это @code{nil}
(по умолчанию), то символ @samp{\} обрабатывается особым образом.
Если @samp{\} появляется в @var{replacement}, то он должен
быть частью одной из следующих последовательностей:

@table @asis
@item @samp{\&}
@cindex @samp{&} in replacement
Это означает замену всего текста.

@item @samp{\@var{n}}, where @var{n} is a digit
@cindex @samp{\@var{n}} in replacement
Это означает текст, который соответствует подвыражению @var{n}ому
в исходном регулярном выражении.  Подвыражения - это выражения,
сгруппированные внутри @samp{\(@dots{}\)}.  Если подвыражение
@var{n}ое совсем не совпадало, подставляется пустая строка.

@item @samp{\\}
@cindex @samp{\} in replacement
Это означает единственный флеш @samp{\} в тексте замены.

@item @samp{\?}
Сам по себе (для совместимости с @code{replace-regexp} и
связанными командами; @pxref{Regexp Replace,,, emacs, The GNU
Emacs Manual}).
@end table

@noindent
Любой другой символ, следующий за @samp{\}, сигнализируется об ошибке.

Подстановки, выполняемые @samp{\&} and @samp{\@var{n}}, происходят
после преобразования регистра, если имеется.  Следовательно, строки,
которые они заменяют, никогда не преобразуются в регистр.

Если @var{subexp} равно не-@code{nil}, это означает замену только
подвыражения с номером @var{subexp} совпавшего регулярного выражения,
а не всего совпадения.  Например, после сопоставления @samp{foo \(ba*r\)}
вызов @code{replace-match} с 1 как @var{subexp} означает замену только
текста, соответствующего @samp{\(ba*r\)}.
@end defun

@defun match-substitute-replacement replacement &optional fixedcase literal string subexp
Функция возвращает текст, который будет вставлен в буфер с помощью
@code{replace-match}, но без изменения буфера.  Это полезно, если
требуется представить пользователю фактический результат замены с
такими конструкциями, как @samp{\@var{n}} или @samp{\&}, замененными
согласованными группами.  Аргументы @var{replacement} и
необязательный @var{fixedcase}, @var{literal}, @var{string} и
@var{subexp} имеют то же значение, что и аргументы @code{replace-match}.
@end defun

@node Simple Match Data
@subsection Простой Доступ к Данным Соответствия

  В этом разделе объясняется, как использовать данные сопоставления,
чтобы узнать, что было сопоставлено последней операцией поиска или
сопоставления, если она была успешной.

  Можно спросить обо всем совпадающем тексте или о конкретном
подвыражении регулярного выражения в скобках.  Аргумент @var{count}
в приведенных ниже функциях указывает в каком именно.  Если
@var{count} равен нулю, спрашивается обо всем совпадении. Если
@var{count} положительно, указывается, какое подвыражение требуется.

  Напомнание, что подвыражения регулярного выражения - это выражения,
сгруппированные с помощью экранированных скобок, @samp{\(@dots{}\)}.
Подвыражение @var{count} находится путем подсчета вхождений @samp{\(}
с начала всего регулярного выражения.  Первое подвыражение имеет
номер 1, второе - 2 и так далее.  Подвыражения могут быть только в
регулярных выражениях - после простого строкового поиска единственная
доступная информация - это полное совпадение.

  Каждый успешный поиск устанавливает данные соответствия.  Следовательно,
потребуется запросить данные соответствия сразу после поиска, прежде
чем вызывать любую другую функцию, которая может выполнить другой поиск.
В качестве альтернативы можно сохранить и восстановить данные
соответствия (@pxref{Saving Match Data}) вокруг вызова функций,
которые могли бы выполнять другой поиск.  Или использовать функции,
которые явно не изменяют данные соответствия; как, @code{string-match-p}.

@c Это старый комментарий, и, по-видимому, сейчас нет никаких
@c перспектив его изменения.  Но все же совет остается в силе.
  Неудачный поиск может изменить или не изменить данные соответствия.
В текущей реализации этого нет, но может измениться в будущем.
Не пытаться полагаться на значение данных соответствия после
неудачного поиска.

@defun match-string count &optional in-string
Функция возвращает в виде строки текст, найденный в последней
операции поиска или сопоставления.  Возвращается весь текст,
если @var{count} равен нулю, или только часть, соответствующая
подвыражению @var{count} в скобках, если @var{count} положительно.

Если последняя такая операция была проделана со строкой с
@code{string-match}, то потребуется передать ту же строку,
что и аргумент @var{in-string}.  После поиска или сопоставления
буфера требуется опустить @var{in-string} или передать для него
@code{nil}; и убедиться, что текущий буфер при вызове
@code{match-string} - это тот буфер, в котором выполнялся
поиск или сопоставление.  Несоблюдение этого совета приведет
к неверным результатам.

Значение - @code{nil}, если @var{count} выходит за пределы
допустимого диапазона, или для подвыражения внутри альтернативы
@samp{\|}, которое не использовалось, или для повторения,
которое повторяется ноль раз.
@end defun

@defun match-string-no-properties count &optional in-string
Функция похожа на @code{match-string}, за исключением того, что
результат не имеет текстовых свойств.
@end defun

@defun match-beginning count
Если последний поиск регулярного выражения нашел совпадение,
эта функция возвращает позицию начала совпадающего текста
или его части.

Если @var{count} равно нулю, то значение является позицией
начала всего совпадения.  В противном случае @var{count}
указывает подвыражение в регулярном выражении, а значение функции
является начальной позицией совпадения для этого подвыражения.

Значение @code{nil} для подвыражения внутри альтернативы
@samp{\|}, которое не использовалось, или повторения, которое
повторяется ноль раз.
@end defun

@defun match-end count
Функция похожа на @code{match-beginning}, за исключением того,
что возвращает позицию конца совпадения, а не позицию начала.
@end defun

  Вот пример использования данных соответствия с комментарием,
показывающим позиции в тексте:

@example
@group
(string-match "\\(qu\\)\\(ick\\)"
              "The quick fox jumped quickly.")
              ;0123456789
     @result{} 4
@end group

@group
(match-string 0 "The quick fox jumped quickly.")
     @result{} "quick"
(match-string 1 "The quick fox jumped quickly.")
     @result{} "qu"
(match-string 2 "The quick fox jumped quickly.")
     @result{} "ick"
@end group

@group
(match-beginning 1)       ; @r{Начало соответствия}
     @result{} 4          ; @r{с @samp{qu} находится в индексе 4.}
@end group

@group
(match-beginning 2)       ; @r{Начало соответствия}
     @result{} 6          ; @r{с @samp{ick} находится в индексе 6.}
@end group

@group
(match-end 1)             ; @r{Конец совпадения}
     @result{} 6          ; @r{с @samp{qu} находится в индексе 6.}

(match-end 2)             ; @r{Конец совпадения}
     @result{} 9          ; @r{с @samp{ick} находится в индексе 9.}
@end group
@end example

  Другой пример.  Точка изначально находится в начале строки. Поиск
перемещает курсор между пробелом и словом @samp{in}.  Начало
совпадения находится на 9-м символе буфера (@samp{T}), а начало
совпадения для первого подвыражения - на 13-м символе (@samp{c}).

@example
@group
(list
  (re-search-forward "The \\(cat \\)")
  (match-beginning 0)
  (match-beginning 1))
    @result{} (17 9 13)
@end group

@group
---------- Buffer: foo ----------
I read "The cat @point{}in the hat comes back" twice.
        ^   ^
        9  13
---------- Buffer: foo ----------
@end group
@end example

@noindent
(В этом случае возвращаемый индекс - это позиция буфера;
первый символ буфера считается 1.)

@node Entire Match Data
@subsection Доступ ко всем Данным Соответствия

  Функции @code{match-data} и @code{set-match-data} считывают
или записывают все данные соответствия одновременно.

@defun match-data &optional integers reuse reseat
Функция возвращает список позиций (маркеров или целых
чисел), в которых записана вся информация о тексте,
соответствующем последнему поисковому запросу.  Нулевой элемент -
это позиция начала совпадения для всего выражения;  Первым
элементом является позиция конца совпадения для выражения.
Следующие два элемента - это позиции начала и конца совпадения
для первого подвыражения и так далее.  В общем случае элемент
@ifnottex
номер 2@var{n}
@end ifnottex
@tex номер {\mathsurround=0pt $2n$}
@end tex
соответствует @code{(match-beginning @var{n})}; и
элемент
@ifnottex
номер 2@var{n} + 1
@end ifnottex
@tex
number {\mathsurround=0pt $2n+1$}
@end tex
соответствует @code{(match-end @var{n})}.

Обычно все элементы являются маркерами или @code{nil}, но
если @var{integers} равно не-@code{nil}, это означает
использование целых чисел вместо маркеров.  (В этом случае
сам буфер добавляется как дополнительный элемент в конце
списка, чтобы облегчить полное восстановление данных
соответствия.)  Если последнее совпадение было выполнено
для строки с @code{string-match}, то всегда используются
целые числа, поскольку маркеры не могут указывать на строку.

Если @var{reuse} равен не-@code{nil}, это должен быть список.
В этом случае @code{match-data} сохраняет данные соответствий
в @var{reuse}.  То есть @var{reuse} деструктивно модифицировано.
@var{reuse} не обязательно иметь правильную длину.  Если этого
недостаточно для хранения данных соответствия, оно расширяется.
Если это слишком длинно, длина @var{reuse} остается неизменной,
но для неиспользуемых элементов устанавливается значение
@code{nil}.  Цель этой функции - уменьшить потребность в
сборке мусора.

Если @var{reseat} равен не-@code{nil}, все маркеры в списке
@var{reuse} переставляются в никуда.

Как всегда, не должно быть возможности промежуточного поиска
между вызовом функции поиска и вызовом @code{match-data},
который предназначен для доступа к данным соответствия для
этого поиска.

@example
@group
(match-data)
     @result{}  (#<marker at 9 in foo>
          #<marker at 17 in foo>
          #<marker at 13 in foo>
          #<marker at 17 in foo>)
@end group
@end example
@end defun

@defun set-match-data match-list &optional reseat
Функция устанавливает данные соответствия из элементов
@var{match-list}, которые должны быть списком, который
был значением предыдущего вызова @code{match-data}. (Точнее,
все, что имеет тот же формат, будет работать.)

Если @var{match-list} относится к несуществующему буферу,
не получится ошибка; которая устанавливает данные
соответствия бессмысленным, но безвредным способом.

Если @var{reseat} равен не-@code{nil}, все маркеры в списке
@var{match-list} переставляются в никуда.

@c TODO Сделать его устаревшим.
@findex store-match-data
@code{store-match-data} - это полу-устаревший псевдоним для
@code{set-match-data}.
@end defun

@node Saving Match Data
@subsection Сохранение и Восстановление Данных Соответствия

  Когда вызывается функция, которая может выполняться поиск,
может потребоваться сохранить и восстановить данные совпадений
вокруг этого вызова, если хотите сохранить данные совпадений из
более раннего поиска для дальнейшего использования.  Вот пример,
показывающий проблему, которая возникает, если не получается
сохранить данные совпадения:

@example
@group
(re-search-forward "The \\(cat \\)")
     @result{} 48
(foo)                   ; @r{@code{foo} выполняет больше поиска.}
(match-end 0)
     @result{} 61              ; @r{Неожиданный результат---не 48!}
@end group
@end example

  Можно сохранить и восстановить данные матча с помощью @code{save-match-data}:

@defmac save-match-data body@dots{}
Этот макрос выполняет @var{body}, сохраняя и восстанавливая данные
соответствия вокруг него.  Возвращаемое значение - это значение
последней формы в @var{body}.
@end defmac

  Можно использовать @code{set-match-data} вместе с @code{match-data}
для имитации эффекта специальной формы @code{save-match-data}.  Вот как:

@example
@group
(let ((data (match-data)))
  (unwind-protect
      @dots{}   ; @r{Ok, чтобы изменить исходные данные соответствия.}
    (set-match-data data)))
@end group
@end example

  Emacs автоматически сохраняет и восстанавливает данные совпадений,
когда запускает функции фильтрации процессов (@pxref{Filter Functions})
и контрольных сигналов процесса (@pxref{Sentinels}).

@ignore
  Вот функция, которая восстанавливает данные совпадения при условии,
что связанный с ними буфер все еще существует.

@smallexample
@group
(defun restore-match-data (data)
@c Неверно разбивать первую строку строки документа.
@c Если здесь есть проблема, ее нужно решить как-то иначе.
  "Восстановите данные соответствия DATA, если буфер не отсутствует."
  (catch 'foo
    (let ((d data))
@end group
      (while d
        (and (car d)
             (null (marker-buffer (car d)))
@group
             ;; @file{match-data} @r{буфер удален.}
             (throw 'foo nil))
        (setq d (cdr d)))
      (set-match-data data))))
@end group
@end smallexample
@end ignore

@node Search and Replace
@section Искать и Заменить
@cindex replacement after search
@cindex searching and replacing

  Если требуется найти все совпадения для регулярного выражения
в части буфера и заменить их, лучший способ - написать явный
цикл с использованием @code{re-search-forward} и
@code{replace-match}, например:

@example
(while (re-search-forward "foo[ \t]+bar" nil t)
  (replace-match "foobar"))
@end example

@noindent
@xref{Replacing Match,, Replacing the Text that Matched}, для
описания @code{replace-match}.

  Однако заменить совпадения в строке сложнее, особенно
если требуется сделать это эффективно.  Итак, Emacs
предоставляет для этого функцию.

@defun replace-regexp-in-string regexp rep string &optional fixedcase literal subexp start
Функция копирует @var{string}, ищет в нем совпадения для
@var{regexp} и заменяет их на @var{rep}.  Возвращает
измененную копию.  Если @var{start} равен не-@code{nil},
поиск совпадений начинается с этого индекса в @var{string},
поэтому совпадения, начинающиеся до этого индекса,
не изменяются.

Функция использует @code{replace-match} для замены и передает
необязательные аргументы @var{fixedcase}, @var{literal} и
@var{subexp} вместе с @code{replace-match}.

Вместо строки @var{rep} может быть функцией.  В этом случае
@code{replace-regexp-in-string} вызывает @var{rep} для каждого
совпадения, передавая текст совпадения в качестве единственного
аргумента.  Он собирает значение, возвращаемое @var{rep}, и
передает его в @code{replace-match} в качестве строки замены.
Данные соответствия на этом этапе являются результатом
сопоставления @var{regexp} с подстрокой @var{string}.
@end defun

  Если требуется написать команду в строках @code{query-replace},
можно использовать @code{perform-replace} для выполнения этой работы.

@defun perform-replace from-string replacements query-flag regexp-flag delimited-flag &optional repeat-count map start end backward region-noncontiguous-p
Функция - основа @code{query-replace} и связанных с ней команд.
Ищет в тексте вхождения @var{from-string} между позициями @var{start}
и @var{end} и заменяет некоторые или все из них.  Если @var{start}
равно @code{nil} (или опущено), вместо этого используется точка, а
конец доступной части буфера используется для @var{end}.  (Если
необязательный аргумент @var{backward} - не-@code{nil}, поиск
начинается с @var{end} и идет в обратном направлении.)

Если @var{query-flag} равно @code{nil}, заменяется все вхождения;
в противном случае спрашивается пользователь, что делать с каждым
из них.

Если @var{regexp-flag} равно не-@code{nil}, то @var{from-string}
считается регулярным выражением; в противном случае он должен
совпадать буквально.  Если @var{delimited-flag} - не-@code{nil},
то рассматриваются только замены, заключенные в границы слов.

Аргумент @var{replacements} указывает, чем заменить вхождения.
Если это строка, используется эта строка.  Это также может быть
список строк, используемых в циклическом порядке.

Если @var{replacements} является cons-ячейкой,
@w{@code{(@var{function} . @var{data})}}, это означает вызов
@var{function} после каждого совпадения для получения текста замены.
Эта функция вызывается с двумя аргументами: @var{data} и количество
уже выполненных замен.

Если @var{repeat-count} равно не-@code{nil}, это должно быть целое
число.  Затем указывается, сколько раз использовать каждую из строк
в списке @var{replacements} перед циклическим переходом к следующей.

Если @var{from-string} содержит буквы в верхнем регистре, то
@code{perform-replace} связывает @code{case-fold-search} с
@code{nil} и использует @var{replacements} без изменения
их регистра.

Обычно раскладка @code{query-replace-map} определяет возможные
ответы пользователя на запросы.  Аргумент @var{map}, если
не-@code{nil}, указывает раскладку клавиатуры, которая будет
использоваться вместо @code{query-replace-map}.

не-@code{nil} @var{region-noncontiguous-p} означает, что
область между @var{start} и @var{end} состоит из несмежных
частей.  Самый распространенный пример - прямоугольная область,
где части разделены символами новой строки.

Функция использует одну из двух функций для поиска следующего
появления @var{from-string}.  Эти функции задаются значениями
двух переменных: @code{replace-re-search-function} и
@code{replace-search-function}.  Первое вызывается, когда
аргумент @var{regexp-flag} равен не-@code{nil}, второе - когда
равно @code{nil}.
@end defun

@defvar query-replace-map
Переменная содержит специальную раскладку, которая определяет
допустимые ответы пользователя для @code{perform-replace} и
команд, которые это используют, а также для @code{y-or-n-p}
и @code{map-y-or-n-p}.  Эта карта необычна в двух отношениях:

@itemize @bullet
@item
Привязки клавиш - это не команды, а просто символы, которые
имеют значение для функций, использующих эту карту.

@item
Ключи префикса не поддерживаются; каждая привязка клавиш должна
быть для последовательности клавиш с одним событием.  Это потому,
что функции не используют @code{read-key-sequence} для получения
входных данных; вместо этого они читают одно событие и ищут
его ``рукой''.
@end itemize
@end defvar

Вот значимые привязки для @code{query-replace-map}.  Некоторые
из них имеют смысл только для @code{query-replace} и производные
этого.

@table @code
@item act
Выполнить рассматриваемое действие - другими словами, ``да''.

@item skip
Не предпринимать никаких действий по этому вопросу ---
другими словами, ``нет''.

@item exit
Ответить на этот вопрос ``нет'' и отказаться от всей серии
вопросов, предполагая, что ответы будут ``нет''.

@item exit-prefix
Аналогично @code{exit}, но добавляется нажатие клавиши в
@code{unread-command-events} (@pxref{Event Input Misc}).

@item act-and-exit
Ответить на этот вопрос ``да'' и отказаться от всей серии
вопросов, предполагая, что последующие ответы будут ``нет''.

@item act-and-show
Ответить на этот вопрос ``да'', но показать результаты ---
до перехода к следующему вопросу.

@item automatic
Ответить на этот вопрос и все последующие вопросы в серии
используя ``да'', без дальнейшего взаимодействия с пользователем.

@item backup
Вернуться к предыдущему месту, о котором был задан вопрос.

@item undo
Отменить последнюю замену и вернуться к тому месту, где
эта замена была произведена.

@item undo-all
Отменить все замены и вернуться на место, где была
произведена первая замена.

@item edit
Ввести рекурсивное редактирование, чтобы ответить на этот
вопрос - вместо любых других действий, которые обычно выполняются.

@item edit-replacement
Отредактировать замену этого вопроса в минибуфере.

@item delete-and-edit
Удалить рассматриваемый текст, затем ввести рекурсивное
редактирование для его замены.

@item recenter
@itemx scroll-up
@itemx scroll-down
@itemx scroll-other-window
@itemx scroll-other-window-down
Выполнить указанную операцию прокрутки окна, затем снова
задать тот же вопрос.  Этот ответ используют только
@code{y-or-n-p} и связанные с этим функции.

@item quit
Немедленно выйти.  Этот ответ используют только
@code{y-or-n-p} и связанные с этим функции.

@item help
Показать некоторую справку, а затем спросить еще раз.
@end table

@defvar multi-query-replace-map
Переменная содержит ключевую карту, которая расширяет
@code{query-replace-map}, предоставляя дополнительные
сочетания ключей, которые полезны при замене нескольких
буферов.  Дополнительные привязки:

@table @code
@item automatic-all
Ответить на этот вопрос и все последующие вопросы в серии
используя ``да'', без дальнейшего взаимодействия с пользователем,
для всех оставшихся буферов.

@item exit-current
Ответить на этот вопрос ``нет'' и отказаться от всей серии
вопросов для текущего буфера.  Перейти к следующему буферу
в последовательности.
@end table
@end defvar

@defvar replace-search-function
Переменная определяет функцию, которую @code{perform-replace}
вызывает для поиска следующей строки для замены.  Это значение
по умолчанию - @code{search-forward}.  Любое другое значение
должно вызывать функцию с 3 аргументами: первыми 3 аргументами
@code{search-forward} (@pxref{String Search}).
@end defvar

@defvar replace-re-search-function
Переменная определяет функцию, которую @code{perform-replace}
вызывает для поиска следующего регулярного выражения для замены.
Это значение по умолчанию - @code{re-search-forward}.  Любое другое
значение должно вызывать функцию с 3 аргументами: первыми 3
аргументами @code{re-search-forward} (@pxref{Regexp Search}).
@end defvar

@node Standard Regexps
@section Стандартные Регулярные Выражения, Используемые при Редактировании
@cindex regexps used standardly in editing
@cindex standard regexps used in editing

  В этом разделе описаны некоторые переменные, которые содержат
регулярные выражения, используемые для определенных целей при
редактировании:

@defopt page-delimiter
Это регулярное выражение, описывающее начало строк, разделяющих
страницы.  Значение по умолчанию - @code{"^\014"}.  (точнее,
@code{"^^L"} или @code{"^обрC-l"});  это соответствует строке,
которая начинается с символа перевода страницы.
@end defopt

  Следующие два регулярных выражения @emph{не} должны предполагать,
что совпадение всегда начинается в начале строки; не должны
использовать @samp{^} для привязки совпадения.  Чаще всего команды
абзацев проверяют совпадение только в начале строки, а это значит,
что @samp{^} будет лишним.  Когда есть ненулевое левое поле,
принимаются совпадения, которые начинаются после левого поля.  В этом
случае @samp{^} будет неверным.  Однако @samp{^} безвреден в режимах,
в которых никогда не используется левое поле.

@defopt paragraph-separate
Регулярное выражение для распознавания начала строки, разделяющей
абзацы.  (Если изменить это, возможно, придется также изменить
@code{paragraph-start}.)  Значение по умолчанию -
@w{@code{"[@ обрtобрf]*$"}}, что соответствует строке, полностью
состоящей из пробелов, табуляции и каналов формы (после ее левого поля).
@end defopt

@defopt paragraph-start
Регулярное выражение для распознавания начала строки, начала
@emph{или} разделения абзацев.  Значение по умолчанию -
@w{@code{"\f\\|[ \t]*$"}}, которое соответствует строке,
содержащей только пробелы или начинающейся с подачи
формы (после его левого поля).
@end defopt

@defopt sentence-end
Если не-@code{nil}, значение должно быть регулярным выражением,
описывающим конец предложения, включая пробелы после предложения.
(Все границы абзацев также заканчивают предложения, независимо.)

Если значение равно @code{nil}, как по умолчанию, то функция
@code{sentence-end} создает регулярное выражение.  Вот почему
всегда требуется вызывать функцию @code{sentence-end}, чтобы
получить регулярное выражение, которое будет использоваться для
распознавания конца предложения.
@end defopt

@defun sentence-end
Функция возвращает значение переменной @code{sentence-end}, если
не-@code{nil}.  В противном случае возвращается значение по
умолчанию на основе значений переменных
@code{sentence-end-double-space}
(@pxref{Definition of sentence-end-double-space}),
@code{sentence-end-without-period} и
@code{sentence-end-without-space}.
@end defun
