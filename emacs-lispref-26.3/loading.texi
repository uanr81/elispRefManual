@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2019 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Loading
@chapter Загрузка
@cindex loading
@cindex library
@cindex Lisp library

  Загрузка файла с кодом Lisp означает перенос его содержимого в среду Lisp
в виде объектов Lisp.  Emacs находит и открывает файл, читает текст,
оценивает каждую форму и затем закрывает файл.  Такой файл также называется
@dfn{Библиотекой Lisp}.

  Функции загрузки оценивают все выражения в файле так же, как функция
@code{eval-buffer} оценивает все выражения в буфере.  Разница в том, что
функции загрузки читают и оценивают текст файла, находящийся на диске, а не
текст в буфере Emacs.

@cindex top-level form
  Загруженный файл должен содержать выражения Lisp либо в виде исходного
кода, либо в виде байт скомпилированного кода.  Каждая форма в файле
называется @dfn{top-level form (форма верхнего уровня)}.  Для форм в
загружаемом файле нет специального формата; любая форма в файле также может
быть введена непосредственно в буфер и обработана там.  (На практике, так
тестируется большая часть кода).  Чаще всего формы представляют собой
определения функций и определения переменных.

  Emacs может также загружать скомпилированные динамические модули:
разделяемые библиотеки, которые предоставляют дополнительные функции для
использования в программах Emacs Lisp, так же как и пакет, написанный на
Emacs Lisp.  Когда динамический модуль загружен, Emacs вызывает функцию
инициализации со специальным именем, которую модуль должен реализовать, и
которая предоставляет дополнительные функции и переменные для программ
Emacs Lisp.

Для загрузки по запросу внешних библиотек, которые, как известно заранее,
требуются некоторыми примитивами Emacs, @pxref{Dynamic Libraries}.

@menu
* How Programs Do Loading:: @code{load} и другие.
* Load Suffixes::           Подробная информация о суффиксах, которые
                            пытается использовать @code{load}.
* Library Search::          Поиск библиотеки для загрузки.
* Loading Non-ASCII::       Не-@acronym{ASCII} в файлах Emacs Lisp.
* Autoload::                Настройка функции на автозагрузку.
* Repeated Loading::        Доп меры предосторожности при загрузке файла.
* Named Features::          Загрузка библиотеки, если она еще не загружена.
* Where Defined::           Поиск файла, определяющего определенный символ.
* Unloading::               Как выгрузить загруженную библиотеку.
* Hooks for Loading::       Предоставление кода для запуска при загрузке
                            определенных библиотек.
* Dynamic Modules::         Модули предоставляют дополнительные примитивы
                            Lisp.
@end menu

@node How Programs Do Loading
@section Как Загружаются Программы

  Emacs Lisp имеет несколько интерфейсов для загрузки.  Например,
@code{autoload} создает объект-заполнитель для функции, определенной в
файле; попытка вызвать функцию автозагрузки загружает файл, чтобы получить
реальное определение функции (@pxref{Autoload}).  @code{require} загружает
файл, если она еще не загружена (@pxref{Named Features}).  В конечном итоге
все эти средства вызывают функцию @code{load} для выполнения своей работы.

@defun load filename &optional missing-ok nomessage nosuffix must-suffix
Эта функция находит и открывает файл с кодом Lisp, оценивает все формы в
нем и закрывает файл.

Чтобы найти файл, @code{load} сначала ищет файл с именем
@file{@var{filename}.elc}, то есть файл с именем @var{filename} с
добавленным расширением @samp{.elc}.  Если такой файл существует, он
загружается.  Если файла с таким именем нет, @code{load} ищет файл с именем
@file{@var{filename}.el}.  Если этот файл существует, он загружается.  Если
Emacs был скомпилирован с поддержкой динамических модулей
(@pxref{Dynamic Modules}), @code{load} затем ищет файл с именем
@file{@var{filename}.@var{ext}}, где @var{ext} - это системно-зависимое
расширение имени файла разделяемых библиотек.  Наконец, если ни одно из этих
имен не найдено, @code{load} ищет файл с именем @var{filename} без
добавочных файлов и загружает его, если он существует.  (Функция @code{load}
не умеет смотреть на @var{filename}.  В неправильном случае имени файла
@file{foo.el.el} оценка @code{(load "foo.el")} действительно найдет его).

Если режим Auto Compression включен, как по умолчанию, то, если @code{load}
не может найти файл, она ищет сжатую версию файла, прежде чем пытаться
использовать другие имена файлов.  Она распаковывает и загружает его, если
он существует.  Она ищет сжатые версии, добавляя каждый из суффиксов в
@code{jka-compr-load-suffixes} к имени файла.  Значение этой переменной
должно быть списком строк.  Стандартное значение - @code{(".gz")}.

Если необязательный аргумент @var{nosuffix} - не-@code{nil}, то @code{load}
не пытается использовать суффиксы @samp{.elc} и @samp{.el}.  В этом случае
потребуется указать точное имя файла, которое нужно, за исключением того,
что, если включен режим автоматического сжатия, @code{load} все равно будет
использовать @code{jka-compr-load-suffixes} для поиска сжатых версий.
Указав точное имя файла и используя @code{t} вместо @var{nosuffix}, можно
предотвратить попытки использования таких имен файлов, как @file{foo.el.el}.

Если необязательный аргумент @var{must-suffix} - не-@code{nil}, то
@code{load} настаивает на том, чтобы используемое имя файла заканчивалось
либо на @samp{.el} или @samp{.elc} (возможно, с суффиксом сжатия), либо на
расширение разделяемой библиотеки, если оно не содержит явное имя каталога.

Если опция @code{load-prefer-newer} - не-@code{nil}, то при поиске суффиксов
@code{load} выбирает ту версию файла (@samp{.elc}, @samp{.el}, etc.)@:
которая изменялась последней.

Если @var{filename} - относительное имя файла, например @file{foo} или
@file{baz/foo.bar}, @code{load}, ищет файл с помощью переменной
@code{load-path}.  Она добавляет @var{filename} в каждый из каталогов,
перечисленных в @code{load-path}, и загружает первый найденный файл, имя
которого соответствует.  Текущий каталог по умолчанию используется, только
если он указан в @code{load-path}, где @code{nil} обозначает каталог по
умолчанию.  @code{load} пробует все три возможных суффикса в первом каталоге
в @code{load-path}, затем все три суффикса во втором каталоге и так далее.
@xref{Library Search}.

Каким бы ни было имя, под которым в конечном итоге был найден файл, и
каталог, в котором Emacs его нашел, Emacs устанавливает значение переменной
@code{load-file-name} равным имени этого файла.

Если получается предупреждение о том, что @file{foo.elc} старше
@file{foo.el}, это означает, что вам следует подумать о перекомпиляции
@file{foo.el}.  @xref{Byte Compilation}.

При загрузке исходного файла (не скомпилированного) @code{load} выполняет
преобразование набора символов так же, как Emacs при обращении к файлу.
@xref{Coding Systems}.

@c Об этом говорится в главе «Макросы».
@c Не уверен, может ли быть иначе.
@cindex eager macro expansion
При загрузке некомпилированного файла Emacs пытается развернуть все макросы,
содержащиеся в файле (@pxref{Macros}).  Называется это
@dfn{eager macro expansion (нетерпеливое расширение макроса)}.  Это может
значительно ускорить выполнение некомпилированного кода (вместо того, чтобы
откладывать раскрытие до запуска соответствующего кода).  Иногда это
макрорасширение невозможно из-за циклической зависимости.  В простейшем
примере загружаемый файл ссылается на макрос, определенный в другом файле, а
этот файл, в свою очередь, требует загружаемого вами файла.  Это вообще
безвредно.  Emacs выводит предупреждение
(@samp{Eager macro-expansion skipped due to cycle@dots{}}) с подробным
описанием проблемы, но по-прежнему загружает файл, оставляя макрос пока
нераскрытым.  Можно захотеть реструктурировать свой код, чтобы этого не
произошло.  Загрузка скомпилированного файла не вызывает макрорасширения,
потому что это уже должно было произойти во время компиляции.
@xref{Compiling Macros}.

Сообщения вроде @samp{Loading foo...} и @samp{Loading foo...done} появляются
в эхо-области во время загрузки, если @var{nomessage} не не-@code{nil}.

@cindex load errors
Любые необработанные ошибки при загрузке файла прекращают загрузку.  Если
загрузка была произведена ради @code{autoload}, любые определения функций,
сделанные во время загрузки, отменяются.

@kindex file-error
Если @code{load} не может найти файл для загрузки, то обычно он
сигнализирует @code{file-error} (с
@samp{Cannot open load file @var{filename}}).  Но если @var{missing-ok}
установлено в не-@code{nil}, то @code{load} просто возвращает @code{nil}.

Можно использовать переменную @code{load-read-function}, чтобы указать
функцию, которую @code{load} будет использовать вместо @code{read} для
чтения выражений.  Смотреть ниже.

@code{load} возвращает @code{t}, если файл загружается успешно.
@end defun

@deffn Command load-file filename
Эта команда загружает файл @var{filename}.  Если @var{filename} -
относительное имя файла, то предполагается текущий каталог по умолчанию.
Эта команда не использует @code{load-path} и не добавляет суффиксы.  Однако
она ищет сжатые версии (если включен режим автоматического сжатия).
Следует Используйте эту команду, если требуется точно указать имя файла для
загрузки.
@end deffn

@deffn Command load-library library
Эта команда загружает библиотеку с именем @var{library}.  Она эквивалентна
@code{load}, за исключением того, как читает свой аргумент в интерактивном
режиме.  @xref{Lisp Libraries,,,emacs, The GNU Emacs Manual}.
@end deffn

@defvar load-in-progress
Эта переменная - не-@code{nil}, если Emacs находится в процессе загрузки
файла, и @code{nil} в противном случае.
@end defvar

@defvar load-file-name
Когда Emacs загружает файл, значением этой переменной является имя этого
файла, которое Emacs нашел во время поиска, описанного ранее в этом разделе.
@end defvar

@defvar load-read-function
@anchor{Definition of load-read-function}
@c не допускать разрыв страницы при привязке; недостаток Texinfo.
Эта переменная определяет альтернативную функцию чтения выражений, которую
@code{load} и @code{eval-region} будет использовать вместо @code{read}.
Функция должна принимать один аргумент, как и @code{read}.

По умолчанию значение этой переменной @code{read}.  @xref{Input Functions}.

Вместо использования этой переменной проще использовать другую, более новую
функцию: передать функцию в качестве аргумента @var{read-function} в
@code{eval-region}.  @xref{Definition of eval-region,, Eval}.
@end defvar

  Для получения информации о том, как @code{load} используется при сборке
  Emacs, смотреть @ref{Building Emacs}.

@node Load Suffixes
@section Суффиксы Загрузки
Теперь опишем некоторые технические подробности о точных суффиксах, которые
пытается использовать @code{load}.

@defvar load-suffixes
Это список суффиксов, обозначающих (скомпилированные или исходные) файлы
Emacs Lisp.  Он не должен включать пустые строки.  @code{load} использует
эти суффиксы по порядку, когда добавляет суффиксы Lisp к указанному имени
файла.  Стандартное значение - @code{(".elc" ".el")}, что обеспечивает
поведение, описанное в предыдущем разделе.
@end defvar

@defvar load-file-rep-suffixes
Это список суффиксов, обозначающих представления одного и того же файла.
Этот список обычно должен начинаться с пустой строки.  Когда @code{load}
ищет файл, она добавляет суффиксы в этом списке по порядку к имени файла
перед поиском другого файла.

Включение режима автоматического сжатия добавляет суффиксы в
@code{jka-compr-load-suffixes} к этому списку, а отключение режима
автоматического сжатия удаляет их снова.  Стандартное значение
@code{load-file-rep-suffixes}, если режим автоматического сжатия отключен,
тогда @code{("")}.  Учитывая, что стандартное значение
@code{jka-compr-load-suffixes} - @code{(".gz")}, стандартное значение
@code{load-file-rep-suffixes}, если включен режим Auto Compression, -
@code{("" ".gz")}.
@end defvar

@defun get-load-suffixes
Эта функция возвращает список всех суффиксов, которые @code{load} должен
попробовать, по порядку, если его аргумент @var{must-suffix} -
не-@code{nil}.  При этом учитываются оба @code{load-suffixes} и
@code{load-file-rep-suffixes}.  Если @code{load-suffixes},
@code{jka-compr-load-suffixes} и @code{load-file-rep-suffixes} имеют свои
стандартные значения, эта функция возвращает
@code{(".elc" ".elc.gz" ".el" ".el.gz")}, если включен режим автоматического
сжатия, и @code{(".elc" ".el")}, если режим автоматического сжатия отключен.
@end defun

Подводя итог, @code{load} обычно сначала пробует суффиксы в значении
@code{(get-load-suffixes)}, а затем в @code{load-file-rep-suffixes}.  Если
@var{nosuffix} равен не-@code{nil}, он пропускает первую группу, а если
@var{must-suffix} равен не-@code{nil}, он пропускает последнюю группу.

@defopt load-prefer-newer
Если эта опция - не-@code{nil}, то вместо того, чтобы останавливаться на
первом существующем суффиксе, @code{load} проверяет их все и использует
самый новый файл.
@end defopt

@node Library Search
@section Поиск Библиотек
@cindex library search
@cindex find library

  Когда Emacs загружает библиотеку Lisp, он ищет библиотеку в списке
каталогов, заданном переменной @code{load-path}..

@defvar load-path
Значение этой переменной представляет собой список каталогов для поиска
при загрузке файлов с @code{load}.  Каждый элемент представляет собой строку
(которая должна быть каталогом) или @code{nil} (что означает текущий рабочий
каталог).
@end defvar

  Когда Emacs запускается, он устанавливает значение @code{load-path} за
несколько шагов.  Во-первых, он инициализирует @code{load-path}, используя
расположение по умолчанию, установленное при компиляции Emacs.  Обычно это
каталог на подобии

@example
"/usr/local/share/emacs/@var{version}/lisp"
@end example

(В этом и следующих примерах замените @file{/usr/local} на префикс
установки, соответствующий вашему Emacs).  Эти каталоги содержат стандартные
файлы Lisp, которые поставляются с Emacs.  Если Emacs не может их найти, он
не запустится правильно.

Если запускается Emacs из каталога, в котором он был собран, то есть
исполняемого файла, который не был официально установлен, Emacs вместо этого
инициализирует @code{load-path}, используя каталог @file{lisp} в каталоге,
содержащем исходные коды, из которых он был построен.
@c Хотя в builddir/lisp файлов *.el быть не должно, это бессмысленно.
Если Emacs построен в каталоге, отличном от исходного, он также добавляет
каталоги lisp из каталога сборки.  (Во всех случаях элементы представлены
как абсолютные имена файлов.)

@cindex site-lisp directories
Если запускается Emacs с опцией @option{--no-site-lisp}, он добавит еще два
каталога @file{site-lisp} в начало @code{load-path}.  Они предназначены для
локально установленных файлов Lisp и обычно имеют вид:

@example
"/usr/local/share/emacs/@var{version}/site-lisp"
@end example

@noindent
and

@example
"/usr/local/share/emacs/site-lisp"
@end example

@noindent
Первый предназначен для локально установленных файлов конкретной версии
Emacs; второй - для локально установленных файлов, предназначенных для
использования со всеми установленными версиями Emacs.  (Если Emacs запущен
без установки, он также добавляет каталоги @file{site-lisp} из исходных
каталогов и каталогов сборки, если они существуют.  Обычно эти каталоги не
содержат каталогов @file{site-lisp}).

@cindex @env{EMACSLOADPATH} environment variable
Если установлена переменная окружения @env{EMACSLOADPATH}, она изменяет
описанную выше процедуру инициализации.  Emacs инициализирует
@code{load-path} на основе значения переменной окружения.

Синтаксис @env{EMACSLOADPATH} такой же, как и у @code{PATH}; каталоги
разделяются @samp{:} (или @samp{;} в некоторых операционных системах).
@ignore
@c AFAICS, (пока) не работает правильно для указания неабсолютных элементов.
А @samp{.} обозначает текущий каталог по умолчанию.
@end ignore
Вот пример того, как установить переменную @env{EMACSLOADPATH} (из оболочки
в стиле @command{sh}):

@example
export EMACSLOADPATH=/home/foo/.emacs.d/lisp:
@end example

Пустой элемент в значении переменной среды, конечный (как в приведенном выше
примере), ведущий или встроенный, заменяется значением по умолчанию
@code{load-path}, как определено стандартной процедурой инициализации.  Если
таких пустых элементов нет, то @env{EMACSLOADPATH} указывает весь
@code{load-path}.  Потребуется включить либо пустой элемент, либо явный путь
к каталогу, содержащему стандартные файлы Lisp, иначе Emacs не будет
работать.  (Другой способ изменить @code{load-path} - использовать параметр
командной строки @option{-L} при запуске Emacs; смотреть Ниже).

  Для каждого каталога в @code{load-path} Emacs затем проверяет, содержит
ли он файл @file{subdirs.el}, и, если да, загружает его.  Файл
@file{subdirs.el} создается при сборке/установке Emacs и содержит код,
который заставляет Emacs добавлять любые подкаталоги этих каталогов в
@code{load-path}.  Добавляются как непосредственные подкаталоги, так и
подкаталоги на несколько уровней ниже.  Но он исключает подкаталоги, имена
которых не начинаются с буквы или цифры, подкаталоги с именем @file{RCS} или
@file{CVS} и подкаталоги, содержащие файл с именем @file{.nosearch}.

  Затем Emacs добавляет любые дополнительные каталоги загрузки, которые
указываются с помощью параметра командной строки @option{-L}
(@pxref{Action Arguments,,,emacs, The GNU Emacs Manual}).  Также добавляются
каталоги, в которых установлены дополнительные пакеты, если таковые имеются
(@pxref{Packaging Basics}).

  Обычно в файл инициализации (@pxref{Init File}) добавляют код, чтобы
добавить один или несколько каталогов в @code{load-path}. Например:

@example
(push "~/.emacs.d/lisp" load-path)
@end example

  При выгрузке Emacs использует специальное значение @code{load-path}.  Если
используется файл @file{site-load.el} или @file{site-init.el} для настройки
дампа Emacs (@pxref{Building Emacs}), любые изменения в @code{load-path},
сделанные этими файлами, будут потеряны после сброса.

@deffn Command locate-library library &optional nosuffix path interactive-call
Эта команда находит точное имя файла для библиотеки @var{library}.  Ищет
библиотеку так же, как @code{load}, а аргумент @var{nosuffix} имеет то же
значение, что и в @code{load}: не добавляйте суффиксы @samp{.elc} или
@samp{.el} к указанному имени @var{library}.

Если @var{path} - не-@code{nil}, этот список каталогов используется вместо
@code{load-path}..

Когда @code{locate-library} вызывается из программы, возвращает имя файла в
виде строки.  Когда пользователь запускает @code{locate-library} в
интерактивном режиме, аргумент @var{interactive-call} равен @code{t}, и это
указывает @code{locate-library} отображать имя файла в эхо-области.
@end deffn

@cindex shadowed Lisp files
@deffn Command list-load-path-shadows &optional stringp
Эта команда показывает список файлов @dfn{shadowed} Emacs Lisp.  Теневой
файл - это файл, который обычно не загружается, несмотря на то, что он
находится в каталоге @code{load-path}, из-за наличия ранее другого файла с
аналогичным именем в каталоге @code{load-path}.

Например, предположим, что для @code{load-path} установлено значение

@example
  ("/opt/emacs/site-lisp" "/usr/share/emacs/23.3/lisp")
@end example

@noindent
и что оба этих каталога содержат файл с именем @file{foo.el}.  Тогда
@code{(require 'foo)} никогда не загружает файл во второй каталог.  Такая
ситуация может указывать на проблему в способе установки Emacs.

При вызове из Lisp эта функция печатает сообщение со списком затененных
файлов, а не отображает их в буфере.  Если необязательный аргумент
@code{stringp} - не-@code{nil}, она вместо этого возвращает затененные файлы
в виде строки.
@end deffn

@node Loading Non-ASCII
@section Загрузка Не-@acronym{ASCII} Символов
@cindex loading, and non-ASCII characters
@cindex non-ASCII characters in loaded files

  Когда программы Emacs Lisp содержат строковые константы с символами
не-@acronym{ASCII}, они могут быть представлены в Emacs либо как
однобайтовые строки, либо как многобайтовые строки
(@pxref{Text Representations}).  Какое представление используется, зависит
от того, как файл читается в Emacs.  Если читается с декодированием в
многобайтовое представление, текст программы Lisp будет многобайтовым, а ее
строковые константы - многобайтовыми строками.  Если файл, содержащий
символы Latin-1 (например), читается без декодирования, текст программы
будет однобайтовым, а его строковые константы будут однобайтными строками.
@xref{Coding Systems}.

  В большинстве программ Emacs Lisp тот факт, что строки не-@acronym{ASCII}
являются многобайтовыми, не должен быть заметен, поскольку их вставка в
однобайтовые буферы автоматически конвертирует их в однобайтовые.  Однако,
если это действительно имеет значение, можно заставить определенный файл
Lisp интерпретироваться как unibyte, написав @samp{coding: raw-text} в
разделе локальных переменных.  С этим обозначением файл безоговорочно будет
интерпретироваться как однобайтный.  Это может иметь значение при привязке
ключей к символам не-@acronym{ASCII}, записанным как @code{?v@var{literal}}.

@node Autoload
@section Автозагрузка
@cindex autoload

  Средство @dfn{autoload} позволяет вам регистрировать существование функции
или макроса, но откладывать загрузку файла, которая их определяет.  Первый
вызов функции автоматически загружает соответствующую библиотеку, чтобы
установить реальное определение и другой связанный код, а затем запускает
реальное определение, как если бы оно было загружено все время.
Автозагрузку также можно запустить, просмотрев документацию функции или
макроса (@pxref{Documentation Basics}) и завершив имена переменных и функций
(@pxref{Autoload by Prefix} ниже).

@menu
* Autoload by Prefix:: Автозагрузка по префиксу.
* When to Autoload::   Когда использовать автозагрузку.
@end menu

  Есть два способа настроить автоматически загружаемую функцию: вызвать
@code{autoload} и записать комментарий ``magic'' в исходный код перед
настоящим определением.  @code{autoload} - низкоуровневый примитив для
автозагрузки; любая программа Lisp может вызвать @code{autoload} в любое
время.  Специальный комментарий - самый удобный способ сделать функцию
автозагрузки для пакетов, установленных вместе с Emacs.  Эти комментарии
ничего не делают сами по себе, но они служат руководством для команды
@code{update-file-autoloads}, которая создает вызовы @code{autoload} и
организует их выполнение при сборке Emacs.

@defun autoload function filename &optional docstring interactive type
Эта функция определяет функцию (или макрос) с именем @var{function} для
автоматической загрузки из @var{filename}.  Строка @var{filename} указывает
файл для загрузки, чтобы получить реальное определение @var{function}.

Если @var{filename} не содержит ни имени каталога, ни суффикса @code{.el}
или @code{.elc}, эта функция настаивает на добавлении одного из этих
суффиксов, и она не будет загружаться из файла с именем @var{filename} без
добавленного суффикса.  (Переменная @code{load-suffixes} указывает точные
требуемые суффиксы.)

Аргумент @var{docstring} - это строка документации для функции.  Указание
строки документации при вызове @code{autoload} позволяет просматривать
документацию без загрузки реального определения функции.  Обычно это должно
быть идентично строке документации в самом определении функции.  Если это не
так, строка документации определения функции вступает в силу после ее
загрузки.

Если @var{interactive} равен не-@code{nil}, значит, @var{function} можно
вызывать интерактивно.  Это позволяет завершению в @kbd{M-x} работать без
загрузки реального определения @var{function}'s.  Полная интерактивная
спецификация здесь не приводится; в этом нет необходимости, если
пользователь не вызывает @var{function}, и когда это произойдет, пора
загрузить настоящее определение.

Можно автоматически загружать макросы и ключевые карты, а также обычные
функции.  Укажите @var{type} как @code{macro}, если @var{function}
действительно макрос.  Укажите @var{type} как @code{keymap}, если
@var{function} действительно является картой.  Эту информацию необходимо
знать различным частям Emacs без загрузки реального определения.

Автоматически загруженная ключевая карта загружается автоматически во время
поиска ключа, когда привязкой префиксного ключа является символ
@var{function}.  Автозагрузки не происходит для других видов доступа к
ключевой карте.  В частности, этого не происходит, когда программа на Lisp
получает карту ключей из значения переменной и не вызывает
@code{define-key}, даже если имя переменной совпадает с символом
@var{function}.

@cindex function cell in autoload
Если @var{function} уже имеет непустое определение функции, которое не
является объектом автозагрузки, эта функция ничего не делает и возвращает
@code{nil}.  В противном случае создается объект автозагрузки
(@pxref{Autoload Type}) и сохраняется определение функции для
@var{function}.  Объект автозагрузки имеет такую форму:

@example
(autoload @var{filename} @var{docstring} @var{interactive} @var{type})
@end example

Для примера,

@example
@group
(symbol-function 'run-prolog)
     @result{} (autoload "prolog" 169681 t nil)
@end group
@end example

@noindent
В этом случае @code{"prolog"} - это имя файла для загрузки, 169681 относится
к строке документации в файле @file{emacs/etc/DOC}
(@pxref{Documentation Basics}), @code{t} означает, что функция является
интерактивной, а @code{nil} - что это не макрос или ключевая карта.
@end defun

@defun autoloadp object
Эта функция возвращает не-@code{nil}, если @var{object} является объектом
автозагрузки.  Например, чтобы проверить, определен ли @code{run-prolog} как
автоматически загружаемая функция, оцените

@smallexample
(autoloadp (symbol-function 'run-prolog))
@end smallexample
@end defun

@cindex autoload errors
  Автозагружаемый файл обычно содержит другие определения и может требовать
или предоставлять одну или несколько функций.  Если файл загружен не
полностью (из-за ошибки при оценке его содержимого), любые определения
функций или вызовы @code{provide}, которые произошли во время загрузки,
отменяются.  Это необходимо для того, чтобы при следующей попытке вызвать
какую-либо функцию автозагрузки из этого файла мы снова попытаемся загрузить
файл.  Если бы не это, то некоторые функции в файле могли бы быть
определены прерванной загрузкой, но не могли работать должным образом из-за
отсутствия определенных подпрограмм, которые не были загружены успешно,
потому что они появляются позже в файле.

  Если автоматически загружаемый файл не может определить желаемую функцию
или макрос Lisp, то об ошибке сообщается с данными.
@code{"Autoloading failed to define function @var{function-name}"}.

@findex update-file-autoloads
@findex update-directory-autoloads
@cindex magic autoload comment
@cindex autoload cookie
@anchor{autoload cookie}
  Специальный комментарий автозагрузки (часто называемый
@dfn{autoload cookie}) состоит из @samp{;;;###autoload} в отдельной строке
непосредственно перед настоящим определением функции в ее автоматически
загружаемом исходном файле.  Команда @kbd{M-x update-file-autoloads}
записывает соответствующий вызов @code{autoload} в @file{loaddefs.el}.
(Строка, которая служит файлом cookie автозагрузки, и имя файла,
сгенерированного @code{update-file-autoloads}, могут быть изменены по
сравнению с указанными выше значениями по умолчанию, смотреть ниже).  Сборка
Emacs загружает @file{loaddefs.el} и, следовательно, вызывает
@code{autoload}.  @kbd{M-x update-directory-autoloads} еще мощнее; это
обновляет автозагрузку для всех файлов в текущем каталоге.

  Тот же специальный комментарий может копировать любую форму в
@file{loaddefs.el}.  Форма, следующая за специальным комментарием,
копируется дословно, @emph{except}, если это одна из форм, которые средство
автозагрузки обрабатывает специально (например, путем преобразования в
вызов @code{autoload}).  Формы, которые не копируются дословно::

@table @asis
@item Definitions for function or function-like objects:
@code{defun} и @code{defmacro}; также @code{cl-defun} и
@code{cl-defmacro} (@pxref{Argument Lists,,,cl,Common Lisp Extensions}),
и @code{define-overloadable-function} (см. комментарий в
@file{mode-local.el}).

@item Definitions for major or minor modes:
@code{define-minor-mode}, @code{define-globalized-minor-mode},
@code{define-generic-mode}, @code{define-derived-mode},
@code{easy-mmode-define-minor-mode},
@code{easy-mmode-define-global-mode}, @code{define-compilation-mode},
and @code{define-global-minor-mode}.

@item Other definition types:
@code{defcustom}, @code{defgroup}, @code{defclass}
(@pxref{Top,EIEIO,,eieio,EIEIO}), and @code{define-skeleton}
(@pxref{Top,Autotyping,,autotype,Autotyping}).
@end table

  Также можно использовать специальный комментарий для выполнения формы во
время сборки @emph{без}, выполняя ее при загрузке самого файла.  Для
этого напишите форму @emph{на той же строке} как специальный коментарий.
Поскольку он находится в комментарии, он ничего не делает при загрузке
исходного файла; но @kbd{M-x update-file-autoloads} копирует его в
@file{loaddefs.el}, где он выполняется при сборке Emacs.

  В следующем примере показано, как @code{doctor} готовится к автозагрузке
со специальным комментарием.:

@example
;;;###autoload
(defun doctor ()
  "Switch to *doctor* buffer and start giving psychotherapy."
  (interactive)
  (switch-to-buffer "*doctor*")
  (doctor-mode))
@end example

@noindent
Вот что это дает в @file{loaddefs.el}:

@example
(autoload (quote doctor) "doctor" "\
Switch to *doctor* buffer and start giving psychotherapy.

\(fn)" t nil)
@end example

@noindent
@cindex @code{fn} in function's documentation string
Обратная косая черта и новая строка сразу после двойных кавычек - это
соглашение, используемое только в предварительно загруженных
некомпилированных файлах Lisp, таких как @file{loaddefs.el}; они указывают
@code{make-docfile} поместить строку документации в файл @file{etc/DOC}.
@xref{Building Emacs}.  Смотреть также комментарий в
@file{lib-src/make-docfile.c}.  @samp{(fn)} в части использования строки
документации заменяется именем функции, когда различные функции справки
(@pxref{Help Functions}) отображают его.

  Если пишется определение функции с необычным макросом, который не является
одним из известных и признанных методов определения функции, использование
обычного специального комментария автозагрузки скопирует все определение в
@code{loaddefs.el}.  Это нежелательно.  Вместо этого потребуется поместить
желаемый вызов @code{autoload} в @code{loaddefs.el}, написав так:

@example
;;;###autoload (autoload 'foo "myfile")
(mydefunmacro foo
  ...)
@end example

  Можно использовать строку, отличную от значения по умолчанию, в качестве
файла cookie автозагрузки и записать соответствующие вызовы автозагрузки в
файл, имя которого отличается от значения по умолчанию @file{loaddefs.el}.
Emacs предоставляет две переменные для управления этим:

@defvar generate-autoload-cookie
Значение этой переменной должно быть строкой, синтаксис которой является
комментарием Lisp.  @kbd{M-x update-file-autoloads} копирует форму Lisp,
которая следует за файлом cookie, в файл автозагрузки, который он
генерирует.  Значение по умолчанию для этой переменной -
@code{";;;###autoload"}.
@end defvar

@defvar generated-autoload-file
Значение этой переменной именует файл Emacs Lisp, куда должны идти вызовы
автозагрузки.  Значение по умолчанию - @file{loaddefs.el}, но можно
переопределить это, например, в разделе локальных переменных файла
@file{.el} (@pxref{File Local Variables}).  Предполагается, что файл
автозагрузки содержит трейлер, начинающийся с символа перевода страницы.
@end defvar

  Следующая функция может использоваться для явной загрузки библиотеки,
указанной объектом автозагрузки.:

@defun autoload-do-load autoload &optional name macro-only
Эта функция выполняет загрузку, указанную @var{autoload}, которая должна
быть объектом автозагрузки.  Необязательный аргумент @var{name}, если
не-@code{nil}, должен быть символом, значение функции которого -
@var{autoload}; в этом случае возвращаемое значение этой функции - это новое
значение ячейки функции символа.  Если значение необязательного аргумента
@var{macro-only} - @code{macro}, эта функция избегает загрузки функции,
только макроса.
@end defun

@node Autoload by Prefix
@subsection Автозагрузка по Префиксу
@cindex autoload by prefix

@vindex definition-prefixes
@findex register-definition-prefixes
@vindex autoload-compute-prefixes
Во время выполнения команд @code{describe-variable} и
@code{describe-function} Emacs попытается загрузить файлы, которые могут
содержать определения, соответствующие завершаемому префиксу.  Переменная
@code{definition-prefixes} содержит хеш-таблицу, которая отображает префикс
в соответствующий список файлов для загрузки.  Записи в это отображение
добавляются вызовами @code{register-definition-prefixes}, которые
генерируются @code{update-file-autoloads} (@pxref{Autoload}).  Файлы,
которые не содержат каких-либо определений, которые стоит загружать
(например, тестовые файлы), должны установить для
@code{autoload-compute-prefixes} значение @code{nil} как локальную
переменную файла.

@node When to Autoload
@subsection Когда Использовать Автозагрузку
@cindex autoload, when to use

Не добавляйте комментарий автозагрузки, если это действительно необходимо.
Код автозагрузки означает, что он всегда виден во всем мире.  После
автозагрузки элемента не существует совместимого способа вернуться к нему
без автозагрузки (после того, как люди привыкнут использовать его без явной
загрузки).

@itemize
@item
Наиболее распространенные элементы для автозагрузки - это интерактивные
точки входа в библиотеку.  Например, если @file{python.el} - это библиотека,
определяющая основной режим для редактирования кода Python, автоматически
загрузите определение функции @code{python-mode}, чтобы люди могли просто
использовать @kbd{M-x python-mode} для загрузки библиотеки.

@item
Переменные обычно не нужно загружать автоматически.  Исключение составляют
случаи, когда переменная сама по себе обычно полезна без загрузки всей
определяющей библиотеки.  (Примером может быть что-то вроде
@code{find-exec-terminator}.)

@item
Не загружайте пользовательский параметр автоматически только для того,
чтобы пользователь мог его установить.

@item
Никогда не добавляйте @emph{комментарий} автозагрузки, чтобы отключить
предупреждение компилятора в другом файле.  В файле, который генерирует
предупреждение, используйте @code{(defvar foo)}, чтобы отключить
предупреждение о неопределенной переменной, и @code{declare-function}
(@pxref{Declaring Functions}), чтобы отключить предупреждение о
неопределенной функции; или потребовать соответствующую библиотеку; или
используйте явное @emph{заявление} автозагрузки.
@end itemize

@node Repeated Loading
@section Повторная Загрузка
@cindex repeated loading

  Можно загрузить данный файл более одного раза за сеанс Emacs.  Например,
после того, как переписано и переустановлено определение функции,
отредактированое в буфере, можно захотеть вернуться к исходной версии; можно
сделать это, перезагрузив файл, из которого он был получен.

  При загрузке или перезагрузке файлов имейте в виду, что функции
@code{load} и @code{load-library} автоматически загружают скомпилированный
в байтах файл, а не некомпилированный файл с аналогичным именем.  Если
переписать файл, который собираетесь сохранить и переустановить, необходимо
выполнить байтовую компиляцию новой версии; в противном случае Emacs
загрузит старый, байт скомпилированный файл вместо вашего нового, не
скомпилированного файла!  Если это произойдет, сообщение, отображаемое при
загрузке файла, включает
@samp{(составлен; обратите внимание, источник новее)}, чтобы напомнить о
необходимости его перекомпиляции.

  При написании форм в файле библиотеки Lisp помните, что файл может
загружаться более одного раза.  Например, подумайте, следует ли
переинициализировать каждую переменную при перезагрузке библиотеки;
@code{defvar} не изменяет значение, если переменная уже инициализирована.
(@xref{Defining Variables}.)

  Самый простой способ добавить элемент в список выглядит так:

@example
(push '(leif-mode " Leif") minor-mode-alist)
@end example

@noindent
Но это добавит несколько элементов, если библиотека будет перезагружена.
Чтобы избежать проблемы, используйте @code{add-to-list}
(@pxref{List Variables}):

@example
(add-to-list 'minor-mode-alist '(leif-mode " Leif"))
@end example

  Иногда может понадобиться явно проверить, загружена ли уже библиотека.
Если библиотека использует @code{provide} для предоставления именованной
функции, можно использовать @code{featurep} ранее в файле, чтобы проверить,
выполнялся ли вызов @code{provide} раньше (@pxref{Named Features}).  В
качестве альтернативы можно использовать что-то вроде этого:

@example
(defvar foo-was-loaded nil)

(unless foo-was-loaded
  @var{execute-first-time-only}
  (setq foo-was-loaded t))
@end example

@noindent

@node Named Features
@section Особенности
@cindex features
@cindex requiring features
@cindex providing features

  @code{provide} и @code{require} - это альтернативы @code{autoload} для
автоматической загрузки файлов.  Они работают в рамках названного
@dfn{features}.  Автозагрузка запускается при вызове определенной функции,
но функция загружается в первый раз, когда другая программа запрашивает ее
по имени.

  Имя функции - это символ, обозначающий набор функций, переменных и т. д.
Файл, определяющий их, должен содержать объект.  Другая программа, которая
их использует, может гарантировать, что они определены функцией
@dfn{requiring}.  Это загружает файл определений, если он еще не был
загружен.

@cindex load error with require
  Чтобы потребовать наличия функции, вызовите @code{require} с именем
функции в качестве аргумента.  @code{require} просматривает глобальную переменную @code{features}, чтобы узнать, была ли уже предоставлена желаемая
функция.  Если нет, загружает функцию из соответствующего файла.  Этот файл
должен вызывать @code{provide} на верхнем уровне, чтобы добавить функцию в
@code{features}; если этого не происходит, @code{require} сигнализирует об
ошибке.

  Например, в @file{idlwave.el} определение @code{idlwave-complete-filename}
включает следующий код:

@example
(defun idlwave-complete-filename ()
  "Use the comint stuff to complete a file name."
   (require 'comint)
   (let* ((comint-file-name-chars "~/A-Za-z0-9+@@:_.$#%=@{@}\\-")
          (comint-completion-addsuffix nil)
          ...)
       (comint-dynamic-complete-filename)))
@end example

@noindent
Выражение @code{(require 'comint)} загружает файл @file{comint.el}, если он
еще не загружен, обеспечивая определение
@code{comint-dynamic-complete-filename}.  Компоненты обычно называются в
честь файлов, которые их предоставляют, поэтому имя файла @code{require} не
требуется.  (Обратите внимание, что важно, чтобы оператор @code{require}
находился вне тела @code{let}.  Загрузка библиотеки, когда ее переменные
привязаны к let, может иметь непредвиденные последствия, а именно,
переменные становятся несвязанными после выхода let.)

@file{comint.el} файл содержит следующее выражение верхнего уровня:

@example
(provide 'comint)
@end example

@noindent
Это добавляет @code{comint} в глобальный список @code{features}, так что
@code{(require 'comint)} отныне будет знать, что ничего делать не нужно.

@cindex byte-compiling @code{require}
  Когда @code{require} используется на верхнем уровне файла, это вступает в
силу при байтовой компиляции файла (@pxref{Byte Compilation}), а также при
его загрузке.  Это на случай, если требуемый пакет содержит макросы, о
которых должен знать байтовый компилятор.  Это также позволяет избежать
байтовых предупреждений компилятора для функций и переменных, определенных в
файле, загруженном с помощью @code{require}.

  Хотя вызовы верхнего уровня к @code{require} оцениваются во время байт
компиляции, вызовы @code{provide} - нет.  Следовательно, можно убедиться,
что файл определений загружен до его побайтной компиляции, включив
@code{provide}, за которым следует @code{require} для той же функции, как в
следующем примере.

@example
@group
(provide 'my-feature)  ; @r{Игнорируется байтовым компилятором,}
                       ;   @r{оценивается @code{load}.}
(require 'my-feature)  ; @r{Оценивается байтовым компилятором.}
@end group
@end example

@noindent
Компилятор игнорирует @code{provide}, а затем обрабатывает @code{require},
загружая соответствующий файл.  При загрузке файла выполняется вызов
@code{provide}, поэтому последующий вызов @code{require} ничего не делает
при загрузке файла.

@defun provide feature &optional subfeatures
Эта функция объявляет, что @var{feature} теперь загружен или загружается в
текущий сеанс Emacs.  Это означает, что средства, связанные с @var{feature},
доступны или будут доступны для других программ Lisp.

Прямым следствием вызова @code{provide} является добавление @var{feature} в
начало @code{features}, если его еще нет в этом списке, и вызов любого
ожидающего его кода @code{eval-after-load} (@pxref{Hooks for Loading}).
Аргумент @var{feature} должен быть символом.  @code{provide} возвращает
@var{feature}.

Если предоставлено, @var{subfeatures} должен быть списком символов,
указывающих набор определенных подфункций, предоставляемых этой версией
@var{feature}.  Можно проверить наличие подкомпонента с помощью
@code{featurep}.  Идея подфункций заключается в том, что используют их,
когда пакет (который представляет собой один @var{feature}) достаточно
сложен, чтобы было полезно давать имена различным частям или функциям
пакета, которые могут или не могут быть загружены, или могут или не могут
присутствовать в данной версии.  @xref{Network Feature Testing}, например:

@example
features
     @result{} (bar bish)

(provide 'foo)
     @result{} foo
features
     @result{} (foo bar bish)
@end example

Когда файл загружается для выполнения автозагрузки и останавливается из-за
ошибки в оценке его содержимого, любые определения функций или вызовы
@code{provide}, которые произошли во время загрузки, отменяются.
@xref{Autoload}.
@end defun

@defun require feature &optional filename noerror
Эта функция проверяет, присутствует ли @var{feature} в текущем сеансе Emacs
(используя @code{(featurep @var{feature})}; смотреть ниже).  Аргумент
@var{feature} должен быть символом.

Если функция отсутствует, то @code{require} загружает @var{filename} с
@code{load}.  Если @var{filename} не указан, то имя символа @var{feature}
используется как базовое имя файла для загрузки.  Однако в этом случае
@code{require} настаивает на поиске @var{feature} с добавленным суффиксом
@samp{.el} или @samp{.elc} (возможно, расширенным с суффиксом сжатия); файл
с именем @var{feature} использоваться не будет.  (Переменная
@code{load-suffixes} указывает точные требуемые суффиксы Lisp.)

Если @var{noerror} равен не-@code{nil}, это подавляет ошибки при фактическойзагрузке файла.  В этом случае @code{require} возвращает @code{nil}, если
загрузка файла не удалась.  Обычно @code{require} возвращает @var{feature}.

Если загрузка файла прошла успешно, но не предоставляется @var{feature},
@code{require} сигнализирует об ошибке об отсутствующей функции.
@end defun

@defun featurep feature &optional subfeature
Эта функция возвращает @code{t}, если @var{feature} был предоставлен в
текущем сеансе Emacs (т. е. Если @var{feature} является членом
@code{features}.).  Если @var{subfeature} равен не-@code{nil}, тогда функция
возвращает @code{t} только в том случае, если эта подфункция также указана
(т. е. если @var{subfeature} имеет значение не-@code{nil}).  Член свойства
@code{subfeature} символа @var{feature}.)
@end defun

@defvar features
Значение этой переменной представляет собой список символов, которые
являются функциями, загруженными в текущем сеансе Emacs.  Каждый символ был
помещен в этот список с вызовом @code{provide}.  Порядок элементов в списке
@code{features} не имеет значения.
@end defvar

@node Where Defined
@section В каком Файле Определен Определенный Символ
@cindex symbol, where defined
@cindex where was a symbol defined

@defun symbol-file symbol &optional type
Эта функция возвращает имя файла, в котором определен @var{symbol}.  Если
@var{type} равно @code{nil}, то приемлемо любое определение.  Если
@var{type} это @code{defun}, @code{defvar}, или @code{defface}, это
указывает только определение функции, определение переменной или определение
лица.

Значение обычно является абсолютным именем файла.  Это также может быть
@code{nil}, если определение не связано ни с каким файлом.  Если
@var{symbol} определяет автоматически загружаемую функцию, значением может
быть относительное имя файла без расширения.
@end defun

  В основе @code{symbol-file} лежат данные в переменной @code{load-history}.

@defvar load-history
Значение этой переменной представляет собой список, который связывает имена
загруженных файлов библиотеки с именами функций и переменных, которые они
определили, а также с функциями, которые они предоставляют или требуют.

Каждый элемент в этом списке описывает одну загруженную библиотеку (включая
библиотеки, которые предварительно загружаются при запуске).  Это список,
@sc{car} которого - абсолютное имя файла библиотеки (строка).  Остальные
элементы списка имеют следующие формы:

@table @code
@item @var{var}
Символ @var{var} был определен как переменная.
@item (defun . @var{fun})
Определена функция @var{fun}.
@item (t . @var{fun})
Функция @var{fun} ранее была автозагружаемой до того, как эта библиотека
переопределила ее как функцию.  Следующим элементом всегда является
@code{(defun . @var{fun})}, который представляет определение @var{fun} как
функции.
@item (autoload . @var{fun})
Функция @var{fun} была определена как автозагружаемая.
@item (defface . @var{face})
Было определено лицо @var{face}.
@item (require . @var{feature})
Требуется функция @var{feature}.
@item (provide . @var{feature})
Была предоставлена функция @var{feature}.
@item (cl-defmethod @var{method} @var{specializers})
Именованный @var{method} был определен с помощью @code{cl-defmethod} со
специализацией @var{specializers}.
@item (define-type . @var{type})
Был определен тип @var{type}.
@end table

Значение @code{load-history} может иметь один элемент, у которого @sc{car}
есть @code{nil}.  Этот элемент описывает определения, сделанные с помощью
@code{eval-buffer} для буфера, который не обращается к файлу.
@end defvar

  Команда @code{eval-region} обновляет @code{load-history}, но делает это
путем добавления символов, определенных для элемента для посещаемого файла,
вместо замены этого элемента.  @xref{Eval}.

@node Unloading
@section Разгрузка
@cindex unloading packages

@c Emacs 19 feature
  Можно отказаться от функций и переменных, загружаемых библиотекой, чтобы
освободить память для других объектов Lisp.  Для этого воспользуйтесь
функцией @code{unload-feature}:

@deffn Command unload-feature feature &optional force
Эта команда выгружает библиотеку с функцией @var{feature}.  Это отменяет
определение всех функций, макросов и переменных, определенных в этой
библиотеке с помощью @code{defun}, @code{defalias}, @code{defsubst},
@code{defmacro}, @code{defconst}, @code{defvar}, и @code{defcustom}.  Затем
восстанавливает все автозагрузки, ранее связанные с этими символами.
(Загрузка сохраняет их в свойстве @code{autoload} символа.)

Перед восстановлением предыдущих определений @code{unload-feature} запускает
@code{remove-hook} для удаления функций в библиотеке из определенных хуков.
Эти хуки включают переменные, имена которых заканчиваются на @samp{-hook}
(или устаревший суффикс @samp{-hooks}), а также переменные, перечисленные в
@code{unload-feature-special-hooks}, а также на @code{auto-mode-alist}.  Это
сделано для предотвращения прекращения работы Emacs, потому что важные
перехватчики относятся к функциям, которые больше не определены.

Стандартные действия по выгрузке также отменяют профилирование ELP функций в
этой библиотеке, отменяют любые функции, предоставляемые библиотекой, и
отменяют таймеры, хранящиеся в переменных, определенных библиотекой.

@vindex @var{feature}-unload-function
Если этих мер недостаточно для предотвращения сбоя, библиотека может
определить явный разгрузчик с именем @code{@var{feature}-unload-function}.
Если этот символ определен как функция, @code{unload-feature} вызывает его
без аргументов, прежде чем делать что-либо еще.  Это может делать все
необходимое, чтобы выгрузить библиотеку.  Если он возвращает @code{nil},
@code{unload-feature} выполняет обычные действия по выгрузке.  В противном
случае он считает работу выполненной.

Обычно @code{unload-feature} отказывается выгружать библиотеку, от которой
зависят другие загруженные библиотеки.  (Библиотека @var{a} зависит от
библиотеки @var{b}, если @var{a} содержит @code{require} для @var{b}.)
Если необязательный аргумент @var{force} - не-@code{nil}, зависимости
игнорируются, и можно выгрузить любую библиотеку.
@end deffn

  Функция @code{unload-feature} написана на Lisp; его действия основаны на
переменной @code{load-history}.

@defvar unload-feature-special-hooks
Эта переменная содержит список перехватчиков, которые нужно просканировать
перед выгрузкой библиотеки, чтобы удалить функции, определенные в
библиотеке.
@end defvar

@node Hooks for Loading
@section Ловушки для Загрузки
@cindex loading hooks
@cindex hooks for loading

Можно запросить выполнение кода каждый раз, когда Emacs загружает
библиотеку, используя переменную @code{after-load-functions}:

@defvar after-load-functions
Эта ненормальная ловушка запускается после загрузки файла.  Каждая функция в
ловушке вызывается с одним аргументом - абсолютным именем файла, который
только что был загружен.
@end defvar

Если требуется, чтобы код выполнялся при загрузке библиотеки в
@emph{частности}, используйте макрос @code{with-eval-after-load}:

@defmac with-eval-after-load library body@dots{}
Этот макрос выполняет оценку @var{body} в конце загрузки файла
@var{library}, каждый раз, когда загружается @var{library}.  Если
@var{library} уже загружен, он сразу оценивает @var{body}.

Не требуется указывать каталог или расширение в имени файла @var{library}.
Обычно просто указывается имя файла:

@example
(with-eval-after-load "edebug" (def-edebug-spec c-point t))
@end example

Чтобы ограничить, какие файлы могут запускать оценку, включите каталог или
расширение или оба в @var{library}.  Будет соответствовать только файл,
абсолютное истинное имя которого (т.е. имя со всеми исключенными
символическими ссылками) соответствует всем заданным компонентам имени.  В
следующем примере @file{my_inst.elc} или @file{my_inst.elc.gz} в некотором
каталоге @code{..../foo/bar} вызовет оценку, но не @file{my_inst.el}.:

@example
(with-eval-after-load "foo/bar/my_inst.elc" @dots{})
@end example

@var{library} также может быть функцией (то есть символом), и в этом случае
@var{body} вычисляется в конце любого файла, в котором вызывается
@code{(provide @var{library})}.

Ошибка в @var{body} не отменяет загрузку, но предотвращает выполнение
остальной части @var{body}.
@end defmac

Обычно хорошо разработанные программы на Lisp не должны использовать
@code{with-eval-after-load}.  Если нужно проверить и установить переменные,
определенные в другой библиотеке (предназначенные для внешнего
использования), можно сделать это немедленно - нет необходимости ждать,
пока библиотека загрузится.  Если нужно вызвать функции, определенные этой
библиотекой, потребуется загрузить библиотеку, желательно с @code{require}
(@pxref{Named Features}).

@node Dynamic Modules
@section Динамические Модули Emacs
@cindex dynamic modules

  @dfn{Динамические Модули Emacs} - это разделяемая библиотека, которая
предоставляет дополнительные функции для использования в программах Emacs
Lisp, как и пакет, написанный на Emacs Lisp.

  Функции, загружающие пакеты Emacs Lisp, также могут загружать динамические
модули.  Они распознают динамические модули, глядя на их расширение имени
файла, a.k.a.@: ``suffix''.  Этот суффикс зависит от платформы.

@defvar module-file-suffix
Эта переменная содержит зависящее от системы значение расширения имени файла
для файлов модуля.  Его значение - @file{.so} на хостах POSIX и @file{.dll}
на MS-Windows.
@end defvar

@findex emacs_module_init
@vindex plugin_is_GPL_compatible
Каждый динамический модуль должен экспортировать вызываемую Cи функцию с
именем @code{emacs_module_init}, которую Emacs будет вызывать как часть
вызова @code{load} или @code{require}, загружающего модуль.  Также должен
экспортировать символ с именем @code{plugin_is_GPL_compatible}, чтобы
указать, что его код выпущен под GPL или совместимой лицензией; Emacs
сообщит об ошибке, если ваша программа попытается загрузить модули, которые
не экспортируют такой символ.

Если модулю необходимо вызывать функции Emacs, он должен делать это через
@acronym{API} (интерфейс прикладного программирования), определенный и
задокументированный в заголовочном файле @file{emacs-module.h}, который
является частью дистрибутива Emacs.  @xref{Writing Dynamic Modules}, чтобы
узнать подробнее об использовании этого API при написании собственных
модулей.

@cindex user-ptr object
@cindex user pointer object
Модули могут создавать объекты @code{user-ptr} Lisp, которые встраивают
указатели на структуры Cи, определенные модулем.  Это полезно для хранения
сложных структур данных, созданных модулем, для передачи обратно функциям
модуля.  Объекты User-ptr также могут иметь связанные @dfn{finalizers} -
функции, которые будут запускаться, когда объект GC'ed; это полезно для
освобождения любых ресурсов, выделенных для базовой структуры данных, таких
как память, дескрипторы открытых файлов и т. д.  @xref{Module Values}.

@defun user-ptrp object
Эта функция возвращает @code{t}, если ее аргумент является объектом
@code{user-ptr}.
@end defun

@defun module-load file
Emacs вызывает этот низкоуровневый примитив для загрузки модуля из
указанного @var{file} и выполнения необходимой инициализации модуля.  Это
примитив, который гарантирует, что модуль экспортирует символ
@code{plugin_is_GPL_compatible}, вызывает функцию модуля
@code{emacs_module_init} и сигнализирует об ошибке, если эта функция
возвращает индикацию ошибки или если во время инициализации используется
набранный @kbd{C-g}.  Если инициализация прошла успешно, @code{module-load}
возвращает @code{t}.  Обратите внимание, что @var{file} уже должен иметь
правильное расширение имени файла, поскольку эта функция не пытается искать
файлы с известными расширениями, в отличие от @code{load}.
@end defun

Загружаемые модули в Emacs включаются с помощью параметра
@kbd{--with-modules} во время настройки.
