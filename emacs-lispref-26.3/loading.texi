@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2019 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Loading
@chapter Загрузка
@cindex loading
@cindex library
@cindex Lisp library

  Загрузка файла с кодом Lisp означает перенос его содержимого в среду Lisp
в виде объектов Lisp.  Emacs находит и открывает файл, читает текст,
оценивает каждую форму и затем закрывает файл.  Такой файл также называется
@dfn{Библиотекой Lisp}.

  Функции загрузки оценивают все выражения в файле так же, как функция
@code{eval-buffer} оценивает все выражения в буфере.  Разница в том, что
функции загрузки читают и оценивают текст файла, находящийся на диске, а не
текст в буфере Emacs.

@cindex top-level form
  Загруженный файл должен содержать выражения Lisp либо в виде исходного
кода, либо в виде байт скомпилированного кода.  Каждая форма в файле
называется @dfn{top-level form (форма верхнего уровня)}.  Для форм в
загружаемом файле нет специального формата; любая форма в файле также может
быть введена непосредственно в буфер и обработана там.  (На практике, так
тестируется большая часть кода).  Чаще всего формы представляют собой
определения функций и определения переменных.

  Emacs может также загружать скомпилированные динамические модули:
разделяемые библиотеки, которые предоставляют дополнительные функции для
использования в программах Emacs Lisp, так же как и пакет, написанный на
Emacs Lisp.  Когда динамический модуль загружен, Emacs вызывает функцию
инициализации со специальным именем, которую модуль должен реализовать, и
которая предоставляет дополнительные функции и переменные для программ
Emacs Lisp.

Для загрузки по запросу внешних библиотек, которые, как известно заранее,
требуются некоторыми примитивами Emacs, @pxref{Dynamic Libraries}.

@menu
* How Programs Do Loading:: @code{load} и другие.
* Load Suffixes::           Подробная информация о суффиксах, которые
                            пытается использовать @code{load}.
* Library Search::          Поиск библиотеки для загрузки.
* Loading Non-ASCII::       Не-@acronym{ASCII} в файлах Emacs Lisp.
* Autoload::                Настройка функции на автозагрузку.
* Repeated Loading::        Доп меры предосторожности при загрузке файла.
* Named Features::          Загрузка библиотеки, если она еще не загружена.
* Where Defined::           Поиск файла, определяющего определенный символ.
* Unloading::               Как выгрузить загруженную библиотеку.
* Hooks for Loading::       Предоставление кода для запуска при загрузке
                            определенных библиотек.
* Dynamic Modules::         Модули предоставляют дополнительные примитивы
                            Lisp.
@end menu

@node How Programs Do Loading
@section Как Загружаются Программы

  Emacs Lisp имеет несколько интерфейсов для загрузки.  Например,
@code{autoload} создает объект-заполнитель для функции, определенной в
файле; попытка вызвать функцию автозагрузки загружает файл, чтобы получить
реальное определение функции (@pxref{Autoload}).  @code{require} загружает
файл, если она еще не загружена (@pxref{Named Features}).  В конечном итоге
все эти средства вызывают функцию @code{load} для выполнения своей работы.

@defun load filename &optional missing-ok nomessage nosuffix must-suffix
Эта функция находит и открывает файл с кодом Lisp, оценивает все формы в
нем и закрывает файл.

Чтобы найти файл, @code{load} сначала ищет файл с именем
@file{@var{filename}.elc}, то есть файл с именем @var{filename} с
добавленным расширением @samp{.elc}.  Если такой файл существует, он
загружается.  Если файла с таким именем нет, @code{load} ищет файл с именем
@file{@var{filename}.el}.  Если этот файл существует, он загружается.  Если
Emacs был скомпилирован с поддержкой динамических модулей
(@pxref{Dynamic Modules}), @code{load} затем ищет файл с именем
@file{@var{filename}.@var{ext}}, где @var{ext} - это системно-зависимое
расширение имени файла разделяемых библиотек.  Наконец, если ни одно из этих
имен не найдено, @code{load} ищет файл с именем @var{filename} без
добавочных файлов и загружает его, если он существует.  (Функция @code{load}
не умеет смотреть на @var{filename}.  В неправильном случае имени файла
@file{foo.el.el} оценка @code{(load "foo.el")} действительно найдет его).

Если режим Auto Compression включен, как по умолчанию, то, если @code{load}
не может найти файл, она ищет сжатую версию файла, прежде чем пытаться
использовать другие имена файлов.  Она распаковывает и загружает его, если
он существует.  Она ищет сжатые версии, добавляя каждый из суффиксов в
@code{jka-compr-load-suffixes} к имени файла.  Значение этой переменной
должно быть списком строк.  Стандартное значение - @code{(".gz")}.

Если необязательный аргумент @var{nosuffix} - не-@code{nil}, то @code{load}
не пытается использовать суффиксы @samp{.elc} и @samp{.el}.  В этом случае
потребуется указать точное имя файла, которое нужно, за исключением того,
что, если включен режим автоматического сжатия, @code{load} все равно будет
использовать @code{jka-compr-load-suffixes} для поиска сжатых версий.
Указав точное имя файла и используя @code{t} вместо @var{nosuffix}, можно
предотвратить попытки использования таких имен файлов, как @file{foo.el.el}.

Если необязательный аргумент @var{must-suffix} - не-@code{nil}, то
@code{load} настаивает на том, чтобы используемое имя файла заканчивалось
либо на @samp{.el} или @samp{.elc} (возможно, с суффиксом сжатия), либо на
расширение разделяемой библиотеки, если оно не содержит явное имя каталога.

Если опция @code{load-prefer-newer} - не-@code{nil}, то при поиске суффиксов
@code{load} выбирает ту версию файла (@samp{.elc}, @samp{.el}, etc.)@:
которая изменялась последней.

Если @var{filename} - относительное имя файла, например @file{foo} или
@file{baz/foo.bar}, @code{load}, ищет файл с помощью переменной
@code{load-path}.  Она добавляет @var{filename} в каждый из каталогов,
перечисленных в @code{load-path}, и загружает первый найденный файл, имя
которого соответствует.  Текущий каталог по умолчанию используется, только
если он указан в @code{load-path}, где @code{nil} обозначает каталог по
умолчанию.  @code{load} пробует все три возможных суффикса в первом каталоге
в @code{load-path}, затем все три суффикса во втором каталоге и так далее.
@xref{Library Search}.

Каким бы ни было имя, под которым в конечном итоге был найден файл, и
каталог, в котором Emacs его нашел, Emacs устанавливает значение переменной
@code{load-file-name} равным имени этого файла.

Если получается предупреждение о том, что @file{foo.elc} старше
@file{foo.el}, это означает, что вам следует подумать о перекомпиляции
@file{foo.el}.  @xref{Byte Compilation}.

При загрузке исходного файла (не скомпилированного) @code{load} выполняет
преобразование набора символов так же, как Emacs при обращении к файлу.
@xref{Coding Systems}.

@c Об этом говорится в главе «Макросы».
@c Не уверен, может ли быть иначе.
@cindex eager macro expansion
При загрузке некомпилированного файла Emacs пытается развернуть все макросы,
содержащиеся в файле (@pxref{Macros}).  Называется это
@dfn{eager macro expansion (нетерпеливое расширение макроса)}.  Это может
значительно ускорить выполнение некомпилированного кода (вместо того, чтобы
откладывать раскрытие до запуска соответствующего кода).  Иногда это
макрорасширение невозможно из-за циклической зависимости.  В простейшем
примере загружаемый файл ссылается на макрос, определенный в другом файле, а
этот файл, в свою очередь, требует загружаемого вами файла.  Это вообще
безвредно.  Emacs выводит предупреждение
(@samp{Eager macro-expansion skipped due to cycle@dots{}}) с подробным
описанием проблемы, но по-прежнему загружает файл, оставляя макрос пока
нераскрытым.  Можно захотеть реструктурировать свой код, чтобы этого не
произошло.  Загрузка скомпилированного файла не вызывает макрорасширения,
потому что это уже должно было произойти во время компиляции.
@xref{Compiling Macros}.

Сообщения вроде @samp{Loading foo...} и @samp{Loading foo...done} появляются
в эхо-области во время загрузки, если @var{nomessage} не не-@code{nil}.

@cindex load errors
Любые необработанные ошибки при загрузке файла прекращают загрузку.  Если
загрузка была произведена ради @code{autoload}, любые определения функций,
сделанные во время загрузки, отменяются.

@kindex file-error
Если @code{load} не может найти файл для загрузки, то обычно он
сигнализирует @code{file-error} (с
@samp{Cannot open load file @var{filename}}).  Но если @var{missing-ok}
установлено в не-@code{nil}, то @code{load} просто возвращает @code{nil}.

Можно использовать переменную @code{load-read-function}, чтобы указать
функцию, которую @code{load} будет использовать вместо @code{read} для
чтения выражений.  Смотреть ниже.

@code{load} возвращает @code{t}, если файл загружается успешно.
@end defun

@deffn Command load-file filename
Эта команда загружает файл @var{filename}.  Если @var{filename} -
относительное имя файла, то предполагается текущий каталог по умолчанию.
Эта команда не использует @code{load-path} и не добавляет суффиксы.  Однако
она ищет сжатые версии (если включен режим автоматического сжатия).
Следует Используйте эту команду, если требуется точно указать имя файла для
загрузки.
@end deffn

@deffn Command load-library library
Эта команда загружает библиотеку с именем @var{library}.  Она эквивалентна
@code{load}, за исключением того, как читает свой аргумент в интерактивном
режиме.  @xref{Lisp Libraries,,,emacs, The GNU Emacs Manual}.
@end deffn

@defvar load-in-progress
Эта переменная - не-@code{nil}, если Emacs находится в процессе загрузки
файла, и @code{nil} в противном случае.
@end defvar

@defvar load-file-name
Когда Emacs загружает файл, значением этой переменной является имя этого
файла, которое Emacs нашел во время поиска, описанного ранее в этом разделе.
@end defvar

@defvar load-read-function
@anchor{Definition of load-read-function}
@c не допускать разрыв страницы при привязке; недостаток Texinfo.
Эта переменная определяет альтернативную функцию чтения выражений, которую
@code{load} и @code{eval-region} будет использовать вместо @code{read}.
Функция должна принимать один аргумент, как и @code{read}.

По умолчанию значение этой переменной @code{read}.  @xref{Input Functions}.

Вместо использования этой переменной проще использовать другую, более новую
функцию: передать функцию в качестве аргумента @var{read-function} в
@code{eval-region}.  @xref{Definition of eval-region,, Eval}.
@end defvar

  Для получения информации о том, как @code{load} используется при сборке
  Emacs, смотреть @ref{Building Emacs}.

@node Load Suffixes
@section Суффиксы Загрузки
Теперь опишем некоторые технические подробности о точных суффиксах, которые
пытается использовать @code{load}.

@defvar load-suffixes
Это список суффиксов, обозначающих (скомпилированные или исходные) файлы
Emacs Lisp.  Он не должен включать пустые строки.  @code{load} использует
эти суффиксы по порядку, когда добавляет суффиксы Lisp к указанному имени
файла.  Стандартное значение - @code{(".elc" ".el")}, что обеспечивает
поведение, описанное в предыдущем разделе.
@end defvar

@defvar load-file-rep-suffixes
Это список суффиксов, обозначающих представления одного и того же файла.
Этот список обычно должен начинаться с пустой строки.  Когда @code{load}
ищет файл, она добавляет суффиксы в этом списке по порядку к имени файла
перед поиском другого файла.

Включение режима автоматического сжатия добавляет суффиксы в
@code{jka-compr-load-suffixes} к этому списку, а отключение режима
автоматического сжатия удаляет их снова.  Стандартное значение
@code{load-file-rep-suffixes}, если режим автоматического сжатия отключен,
тогда @code{("")}.  Учитывая, что стандартное значение
@code{jka-compr-load-suffixes} - @code{(".gz")}, стандартное значение
@code{load-file-rep-suffixes}, если включен режим Auto Compression, -
@code{("" ".gz")}.
@end defvar

@defun get-load-suffixes
Эта функция возвращает список всех суффиксов, которые @code{load} должен
попробовать, по порядку, если его аргумент @var{must-suffix} -
не-@code{nil}.  При этом учитываются оба @code{load-suffixes} и
@code{load-file-rep-suffixes}.  Если @code{load-suffixes},
@code{jka-compr-load-suffixes} и @code{load-file-rep-suffixes} имеют свои
стандартные значения, эта функция возвращает
@code{(".elc" ".elc.gz" ".el" ".el.gz")}, если включен режим автоматического
сжатия, и @code{(".elc" ".el")}, если режим автоматического сжатия отключен.
@end defun

Подводя итог, @code{load} обычно сначала пробует суффиксы в значении
@code{(get-load-suffixes)}, а затем в @code{load-file-rep-suffixes}.  Если
@var{nosuffix} равен не-@code{nil}, он пропускает первую группу, а если
@var{must-suffix} равен не-@code{nil}, он пропускает последнюю группу.

@defopt load-prefer-newer
Если эта опция - не-@code{nil}, то вместо того, чтобы останавливаться на
первом существующем суффиксе, @code{load} проверяет их все и использует
самый новый файл.
@end defopt

@node Library Search
@section Поиск Библиотек
@cindex library search
@cindex find library

  Когда Emacs загружает библиотеку Lisp, он ищет библиотеку в списке
каталогов, заданном переменной @code{load-path}..

@defvar load-path
Значение этой переменной представляет собой список каталогов для поиска
при загрузке файлов с @code{load}.  Каждый элемент представляет собой строку
(которая должна быть каталогом) или @code{nil} (что означает текущий рабочий
каталог).
@end defvar

  Когда Emacs запускается, он устанавливает значение @code{load-path} за
несколько шагов.  Во-первых, он инициализирует @code{load-path}, используя
расположение по умолчанию, установленное при компиляции Emacs.  Обычно это
каталог на подобии

@example
"/usr/local/share/emacs/@var{version}/lisp"
@end example

(В этом и следующих примерах замените @file{/usr/local} на префикс
установки, соответствующий вашему Emacs).  Эти каталоги содержат стандартные
файлы Lisp, которые поставляются с Emacs.  Если Emacs не может их найти, он
не запустится правильно.

Если запускается Emacs из каталога, в котором он был собран, то есть
исполняемого файла, который не был официально установлен, Emacs вместо этого
инициализирует @code{load-path}, используя каталог @file{lisp} в каталоге,
содержащем исходные коды, из которых он был построен.
@c Хотя в builddir/lisp файлов *.el быть не должно, это бессмысленно.
Если Emacs построен в каталоге, отличном от исходного, он также добавляет
каталоги lisp из каталога сборки.  (Во всех случаях элементы представлены
как абсолютные имена файлов.)

@cindex site-lisp directories
Если запускается Emacs с опцией @option{--no-site-lisp}, он добавит еще два
каталога @file{site-lisp} в начало @code{load-path}.  Они предназначены для
локально установленных файлов Lisp и обычно имеют вид:

@example
"/usr/local/share/emacs/@var{version}/site-lisp"
@end example

@noindent
and

@example
"/usr/local/share/emacs/site-lisp"
@end example

@noindent
Первый предназначен для локально установленных файлов конкретной версии
Emacs; второй - для локально установленных файлов, предназначенных для
использования со всеми установленными версиями Emacs.  (Если Emacs запущен
без установки, он также добавляет каталоги @file{site-lisp} из исходных
каталогов и каталогов сборки, если они существуют.  Обычно эти каталоги не
содержат каталогов @file{site-lisp}).

@cindex @env{EMACSLOADPATH} environment variable
Если установлена переменная окружения @env{EMACSLOADPATH}, она изменяет
описанную выше процедуру инициализации.  Emacs инициализирует
@code{load-path} на основе значения переменной окружения.

Синтаксис @env{EMACSLOADPATH} такой же, как и у @code{PATH}; каталоги
разделяются @samp{:} (или @samp{;} в некоторых операционных системах).
@ignore
@c AFAICS, (пока) не работает правильно для указания неабсолютных элементов.
А @samp{.} обозначает текущий каталог по умолчанию.
@end ignore
Вот пример того, как установить переменную @env{EMACSLOADPATH} (из оболочки
в стиле @command{sh}):

@example
export EMACSLOADPATH=/home/foo/.emacs.d/lisp:
@end example

Пустой элемент в значении переменной среды, конечный (как в приведенном выше
примере), ведущий или встроенный, заменяется значением по умолчанию
@code{load-path}, как определено стандартной процедурой инициализации.  Если
таких пустых элементов нет, то @env{EMACSLOADPATH} указывает весь
@code{load-path}.  Потребуется включить либо пустой элемент, либо явный путь
к каталогу, содержащему стандартные файлы Lisp, иначе Emacs не будет
работать.  (Другой способ изменить @code{load-path} - использовать параметр
командной строки @option{-L} при запуске Emacs; смотреть Ниже).

  Для каждого каталога в @code{load-path} Emacs затем проверяет, содержит
ли он файл @file{subdirs.el}, и, если да, загружает его.  Файл
@file{subdirs.el} создается при сборке/установке Emacs и содержит код,
который заставляет Emacs добавлять любые подкаталоги этих каталогов в
@code{load-path}.  Добавляются как непосредственные подкаталоги, так и
подкаталоги на несколько уровней ниже.  Но он исключает подкаталоги, имена
которых не начинаются с буквы или цифры, подкаталоги с именем @file{RCS} или
@file{CVS} и подкаталоги, содержащие файл с именем @file{.nosearch}.

  Затем Emacs добавляет любые дополнительные каталоги загрузки, которые
указываются с помощью параметра командной строки @option{-L}
(@pxref{Action Arguments,,,emacs, The GNU Emacs Manual}).  Также добавляются
каталоги, в которых установлены дополнительные пакеты, если таковые имеются
(@pxref{Packaging Basics}).

  Обычно в файл инициализации (@pxref{Init File}) добавляют код, чтобы
добавить один или несколько каталогов в @code{load-path}. Например:

@example
(push "~/.emacs.d/lisp" load-path)
@end example

  При выгрузке Emacs использует специальное значение @code{load-path}.  Если
используется файл @file{site-load.el} или @file{site-init.el} для настройки
дампа Emacs (@pxref{Building Emacs}), любые изменения в @code{load-path},
сделанные этими файлами, будут потеряны после сброса.

@deffn Command locate-library library &optional nosuffix path interactive-call
Эта команда находит точное имя файла для библиотеки @var{library}.  Ищет
библиотеку так же, как @code{load}, а аргумент @var{nosuffix} имеет то же
значение, что и в @code{load}: не добавляйте суффиксы @samp{.elc} или
@samp{.el} к указанному имени @var{library}.

Если @var{path} - не-@code{nil}, этот список каталогов используется вместо
@code{load-path}..

Когда @code{locate-library} вызывается из программы, возвращает имя файла в
виде строки.  Когда пользователь запускает @code{locate-library} в
интерактивном режиме, аргумент @var{interactive-call} равен @code{t}, и это
указывает @code{locate-library} отображать имя файла в эхо-области.
@end deffn

@cindex shadowed Lisp files
@deffn Command list-load-path-shadows &optional stringp
Эта команда показывает список файлов @dfn{shadowed} Emacs Lisp.  Теневой
файл - это файл, который обычно не загружается, несмотря на то, что он
находится в каталоге @code{load-path}, из-за наличия ранее другого файла с
аналогичным именем в каталоге @code{load-path}.

Например, предположим, что для @code{load-path} установлено значение

@example
  ("/opt/emacs/site-lisp" "/usr/share/emacs/23.3/lisp")
@end example

@noindent
и что оба этих каталога содержат файл с именем @file{foo.el}.  Тогда
@code{(require 'foo)} никогда не загружает файл во второй каталог.  Такая
ситуация может указывать на проблему в способе установки Emacs.

При вызове из Lisp эта функция печатает сообщение со списком затененных
файлов, а не отображает их в буфере.  Если необязательный аргумент
@code{stringp} - не-@code{nil}, она вместо этого возвращает затененные файлы
в виде строки.
@end deffn

@node Loading Non-ASCII
@section Loading Non-@acronym{ASCII} Characters
@cindex loading, and non-ASCII characters
@cindex non-ASCII characters in loaded files

  When Emacs Lisp programs contain string constants with non-@acronym{ASCII}
characters, these can be represented within Emacs either as unibyte
strings or as multibyte strings (@pxref{Text Representations}).  Which
representation is used depends on how the file is read into Emacs.  If
it is read with decoding into multibyte representation, the text of the
Lisp program will be multibyte text, and its string constants will be
multibyte strings.  If a file containing Latin-1 characters (for
example) is read without decoding, the text of the program will be
unibyte text, and its string constants will be unibyte strings.
@xref{Coding Systems}.

  In most Emacs Lisp programs, the fact that non-@acronym{ASCII}
strings are multibyte strings should not be noticeable, since
inserting them in unibyte buffers converts them to unibyte
automatically.  However, if this does make a difference, you can force
a particular Lisp file to be interpreted as unibyte by writing
@samp{coding: raw-text} in a local variables section.  With
that designator, the file will unconditionally be interpreted as
unibyte.  This can matter when making keybindings to
non-@acronym{ASCII} characters written as @code{?v@var{literal}}.

@node Autoload
@section Autoload
@cindex autoload

  The @dfn{autoload} facility lets you register the existence of a
function or macro, but put off loading the file that defines it.  The
first call to the function automatically loads the proper library, in
order to install the real definition and other associated code, then
runs the real definition as if it had been loaded all along.
Autoloading can also be triggered by looking up the documentation of
the function or macro (@pxref{Documentation Basics}), and completion
of variable and function names (@pxref{Autoload by Prefix} below).

@menu
* Autoload by Prefix:: Autoload by Prefix.
* When to Autoload::   When to Use Autoload.
@end menu

  There are two ways to set up an autoloaded function: by calling
@code{autoload}, and by writing a ``magic'' comment in the
source before the real definition.  @code{autoload} is the low-level
primitive for autoloading; any Lisp program can call @code{autoload} at
any time.  Magic comments are the most convenient way to make a function
autoload, for packages installed along with Emacs.  These comments do
nothing on their own, but they serve as a guide for the command
@code{update-file-autoloads}, which constructs calls to @code{autoload}
and arranges to execute them when Emacs is built.

@defun autoload function filename &optional docstring interactive type
This function defines the function (or macro) named @var{function} so as
to load automatically from @var{filename}.  The string @var{filename}
specifies the file to load to get the real definition of @var{function}.

If @var{filename} does not contain either a directory name, or the
suffix @code{.el} or @code{.elc}, this function insists on adding one
of these suffixes, and it will not load from a file whose name is just
@var{filename} with no added suffix.  (The variable
@code{load-suffixes} specifies the exact required suffixes.)

The argument @var{docstring} is the documentation string for the
function.  Specifying the documentation string in the call to
@code{autoload} makes it possible to look at the documentation without
loading the function's real definition.  Normally, this should be
identical to the documentation string in the function definition
itself.  If it isn't, the function definition's documentation string
takes effect when it is loaded.

If @var{interactive} is non-@code{nil}, that says @var{function} can be
called interactively.  This lets completion in @kbd{M-x} work without
loading @var{function}'s real definition.  The complete interactive
specification is not given here; it's not needed unless the user
actually calls @var{function}, and when that happens, it's time to load
the real definition.

You can autoload macros and keymaps as well as ordinary functions.
Specify @var{type} as @code{macro} if @var{function} is really a macro.
Specify @var{type} as @code{keymap} if @var{function} is really a
keymap.  Various parts of Emacs need to know this information without
loading the real definition.

An autoloaded keymap loads automatically during key lookup when a prefix
key's binding is the symbol @var{function}.  Autoloading does not occur
for other kinds of access to the keymap.  In particular, it does not
happen when a Lisp program gets the keymap from the value of a variable
and calls @code{define-key}; not even if the variable name is the same
symbol @var{function}.

@cindex function cell in autoload
If @var{function} already has a non-void function definition that is not
an autoload object, this function does nothing and returns @code{nil}.
Otherwise, it constructs an autoload object (@pxref{Autoload Type}),
and stores it as the function definition for @var{function}.  The
autoload object has this form:

@example
(autoload @var{filename} @var{docstring} @var{interactive} @var{type})
@end example

For example,

@example
@group
(symbol-function 'run-prolog)
     @result{} (autoload "prolog" 169681 t nil)
@end group
@end example

@noindent
In this case, @code{"prolog"} is the name of the file to load, 169681
refers to the documentation string in the
@file{emacs/etc/DOC} file (@pxref{Documentation Basics}),
@code{t} means the function is interactive, and @code{nil} that it is
not a macro or a keymap.
@end defun

@defun autoloadp object
This function returns non-@code{nil} if @var{object} is an autoload
object.  For example, to check if @code{run-prolog} is defined as an
autoloaded function, evaluate

@smallexample
(autoloadp (symbol-function 'run-prolog))
@end smallexample
@end defun

@cindex autoload errors
  The autoloaded file usually contains other definitions and may require
or provide one or more features.  If the file is not completely loaded
(due to an error in the evaluation of its contents), any function
definitions or @code{provide} calls that occurred during the load are
undone.  This is to ensure that the next attempt to call any function
autoloading from this file will try again to load the file.  If not for
this, then some of the functions in the file might be defined by the
aborted load, but fail to work properly for the lack of certain
subroutines not loaded successfully because they come later in the file.

  If the autoloaded file fails to define the desired Lisp function or
macro, then an error is signaled with data @code{"Autoloading failed to
define function @var{function-name}"}.

@findex update-file-autoloads
@findex update-directory-autoloads
@cindex magic autoload comment
@cindex autoload cookie
@anchor{autoload cookie}
  A magic autoload comment (often called an @dfn{autoload cookie})
consists of @samp{;;;###autoload}, on a line by itself,
just before the real definition of the function in its
autoloadable source file.  The command @kbd{M-x update-file-autoloads}
writes a corresponding @code{autoload} call into @file{loaddefs.el}.
(The string that serves as the autoload cookie and the name of the
file generated by @code{update-file-autoloads} can be changed from the
above defaults, see below.)
Building Emacs loads @file{loaddefs.el} and thus calls @code{autoload}.
@kbd{M-x update-directory-autoloads} is even more powerful; it updates
autoloads for all files in the current directory.

  The same magic comment can copy any kind of form into
@file{loaddefs.el}.  The form following the magic comment is copied
verbatim, @emph{except} if it is one of the forms which the autoload
facility handles specially (e.g., by conversion into an
@code{autoload} call).  The forms which are not copied verbatim are
the following:

@table @asis
@item Definitions for function or function-like objects:
@code{defun} and @code{defmacro}; also @code{cl-defun} and
@code{cl-defmacro} (@pxref{Argument Lists,,,cl,Common Lisp Extensions}),
and @code{define-overloadable-function} (see the commentary in
@file{mode-local.el}).

@item Definitions for major or minor modes:
@code{define-minor-mode}, @code{define-globalized-minor-mode},
@code{define-generic-mode}, @code{define-derived-mode},
@code{easy-mmode-define-minor-mode},
@code{easy-mmode-define-global-mode}, @code{define-compilation-mode},
and @code{define-global-minor-mode}.

@item Other definition types:
@code{defcustom}, @code{defgroup}, @code{defclass}
(@pxref{Top,EIEIO,,eieio,EIEIO}), and @code{define-skeleton}
(@pxref{Top,Autotyping,,autotype,Autotyping}).
@end table

  You can also use a magic comment to execute a form at build time
@emph{without} executing it when the file itself is loaded.  To do this,
write the form @emph{on the same line} as the magic comment.  Since it
is in a comment, it does nothing when you load the source file; but
@kbd{M-x update-file-autoloads} copies it to @file{loaddefs.el}, where
it is executed while building Emacs.

  The following example shows how @code{doctor} is prepared for
autoloading with a magic comment:

@example
;;;###autoload
(defun doctor ()
  "Switch to *doctor* buffer and start giving psychotherapy."
  (interactive)
  (switch-to-buffer "*doctor*")
  (doctor-mode))
@end example

@noindent
Here's what that produces in @file{loaddefs.el}:

@example
(autoload (quote doctor) "doctor" "\
Switch to *doctor* buffer and start giving psychotherapy.

\(fn)" t nil)
@end example

@noindent
@cindex @code{fn} in function's documentation string
The backslash and newline immediately following the double-quote are a
convention used only in the preloaded uncompiled Lisp files such as
@file{loaddefs.el}; they tell @code{make-docfile} to put the
documentation string in the @file{etc/DOC} file.  @xref{Building Emacs}.
See also the commentary in @file{lib-src/make-docfile.c}.  @samp{(fn)}
in the usage part of the documentation string is replaced with the
function's name when the various help functions (@pxref{Help
Functions}) display it.

  If you write a function definition with an unusual macro that is not
one of the known and recognized function definition methods, use of an
ordinary magic autoload comment would copy the whole definition into
@code{loaddefs.el}.  That is not desirable.  You can put the desired
@code{autoload} call into @code{loaddefs.el} instead by writing this:

@example
;;;###autoload (autoload 'foo "myfile")
(mydefunmacro foo
  ...)
@end example

  You can use a non-default string as the autoload cookie and have the
corresponding autoload calls written into a file whose name is
different from the default @file{loaddefs.el}.  Emacs provides two
variables to control this:

@defvar generate-autoload-cookie
The value of this variable should be a string whose syntax is a Lisp
comment.  @kbd{M-x update-file-autoloads} copies the Lisp form that
follows the cookie into the autoload file it generates.  The default
value of this variable is @code{";;;###autoload"}.
@end defvar

@defvar generated-autoload-file
The value of this variable names an Emacs Lisp file where the autoload
calls should go.  The default value is @file{loaddefs.el}, but you can
override that, e.g., in the local variables section of a
@file{.el} file (@pxref{File Local Variables}).  The autoload file is
assumed to contain a trailer starting with a formfeed character.
@end defvar

  The following function may be used to explicitly load the library
specified by an autoload object:

@defun autoload-do-load autoload &optional name macro-only
This function performs the loading specified by @var{autoload}, which
should be an autoload object.  The optional argument @var{name}, if
non-@code{nil}, should be a symbol whose function value is
@var{autoload}; in that case, the return value of this function is the
symbol's new function value.  If the value of the optional argument
@var{macro-only} is @code{macro}, this function avoids loading a
function, only a macro.
@end defun

@node Autoload by Prefix
@subsection Autoload by Prefix
@cindex autoload by prefix

@vindex definition-prefixes
@findex register-definition-prefixes
@vindex autoload-compute-prefixes
During completion for the commands @code{describe-variable} and
@code{describe-function}, Emacs will try to load files which may
contain definitions matching the prefix being completed.  The variable
@code{definition-prefixes} holds a hashtable which maps a prefix to
the corresponding list of files to load for it.  Entries to this
mapping are added by calls to @code{register-definition-prefixes}
which are generated by @code{update-file-autoloads}
(@pxref{Autoload}).  Files which don't contain any definitions worth
loading (test files, for examples), should set
@code{autoload-compute-prefixes} to @code{nil} as a file-local
variable.

@node When to Autoload
@subsection When to Use Autoload
@cindex autoload, when to use

Do not add an autoload comment unless it is really necessary.
Autoloading code means it is always globally visible.  Once an item is
autoloaded, there is no compatible way to transition back to it not
being autoloaded (after people become accustomed to being able to use it
without an explicit load).

@itemize
@item
The most common items to autoload are the interactive entry points to a
library.  For example, if @file{python.el} is a library defining a
major-mode for editing Python code, autoload the definition of the
@code{python-mode} function, so that people can simply use @kbd{M-x
python-mode} to load the library.

@item
Variables usually don't need to be autoloaded.  An exception is if the
variable on its own is generally useful without the whole defining
library being loaded.  (An example of this might be something like
@code{find-exec-terminator}.)

@item
Don't autoload a user option just so that a user can set it.

@item
Never add an autoload @emph{comment} to silence a compiler warning in
another file.  In the file that produces the warning, use
@code{(defvar foo)} to silence an undefined variable warning, and
@code{declare-function} (@pxref{Declaring Functions}) to silence an
undefined function warning; or require the relevant library; or use an
explicit autoload @emph{statement}.
@end itemize

@node Repeated Loading
@section Repeated Loading
@cindex repeated loading

  You can load a given file more than once in an Emacs session.  For
example, after you have rewritten and reinstalled a function definition
by editing it in a buffer, you may wish to return to the original
version; you can do this by reloading the file it came from.

  When you load or reload files, bear in mind that the @code{load} and
@code{load-library} functions automatically load a byte-compiled file
rather than a non-compiled file of similar name.  If you rewrite a file
that you intend to save and reinstall, you need to byte-compile the new
version; otherwise Emacs will load the older, byte-compiled file instead
of your newer, non-compiled file!  If that happens, the message
displayed when loading the file includes, @samp{(compiled; note, source is
newer)}, to remind you to recompile it.

  When writing the forms in a Lisp library file, keep in mind that the
file might be loaded more than once.  For example, think about whether
each variable should be reinitialized when you reload the library;
@code{defvar} does not change the value if the variable is already
initialized.  (@xref{Defining Variables}.)

  The simplest way to add an element to an alist is like this:

@example
(push '(leif-mode " Leif") minor-mode-alist)
@end example

@noindent
But this would add multiple elements if the library is reloaded.  To
avoid the problem, use @code{add-to-list} (@pxref{List Variables}):

@example
(add-to-list 'minor-mode-alist '(leif-mode " Leif"))
@end example

  Occasionally you will want to test explicitly whether a library has
already been loaded.  If the library uses @code{provide} to provide a
named feature, you can use @code{featurep} earlier in the file to test
whether the @code{provide} call has been executed before (@pxref{Named
Features}).  Alternatively, you could use something like this:

@example
(defvar foo-was-loaded nil)

(unless foo-was-loaded
  @var{execute-first-time-only}
  (setq foo-was-loaded t))
@end example

@noindent

@node Named Features
@section Features
@cindex features
@cindex requiring features
@cindex providing features

  @code{provide} and @code{require} are an alternative to
@code{autoload} for loading files automatically.  They work in terms of
named @dfn{features}.  Autoloading is triggered by calling a specific
function, but a feature is loaded the first time another program asks
for it by name.

  A feature name is a symbol that stands for a collection of functions,
variables, etc.  The file that defines them should @dfn{provide} the
feature.  Another program that uses them may ensure they are defined by
@dfn{requiring} the feature.  This loads the file of definitions if it
hasn't been loaded already.

@cindex load error with require
  To require the presence of a feature, call @code{require} with the
feature name as argument.  @code{require} looks in the global variable
@code{features} to see whether the desired feature has been provided
already.  If not, it loads the feature from the appropriate file.  This
file should call @code{provide} at the top level to add the feature to
@code{features}; if it fails to do so, @code{require} signals an error.

  For example, in @file{idlwave.el}, the definition for
@code{idlwave-complete-filename} includes the following code:

@example
(defun idlwave-complete-filename ()
  "Use the comint stuff to complete a file name."
   (require 'comint)
   (let* ((comint-file-name-chars "~/A-Za-z0-9+@@:_.$#%=@{@}\\-")
          (comint-completion-addsuffix nil)
          ...)
       (comint-dynamic-complete-filename)))
@end example

@noindent
The expression @code{(require 'comint)} loads the file @file{comint.el}
if it has not yet been loaded, ensuring that
@code{comint-dynamic-complete-filename} is defined.  Features are
normally named after the files that provide them, so that
@code{require} need not be given the file name.  (Note that it is
important that the @code{require} statement be outside the body of the
@code{let}.  Loading a library while its variables are let-bound can
have unintended consequences, namely the variables becoming unbound
after the let exits.)

The @file{comint.el} file contains the following top-level expression:

@example
(provide 'comint)
@end example

@noindent
This adds @code{comint} to the global @code{features} list, so that
@code{(require 'comint)} will henceforth know that nothing needs to be
done.

@cindex byte-compiling @code{require}
  When @code{require} is used at top level in a file, it takes effect
when you byte-compile that file (@pxref{Byte Compilation}) as well as
when you load it.  This is in case the required package contains macros
that the byte compiler must know about.  It also avoids byte compiler
warnings for functions and variables defined in the file loaded with
@code{require}.

  Although top-level calls to @code{require} are evaluated during
byte compilation, @code{provide} calls are not.  Therefore, you can
ensure that a file of definitions is loaded before it is byte-compiled
by including a @code{provide} followed by a @code{require} for the same
feature, as in the following example.

@example
@group
(provide 'my-feature)  ; @r{Ignored by byte compiler,}
                       ;   @r{evaluated by @code{load}.}
(require 'my-feature)  ; @r{Evaluated by byte compiler.}
@end group
@end example

@noindent
The compiler ignores the @code{provide}, then processes the
@code{require} by loading the file in question.  Loading the file does
execute the @code{provide} call, so the subsequent @code{require} call
does nothing when the file is loaded.

@defun provide feature &optional subfeatures
This function announces that @var{feature} is now loaded, or being
loaded, into the current Emacs session.  This means that the facilities
associated with @var{feature} are or will be available for other Lisp
programs.

The direct effect of calling @code{provide} is to add @var{feature} to
the front of @code{features} if it is not already in that list and
call any @code{eval-after-load} code waiting for it (@pxref{Hooks for
Loading}).  The argument @var{feature} must be a symbol.
@code{provide} returns @var{feature}.

If provided, @var{subfeatures} should be a list of symbols indicating
a set of specific subfeatures provided by this version of
@var{feature}.  You can test the presence of a subfeature using
@code{featurep}.  The idea of subfeatures is that you use them when a
package (which is one @var{feature}) is complex enough to make it
useful to give names to various parts or functionalities of the
package, which might or might not be loaded, or might or might not be
present in a given version.  @xref{Network Feature Testing}, for
an example.

@example
features
     @result{} (bar bish)

(provide 'foo)
     @result{} foo
features
     @result{} (foo bar bish)
@end example

When a file is loaded to satisfy an autoload, and it stops due to an
error in the evaluation of its contents, any function definitions or
@code{provide} calls that occurred during the load are undone.
@xref{Autoload}.
@end defun

@defun require feature &optional filename noerror
This function checks whether @var{feature} is present in the current
Emacs session (using @code{(featurep @var{feature})}; see below).  The
argument @var{feature} must be a symbol.

If the feature is not present, then @code{require} loads @var{filename}
with @code{load}.  If @var{filename} is not supplied, then the name of
the symbol @var{feature} is used as the base file name to load.
However, in this case, @code{require} insists on finding @var{feature}
with an added @samp{.el} or @samp{.elc} suffix (possibly extended with
a compression suffix); a file whose name is just @var{feature} won't
be used.  (The variable @code{load-suffixes} specifies the exact
required Lisp suffixes.)

If @var{noerror} is non-@code{nil}, that suppresses errors from actual
loading of the file.  In that case, @code{require} returns @code{nil}
if loading the file fails.  Normally, @code{require} returns
@var{feature}.

If loading the file succeeds but does not provide @var{feature},
@code{require} signals an error about the missing feature.
@end defun

@defun featurep feature &optional subfeature
This function returns @code{t} if @var{feature} has been provided in
the current Emacs session (i.e., if @var{feature} is a member of
@code{features}.)  If @var{subfeature} is non-@code{nil}, then the
function returns @code{t} only if that subfeature is provided as well
(i.e., if @var{subfeature} is a member of the @code{subfeature}
property of the @var{feature} symbol.)
@end defun

@defvar features
The value of this variable is a list of symbols that are the features
loaded in the current Emacs session.  Each symbol was put in this list
with a call to @code{provide}.  The order of the elements in the
@code{features} list is not significant.
@end defvar

@node Where Defined
@section Which File Defined a Certain Symbol
@cindex symbol, where defined
@cindex where was a symbol defined

@defun symbol-file symbol &optional type
This function returns the name of the file that defined @var{symbol}.
If @var{type} is @code{nil}, then any kind of definition is acceptable.
If @var{type} is @code{defun}, @code{defvar}, or @code{defface}, that
specifies function definition, variable definition, or face definition
only.

The value is normally an absolute file name.  It can also be @code{nil},
if the definition is not associated with any file.  If @var{symbol}
specifies an autoloaded function, the value can be a relative file name
without extension.
@end defun

  The basis for @code{symbol-file} is the data in the variable
@code{load-history}.

@defvar load-history
The value of this variable is an alist that associates the names of
loaded library files with the names of the functions and variables
they defined, as well as the features they provided or required.

Each element in this alist describes one loaded library (including
libraries that are preloaded at startup).  It is a list whose @sc{car}
is the absolute file name of the library (a string).  The rest of the
list elements have these forms:

@table @code
@item @var{var}
The symbol @var{var} was defined as a variable.
@item (defun . @var{fun})
The function @var{fun} was defined.
@item (t . @var{fun})
The function @var{fun} was previously an autoload before this library
redefined it as a function.  The following element is always
@code{(defun . @var{fun})}, which represents defining @var{fun} as a
function.
@item (autoload . @var{fun})
The function @var{fun} was defined as an autoload.
@item (defface . @var{face})
The face @var{face} was defined.
@item (require . @var{feature})
The feature @var{feature} was required.
@item (provide . @var{feature})
The feature @var{feature} was provided.
@item (cl-defmethod @var{method} @var{specializers})
The named @var{method} was defined by using @code{cl-defmethod}, with
@var{specializers} as its specializers.
@item (define-type . @var{type})
The type @var{type} was defined.
@end table

The value of @code{load-history} may have one element whose @sc{car} is
@code{nil}.  This element describes definitions made with
@code{eval-buffer} on a buffer that is not visiting a file.
@end defvar

  The command @code{eval-region} updates @code{load-history}, but does so
by adding the symbols defined to the element for the file being visited,
rather than replacing that element.  @xref{Eval}.

@node Unloading
@section Unloading
@cindex unloading packages

@c Emacs 19 feature
  You can discard the functions and variables loaded by a library to
reclaim memory for other Lisp objects.  To do this, use the function
@code{unload-feature}:

@deffn Command unload-feature feature &optional force
This command unloads the library that provided feature @var{feature}.
It undefines all functions, macros, and variables defined in that
library with @code{defun}, @code{defalias}, @code{defsubst},
@code{defmacro}, @code{defconst}, @code{defvar}, and @code{defcustom}.
It then restores any autoloads formerly associated with those symbols.
(Loading saves these in the @code{autoload} property of the symbol.)

Before restoring the previous definitions, @code{unload-feature} runs
@code{remove-hook} to remove functions in the library from certain
hooks.  These hooks include variables whose names end in @samp{-hook}
(or the deprecated suffix @samp{-hooks}), plus those listed in
@code{unload-feature-special-hooks}, as well as
@code{auto-mode-alist}.  This is to prevent Emacs from ceasing to
function because important hooks refer to functions that are no longer
defined.

Standard unloading activities also undoes ELP profiling of functions
in that library, unprovides any features provided by the library, and
cancels timers held in variables defined by the library.

@vindex @var{feature}-unload-function
If these measures are not sufficient to prevent malfunction, a library
can define an explicit unloader named @code{@var{feature}-unload-function}.
If that symbol is defined as a function, @code{unload-feature} calls
it with no arguments before doing anything else.  It can do whatever
is appropriate to unload the library.  If it returns @code{nil},
@code{unload-feature} proceeds to take the normal unload actions.
Otherwise it considers the job to be done.

Ordinarily, @code{unload-feature} refuses to unload a library on which
other loaded libraries depend.  (A library @var{a} depends on library
@var{b} if @var{a} contains a @code{require} for @var{b}.)  If the
optional argument @var{force} is non-@code{nil}, dependencies are
ignored and you can unload any library.
@end deffn

  The @code{unload-feature} function is written in Lisp; its actions are
based on the variable @code{load-history}.

@defvar unload-feature-special-hooks
This variable holds a list of hooks to be scanned before unloading a
library, to remove functions defined in the library.
@end defvar

@node Hooks for Loading
@section Hooks for Loading
@cindex loading hooks
@cindex hooks for loading

You can ask for code to be executed each time Emacs loads a library,
by using the variable @code{after-load-functions}:

@defvar after-load-functions
This abnormal hook is run after loading a file.  Each function in the
hook is called with a single argument, the absolute filename of the
file that was just loaded.
@end defvar

If you want code to be executed when a @emph{particular} library is
loaded, use the macro @code{with-eval-after-load}:

@defmac with-eval-after-load library body@dots{}
This macro arranges to evaluate @var{body} at the end of loading
the file @var{library}, each time @var{library} is loaded.  If
@var{library} is already loaded, it evaluates @var{body} right away.

You don't need to give a directory or extension in the file name
@var{library}.  Normally, you just give a bare file name, like this:

@example
(with-eval-after-load "edebug" (def-edebug-spec c-point t))
@end example

To restrict which files can trigger the evaluation, include a
directory or an extension or both in @var{library}.  Only a file whose
absolute true name (i.e., the name with all symbolic links chased out)
matches all the given name components will match.  In the following
example, @file{my_inst.elc} or @file{my_inst.elc.gz} in some directory
@code{..../foo/bar} will trigger the evaluation, but not
@file{my_inst.el}:

@example
(with-eval-after-load "foo/bar/my_inst.elc" @dots{})
@end example

@var{library} can also be a feature (i.e., a symbol), in which case
@var{body} is evaluated at the end of any file where
@code{(provide @var{library})} is called.

An error in @var{body} does not undo the load, but does prevent
execution of the rest of @var{body}.
@end defmac

Normally, well-designed Lisp programs should not use
@code{with-eval-after-load}.  If you need to examine and set the
variables defined in another library (those meant for outside use),
you can do it immediately---there is no need to wait until the library
is loaded.  If you need to call functions defined by that library, you
should load the library, preferably with @code{require} (@pxref{Named
Features}).

@node Dynamic Modules
@section Emacs Dynamic Modules
@cindex dynamic modules

  A @dfn{dynamic Emacs module} is a shared library that provides
additional functionality for use in Emacs Lisp programs, just like a
package written in Emacs Lisp would.

  Functions that load Emacs Lisp packages can also load dynamic
modules.  They recognize dynamic modules by looking at their file-name
extension, a.k.a.@: ``suffix''.  This suffix is platform-dependent.

@defvar module-file-suffix
This variable holds the system-dependent value of the file-name
extension of the module files.  Its value is @file{.so} on POSIX hosts
and @file{.dll} on MS-Windows.
@end defvar

@findex emacs_module_init
@vindex plugin_is_GPL_compatible
Every dynamic module should export a C-callable function named
@code{emacs_module_init}, which Emacs will call as part of the call to
@code{load} or @code{require} which loads the module.  It should also
export a symbol named @code{plugin_is_GPL_compatible} to indicate that
its code is released under the GPL or compatible license; Emacs will
signal an error if your program tries to load modules that don't
export such a symbol.

If a module needs to call Emacs functions, it should do so through the
@acronym{API} (Application Programming Interface) defined and
documented in the header file @file{emacs-module.h} that is part of
the Emacs distribution.  @xref{Writing Dynamic Modules}, for details
of using that API when writing your own modules.

@cindex user-ptr object
@cindex user pointer object
Modules can create @code{user-ptr} Lisp objects that embed pointers to
C struct's defined by the module.  This is useful for keeping around
complex data structures created by a module, to be passed back to the
module's functions.  User-ptr objects can also have associated
@dfn{finalizers} -- functions to be run when the object is GC'ed; this
is useful for freeing any resources allocated for the underlying data
structure, such as memory, open file descriptors, etc.  @xref{Module
Values}.

@defun user-ptrp object
This function returns @code{t} if its argument is a @code{user-ptr}
object.
@end defun

@defun module-load file
Emacs calls this low-level primitive to load a module from the
specified @var{file} and perform the necessary initialization of the
module.  This is the primitive which makes sure the module exports the
@code{plugin_is_GPL_compatible} symbol, calls the module's
@code{emacs_module_init} function, and signals an error if that
function returns an error indication, or if the use typed @kbd{C-g}
during the initialization.  If the initialization succeeds,
@code{module-load} returns @code{t}.  Note that @var{file} must
already have the proper file-name extension, as this function doesn't
try looking for files with known extensions, unlike @code{load}.
@end defun

Loadable modules in Emacs are enabled by using the
@kbd{--with-modules} option at configure time.
