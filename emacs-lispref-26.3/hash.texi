@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1999, 2001-2019 Free Software Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Hash Tables
@chapter Хеш Таблицы
@cindex hash tables
@cindex lookup tables

  Хэш таблица является очень быстрым видом таблицы поиска, чем-то схожа с
  ALIST (@pxref{Association Lists}) в том, что сопоставляет ключи
  соответствующим значениям.  Отличается от ALIST следующим образом:

@itemize @bullet
@item
Поиск в хэш-таблице очень быстр для больших таблиц---на самом деле, время,
необходимое, по существу @emph{не зависит} от того, сколько элементов
хранит таблица.  Для небольших таблиц (несколько десятков элементов) alists
выигрует по скорости поиска, так как в хэш-таблице присутствуют более или
менее постоянные временные накладные расходы.

@item
Соответствия в хэш-таблице распологаются в произвольном порядке.

@item
Нет возможности разделить одну и туже структуру между двумя хэш-таблицы, как
два ассоциативных списка могут разделять общий хвост.
@end itemize

  Emacs Lisp предоставляет тип данных общего назначения хэш-таблица, а также
  ряд функций для работающих с ней.  Хеш-таблица имеет специальное печатное
  представление, которое состоит из @samp{#s} за которым следует список со
  свойствами и содержимым хэш-таблицы.
  @xref{Creating Hash}.
  (Hash-нотация с начальным символои @samp{#} используется в печатных
  представлениях объектов без представления для чтения, не имеет ничего
  общего с хэш-таблицей.  @xref{Printed Representation}.)

  Массивы также являются своего рода хэш-таблицами, но они другой тип
  объекта и используются только для записи интернированных символов
  (@pxref{Creating Symbols}).

@menu
* Creating Hash::       Функции для создания хеш-таблицы.
* Hash Access::         Чтение и запись содержимого хэш-таблицы.
* Defining Hash::       Определение новых методов сравнения.
* Other Hash::          Разное.
@end menu

@node Creating Hash
@section Создание Хэш-Таблицы
@cindex creating hash tables

  Основная функция для создания хэш-таблицы @code{make-hash-table}.

@defun make-hash-table &rest keyword-args
Функция создает новую хэш-таблицу в соответствии с заданными аргументами.
Аргументы должны состоять из чередующихся ключевых слов (определённые символы
распознаются особым образом) и соответствующих им значений.

Несколько ключевых слов имеет смысл в @code{make-hash-table}, но только два,
о которых действительно нужно знать - это @code{:test} и @code{:weakness}.

@table @code
@item :test @var{test}
Определяет метод поиска ключа для хэш-таблицы.  По умолчанию @code{eql};
@code{eq} и @code{equal}  и другие варианты:

@table @code
@item eql
Ключи, которые являются числами, счтаются одинаковыми, если @code{equal}
признаёт их равными, то есть, если они равны по значению, либо оба
представляют собой целые числа, либо оба являются числами с плавающей точкой;
в противном случае, два отдельных объекта никогда не являются одинаковыми.

@item eq
Любые два различных объекта Lisp, различны как ключи.

@item equal
Два объекта Lisp такие же, как ключи, если они равны согласно @code{equal}.
@end table

Вы можете использовать @code{define-hash-table-test} (@pxref{Defining Hash})
чтобы определить дополнительные возможности для @var{test}.

@item :weakness @var{weak}
Свойство слабость хэш-таблицы указывает сохраняется ли наличие ключа или
значения в хэш-таблице от сборщика мусора.

Значение, @var{weak}, может быть одним из @code{nil}, @code{key},
@code{value}, @code{key-or-value}, @code{key-and-value}, или @code{t},
которое является псевдонимом для @code{key-and-value}.  Если @var{weak}
установлено в @code{key}, то хеш-таблица не препятствует сбору своих ключей
как мусора (если на них нигде нет ссылок); если конкретный ключ действительно
убирается, соответствующая ассоциация удаляется из хеш-таблицы.

Если @var{weak} уставлено в @code{value}, то хеш-таблица не препятствует
сбору своих значений как мусора (если они не на что не ссылаются); если
конкретное значение действительно убирается, соответствующая ассоциация
удаляется из хеш-таблицы.

Если @var{weak} установлено в @code{key-and-value} или @code{t}, ключ и
значение должно быть активными, чтобы сохранить ассоциацию.  Таким образом,
хэш-таблица не защищает по отдельности ключи и значения от сборщика мусора;
если хотя бы одно из них двоих будет собрано как мусор, это удалит
также ассоциацию.

Если @var{weak} установлено в @code{key-or-value}, либо ключ, либо значение
могут сохранить ассоциацию.  Таким образом, ассоциация удаляется из
хэш-таблицы, когда оба и ключ и значение будут собраны как мусор
(если нет ссылок и ничто не ссылается).

По умолчанию @var{weak} установлено в @code{nil}, так что все ключи и
значения, указанные в хэш-таблице сохраняются от сборщика мусора.

@item :size @var{size}
Указывает планируемое количество хранимых ассоциаций в хэш-таблице.  Если вы
знаете приблизительное это количество, вы можете сделать хеш-таблицу немного
более эффективной, определив её таким образом.  Если задаётся количество
меньше требуемого размера, хэш-таблица будет расти автоматически, когда это
необходимо, но это будет занимает некоторое дополнительное время.

Размер по умолчанию 65.

@item :rehash-size @var{rehash-size}
При добавлении ассоциации в хэш-таблицу, которая уже заполнена, она
автоматически увеличивается.  Это значение указывает, на сколько хэш-таблица
должна быть увеличина, в этот момент.

Если @var{rehash-size} представляет собой целое число, оно должно быть
положительным, и хэш-таблица увеличится, добавив примерно столько к
номинальному размеру.  Если @var{rehash-size} представляет собой  число с
плавающей точкой, то оно должно быть больше 1, и хэш-таблица растет путем
умножения старого размера примерно это число.

Значение по умолчанию 1.5.

@item :rehash-threshold @var{threshold}
Определяет критерий, когда хэш-таблица заполнена (поэтому её следует
увеличить).  Значение, @var{threshold}, должно быть положительным числом с
плавающей точкой, не больше, чем 1.  Хеш-таблица считается заполненой, когда
фактическое количество записей превышает номинальный размер, умноженный на
приближённое к этому значению.  По умолчанию значение @var{threshold}
установлено в 0.8125.
@end table
@end defun

Можно создать новую хэш-таблицу, используя печатное представление
хэш-таблицы.  Читатель Lisp может прочесть это печатное представление, при
условии, что каждый элемент в указанном представлении хэш-таблицы, имеет
допустимый синтаксис для чтения (@pxref{Printed Representation}).  Например,
следующая надпись определяет новую хэш-таблицу, содержащую ключи @code{key1}
и @code{key2} (обое символы), связанные со значениями @code{val1} (символ) и
@code{300} (число) соответственно.

@example
#s(hash-table size 30 data (key1 val1 key2 300))
@end example

@noindent
Печатное представление хэш-таблицы состоит из @samp{#s}, за которым следует
список, начинающийся с @samp{hash-table}.  Остальная часть списка должна
состоять из нуля или более пар свойство-значение, определяющих свойства
хэш-таблицы и начальное содержание.  Свойства и значения считываются
буквально.  Допустимые имена свойств @code{size}, @code{test},
@code{weakness}, @code{rehash-size}, @code{rehash-threshold}, и @code{data}.
Свойство @code{data} должно быть списком пар ключ-значение для исходного
содержания; другие свойства имеют то же значение, что и соответствующие
ключевые слова для @code{make-hash-table} (@code{:size}, @code{:test} и
т.п.), описанные выше.

Обратите внимание, что вы не сможете указать хэш-таблицу, начальное
содержание которой включает объекты, которые не имеют синтаксис чтения, такие
как буферы и фреймы.  Такие объекты можно добавить в хэш-таблицу уже после её
создания.

@node Hash Access
@section Доступ к Хэш Таблице
@cindex accessing hash tables
@cindex hash table access

  В этом разделе описаны функции для доступа и сохранения ассоциаций в
  хэш-таблице.  В общем случае, любой объект Lisp может быть использован в
  качестве хэш-ключа, если метод сравнения не накладывает ограничений.  Любой
  объект Lisp также может быть использован в качестве хеш-значения.

@defun gethash key table &optional default
Функция ищет хеш-ключ @var{key} в хеш-таблице @var{table} и возвращает
связанное с ним хеш-значение @var{value}---или @var{default}, если хеш-ключ
@var{key} не имеет ассоциаций в @var{table}.
@end defun

@defun puthash key value table
Функция вводит ассоциацию для хеш-ключа @var{key} в хеш-таблице @var{table},
со значением @var{value}.  Если у хеш-ключа @var{key} уже есть ассоциация в
хеш-таблице @var{table}, значение @var{value} заменяет старое связанное с ним
хеш-значение ассоциации.
@end defun

@defun remhash key table
Функция удаляет ассоциацию с хеш-ключём  @var{key} из хеш-таблицы
@var{table}, если такая существует.  Если хеш-ключ @var{key} не имеет никакой
ассоциации, @code{remhash} ничего не делает.

@b{Примечание Common Lisp:} В Common Lisp, @code{remhash} возвращается
не-@code{nil}, если на самом деле удалена ассоциация и @code{nil} в другом
случае.  В Emacs Lisp, @code{remhash} всегда возвращает @code{nil}.
@end defun

@defun clrhash table
Функция удаляет все ассоциации из хэш-таблицы @var{table}, так что она
становится пустой. Это также называется @dfn{очисткой} хэш-таблицы.

@b{Примечание Common Lisp:} В Common Lisp, в @code{clrhash} возвращается
пустая @var{table}. В Emacs Lisp, возвращается @code{nil}.
@end defun

@defun maphash function table
@anchor{Definition of maphash}
Функция вызывает функцию @var{function} один раз для каждой ассоциации из
хеш-таблицы @var{table}.  Функция @var{function} должна принимать два
аргумента---хеш-ключ @var{key} указанный в хеш-таблице @var{table}, и
связанное с ним хеш-значение @var{value}.  @code{maphash} возвращает
@code{nil}.
@end defun

@node Defining Hash
@section Defining Hash Comparisons
@cindex hash code
@cindex define hash comparisons

  You can define new methods of key lookup by means of
@code{define-hash-table-test}.  In order to use this feature, you need
to understand how hash tables work, and what a @dfn{hash code} means.

  You can think of a hash table conceptually as a large array of many
slots, each capable of holding one association.  To look up a key,
@code{gethash} first computes an integer, the hash code, from the key.
It reduces this integer modulo the length of the array, to produce an
index in the array.  Then it looks in that slot, and if necessary in
other nearby slots, to see if it has found the key being sought.

  Thus, to define a new method of key lookup, you need to specify both a
function to compute the hash code from a key, and a function to compare
two keys directly.

@defun define-hash-table-test name test-fn hash-fn
This function defines a new hash table test, named @var{name}.

After defining @var{name} in this way, you can use it as the @var{test}
argument in @code{make-hash-table}.  When you do that, the hash table
will use @var{test-fn} to compare key values, and @var{hash-fn} to compute
a hash code from a key value.

The function @var{test-fn} should accept two arguments, two keys, and
return non-@code{nil} if they are considered the same.

The function @var{hash-fn} should accept one argument, a key, and return
an integer that is the hash code of that key.  For good results, the
function should use the whole range of integers for hash codes,
including negative integers.

The specified functions are stored in the property list of @var{name}
under the property @code{hash-table-test}; the property value's form is
@code{(@var{test-fn} @var{hash-fn})}.
@end defun

@defun sxhash-equal obj
This function returns a hash code for Lisp object @var{obj}.
This is an integer which reflects the contents of @var{obj}
and the other Lisp objects it points to.

If two objects @var{obj1} and @var{obj2} are @code{equal}, then
@code{(sxhash-equal @var{obj1})} and @code{(sxhash-equal @var{obj2})}
are the same integer.

If the two objects are not @code{equal}, the values returned by
@code{sxhash-equal} are usually different, but not always; once in a
rare while, by luck, you will encounter two distinct-looking objects
that give the same result from @code{sxhash-equal}.

@b{Common Lisp note:} In Common Lisp a similar function is called
@code{sxhash}.  Emacs provides this name as a compatibility alias for
@code{sxhash-equal}.
@end defun

@defun sxhash-eq obj
This function returns a hash code for Lisp object @var{obj}.  Its
result reflects identity of @var{obj}, but not its contents.

If two objects @var{obj1} and @var{obj2} are @code{eq}, then
@code{(sxhash-eq @var{obj1})} and @code{(sxhash-eq @var{obj2})} are
the same integer.
@end defun

@defun sxhash-eql obj
This function returns a hash code for Lisp object @var{obj} suitable
for @code{eql} comparison.  I.e. it reflects identity of @var{obj}
except for the case where the object is a float number, in which case
hash code is generated for the value.

If two objects @var{obj1} and @var{obj2} are @code{eql}, then
@code{(sxhash-eql @var{obj1})} and @code{(sxhash-eql @var{obj2})} are
the same integer.
@end defun

  This example creates a hash table whose keys are strings that are
compared case-insensitively.

@example
(defun case-fold-string= (a b)
  (eq t (compare-strings a nil nil b nil nil t)))
(defun case-fold-string-hash (a)
  (sxhash-equal (upcase a)))

(define-hash-table-test 'case-fold
  'case-fold-string= 'case-fold-string-hash)

(make-hash-table :test 'case-fold)
@end example

  Here is how you could define a hash table test equivalent to the
predefined test value @code{equal}.  The keys can be any Lisp object,
and equal-looking objects are considered the same key.

@example
(define-hash-table-test 'contents-hash 'equal 'sxhash-equal)

(make-hash-table :test 'contents-hash)
@end example

@node Other Hash
@section Other Hash Table Functions

  Here are some other functions for working with hash tables.

@defun hash-table-p table
This returns non-@code{nil} if @var{table} is a hash table object.
@end defun

@defun copy-hash-table table
This function creates and returns a copy of @var{table}.  Only the table
itself is copied---the keys and values are shared.
@end defun

@defun hash-table-count table
This function returns the actual number of entries in @var{table}.
@end defun

@defun hash-table-test table
This returns the @var{test} value that was given when @var{table} was
created, to specify how to hash and compare keys.  See
@code{make-hash-table} (@pxref{Creating Hash}).
@end defun

@defun hash-table-weakness table
This function returns the @var{weak} value that was specified for hash
table @var{table}.
@end defun

@defun hash-table-rehash-size table
This returns the rehash size of @var{table}.
@end defun

@defun hash-table-rehash-threshold table
This returns the rehash threshold of @var{table}.
@end defun

@defun hash-table-size table
This returns the current nominal size of @var{table}.
@end defun
