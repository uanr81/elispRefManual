@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1999, 2001-2019 Free Software Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Hash Tables
@chapter Хеш Таблицы
@cindex hash tables
@cindex lookup tables

  Хэш таблица является очень быстрым видом таблицы поиска, чем-то схожа с
  ALIST (@pxref{Association Lists}) в том, что сопоставляет ключи
  соответствующим значениям.  Отличается от ALIST следующим образом:

@itemize @bullet
@item
Поиск в хэш-таблице очень быстр для больших таблиц---на самом деле, время,
необходимое, по существу @emph{не зависит} от того, сколько элементов
хранит таблица.  Для небольших таблиц (несколько десятков элементов) alists
выигрует по скорости поиска, так как в хэш-таблице присутствуют более или
менее постоянные временные накладные расходы.

@item
Соответствия в хэш-таблице распологаются в произвольном порядке.

@item
Нет возможности разделить одну и туже структуру между двумя хэш-таблицы, как
два ассоциативных списка могут разделять общий хвост.
@end itemize

  Emacs Lisp предоставляет тип данных общего назначения хэш-таблица, а также
  ряд функций для работающих с ней.  Хеш-таблица имеет специальное печатное
  представление, которое состоит из @samp{#s} за которым следует список со
  свойствами и содержимым хэш-таблицы.
  @xref{Creating Hash}.
  (Hash-нотация с начальным символои @samp{#} используется в печатных
  представлениях объектов без представления для чтения, не имеет ничего
  общего с хэш-таблицей.  @xref{Printed Representation}.)

  Массивы также являются своего рода хэш-таблицами, но они другой тип
  объекта и используются только для записи интернированных символов
  (@pxref{Creating Symbols}).

@menu
* Creating Hash::       Функции для создания хеш-таблицы.
* Hash Access::         Чтение и запись содержимого хэш-таблицы.
* Defining Hash::       Определение новых методов сравнения.
* Other Hash::          Разное.
@end menu

@node Creating Hash
@section Создание Хэш-Таблицы
@cindex creating hash tables

  Основная функция для создания хэш-таблицы @code{make-hash-table}.

@defun make-hash-table &rest keyword-args
Функция создает новую хэш-таблицу в соответствии с заданными аргументами.
Аргументы должны состоять из чередующихся ключевых слов (определённые символы
распознаются особым образом) и соответствующих им значений.

Несколько ключевых слов имеет смысл в @code{make-hash-table}, но только два,
о которых действительно нужно знать - это @code{:test} и @code{:weakness}.

@table @code
@item :test @var{test}
Определяет метод поиска ключа для хэш-таблицы.  По умолчанию @code{eql};
@code{eq} и @code{equal}  и другие варианты:

@table @code
@item eql
Ключи, которые являются числами, счтаются одинаковыми, если @code{equal}
признаёт их равными, то есть, если они равны по значению, либо оба
представляют собой целые числа, либо оба являются числами с плавающей точкой;
в противном случае, два отдельных объекта никогда не являются одинаковыми.

@item eq
Любые два различных объекта Lisp, различны как ключи.

@item equal
Два объекта Lisp такие же, как ключи, если они равны согласно @code{equal}.
@end table

Вы можете использовать @code{define-hash-table-test} (@pxref{Defining Hash})
чтобы определить дополнительные возможности для @var{test}.

@item :weakness @var{weak}
Свойство слабость хэш-таблицы указывает сохраняется ли наличие ключа или
значения в хэш-таблице от сборщика мусора.

Значение, @var{weak}, может быть одним из @code{nil}, @code{key},
@code{value}, @code{key-or-value}, @code{key-and-value}, или @code{t},
которое является псевдонимом для @code{key-and-value}.  Если @var{weak}
установлено в @code{key}, то хеш-таблица не препятствует сбору своих ключей
как мусора (если на них нигде нет ссылок); если конкретный ключ действительно
убирается, соответствующая ассоциация удаляется из хеш-таблицы.

Если @var{weak} уставлено в @code{value}, то хеш-таблица не препятствует
сбору своих значений как мусора (если они не на что не ссылаются); если
конкретное значение действительно убирается, соответствующая ассоциация
удаляется из хеш-таблицы.

Если @var{weak} установлено в @code{key-and-value} или @code{t}, ключ и
значение должно быть активными, чтобы сохранить ассоциацию.  Таким образом,
хэш-таблица не защищает по отдельности ключи и значения от сборщика мусора;
если хотя бы одно из них двоих будет собрано как мусор, это удалит
также ассоциацию.

Если @var{weak} установлено в @code{key-or-value}, либо ключ, либо значение
могут сохранить ассоциацию.  Таким образом, ассоциация удаляется из
хэш-таблицы, когда оба и ключ и значение будут собраны как мусор
(если нет ссылок и ничто не ссылается).

По умолчанию @var{weak} установлено в @code{nil}, так что все ключи и
значения, указанные в хэш-таблице сохраняются от сборщика мусора.

@item :size @var{size}
Указывает планируемое количество хранимых ассоциаций в хэш-таблице.  Если вы
знаете приблизительное это количество, вы можете сделать хеш-таблицу немного
более эффективной, определив её таким образом.  Если задаётся количество
меньше требуемого размера, хэш-таблица будет расти автоматически, когда это
необходимо, но это будет занимает некоторое дополнительное время.

Размер по умолчанию 65.

@item :rehash-size @var{rehash-size}
При добавлении ассоциации в хэш-таблицу, которая уже заполнена, она
автоматически увеличивается.  Это значение указывает, на сколько хэш-таблица
должна быть увеличина, в этот момент.

Если @var{rehash-size} представляет собой целое число, оно должно быть
положительным, и хэш-таблица увеличится, добавив примерно столько к
номинальному размеру.  Если @var{rehash-size} представляет собой  число с
плавающей точкой, то оно должно быть больше 1, и хэш-таблица растет путем
умножения старого размера примерно это число.

Значение по умолчанию 1.5.

@item :rehash-threshold @var{threshold}
Определяет критерий, когда хэш-таблица заполнена (поэтому её следует
увеличить).  Значение, @var{threshold}, должно быть положительным числом с
плавающей точкой, не больше, чем 1.  Хеш-таблица считается заполненой, когда
фактическое количество записей превышает номинальный размер, умноженный на
приближённое к этому значению.  По умолчанию значение @var{threshold}
установлено в 0.8125.
@end table
@end defun

Можно создать новую хэш-таблицу, используя печатное представление
хэш-таблицы.  Читатель Lisp может прочесть это печатное представление, при
условии, что каждый элемент в указанном представлении хэш-таблицы, имеет
допустимый синтаксис для чтения (@pxref{Printed Representation}).  Например,
следующая надпись определяет новую хэш-таблицу, содержащую ключи @code{key1}
и @code{key2} (обое символы), связанные со значениями @code{val1} (символ) и
@code{300} (число) соответственно.

@example
#s(hash-table size 30 data (key1 val1 key2 300))
@end example

@noindent
Печатное представление хэш-таблицы состоит из @samp{#s}, за которым следует
список, начинающийся с @samp{hash-table}.  Остальная часть списка должна
состоять из нуля или более пар свойство-значение, определяющих свойства
хэш-таблицы и начальное содержание.  Свойства и значения считываются
буквально.  Допустимые имена свойств @code{size}, @code{test},
@code{weakness}, @code{rehash-size}, @code{rehash-threshold}, и @code{data}.
Свойство @code{data} должно быть списком пар ключ-значение для исходного
содержания; другие свойства имеют то же значение, что и соответствующие
ключевые слова для @code{make-hash-table} (@code{:size}, @code{:test} и
т.п.), описанные выше.

Обратите внимание, что вы не сможете указать хэш-таблицу, начальное
содержание которой включает объекты, которые не имеют синтаксис чтения, такие
как буферы и фреймы.  Такие объекты можно добавить в хэш-таблицу уже после её
создания.

@node Hash Access
@section Доступ к Хэш Таблице
@cindex accessing hash tables
@cindex hash table access

  В этом разделе описаны функции для доступа и сохранения ассоциаций в
  хэш-таблице.  В общем случае, любой объект Lisp может быть использован в
  качестве хэш-ключа, если метод сравнения не накладывает ограничений.  Любой
  объект Lisp также может быть использован в качестве хеш-значения.

@defun gethash key table &optional default
Функция ищет хеш-ключ @var{key} в хеш-таблице @var{table} и возвращает
связанное с ним хеш-значение @var{value}---или @var{default}, если хеш-ключ
@var{key} не имеет ассоциаций в @var{table}.
@end defun

@defun puthash key value table
Функция вводит ассоциацию для хеш-ключа @var{key} в хеш-таблице @var{table},
со значением @var{value}.  Если у хеш-ключа @var{key} уже есть ассоциация в
хеш-таблице @var{table}, значение @var{value} заменяет старое связанное с ним
хеш-значение ассоциации.
@end defun

@defun remhash key table
Функция удаляет ассоциацию с хеш-ключём  @var{key} из хеш-таблицы
@var{table}, если такая существует.  Если хеш-ключ @var{key} не имеет никакой
ассоциации, @code{remhash} ничего не делает.

@b{Примечание Common Lisp:} В Common Lisp, @code{remhash} возвращается
не-@code{nil}, если на самом деле удалена ассоциация и @code{nil} в другом
случае.  В Emacs Lisp, @code{remhash} всегда возвращает @code{nil}.
@end defun

@defun clrhash table
Функция удаляет все ассоциации из хэш-таблицы @var{table}, так что она
становится пустой. Это также называется @dfn{очисткой} хэш-таблицы.

@b{Примечание Common Lisp:} В Common Lisp, в @code{clrhash} возвращается
пустая @var{table}. В Emacs Lisp, возвращается @code{nil}.
@end defun

@defun maphash function table
@anchor{Definition of maphash}
Функция вызывает функцию @var{function} один раз для каждой ассоциации из
хеш-таблицы @var{table}.  Функция @var{function} должна принимать два
аргумента---хеш-ключ @var{key} указанный в хеш-таблице @var{table}, и
связанное с ним хеш-значение @var{value}.  @code{maphash} возвращает
@code{nil}.
@end defun

@node Defining Hash
@section Определение Hash Сравнения
@cindex hash code
@cindex define hash comparisons

  Есть возможность определить новые методы поиска ключей в хеш-таблицах
  с помощью @code{define-hash-table-test}.м Для того, чтобы использовать эту
  функцию, нужно понимать, как работают хэш-таблицы, и что означает
  средство @dfn{хеш-код}.

  Хэш-таблицы концептуально можно рассматривать как большой массив из
  множества слотов, каждый из которых способен удерживать одну ассоциацию.
  Чтобы найти ключ, @code{gethash} сначала вычисляет целое число - хэш-код
  от ключа.  Затем уменьшает это число по модулю длины массива, чтобы
  получить индекс в массиве.  Далее ищет в слоте с этим индексом, а при
  необходимости и в других соседних слотах, чтобы определить, найден ли
  искомый ключ.

  Таким образом, чтобы определить новый метод поиска ключа, необходимо
  указать как функцию для вычисления хэш-кода из ключа и так и функцию
  непосредственного сравнения двух ключей.

@defun define-hash-table-test name test-fn hash-fn
Функция определяет новый тест для хэш-таблицы с именем @var{name}.

После такого определения, @var{name} можно использовать в качестве аргумента
@var{test} для @code{make-hash-table}.  Если это сделано, хэш-таблица будет
использовать @var{test-fn} для сравнения значения ключа, и @var{hash-fn} для
вычисления хэш-кода из значения ключа.

Функция @var{test-fn} принимает два аргумента, два ключа, и возвращает
не-@code{nil}, если они считаются одинаковыми.

Функция @var{hash-fn} принимает один аргумент, ключ и возвращает целое число,
которое является хэш-кодом этого ключа.  Для получения хороших результатов,
функция должна использовать весь диапазон целых чисел для хэша-кода, в том
числе отрицательные целые числа.

Указанные функции хранятся в списке свойств @code{hash-table-test} под именем
@var{name}; значения хранятся в свойствах @code{(@var{test-fn}
@var{hash-fn})}. (ВопросHash267)
@end defun

@defun sxhash-equal obj
Функция возвращает хэш-код для объекта Lisp @var{obj}.  Это целое число,
которое отражает содержание @var{obj} и других объектов Lisp на которые он
указывает.

Если два объекта @var{obj1} и @var{obj2} удовлетворят @code{equal},
то @code{(sxhash-equal @var{obj1})} и @code{(sxhash-equal @var{obj2})} также
являются одним и тем же целым числом.

Если два объекта не удовлетворяют @code{equal}, значения, возвращаемые
@code{sxhash-equal}, как правило, различны, но не всегда; изредка, по
счастливой случайности, встречаются два совершенно разных объекта, для
которых @code{sxhash-equal} выдаёт один и тот же результат.

@b{Common Lisp примечание:} В Common Lisp аналогичная функция называется
@code{sxhash}.  Emacs предоставляет имя @code{sxhash-equal} в качестве
псевдонима для совместимости.(ВопросHash286)
@end defun

@defun sxhash-eq obj
Функция возвращает хэш-код для объекта Lisp @var{obj}.  Результат отражает
идентичность @var{obj}, без учёта его содержимого.

Если два объекта @var{obj1} и @var{obj2} удовлетворяют @code{eq}, то
@code{(sxhash-eq @var{obj1})} и @code{(sxhash-eq @var{obj2})} выдают одно и
то же целое число.
@end defun

@defun sxhash-eql obj
Функция возвращает хэш-код Lisp объекта @var{obj}, пригодный для сравнения
@code{eql}.  То есть отражается идентичность @var{obj}, за исключением
случая, когда объект представляет собой число с плавающей точкой, и в этом
случае генерируется значение хеш-кода.(Вопрос302)

Если два объекта @var{obj1} и @var{obj2} удовлетворяют @code{eql}, то
@code{(sxhash-eql @var{obj1})} и @code{(sxhash-eql @var{obj2})} производят
одно и тоже целое число.
@end defun

  Этот пример создает хэш-таблицу, ключи которой представляют собой строки,
  которые сравниваются без учёта регистра.

@example
(defun case-fold-string= (a b)
  (eq t (compare-strings a nil nil b nil nil t)))
(defun case-fold-string-hash (a)
  (sxhash-equal (upcase a)))

(define-hash-table-test 'case-fold
  'case-fold-string= 'case-fold-string-hash)

(make-hash-table :test 'case-fold)
@end example

  Вот как можно определить тест хэш-таблицы, эквивалентный предопределённому
  тесту @code{equal}.  Ключи могут быть любыми объектами Lisp и объекты
  одинакового вида считаются одним и тем же ключом.(Вопрос326)

@example
(define-hash-table-test 'contents-hash 'equal 'sxhash-equal)

(make-hash-table :test 'contents-hash)
@end example

@node Other Hash
@section Другие Функции работы с Хеш-Таблицей

  Вот некоторые другие функции для работы с хэш-таблицами.

@defun hash-table-p table
Возвращает не-@code{nil} если @var{table} это объект хэш-таблица.
@end defun

@defun copy-hash-table table
Функция создает и возвращает копию @var{table}.  Только сама таблица
копируется---ключи и значения используются совместно. (ВопросHash345)
@end defun

@defun hash-table-count table
Функция возвращает фактическое число записей в @var{table}.
@end defun

@defun hash-table-test table
Возвращает значение @var{test}, которое было дано при создании @var{table},
чтобы определить, как получается хэш-ключа и сравниваются ключи.  Смотреть
@code{make-hash-table} (@pxref{Creating Hash}).
@end defun

@defun hash-table-weakness table
Функция возвращает значение @var{weak}, которое было задано для хэш-таблицы
@var{table}.
@end defun

@defun hash-table-rehash-size table
Возвращает размер хеширования @var{table}.(ВопросHsh364)
@end defun

@defun hash-table-rehash-threshold table
Возвращает порог повторного хеширования @var{table}.
@end defun

@defun hash-table-size table
Возвращает текущий номинальный размер @var{table}.
@end defun
