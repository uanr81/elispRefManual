@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1994, 1998, 2001-2019 Free Software Foundation,
@c Inc.
@c See the file elisp.texi for copying conditions.
@node Evaluation
@chapter Оценка
@cindex evaluation
@cindex  interpreter
@cindex interpreter
@cindex value of expression

  @dfn{Оценка} выражений в Emacs Lisp выполняется программой
  @dfn{Интерпретатор Lisp}---a, который принимает Lisp объект
  в качестве входных данных и вычисляет его @dfn{значение как выражение}.
  Как это происходит, зависит от типа данных объекта, в соответствии с
  правилами, описанными в этой главе. Интерпретатор запускается
  автоматически для оценки частей вашей программы, но также может
  быть вызван явно с помощью примитивной функции Lisp @code{eval}.

@ifnottex
@menu
* Intro Eval::  Схема оценки.
* Forms::       Как оцениваются различные виды объектов.
* Quoting::     Чтобы Избежать Оценки (константы в программе).
* Backquote::   Более лёгкое построение структуры списка.
* Eval::        Как вызвать интерпретатор Lisp явно.
@end menu

@node Intro Eval
@section Введение в оценку

  Lisp интерпретатор или оценщик, является частью Emacs, которая
  вычисляет значение переданного ему выражения. Когда функция,
  написаная на Lisp вызывается, оценщик вычисляет значение функции
  путем оценки выражения в теле функции. Таким образом, запуск
  любой программы Lisp действительно означает запуск
  интерпретатора Lisp.
@end ifnottex

@cindex form
@cindex expression
@cindex S-expression
@cindex sexp
  Lisp объект предназначенный для оценки, называется @dfn{формой}
или @dfn{выражением}@footnote{Иногда также упоминается как
@dfn{S-выражение} или @dfn{sexp}, но мы вообще не используем
эту терминологию в данном руководстве.}.  Тот факт, что формы
являются объектами данных, а не просто текстом, является
одним из фундаментальных различий между Lisp-подобными
языками и типичными языками программирования. Любой объект
может быть оценен, но на практике в основном обрабатываются
только цифры, символы,списки и строки.

  В последующих разделах мы подробно опишем, что означает
  оценка для каждого вида формы.

  Очень часто, Lisp читает форму, а затем оценивает её, и
  чтение и оценка являются отдельными видами деятельности, и
  любой из них может быть выполнен в одиночку. Чтение
  само по себе ничего не оценивает; оно преобразует печатное
  представление объекта Lisp в сам объект. Вызывающий
  @code{read} объект должен указать, подлежит ли форма для
  оценки, или служит какой-то совершенно иной цели.
  @xref{Input Functions}.

@cindex recursive evaluation
  Оценка представляет собой рекурсивный процесс, и оценка формы часто
  включает в себя оценку частей внутри этой формы.  Например, при оценке
  формы @dfn{вызова функции}, такой как @code{(car x)}, Emacs сначала
  вычисляет аргумент (подчиненную форму @code{x}).  После оценки аргумента,
  Emacs @dfn{выполняет} функцию (@code{car}), и если функция написана на
  Lisp, выполнение происходит путем оценки @dfn{тела} функции (в данном
  примере, однако, @code{car} не является функция Lisp, это примитивная
  функция реализованная на C).  @xref{Functions}, для получения
  дополнительной информации о функциях и вызовах функций.

@cindex environment
  Оценка происходит в контексте,называемой @dfn{environment (средой)},
  которая состоит из текущих значений и привязки всех переменных Lisp
  (@pxref{Variables}).@footnote{Это определение ``environment (среда)''
  специально не включают в себя все данные, которые могут повлиять на
  результат программы.}  Всякий раз, когда форма обращается к переменной без
  создания нового связывания для неё, переменная принимает значение величины,
  заданное текущей средой.   Оценка формы также может временно изменить
  окружающую среду путем связывания переменных (@pxref{Local Variables}).

@cindex side effect
@anchor{Definition of side effect}
  Оценка формы также может внести изменения, которые сохраняются; эти
  изменения называются @dfn{побочными уффектами}.  Пример формы, которая
  производит побочный эффект @code{(setq foo 1)}.

  Не следует путать оценку с интерпретацией ключевой команды.  Командный
  цикл редактора переводит ввод с клавиатуры в команду (интерактивно
  вызываемую функцию) с использованием активных раскладок клавиш, а затем
  использует @code{call-interactively}, чтобы выполнить эту команду.
  Выполнение команды обычно включает в себя оценку, если команда написана на
  Lisp; однако этот шаг не считается частью интерпретации ключевой команды.
  @xref{Command Loop}.

@node Forms
@section Виды Форм

  Lisp объект, который предназначен для оценки называется @dfn{формой} (или
  @dfn{выражением}).  Как Emacs оценивает форму, зависит от её типа данных.
  Emacs имеет три различных вида формы, которые оцениваются по-разному:
  символы, списки и все остальные типы.  В этом разделе описаны все три вида,
  один за другим, начиная с остальных типов, которые представляют собой
  самооценочные формы.

@menu
* Self-Evaluating Forms::   Формы, которые оценивают себя.
* Symbol Forms::            Символы оцениваются как переменные.
* Classifying Lists::       Отличие различных списочных форм.
* Function Indirection::    При появлении символа как car списка, ищется
                            действительная функция через символ.
* Function Forms::          Формы, вызова функции.
* Macro Forms::             Формы, вызова макроса.
* Special Forms::           Специальные формы - своеобразные примитивы,
                            большинство из них являются крайне важными.
* Autoloading::             Функции, загружаемые из файлов, содержащих их
                            реальное определение.
@end menu

@node Self-Evaluating Forms
@subsection Самооценочные Формы
@cindex vector evaluation
@cindex literal evaluation
@cindex self-evaluating form
@cindex form, self-evaluating

  @dfn{Самооценочная форма} это любая форма, которая не является списком
  или символом.  Самооценочная форма оценивает себя сама: результат оценки
  тот же объект, который был оценен.  Таким образом, число 25 имеет значение
  25, а строка @code{"foo"} принимает значение строки @code{"foo"}.  Точно
  так же, оценка вектора не вызывает оценку элементов вектора---возвращается
  один и тот же вектор с его содержимым без изменений.

@example
@group
'123               ; @r{Число, показанное без оценки.}
     @result{} 123
@end group
@group
123                ; @r{Оценка числа как обычно---результат тот же.}
     @result{} 123
@end group
@group
(eval '123)        ; @r{Оценка @code{вручную}---результат тот же.}
     @result{} 123
@end group
@group
(eval (eval '123)) ; @r{Двойная оценка ничего не меняет.}
     @result{} 123
@end group
@end example

  Часто пользуются при записи чисел, символов, строк и даже векторов в
  Lisp коде тем, что они самооцениваются.  Тем не менее, это довольно
  необычно для типов, которые не имеют синтаксис чтения, потому что нет
  никакого способа, написать их текстуально.  Можно создать Lisp выражения,
  содержащие эти типы с помощью программы Lisp. Вот пример:

@example
@group
;; @r{Построить выражение, содержащее объект буфера.}
(setq print-exp (list 'print (current-buffer)))
     @result{} (print #<buffer eval.texi>)
@end group
@group
;; @r{Оценить его.}
(eval print-exp)
     @print{} #<buffer eval.texi>
     @result{} #<buffer eval.texi>
@end group
@end example

@node Symbol Forms
@subsection Символьные Формы
@cindex symbol evaluation
@cindex symbol forms
@cindex forms, symbol

  Когда символ оценивается, он рассматривается в качестве переменной.
  Результатом является значение переменной, если оно есть.  Если символ не
  имеет значения в качестве переменной, интерпретатор Lisp сигнализирует об
  ошибке.  Для получения дополнительной информации об использовании
  переменных смотреть @ref{Variables}.

  В следующем примере устанавливается значение символу @code{a}, используя
  @code{setq}.  Затем оценивается символ, и @code{setq} возвращает
  сохраненное значение.

@example
@group
(setq a 123)
     @result{} 123
@end group
@group
(eval 'a)
     @result{} 123
@end group
@group
a
     @result{} 123
@end group
@end example

  Символы @code{nil} и @code{t} обрабатывают специально, так что значение
  @code{nil} всегда @code{nil}, а значение @code{t} всегда @code{t}; вы не
  можете установить или связать их с любыми другими значениями.  Таким
  образом, эти два символа действуют как самооценочные формы, даже если
  @code{eval} обрабатывает их, как и любой другой символ.  Символ, имя
  которого начинается с @samp{:} также являются самооценочными; так же, его
  значение обычно не может быть изменено.  @xref{Constant Variables}.

@node Classifying Lists
@subsection Классификация Списочных Форм
@cindex list form evaluation
@cindex forms, list

  Форма, которая является непустым списком является либо вызовом функции,
  либо вызовом макроса, либо специальной формой в зависимости от первого
  элемента списочной формы.  Эти три вида форм оценивается по-разному,
  описано ниже.  Остальные элементы списка представляют собой @dfn{аргументы}
  для функции, макроса или специальной формы.

  Первый шаг в оценке непустого списка состоит в изучении его первого
  элемента.  Только по этому элементу определяется к какой форме принадлежит
  списочная форма и каким образом будет обработана её остальная часть списка.
  Первый элемент @emph{не} оценивается, как в некоторых Lisp диалектах,
  таких как Scheme.

@node Function Indirection
@subsection Косвенная Функция Символа
@cindex symbol function indirection
@cindex indirection for functions
@cindex void function

  Если первый элемент списка является символ, то оценщик проверяет компоненту
  символа, ячейку функции и использует её содержимое вместо исходного
  символа.  Если содержимое представляет собой другой символ, запускается
  рекурсивный процесс обрабатывающий @dfn{косвенную функцию символа},
  повторяется до тех пор, пока в результате не получится не-символ.
  @xref{Function Names}, для получения дополнительной информации о
  косвенной функции символа. (ВопросEval247)

  Одним из возможных последствий этого процесса является бесконечный цикл,
  в том случае, когда значение компоненты символа ячейки функции ссылается на
  один и тот же символ.  В противном случае, в конечном итоге получается
  не-символ, который должен быть функцией или другим подходящим объектом.

@kindex invalid-function
  Точнее, в конце концов должна быть: функция Lisp (лямбда-выражение),
  байт-скомпилированная функция, примитивная функция, макрос Lisp,
  специальная форма или объект автозагрузки.  Каждый из этих типов описан
  в одном из следующих разделов.  Если объект не является одним из этих
  типов, то Emacs сигнализирует об ошибке @code{invalid-function}.

  Следующий пример иллюстрирует процесс косвенного обращения к символу.  Мы
  используем @code{fset}, чтобы установить значение компоненты символа ячейки
  функции и @code{symbol-function}, чтобы получить такое значение
  (@pxref{Function Cells}).  В частности, мы сохраняем символ @code{car}
  значением компоненты ячейки функции символа @code{first}, а символ
  @code{first} - значением компоненты ячейки функции символа @code{erste}.

@example
@group
;; @r{Построение связи компоненты символа ячейки функции:}
;;   -------------       -----        -------        -------
;;  | #<subr car> | <-- | car |  <-- | first |  <-- | erste |
;;   -------------       -----        -------        -------
@end group
@group
(symbol-function 'car)
     @result{} #<subr car>
@end group
@group
(fset 'first 'car)
     @result{} car
@end group
@group
(fset 'erste 'first)
     @result{} first
@end group
@group
(erste '(1 2 3))   ; @r{Вызов функции, на которую ссылается @code{erste}.}
     @result{} 1
@end group
@end example

  В отличии от этого, в следующем примере вызывается функция без какой-либо
  косвенной символьной функции, потому что первый элемент является
  анонимной функцией Lisp, а не символом.

@example
@group
((lambda (arg) (erste arg))
 '(1 2 3))
     @result{} 1
@end group
@end example

@noindent
Выполнение самой функции оценивает её тело; это включает косвенное обращение
к функции установленной значением компоненты ячейки функции символа
@code{erste}.

  Эта форма редко используется и в настоящее время не рекомендуется.
  Вместо этого используется форма:

@example
@group
(funcall (lambda (arg) (erste arg))
         '(1 2 3))
@end group
@end example
или ещё проще
@example
@group
(let ((arg '(1 2 3))) (erste arg))
@end group
@end example

  Встроенная функция @code{indirect-function} обеспечивает простой способ
  для явного обращения к косвенной функции символа.

@c Emacs 19 feature
@defun indirect-function function &optional noerror
@anchor{Definition of indirect-function}
Функция возвращает значение @var{function} как функции.  Если @var{function}
является символом, то снова ищется @var{function} определение функции с
этим значением.  Если @var{function} не символ, то он возвращается сама
@var{function} функция.

Эта функция возвращает @code{nil} если конечный символ несвязанн.
Сигнализируется об ошибке @code{cyclic-function-indirection} если есть
петля в цепочке символов.

Необязательный аргумент @var{noerror} устарел, сохранён для обратной
совместимости, и не имеет никакого эффекта.

Вот как можно определить @code{indirect-function} в Lisp:

@example
(defun indirect-function (function)
  (if (symbolp function)
      (indirect-function (symbol-function function))
    function))
@end example
@end defun

@node Function Forms
@subsection Оценка Функциональных Форм
@cindex function form evaluation
@cindex function call
@cindex forms, function call

  Если первый элемент оцениваемого списка является Lisp объектом функции,
  объектом байт-кода или объектом примитивной функции, то этот список
  является @dfn{вызовом функции}.  Например, здесь есть вызов функции
  @code{+}:

@example
(+ 1 x)
@end example

  Первый шаг в оценке вызова функции является оценка оставшихся элементов
  списка слева направо.  Результаты представляют собой фактические значения
  аргументов, одно значение для каждого элемента списка.  Следующий шаг
  заключается в вызове функции с этим списком аргументов, эффективно
  используя функцию @code{apply} (@pxref{Calling Functions}).  Если функция
  написана на Lisp, аргументы используются для связывания переменных
  аргументов функции (@pxref{Lambda Expressions}); затем формы в теле функции
  вычисляется по порядку, и значение последней формы тела становится
  значением вызова функции.(ВопросEval377)

@node Macro Forms
@subsection Lisp Macro Evaluation
@cindex macro call evaluation
@cindex forms, macro call

  If the first element of a list being evaluated is a macro object, then
the list is a @dfn{macro call}.  When a macro call is evaluated, the
elements of the rest of the list are @emph{not} initially evaluated.
Instead, these elements themselves are used as the arguments of the
macro.  The macro definition computes a replacement form, called the
@dfn{expansion} of the macro, to be evaluated in place of the original
form.  The expansion may be any sort of form: a self-evaluating
constant, a symbol, or a list.  If the expansion is itself a macro call,
this process of expansion repeats until some other sort of form results.

  Ordinary evaluation of a macro call finishes by evaluating the
expansion.  However, the macro expansion is not necessarily evaluated
right away, or at all, because other programs also expand macro calls,
and they may or may not evaluate the expansions.

  Normally, the argument expressions are not evaluated as part of
computing the macro expansion, but instead appear as part of the
expansion, so they are computed when the expansion is evaluated.

  For example, given a macro defined as follows:

@example
@group
(defmacro cadr (x)
  (list 'car (list 'cdr x)))
@end group
@end example

@noindent
an expression such as @code{(cadr (assq 'handler list))} is a macro
call, and its expansion is:

@example
(car (cdr (assq 'handler list)))
@end example

@noindent
Note that the argument @code{(assq 'handler list)} appears in the
expansion.

@xref{Macros}, for a complete description of Emacs Lisp macros.

@node Special Forms
@subsection Special Forms
@cindex special forms
@cindex forms, special
@cindex evaluation of special forms

  A @dfn{special form} is a primitive function specially marked so that
its arguments are not all evaluated.  Most special forms define control
structures or perform variable bindings---things which functions cannot
do.

  Each special form has its own rules for which arguments are evaluated
and which are used without evaluation.  Whether a particular argument is
evaluated may depend on the results of evaluating other arguments.

  If an expression's first symbol is that of a special form, the
expression should follow the rules of that special form; otherwise,
Emacs's behavior is not well-defined (though it will not crash).  For
example, @code{((lambda (x) x . 3) 4)} contains a subexpression that
begins with @code{lambda} but is not a well-formed @code{lambda}
expression, so Emacs may signal an error, or may return 3 or 4 or
@code{nil}, or may behave in other ways.

@defun special-form-p object
This predicate tests whether its argument is a special form, and
returns @code{t} if so, @code{nil} otherwise.
@end defun

  Here is a list, in alphabetical order, of all of the special forms in
Emacs Lisp with a reference to where each is described.

@table @code
@item and
@pxref{Combining Conditions}

@item catch
@pxref{Catch and Throw}

@item cond
@pxref{Conditionals}

@item condition-case
@pxref{Handling Errors}

@item defconst
@pxref{Defining Variables}

@item defvar
@pxref{Defining Variables}

@item function
@pxref{Anonymous Functions}

@item if
@pxref{Conditionals}

@item interactive
@pxref{Interactive Call}

@item lambda
@pxref{Lambda Expressions}

@item let
@itemx let*
@pxref{Local Variables}

@item or
@pxref{Combining Conditions}

@item prog1
@itemx prog2
@itemx progn
@pxref{Sequencing}

@item quote
@pxref{Quoting}

@item save-current-buffer
@pxref{Current Buffer}

@item save-excursion
@pxref{Excursions}

@item save-restriction
@pxref{Narrowing}

@item setq
@pxref{Setting Variables}

@item setq-default
@pxref{Creating Buffer-Local}

@item unwind-protect
@pxref{Nonlocal Exits}

@item while
@pxref{Iteration}
@end table

@cindex CL note---special forms compared
@quotation
@b{Common Lisp note:} Here are some comparisons of special forms in
GNU Emacs Lisp and Common Lisp.  @code{setq}, @code{if}, and
@code{catch} are special forms in both Emacs Lisp and Common Lisp.
@code{save-excursion} is a special form in Emacs Lisp, but
doesn't exist in Common Lisp.  @code{throw} is a special form in
Common Lisp (because it must be able to throw multiple values), but it
is a function in Emacs Lisp (which doesn't have multiple
values).
@end quotation

@node Autoloading
@subsection Autoloading

  The @dfn{autoload} feature allows you to call a function or macro
whose function definition has not yet been loaded into Emacs.  It
specifies which file contains the definition.  When an autoload object
appears as a symbol's function definition, calling that symbol as a
function automatically loads the specified file; then it calls the
real definition loaded from that file.  The way to arrange for an
autoload object to appear as a symbol's function definition is
described in @ref{Autoload}.

@node Quoting
@section Quoting
@cindex forms, quote

  The special form @code{quote} returns its single argument, as written,
without evaluating it.  This provides a way to include constant symbols
and lists, which are not self-evaluating objects, in a program.  (It is
not necessary to quote self-evaluating objects such as numbers, strings,
and vectors.)

@defspec quote object
This special form returns @var{object}, without evaluating it.
@end defspec

@cindex @samp{'} for quoting
@cindex quoting using apostrophe
@cindex apostrophe for quoting
Because @code{quote} is used so often in programs, Lisp provides a
convenient read syntax for it.  An apostrophe character (@samp{'})
followed by a Lisp object (in read syntax) expands to a list whose first
element is @code{quote}, and whose second element is the object.  Thus,
the read syntax @code{'x} is an abbreviation for @code{(quote x)}.

Here are some examples of expressions that use @code{quote}:

@example
@group
(quote (+ 1 2))
     @result{} (+ 1 2)
@end group
@group
(quote foo)
     @result{} foo
@end group
@group
'foo
     @result{} foo
@end group
@group
''foo
     @result{} (quote foo)
@end group
@group
'(quote foo)
     @result{} (quote foo)
@end group
@group
['foo]
     @result{} [(quote foo)]
@end group
@end example

  Other quoting constructs include @code{function} (@pxref{Anonymous
Functions}), which causes an anonymous lambda expression written in Lisp
to be compiled, and @samp{`} (@pxref{Backquote}), which is used to quote
only part of a list, while computing and substituting other parts.

@node Backquote
@section Backquote
@cindex backquote (list substitution)
@cindex ` (list substitution)
@findex `
@cindex forms, backquote

  @dfn{Backquote constructs} allow you to quote a list, but
selectively evaluate elements of that list.  In the simplest case, it
is identical to the special form @code{quote}
@iftex
@end iftex
@ifnottex
(described in the previous section; @pxref{Quoting}).
@end ifnottex
For example, these two forms yield identical results:

@example
@group
`(a list of (+ 2 3) elements)
     @result{} (a list of (+ 2 3) elements)
@end group
@group
'(a list of (+ 2 3) elements)
     @result{} (a list of (+ 2 3) elements)
@end group
@end example

@findex , @r{(with backquote)}
  The special marker @samp{,} inside of the argument to backquote
indicates a value that isn't constant.  The Emacs Lisp evaluator
evaluates the argument of @samp{,}, and puts the value in the list
structure:

@example
@group
`(a list of ,(+ 2 3) elements)
     @result{} (a list of 5 elements)
@end group
@end example

@noindent
Substitution with @samp{,} is allowed at deeper levels of the list
structure also.  For example:

@example
@group
`(1 2 (3 ,(+ 4 5)))
     @result{} (1 2 (3 9))
@end group
@end example

@findex ,@@ @r{(with backquote)}
@cindex splicing (with backquote)
  You can also @dfn{splice} an evaluated value into the resulting list,
using the special marker @samp{,@@}.  The elements of the spliced list
become elements at the same level as the other elements of the resulting
list.  The equivalent code without using @samp{`} is often unreadable.
Here are some examples:

@example
@group
(setq some-list '(2 3))
     @result{} (2 3)
@end group
@group
(cons 1 (append some-list '(4) some-list))
     @result{} (1 2 3 4 2 3)
@end group
@group
`(1 ,@@some-list 4 ,@@some-list)
     @result{} (1 2 3 4 2 3)
@end group

@group
(setq list '(hack foo bar))
     @result{} (hack foo bar)
@end group
@group
(cons 'use
  (cons 'the
    (cons 'words (append (cdr list) '(as elements)))))
     @result{} (use the words foo bar as elements)
@end group
@group
`(use the words ,@@(cdr list) as elements)
     @result{} (use the words foo bar as elements)
@end group
@end example


@node Eval
@section Eval

  Most often, forms are evaluated automatically, by virtue of their
occurrence in a program being run.  On rare occasions, you may need to
write code that evaluates a form that is computed at run time, such as
after reading a form from text being edited or getting one from a
property list.  On these occasions, use the @code{eval} function.
Often @code{eval} is not needed and something else should be used instead.
For example, to get the value of a variable, while @code{eval} works,
@code{symbol-value} is preferable; or rather than store expressions
in a property list that then need to go through @code{eval}, it is better to
store functions instead that are then passed to @code{funcall}.

  The functions and variables described in this section evaluate forms,
specify limits to the evaluation process, or record recently returned
values.  Loading a file also does evaluation (@pxref{Loading}).

  It is generally cleaner and more flexible to store a function in a
data structure, and call it with @code{funcall} or @code{apply}, than
to store an expression in the data structure and evaluate it.  Using
functions provides the ability to pass information to them as
arguments.

@defun eval form &optional lexical
This is the basic function for evaluating an expression.  It evaluates
@var{form} in the current environment, and returns the result.  The
type of the @var{form} object determines how it is evaluated.
@xref{Forms}.

The argument @var{lexical} specifies the scoping rule for local
variables (@pxref{Variable Scoping}).  If it is omitted or @code{nil},
that means to evaluate @var{form} using the default dynamic scoping
rule.  If it is @code{t}, that means to use the lexical scoping rule.
The value of @var{lexical} can also be a non-empty alist specifying a
particular @dfn{lexical environment} for lexical bindings; however,
this feature is only useful for specialized purposes, such as in Emacs
Lisp debuggers.  @xref{Lexical Binding}.

Since @code{eval} is a function, the argument expression that appears
in a call to @code{eval} is evaluated twice: once as preparation before
@code{eval} is called, and again by the @code{eval} function itself.
Here is an example:

@example
@group
(setq foo 'bar)
     @result{} bar
@end group
@group
(setq bar 'baz)
     @result{} baz
;; @r{Here @code{eval} receives argument @code{foo}}
(eval 'foo)
     @result{} bar
;; @r{Here @code{eval} receives argument @code{bar}, which is the value of @code{foo}}
(eval foo)
     @result{} baz
@end group
@end example

The number of currently active calls to @code{eval} is limited to
@code{max-lisp-eval-depth} (see below).
@end defun

@deffn Command eval-region start end &optional stream read-function
@anchor{Definition of eval-region}
This function evaluates the forms in the current buffer in the region
defined by the positions @var{start} and @var{end}.  It reads forms from
the region and calls @code{eval} on them until the end of the region is
reached, or until an error is signaled and not handled.

By default, @code{eval-region} does not produce any output.  However,
if @var{stream} is non-@code{nil}, any output produced by output
functions (@pxref{Output Functions}), as well as the values that
result from evaluating the expressions in the region are printed using
@var{stream}.  @xref{Output Streams}.

If @var{read-function} is non-@code{nil}, it should be a function,
which is used instead of @code{read} to read expressions one by one.
This function is called with one argument, the stream for reading
input.  You can also use the variable @code{load-read-function}
(@pxref{Definition of load-read-function,, How Programs Do Loading})
to specify this function, but it is more robust to use the
@var{read-function} argument.

@code{eval-region} does not move point.  It always returns @code{nil}.
@end deffn

@cindex evaluation of buffer contents
@deffn Command eval-buffer &optional buffer-or-name stream filename unibyte print
This is similar to @code{eval-region}, but the arguments provide
different optional features.  @code{eval-buffer} operates on the
entire accessible portion of buffer @var{buffer-or-name}
(@pxref{Narrowing,,, emacs, The GNU Emacs Manual}).
@var{buffer-or-name} can be a buffer, a buffer name (a string), or
@code{nil} (or omitted), which means to use the current buffer.
@var{stream} is used as in @code{eval-region}, unless @var{stream} is
@code{nil} and @var{print} non-@code{nil}.  In that case, values that
result from evaluating the expressions are still discarded, but the
output of the output functions is printed in the echo area.
@var{filename} is the file name to use for @code{load-history}
(@pxref{Unloading}), and defaults to @code{buffer-file-name}
(@pxref{Buffer File Name}).  If @var{unibyte} is non-@code{nil},
@code{read} converts strings to unibyte whenever possible.

@findex eval-current-buffer
@code{eval-current-buffer} is an alias for this command.
@end deffn

@defopt max-lisp-eval-depth
@anchor{Definition of max-lisp-eval-depth}
This variable defines the maximum depth allowed in calls to @code{eval},
@code{apply}, and @code{funcall} before an error is signaled (with error
message @code{"Lisp nesting exceeds max-lisp-eval-depth"}).

This limit, with the associated error when it is exceeded, is one way
Emacs Lisp avoids infinite recursion on an ill-defined function.  If
you increase the value of @code{max-lisp-eval-depth} too much, such
code can cause stack overflow instead.  On some systems, this overflow
can be handled.  In that case, normal Lisp evaluation is interrupted
and control is transferred back to the top level command loop
(@code{top-level}).  Note that there is no way to enter Emacs Lisp
debugger in this situation.  @xref{Error Debugging}.

@cindex Lisp nesting error

The depth limit counts internal uses of @code{eval}, @code{apply}, and
@code{funcall}, such as for calling the functions mentioned in Lisp
expressions, and recursive evaluation of function call arguments and
function body forms, as well as explicit calls in Lisp code.

The default value of this variable is 800.  If you set it to a value
less than 100, Lisp will reset it to 100 if the given value is
reached.  Entry to the Lisp debugger increases the value, if there is
little room left, to make sure the debugger itself has room to
execute.

@code{max-specpdl-size} provides another limit on nesting.
@xref{Definition of max-specpdl-size,, Local Variables}.
@end defopt

@defvar values
The value of this variable is a list of the values returned by all the
expressions that were read, evaluated, and printed from buffers
(including the minibuffer) by the standard Emacs commands which do
this.  (Note that this does @emph{not} include evaluation in
@file{*ielm*} buffers, nor evaluation using @kbd{C-j}, @kbd{C-x C-e},
and similar evaluation commands in @code{lisp-interaction-mode}.)  The
elements are ordered most recent first.

@example
@group
(setq x 1)
     @result{} 1
@end group
@group
(list 'A (1+ 2) auto-save-default)
     @result{} (A 3 t)
@end group
@group
values
     @result{} ((A 3 t) 1 @dots{})
@end group
@end example

This variable is useful for referring back to values of forms recently
evaluated.  It is generally a bad idea to print the value of
@code{values} itself, since this may be very long.  Instead, examine
particular elements, like this:

@example
@group
;; @r{Refer to the most recent evaluation result.}
(nth 0 values)
     @result{} (A 3 t)
@end group
@group
;; @r{That put a new element on,}
;;   @r{so all elements move back one.}
(nth 1 values)
     @result{} (A 3 t)
@end group
@group
;; @r{This gets the element that was next-to-most-recent}
;;   @r{before this example.}
(nth 3 values)
     @result{} 1
@end group
@end example
@end defvar
