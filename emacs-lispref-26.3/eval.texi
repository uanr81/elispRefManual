@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1994, 1998, 2001-2019 Free Software Foundation,
@c Inc.
@c See the file elisp.texi for copying conditions.
@node Evaluation
@chapter Оценка
@cindex evaluation
@cindex  interpreter
@cindex interpreter
@cindex value of expression

  @dfn{Оценка} выражений в Emacs Lisp выполняется программой
  @dfn{Интерпретатор Lisp}---a, который принимает Lisp объект
  в качестве входных данных и вычисляет его @dfn{значение как выражение}.
  Как это происходит, зависит от типа данных объекта, в соответствии с
  правилами, описанными в этой главе. Интерпретатор запускается
  автоматически для оценки частей вашей программы, но также может
  быть вызван явно с помощью примитивной функции Lisp @code{eval}.

@ifnottex
@menu
* Intro Eval::  Схема оценки.
* Forms::       Как оцениваются различные виды объектов.
* Quoting::     Чтобы Избежать Оценки (константы в программе).
* Backquote::   Более лёгкое построение структуры списка.
* Eval::        Как вызвать интерпретатор Lisp явно.
@end menu

@node Intro Eval
@section Введение в оценку

  Lisp интерпретатор или оценщик, является частью Emacs, которая
  вычисляет значение переданного ему выражения. Когда функция,
  написаная на Lisp вызывается, оценщик вычисляет значение функции
  путем оценки выражения в теле функции. Таким образом, запуск
  любой программы Lisp действительно означает запуск
  интерпретатора Lisp.
@end ifnottex

@cindex form
@cindex expression
@cindex S-expression
@cindex sexp
  Lisp объект предназначенный для оценки, называется @dfn{формой}
или @dfn{выражением}@footnote{Иногда также упоминается как
@dfn{S-выражение} или @dfn{sexp}, но мы вообще не используем
эту терминологию в данном руководстве.}.  Тот факт, что формы
являются объектами данных, а не просто текстом, является
одним из фундаментальных различий между Lisp-подобными
языками и типичными языками программирования. Любой объект
может быть оценен, но на практике в основном обрабатываются
только цифры, символы,списки и строки.

  В последующих разделах мы подробно опишем, что означает
  оценка для каждого вида формы.

  Очень часто, Lisp читает форму, а затем оценивает её, и
  чтение и оценка являются отдельными видами деятельности, и
  любой из них может быть выполнен в одиночку. Чтение
  само по себе ничего не оценивает; оно преобразует печатное
  представление объекта Lisp в сам объект. Вызывающий
  @code{read} объект должен указать, подлежит ли форма для
  оценки, или служит какой-то совершенно иной цели.
  @xref{Input Functions}.

@cindex recursive evaluation
  Оценка представляет собой рекурсивный процесс, и оценка формы часто
  включает в себя оценку частей внутри этой формы.  Например, при оценке
  формы @dfn{вызова функции}, такой как @code{(car x)}, Emacs сначала
  вычисляет аргумент (подчиненную форму @code{x}).  После оценки аргумента,
  Emacs @dfn{выполняет} функцию (@code{car}), и если функция написана на
  Lisp, выполнение происходит путем оценки @dfn{тела} функции (в данном
  примере, однако, @code{car} не является функция Lisp, это примитивная
  функция реализованная на C).  @xref{Functions}, для получения
  дополнительной информации о функциях и вызовах функций.

@cindex environment
  Оценка происходит в контексте,называемой @dfn{environment (средой)},
  которая состоит из текущих значений и привязки всех переменных Lisp
  (@pxref{Variables}).@footnote{Это определение ``environment (среда)''
  специально не включают в себя все данные, которые могут повлиять на
  результат программы.}  Всякий раз, когда форма обращается к переменной без
  создания нового связывания для неё, переменная принимает значение величины,
  заданное текущей средой.   Оценка формы также может временно изменить
  окружающую среду путем связывания переменных (@pxref{Local Variables}).

@cindex side effect
@anchor{Definition of side effect}
  Оценка формы также может внести изменения, которые сохраняются; эти
  изменения называются @dfn{побочными уффектами}.  Пример формы, которая
  производит побочный эффект @code{(setq foo 1)}.

  Не следует путать оценку с интерпретацией ключевой команды.  Командный
  цикл редактора переводит ввод с клавиатуры в команду (интерактивно
  вызываемую функцию) с использованием активных раскладок клавиш, а затем
  использует @code{call-interactively}, чтобы выполнить эту команду.
  Выполнение команды обычно включает в себя оценку, если команда написана на
  Lisp; однако этот шаг не считается частью интерпретации ключевой команды.
  @xref{Command Loop}.

@node Forms
@section Виды Форм

  Lisp объект, который предназначен для оценки называется @dfn{формой} (или
  @dfn{выражением}).  Как Emacs оценивает форму, зависит от её типа данных.
  Emacs имеет три различных вида формы, которые оцениваются по-разному:
  символы, списки и все остальные типы.  В этом разделе описаны все три вида,
  один за другим, начиная с остальных типов, которые представляют собой
  самооценочные формы.

@menu
* Self-Evaluating Forms::   Формы, которые оценивают себя.
* Symbol Forms::            Символы оцениваются как переменные.
* Classifying Lists::       Отличие различных списочных форм.
* Function Indirection::    При появлении символа как car списка, ищется
                            действительная функция через символ.
* Function Forms::          Формы, вызова функции.
* Macro Forms::             Формы, вызова макроса.
* Special Forms::           Специальные формы - своеобразные примитивы,
                            большинство из них являются крайне важными.
* Autoloading::             Функции, загружаемые из файлов, содержащих их
                            реальное определение.
@end menu

@node Self-Evaluating Forms
@subsection Самооценочные Формы
@cindex vector evaluation
@cindex literal evaluation
@cindex self-evaluating form
@cindex form, self-evaluating

  @dfn{Самооценочная форма} это любая форма, которая не является списком
  или символом.  Самооценочная форма оценивает себя сама: результат оценки
  тот же объект, который был оценен.  Таким образом, число 25 имеет значение
  25, а строка @code{"foo"} принимает значение строки @code{"foo"}.  Точно
  так же, оценка вектора не вызывает оценку элементов вектора---возвращается
  один и тот же вектор с его содержимым без изменений.

@example
@group
'123               ; @r{Число, показанное без оценки.}
     @result{} 123
@end group
@group
123                ; @r{Оценка числа как обычно---результат тот же.}
     @result{} 123
@end group
@group
(eval '123)        ; @r{Оценка @code{вручную}---результат тот же.}
     @result{} 123
@end group
@group
(eval (eval '123)) ; @r{Двойная оценка ничего не меняет.}
     @result{} 123
@end group
@end example

  Часто пользуются при записи чисел, символов, строк и даже векторов в
  Lisp коде тем, что они самооцениваются.  Тем не менее, это довольно
  необычно для типов, которые не имеют синтаксис чтения, потому что нет
  никакого способа, написать их текстуально.  Можно создать Lisp выражения,
  содержащие эти типы с помощью программы Lisp. Вот пример:

@example
@group
;; @r{Построить выражение, содержащее объект буфера.}
(setq print-exp (list 'print (current-buffer)))
     @result{} (print #<buffer eval.texi>)
@end group
@group
;; @r{Оценить его.}
(eval print-exp)
     @print{} #<buffer eval.texi>
     @result{} #<buffer eval.texi>
@end group
@end example

@node Symbol Forms
@subsection Символьные Формы
@cindex symbol evaluation
@cindex symbol forms
@cindex forms, symbol

  Когда символ оценивается, он рассматривается в качестве переменной.
  Результатом является значение переменной, если оно есть.  Если символ не
  имеет значения в качестве переменной, интерпретатор Lisp сигнализирует об
  ошибке.  Для получения дополнительной информации об использовании
  переменных смотреть @ref{Variables}.

  В следующем примере устанавливается значение символу @code{a}, используя
  @code{setq}.  Затем оценивается символ, и @code{setq} возвращает
  сохраненное значение.

@example
@group
(setq a 123)
     @result{} 123
@end group
@group
(eval 'a)
     @result{} 123
@end group
@group
a
     @result{} 123
@end group
@end example

  Символы @code{nil} и @code{t} обрабатывают специально, так что значение
  @code{nil} всегда @code{nil}, а значение @code{t} всегда @code{t}; вы не
  можете установить или связать их с любыми другими значениями.  Таким
  образом, эти два символа действуют как самооценочные формы, даже если
  @code{eval} обрабатывает их, как и любой другой символ.  Символ, имя
  которого начинается с @samp{:} также являются самооценочными; так же, его
  значение обычно не может быть изменено.  @xref{Constant Variables}.

@node Classifying Lists
@subsection Классификация Списочных Форм
@cindex list form evaluation
@cindex forms, list

  Форма, которая является непустым списком является либо вызовом функции,
  либо вызовом макроса, либо специальной формой в зависимости от первого
  элемента списочной формы.  Эти три вида форм оценивается по-разному,
  описано ниже.  Остальные элементы списка представляют собой @dfn{аргументы}
  для функции, макроса или специальной формы.

  Первый шаг в оценке непустого списка состоит в изучении его первого
  элемента.  Только по этому элементу определяется к какой форме принадлежит
  списочная форма и каким образом будет обработана её остальная часть списка.
  Первый элемент @emph{не} оценивается, как в некоторых Lisp диалектах,
  таких как Scheme.

@node Function Indirection
@subsection Косвенная Функция Символа
@cindex symbol function indirection
@cindex indirection for functions
@cindex void function

  Если первый элемент списка является символ, то оценщик проверяет компоненту
  символа, ячейку функции и использует её содержимое вместо исходного
  символа.  Если содержимое представляет собой другой символ, запускается
  рекурсивный процесс обрабатывающий @dfn{косвенную функцию символа},
  повторяется до тех пор, пока в результате не получится не-символ.
  @xref{Function Names}, для получения дополнительной информации о
  косвенной функции символа. (ВопросEval247)

  Одним из возможных последствий этого процесса является бесконечный цикл,
  в том случае, когда значение компоненты символа ячейки функции ссылается на
  один и тот же символ.  В противном случае, в конечном итоге получается
  не-символ, который должен быть функцией или другим подходящим объектом.

@kindex invalid-function
  Точнее, в конце концов должна быть: функция Lisp (лямбда-выражение),
  байт-скомпилированная функция, примитивная функция, макрос Lisp,
  специальная форма или объект автозагрузки.  Каждый из этих типов описан
  в одном из следующих разделов.  Если объект не является одним из этих
  типов, то Emacs сигнализирует об ошибке @code{invalid-function}.

  Следующий пример иллюстрирует процесс косвенного обращения к символу.  Мы
  используем @code{fset}, чтобы установить значение компоненты символа ячейки
  функции и @code{symbol-function}, чтобы получить такое значение
  (@pxref{Function Cells}).  В частности, мы сохраняем символ @code{car}
  значением компоненты ячейки функции символа @code{first}, а символ
  @code{first} - значением компоненты ячейки функции символа @code{erste}.

@example
@group
;; @r{Построение связи компоненты символа ячейки функции:}
;;   -------------       -----        -------        -------
;;  | #<subr car> | <-- | car |  <-- | first |  <-- | erste |
;;   -------------       -----        -------        -------
@end group
@group
(symbol-function 'car)
     @result{} #<subr car>
@end group
@group
(fset 'first 'car)
     @result{} car
@end group
@group
(fset 'erste 'first)
     @result{} first
@end group
@group
(erste '(1 2 3))   ; @r{Вызов функции, на которую ссылается @code{erste}.}
     @result{} 1
@end group
@end example

  В отличии от этого, в следующем примере вызывается функция без какой-либо
  косвенной символьной функции, потому что первый элемент является
  анонимной функцией Lisp, а не символом.

@example
@group
((lambda (arg) (erste arg))
 '(1 2 3))
     @result{} 1
@end group
@end example

@noindent
Выполнение самой функции оценивает её тело; это включает косвенное обращение
к функции установленной значением компоненты ячейки функции символа
@code{erste}.

  Эта форма редко используется и в настоящее время не рекомендуется.
  Вместо этого используется форма:

@example
@group
(funcall (lambda (arg) (erste arg))
         '(1 2 3))
@end group
@end example
или ещё проще
@example
@group
(let ((arg '(1 2 3))) (erste arg))
@end group
@end example

  Встроенная функция @code{indirect-function} обеспечивает простой способ
  для явного обращения к косвенной функции символа.

@c Emacs 19 feature
@defun indirect-function function &optional noerror
@anchor{Definition of indirect-function}
Функция возвращает значение @var{function} как функции.  Если @var{function}
является символом, то снова ищется @var{function} определение функции с
этим значением.  Если @var{function} не символ, то он возвращается сама
@var{function} функция.

Эта функция возвращает @code{nil} если конечный символ несвязанн.
Сигнализируется об ошибке @code{cyclic-function-indirection} если есть
петля в цепочке символов.

Необязательный аргумент @var{noerror} устарел, сохранён для обратной
совместимости, и не имеет никакого эффекта.

Вот как можно определить @code{indirect-function} в Lisp:

@example
(defun indirect-function (function)
  (if (symbolp function)
      (indirect-function (symbol-function function))
    function))
@end example
@end defun

@node Function Forms
@subsection Оценка Функциональных Форм
@cindex function form evaluation
@cindex function call
@cindex forms, function call

  Если первый элемент оцениваемого списка является Lisp объектом функции,
  объектом байт-кода или объектом примитивной функции, то этот список
  является @dfn{вызовом функции}.  Например, здесь есть вызов функции
  @code{+}:

@example
(+ 1 x)
@end example

  Первый шаг в оценке вызова функции является оценка оставшихся элементов
  списка слева направо.  Результаты представляют собой фактические значения
  аргументов, одно значение для каждого элемента списка.  Следующий шаг
  заключается в вызове функции с этим списком аргументов, эффективно
  используя функцию @code{apply} (@pxref{Calling Functions}).  Если функция
  написана на Lisp, аргументы используются для связывания переменных
  аргументов функции (@pxref{Lambda Expressions}); затем формы в теле функции
  вычисляется по порядку, и значение последней формы тела становится
  значением вызова функции.(ВопросEval377)

@node Macro Forms
@subsection Оценка Макросов Lisp
@cindex macro call evaluation
@cindex forms, macro call

  Если первый элемент оцениваемого спика является объект макрос, то список
  является @dfn{вызовом макроса}.  Когда макрос оценивается, оставшиеся
  элементы списка остаются @emph{не} оценёнными первоначально.  Вместо этого,
  сами по себе эти элементы используются в качестве аргументов макроса.
  Определение макроса вычисляет собранную таким образом новую форму,
  называемую @dfn{расширением} макроса, которая оценевается вместо
  оригинальной формы.  Расширение может иметь любую форму: самооценочной
  константой, символом, или списком.  Если расширение само по себе является
  вызовом макроса, этот процесс расширения повторяется до тех пор, пока не
  будет получена в результате другого рода форма.

  Обычная оценка макроса завершается путем оценки расширения.  Однако
  расширение макроса не обязательно оценивается сразу, или не оценивается
  вообще, потому что другие программы также расширяют вызовы макроса и могут
  не оценивать это расширение.

  Как правило, выражение аргумента не оценивается как часть вычисления
  расширения макроса, вместо этого буквально появляется в выражении для
  расширения, таким образом, они вычисляются тогда, когда расширение
  оцениваются.

  Например, если макрос определяется следующим образом:

@example
@group
(defmacro cadr (x)
  (list 'car (list 'cdr x)))
@end group
@end example

@noindent
выражение, такое как @code{(cadr (assq 'обработчик list))} является вызовом
макроса и вот его выражение для оценки после расширения:

@example
(car (cdr (assq 'обработчик list)))
@end example

@noindent
Обратите внимание, как аргумент @code{(assq 'обработчик list)} появляется
в выражении расширения.

@xref{Macros}, для полного описания макросов Emacs Lisp.

@node Special Forms
@subsection Специальная Форма
@cindex special forms
@cindex forms, special
@cindex evaluation of special forms

  @dfn{Специальная формы} - примитивная функция, специально отмечена особым
  образом и её аргументы не все оцениваются.  Большинство специальных форм
  определяют управляющие структуры или выполняют привязку переменных --- то,
  что функции не могут делать.

  Каждая специальная форма имеет свои собственные правила, по которым
  оценеваются её аргументы и которые используются без оценки.  Оценка того
  или иного аргумента может зависеть от результатов оценки других аргументов.

  Если первый символ выражения представляет собой символ особой формы,
  выражение должно следовать правилам оценки этой особой формы; в противном
  случае поведение Emacs является не вполне определенным (хотя сбой не
  произойдёт).  Например, форма @code{((lambda (x) x . 3) 4)} содержит
  подвыражение, которое начинается с @code{lambda}, но не является правильно
  сформированным выражением @code{lambda}, поэтому Emacs может
  сигнализировать об ошибке, или может вернуть 3 или 4 или @code{nil}, или
  может вести себя по-другому.

@defun special-form-p object
Предикат проверяет является ли его аргумент особой формой, и возвращает
@code{t} если это так и @code{nil} в другом случае.
@end defun

  Вот список в алфавитном порядке, из всех специальных форм в Emacs Lisp
  со ссылкой, где описывается каждая форма.

@table @code
@item and
@pxref{Combining Conditions}

@item catch
@pxref{Catch and Throw}

@item cond
@pxref{Conditionals}

@item condition-case
@pxref{Handling Errors}

@item defconst
@pxref{Defining Variables}

@item defvar
@pxref{Defining Variables}

@item function
@pxref{Anonymous Functions}

@item if
@pxref{Conditionals}

@item interactive
@pxref{Interactive Call}

@item lambda
@pxref{Lambda Expressions}

@item let
@itemx let*
@pxref{Local Variables}

@item or
@pxref{Combining Conditions}

@item prog1
@itemx prog2
@itemx progn
@pxref{Sequencing}

@item quote
@pxref{Quoting}

@item save-current-buffer
@pxref{Current Buffer}

@item save-excursion
@pxref{Excursions}

@item save-restriction
@pxref{Narrowing}

@item setq
@pxref{Setting Variables}

@item setq-default
@pxref{Creating Buffer-Local}

@item unwind-protect
@pxref{Nonlocal Exits}

@item while
@pxref{Iteration}
@end table

@cindex CL note---special forms compared
@quotation
@b{Common Lisp примечание:} Вот некоторые сравнения специальных форм в GNU
Emacs Lisp и Common Lisp.  @code{setq}, @code{if}, и @code{catch}
специальные формы в обоих Emacs Lisp и Common Lisp.  @code{save-excursion}
является особой формой в Emacs Lisp, но не существует в Common Lisp.
@code{throw} является особой формой в Common Lisp (потому что он должен быть
в состоянии генерировать несколько значений), но это функция в Emacs Lisp
(который не имеет несколько значений).
@end quotation

@node Autoloading
@subsection Автозагрузка

  @dfn{Автозагрузка} функции позволяет вызывать функцию или макрос,
  определение которых еще не были загружены в Emacs.  Указывается какой файл
  содержит определение.  Когда объект автозагрузка содержиться в компоненте
  ячейки функции символа, вызов символа как функции автоматически загружает
  указанный файл и затем вызывается реальное определение, загруженное из
  этого файла.  Способ организовать отображение объекта автозагрузки, чтобы
  выглядел как определение функции символа, описан в @ref{Autoload}.

@node Quoting
@section Квотирование
@cindex forms, quote

  Специальная форма @code{quote} возвращает свой единственный аргумент,
  в его печатном представлении, так как он написан, не оценивая его.  Это
  дает возможность включать в коде такие символы и списки, которые не
  должны рассматриваться как самооценочные объекты при выполнения кода
  программы.  (Необязательно цитировать самооценочные объекты, такие как
  числа, строки и векторы.)

@defspec quote object
Специальная форма возвращает @var{object}, без его оценки.
@end defspec

@cindex @samp{'} for quoting
@cindex quoting using apostrophe
@cindex apostrophe for quoting
Поскольку @code{quote} используется крайне часто в программах, Lisp
предоставляет удобный синтаксис для чтения для него.  Апостроф (@samp{'}) с
последующим объектом Lisp (в синтаксисе для чтения) расширяется до списка,
первый элемент которого функция @code{quote}, а второй элемент сам объект.
Таким образом, чтение синтаксиса @code{'x} это аббревиатура для
@code{(quote x)}.

Вот некоторые примеры выражений, которые используют @code{quote}:

@example
@group
(quote (+ 1 2))
     @result{} (+ 1 2)
@end group
@group
(quote foo)
     @result{} foo
@end group
@group
'foo
     @result{} foo
@end group
@group
''foo
     @result{} (quote foo)
@end group
@group
'(quote foo)
     @result{} (quote foo)
@end group
@group
['foo]
     @result{} [(quote foo)]
@end group
@end example

  К другим конструкциям квотирования относятся @code{function}
  (@pxref{Anonymous Functions}), которая вызывают компиляцию анонимного
  лямбда-выражения, написанного на Lisp и @samp{`} (@pxref{Backquote}),
  которая используется для квотирования текстуально опредлённых частей
  списочной формы при вычислении и замене других частей.(ВопросEval608)

@node Backquote
@section Обратная Кавычка
@cindex backquote (list substitution)
@cindex ` (list substitution)
@findex `
@cindex forms, backquote

  @dfn{Конструкция обратной кавычки} позволяет квотировать списочную форму,
  но выборочно оценивать элементы этого списка.  В простейшем случае
  конструкция идентична специальной форме @code{quote}
@iftex
@end iftex
@ifnottex
(описано в предыдущем разделе; @pxref{Quoting}).
@end ifnottex
Например, эти две формы дают одинаковые результаты:

@example
@group
`(список состоит из (+ 2 3) элементов)
     @result{} (список состоит из
	(+ 2 3)
	элементов)
@end group
@group
'(список состоит из (+ 2 3) элементов)
     @result{} (список состоит из
	(+ 2 3)
	элементов)
@end group
@end example

@findex , @r{(with backquote)}
  Специальный маркер @samp{,} внутри аргумента обратной кавычки указывает на
  значение, которое не является константным.  Emacs Lisp оценщик оценивает
  форму, которая следует сразу после @samp{,} в аргументе обратной кавычки и
  помещает полученное значение вместо оценённой формы в списочную структуру:

@example
@group
`(список состоит из ,(+ 2 3) элементов)
     @result{} (список состоит из 5 элементов)
@end group
@end example

@noindent
Замещение @samp{,} допускается также и на более глубоких уровнях списочной
структуры.  Например:

@example
@group
`(1 2 (3 ,(+ 4 5)))
     @result{} (1 2 (3 9))
@end group
@end example

@findex ,@@ @r{(with backquote)}
@cindex splicing (with backquote)
  Вы также можете @dfn{вставить} оцененное значение в результирующую
  списочную форму, с помощью специального маркера @samp{,@@}.  Элементы
  сращенной списочной формы становятся того же уровня вложенности, что и
  другие элементы полученной списочной формы.  Эквивалентный код без
  использования @samp{`} часто получается нечитаем.  Вот некоторые примеры:

@example
@group
(setq some-list '(2 3))
     @result{} (2 3)
@end group
@group
(cons 1 (append some-list '(4) some-list))
     @result{} (1 2 3 4 2 3)
@end group
@group
`(1 ,@@some-list 4 ,@@some-list)
     @result{} (1 2 3 4 2 3)
@end group

@group
(setq list '(hack foo bar))
     @result{} (hack foo bar)
@end group
@group
(cons 'здесь
  (cons 'используются
    (cons 'слова (append (cdr list) '(в качестве элементов)))))
     @result{} (здесь используются слова foo bar в качестве элементов)
@end group
@group
`(здесь используются слова ,@@(cdr list) в качестве элементов)
     @result{} (здесь используются слова foo bar в качестве элементов)
@end group
@end example


@node Eval
@section Оценка

  Чаще всего, формы вычисляются автоматически, в силу их появления в
  запущенной программе.  В редких случаях может возникнуть необходимость
  написания кода, который оценивает форму, которая создаётся во время
  выполнения, например, после чтения формы из редактируемого текста или
  получения формы из списка свойств.  В таких случаях используется функция
  @code{eval}.  В основном используется что-то другое вместо @code{eval}.
  Например, чтобы получить значение переменной, предпочтительнее использовать
  @code{symbol-value} вместо @code{eval} или если значения хранится в списке
  свойств, лучше получать значения свойств, используя написанную специально
  для этого действия функцию, вызывая её в @code{funcall} с этим списком
  свойств в качестве аргумента а не получать эти значения через @code{eval}.

  Функции и переменные, описанные в этом разделе, оценивают формы, указывают
  ограничения при процессе оценки или записывают недавно возвращённые
  значения.  При загрузки файла также производится оценка (@pxref{Loading}).
  
  Как правило, более чище и более гибче, иметь функцию для работы с хранимой
  структурой данных, вызывать её с @code{funcall} или @code{apply} для
  обработки этой структуры, чем непосредственно оценивать эту структуру.
  Использование таким образом функции, реализуется путём передачи самой
  структуры в качестве аргумента функции.

@defun eval form &optional lexical
Основная функция для вычисления выражения.  Оценивает @var{form} в текущей
определённой окружающей среде, и возвращает результат.  Тип объекта
@var{form} определяет, каким образом оно вычисляется.
@xref{Forms}.

Аргумент @var{lexical} определяет правила видимости для локальных переменных
(@pxref{Variable Scoping}).  Если опущен или @code{nil}, то форма @var{form}
оценивается по правилам динамического связывания области по умолчанию.  Если
аргумент установлен в @code{t}, это значит использовать правила лексической
области видимости.  Значение @var{lexical} также может быть установленно в
непустой ALIST, указывающий конкретную @dfn{лексическую среду} для
лексического связывания; однако, эта возможность полезна только для
специальных целей, например, в Emacs Lisp отладчиках.
@xref{Lexical Binding}.

Поскольку @code{eval} - это функция, оценивающая также выражение аргумента,
который передаётся в вызове @code{eval}, она вычисляется дважды: один раз
как подготовка перед вызовом @code{eval} и снова самой функцией @code{eval}.
Вот пример:

@example
@group
(setq foo 'bar)
     @result{} bar
@end group
@group
(setq bar 'baz)
     @result{} baz
;; @r{Здесь @code{eval} получает квотируемый аргумент @code{foo}}
(eval 'foo)
     @result{} bar
;; @r{Здесь @code{eval} получает аргумент @code{foo}, который оценивается в
значение @code{bar}} 
(eval foo)
     @result{} baz
@end group
@end example

Количество активных в данный момент вызовов в @code{eval} ограничивается
@code{max-lisp-eval-depth} (смотреть ниже).
@end defun

@deffn Command eval-region start end &optional stream read-function
@anchor{Definition of eval-region}
Функция оценивает форму в текущем буфере, в области, определяемой позицией
начала @var{start} и позицией конца @var{end} области.  Считываются все формы
из региона.  Для каждой вызывается @code{eval}, пока не будет достигнут конец
указанного региона или пока не произойдёт ошибка, которая не будет
обработана.

По умолчанию @code{eval-region} не производит никакокого вывода.  Однако,
если @var{stream} установлен в не-@code{nil}, любой вывод, производимый
функциями вывода (@pxref{Output Functions}), а также значения, которые
являются результатом оценки выражений в выбранной области выводятся в
указанный поток @var{stream}.  @xref{Output Streams}.

Если аргумент функция чтения @var{read-function} установлен в не-@code{nil},
это должна быть функция, которая используется вместо @code{read} для чтения
выражений одиного за другим.  Эта функция вызывается с одним аргументом,
потоком для чтения ввода.  Также можно использовать переменную
@code{load-read-function}
(@pxref{Definition of load-read-function,, How Programs Do Loading}), чтобы
указать эту функцию, но более надежно использовать в аргументе функцию
чтения @var{read-function}.

@code{eval-region} не перемещает и всегда возвращает @code{nil}.
@end deffn

@cindex evaluation of buffer contents
@deffn Command eval-buffer &optional buffer-or-name stream filename unibyte print
Похожа на @code{eval-region}, но аргументами предоставляется различный
дополнительный функционал.  @code{eval-buffer} действует на всей доступной
части буфера @var{buffer-or-name}
(@pxref{Narrowing,,, emacs, The GNU Emacs Manual}).
@var{buffer-or-name} может быть буфером, именем буфера (строкой), или
@code{nil} (быть опущен), что означает использовать текущий буфер.
@var{stream} используется как и в @code{eval-region}, если @var{stream}
установлен в не-@code{nil} и @var{print} установлен в не-@code{nil}.  В этом
случае, значения, полученные в результате оценки выражений все ещё
отбрасываются, но вывод функций вывода печатаются в области эха.
@var{filename} это имя файла для @code{load-history} (@pxref{Unloading}), и
по умолчанию это @code{buffer-file-name} (@pxref{Buffer File Name}).  Если
@var{unibyte} не-@code{nil}, @code{read} преобразует строки в однобайтные
всякий раз, когда это возможно.

@findex eval-current-buffer
@code{eval-current-buffer} это псевдоним для этой команды.
@end deffn

@defopt max-lisp-eval-depth
@anchor{Definition of max-lisp-eval-depth}
Эта переменная определяет максимальную глубину разрешенных вызовов
@code{eval}, @code{apply}, и @code{funcall}, превышение значение которой,
способствует сигналу об ошибке (с сообщением об ошибке
@code{"Lisp nesting exceeds max-lisp-eval-depth"}).

Этот предел и связанная с ним ошибка при его превышении - это один из
способов, избежать Emacs Lisp, зацикливание на плохо определенной функции.
Если сильно увеличить значение @code{max-lisp-eval-depth}, такой код может
вызвать переполнение стека.  В некоторых системах, это переполнение может
быть обработано.  В этом случае нормальная оценка Lisp прерывается и
управление передается обратно в (@code{top-level}) цикл верхнего уровня.
Обратите внимание, что нет никакого способа, чтобы запустить Emacs Lisp
отладчик в этой ситуации.  @xref{Error Debugging}.

@cindex Lisp nesting error

Предел глубины подсчитывает внутренние использования @code{eval},
@code{apply}, и @code{funcall}, например, для вызова функций, упомянутых в
Lisp выражениях, рекурсивные оценки аргументов вызова функции и формы
функции тела, а также явные вызовы в коде Lisp.

Значение по умолчанию для этой переменной равно 800.  Если вы установите его
на значение меньше 100, Lisp исправит его до 100, если будет достигнуто
заданное максимальное значение.  Вход в Lisp отладчик увеличивает при
необходимости это значение, если у самого отладчика существует место для
выполнения.

@code{max-specpdl-size} предоставляет ещё один предел вложенности.
@xref{Definition of max-specpdl-size,, Local Variables}.
@end defopt

@defvar values
Значение этого переменный представляет собой список значений, возвращаемых
всеми выражениями, которые были прочитаны, оценены, и введены из буферов
(в том числе минибуфера) с помощью стандартных команд Emacs, которые делают
это.  (Обратите внимание, что это @emph{не} включает оценку в @file{*ielm*}
буфере: не производит оценки, используя @kbd{C-j}, @kbd{C-x C-e} и подобные
в @code{lisp-interaction-mode} команды оценки.).  Элементы упорядочиваются
в хронологическом порядке.

@example
@group
(setq x 1)
     @result{} 1
@end group
@group
(list 'A (1+ 2) auto-save-default)
     @result{} (A 3 t)
@end group
@group
values
     @result{} ((A 3 t) 1 @dots{})
@end group
@end example

Эта переменная полезна для ссылок к значениям недавно оценённых форм.  Как
правило, плохая идея, вывести значение самого @code{values}, так как это
может быть очень длинным.  Вместо этого, лучше изучить отдельные элементы,
например так:

@example
@group
;; @r{Обращение к самому недавнему результату оценки.}
(nth 0 values)
     @result{} (A 3 t)
@end group
@group
;; @r{Предоставит результат предыдущей оценки примера, }
;;   @r{все элементы перемещаются назад на один, при каждой оценки.}
(nth 1 values)
     @result{} (A 3 t)
@end group
@group
;; @r{Это получает элемент, который был следующий перед самым новым}
;;   @r{до оценки этого примера.}
(nth 3 values)
     @result{} 1
@end group
@end example
@end defvar
