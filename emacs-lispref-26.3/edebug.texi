@comment -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1992-1994, 1998-1999, 2001-2019 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.

@c This file can also be used by an independent Edebug User
@c Manual in which case the Edebug node below should be used
@c with the following links to the Bugs section and to the top level:

@c , Bugs and Todo List, Top, Top

@node Edebug
@section Отладчик Edebug
@cindex Edebug debugging facility

  Edebug - это отладчик исходного кода для программ Emacs Lisp, с помощью
которого можно:

@itemize @bullet
@item
Пошагово выполнять оценку, останавливаясь до и после каждого выражения.

@item
Установить условные или безусловные точки останова.

@item
Остановить, когда указанное условие истинно (глобальное событие прерывания).

@item
Отслеживать медленно или быстро, ненадолго останавливаясь в каждой точке
остановки или в каждой точке останова.

@item
Отображать результаты выражений и оценивать выражения, как если бы они были
вне Edebug.

@item
Автоматически переоценивать список выражений и отображать их результаты
каждый раз, когда Edebug обновляет отображение.

@item
Вывод информации трассировки для вызовов и возвратов функций.

@item
Остановка при возникновении ошибки.

@item
Отобразить обратную трассировку, опуская собственные кадры Edebug.

@item
Указать оценку аргументов для макросов и определяющих форм.

@item
Получить элементарное тестирование покрытия и подсчет частоты.
@end itemize

Первые три раздела ниже должны рассказать достаточно об Edebug, чтобы начать
его использовать.

@menu
* Using Edebug::                Введение в использование Edebug.
* Instrumenting::               Потребуется инструментировать код, чтобы
отлаживать его с помощью Edebug.
* Modes:  Edebug Execution Modes. Режимы выполнения, остановка более-менее
часто.
* Jumping::                     Команды для перехода в указанное место.
* Misc: Edebug Misc.            Разные команды.
* Breaks::                      Установка точек останова для остановки программы.
* Trapping Errors::             Перехват ошибок с помощью Edebug.
* Views: Edebug Views.          Виды внутри и снаружи Edebug.
* Eval: Edebug Eval.            Оценка выражений в Edebug.
* Eval List::                   Выражения, значения которых отображаются
                                 каждый раз при входе в Edebug.
* Printing in Edebug::          Настройка вывода.
* Trace Buffer::                Как произвести вывод трассировки в буфер.
* Coverage Testing::            Как протестировать оценочное покрытие.
* The Outside Context::         Данные, которые Edebug сохраняет и
                                 восстанавливает.
* Edebug and Macros::           Определение того, как обрабатывать вызовы
                                 макросов.
* Options: Edebug Options.      Переменные параметров для настройки Edebug.
@end menu

@node Using Edebug
@subsection Использование Edebug

  Чтобы отлаживать программу на Lisp с помощью Edebug, потребуется сначала
@dfn{инструментировать} код Lisp, который нужно отлаживать.  Простой способ
сделать это - сначала переместить точку в определение функции или макроса,
а затем выполнить @kbd{C-u C-M-x} (@code{eval-defun} с префиксным
аргументом).  Смотреть @ref{Instrumenting}, для альтернативных способов
инструментирования кода.

  После инструментирования функции любой вызов функции активирует Edebug.
В зависимости от того, какой режим выполнения Edebug выбран, активация
Edebug может остановить выполнение и позволить перейти к выполнению функции
или может обновить отображение и продолжить выполнение при проверке команд
отладки.  Режим выполнения по умолчанию - шаг, который останавливает
выполнение.  @xref{Edebug Execution Modes}.

  В Edebug обычно просматривается буфер Emacs, показывающий исходный код
Lisp, который отлаживается.  Он называется @dfn{буфер исходного када} и
он временно доступен только для чтения.

  Стрелка в левой части указывает строку, в которой выполняется функция.
Изначально точка показывает, где внутри строки выполняется функция, но это
перестает быть истинным, если перемещена точка самостоятельно.

  Если инструментируется определение @code{fac} (показано ниже), а затем
выполняется @code{(fac 3)}, вот что обычно увидите.  Точка стоит в скобках
перед @code{if}.

@example
(defun fac (n)
=>@point{}(if (< 0 n)
      (* n (fac (1- n)))
    1))
@end example

@cindex stop points
Места внутри функции, где Edebug может остановить выполнение, называются
@dfn{точками останова}.  Они могут быть как до, так и после каждого
подвыражения, представляющего собой список, а также после каждой ссылки на
переменную.  Здесь используются точки для отображения точек останова в
функции @code{fac}:

@example
(defun fac (n)
  .(if .(< 0 n.).
      .(* n. .(fac .(1- n.).).).
    1).)
@end example

Специальные команды Edebug доступны в буфере исходного кода в дополнение к
командам режима Emacs Lisp.  Например, можно ввести команду Edebug @key{SPC}
для выполнения до следующей точки остановки.  Если наберается @key{SPC} один
раз после входа в @code{fac}, экран примет такой вид:

@example
(defun fac (n)
=>(if @point{}(< 0 n)
      (* n (fac (1- n)))
    1))
@end example

Когда Edebug останавливает выполнение после выражения, он отображает
значение выражения в эхо-области.

Другие часто используемые команды: @kbd{b} для установки точки останова в
точке останова, @kbd{g} для выполнения до достижения точки останова и
@kbd{q} для выхода из Edebug и возврата в командный цикл верхнего уровня.
Введите @kbd{?}, чтобы отобразить список всех команд Edebug.

@node Instrumenting
@subsection Инструментирование для Edebug
@cindex instrumenting for Edebug

  Чтобы использовать Edebug для отладки кода Lisp, потребуется сначала
инструментировать код.  Инструментирование кода вставляет в него
дополнительный код для вызова Edebug в нужных местах.

@kindex C-M-x
@findex eval-defun @r{(Edebug)}
  Когда вызывается команда @kbd{C-M-x} (@code{eval-defun}) с префиксным
аргументом в тексте определении функции, это инструментирует определение
перед оценкой его формч.  (Это не изменяет сам исходный код.).  Если
переменная @code{edebug-all-defs} - не-@code{nil}, это меняет значение
префиксного аргумента: в этом случае @kbd{C-M-x} определяет префиксный
аргумент @emph{unless}.  Значение @code{edebug-all-defs} по умолчанию -
@code{nil}.  Команда @kbd{M-x edebug-all-defs} переключает значение
переменной @code{edebug-all-defs}.

@findex eval-region @r{(Edebug)}
@findex eval-buffer @r{(Edebug)}
@findex eval-current-buffer @r{(Edebug)}
  Если @code{edebug-all-defs} равен не-@code{nil}, то команды
@code{eval-region}, @code{eval-current-buffer}, и @code{eval-buffer} также
обрабатывают любые определения, которые они оценивают.  Точно так же
@code{edebug-all-forms} контролирует, должен ли @code{eval-region}
использовать @emph{любую} форму , даже не определяющую.  Это не относится к
загрузке или оценке в минибуфере.  Команда @kbd{M-x edebug-all-forms}
переключает эту опцию.

@findex edebug-eval-top-level-form
@findex edebug-defun
  Другая команда, @kbd{M-x edebug-eval-top-level-form}, доступна для
инструментирования любой формы верхнего уровня независимо от значений
@code{edebug-all-defs} и @code{edebug-all-forms}.  @code{edebug-defun} - это
псевдоним @code{edebug-eval-top-level-form}.

  Пока Edebug активен, команда @kbd{I} (@code{edebug-instrument-callee})
инструментирует определение функции или макроса, вызываемых формой списка
после точки, если это еще не инструментировано.  Это возможно только в том
случае, если Edebug знает, где найти источник этой функции; по этой причине,
после загрузки Edebug, @code{eval-region} записывает позицию каждого
определения, которое он оценивает, даже если он не инструментировал его.
Смотреть также команду @kbd{i} (@pxref{Jumping}), которая переходит в вызов
после инструментирования функции.

  Edebug знает, как инструментировать все стандартные специальные формы,
формы @code{interactive} с аргументом выражением, анонимные лямбда-выражения
и другие определяющие формы.  Однако Edebug не может самостоятельно
определить, что пользовательский макрос будет делать с аргументами вызова
макроса, поэтому потребуется предоставить эту информацию, используя
спецификации Edebug; подробнее @pxref{Edebug and Macros}.

  Когда Edebug собирается инструментировать код в первый раз в сеансе, он
запускает ловушку @code{edebug-setup-hook}, а затем устанавливает для неё
значение @code{nil}.  Можно использовать это для загрузки спецификаций
Edebug, связанных с используемым пакетом, но только когда используется
Edebug.

@cindex edebug, failure to instrument
  Если Edebug обнаруживает синтаксическую ошибку во время
инструментирования, он оставляет точку в ошибочном коде и сигнализирует об
ошибке @code{invalid-read-syntax}.
@c От меня?  Я не вижу, что он это делает.
Example:

@example
@error{} Invalid read syntax: "Expected lambda expression"
@end example

  Одной из возможных причин такой неудачи с инструментарием является то, что
некоторые макроопределения еще не известны Emacs.  Чтобы обойти это,
загружается файл, который определяет функцию, которую инструментируется.

@findex eval-expression @r{(Edebug)}
  Чтобы удалить инструментарий из определения, просто переоценивается его
определение способом, который не инструментирует.  Есть два способа оценки
форм, которые никогда не инструментируют их: из файла используя @code{load}
и из минибуфера с помощью @code{eval-expression} (@kbd{M-:}).

  @xref{Edebug Eval}, для других оценочных функций, доступных в Edebug.

@node Edebug Execution Modes
@subsection Режимы Выполнения Edebug

@cindex Edebug execution modes
Edebug поддерживает несколько режимов выполнения отлаживаемой программы.
Называются эти альтернативы @dfn{Режимы выполнения Edebug}; не путатm их с
основными или второстепенными режимами.  Текущий режим выполнения Edebug
определяет, как далеко Edebug продолжает выполнение до остановки - например,
останавливается ли он в каждой точке останова или продолжает выполнение до
следующей точки останова - и сколько Edebug отображает прогресс оценки до
остановки.

Обычно указывается режим выполнения Edebug, набирается команду для
продолжения программы в определенном режиме.  Вот таблица этих команд; все
кроме @kbd{S} возобновляют выполнение программы хотя бы на определенное
расстояние.

@table @kbd
@item S
Стоп: больше не выполнять программу, а дождаться других команд Edebug
(@code{edebug-stop}).
@c от себя Не работает. https://debbugs.gnu.org/9764

@item @key{SPC}
Шаг: остановиться в следующей обнаруженной точке остановки
(@code{edebug-step-mode}).

@item n
Далее: остановиться в следующей точке остановки, обнаруженной после
выражения (@code{edebug-next-mode}).  Также смотреть
@code{edebug-forward-sexp} в @ref{Jumping}.

@item t
Трассировка: пауза (обычно одна секунда) в каждой точке остановки Edebug
(@code{edebug-trace-mode}).

@item T
Быстрое отслеживание: обновляется отображение в каждой точке останова, но
не приостанавливает работу (@code{edebug-Trace-fast-mode}).

@item g
Вперёд: идти до следующей точки останова (@code{edebug-go-mode}).
@xref{Breakpoints}.

@item c
Продолжить: делать паузу на одну секунду в каждой точке останова, а затем
продолжить (@code{edebug-continue-mode}).

@item C
Быстрое продолжение: переместите точку к каждой точке останова, но не
останавливаться (@code{edebug-Continue-fast-mode}).

@item G
Не останавливаться: игнорировать точки останова
(@code{edebug-Go-nonstop-mode}).  По-прежнему можно остановить программу,
набрав @kbd{S} или любую команду редактирования.
@end table

В общем, режимы выполнения, указанные ранее в приведенном выше списке,
запускают программу медленнее или останавливаются раньше, чем режимы,
указанные ниже в списке.

Когда происходит вход на новый уровень Edebug, Edebug обычно останавливается
на первой обнаруженной инструментированной функции.  Если предпочитается
останавливаться только в точке останова или вообще не останавливаться
(например, при сборе данных о покрытии), изменяется значение
@code{edebug-initial-mode} с его значения по умолчанию @code{step} на
@code{go}, или @code{Go-nonstop}, или одно из других его значений
(@pxref{Edebug Options}).  Можно легко сделать это с помощью
@kbd{C-x C-a C-m} (@code{edebug-set-initial-mode}):

@deffn Command edebug-set-initial-mode
@kindex C-x C-a C-m
Эта команда, привязанная к @kbd{C-x C-a C-m}, устанавливает
@code{edebug-initial-mode}.  Будет предложено ввести ключ для указания
режима.  Необходимо ввести одну из восьми ключей, перечисленных выше,
что установит соответствующий режим.
@end deffn

Обратите внимание, что можно повторно войти на один и тот же уровень Edebug
несколько раз, если, например, инструментированая функция вызывается
несколько раз из одной команды.

Во время выполнения или трассировки можно прервать выполнение, набрав любую
команду Edebug.  Edebug останавливает программу в следующей точке останова,
а затем выполняет набранную вами команду.  Например, ввод @kbd{t} во время
выполнения переключает в режим трассировки в следующей точке остановки.
Можно использовать @kbd{S}, чтобы остановить выполнение, ничего не делая.

Если ваша функция выполняет чтение ввода, вместо этого функция может
прочитать символ, который вводится, намереваясь прервать выполнение.  Можно
избежать таких непредвиденных результатов, обращая внимание на то, когда
программа требует ввода.

@cindex keyboard macros (Edebug)
Макросы клавиатуры, содержащие команды из этого раздела, не работают
полностью: при выходе из Edebug для возобновления программы макрос
клавиатуры теряется.  Исправить это непросто.  Кроме того, определение или
выполнение макроса клавиатуры вне Edebug не влияет на команды внутри Edebug.
Обычно это преимущество.  Смотреть параметр @code{edebug-continue-kbd-macro}
в @ref{Edebug Options}.

@defopt edebug-sit-for-seconds
Этот параметр указывает, сколько секунд ждать между этапами выполнения в
режиме трассировки или режиме продолжения.  По умолчанию 1 секунда.
@end defopt

@node Jumping
@subsection Прыжки

  Команды, описанные в этом разделе, выполняются, пока не достигнут
указанного места.  Все, кроме @kbd{i}, создают временную точку останова,
чтобы установить место для остановки, затем переключаются в режим перехода.
Любая другая точка останова, достигнутая до предполагаемой точки останова,
также остановит выполнение.  @xref{Breakpoints}, чтобы узнать о точках
останова.

  Эти команды могут не работать должным образом в случае нелокального
выхода, так как это может обойти временную точку останова, на которой
ожидалась остановка программы.

@table @kbd
@item h
Перейти к точке омтанова с точкой (@code{edebug-goto-here}).

@item f
Запустить программу для одного выражения (@code{edebug-forward-sexp}).

@item o
Запустить программу до конца содержащего sexp (@code{edebug-step-out}).

@item i
Войти в функцию или макрос, вызываемый формой после точки
(@code{edebug-step-in}).
@end table

Команда @kbd{h} переходит к точке останова в текущем положении точки или
после нее, используя временную точку останова.

Команда @kbd{f} запускает программу вперед по одному выражению.  Точнее, она
устанавливает временную точку останова в позиции, которую достигнет
@code{forward-sexp}, а затем выполняется в режиме go, так что программа
останавливается на точках останова.

С префиксным аргументом @var{n} временная точка останова помещается @var{n}
секунд на точку.  Если содержащий список заканчивается до всех @var{n}
элементов, то место для останова находится после содержащего выражения.

Потребуется убедиться, что найденная @code{forward-sexp} позиция - это то
место, куда программа действительно попадет.  В @code{cond}, например, это
может быть не так.

Для гибкости команда @kbd{f} выполняет @code{forward-sexp}, начиная с точки,
а не с точки останова.  Если требуется выполнить одно выражение
@emph{от текущей точки остановки}, сначала вводится @kbd{w}
(@code{edebug-where}), чтобы переместить туда точку, а затем вводится
@kbd{f}.

Команда @kbd{o} продолжается вне выражения.  Она помещает временную точку
останова в конец точки, содержащей выражение sexp.  Если содержащее sexp
само является определением функции, @kbd{o} продолжается до самого
последнего sexp в определении.  Если это и есть то место, она возвращается
из функции, а затем останавливается.  Другими словами, эта команда не
завершает текущую выполняемую функцию, если положение находится после
последнего выражения sexp.

Обычно команды @kbd{h}, @kbd{f}, и @kbd{o} отображают ``Break'' и делают
паузу для @code{edebug-sit-for-seconds} перед отображением результата только
что оцененной формы.  Можно избежать этой паузы, установив для
@code{edebug-sit-on-break} значение @code{nil}.  @xref{Edebug Options}.

Команда @kbd{i} переходит к функции или макросу, вызываемой формой списка
после точки, и останавливается в своей первой точке останова.  Обратить
внимание, что форма не обязательно должна быть той, которая будет
оцениваться.  Но если форма представляет собой вызов функции, которая должна
быть оценена, не забыть использовать эту команду до оценки любого из
аргументов, поскольку в противном случае будет слишком поздно.

Команда @kbd{i} инструментирует функцию или макрос, в которые она должна
входить, если это еще не инструментировано.  Это удобно, но нужно иметь в
виду, что функция или макрос остаются инструментированными, если явно их не
деинструментировать.

@node Edebug Misc
@subsection Разные Команды Edebug

  Здесь описаны некоторые разные команды Edebug.

@table @kbd
@item ?
Показать справочное сообщение для Edebug (@code{edebug-help}).

@item C-]
Отменить один уровень назад к предыдущему командному уровню
(@code{abort-recursive-edit}).

@item q
Вернуться в редактор верхнего уровня command loop (@code{top-level}).  Это
закрывает все уровни рекурсивного редактирования, включая все уровни
активности Edebug.  Однако инструментированый код, защищенный формами
@code{unwind-protect} или @code{condition-case}, может возобновить отладку.

@item Q
Как @kbd{q}, но не останавливаться даже на защищенном коде
(@code{edebug-top-level-nonstop}).

@item r
Повторно отобразить результат последнего известного выражения в эхо-области
(@code{edebug-previous-result}).

@item d
Отобразить трассировку, исключая собственные функции Edebug для наглядности
(@code{edebug-backtrace}).

Не выйдет использовать команды отладчика в буфере обратной трассировки в
Edebug, как в стандартном отладчике.

Буфер трассировки автоматически уничтожается, когда продолжается выполнение.
@end table

Можно вызывать команды из Edebug, которые снова рекурсивно активируют
Edebug.  Когда Edebug активен, можно выйти на верхний уровень с помощью
@kbd{q} или прервать один рекурсивный уровень редактирования с помощью
@kbd{C-]}.  Можно отобразить трассировку всех ожидающих оценок с помощью
@kbd{d}.

@node Breaks
@subsection Остановы

Пошаговый режим Edebug останавливает выполнение, когда достигается следующая
точка останова.  Есть три разных способа остановить выполнение Edebug после
его запуска: точка останова, глобальное условие останова и исходная точка
останова.

@menu
* Breakpoints::                 Точки останова в точках останова.
* Global Break Condition::      Останов по событию.
* Source Breakpoints::          Встраивание точек останова в исходный код.
@end menu

@node Breakpoints
@subsubsection Edebug Точки Останова

@cindex breakpoints (Edebug)
При использовании Edebug можно указать @dfn{точки останова} в тестируемой
программе: это места, где выполнение должно остановиться.  Можно установить
точку останова в любой точке остановки, как определено в @ref{Using Edebug}.
При установке и снятии точек останова затрагивается точка останова, которая
находится первее в буфере исходного кода или после нее.  Вот команды Edebug
для точек останова:

@table @kbd
@item b
Установить точку останова в точке остановки в точке
(@code{edebug-set-breakpoint}) или после нее.  Если используется префиксный
аргумент, точка останова будет временной - она отключается при первом
останове программы.

@item u
Сбросить точку останова (если есть) в точке останова в точке
(@code{edebug-unset-breakpoint}) или после нее.

@item x @var{condition} @key{RET}
Установить условную точку останова, которая останавливает программу, только
если оценка @var{condition} дает значение не-@code{nil}
(@code{edebug-set-conditional-breakpoint}).  С префиксным аргументом точка
останова является временной.

@item B
Переместить точку к следующей точке останова в текущем определении
(@code{edebug-next-breakpoint}).
@end table

Находясь в Edebug, можно установить точку останова с помощью @kbd{b} и
отключить ее с помощью @kbd{u}.  Сначала переместить точку в точку останова
Edebug по вашему выбору, затем ввести @kbd{b} или @kbd{u}, чтобы установить
или сбросить точку останова там.  Снятие точки останова, если она не была
установлена, не имеет никакого эффекта.

При повторной оценке или повторном использовании определения удаляются все
предыдущие точки останова.

@dfn{Условные точки останова} проверяет условие каждый раз, когда программа
попадает туда.  Любые ошибки, возникающие в результате оценки условия,
игнорируются, как если бы результат был @code{nil}.  Чтобы установить
условную точку останова, используется @kbd{x} и указывается выражение
условия в минибуфере.  Установка условной точки останова в точке останова,
которая имеет ранее установленную условную точку останова, помещает
предыдущее выражение условия в минибуфер, чтобы можно было его
редактировать.

Можно создать условную или безусловную точку останова @dfn{temporary},
используя префиксный аргумент с командой для установки точки останова.
Когда временная точка останова останавливает программу, она автоматически
сбрасывается.

Edebug всегда останавливается или приостанавливается в точке останова, за
исключением случаев, когда режим Edebug - Go-nonstop.  В этом режиме он
полностью игнорирует точки останова.

Чтобы узнать, где находятся точки останова, используется команда @kbd{B},
которая перемещает точку к следующей точке останова, следующей за точкой,
внутри той же функции или к первой точке останова, если следующих точек
останова нет.  Эта команда не продолжает выполнение - она просто перемещает
точку в буфере.

@node Global Break Condition
@subsubsection Глобальное Условие Останова

@cindex stopping on events
@cindex global break condition
  @dfn{Глобальное условие останова} останавливает выполнение, когда
выполняется указанное условие, независимо от того, где это может произойти.
Edebug оценивает глобальное условие прерывания в каждой точке останова; если
оно оценивается в значение не-@code{nil}, то выполнение останавливается или
приостанавливается в зависимости от режима выполнения, как если бы была
достигнута точка останова.  Если при оценке условия возникает ошибка,
выполнение не останавливается.

@findex edebug-set-global-break-condition
  Выражение условия хранится в @code{edebug-global-break-condition}.  Можно
указать новое выражение, используя команду @kbd{X} из буфера исходного кода,
пока Edebug активен, или используя @kbd{C-x X X} из любого буфера в любое
время, пока Edebug загружен (@code{edebug-set-global-break-condition}).

  Глобальное условие останова - это самый простой способ найти, где в вашем
коде происходит какое-либо событие, но оно заставляет код работать намного
медленнее.  Поэтому следует сбросить условие на @code{nil}, когда оно не
используется.

@node Source Breakpoints
@subsubsection Точки Останова в Исходном Коде

@findex edebug
@cindex source breakpoints
  Все точки останова в определении забываются каждый раз, когда оно заново
определяется.  Если потребуется создать точку останова, которая не будет
забыта, можно вставить @dfn{точку останова исходного кода}, которая
представляет собой просто вызов функции @code{edebug} в вашем исходном коде.
Конечно, можете сделать такой вызов условным.  Например, в функции
@code{fac} можно вставить первую строку, как показано ниже, чтобы
остановить, когда аргумент достигнет нуля:

@example
(defun fac (n)
  (if (= n 0) (edebug))
  (if (< 0 n)
      (* n (fac (1- n)))
    1))
@end example

  Когда определение @code{fac} инструментировано и функция вызывается, вызов
@code{edebug} действует как точка останова.  В зависимости от режима
выполнения Edebug останавливается или приостанавливается на нем.

  Если инструментальный код не выполняется при вызове @code{edebug}, эта
функция вызывает @code{debug}.
@c Возможно, это уже не лучшая идея.

@node Trapping Errors
@subsection Захват Ошибок

  Emacs обычно отображает сообщение об ошибке, когда сообщается об ошибке и
не обрабатывается с помощью @code{condition-case}.  Пока Edebug активен и
выполняет инструментированный код, он обычно реагирует на все необработанные
ошибки.  Можно настроить это с помощью параметров @code{edebug-on-error} и
@code{edebug-on-quit}; смотреть @ref{Edebug Options}.

  Когда Edebug реагирует на ошибку, он показывает последнюю точку останова,
встреченную перед ошибкой.  Это может быть место вызова функции, которая не
была инструментирована и в которой действительно произошла ошибка.  Для
ошибки несвязанной переменной, последняя известная точка останова может быть
довольно далеко удалена от ссылки на переменную, вызывающую нарушение.  В
этом случае можно отобразить полную трассировку (@pxref{Edebug Misc}).

@c Edebug следует изменить на следующие: -- dan
  Если изменить @code{debug-on-error} или @code{debug-on-quit}, когда Edebug
активен, эти изменения будут забыты, когда Edebug станет неактивным.  Более
того, во время рекурсивного редактирования Edebug эти переменные
привязываются к значениям, которые у них были вне Edebug.

@node Edebug Views
@subsection Виды Edebug

  Эти команды Edebug позволяют просматривать аспекты состояния буфера и
окна, какими они были до входа в Edebug.  Конфигурация внешнего окна - это
набор окон и содержимого, которые действовали вне Edebug.

@table @kbd
@item v
Перейти к просмотру конфигурации внешнего окна (@code{edebug-view-outside}).
Ввести @kbd{C-x X w}, чтобы вернуться в Edebug.

@item p
Временно отобразить внешний текущий буфер с точкой в его внешней позиции
(@code{edebug-bounce-point}), сделав паузу на одну секунду перед возвратом в
Edebug.  С префиксным аргументом @var{n} вместо этого сделайте паузу на
@var{n} секунд.

@item w
Переместить точку обратно в текущую точку остановки в буфере исходного кода
(@code{edebug-where}).

Если использовать эту команду в другом окне, отображающем тот же буфер, это
окно будет использоваться вместо этого для отображения текущего определения
в будущем.

@item W
@c Его функция - не просто забыть сохраненную конфигурацию. -- dan
Указать, сохраняет ли Edebug и восстанавливает конфигурацию внешнего окна
(@code{edebug-toggle-save-windows}).

С префиксным аргументом @code{W} переключает только сохранение и
восстановление выбранного окна.  Чтобы указать окно, в котором не
отображается буфер исходного кода, необходимо использовать @kbd{C-x X W} из
глобальной ключевой карты.
@end table

  Можно просмотреть конфигурацию внешнего окна с помощью @kbd{v} или просто
перейти к точке в текущем буфере с помощью @kbd{p}, даже если он обычно не
отображается.

  После перемещения точки может потребоваться вернуться к точке останова.
Можно сделать это с помощью @kbd{w} из буфера исходного кода.  Можно
вернуться к точке останова в буфере исходного кода из любого буфера,
используя @kbd{C-x X w}.

  Каждый раз, когда используется @kbd{W} для включения сохранения
@emph{off}, Edebug забывает сохраненную конфигурацию внешнего окна --- так
что даже если снова включить сохранение @emph{on}, текущая конфигурация окна
останется неизменной при следующем выходе из Edebug (продолжая программу).
Однако автоматическое повторное отображение @file{*edebug*} и
@file{*edebug-trace*} может конфликтовать с буферами, которые потребуется
видеть, если не открыто достаточно окон.

@node Edebug Eval
@subsection Оценка

  Находясь в Edebug, можно оценивать выражения, как если бы Edebug не был
запущен.  Edebug пытается быть невидимым для вычисления и печати выражения.
Оценка выражений, вызывающих побочные эффекты, будет работать должным
образом, за исключением изменений данных, которые Edebug явно сохраняет и
восстанавливает.  @xref{The Outside Context}, чтобы узнать подробнее об этом
процессе.

@table @kbd
@item e @var{exp} @key{RET}
Вычислить выражение @var{exp} в контексте вне Edebug
(@code{edebug-eval-expression}).  То есть Edebug пытается минимизировать
своё вмешательство в оценку.

@item M-: @var{exp} @key{RET}
Вычислить выражение @var{exp} в контексте самого Edebug
(@code{eval-expression}).

@item C-x C-e
Оценитm выражение перед точкой в контексте за пределами Edebug
(@code{edebug-eval-last-sexp}).
@end table

@cindex lexical binding (Edebug)
  Edebug поддерживает оценку выражений, содержащих ссылки на лексически
связанные символы, созданные следующими конструкциями в @file{cl.el}:
@code{lexical-let}, @code{macrolet}, и @code{symbol-macrolet}.
@c от себя?  А как насчет лексической привязки = t?

@node Eval List
@subsection Буфер Оценочного Списка

  Можно использовать @dfn{Буфер Оценочного Списка}, называемый
@file{*edebug*}, для интерактивной оценки выражений.  Можно настроить
@dfn{лист оценки} выражений на автоматическое вычисление каждый раз, когда
Edebug обновляет отображение.

@table @kbd
@item E
Перейти в буфер списка оценок @file{*edebug*}
(@code{edebug-visit-eval-list}).
@end table

  В буфере @file{*edebug*} можно использовать команды режима взаимодействия
с Lisp (@pxref{Lisp Interaction,,, emacs, The GNU Emacs Manual}), а также
эти специальные команды:

@table @kbd
@item C-j
Вычислить выражение перед точкой во внешнем контексте и вставить значение в
буфер (@code{edebug-eval-print-last-sexp}).

@item C-x C-e
Оценить выражение перед точкой в контексте за пределами Edebug
(@code{edebug-eval-last-sexp}).

@item C-c C-u
Создать новый оценочный список из содержимого буфера
(@code{edebug-update-eval-list}).

@item C-c C-d
Удалить группу списка оценки, которая находится в
(@code{edebug-delete-eval-item}).

@item C-c C-w
Вернуться в буфер исходного кода в текущей точке останова
(@code{edebug-where}).
@end table

  Можно оценивать выражения в окне списка оценок с помощью @kbd{C-j} или
@kbd{C-x C-e}, как и в @file{*scratch*}; но они оцениваются вне Edebug.

  Выражения, которые вводятся в интерактивном режиме (и их результаты),
теряются, когда продолжается выполнение; но можно настроить
@dfn{список оценки}, состоящий из выражений, которые будут вычисляться
каждый раз при остановке выполнения.

@cindex evaluation list group
  Для этого запишите одну или несколько @dfn{групп листа оценки} в буфер
оценочного списка.  Группа оценочного списка состоит из одного или
нескольких выражений Lisp.  Группы разделяются строками комментариев.

  Команда @kbd{C-c C-u} (@code{edebug-update-eval-list}) перестраивает
оценочный список, просматривая буфер и используя первое выражение каждой
группы.  (Идея состоит в том, что второе выражение группы - это значение,
ранее вычисленное и отображаемое.)

  Каждая запись в Edebug повторно отображает список оценки, вставляя каждое
выражение в буфер, за которым следует его текущее значение.  Это также
вставляет строки комментариев, так что каждое выражение становится отдельной
группой.  Таким образом, если снова набрать @kbd{C-c C-u}, не изменяя текст
буфера, оценочный список фактически не изменится.

  Если ошибка возникает во время оценки из оценочного списка, сообщение об
ошибке отображается в строке, как если бы это было результатом.
Следовательно, выражения, использующие переменные, которые в настоящее время
недействительны, не прерывают отладку.

  Вот пример того, как выглядит окно оценочного списка после добавления к
нему нескольких выражений:

@smallexample
(current-buffer)
#<buffer *scratch*>
;---------------------------------------------------------------
(selected-window)
#<window 16 on *scratch*>
;---------------------------------------------------------------
(point)
196
;---------------------------------------------------------------
bad-var
"Symbol's value as variable is void: bad-var"
;---------------------------------------------------------------
(recursion-depth)
0
;---------------------------------------------------------------
this-command
eval-last-sexp
;---------------------------------------------------------------
@end smallexample

Чтобы удалить группу, перемещается в неё точка и вводится @kbd{C-c C-d} или
просто удаляется текст для группы и обновляется оценочный список с помощью
@kbd{C-c C-u}.  Чтобы добавить новое выражение в список оценки, вставляется
выражение в подходящее место, вставляется новая строка комментария, затем
введится @kbd{C-c C-u}.  Не нужно вставлять тире в строку комментария - его
содержание не имеет значения.

После выбора @file{*edebug*} можно вернуться в буфер исходного кода с
помощью @kbd{C-c C-w}.  Буфер @file{*edebug*} уничтожается, когда
продолжается выполнение, и воссоздается в следующий раз, когда понадобится.

@node Printing in Edebug
@subsection Печать в Edebug

@cindex printing (Edebug)
@cindex printing circular structures
@pindex cust-print
  Если выражение в программе создает значение, содержащее круговую структуру
списка, можно получить ошибку, когда Edebug попытается распечатать его.

  Один из способов справиться с круговой структурой - установить
@code{print-length} или @code{print-level}, чтобы урезать печать.  Edebug
сделает это за вас; он связывает @code{print-length} и @code{print-level}
со значениями переменных @code{edebug-print-length} и
@code{edebug-print-level} (при условии, что они имеют значения
не-@code{nil}).  @xref{Output Variables}.

@defopt edebug-print-length
Если не-@code{nil}, Edebug связывает @code{print-length} с этим значением
при печати результатов.  Значение по умолчанию - @code{50}.
@end defopt

@defopt edebug-print-level
Если не-@code{nil}, Edebug связывает @code{print-level} с этим значением
при печати результатов.  Значение по умолчанию - @code{50}.
@end defopt

  Также можете печатать круговые структуры и структуры, которые более
информативно разделяют элементы, привязав @code{print-circle} к значению
не-@code{nil}.

  Вот пример кода, который создает круговую структуру:

@example
(setq a '(x y))
(setcar a a)
@end example

@noindent
Пользовательская печать выводит это как @samp{Result: #1=(#1# y)}.
Обозначение @samp{#1=} маркирует структуру, которая следует за ней, меткой
@samp{1}, а запись @samp{#1#} ссылается на ранее помеченную структуру.  Это
обозначение используется для любых общих элементов списков или векторов.

@defopt edebug-print-circle
Если не-@code{nil}, Edebug связывает @code{print-circle} с этим значением
при печати результатов.  Значение по умолчанию - @code{t}.
@end defopt

  Другие программы также могут использовать настраиваемую печать; подробнее
смотреть @file{cust-print.el}.

@node Trace Buffer
@subsection Буфер Трассировки
@cindex trace buffer

  Edebug может записывать трассировку выполнения, сохраняя ее в буфере с
именем @file{*edebug-trace*}.  Это журнал вызовов и возвратов функций,
показывающий имена функций, их аргументы и значения.  Чтобы включить запись
трассировки, установите для @code{edebug-trace} значение не-@code{nil}.

  Создание буфера трассировки - это не то же самое, что использование режима
 выполнения трассировки (@pxref{Edebug Execution Modes}).

  Когда запись трассировки включена, каждый вход и выход функции добавляет
строки в буфер трассировки.  Запись функции состоит из @samp{::::@{}, за
которой следуют имя функции и значения аргументов.  Запись о выходе функции
состоит из @samp{::::@}}, за которой следуют имя функции и результат
функции.

  Число @samp{:} в записи показывает глубину ее рекурсии.  Можно
использовать фигурные скобки в буфере трассировки, чтобы найти совпадающее
начало или конец вызовов функций.

@findex edebug-print-trace-before
@findex edebug-print-trace-after
  Можно настроить запись трассировки для входа и выхода из функций,
переопределив функции @code{edebug-print-trace-before} и @code{edebug-print-trace-after}.

@defmac edebug-tracing string body@dots{}
This macro requests additional trace information around the execution
of the @var{body} forms.  The argument @var{string} specifies text
to put in the trace buffer, after the @samp{@{} or @samp{@}}.  All
the arguments are evaluated, and @code{edebug-tracing} returns the
value of the last form in @var{body}.
@end defmac

@defun edebug-trace format-string &rest format-args
This function inserts text in the trace buffer.  It computes the text
with @code{(apply 'format @var{format-string} @var{format-args})}.
It also appends a newline to separate entries.
@end defun

  @code{edebug-tracing} and @code{edebug-trace} insert lines in the
trace buffer whenever they are called, even if Edebug is not active.
Adding text to the trace buffer also scrolls its window to show the last
lines inserted.

@node Coverage Testing
@subsection Coverage Testing

@cindex coverage testing (Edebug)
@cindex frequency counts
@cindex performance analysis (Edebug)
  Edebug provides rudimentary coverage testing and display of execution
frequency.

  Coverage testing works by comparing the result of each expression with
the previous result; each form in the program is considered covered
if it has returned two different values since you began testing coverage
in the current Emacs session.  Thus, to do coverage testing on your
program, execute it under various conditions and note whether it behaves
correctly; Edebug will tell you when you have tried enough different
conditions that each form has returned two different values.

  Coverage testing makes execution slower, so it is only done if
@code{edebug-test-coverage} is non-@code{nil}.  Frequency counting is
performed for all executions of an instrumented function, even if the
execution mode is Go-nonstop, and regardless of whether coverage testing
is enabled.

@kindex C-x X =
@findex edebug-temp-display-freq-count
  Use @kbd{C-x X =} (@code{edebug-display-freq-count}) to display both
the coverage information and the frequency counts for a definition.
Just @kbd{=} (@code{edebug-temp-display-freq-count}) displays the same
information temporarily, only until you type another key.

@deffn Command edebug-display-freq-count
This command displays the frequency count data for each line of the
current definition.

It inserts frequency counts as comment lines after each line of code.
You can undo all insertions with one @code{undo} command.  The counts
appear under the @samp{(} before an expression or the @samp{)} after
an expression, or on the last character of a variable.  To simplify
the display, a count is not shown if it is equal to the count of an
earlier expression on the same line.

The character @samp{=} following the count for an expression says that
the expression has returned the same value each time it was evaluated.
In other words, it is not yet covered for coverage testing purposes.

To clear the frequency count and coverage data for a definition,
simply reinstrument it with @code{eval-defun}.
@end deffn

For example, after evaluating @code{(fac 5)} with a source
breakpoint, and setting @code{edebug-test-coverage} to @code{t}, when
the breakpoint is reached, the frequency data looks like this:

@example
(defun fac (n)
  (if (= n 0) (edebug))
;#6           1      = =5
  (if (< 0 n)
;#5         =
      (* n (fac (1- n)))
;#    5               0
    1))
;#   0
@end example

The comment lines show that @code{fac} was called 6 times.  The
first @code{if} statement returned 5 times with the same result each
time; the same is true of the condition on the second @code{if}.
The recursive call of @code{fac} did not return at all.


@node The Outside Context
@subsection The Outside Context

Edebug tries to be transparent to the program you are debugging, but it
does not succeed completely.  Edebug also tries to be transparent when
you evaluate expressions with @kbd{e} or with the evaluation list
buffer, by temporarily restoring the outside context.  This section
explains precisely what context Edebug restores, and how Edebug fails to
be completely transparent.

@menu
* Checking Whether to Stop::    When Edebug decides what to do.
* Edebug Display Update::       When Edebug updates the display.
* Edebug Recursive Edit::       When Edebug stops execution.
@end menu

@node Checking Whether to Stop
@subsubsection Checking Whether to Stop

Whenever Edebug is entered, it needs to save and restore certain data
before even deciding whether to make trace information or stop the
program.

@itemize @bullet
@item
@vindex edebug-max-depth
@code{max-lisp-eval-depth} (@pxref{Eval}) and @code{max-specpdl-size}
(@pxref{Local Variables}) are both increased to reduce Edebug's impact
on the stack.  You could, however, still run out of stack space when
using Edebug.  You can also enlarge the value of
@code{edebug-max-depth} if Edebug reaches the limit of recursion depth
instrumenting code that contains very large quoted lists.

@item
The state of keyboard macro execution is saved and restored.  While
Edebug is active, @code{executing-kbd-macro} is bound to @code{nil}
unless @code{edebug-continue-kbd-macro} is non-@code{nil}.
@end itemize


@node Edebug Display Update
@subsubsection Edebug Display Update

@c This paragraph is not filled, because LaLiberte's conversion script
@c needs an xref to be on just one line.
When Edebug needs to display something (e.g., in trace mode), it saves
the current window configuration from outside Edebug
(@pxref{Window Configurations}).  When you exit Edebug, it restores
the previous window configuration.

Emacs redisplays only when it pauses.  Usually, when you continue
execution, the program re-enters Edebug at a breakpoint or after
stepping, without pausing or reading input in between.  In such cases,
Emacs never gets a chance to redisplay the outside configuration.
Consequently, what you see is the same window configuration as the last
time Edebug was active, with no interruption.

Entry to Edebug for displaying something also saves and restores the
following data (though some of them are deliberately not restored if an
error or quit signal occurs).

@itemize @bullet
@item
@cindex current buffer point and mark (Edebug)
Which buffer is current, and the positions of point and the mark in the
current buffer, are saved and restored.

@item
@cindex window configuration (Edebug)
The outside window configuration is saved and restored if
@code{edebug-save-windows} is non-@code{nil} (@pxref{Edebug Options}).

The window configuration is not restored on error or quit, but the
outside selected window @emph{is} reselected even on error or quit in
case a @code{save-excursion} is active.  If the value of
@code{edebug-save-windows} is a list, only the listed windows are saved
and restored.

The window start and horizontal scrolling of the source code buffer are
not restored, however, so that the display remains coherent within Edebug.

@item
The value of point in each displayed buffer is saved and restored if
@code{edebug-save-displayed-buffer-points} is non-@code{nil}.

@item
The variables @code{overlay-arrow-position} and
@code{overlay-arrow-string} are saved and restored, so you can safely
invoke Edebug from the recursive edit elsewhere in the same buffer.

@item
@code{cursor-in-echo-area} is locally bound to @code{nil} so that
the cursor shows up in the window.
@end itemize

@node Edebug Recursive Edit
@subsubsection Edebug Recursive Edit

When Edebug is entered and actually reads commands from the user, it
saves (and later restores) these additional data:

@itemize @bullet
@item
The current match data.  @xref{Match Data}.

@item
The variables @code{last-command}, @code{this-command},
@code{last-command-event}, @code{last-input-event},
@code{last-event-frame}, @code{last-nonmenu-event}, and
@code{track-mouse}.  Commands in Edebug do not affect these variables
outside of Edebug.

Executing commands within Edebug can change the key sequence that
would be returned by @code{this-command-keys}, and there is no way to
reset the key sequence from Lisp.

Edebug cannot save and restore the value of
@code{unread-command-events}.  Entering Edebug while this variable has a
nontrivial value can interfere with execution of the program you are
debugging.

@item
Complex commands executed while in Edebug are added to the variable
@code{command-history}.  In rare cases this can alter execution.

@item
Within Edebug, the recursion depth appears one deeper than the recursion
depth outside Edebug.  This is not true of the automatically updated
evaluation list window.

@item
@code{standard-output} and @code{standard-input} are bound to @code{nil}
by the @code{recursive-edit}, but Edebug temporarily restores them during
evaluations.

@item
The state of keyboard macro definition is saved and restored.  While
Edebug is active, @code{defining-kbd-macro} is bound to
@code{edebug-continue-kbd-macro}.
@end itemize

@node Edebug and Macros
@subsection Edebug and Macros

To make Edebug properly instrument expressions that call macros, some
extra care is needed.  This subsection explains the details.

@menu
* Instrumenting Macro Calls::   The basic problem.
* Specification List::          How to specify complex patterns of evaluation.
* Backtracking::                What Edebug does when matching fails.
* Specification Examples::      To help understand specifications.
@end menu

@node Instrumenting Macro Calls
@subsubsection Instrumenting Macro Calls

  When Edebug instruments an expression that calls a Lisp macro, it needs
additional information about the macro to do the job properly.  This is
because there is no a-priori way to tell which subexpressions of the
macro call are forms to be evaluated.  (Evaluation may occur explicitly
in the macro body, or when the resulting expansion is evaluated, or any
time later.)

  Therefore, you must define an Edebug specification for each macro
that Edebug will encounter, to explain the format of calls to that
macro.  To do this, add a @code{debug} declaration to the macro
definition.  Here is a simple example that shows the specification for
the @code{for} example macro (@pxref{Argument Evaluation}).

@smallexample
(defmacro for (var from init to final do &rest body)
  "Execute a simple \"for\" loop.
For example, (for i from 1 to 10 do (print i))."
  (declare (debug (symbolp "from" form "to" form "do" &rest form)))
  ...)
@end smallexample

  The Edebug specification says which parts of a call to the macro are
forms to be evaluated.  For simple macros, the specification
often looks very similar to the formal argument list of the macro
definition, but specifications are much more general than macro
arguments.  @xref{Defining Macros}, for more explanation of
the @code{declare} form.

@c See, e.g., https://debbugs.gnu.org/10577
@c FIXME  Maybe there should be an Edebug option to get it to
@c automatically load the entire source file containing the function
@c being instrumented.  That would avoid this.
  Take care to ensure that the specifications are known to Edebug when
you instrument code.  If you are instrumenting a function which uses a
macro defined in another file, you may first need to either evaluate
the @code{require} forms in the file containing your function, or
explicitly load the file containing the macro.  If the definition of a
macro is wrapped by @code{eval-when-compile}, you may need to evaluate
it.

  You can also define an edebug specification for a macro separately
from the macro definition with @code{def-edebug-spec}.  Adding
@code{debug} declarations is preferred, and more convenient, for macro
definitions in Lisp, but @code{def-edebug-spec} makes it possible to
define Edebug specifications for special forms implemented in C.

@defmac def-edebug-spec macro specification
Specify which expressions of a call to macro @var{macro} are forms to be
evaluated.  @var{specification} should be the edebug specification.
Neither argument is evaluated.

The @var{macro} argument can actually be any symbol, not just a macro
name.
@end defmac

Here is a table of the possibilities for @var{specification} and how each
directs processing of arguments.

@table @asis
@item @code{t}
All arguments are instrumented for evaluation.

@item @code{0}
None of the arguments is instrumented.

@item a symbol
The symbol must have an Edebug specification, which is used instead.
This indirection is repeated until another kind of specification is
found.  This allows you to inherit the specification from another macro.

@item a list
The elements of the list describe the types of the arguments of a
calling form.  The possible elements of a specification list are
described in the following sections.
@end table

If a macro has no Edebug specification, neither through a @code{debug}
declaration nor through a @code{def-edebug-spec} call, the variable
@code{edebug-eval-macro-args} comes into play.

@defopt edebug-eval-macro-args
This controls the way Edebug treats macro arguments with no explicit
Edebug specification.  If it is @code{nil} (the default), none of the
arguments is instrumented for evaluation.  Otherwise, all arguments
are instrumented.
@end defopt

@node Specification List
@subsubsection Specification List

@cindex Edebug specification list
A @dfn{specification list} is required for an Edebug specification if
some arguments of a macro call are evaluated while others are not.  Some
elements in a specification list match one or more arguments, but others
modify the processing of all following elements.  The latter, called
@dfn{specification keywords}, are symbols beginning with @samp{&} (such
as @code{&optional}).

A specification list may contain sublists, which match arguments that are
themselves lists, or it may contain vectors used for grouping.  Sublists
and groups thus subdivide the specification list into a hierarchy of
levels.  Specification keywords apply only to the remainder of the
sublist or group they are contained in.

When a specification list involves alternatives or repetition, matching
it against an actual macro call may require backtracking.  For more
details, @pxref{Backtracking}.

Edebug specifications provide the power of regular expression matching,
plus some context-free grammar constructs: the matching of sublists with
balanced parentheses, recursive processing of forms, and recursion via
indirect specifications.

Here's a table of the possible elements of a specification list, with
their meanings (see @ref{Specification Examples}, for the referenced
examples):

@table @code
@item sexp
A single unevaluated Lisp object, which is not instrumented.
@c an "expression" is not necessarily intended for evaluation.

@item form
A single evaluated expression, which is instrumented.  If your macro
wraps the expression with @code{lambda} before it is evaluated, use
@code{def-form} instead.  See @code{def-form} below.

@item place
A generalized variable.  @xref{Generalized Variables}.

@item body
Short for @code{&rest form}.  See @code{&rest} below.  If your macro
wraps its body of code with @code{lambda} before it is evaluated, use
@code{def-body} instead.  See @code{def-body} below.

@item function-form
A function form: either a quoted function symbol, a quoted lambda
expression, or a form (that should evaluate to a function symbol or
lambda expression).  This is useful when an argument that's a lambda
expression might be quoted with @code{quote} rather than
@code{function}, since it instruments the body of the lambda expression
either way.

@item lambda-expr
A lambda expression with no quoting.

@item &optional
@c @kindex &optional @r{(Edebug)}
All following elements in the specification list are optional; as soon
as one does not match, Edebug stops matching at this level.

To make just a few elements optional, followed by non-optional elements,
use @code{[&optional @var{specs}@dots{}]}.  To specify that several
elements must all match or none, use @code{&optional
[@var{specs}@dots{}]}.  See the @code{defun} example.

@item &rest
@c @kindex &rest @r{(Edebug)}
All following elements in the specification list are repeated zero or
more times.  In the last repetition, however, it is not a problem if the
expression runs out before matching all of the elements of the
specification list.

To repeat only a few elements, use @code{[&rest @var{specs}@dots{}]}.
To specify several elements that must all match on every repetition, use
@code{&rest [@var{specs}@dots{}]}.

@item &or
@c @kindex &or @r{(Edebug)}
Each of the following elements in the specification list is an
alternative.  One of the alternatives must match, or the @code{&or}
specification fails.

Each list element following @code{&or} is a single alternative.  To
group two or more list elements as a single alternative, enclose them in
@code{[@dots{}]}.

@item &not
@c @kindex &not @r{(Edebug)}
Each of the following elements is matched as alternatives as if by using
@code{&or}, but if any of them match, the specification fails.  If none
of them match, nothing is matched, but the @code{&not} specification
succeeds.

@c FIXME &key?

@item &define
@c @kindex &define @r{(Edebug)}
Indicates that the specification is for a defining form.  Edebug's
definition of a defining form is a form containing one or more code
forms which are saved and executed later, after the execution of the
defining form.

The defining form itself is not instrumented (that is, Edebug does not
stop before and after the defining form), but forms inside it
typically will be instrumented.  The @code{&define} keyword should be
the first element in a list specification.

@item nil
This is successful when there are no more arguments to match at the
current argument list level; otherwise it fails.  See sublist
specifications and the backquote example.

@item gate
@cindex preventing backtracking
No argument is matched but backtracking through the gate is disabled
while matching the remainder of the specifications at this level.  This
is primarily used to generate more specific syntax error messages.  See
@ref{Backtracking}, for more details.  Also see the @code{let} example.

@item @var{other-symbol}
@cindex indirect specifications
Any other symbol in a specification list may be a predicate or an
indirect specification.

If the symbol has an Edebug specification, this @dfn{indirect
specification} should be either a list specification that is used in
place of the symbol, or a function that is called to process the
arguments.  The specification may be defined with @code{def-edebug-spec}
just as for macros.  See the @code{defun} example.

Otherwise, the symbol should be a predicate.  The predicate is called
with the argument, and if the predicate returns @code{nil}, the
specification fails and the argument is not instrumented.

Some suitable predicates include @code{symbolp}, @code{integerp},
@code{stringp}, @code{vectorp}, and @code{atom}.

@item [@var{elements}@dots{}]
@cindex [@dots{}] (Edebug)
A vector of elements groups the elements into a single @dfn{group
specification}.  Its meaning has nothing to do with vectors.

@item "@var{string}"
The argument should be a symbol named @var{string}.  This specification
is equivalent to the quoted symbol, @code{'@var{symbol}}, where the name
of @var{symbol} is the @var{string}, but the string form is preferred.

@item (vector @var{elements}@dots{})
The argument should be a vector whose elements must match the
@var{elements} in the specification.  See the backquote example.

@item (@var{elements}@dots{})
Any other list is a @dfn{sublist specification} and the argument must be
a list whose elements match the specification @var{elements}.

@cindex dotted lists (Edebug)
A sublist specification may be a dotted list and the corresponding list
argument may then be a dotted list.  Alternatively, the last @sc{cdr} of a
dotted list specification may be another sublist specification (via a
grouping or an indirect specification, e.g., @code{(spec .  [(more
specs@dots{})])}) whose elements match the non-dotted list arguments.
This is useful in recursive specifications such as in the backquote
example.  Also see the description of a @code{nil} specification
above for terminating such recursion.

Note that a sublist specification written as @code{(specs .  nil)}
is equivalent to @code{(specs)}, and @code{(specs .
(sublist-elements@dots{}))} is equivalent to @code{(specs
sublist-elements@dots{})}.
@end table

@c Need to document extensions with &symbol and :symbol

Here is a list of additional specifications that may appear only after
@code{&define}.  See the @code{defun} example.

@table @code
@item name
The argument, a symbol, is the name of the defining form.

A defining form is not required to have a name field; and it may have
multiple name fields.

@item :name
This construct does not actually match an argument.  The element
following @code{:name} should be a symbol; it is used as an additional
name component for the definition.  You can use this to add a unique,
static component to the name of the definition.  It may be used more
than once.

@item arg
The argument, a symbol, is the name of an argument of the defining form.
However, lambda-list keywords (symbols starting with @samp{&})
are not allowed.

@item lambda-list
@cindex lambda-list (Edebug)
This matches a lambda list---the argument list of a lambda expression.

@item def-body
The argument is the body of code in a definition.  This is like
@code{body}, described above, but a definition body must be instrumented
with a different Edebug call that looks up information associated with
the definition.  Use @code{def-body} for the highest level list of forms
within the definition.

@item def-form
The argument is a single, highest-level form in a definition.  This is
like @code{def-body}, except it is used to match a single form rather than
a list of forms.  As a special case, @code{def-form} also means that
tracing information is not output when the form is executed.  See the
@code{interactive} example.
@end table

@node Backtracking
@subsubsection Backtracking in Specifications

@cindex backtracking
@cindex syntax error (Edebug)
If a specification fails to match at some point, this does not
necessarily mean a syntax error will be signaled; instead,
@dfn{backtracking} will take place until all alternatives have been
exhausted.  Eventually every element of the argument list must be
matched by some element in the specification, and every required element
in the specification must match some argument.

When a syntax error is detected, it might not be reported until much
later, after higher-level alternatives have been exhausted, and with the
point positioned further from the real error.  But if backtracking is
disabled when an error occurs, it can be reported immediately.  Note
that backtracking is also reenabled automatically in several situations;
when a new alternative is established by @code{&optional},
@code{&rest}, or @code{&or}, or at the start of processing a sublist,
group, or indirect specification.  The effect of enabling or disabling
backtracking is limited to the remainder of the level currently being
processed and lower levels.

Backtracking is disabled while matching any of the
form specifications (that is, @code{form}, @code{body}, @code{def-form}, and
@code{def-body}).  These specifications will match any form so any error
must be in the form itself rather than at a higher level.

Backtracking is also disabled after successfully matching a quoted
symbol or string specification, since this usually indicates a
recognized construct.  But if you have a set of alternative constructs that
all begin with the same symbol, you can usually work around this
constraint by factoring the symbol out of the alternatives, e.g.,
@code{["foo" &or [first case] [second case] ...]}.

Most needs are satisfied by these two ways that backtracking is
automatically disabled, but occasionally it is useful to explicitly
disable backtracking by using the @code{gate} specification.  This is
useful when you know that no higher alternatives could apply.  See the
example of the @code{let} specification.

@node Specification Examples
@subsubsection Specification Examples

It may be easier to understand Edebug specifications by studying
the examples provided here.

A @code{let} special form has a sequence of bindings and a body.  Each
of the bindings is either a symbol or a sublist with a symbol and
optional expression.  In the specification below, notice the @code{gate}
inside of the sublist to prevent backtracking once a sublist is found.

@ignore
@c FIXME?  The actual definition in edebug.el looks like this (and always
@c has AFAICS).  In fact, nothing in edebug.el uses gate.  So maybe
@c this is just an example for illustration?
(def-edebug-spec let
  ((&rest
    &or (symbolp &optional form) symbolp)
   body))
@end ignore
@example
(def-edebug-spec let
  ((&rest
    &or symbolp (gate symbolp &optional form))
   body))
@end example

Edebug uses the following specifications for @code{defun} and the
associated argument list and @code{interactive} specifications.  It is
necessary to handle interactive forms specially since an expression
argument is actually evaluated outside of the function body.  (The
specification for @code{defmacro} is very similar to that for
@code{defun}, but allows for the @code{declare} statement.)

@smallexample
(def-edebug-spec defun
  (&define name lambda-list
           [&optional stringp]   ; @r{Match the doc string, if present.}
           [&optional ("interactive" interactive)]
           def-body))

(def-edebug-spec lambda-list
  (([&rest arg]
    [&optional ["&optional" arg &rest arg]]
    &optional ["&rest" arg]
    )))

(def-edebug-spec interactive
  (&optional &or stringp def-form))    ; @r{Notice: @code{def-form}}
@end smallexample

The specification for backquote below illustrates how to match
dotted lists and use @code{nil} to terminate recursion.  It also
illustrates how components of a vector may be matched.  (The actual
specification defined by Edebug is a little different, and does not
support dotted lists because doing so causes very deep recursion that
could fail.)

@smallexample
(def-edebug-spec \` (backquote-form))   ; @r{Alias just for clarity.}

(def-edebug-spec backquote-form
  (&or ([&or "," ",@@"] &or ("quote" backquote-form) form)
       (backquote-form . [&or nil backquote-form])
       (vector &rest backquote-form)
       sexp))
@end smallexample


@node Edebug Options
@subsection Edebug Options

  These options affect the behavior of Edebug:
@c Previously defopt'd:
@c edebug-sit-for-seconds, edebug-print-length, edebug-print-level
@c edebug-print-circle, edebug-eval-macro-args

@defopt edebug-setup-hook
Functions to call before Edebug is used.  Each time it is set to a new
value, Edebug will call those functions once and then
reset @code{edebug-setup-hook} to @code{nil}.  You could use this to
load up Edebug specifications associated with a package you are using,
but only when you also use Edebug.
@xref{Instrumenting}.
@end defopt

@defopt edebug-all-defs
If this is non-@code{nil}, normal evaluation of defining forms such as
@code{defun} and @code{defmacro} instruments them for Edebug.  This
applies to @code{eval-defun}, @code{eval-region}, @code{eval-buffer},
and @code{eval-current-buffer}.

Use the command @kbd{M-x edebug-all-defs} to toggle the value of this
option.  @xref{Instrumenting}.
@end defopt

@defopt edebug-all-forms
If this is non-@code{nil}, the commands @code{eval-defun},
@code{eval-region}, @code{eval-buffer}, and @code{eval-current-buffer}
instrument all forms, even those that don't define anything.
This doesn't apply to loading or evaluations in the minibuffer.

Use the command @kbd{M-x edebug-all-forms} to toggle the value of this
option.  @xref{Instrumenting}.
@end defopt

@defopt edebug-eval-macro-args
When this is non-@code{nil}, all macro arguments will be instrumented
in the generated code.  For any macro, an @code{edebug-form-spec}
overrides this option.  So to specify exceptions for macros that have
some arguments evaluated and some not, use @code{def-edebug-spec} to
specify an @code{edebug-form-spec}.
@end defopt

@defopt edebug-save-windows
If this is non-@code{nil}, Edebug saves and restores the window
configuration.  That takes some time, so if your program does not care
what happens to the window configurations, it is better to set this
variable to @code{nil}.

If the value is a list, only the listed windows are saved and
restored.

You can use the @kbd{W} command in Edebug to change this variable
interactively.  @xref{Edebug Display Update}.
@end defopt

@defopt edebug-save-displayed-buffer-points
If this is non-@code{nil}, Edebug saves and restores point in all
displayed buffers.

Saving and restoring point in other buffers is necessary if you are
debugging code that changes the point of a buffer that is displayed in
a non-selected window.  If Edebug or the user then selects the window,
point in that buffer will move to the window's value of point.

Saving and restoring point in all buffers is expensive, since it
requires selecting each window twice, so enable this only if you need
it.  @xref{Edebug Display Update}.
@end defopt

@defopt edebug-initial-mode
If this variable is non-@code{nil}, it specifies the initial execution
mode for Edebug when it is first activated.  Possible values are
@code{step}, @code{next}, @code{go}, @code{Go-nonstop}, @code{trace},
@code{Trace-fast}, @code{continue}, and @code{Continue-fast}.

The default value is @code{step}.  This variable can be set
interactively with @kbd{C-x C-a C-m} (@code{edebug-set-initial-mode}).
@xref{Edebug Execution Modes}.
@end defopt

@defopt edebug-trace
If this is non-@code{nil}, trace each function entry and exit.
Tracing output is displayed in a buffer named @file{*edebug-trace*}, one
function entry or exit per line, indented by the recursion level.

Also see @code{edebug-tracing}, in @ref{Trace Buffer}.
@end defopt

@defopt edebug-test-coverage
If non-@code{nil}, Edebug tests coverage of all expressions debugged.
@xref{Coverage Testing}.
@end defopt

@defopt edebug-continue-kbd-macro
If non-@code{nil}, continue defining or executing any keyboard macro
that is executing outside of Edebug.   Use this with caution since it is not
debugged.
@xref{Edebug Execution Modes}.
@end defopt

@defopt edebug-print-length
If non-@code{nil}, the default value of @code{print-length} for
printing results in Edebug.  @xref{Output Variables}.
@end defopt

@defopt edebug-print-level
If non-@code{nil}, the default value of @code{print-level} for
printing results in Edebug.  @xref{Output Variables}.
@end defopt

@defopt edebug-print-circle
If non-@code{nil}, the default value of @code{print-circle} for
printing results in Edebug.  @xref{Output Variables}.
@end defopt

@defopt edebug-unwrap-results
If non-@code{nil}, Edebug tries to remove any of its own
instrumentation when showing the results of expressions.  This is
relevant when debugging macros where the results of expressions are
themselves instrumented expressions.  As a very artificial example,
suppose that the example function @code{fac} has been instrumented,
and consider a macro of the form:

@c FIXME find a less silly example.
@smallexample
(defmacro test () "Edebug example."
  (if (symbol-function 'fac)
      @dots{}))
@end smallexample

If you instrument the @code{test} macro and step through it, then by
default the result of the @code{symbol-function} call has numerous
@code{edebug-after} and @code{edebug-before} forms, which can make it
difficult to see the actual result.  If
@code{edebug-unwrap-results} is non-@code{nil}, Edebug tries to remove
these forms from the result.
@end defopt

@defopt edebug-on-error
Edebug binds @code{debug-on-error} to this value, if
@code{debug-on-error} was previously @code{nil}.  @xref{Trapping
Errors}.
@end defopt

@defopt edebug-on-quit
Edebug binds @code{debug-on-quit} to this value, if
@code{debug-on-quit} was previously @code{nil}.  @xref{Trapping
Errors}.
@end defopt

  If you change the values of @code{edebug-on-error} or
@code{edebug-on-quit} while Edebug is active, their values won't be used
until the @emph{next} time Edebug is invoked via a new command.
@c Not necessarily a deeper command level.
@c A new command is not precisely true, but that is close enough -- dan

@defopt edebug-global-break-condition
If non-@code{nil}, an expression to test for at every stop point.  If
the result is non-@code{nil}, then break.  Errors are ignored.
@xref{Global Break Condition}.
@end defopt

@defopt edebug-sit-for-seconds
Number of seconds to pause when a breakpoint is reached and the execution
mode is trace or continue.  @xref{Edebug Execution Modes}.
@end defopt

@defopt edebug-sit-on-break
Whether or not to pause for @code{edebug-sit-for-seconds} on reaching
a breakpoint.  Set to @code{nil} to prevent the pause, non-@code{nil}
to allow it.
@end defopt
