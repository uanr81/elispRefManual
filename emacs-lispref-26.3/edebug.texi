@comment -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1992-1994, 1998-1999, 2001-2019 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.

@c This file can also be used by an independent Edebug User
@c Manual in which case the Edebug node below should be used
@c with the following links to the Bugs section and to the top level:

@c , Bugs and Todo List, Top, Top

@node Edebug
@section Отладчик Edebug
@cindex Edebug debugging facility

  Edebug - это отладчик исходного кода для программ Emacs Lisp, с помощью
которого можно:

@itemize @bullet
@item
Пошагово выполнять оценку, останавливаясь до и после каждого выражения.

@item
Установить условные или безусловные точки останова.

@item
Остановить, когда указанное условие истинно (глобальное событие прерывания).

@item
Отслеживать медленно или быстро, ненадолго останавливаясь в каждой точке
остановки или в каждой точке останова.

@item
Отображать результаты выражений и оценивать выражения, как если бы они были
вне Edebug.

@item
Автоматически переоценивать список выражений и отображать их результаты
каждый раз, когда Edebug обновляет отображение.

@item
Вывод информации трассировки для вызовов и возвратов функций.

@item
Остановка при возникновении ошибки.

@item
Отобразить обратную трассировку, опуская собственные кадры Edebug.

@item
Указать оценку аргументов для макросов и определяющих форм.

@item
Получить элементарное тестирование покрытия и подсчет частоты.
@end itemize

Первые три раздела ниже должны рассказать достаточно об Edebug, чтобы начать
его использовать.

@menu
* Using Edebug::                Введение в использование Edebug.
* Instrumenting::               Потребуется инструментировать код, чтобы
отлаживать его с помощью Edebug.
* Modes:  Edebug Execution Modes. Режимы выполнения, остановка более-менее
часто.
* Jumping::                     Команды для перехода в указанное место.
* Misc: Edebug Misc.            Разные команды.
* Breaks::                      Установка точек останова для остановки программы.
* Trapping Errors::             Перехват ошибок с помощью Edebug.
* Views: Edebug Views.          Виды внутри и снаружи Edebug.
* Eval: Edebug Eval.            Оценка выражений в Edebug.
* Eval List::                   Выражения, значения которых отображаются
                                 каждый раз при входе в Edebug.
* Printing in Edebug::          Настройка вывода.
* Trace Buffer::                Как произвести вывод трассировки в буфер.
* Coverage Testing::            Как протестировать оценочное покрытие.
* The Outside Context::         Данные, которые Edebug сохраняет и
                                 восстанавливает.
* Edebug and Macros::           Определение того, как обрабатывать вызовы
                                 макросов.
* Options: Edebug Options.      Переменные параметров для настройки Edebug.
@end menu

@node Using Edebug
@subsection Использование Edebug

  Чтобы отлаживать программу на Lisp с помощью Edebug, потребуется сначала
@dfn{инструментировать} код Lisp, который нужно отлаживать.  Простой способ
сделать это - сначала переместить точку в определение функции или макроса,
а затем выполнить @kbd{C-u C-M-x} (@code{eval-defun} с префиксным
аргументом).  Смотреть @ref{Instrumenting}, для альтернативных способов
инструментирования кода.

  После инструментирования функции любой вызов функции активирует Edebug.
В зависимости от того, какой режим выполнения Edebug выбран, активация
Edebug может остановить выполнение и позволить перейти к выполнению функции
или может обновить отображение и продолжить выполнение при проверке команд
отладки.  Режим выполнения по умолчанию - шаг, который останавливает
выполнение.  @xref{Edebug Execution Modes}.

  В Edebug обычно просматривается буфер Emacs, показывающий исходный код
Lisp, который отлаживается.  Он называется @dfn{буфер исходного када} и
он временно доступен только для чтения.

  Стрелка в левой части указывает строку, в которой выполняется функция.
Изначально точка показывает, где внутри строки выполняется функция, но это
перестает быть истинным, если перемещена точка самостоятельно.

  Если инструментируется определение @code{fac} (показано ниже), а затем
выполняется @code{(fac 3)}, вот что обычно увидите.  Точка стоит в скобках
перед @code{if}.

@example
(defun fac (n)
=>@point{}(if (< 0 n)
      (* n (fac (1- n)))
    1))
@end example

@cindex stop points
Места внутри функции, где Edebug может остановить выполнение, называются
@dfn{точками останова}.  Они могут быть как до, так и после каждого
подвыражения, представляющего собой список, а также после каждой ссылки на
переменную.  Здесь используются точки для отображения точек останова в
функции @code{fac}:

@example
(defun fac (n)
  .(if .(< 0 n.).
      .(* n. .(fac .(1- n.).).).
    1).)
@end example

Специальные команды Edebug доступны в буфере исходного кода в дополнение к
командам режима Emacs Lisp.  Например, можно ввести команду Edebug @key{SPC}
для выполнения до следующей точки остановки.  Если наберается @key{SPC} один
раз после входа в @code{fac}, экран примет такой вид:

@example
(defun fac (n)
=>(if @point{}(< 0 n)
      (* n (fac (1- n)))
    1))
@end example

Когда Edebug останавливает выполнение после выражения, он отображает
значение выражения в эхо-области.

Другие часто используемые команды: @kbd{b} для установки точки останова в
точке останова, @kbd{g} для выполнения до достижения точки останова и
@kbd{q} для выхода из Edebug и возврата в командный цикл верхнего уровня.
Введите @kbd{?}, чтобы отобразить список всех команд Edebug.

@node Instrumenting
@subsection Инструментирование для Edebug
@cindex instrumenting for Edebug

  Чтобы использовать Edebug для отладки кода Lisp, потребуется сначала
инструментировать код.  Инструментирование кода вставляет в него
дополнительный код для вызова Edebug в нужных местах.

@kindex C-M-x
@findex eval-defun @r{(Edebug)}
  Когда вызывается команда @kbd{C-M-x} (@code{eval-defun}) с префиксным
аргументом в тексте определении функции, это инструментирует определение
перед оценкой его формч.  (Это не изменяет сам исходный код.).  Если
переменная @code{edebug-all-defs} - не-@code{nil}, это меняет значение
префиксного аргумента: в этом случае @kbd{C-M-x} определяет префиксный
аргумент @emph{unless}.  Значение @code{edebug-all-defs} по умолчанию -
@code{nil}.  Команда @kbd{M-x edebug-all-defs} переключает значение
переменной @code{edebug-all-defs}.

@findex eval-region @r{(Edebug)}
@findex eval-buffer @r{(Edebug)}
@findex eval-current-buffer @r{(Edebug)}
  Если @code{edebug-all-defs} равен не-@code{nil}, то команды
@code{eval-region}, @code{eval-current-buffer}, и @code{eval-buffer} также
обрабатывают любые определения, которые они оценивают.  Точно так же
@code{edebug-all-forms} контролирует, должен ли @code{eval-region}
использовать @emph{любую} форму , даже не определяющую.  Это не относится к
загрузке или оценке в минибуфере.  Команда @kbd{M-x edebug-all-forms}
переключает эту опцию.

@findex edebug-eval-top-level-form
@findex edebug-defun
  Другая команда, @kbd{M-x edebug-eval-top-level-form}, доступна для
инструментирования любой формы верхнего уровня независимо от значений
@code{edebug-all-defs} и @code{edebug-all-forms}.  @code{edebug-defun} - это
псевдоним @code{edebug-eval-top-level-form}.

  Пока Edebug активен, команда @kbd{I} (@code{edebug-instrument-callee})
инструментирует определение функции или макроса, вызываемых формой списка
после точки, если это еще не инструментировано.  Это возможно только в том
случае, если Edebug знает, где найти источник этой функции; по этой причине,
после загрузки Edebug, @code{eval-region} записывает позицию каждого
определения, которое он оценивает, даже если он не инструментировал его.
Смотреть также команду @kbd{i} (@pxref{Jumping}), которая переходит в вызов
после инструментирования функции.

  Edebug знает, как инструментировать все стандартные специальные формы,
формы @code{interactive} с аргументом выражением, анонимные лямбда-выражения
и другие определяющие формы.  Однако Edebug не может самостоятельно
определить, что пользовательский макрос будет делать с аргументами вызова
макроса, поэтому потребуется предоставить эту информацию, используя
спецификации Edebug; подробнее @pxref{Edebug and Macros}.

  Когда Edebug собирается инструментировать код в первый раз в сеансе, он
запускает ловушку @code{edebug-setup-hook}, а затем устанавливает для неё
значение @code{nil}.  Можно использовать это для загрузки спецификаций
Edebug, связанных с используемым пакетом, но только когда используется
Edebug.

@cindex edebug, failure to instrument
  Если Edebug обнаруживает синтаксическую ошибку во время
инструментирования, он оставляет точку в ошибочном коде и сигнализирует об
ошибке @code{invalid-read-syntax}.
@c От меня?  Я не вижу, что он это делает.
Example:

@example
@error{} Invalid read syntax: "Expected lambda expression"
@end example

  Одной из возможных причин такой неудачи с инструментарием является то, что
некоторые макроопределения еще не известны Emacs.  Чтобы обойти это,
загружается файл, который определяет функцию, которую инструментируется.

@findex eval-expression @r{(Edebug)}
  Чтобы удалить инструментарий из определения, просто переоценивается его
определение способом, который не инструментирует.  Есть два способа оценки
форм, которые никогда не инструментируют их: из файла используя @code{load}
и из минибуфера с помощью @code{eval-expression} (@kbd{M-:}).

  @xref{Edebug Eval}, для других оценочных функций, доступных в Edebug.

@node Edebug Execution Modes
@subsection Режимы Выполнения Edebug

@cindex Edebug execution modes
Edebug поддерживает несколько режимов выполнения отлаживаемой программы.
Называются эти альтернативы @dfn{Режимы выполнения Edebug}; не путатm их с
основными или второстепенными режимами.  Текущий режим выполнения Edebug
определяет, как далеко Edebug продолжает выполнение до остановки - например,
останавливается ли он в каждой точке останова или продолжает выполнение до
следующей точки останова - и сколько Edebug отображает прогресс оценки до
остановки.

Обычно указывается режим выполнения Edebug, набирается команду для
продолжения программы в определенном режиме.  Вот таблица этих команд; все
кроме @kbd{S} возобновляют выполнение программы хотя бы на определенное
расстояние.

@table @kbd
@item S
Стоп: больше не выполнять программу, а дождаться других команд Edebug
(@code{edebug-stop}).
@c от себя Не работает. https://debbugs.gnu.org/9764

@item @key{SPC}
Шаг: остановиться в следующей обнаруженной точке остановки
(@code{edebug-step-mode}).

@item n
Далее: остановиться в следующей точке остановки, обнаруженной после
выражения (@code{edebug-next-mode}).  Также смотреть
@code{edebug-forward-sexp} в @ref{Jumping}.

@item t
Трассировка: пауза (обычно одна секунда) в каждой точке остановки Edebug
(@code{edebug-trace-mode}).

@item T
Быстрое отслеживание: обновляется отображение в каждой точке останова, но
не приостанавливает работу (@code{edebug-Trace-fast-mode}).

@item g
Вперёд: идти до следующей точки останова (@code{edebug-go-mode}).
@xref{Breakpoints}.

@item c
Продолжить: делать паузу на одну секунду в каждой точке останова, а затем
продолжить (@code{edebug-continue-mode}).

@item C
Быстрое продолжение: переместите точку к каждой точке останова, но не
останавливаться (@code{edebug-Continue-fast-mode}).

@item G
Не останавливаться: игнорировать точки останова
(@code{edebug-Go-nonstop-mode}).  По-прежнему можно остановить программу,
набрав @kbd{S} или любую команду редактирования.
@end table

В общем, режимы выполнения, указанные ранее в приведенном выше списке,
запускают программу медленнее или останавливаются раньше, чем режимы,
указанные ниже в списке.

Когда происходит вход на новый уровень Edebug, Edebug обычно останавливается
на первой обнаруженной инструментированной функции.  Если предпочитается
останавливаться только в точке останова или вообще не останавливаться
(например, при сборе данных о покрытии), изменяется значение
@code{edebug-initial-mode} с его значения по умолчанию @code{step} на
@code{go}, или @code{Go-nonstop}, или одно из других его значений
(@pxref{Edebug Options}).  Можно легко сделать это с помощью
@kbd{C-x C-a C-m} (@code{edebug-set-initial-mode}):

@deffn Command edebug-set-initial-mode
@kindex C-x C-a C-m
Эта команда, привязанная к @kbd{C-x C-a C-m}, устанавливает
@code{edebug-initial-mode}.  Будет предложено ввести ключ для указания
режима.  Необходимо ввести одну из восьми ключей, перечисленных выше,
что установит соответствующий режим.
@end deffn

Обратите внимание, что можно повторно войти на один и тот же уровень Edebug
несколько раз, если, например, инструментированая функция вызывается
несколько раз из одной команды.

Во время выполнения или трассировки можно прервать выполнение, набрав любую
команду Edebug.  Edebug останавливает программу в следующей точке останова,
а затем выполняет набранную вами команду.  Например, ввод @kbd{t} во время
выполнения переключает в режим трассировки в следующей точке остановки.
Можно использовать @kbd{S}, чтобы остановить выполнение, ничего не делая.

Если ваша функция выполняет чтение ввода, вместо этого функция может
прочитать символ, который вводится, намереваясь прервать выполнение.  Можно
избежать таких непредвиденных результатов, обращая внимание на то, когда
программа требует ввода.

@cindex keyboard macros (Edebug)
Макросы клавиатуры, содержащие команды из этого раздела, не работают
полностью: при выходе из Edebug для возобновления программы макрос
клавиатуры теряется.  Исправить это непросто.  Кроме того, определение или
выполнение макроса клавиатуры вне Edebug не влияет на команды внутри Edebug.
Обычно это преимущество.  Смотреть параметр @code{edebug-continue-kbd-macro}
в @ref{Edebug Options}.

@defopt edebug-sit-for-seconds
Этот параметр указывает, сколько секунд ждать между этапами выполнения в
режиме трассировки или режиме продолжения.  По умолчанию 1 секунда.
@end defopt

@node Jumping
@subsection Прыжки

  Команды, описанные в этом разделе, выполняются, пока не достигнут
указанного места.  Все, кроме @kbd{i}, создают временную точку останова,
чтобы установить место для остановки, затем переключаются в режим перехода.
Любая другая точка останова, достигнутая до предполагаемой точки останова,
также остановит выполнение.  @xref{Breakpoints}, чтобы узнать о точках
останова.

  Эти команды могут не работать должным образом в случае нелокального
выхода, так как это может обойти временную точку останова, на которой
ожидалась остановка программы.

@table @kbd
@item h
Перейти к точке омтанова с точкой (@code{edebug-goto-here}).

@item f
Запустить программу для одного выражения (@code{edebug-forward-sexp}).

@item o
Запустить программу до конца содержащего sexp (@code{edebug-step-out}).

@item i
Войти в функцию или макрос, вызываемый формой после точки
(@code{edebug-step-in}).
@end table

Команда @kbd{h} переходит к точке останова в текущем положении точки или
после нее, используя временную точку останова.

Команда @kbd{f} запускает программу вперед по одному выражению.  Точнее, она
устанавливает временную точку останова в позиции, которую достигнет
@code{forward-sexp}, а затем выполняется в режиме go, так что программа
останавливается на точках останова.

С префиксным аргументом @var{n} временная точка останова помещается @var{n}
секунд на точку.  Если содержащий список заканчивается до всех @var{n}
элементов, то место для останова находится после содержащего выражения.

Потребуется убедиться, что найденная @code{forward-sexp} позиция - это то
место, куда программа действительно попадет.  В @code{cond}, например, это
может быть не так.

Для гибкости команда @kbd{f} выполняет @code{forward-sexp}, начиная с точки,
а не с точки останова.  Если требуется выполнить одно выражение
@emph{от текущей точки остановки}, сначала вводится @kbd{w}
(@code{edebug-where}), чтобы переместить туда точку, а затем вводится
@kbd{f}.

Команда @kbd{o} продолжается вне выражения.  Она помещает временную точку
останова в конец точки, содержащей выражение sexp.  Если содержащее sexp
само является определением функции, @kbd{o} продолжается до самого
последнего sexp в определении.  Если это и есть то место, она возвращается
из функции, а затем останавливается.  Другими словами, эта команда не
завершает текущую выполняемую функцию, если положение находится после
последнего выражения sexp.

Обычно команды @kbd{h}, @kbd{f}, и @kbd{o} отображают ``Break'' и делают
паузу для @code{edebug-sit-for-seconds} перед отображением результата только
что оцененной формы.  Можно избежать этой паузы, установив для
@code{edebug-sit-on-break} значение @code{nil}.  @xref{Edebug Options}.

Команда @kbd{i} переходит к функции или макросу, вызываемой формой списка
после точки, и останавливается в своей первой точке останова.  Обратить
внимание, что форма не обязательно должна быть той, которая будет
оцениваться.  Но если форма представляет собой вызов функции, которая должна
быть оценена, не забыть использовать эту команду до оценки любого из
аргументов, поскольку в противном случае будет слишком поздно.

Команда @kbd{i} инструментирует функцию или макрос, в которые она должна
входить, если это еще не инструментировано.  Это удобно, но нужно иметь в
виду, что функция или макрос остаются инструментированными, если явно их не
деинструментировать.

@node Edebug Misc
@subsection Разные Команды Edebug

  Здесь описаны некоторые разные команды Edebug.

@table @kbd
@item ?
Показать справочное сообщение для Edebug (@code{edebug-help}).

@item C-]
Отменить один уровень назад к предыдущему командному уровню
(@code{abort-recursive-edit}).

@item q
Вернуться в редактор верхнего уровня command loop (@code{top-level}).  Это
закрывает все уровни рекурсивного редактирования, включая все уровни
активности Edebug.  Однако инструментированый код, защищенный формами
@code{unwind-protect} или @code{condition-case}, может возобновить отладку.

@item Q
Как @kbd{q}, но не останавливаться даже на защищенном коде
(@code{edebug-top-level-nonstop}).

@item r
Повторно отобразить результат последнего известного выражения в эхо-области
(@code{edebug-previous-result}).

@item d
Отобразить трассировку, исключая собственные функции Edebug для наглядности
(@code{edebug-backtrace}).

Не выйдет использовать команды отладчика в буфере обратной трассировки в
Edebug, как в стандартном отладчике.

Буфер трассировки автоматически уничтожается, когда продолжается выполнение.
@end table

Можно вызывать команды из Edebug, которые снова рекурсивно активируют
Edebug.  Когда Edebug активен, можно выйти на верхний уровень с помощью
@kbd{q} или прервать один рекурсивный уровень редактирования с помощью
@kbd{C-]}.  Можно отобразить трассировку всех ожидающих оценок с помощью
@kbd{d}.

@node Breaks
@subsection Остановы

Пошаговый режим Edebug останавливает выполнение, когда достигается следующая
точка останова.  Есть три разных способа остановить выполнение Edebug после
его запуска: точка останова, глобальное условие останова и исходная точка
останова.

@menu
* Breakpoints::                 Точки останова в точках останова.
* Global Break Condition::      Останов по событию.
* Source Breakpoints::          Встраивание точек останова в исходный код.
@end menu

@node Breakpoints
@subsubsection Edebug Точки Останова

@cindex breakpoints (Edebug)
При использовании Edebug можно указать @dfn{точки останова} в тестируемой
программе: это места, где выполнение должно остановиться.  Можно установить
точку останова в любой точке остановки, как определено в @ref{Using Edebug}.
При установке и снятии точек останова затрагивается точка останова, которая
находится первее в буфере исходного кода или после нее.  Вот команды Edebug
для точек останова:

@table @kbd
@item b
Установить точку останова в точке остановки в точке
(@code{edebug-set-breakpoint}) или после нее.  Если используется префиксный
аргумент, точка останова будет временной - она отключается при первом
останове программы.

@item u
Сбросить точку останова (если есть) в точке останова в точке
(@code{edebug-unset-breakpoint}) или после нее.

@item x @var{condition} @key{RET}
Установить условную точку останова, которая останавливает программу, только
если оценка @var{condition} дает значение не-@code{nil}
(@code{edebug-set-conditional-breakpoint}).  С префиксным аргументом точка
останова является временной.

@item B
Переместить точку к следующей точке останова в текущем определении
(@code{edebug-next-breakpoint}).
@end table

Находясь в Edebug, можно установить точку останова с помощью @kbd{b} и
отключить ее с помощью @kbd{u}.  Сначала переместить точку в точку останова
Edebug по вашему выбору, затем ввести @kbd{b} или @kbd{u}, чтобы установить
или сбросить точку останова там.  Снятие точки останова, если она не была
установлена, не имеет никакого эффекта.

При повторной оценке или повторном использовании определения удаляются все
предыдущие точки останова.

@dfn{Условные точки останова} проверяет условие каждый раз, когда программа
попадает туда.  Любые ошибки, возникающие в результате оценки условия,
игнорируются, как если бы результат был @code{nil}.  Чтобы установить
условную точку останова, используется @kbd{x} и указывается выражение
условия в минибуфере.  Установка условной точки останова в точке останова,
которая имеет ранее установленную условную точку останова, помещает
предыдущее выражение условия в минибуфер, чтобы можно было его
редактировать.

Можно создать условную или безусловную точку останова @dfn{temporary},
используя префиксный аргумент с командой для установки точки останова.
Когда временная точка останова останавливает программу, она автоматически
сбрасывается.

Edebug всегда останавливается или приостанавливается в точке останова, за
исключением случаев, когда режим Edebug - Go-nonstop.  В этом режиме он
полностью игнорирует точки останова.

Чтобы узнать, где находятся точки останова, используется команда @kbd{B},
которая перемещает точку к следующей точке останова, следующей за точкой,
внутри той же функции или к первой точке останова, если следующих точек
останова нет.  Эта команда не продолжает выполнение - она просто перемещает
точку в буфере.

@node Global Break Condition
@subsubsection Глобальное Условие Останова

@cindex stopping on events
@cindex global break condition
  @dfn{Глобальное условие останова} останавливает выполнение, когда
выполняется указанное условие, независимо от того, где это может произойти.
Edebug оценивает глобальное условие прерывания в каждой точке останова; если
оно оценивается в значение не-@code{nil}, то выполнение останавливается или
приостанавливается в зависимости от режима выполнения, как если бы была
достигнута точка останова.  Если при оценке условия возникает ошибка,
выполнение не останавливается.

@findex edebug-set-global-break-condition
  Выражение условия хранится в @code{edebug-global-break-condition}.  Можно
указать новое выражение, используя команду @kbd{X} из буфера исходного кода,
пока Edebug активен, или используя @kbd{C-x X X} из любого буфера в любое
время, пока Edebug загружен (@code{edebug-set-global-break-condition}).

  Глобальное условие останова - это самый простой способ найти, где в вашем
коде происходит какое-либо событие, но оно заставляет код работать намного
медленнее.  Поэтому следует сбросить условие на @code{nil}, когда оно не
используется.

@node Source Breakpoints
@subsubsection Точки Останова в Исходном Коде

@findex edebug
@cindex source breakpoints
  Все точки останова в определении забываются каждый раз, когда оно заново
определяется.  Если потребуется создать точку останова, которая не будет
забыта, можно вставить @dfn{точку останова исходного кода}, которая
представляет собой просто вызов функции @code{edebug} в вашем исходном коде.
Конечно, можете сделать такой вызов условным.  Например, в функции
@code{fac} можно вставить первую строку, как показано ниже, чтобы
остановить, когда аргумент достигнет нуля:

@example
(defun fac (n)
  (if (= n 0) (edebug))
  (if (< 0 n)
      (* n (fac (1- n)))
    1))
@end example

  Когда определение @code{fac} инструментировано и функция вызывается, вызов
@code{edebug} действует как точка останова.  В зависимости от режима
выполнения Edebug останавливается или приостанавливается на нем.

  Если инструментальный код не выполняется при вызове @code{edebug}, эта
функция вызывает @code{debug}.
@c Возможно, это уже не лучшая идея.

@node Trapping Errors
@subsection Захват Ошибок

  Emacs обычно отображает сообщение об ошибке, когда сообщается об ошибке и
не обрабатывается с помощью @code{condition-case}.  Пока Edebug активен и
выполняет инструментированный код, он обычно реагирует на все необработанные
ошибки.  Можно настроить это с помощью параметров @code{edebug-on-error} и
@code{edebug-on-quit}; смотреть @ref{Edebug Options}.

  Когда Edebug реагирует на ошибку, он показывает последнюю точку останова,
встреченную перед ошибкой.  Это может быть место вызова функции, которая не
была инструментирована и в которой действительно произошла ошибка.  Для
ошибки несвязанной переменной, последняя известная точка останова может быть
довольно далеко удалена от ссылки на переменную, вызывающую нарушение.  В
этом случае можно отобразить полную трассировку (@pxref{Edebug Misc}).

@c Edebug следует изменить на следующие: -- dan
  Если изменить @code{debug-on-error} или @code{debug-on-quit}, когда Edebug
активен, эти изменения будут забыты, когда Edebug станет неактивным.  Более
того, во время рекурсивного редактирования Edebug эти переменные
привязываются к значениям, которые у них были вне Edebug.

@node Edebug Views
@subsection Виды Edebug

  Эти команды Edebug позволяют просматривать аспекты состояния буфера и
окна, какими они были до входа в Edebug.  Конфигурация внешнего окна - это
набор окон и содержимого, которые действовали вне Edebug.

@table @kbd
@item v
Перейти к просмотру конфигурации внешнего окна (@code{edebug-view-outside}).
Ввести @kbd{C-x X w}, чтобы вернуться в Edebug.

@item p
Временно отобразить внешний текущий буфер с точкой в его внешней позиции
(@code{edebug-bounce-point}), сделав паузу на одну секунду перед возвратом в
Edebug.  С префиксным аргументом @var{n} вместо этого сделайте паузу на
@var{n} секунд.

@item w
Переместить точку обратно в текущую точку остановки в буфере исходного кода
(@code{edebug-where}).

Если использовать эту команду в другом окне, отображающем тот же буфер, это
окно будет использоваться вместо этого для отображения текущего определения
в будущем.

@item W
@c Его функция - не просто забыть сохраненную конфигурацию. -- dan
Указать, сохраняет ли Edebug и восстанавливает конфигурацию внешнего окна
(@code{edebug-toggle-save-windows}).

С префиксным аргументом @code{W} переключает только сохранение и
восстановление выбранного окна.  Чтобы указать окно, в котором не
отображается буфер исходного кода, необходимо использовать @kbd{C-x X W} из
глобальной ключевой карты.
@end table

  Можно просмотреть конфигурацию внешнего окна с помощью @kbd{v} или просто
перейти к точке в текущем буфере с помощью @kbd{p}, даже если он обычно не
отображается.

  После перемещения точки может потребоваться вернуться к точке останова.
Можно сделать это с помощью @kbd{w} из буфера исходного кода.  Можно
вернуться к точке останова в буфере исходного кода из любого буфера,
используя @kbd{C-x X w}.

  Каждый раз, когда используется @kbd{W} для включения сохранения
@emph{off}, Edebug забывает сохраненную конфигурацию внешнего окна --- так
что даже если снова включить сохранение @emph{on}, текущая конфигурация окна
останется неизменной при следующем выходе из Edebug (продолжая программу).
Однако автоматическое повторное отображение @file{*edebug*} и
@file{*edebug-trace*} может конфликтовать с буферами, которые потребуется
видеть, если не открыто достаточно окон.

@node Edebug Eval
@subsection Оценка

  Находясь в Edebug, можно оценивать выражения, как если бы Edebug не был
запущен.  Edebug пытается быть невидимым для вычисления и печати выражения.
Оценка выражений, вызывающих побочные эффекты, будет работать должным
образом, за исключением изменений данных, которые Edebug явно сохраняет и
восстанавливает.  @xref{The Outside Context}, чтобы узнать подробнее об этом
процессе.

@table @kbd
@item e @var{exp} @key{RET}
Вычислить выражение @var{exp} в контексте вне Edebug
(@code{edebug-eval-expression}).  То есть Edebug пытается минимизировать
своё вмешательство в оценку.

@item M-: @var{exp} @key{RET}
Вычислить выражение @var{exp} в контексте самого Edebug
(@code{eval-expression}).

@item C-x C-e
Оценитm выражение перед точкой в контексте за пределами Edebug
(@code{edebug-eval-last-sexp}).
@end table

@cindex lexical binding (Edebug)
  Edebug поддерживает оценку выражений, содержащих ссылки на лексически
связанные символы, созданные следующими конструкциями в @file{cl.el}:
@code{lexical-let}, @code{macrolet}, и @code{symbol-macrolet}.
@c от себя?  А как насчет лексической привязки = t?

@node Eval List
@subsection Буфер Оценочного Списка

  Можно использовать @dfn{Буфер Оценочного Списка}, называемый
@file{*edebug*}, для интерактивной оценки выражений.  Можно настроить
@dfn{лист оценки} выражений на автоматическое вычисление каждый раз, когда
Edebug обновляет отображение.

@table @kbd
@item E
Перейти в буфер списка оценок @file{*edebug*}
(@code{edebug-visit-eval-list}).
@end table

  В буфере @file{*edebug*} можно использовать команды режима взаимодействия
с Lisp (@pxref{Lisp Interaction,,, emacs, The GNU Emacs Manual}), а также
эти специальные команды:

@table @kbd
@item C-j
Вычислить выражение перед точкой во внешнем контексте и вставить значение в
буфер (@code{edebug-eval-print-last-sexp}).

@item C-x C-e
Оценить выражение перед точкой в контексте за пределами Edebug
(@code{edebug-eval-last-sexp}).

@item C-c C-u
Создать новый оценочный список из содержимого буфера
(@code{edebug-update-eval-list}).

@item C-c C-d
Удалить группу списка оценки, которая находится в
(@code{edebug-delete-eval-item}).

@item C-c C-w
Вернуться в буфер исходного кода в текущей точке останова
(@code{edebug-where}).
@end table

  Можно оценивать выражения в окне списка оценок с помощью @kbd{C-j} или
@kbd{C-x C-e}, как и в @file{*scratch*}; но они оцениваются вне Edebug.

  Выражения, которые вводятся в интерактивном режиме (и их результаты),
теряются, когда продолжается выполнение; но можно настроить
@dfn{список оценки}, состоящий из выражений, которые будут вычисляться
каждый раз при остановке выполнения.

@cindex evaluation list group
  Для этого запишите одну или несколько @dfn{групп листа оценки} в буфер
оценочного списка.  Группа оценочного списка состоит из одного или
нескольких выражений Lisp.  Группы разделяются строками комментариев.

  Команда @kbd{C-c C-u} (@code{edebug-update-eval-list}) перестраивает
оценочный список, просматривая буфер и используя первое выражение каждой
группы.  (Идея состоит в том, что второе выражение группы - это значение,
ранее вычисленное и отображаемое.)

  Каждая запись в Edebug повторно отображает список оценки, вставляя каждое
выражение в буфер, за которым следует его текущее значение.  Это также
вставляет строки комментариев, так что каждое выражение становится отдельной
группой.  Таким образом, если снова набрать @kbd{C-c C-u}, не изменяя текст
буфера, оценочный список фактически не изменится.

  Если ошибка возникает во время оценки из оценочного списка, сообщение об
ошибке отображается в строке, как если бы это было результатом.
Следовательно, выражения, использующие переменные, которые в настоящее время
недействительны, не прерывают отладку.

  Вот пример того, как выглядит окно оценочного списка после добавления к
нему нескольких выражений:

@smallexample
(current-buffer)
#<buffer *scratch*>
;---------------------------------------------------------------
(selected-window)
#<window 16 on *scratch*>
;---------------------------------------------------------------
(point)
196
;---------------------------------------------------------------
bad-var
"Symbol's value as variable is void: bad-var"
;---------------------------------------------------------------
(recursion-depth)
0
;---------------------------------------------------------------
this-command
eval-last-sexp
;---------------------------------------------------------------
@end smallexample

Чтобы удалить группу, перемещается в неё точка и вводится @kbd{C-c C-d} или
просто удаляется текст для группы и обновляется оценочный список с помощью
@kbd{C-c C-u}.  Чтобы добавить новое выражение в список оценки, вставляется
выражение в подходящее место, вставляется новая строка комментария, затем
введится @kbd{C-c C-u}.  Не нужно вставлять тире в строку комментария - его
содержание не имеет значения.

После выбора @file{*edebug*} можно вернуться в буфер исходного кода с
помощью @kbd{C-c C-w}.  Буфер @file{*edebug*} уничтожается, когда
продолжается выполнение, и воссоздается в следующий раз, когда понадобится.

@node Printing in Edebug
@subsection Печать в Edebug

@cindex printing (Edebug)
@cindex printing circular structures
@pindex cust-print
  Если выражение в программе создает значение, содержащее круговую структуру
списка, можно получить ошибку, когда Edebug попытается распечатать его.

  Один из способов справиться с круговой структурой - установить
@code{print-length} или @code{print-level}, чтобы урезать печать.  Edebug
сделает это за вас; он связывает @code{print-length} и @code{print-level}
со значениями переменных @code{edebug-print-length} и
@code{edebug-print-level} (при условии, что они имеют значения
не-@code{nil}).  @xref{Output Variables}.

@defopt edebug-print-length
Если не-@code{nil}, Edebug связывает @code{print-length} с этим значением
при печати результатов.  Значение по умолчанию - @code{50}.
@end defopt

@defopt edebug-print-level
Если не-@code{nil}, Edebug связывает @code{print-level} с этим значением
при печати результатов.  Значение по умолчанию - @code{50}.
@end defopt

  Также можете печатать круговые структуры и структуры, которые более
информативно разделяют элементы, привязав @code{print-circle} к значению
не-@code{nil}.

  Вот пример кода, который создает круговую структуру:

@example
(setq a '(x y))
(setcar a a)
@end example

@noindent
Пользовательская печать выводит это как @samp{Result: #1=(#1# y)}.
Обозначение @samp{#1=} маркирует структуру, которая следует за ней, меткой
@samp{1}, а запись @samp{#1#} ссылается на ранее помеченную структуру.  Это
обозначение используется для любых общих элементов списков или векторов.

@defopt edebug-print-circle
Если не-@code{nil}, Edebug связывает @code{print-circle} с этим значением
при печати результатов.  Значение по умолчанию - @code{t}.
@end defopt

  Другие программы также могут использовать настраиваемую печать; подробнее
смотреть @file{cust-print.el}.

@node Trace Buffer
@subsection Буфер Трассировки
@cindex trace buffer

  Edebug может записывать трассировку выполнения, сохраняя ее в буфере с
именем @file{*edebug-trace*}.  Это журнал вызовов и возвратов функций,
показывающий имена функций, их аргументы и значения.  Чтобы включить запись
трассировки, установите для @code{edebug-trace} значение не-@code{nil}.

  Создание буфера трассировки - это не то же самое, что использование режима
 выполнения трассировки (@pxref{Edebug Execution Modes}).

  Когда запись трассировки включена, каждый вход и выход функции добавляет
строки в буфер трассировки.  Запись функции состоит из @samp{::::@{}, за
которой следуют имя функции и значения аргументов.  Запись о выходе функции
состоит из @samp{::::@}}, за которой следуют имя функции и результат
функции.

  Число @samp{:} в записи показывает глубину ее рекурсии.  Можно
использовать фигурные скобки в буфере трассировки, чтобы найти совпадающее
начало или конец вызовов функций.

@findex edebug-print-trace-before
@findex edebug-print-trace-after
  Можно настроить запись трассировки для входа и выхода из функций,
переопределив функции @code{edebug-print-trace-before} и @code{edebug-print-trace-after}.

@defmac edebug-tracing string body@dots{}
Этот макрос запрашивает дополнительную информацию о трассировке выполнения
форм @var{body}.  Аргумент @var{string} указывает текст, помещаемый в буфер
трассировки, после @samp{@{} или @samp{@}}.  Все аргументы оцениваются, и
@code{edebug-tracing} возвращает значение последней формы в @var{body}.
@end defmac

@defun edebug-trace format-string &rest format-args
Эта функция вставляет текст в буфер трассировки.  Вычисляет текст по
средствам @code{(apply 'format @var{format-string} @var{format-args})}.
Также добавляет новую строку к отдельным записям.
@end defun

  @code{edebug-tracing} и @code{edebug-trace} вставляет строки в буфер
трассировки всякий раз, когда они вызываются, даже если Edebug не активен.
Добавление текста в буфер трассировки также прокручивает его окно, чтобы
показать последние вставленные строки.

@node Coverage Testing
@subsection Тестовое Покрытие

@cindex coverage testing (Edebug)
@cindex frequency counts
@cindex performance analysis (Edebug)
  Edebug обеспечивает элементарное тестовое покрытие и отображение частоты
выполнения.

  Тестовое покрытие работает путем сравнения результата каждого выражения с
предыдущим результатом; каждая форма в программе считается покрытой, если
она вернула два разных значения с момента начала тестового покрытия в
текущем сеансе Emacs.  Таким образом, чтобы выполнить тестовое покрытие
программы, выполнить ее при различных условиях и отметить, правильно ли она
ведет себя; Edebug сообщит, когда попробовано достаточно разных условий, что
каждая форма вернула два разных значения.

  Тестовое покрытие замедляет выполнение, поэтому оно выполняется, только
если @code{edebug-test-coverage} установлено в не-@code{nil}.  Подсчет
частоты выполняется для всех выполнений инструментированной функции, даже
если режим выполнения - непрерывный, и независимо от того, включено ли
тестовое покрытие.

@kindex C-x X =
@findex edebug-temp-display-freq-count
  Используется @kbd{C-x X =} (@code{edebug-display-freq-count}), чтобы
отображать как информацию о покрытии, так и частоту для определения.  Просто
@kbd{=} (@code{edebug-temp-display-freq-count}) временно отображает ту же
информацию, только пока не наберана другая клавиша.

@deffn Command edebug-display-freq-count
Эта команда отображает данные подсчета частоты для каждой строки текущего
определения.

Вставляет счетчики частоты в виде строк комментариев после каждой строки
кода.  Можно отменить все вставки с помощью одной команды @code{undo}.
Счетчики отображаются под @samp{(} перед выражением, под @samp{)} после
выражения или на последнем символе переменной.  Для упрощения отображения
счетчик не отображается, если он равен счетчику предыдущего выражения в той
же строке.

Символ @samp{=}, следующий за счетчиком для выражения, означает, что
выражение возвращало одно и то же значение каждый раз, когда оно
вычислялось. Другими словами, это еще не охвачено для целей тестового
покрытия.

Чтобы очистить счетчик частоты и данные покрытия для определения, просто
повторно настроить его с помощью @code{eval-defun}.
@end deffn

Например, после оценки @code{(fac 5)} с исходной точкой останова и установки
@code{edebug-test-coverage} в @code{t}, когда точка останова достигнута,
данные частоты выглядят следующим образом:

@example
(defun fac (n)
  (if (= n 0) (edebug))
;#6           1      = =5
  (if (< 0 n)
;#5         =
      (* n (fac (1- n)))
;#    5               0
    1))
;#   0
@end example

Строки комментариев показывают, что @code{fac} был вызван 6 раз.  Первый
оператор @code{if} возвращал 5 раз с одним и тем же результатом каждый раз;
то же самое верно для условия на втором @code{if}.  Рекурсивный вызов
@code{fac} вообще не вернулся.


@node The Outside Context
@subsection Внешний Контекст

Edebug пытается быть прозрачным для отлаживаемой программы, но это не
удается полностью.  Edebug также пытается быть прозрачным, когда оцениваются
выражения с помощью @kbd{e} или с буфером списка оценки, временно
восстанавливая внешний контекст.  В этом разделе подробно объясняется, какой
контекст восстанавливает Edebug и почему Edebug не может быть полностью
прозрачным.

@menu
* Checking Whether to Stop::    Когда Edebug решает, что делать.
* Edebug Display Update::       Когда Edebug обновляет отображение.
* Edebug Recursive Edit::       Когда Edebug прекращает выполнение.
@end menu

@node Checking Whether to Stop
@subsubsection Проверка Того, Стоит ли Остановиться

Каждый раз, когда вводится Edebug, ему необходимо сохранить и восстановить
определенные данные, прежде чем даже решить, делать ли информацию
трассировки или останавливать программу.

@itemize @bullet
@item
@vindex edebug-max-depth
@code{max-lisp-eval-depth} (@pxref{Eval}) и @code{max-specpdl-size}
(@pxref{Local Variables}) увеличены, чтобы уменьшить влияние Edebug на стек.
Однако при использовании Edebug может не хватить места в стеке.  Также
можно увеличить значение @code{edebug-max-depth}, если Edebug достигает
предела глубины рекурсии инструментированого кода , который содержит очень
большие цитированные списки.

@item
Состояние выполнения макроса клавиатуры сохраняется и восстанавливается.
Пока Edebug активен, @code{executing-kbd-macro} привязан к @code{nil}, если
@code{edebug-continue-kbd-macro} не не-@code{nil}.
@end itemize


@node Edebug Display Update
@subsubsection Обновление Отображения Edebug

@c Этот абзац не заполнен, потому что скрипту преобразования LaLiberte
@c требуется, чтобы внешняя ссылка была только в одной строке.
Когда Edebug нужно что-то отобразить (например, в режиме трассировки), он
сохраняет текущую конфигурацию окна извне Edebug
(@pxref{Window Configurations}).  При выходе из Edebug восстанавливается
предыдущая конфигурация окна.

Emacs отображается повторно только при паузе.  Обычно, когда продолжается
выполнение, программа повторно входит в Edebug в точке останова или после
пошагового выполнения, без приостановки или чтения ввода между ними.  В
таких случаях у Emacs никогда не будет возможности повторно отобразить
внешнюю конфигурацию.  Следовательно, видно ту же конфигурацию окна, что и в
последний раз, когда Edebug был активен, без прерывания.

Вход в Edebug для отображения чего-либо также сохраняет и восстанавливает
следующие данные (хотя некоторые из них намеренно не восстанавливаются при
возникновении ошибки или сигнала выхода).

@itemize @bullet
@item
@cindex current buffer point and mark (Edebug)
Какой буфер является текущим, а также позиции точки и метки в текущем буфере
сохраняются и восстанавливаются.

@item
@cindex window configuration (Edebug)
Конфигурация внешнего окна сохраняется и восстанавливается, если
@code{edebug-save-windows} равен не-@code{nil} (@pxref{Edebug Options}).

Конфигурация окна не восстанавливается при ошибке или выходе, но внешнее
выбранное окно @emph{является} повторно выбиранным даже при ошибке или
закрытии, если @code{save-excursion} активен.  Если значение
@code{edebug-save-windows} является списком, сохраняются и восстанавливаются
только перечисленные окна.

Однако начало окна и горизонтальная прокрутка буфера исходного кода не
восстанавливаются, поэтому отображение в Edebug остается согласованным.

@item
Значение точки в каждом отображаемом буфере сохраняется и восстанавливается,
если @code{edebug-save-displayed-buffer-points} равно не-@code{nil}.

@item
Переменные @code{overlay-arrow-position} и @code{overlay-arrow-string}
сохраняются и восстанавливаются, поэтому можно безопасно вызывать Edebug из
рекурсивного редактирования в другом месте того же буфера.

@item
@code{cursor-in-echo-area} локально привязан к @code{nil}, поэтому курсор
отображается в окне.
@end itemize

@node Edebug Recursive Edit
@subsubsection Рекурсивное Редактирование Edebug

Когда Edebug вводится и фактически считывает команды от пользователя, он
сохраняет (а позже восстанавливает) эти дополнительные данные.:

@itemize @bullet
@item
Текущие данные соответствия.  @xref{Match Data}.

@item
Переменные @code{last-command}, @code{this-command},
@code{last-command-event}, @code{last-input-event},
@code{last-event-frame}, @code{last-nonmenu-event}, и
@code{track-mouse}.  Команды в Edebug не влияют на эти
переменные вне Edebug.

Выполнение команд в Edebug может изменить последовательность ключей,
возвращаемую @code{this-command-keys}, и нет способа сбросить
последовательность ключей из Lisp.

Edebug не может сохранять и восстанавливать значение
@code{unread-command-events}.  Ввод Edebug, когда эта переменная имеет
нетривиальное значение, может помешать выполнению отлаживаемой программы.

@item
Сложные команды, выполняемые в Edebug, добавляются в переменную
@code{command-history}.  В редких случаях это может повлиять на исполнение.

@item
Внутри Edebug глубина рекурсии кажется на единицу глубже, чем глубина
рекурсии вне Edebug.  Это не относится к автоматически обновляемому окну
оценочного списка.

@item
@code{standard-output} и @code{standard-input} привязаны к @code{nil} через
@code{recursive-edit}, но Edebug временно восстанавливает их во время
оценки.

@item
Состояние определения макроса клавиатуры сохраняется и восстанавливается.
Пока Edebug активен, @code{defining-kbd-macro} привязан к
@code{edebug-continue-kbd-macro}.
@end itemize

@node Edebug and Macros
@subsection Edebug и Макросы

Чтобы заставить Edebug правильно использовать выражения, вызывающие макросы,
требуется дополнительная осторожность.  В этом подразделе объясняются
детали.

@menu
* Instrumenting Macro Calls::   Основная проблема.
* Specification List::          Как указать сложные модели оценки.
* Backtracking::                Что делает Edebug при сбое сопоставления.
* Specification Examples::      Чтобы помочь понять спецификации.
@end menu

@node Instrumenting Macro Calls
@subsubsection Инструментирование Макросов

  Когда Edebug инструментирует выражение, которое вызывает макрос Lisp, ему
нужна дополнительная информация о макросе, чтобы правильно выполнить работу.
Это потому, что не существует априорного способа определить, какие
подвыражения макроса являются формами для оценки.  (Оценка может происходить
явно в теле макроса, либо при оценке результирующего раскрытия, либо в любое
время позже.)

  Следовательно, потребуется определить спецификацию Edebug для каждого
макроса, с которым столкнется Edebug, чтобы объяснить формат вызовов этого
макроса.  Для этого добавляется объявление @code{debug} в определение
макроса.  Вот простой пример, который показывает спецификацию макроса
(@pxref{Argument Evaluation}) для примера (@pxref{Argument Evaluation}).

@smallexample
(defmacro for (var from init to final do &rest body)
  "Выполнить простой \"for\" цикл.
Для примера, (for i from 1 to 10 do (print i))."
  (declare (debug (symbolp "from" form "to" form "do" &rest form)))
  ...)
@end smallexample

  В спецификации Edebug указано, какие части вызова макроса являются формами
для оценки.  Для простых макросов спецификация часто очень похожа на
формальный список аргументов определения макроса, но спецификации гораздо
более общие, чем аргументы макроса.  @xref{Defining Macros}, для более
подробного объяснения формы @code{declare}.

@c See, e.g., https://debbugs.gnu.org/10577
@c FIXME  Может быть, должна быть опция Edebug, чтобы он автоматически
@c загружал весь исходный файл, содержащий инструментируемую функцию.
@c Это позволило бы этого избежать.
  Потребуется позаботьтесь о том, чтобы спецификации были известны Edebug,
когда инструментируете код.  Если инструментируете функцию, которая
использует макрос, определенный в другом файле, может сначала потребоваться
либо оценить формы @code{require} в файле, содержащем функцию, либо явно
загрузить файл, содержащий макрос.  Если определение макроса заключено в
@code{eval-when-compile}, может потребоваться его оценить.

  Также можно определить спецификацию edebug для макроса отдельно от
определения макроса с помощью @code{def-edebug-spec}.  Добавление объявлений
@code{debug} является предпочтительным и более удобным для определений
макросов в Lisp, но @code{def-edebug-spec} позволяет определять спецификации
Edebug для специальных форм, реализованных в Cи.

@defmac def-edebug-spec macro specification
Указать, какие выражения вызова макроса @var{macro} являются формами для
оценки.  @var{specification} должен быть спецификацией edebug.  Ни один из
аргументов не оценивается.

Аргумент @var{macro} может быть любым символом, а не только именем макроса.
@end defmac

Вот таблица возможностей @var{specification} и того, как каждый управляет
обработкой аргументов.

@table @asis
@item @code{t}
Все аргументы приспособлены для оценки.

@item @code{0}
Ни один из аргументов не обоснован.

@item a symbol
Символ должен иметь спецификацию Edebug, которая используется вместо этого.
Это косвенное обращение повторяется до тех пор, пока не будет найден другой
вид спецификации.  Это позволяет унаследовать спецификацию от другого
макроса.

@item a list
Элементы списка описывают типы аргументов вызывающей формы.  Возможные
элементы списка спецификаций описаны в следующих разделах.
@end table

Если макрос не имеет спецификации Edebug, ни через объявление @code{debug},
ни через вызов @code{def-edebug-spec}, переменная
@code{edebug-eval-macro-args} вступает в игру.

@defopt edebug-eval-macro-args
Это контролирует способ обработки Edebug аргументов макроса без явной
спецификации Edebug.  Если это @code{nil} (по умолчанию), ни один из
аргументов не инструментирован для оценки.  В противном случае все аргументы
инструментированы.
@end defopt

@node Specification List
@subsubsection Список Спецификаций

@cindex Edebug specification list
@dfn{specification list} требуется для спецификации Edebug, если одни
аргументы вызова макроса оцениваются, а другие нет.  Некоторые элементы в
списке спецификации соответствуют одному или нескольким аргументам, но
другие изменяют обработку всех следующих элементов.  Последние, называемые
@dfn{specification keywords}, представляют собой символы, начинающиеся с
@samp{&} (например, @code{&optional}).

Список спецификации может содержать подсписки, которые соответствуют
аргументам, которые сами по себе являются списками, или он может содержать
векторы, используемые для группировки.  Таким образом, подсписки и группы
подразделяют список спецификаций на иерархию уровней.  Ключевые слова
спецификации применяются только к оставшейся части подсписка или группы, в
которой они содержатся.

Когда список спецификаций включает альтернативы или повторение,
сопоставление его с фактическим вызовом макроса может потребовать
отслеживания с возвратом.  Больше подробностей, @pxref{Backtracking}.

Спецификации Edebug обеспечивают возможность сопоставления регулярных
выражений, а также некоторые контекстно-свободные грамматические
конструкции: сопоставление подсписок со сбалансированными круглыми скобками,
рекурсивную обработку форм и рекурсию через косвенные спецификации.

Вот таблица возможных элементов списка спецификаций с их значениями
(@ref{Specification Examples}, для упомянутых примеров):

@table @code
@item sexp
Единственный неоцененный объект Lisp, который не инструментирован.
@c выражение не обязательно предназначено для оценки.

@item form
Единственное оцененное выражение, которое инструментировано.  Если макрос
заключает выражение в @code{lambda} до его оценки, используется вместо него
@code{def-form}.  Смотреть @code{def-form} below.

@item place
Обобщенная переменная.  @xref{Generalized Variables}.

@item body
Сокращение от @code{&rest form}.  Смотреть @code{&rest} ниже.  Если макрос
заключает свое тело кода в @code{lambda} до его оценки, используется вместо
него @code{def-body}.  Смотреть @code{def-body} ниже.

@item function-form
Функциональная форма: либо цитируемый функциональный символ, цитируемое
лямбда-выражение, либо форма (которая должна оцениваться как функциональный
символ или лямбда-выражение).  Это полезно, когда аргумент, являющийся
лямбда-выражением, может быть заключен в кавычки с помощью @code{quote}, а
не @code{function}, поскольку он в любом случае инструментирует тело
лямбда-выражения.

@item lambda-expr
Лямбда-выражение без кавычек.

@item &optional
@c @kindex &optional @r{(Edebug)}
Все следующие элементы в списке спецификаций являются необязательными; как
только один не совпадает, Edebug прекращает сопоставление на этом уровне.

Чтобы сделать несколько элементов необязательными, за которыми следуют
необязательные элементы, используется @code{[&optional @var{specs}@dots{}]}.
Чтобы указать, что все несколько элементов должны совпадать или не
совпадать, используется @code{&optional [@var{specs}@dots{}]}.  Смотреть
пример @code{defun}.

@item &rest
@c @kindex &rest @r{(Edebug)}
Все следующие элементы в списке спецификаций повторяются ноль или более раз.
Однако в последнем повторении не проблема, если выражение закончится до
того, как сопоставятся все элементы списка спецификаций.

Чтобы повторить только несколько элементов, используйте
@code{[&rest @var{specs}@dots{}]}.  Чтобы указать несколько элементов,
которые должны совпадать при каждом повторении, используйте
@code{&rest [@var{specs}@dots{}]}.

@item &or
@c @kindex &or @r{(Edebug)}
Каждый из следующих элементов в списке спецификаций является альтернативой.
Одна из альтернатив должна совпадать, иначе спецификация @code{&or} не
выполняется.

Каждый элемент списка, следующий за @code{&or}, является единственной
альтернативой.  Чтобы сгруппировать два или более элемента списка как одну
альтернативу, они заключаются в @code{[@dots{}]}.

@item &not
@c @kindex &not @r{(Edebug)}
Каждый из следующих элементов сопоставляется как альтернативы, как если бы с
использованием @code{&or}, но если какой-либо из них соответствует,
спецификация не выполняется.  Если ни один из них не соответствует, ничего
не найдено, но спецификация @code{&not} выполняется успешно.

@c FIXME &key?

@item &define
@c @kindex &define @r{(Edebug)}
Указывает, что спецификация предназначена для определения формы.
Определение формы определения в Edebug - это форма, содержащая одну или
несколько форм кода, которые сохраняются и выполняются позже, после
выполнения формы определения.

Сама определяющая форма не инструментирована (то есть Edebug не
останавливается до и после определяющей формы), но формы внутри нее обычно
будут инструментированы.  Ключевое слово @code{&define} должно быть первым
элементом в спецификации списка.

@item nil
Это успешно, если на текущем уровне списка аргументов больше нет аргументов;
в противном случае это не удается.  Смотреть спецификации подсписок и пример
обратной кавычки.

@item gate
@cindex preventing backtracking
Никакой аргумент не сопоставлен, но обратное отслеживание через шлюз
отключено при сопоставлении остальных спецификаций на этом уровне.  Это в
основном используется для генерации более конкретных сообщений об ошибках
синтаксиса.  Смотреть @ref{Backtracking}, для подробностей.  Смотреть также
@code{let} пример.

@item @var{other-symbol}
@cindex indirect specifications
Любой другой символ в списке спецификаций может быть предикатом или
косвенной спецификацией.

Если символ имеет спецификацию Edebug, эта @dfn{косвенная спецификация}
должна быть либо спецификацией списка, который используется вместо символа,
либо функцией, вызываемой для обработки аргументов.  Спецификация может быть
определена с помощью @code{def-edebug-spec}, как и для макросов.  Смотреть
пример @code{defun}.

В противном случае символ должен быть предикатом.  Предикат вызывается с
аргументом, и если предикат возвращает @code{nil}, спецификация не
выполняется и аргумент не инструментирован.

Некоторые подходящие предикаты включают @code{symbolp}, @code{integerp},
@code{stringp}, @code{vectorp}, и @code{atom}.

@item [@var{elements}@dots{}]
@cindex [@dots{}] (Edebug)
Вектор элементов группирует элементы в одну @dfn{групповую спецификацию}. Его значение не имеет ничего общего с векторами.

@item "@var{string}"
Аргументом должен быть символ с именем @var{string}.  Эта спецификация
эквивалентна заключенному в кавычки символу @code{'@var{symbol}}, где имя
@var{symbol} - это @var{string}, но строковая форма предпочтительнее.

@item (vector @var{elements}@dots{})
Аргументом должен быть вектор, элементы которого должны соответствовать
@var{elements} в спецификации.  Смотреть пример обратной кавычки.

@item (@var{elements}@dots{})
Любой другой список - это @dfn{подсписок спецификации}, а аргумент должен
быть списком, элементы которого соответствуют спецификации @var{elements}.

@cindex dotted lists (Edebug)
Спецификация подсписка может быть точечным списком, а соответствующий
аргумент списка также может быть точечным списком.  В качестве альтернативы,
последний @sc{cdr} спецификации точечного списка может быть другой
спецификацией подсписка (через группировку или косвенную спецификацию,
например, @code{(spec .  [(more specs@dots{})])}), элементы которого
соответствуют аргументам безточечного списка.  Это полезно в рекурсивных
спецификациях, таких как в примере обратных кавычек.  Также смотреть
описание спецификации @code{nil} выше для прекращения такой рекурсии.

Обратить внимание, что спецификация подсписка, записанная как
@code{(specs .  nil)}, эквивалентна @code{(specs)}, а
@code{(specs . (sublist-elements@dots{}))} эквивалентна
@code{(specs sublist-elements@dots{})}.
@end table

@c Необходимо задокументировать расширения с помощью &symbol :symbol

Вот список дополнительных спецификаций, которые могут появиться только после
@code{&define}.  Смотреть пример @code{defun}.

@table @code
@item name
Аргумент, символ - это имя определяющей формы.

Форма определения не требуется, чтобы иметь поле имени; и может иметь
несколько полей имени.

@item :name
Эта конструкция фактически не соответствует аргументу.  Элемент, следующий
за @code{:name}, должен быть символом; он используется как дополнительный
компонент имени для определения.  Можно использовать это, чтобы добавить
уникальный статический компонент к имени определения.  Его можно
использовать более одного раза.

@item arg
Аргумент, символ - это имя аргумента определяющей формы.  Однако ключевые
слова лямбда-списка (символы, начинающиеся с @samp{&}) не допускаются.

@item lambda-list
@cindex lambda-list (Edebug)
Это соответствует лямбда-списку - списку аргументов лямбда-выражения.

@item def-body
Аргумент - это основная часть кода в определении.  Это похоже на
@code{body}, описанное выше, но тело определения должно быть оснащено другим
вызовом Edebug, который ищет информацию, связанную с определением.
Используется @code{def-body} для списка форм самого высокого уровня в
определении.

@item def-form
Аргумент - это единственная форма высшего уровня в определении.  Это похоже
на @code{def-body}, за исключением того, что используется для сопоставления
одной формы, а не списка форм.  В качестве особого случая @code{def-form}
также означает, что информация трассировки не выводится при выполнении
формы.  Смотреть пример @code{interactive}.
@end table

@node Backtracking
@subsubsection Возврат в Спецификациях

@cindex backtracking
@cindex syntax error (Edebug)
Если спецификация не соответствует в какой-то момент, это не обязательно
означает, что будет сигнализироваться синтаксическая ошибка; вместо этого
будет выполняться @dfn{backtracking}, пока не будут исчерпаны все
альтернативы.  В конце концов, каждому элементу списка аргументов должен
соответствовать некоторый элемент в спецификации, и каждый требуемый элемент
в спецификации должен соответствовать некоторому аргументу.

Когда обнаруживается синтаксическая ошибка, о ней может сообщаться не
намного позже, когда альтернативы более высокого уровня будут исчерпаны, и
точка будет расположена дальше от реальной ошибки.  Но если при
возникновении ошибки обратное отслеживание отключено, о ней можно сообщить
немедленно.  Обратить внимание, что в некоторых ситуациях возврат с
возвратом также включается автоматически; когда новая альтернатива
устанавливается @code{&optional}, @code{&rest}, или @code{&or}, или в
начале обработки подсписка, группы или косвенной спецификации.  Эффект
включения или отключения отслеживания с возвратом ограничивается оставшейся
частью уровня, обрабатываемого в данный момент, и более низкими уровнями.

Отслеживание с возвратом отключено при сопоставлении любой из спецификаций
формы (то есть, @code{form}, @code{body}, @code{def-form}, и
@code{def-body}).  Эти спецификации будут соответствовать любой форме,
поэтому любая ошибка должна быть в самой форме, а не на более высоком
уровне.

Отслеживание с возвратом также отключается после успешного сопоставления
указанного символа или строки в кавычках, поскольку это обычно указывает на
распознанную конструкцию.  Но если у есть набор альтернативных конструкций,
которые начинаются с одного и того же символа, обычно можно обойти это
ограничение, вычленив символ из альтернатив, например
@code{["foo" &or [first case] [second case] ...]}.

Большинство потребностей удовлетворяются этими двумя способами
автоматического отключения отслеживания с возвратом, но иногда полезно явно
отключить отслеживание с возвратом с помощью спецификации @code{gate}.  Это
полезно, когда есть уверенность, что альтернативы более высокого уровня не
применимы.  Смотреть пример спецификации @code{let}.

@node Specification Examples
@subsubsection Примеры Спецификаций

Возможно, будет легче понять спецификации Edebug, изучив приведенные здесь
примеры.

Специальная форма @code{let} имеет последовательность привязок и тело.
Каждая из привязок представляет собой символ или подсписок с символом и
необязательным выражением.  В приведенной ниже спецификации обратить
внимание на @code{gate} внутри подсписка, чтобы предотвратить поиск с
возвратом после нахождения подсписка.

@ignore
@c FIXME?  Фактическое определение в edebug.el выглядит так (и всегда имеет 
@c AFAICS).  Фактически, ничто в edebug.el не использует гейт. Так, может
@c  быть, это просто пример для иллюстрации?
(def-edebug-spec let
  ((&rest
    &or (symbolp &optional form) symbolp)
   body))
@end ignore
@example
(def-edebug-spec let
  ((&rest
    &or symbolp (gate symbolp &optional form))
   body))
@end example

Edebug использует следующие спецификации для @code{defun} и связанного
списка аргументов и спецификаций @code{interactive}.  Интерактивные формы
необходимо обрабатывать специально, поскольку аргумент выражения фактически
вычисляется вне тела функции.  (Спецификация @code{defmacro} очень похожа
на спецификацию @code{defun}, но позволяет использовать оператор
@code{declare}.)

@smallexample
(def-edebug-spec defun
  (&define name lambda-list
           [&optional stringp]; @r{Сопоставить строку документа, если есть.}
           [&optional ("interactive" interactive)]
           def-body))

(def-edebug-spec lambda-list
  (([&rest arg]
    [&optional ["&optional" arg &rest arg]]
    &optional ["&rest" arg]
    )))

(def-edebug-spec interactive
  (&optional &or stringp def-form))    ; @r{Уведомление: @code{def-form}}
@end smallexample

В спецификации обратной кавычки ниже показано, как сопоставить точечные
списки и использовать @code{nil} для завершения рекурсии.  Также
показывается, как можно сопоставить компоненты вектора.  (Фактическая
спецификация, определенная Edebug, немного отличается и не поддерживает
точечные списки, потому что это вызывает очень глубокую рекурсию, которая
может привести к сбою.)

@smallexample
(def-edebug-spec \` (backquote-form))   ; @r{Псевдоним для ясности.}

(def-edebug-spec backquote-form
  (&or ([&or "," ",@@"] &or ("quote" backquote-form) form)
       (backquote-form . [&or nil backquote-form])
       (vector &rest backquote-form)
       sexp))
@end smallexample


@node Edebug Options
@subsection Параметры Edebug

  Эти параметры влияют на поведение Edebug:
@c Previously defopt'd:
@c edebug-sit-for-seconds, edebug-print-length, edebug-print-level
@c edebug-print-circle, edebug-eval-macro-args

@defopt edebug-setup-hook
Функции, вызываемые перед использованием Edebug.  Каждый раз, когда
устанавливается новое значение, Edebug вызывает эти функции один раз, а
затем сбрасывает @code{edebug-setup-hook} в @code{nil}.  Можно использовать
это для загрузки спецификаций Edebug, связанных с используемым пакетом, но
только если также используется Edebug.
@xref{Instrumenting}.
@end defopt

@defopt edebug-all-defs
Если это не-@code{nil}, обычная оценка определяющих форм, таких как
@code{defun} и @code{defmacro}, определяет их для Edebug.  Это
относится к @code{eval-defun}, @code{eval-region}, @code{eval-buffer},
и @code{eval-current-buffer}.

Используется команда @kbd{M-x edebug-all-defs}, чтобы переключить значение
этой опции.  @xref{Instrumenting}.
@end defopt

@defopt edebug-all-forms
Если это не-@code{nil}, команды @code{eval-defun}, @code{eval-region},
@code{eval-buffer}, и @code{eval-current-buffer} обрабатывают все формы,
даже те, которые ничего не определяют.  Это не относится к загрузке или
оценки в минибуфере.

Использовать команду @kbd{M-x edebug-all-forms}, чтобы переключить значение
этой опции.  @xref{Instrumenting}.
@end defopt

@defopt edebug-eval-macro-args
Когда не-@code{nil}, все аргументы макроса будут инструментированы в
сгенерированном коде.  Для любого макроса @code{edebug-form-spec} отменяет
эту опцию.  Таким образом, чтобы указать исключения для макросов, некоторые
аргументы которых оцениваются, а некоторые нет, используется
@code{def-edebug-spec}, чтобы указать @code{edebug-form-spec}.
@end defopt

@defopt edebug-save-windows
Если это не-@code{nil}, Edebug сохраняет и восстанавливает конфигурацию
окна.  Это займет некоторое время, поэтому, если программе все равно, что
происходит с конфигурациями окон, лучше установить для этой переменной
значение @code{nil}.

Если значением является список, сохраняются и восстанавливаются только
перечисленные окна.

Можно использовать команду @kbd{W} в Edebug для интерактивного изменения
этой переменной.  @xref{Edebug Display Update}.
@end defopt

@defopt edebug-save-displayed-buffer-points
Если это не-@code{nil}, Edebug сохраняет и восстанавливает точку во всех
отображаемых буферах.

Сохранение и восстановление точки в других буферах необходимо, если
отлаживается код, который изменяет точку буфера, отображаемую в невыбранном
окне.  Если Edebug или пользователь затем выбирает окно, точка в этом буфере
переместится на значение точки для окна.

Сохранение и восстановление точки во всех буферах обходится дорого, так как
для этого нужно дважды выбирать каждое окно, поэтому включается это, только
если это нужно.  @xref{Edebug Display Update}.
@end defopt

@defopt edebug-initial-mode
Если эта переменная - не-@code{nil}, она указывает начальный режим
выполнения для Edebug при его первой активации.  Возможные значения:
@code{step}, @code{next}, @code{go}, @code{Go-nonstop}, @code{trace},
@code{Trace-fast}, @code{continue}, и @code{Continue-fast}.

Значение по умолчанию - @code{step}.  Эта переменная может быть установлена
интерактивно с помощью @kbd{C-x C-a C-m} (@code{edebug-set-initial-mode}).
@xref{Edebug Execution Modes}.
@end defopt

@defopt edebug-trace
Если это не-@code{nil}, отслеживать вход и выход каждой функции.  Выходные
данные трассировки отображаются в буфере с именем @file{*edebug-trace*}, по
одному входу или выходу функции на строку, с отступом по уровню рекурсии.

Смотреть также @code{edebug-tracing}, в @ref{Trace Buffer}.
@end defopt

@defopt edebug-test-coverage
Если не-@code{nil}, Edebug проверяет покрытие всех отлаженных выражений.
@xref{Coverage Testing}.
@end defopt

@defopt edebug-continue-kbd-macro
Если не-@code{nil}, продолжать определение или выполнение любого макроса
клавиатуры, который выполняется вне Edebug.  Использовать это с
осторожностью, так как это не отлажено.
@xref{Edebug Execution Modes}.
@end defopt

@defopt edebug-print-length
Если не-@code{nil}, значение по умолчанию @code{print-length} для печати
приводит к Edebug.  @xref{Output Variables}.
@end defopt

@defopt edebug-print-level
Если не-@code{nil}, значение по умолчанию @code{print-level} для печати
приводит к Edebug.  @xref{Output Variables}.
@end defopt

@defopt edebug-print-circle
Если не-@code{nil}, значение по умолчанию @code{print-circle} для печати
приводит к Edebug.  @xref{Output Variables}.
@end defopt

@defopt edebug-unwrap-results
Если не-@code{nil}, Edebug пытается удалить любой из своих инструментов при
отображении результатов выражений.  Это актуально при отладке макросов, в
которых результаты выражений сами являются инструментированными выражениями.
В качестве очень искусственного примера предпологается, что примерная
функция @code{fac} была оснащена инструментированием, и рассматривается
макрос вида:

@c FIXME найти менее глупый пример.
@smallexample
(defmacro test () "Edebug example."
  (if (symbol-function 'fac)
      @dots{}))
@end smallexample

Если инструментируется макрос @code{test} и проходится через него, то по
умолчанию результат вызова @code{symbol-function} имеет множество форм
@code{edebug-after} и @code{edebug-before}, что может затруднить просмотр
фактического результата.  Если @code{edebug-unwrap-results} равно
не-@code{nil}, Edebug пытается удалить эти формы из результата.
@end defopt

@defopt edebug-on-error
Edebug привязывает @code{debug-on-error} к этому значению, если
@code{debug-on-error} ранее был @code{nil}.  @xref{Trapping Errors}.
@end defopt

@defopt edebug-on-quit
Edebug привязывает @code{debug-on-quit} к этому значению, если
@code{debug-on-quit} ранее был @code{nil}.  @xref{Trapping Errors}.
@end defopt

  Если изменить значения @code{edebug-on-error} или @code{edebug-on-quit},
пока Edebug активен, их значения не будут использоваться до тех пор, пока не
будет вызван новой командой @emph{следующий} Edebug.
@c Не обязательно более глубокий командный уровень. Новая команда не
@c совсем верна, но это достаточно близко - дан

@defopt edebug-global-break-condition
Если не-@code{nil}, выражение для проверки в каждой точке останова.  Если
результат не-@code{nil}, то останов.  Ошибки игнорируются.
@xref{Global Break Condition}.
@end defopt

@defopt edebug-sit-for-seconds
Количество секунд для паузы при достижении точки останова и режиме
выполнения - трассировка или продолжение.  @xref{Edebug Execution Modes}.
@end defopt

@defopt edebug-sit-on-break
Следует ли делать паузу для @code{edebug-sit-for-seconds} при достижении
точки останова.  Установить @code{nil} для предотвращения останова и
не-@code{nil}, чтобы разрешить.
@end defopt
