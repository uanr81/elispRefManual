@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2019 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Symbols
@chapter Символы
@cindex symbol

  @dfn{Символ} представляет собой объект с уникальным именем.  В этой главе
  описаны символы, их компоненты, их списки свойств, а также способы их
  создания и интернирования.  Отдельные главы описывают использование
  символов в качестве переменных и как имена функций; смотреть
  @ref{Variables}, и @ref{Functions}.  Точный синтаксис чтения для символов,
  смотреть @ref{Symbol Type}.

  Вы можете проверить произвольный объект Lisp, является ли он символом
  с помощью предиката @code{symbolp}:

@defun symbolp object
Функция возвращает @code{t} если @var{object} является символом, @code{nil}
в другом случае.
@end defun

@menu
* Symbol Components::        Символ имеет имя, значение, определение
                             функции и список свойств.
* Definitions::              Определяется, как будет использоваться символ.
* Creating Symbols::         Как символы сохраняются уникальными.
* Symbol Properties::        Каждый символ имеет список свойств для
                             записи разнообразной информации.
@end menu

@node Symbol Components
@section Компоненты Символа
@cindex symbol components

  Каждый символ имеет четыре компоненты (или ``ячейки''), каждая из которых
  ссылается на другой объект:

@table @asis
@item Print name
@cindex print name cell
Ячейка содержит имя символа.

@item Value
@cindex value cell
Ячейка содержит текущее значение символа в качестве переменной.

@item Function
@cindex function cell
Ячейка содержит текущее определение символа в качестве функции.  Также может
содержать символ, раскладку клавиатуры или клавиатурный макрос.
(ВопросSymbol54)

@item Property list
@cindex property list cell
Ячейка содержит список свойств символа.
@end table

@noindent
Компонента ячейка имени всегда содержит строку, и не может быть изменена.
Каждая из трех других компонент может содержать любой объект Lisp.

  Компонента с ячейкой имени содержит строку, которая является именем
  символа.  Поскольку символы представлены текстуально своими именами, важно,
  не иметь два символа с одним и тем же именем.  Читатель Lisp обеспечивает
  это: каждый раз, при чтении символа, ищется существующий символ с указанным
  именем, прежде чем создать новый.  Для получения имени символа,
  используется функция @code{symbol-name} (@pxref{Creating Symbols}).

  Компонента с ячейкой значения символа, является тем, что
  получается, если сам символ оцениваются как выражение Lisp.
  @xref{Variables}, для получения подробной информации о том, как значения
  устанавливаются и извлекаются, включая такие осложнения, как
  @dfn{локальная привязка} и @dfn{область действия}.  Большинство символов
  могут иметь любой объект Lisp в качестве значения, но некоторые специальные
  символы имеют значение, которое не может быть изменено; это символы
  @code{nil} и @code{t} и любой символ, имя которого начинается с @samp{:}
  (они называются @dfn{ключевыми словами}).  @xref{Constant Variables}.

  Компонента с ячейкой функции содержит определение символа как функции.
  Часто употребляется ``функция @code{foo}'', когда имеется в виду функция,
  хранящаяся в компоненте символа ячейка функции @code{foo}; делается
  различие явно только при необходимости.  Как правило, ячейка функции
  используются для хранения функции (@pxref{Functions}) или макроса
  (@pxref{Macros}).  Тем не менее, также может быть использована для хранения
  символа (@pxref{Function Indirection}), клавиатурного макроса
  (@pxref{Keyboard Macros}), раскладки клавиатуры (@pxref{Keymaps}) или
  объекта автозагрузка (@pxref{Autoloading}).  К содержимому ячейки функции
  обращаются функцией @code{symbol-function} (@pxref{Function Cells}).

  Компонента содержащая ячейку списка свойств символа содержит правильно
  отформатированный список свойств.  Для доступа к списку свойств символа,
  используется функция @code{symbol-plist}.  @xref{Symbol Properties}.

  Компоненты ячейка функции или ячейка значения могут быть @dfn{void}, что
  означает, что ячейка не ссылается на какой-либо объект.  (Это не то же
  самое, когда содержится символ @code{void}, и ни то же самое, когда
  содержится символ @code{nil}.).  Проверка ячейки функции или ячейки
  значения, которая не ссылается ни на что, приводит к ошибке, такой как
  @samp{Symbol's value as variable is void}
  (@samp{Значение символа как переменный является недействительным}).

  Поскольку каждый символ имеет отдельные компоненты хранения ячейки значения
  и ячейки функции, обращение к одному и тому же символу как к функции или
  как к переменной не противоречат друг другу.  Например, символ
  @code{buffer-file-name} имеет значение (имя файла, который посетил в
  текущий буфер), а также определение функции (примитивную функцию, которая
  возвращает имя файла):

@example
buffer-file-name
     @result{} "/gnu/elisp/symbols.texi"
(symbol-function 'buffer-file-name)
     @result{} #<subr buffer-file-name>
@end example

@node Definitions
@section Определение Cимвола
@cindex definitions of symbols

  @dfn{Определение} это особый вид Lisp выражения, которое объявляет о своем
  намерении использовать символ определенным образом.  Это, как правило,
  определяет вид использования значения символа, а также документацию по его
  значению, когда используется определённым образом.  Поэтому, при
  определении символа в качестве переменной, устанавливается начальное
  значение переменной, а также документация по переменной.

  @code{defvar} и @code{defconst} специальные формы, которые определяют
  символ как @dfn{глобальная переменная}---переменная, которая может быть
  доступна из любой точки и в любой момент в программе Lisp.
  @xref{Variables}, для получения подробной информации о переменных. Чтобы
  определить переменную настройки, используется @code{defcustom} макрос,
  который также вызывает @code{defvar} в качестве подпрограммы
  (@pxref{Customization}).

  В принципе, можно присвоить значение переменной любому символу используя
  @code{setq}, не зависимо от того, была ли определена компонента символа
  ячейка значения.  Тем не менее, требуется писать определение переменной для
  каждой глобальной переменной, которая будет использоваться; в противном
  случае, ваша программа Lisp не сможет правильно действовать, когда при
  оценки будет учитываться лексическая областью видимости
  (@pxref{Variable Scoping}).

  @code{defun} определяет символ как функцию, создавая лямбда-выражения и
  сохраняя его в компоненте символа ячейке функции.  Таким образом, это
  лямбда-выражение становится определением символа как функции. (Термин
  ``определение функции'', то есть содержимое компоненты символа ячейка
  функции, происходит от идеи, что @code{defun} определяет символ в виде
  функции.).  @code{defsubst} и @code{defalias} два других способа
  определения функции.  @xref{Functions}.

  @code{defmacro} определяет символ как макроc.  Cоздаётся макрообъект и
  и сохраняется в компоненте символа ячейки функции.  Следует отметить, что
  данный символ может быть либо макросом, либо функцией, но не обоими сразу,
  потому что и определения символа как макроса, так и функции сохраняются в
  одной и той же компоненте символа ячейки функции, и эта ячейка может
  содержать только один объект Lisp в один момент времени. @xref{Macros}.

  Как было отмечено ранее, Emacs Lisp позволяет определять один и тот же
  символ, как в качестве переменной (например, с @code{defvar}) так и в виде
  функции или макроса (например, с @code{defun}). Такие определения не
  порождают противоречия.

  Такие определения также выступают в качестве руководства для инструментов
  программирования.  Например, команды @kbd{C-h f} и @kbd{C-h v} создают
  справочные буфера, содержащие ссылки на соответствующие переменные, функции
  или макроопределения.  @xref{Name Help,,, emacs, The GNU Emacs Manual}.

@node Creating Symbols
@section Создание и Интернирование Символа
@cindex reading symbols

  Чтобы понять, как символы создаются в GNU Emacs Lisp, нужно знать, как Lisp
  читает их.  Lisp должен гарантировать, что находится один и тот же символ
  каждый раз, когда читается один и тот же буквенный набор символов.
  Несоблюдение этого правила приведет к полной путанице.

@cindex symbol name hashing
@cindex hashing
@cindex obarray
@cindex bucket (in obarray)
  Когда читатель Lisp встречает символ, считываются все буквенные символы
  имени.  Вычисляется хэш этих символов (индекс), число представляющее индекс
  в таблице, называемой @dfn{obarray (объектный массив)}.  Хэш является
  эффективным способом найти что-нибудь.  Например, вместо того, чтобы
  искать от корки до корки в телефонной книге номер Яна Джонса, поиск
  начинается со страниц начинающихся с буквы Я и далле оттуда.  Это простая
  версия хеширования.  Каждый элемент obarray является
  @dfn{bucket (корзиной)}, котораая содержит все символы с заданным
  хэш-кодом; чтобы отыскать заданное имя, достаточно просмотреть все символы
  в корзине на предмет хэш-кода этого имени.  (Та же идея используется для
  общих хэш-таблиц Emacs, но это другой тип данных; смотреть
  @ref{Hash Tables}.) (ВопросSymbol194)

@cindex interning
  Если символ с заданным именем найден, то читатель Lisp использует этот
  символ.  Если obarray не содержит символ с таким именем, читатель создаёт
  новый символ и добавляет его в obarray.  Обнаружение или добавление символа
  с определенным именем называется @dfn{интернированием}, а символ затем
  называется @dfn{интернированым символом}.

  Интернирование гарантирует, что каждый obarray имеет только один символ с
  любым определенным именем.  Другие одноименные символы могут существовать,
  но не в том же obarray.  Таким образом, читатель получает один и тот же
  символ для одного и тогоже имени, пока продолжается чтение с одним и тем же
  obarray.

  Интернирование обычно происходит автоматически в читателе, но иногда это
  требуется и другим программам.  Например, после того, как командой
  @kbd{M-x} получается имя команды в виде строки, используя минибуфер,
  происходит обработка этой строки, чтобы получить интернированный символ с
  таким именем.

@cindex symbol equality
@cindex uninterned symbol
  Нет obarray который содержит все символы; на самом деле, некоторые символы
  не состаят ни в одном obarray.  Они называются
  @dfn{неинтернированными символами}.  Неинтернированный символ имеет те же
  четыре компоненты, как и другие символы; однако, единственный способ
  получить доступ к нему - найти его в каком-либо другом объекте или в
  качестве значения переменной.

  Создание неинтернированного символа полезно при генерации кода Lisp, так
  как неинтернированный символ, используемый в качестве переменной в коде
  не может конфликтовать с любыми переменными, используемыми в других
  программах Lisp.

  В Emacs Lisp, obarray на самом деле вектор.  Каждый элемент вектора
  представляет собой корзину; его значение либо интернированный символ, имя
  которого хэшируется в это корзину, или 0, если корзина пуста.  Каждый
  интернировано символ имеет внутреннюю связь (невидимую для пользователя) со
  следующим символе в корзине.  Поскольку эти связи незримы, нет никакого
  способа, чтобы найти все символы в obarray, за исключением использования
  @code{mapatoms} (ниже).  Порядок символов в корзине не имеет существенного
  значения.

  В пустом obarray, каждый элемент равен 0, так что можно создать obarray с
  помощью @code{(make-vector @var{length} 0)}.
  @strong{Это единственный допустимый способ создания obarray.}.  Простые
  числа для @var{length}, как правило, приводят к хорошему хешированию;
  @var{length} на еденицу меньше степени двойки также хороши.
  (ВопросSymbol.243)

  @strong{Do not try to put symbols in an obarray yourself.}  This does
not work---only @code{intern} can enter a symbol in an obarray properly.

@cindex CL note---symbol in obarrays
@quotation
@b{Common Lisp note:} Unlike Common Lisp, Emacs Lisp does not provide
for interning a single symbol in several obarrays.
@end quotation

  Most of the functions below take a name and sometimes an obarray as
arguments.  A @code{wrong-type-argument} error is signaled if the name
is not a string, or if the obarray is not a vector.

@defun symbol-name symbol
This function returns the string that is @var{symbol}'s name.  For example:

@example
@group
(symbol-name 'foo)
     @result{} "foo"
@end group
@end example

@strong{Warning:} Changing the string by substituting characters does
change the name of the symbol, but fails to update the obarray, so don't
do it!
@end defun

@defun make-symbol name
This function returns a newly-allocated, uninterned symbol whose name is
@var{name} (which must be a string).  Its value and function definition
are void, and its property list is @code{nil}.  In the example below,
the value of @code{sym} is not @code{eq} to @code{foo} because it is a
distinct uninterned symbol whose name is also @samp{foo}.

@example
(setq sym (make-symbol "foo"))
     @result{} foo
(eq sym 'foo)
     @result{} nil
@end example
@end defun

@defun gensym &optional prefix
This function returns a symbol using @code{make-symbol}, whose name is
made by appending @code{gensym-counter} to @var{prefix}.  The prefix
defaults to @code{"g"}.
@end defun

@defun intern name &optional obarray
This function returns the interned symbol whose name is @var{name}.  If
there is no such symbol in the obarray @var{obarray}, @code{intern}
creates a new one, adds it to the obarray, and returns it.  If
@var{obarray} is omitted, the value of the global variable
@code{obarray} is used.

@example
(setq sym (intern "foo"))
     @result{} foo
(eq sym 'foo)
     @result{} t

(setq sym1 (intern "foo" other-obarray))
     @result{} foo
(eq sym1 'foo)
     @result{} nil
@end example
@end defun

@cindex CL note---interning existing symbol
@quotation
@b{Common Lisp note:} In Common Lisp, you can intern an existing symbol
in an obarray.  In Emacs Lisp, you cannot do this, because the argument
to @code{intern} must be a string, not a symbol.
@end quotation

@defun intern-soft name &optional obarray
This function returns the symbol in @var{obarray} whose name is
@var{name}, or @code{nil} if @var{obarray} has no symbol with that name.
Therefore, you can use @code{intern-soft} to test whether a symbol with
a given name is already interned.  If @var{obarray} is omitted, the
value of the global variable @code{obarray} is used.

The argument @var{name} may also be a symbol; in that case,
the function returns @var{name} if @var{name} is interned
in the specified obarray, and otherwise @code{nil}.

@example
(intern-soft "frazzle")        ; @r{No such symbol exists.}
     @result{} nil
(make-symbol "frazzle")        ; @r{Create an uninterned one.}
     @result{} frazzle
@group
(intern-soft "frazzle")        ; @r{That one cannot be found.}
     @result{} nil
@end group
@group
(setq sym (intern "frazzle"))  ; @r{Create an interned one.}
     @result{} frazzle
@end group
@group
(intern-soft "frazzle")        ; @r{That one can be found!}
     @result{} frazzle
@end group
@group
(eq sym 'frazzle)              ; @r{And it is the same one.}
     @result{} t
@end group
@end example
@end defun

@defvar obarray
This variable is the standard obarray for use by @code{intern} and
@code{read}.
@end defvar

@defun mapatoms function &optional obarray
@anchor{Definition of mapatoms}
This function calls @var{function} once with each symbol in the obarray
@var{obarray}.  Then it returns @code{nil}.  If @var{obarray} is
omitted, it defaults to the value of @code{obarray}, the standard
obarray for ordinary symbols.

@example
(setq count 0)
     @result{} 0
(defun count-syms (s)
  (setq count (1+ count)))
     @result{} count-syms
(mapatoms 'count-syms)
     @result{} nil
count
     @result{} 1871
@end example

See @code{documentation} in @ref{Accessing Documentation}, for another
example using @code{mapatoms}.
@end defun

@defun unintern symbol obarray
This function deletes @var{symbol} from the obarray @var{obarray}.  If
@code{symbol} is not actually in the obarray, @code{unintern} does
nothing.  If @var{obarray} is @code{nil}, the current obarray is used.

If you provide a string instead of a symbol as @var{symbol}, it stands
for a symbol name.  Then @code{unintern} deletes the symbol (if any) in
the obarray which has that name.  If there is no such symbol,
@code{unintern} does nothing.

If @code{unintern} does delete a symbol, it returns @code{t}.  Otherwise
it returns @code{nil}.
@end defun

@node Symbol Properties
@section Symbol Properties
@cindex symbol property

  A symbol may possess any number of @dfn{symbol properties}, which
can be used to record miscellaneous information about the symbol.  For
example, when a symbol has a @code{risky-local-variable} property with
a non-@code{nil} value, that means the variable which the symbol names
is a risky file-local variable (@pxref{File Local Variables}).

  Each symbol's properties and property values are stored in the
symbol's property list cell (@pxref{Symbol Components}), in the form
of a property list (@pxref{Property Lists}).

@menu
* Symbol Plists::        Accessing symbol properties.
* Standard Properties::  Standard meanings of symbol properties.
@end menu

@node Symbol Plists
@subsection Accessing Symbol Properties

  The following functions can be used to access symbol properties.

@defun get symbol property
This function returns the value of the property named @var{property}
in @var{symbol}'s property list.  If there is no such property, it
returns @code{nil}.  Thus, there is no distinction between a value of
@code{nil} and the absence of the property.

The name @var{property} is compared with the existing property names
using @code{eq}, so any object is a legitimate property.

See @code{put} for an example.
@end defun

@defun put symbol property value
This function puts @var{value} onto @var{symbol}'s property list under
the property name @var{property}, replacing any previous property value.
The @code{put} function returns @var{value}.

@example
(put 'fly 'verb 'transitive)
     @result{}'transitive
(put 'fly 'noun '(a buzzing little bug))
     @result{} (a buzzing little bug)
(get 'fly 'verb)
     @result{} transitive
(symbol-plist 'fly)
     @result{} (verb transitive noun (a buzzing little bug))
@end example
@end defun

@defun symbol-plist symbol
This function returns the property list of @var{symbol}.
@end defun

@defun setplist symbol plist
This function sets @var{symbol}'s property list to @var{plist}.
Normally, @var{plist} should be a well-formed property list, but this is
not enforced.  The return value is @var{plist}.

@example
(setplist 'foo '(a 1 b (2 3) c nil))
     @result{} (a 1 b (2 3) c nil)
(symbol-plist 'foo)
     @result{} (a 1 b (2 3) c nil)
@end example

For symbols in special obarrays, which are not used for ordinary
purposes, it may make sense to use the property list cell in a
nonstandard fashion; in fact, the abbrev mechanism does so
(@pxref{Abbrevs}).

You could define @code{put} in terms of @code{setplist} and
@code{plist-put}, as follows:

@example
(defun put (symbol prop value)
  (setplist symbol
            (plist-put (symbol-plist symbol) prop value)))
@end example
@end defun

@defun function-get symbol property &optional autoload
This function is identical to @code{get}, except that if @var{symbol}
is the name of a function alias, it looks in the property list of the
symbol naming the actual function.  @xref{Defining Functions}.  If the
optional argument @var{autoload} is non-@code{nil}, and @var{symbol}
is auto-loaded, this function will try to autoload it, since
autoloading might set @var{property} of @var{symbol}.  If
@var{autoload} is the symbol @code{macro}, only try autoloading if
@var{symbol} is an auto-loaded macro.
@end defun

@defun function-put function property value
This function sets @var{property} of @var{function} to @var{value}.
@var{function} should be a symbol.  This function is preferred to
calling @code{put} for setting properties of a function, because it
will allow us some day to implement remapping of old properties to new
ones.
@end defun

@node Standard Properties
@subsection Standard Symbol Properties

  Here, we list the symbol properties which are used for special
purposes in Emacs.  In the following table, whenever we say ``the
named function'', that means the function whose name is the relevant
symbol; similarly for ``the named variable'' etc.

@table @code
@item :advertised-binding
This property value specifies the preferred key binding, when showing
documentation, for the named function.  @xref{Keys in Documentation}.

@item char-table-extra-slots
The value, if non-@code{nil}, specifies the number of extra slots in
the named char-table type.  @xref{Char-Tables}.

@item customized-face
@itemx face-defface-spec
@itemx saved-face
@itemx theme-face
These properties are used to record a face's standard, saved,
customized, and themed face specs.  Do not set them directly; they are
managed by @code{defface} and related functions.  @xref{Defining
Faces}.

@item customized-value
@itemx saved-value
@itemx standard-value
@itemx theme-value
These properties are used to record a customizable variable's standard
value, saved value, customized-but-unsaved value, and themed values.
Do not set them directly; they are managed by @code{defcustom} and
related functions.  @xref{Variable Definitions}.

@item disabled
If the value is non-@code{nil}, the named function is disabled as a
command.  @xref{Disabling Commands}.

@item face-documentation
The value stores the documentation string of the named face.  This is
set automatically by @code{defface}.  @xref{Defining Faces}.

@item history-length
The value, if non-@code{nil}, specifies the maximum minibuffer history
length for the named history list variable.  @xref{Minibuffer
History}.

@item interactive-form
The value is an interactive form for the named function.  Normally,
you should not set this directly; use the @code{interactive} special
form instead.  @xref{Interactive Call}.

@item menu-enable
The value is an expression for determining whether the named menu item
should be enabled in menus.  @xref{Simple Menu Items}.

@item mode-class
If the value is @code{special}, the named major mode is special.
@xref{Major Mode Conventions}.

@item permanent-local
If the value is non-@code{nil}, the named variable is a buffer-local
variable whose value should not be reset when changing major modes.
@xref{Creating Buffer-Local}.

@item permanent-local-hook
If the value is non-@code{nil}, the named function should not be
deleted from the local value of a hook variable when changing major
modes.  @xref{Setting Hooks}.

@item pure
@cindex @code{pure} property
If the value is non-@code{nil}, the named function is considered to be
pure (@pxref{What Is a Function}).  Calls with constant arguments can
be evaluated at compile time.  This may shift run time errors to
compile time.  Not to be confused with pure storage (@pxref{Pure
Storage}).

@item risky-local-variable
If the value is non-@code{nil}, the named variable is considered risky
as a file-local variable.  @xref{File Local Variables}.

@item safe-function
If the value is non-@code{nil}, the named function is considered
generally safe for evaluation.  @xref{Function Safety}.

@item safe-local-eval-function
If the value is non-@code{nil}, the named function is safe to call in
file-local evaluation forms.  @xref{File Local Variables}.

@item safe-local-variable
The value specifies a function for determining safe file-local values
for the named variable.  @xref{File Local Variables}.

@item side-effect-free
@cindex @code{side-effect-free} property
A non-@code{nil} value indicates that the named function is free of
side effects (@pxref{What Is a Function}), so the byte compiler may
ignore a call whose value is unused.  If the property's value is
@code{error-free}, the byte compiler may even delete such unused
calls.  In addition to byte compiler optimizations, this property is
also used for determining function safety (@pxref{Function Safety}).

@item variable-documentation
If non-@code{nil}, this specifies the named variable's documentation
string.  This is set automatically by @code{defvar} and related
functions.  @xref{Defining Faces}.
@end table
