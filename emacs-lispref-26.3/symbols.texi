@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2019 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Symbols
@chapter Символы
@cindex symbol

  @dfn{Символ} представляет собой объект с уникальным именем.  В этой главе
  описаны символы, их компоненты, их списки свойств, а также способы их
  создания и интернирования.  Отдельные главы описывают использование
  символов в качестве переменных и как имена функций; смотреть
  @ref{Variables}, и @ref{Functions}.  Точный синтаксис чтения для символов,
  смотреть @ref{Symbol Type}.

  Вы можете проверить произвольный объект Lisp, является ли он символом
  с помощью предиката @code{symbolp}:

@defun symbolp object
Функция возвращает @code{t} если @var{object} является символом, @code{nil}
в другом случае.
@end defun

@menu
* Symbol Components::        Символ имеет имя, значение, определение
                             функции и список свойств.
* Definitions::              Определяется, как будет использоваться символ.
* Creating Symbols::         Как символы сохраняются уникальными.
* Symbol Properties::        Каждый символ имеет список свойств для
                             записи разнообразной информации.
@end menu

@node Symbol Components
@section Компоненты Символа
@cindex symbol components

  Каждый символ имеет четыре компоненты (или ``ячейки''), каждая из которых
  ссылается на другой объект:

@table @asis
@item Print name
@cindex print name cell
Ячейка содержит имя символа.

@item Value
@cindex value cell
Ячейка содержит текущее значение символа в качестве переменной.

@item Function
@cindex function cell
Ячейка содержит текущее определение символа в качестве функции.  Также может
содержать символ, раскладку клавиатуры или клавиатурный макрос.
(ВопросSymbol54)

@item Property list
@cindex property list cell
Ячейка содержит список свойств символа.
@end table

@noindent
Компонента ячейка имени всегда содержит строку, и не может быть изменена.
Каждая из трех других компонент может содержать любой объект Lisp.

  Компонента с ячейкой имени содержит строку, которая является именем
  символа.  Поскольку символы представлены текстуально своими именами, важно,
  не иметь два символа с одним и тем же именем.  Читатель Lisp обеспечивает
  это: каждый раз, при чтении символа, ищется существующий символ с указанным
  именем, прежде чем создать новый.  Для получения имени символа,
  используется функция @code{symbol-name} (@pxref{Creating Symbols}).

  Компонента с ячейкой значения символа, является тем, что
  получается, если сам символ оцениваются как выражение Lisp.
  @xref{Variables}, для получения подробной информации о том, как значения
  устанавливаются и извлекаются, включая такие осложнения, как
  @dfn{локальная привязка} и @dfn{область действия}.  Большинство символов
  могут иметь любой объект Lisp в качестве значения, но некоторые специальные
  символы имеют значение, которое не может быть изменено; это символы
  @code{nil} и @code{t} и любой символ, имя которого начинается с @samp{:}
  (они называются @dfn{ключевыми словами}).  @xref{Constant Variables}.

  Компонента с ячейкой функции содержит определение символа как функции.
  Часто употребляется ``функция @code{foo}'', когда имеется в виду функция,
  хранящаяся в компоненте символа ячейка функции @code{foo}; делается
  различие явно только при необходимости.  Как правило, ячейка функции
  используются для хранения функции (@pxref{Functions}) или макроса
  (@pxref{Macros}).  Тем не менее, также может быть использована для хранения
  символа (@pxref{Function Indirection}), клавиатурного макроса
  (@pxref{Keyboard Macros}), раскладки клавиатуры (@pxref{Keymaps}) или
  объекта автозагрузка (@pxref{Autoloading}).  К содержимому ячейки функции
  обращаются функцией @code{symbol-function} (@pxref{Function Cells}).

  Компонента содержащая ячейку списка свойств символа содержит правильно
  отформатированный список свойств.  Для доступа к списку свойств символа,
  используется функция @code{symbol-plist}.  @xref{Symbol Properties}.

  Компоненты ячейка функции или ячейка значения могут быть @dfn{void}, что
  означает, что ячейка не ссылается на какой-либо объект.  (Это не то же
  самое, когда содержится символ @code{void}, и ни то же самое, когда
  содержится символ @code{nil}.).  Проверка ячейки функции или ячейки
  значения, которая не ссылается ни на что, приводит к ошибке, такой как
  @samp{Symbol's value as variable is void}
  (@samp{Значение символа как переменный является недействительным}).

  Поскольку каждый символ имеет отдельные компоненты хранения ячейки значения
  и ячейки функции, обращение к одному и тому же символу как к функции или
  как к переменной не противоречат друг другу.  Например, символ
  @code{buffer-file-name} имеет значение (имя файла, который посетил в
  текущий буфер), а также определение функции (примитивную функцию, которая
  возвращает имя файла):

@example
buffer-file-name
     @result{} "/gnu/elisp/symbols.texi"
(symbol-function 'buffer-file-name)
     @result{} #<subr buffer-file-name>
@end example

@node Definitions
@section Определение Cимвола
@cindex definitions of symbols

  @dfn{Определение} это особый вид Lisp выражения, которое объявляет о своем
  намерении использовать символ определенным образом.  Это, как правило,
  определяет вид использования значения символа, а также документацию по его
  значению, когда используется определённым образом.  Поэтому, при
  определении символа в качестве переменной, устанавливается начальное
  значение переменной, а также документация по переменной.

  @code{defvar} и @code{defconst} специальные формы, которые определяют
  символ как @dfn{глобальная переменная}---переменная, которая может быть
  доступна из любой точки и в любой момент в программе Lisp.
  @xref{Variables}, для получения подробной информации о переменных. Чтобы
  определить переменную настройки, используется @code{defcustom} макрос,
  который также вызывает @code{defvar} в качестве подпрограммы
  (@pxref{Customization}).

  В принципе, можно присвоить значение переменной любому символу используя
  @code{setq}, не зависимо от того, была ли определена компонента символа
  ячейка значения.  Тем не менее, требуется писать определение переменной для
  каждой глобальной переменной, которая будет использоваться; в противном
  случае, ваша программа Lisp не сможет правильно действовать, когда при
  оценки будет учитываться лексическая областью видимости
  (@pxref{Variable Scoping}).

  @code{defun} определяет символ как функцию, создавая лямбда-выражения и
  сохраняя его в компоненте символа ячейке функции.  Таким образом, это
  лямбда-выражение становится определением символа как функции. (Термин
  ``определение функции'', то есть содержимое компоненты символа ячейка
  функции, происходит от идеи, что @code{defun} определяет символ в виде
  функции.).  @code{defsubst} и @code{defalias} два других способа
  определения функции.  @xref{Functions}.

  @code{defmacro} определяет символ как макроc.  Cоздаётся макрообъект и
  и сохраняется в компоненте символа ячейки функции.  Следует отметить, что
  данный символ может быть либо макросом, либо функцией, но не обоими сразу,
  потому что и определения символа как макроса, так и функции сохраняются в
  одной и той же компоненте символа ячейки функции, и эта ячейка может
  содержать только один объект Lisp в один момент времени. @xref{Macros}.

  Как было отмечено ранее, Emacs Lisp позволяет определять один и тот же
  символ, как в качестве переменной (например, с @code{defvar}) так и в виде
  функции или макроса (например, с @code{defun}). Такие определения не
  порождают противоречия.

  Такие определения также выступают в качестве руководства для инструментов
  программирования.  Например, команды @kbd{C-h f} и @kbd{C-h v} создают
  справочные буфера, содержащие ссылки на соответствующие переменные, функции
  или макроопределения.  @xref{Name Help,,, emacs, The GNU Emacs Manual}.

@node Creating Symbols
@section Создание и Интернирование Символа
@cindex reading symbols

  Чтобы понять, как символы создаются в GNU Emacs Lisp, нужно знать, как Lisp
  читает их.  Lisp должен гарантировать, что находится один и тот же символ
  каждый раз, когда читается один и тот же буквенный набор символов.
  Несоблюдение этого правила приведет к полной путанице.

@cindex symbol name hashing
@cindex hashing
@cindex obarray
@cindex bucket (in obarray)
  Когда читатель Lisp встречает символ, считываются все буквенные символы
  имени.  Вычисляется хэш этих символов (индекс), число представляющее индекс
  в таблице, называемой @dfn{obarray (объектный массив)}.  Хэш является
  эффективным способом найти что-нибудь.  Например, вместо того, чтобы
  искать от корки до корки в телефонной книге номер Яна Джонса, поиск
  начинается со страниц начинающихся с буквы Я и далле оттуда.  Это простая
  версия хеширования.  Каждый элемент obarray является
  @dfn{bucket (корзиной)}, котораая содержит все символы с заданным
  хэш-кодом; чтобы отыскать заданное имя, достаточно просмотреть все символы
  в корзине на предмет хэш-кода этого имени.  (Та же идея используется для
  общих хэш-таблиц Emacs, но это другой тип данных; смотреть
  @ref{Hash Tables}.) (ВопросSymbol194)

@cindex interning
  Если символ с заданным именем найден, то читатель Lisp использует этот
  символ.  Если obarray не содержит символ с таким именем, читатель создаёт
  новый символ и добавляет его в obarray.  Обнаружение или добавление символа
  с определенным именем называется @dfn{интернированием}, а символ затем
  называется @dfn{интернированым символом}.

  Интернирование гарантирует, что каждый obarray имеет только один символ с
  любым определенным именем.  Другие одноименные символы могут существовать,
  но не в том же obarray.  Таким образом, читатель получает один и тот же
  символ для одного и тогоже имени, пока продолжается чтение с одним и тем же
  obarray.

  Интернирование обычно происходит автоматически в читателе, но иногда это
  требуется и другим программам.  Например, после того, как командой
  @kbd{M-x} получается имя команды в виде строки, используя минибуфер,
  происходит обработка этой строки, чтобы получить интернированный символ с
  таким именем.

@cindex symbol equality
@cindex uninterned symbol
  Нет obarray который содержит все символы; на самом деле, некоторые символы
  не состаят ни в одном obarray.  Они называются
  @dfn{неинтернированными символами}.  Неинтернированный символ имеет те же
  четыре компоненты, как и другие символы; однако, единственный способ
  получить доступ к нему - найти его в каком-либо другом объекте или в
  качестве значения переменной.

  Создание неинтернированного символа полезно при генерации кода Lisp, так
  как неинтернированный символ, используемый в качестве переменной в коде
  не может конфликтовать с любыми переменными, используемыми в других
  программах Lisp.

  В Emacs Lisp, obarray на самом деле вектор.  Каждый элемент вектора
  представляет собой корзину; его значение либо интернированный символ, имя
  которого хэшируется в это корзину, или 0, если корзина пуста.  Каждый
  интернировано символ имеет внутреннюю связь (невидимую для пользователя) со
  следующим символе в корзине.  Поскольку эти связи незримы, нет никакого
  способа, чтобы найти все символы в obarray, за исключением использования
  @code{mapatoms} (ниже).  Порядок символов в корзине не имеет существенного
  значения.

  В пустом obarray, каждый элемент равен 0, так что можно создать obarray с
  помощью @code{(make-vector @var{length} 0)}.
  @strong{Это единственный допустимый способ создания obarray.}.  Простые
  числа для @var{length}, как правило, приводят к хорошему хешированию;
  @var{length} на еденицу меньше степени двойки также хороши.
  (ВопросSymbol.243)

  @strong{Не пытайтесь вносить символы в obarray самостоятельно.}  Это не
  сработает---только @code{intern} может внести символ в obarray правильно.

@cindex CL note---symbol in obarrays
@quotation
@b{Common Lisp замечание:} В отличие от Common Lisp, Emacs Lisp не
обеспечивает интернирование одного символа в нескольких obarrays.
@end quotation

  Большинство функций, описанных ниже, принимают в качестве аргумента имя, а
  иногда obarray.  Ошибка @code{wrong-type-argument} сигнализируется, если
  имя не является строкой, или если obarray не является вектором.

@defun symbol-name symbol
Функция возвращает строку, которая является именем @var{symbol}ов. Например:

@example
@group
(symbol-name 'foo)
     @result{} "foo"
@end group
@end example

@strong{Предупреждение:} Изменение строки имени, путем замены буквенных
символов меняет имя символа, но это не отражается обновлением obarray, так
что не делайте этого!
@end defun

@defun make-symbol name
Функция возвращает вновь выделенный, неинтернированный символ, имя которого
@var{name} (которое должно быть строкой).  Его компоненты символа: ячейки
значения и ячейки функции являются недействительными, а список свойств
установлен в @code{nil}.  В приведенном ниже примере, значение @code{sym}
не удовлетворяет  @code{eq} к @code{foo}, потому что это отдельный
неинтернированный символ, имя которого также @samp{foo}.

@example
(setq sym (make-symbol "foo"))
     @result{} foo
(eq sym 'foo)
     @result{} nil
@end example
@end defun

@defun gensym &optional prefix
Функция возвращает символ с использованием @code{make-symbol}, имя которого
получается путем добавления @code{gensym-counter} к @var{prefix}. Префикс по
умолчанию @code{"g"}.(ВопросSymbol293)
@end defun

@defun intern name &optional obarray
Функция возвращает интернированый символ, имя которого @var{name}.  Если нет
такого символа в obarray @var{obarray}, @code{intern} создает новый,
добавляет его в obarray, и возвращает его.  Если @var{obarray} опущен,
используется значение глобальной переменной @code{obarray}.

@example
(setq sym (intern "foo"))
     @result{} foo
(eq sym 'foo)
     @result{} t

(setq sym1 (intern "foo" other-obarray))
     @result{} foo
(eq sym1 'foo)
     @result{} nil
@end example
@end defun

@cindex CL note---interning existing symbol
@quotation
@b{Common Lisp предупреждение:} В Common Lisp, вы можете поместить
существующий символ в obarray.  В Emacs Lisp, вы не можете этого сделать,
потому что аргумент @code{intern} должен быть строкой, а не символом.
@end quotation

@defun intern-soft name &optional obarray
Функция возвращает символ из @var{obarray}, имя которого @var{name}, или
@code{nil} если @var{obarray} не имеет символа с таким именем.  Таким
образом, вы можете использовать @code{intern-soft}, чтобы проверить, является
ли символ с указанным именем уже интернированным.  Если @var{obarray} опущен,
используется значение глобальной переменной @code{obarray}.

Аргумент @var{name} также может быть символом; в этом случае возвращается
@var{name} если есть интернированный символ с именем @var{name} в указанном
obarray @code{obarray}, а в противном случае возвращается @code{nil}.

@example
(intern-soft "испытуемый")        ; @r{Нет, такого символа не существует.}
     @result{} nil
(make-symbol "испытуемый")        ; @r{Создание неитернированного символа.}
     @result{} испытуемый
@group
(intern-soft "испытуемый")        ; @r{Не найдено.}
     @result{} nil
@end group
@group
(setq sym (intern "испытуемый"))  ; @r{Создание интернированного символа.}
     @result{} испытуемый
@end group
@group
(intern-soft "испытуемый")        ; @r{Найден!}
     @result{} испытуемый
@end group
@group
(eq sym 'испытуемый)              ; @r{Одно и тоже.}
     @result{} t
@end group
@end example
@end defun

@defvar obarray
Переменная - стандартный obarray для использования в @code{intern} и
@code{read}.
@end defvar

@defun mapatoms function &optional obarray
@anchor{Definition of mapatoms}
Функция вызывает функцию @var{function} один раз с каждым символом в obarray
@var{obarray}.  Затем возвращается @code{nil}.  Если @var{obarray} опущен, то
используется значение по умолчанию в переменнй @code{obarray}, стандартный
obarray для обычных символов.

@example
(setq count 0)
     @result{} 0
(defun count-syms (s)
  (setq count (1+ count)))
     @result{} count-syms
(mapatoms 'count-syms)
     @result{} nil
count
     @result{} 1871
@end example

Смотреть @code{documentation} в @ref{Accessing Documentation}, ещё пример
использования @code{mapatoms}.
@end defun

@defun unintern symbol obarray
Функция удаляет @var{symbol} из obarray @var{obarray}.  Если @code{symbol}
отсутствует в obarray, @code{unintern} ничего не делает.  Если @var{obarray}
установлен в @code{nil}, используется текущий obarray.

Если вы предоставляете строку вместо символа в @var{symbol}, это выступает
в роли имени символа.  Затем @code{unintern} удаляет символ (если такой
имеется) из obarray по его имени.  Если нет искомого символа, @code{unintern}
ничего не делает.

Если функцией @code{unintern} действительно был удалён символ, возвращается
@code{t}.  В противном случае возвращается @code{nil}.
@end defun

@node Symbol Properties
@section Свойства Символа
@cindex symbol property

  Символ может иметь любое количество @dfn{свойств символа}, которые можно
  использовать для записи разнообразной информации о символе.  Например,
  когда символ имеет свойство @code{risky-local-variable} установленное в
  не-@code{nil}, это означает, что символ с заданным именем в своей
  компоненте ячейки значения, содержит опасную локальную переменную файла
  (@pxref{File Local Variables}).

  Свойства и их значения, каждого символа хранятся в компоненте символа
  ячейки свойств (@pxref{Symbol Components}) в форме списка свойств
  (@pxref{Property Lists}).

@menu
* Symbol Plists::        Доступ к свойствам символа.
* Standard Properties::  Стандартные значения свойств символов.
@end menu

@node Symbol Plists
@subsection Доступ к Свойствам Символа

  Следующие функции могут быть использованы для доступа к свойствам символа.

@defun get symbol property
Функция возвращает значение свойства под названием @var{property} из списка
свойств символа @var{symbol}.  Если требуемого свойства нет, возвращается
@code{nil}.  Таким образом, нельзя определить разницу между тем что, свойство
с указаным названием не существует или же оно содержит значение @code{nil}.

Название свойства, переданное аргументом @var{property}, сравнивается со
всеми существующими свойствами символами с помощью @code{eq}, поэтому
любой объект можен выступать в роли свойства.(ВопросSymbol432)

Смотреть @code{put} для примера.
@end defun

@defun put symbol property value
Функция помещает значение @var{value} в список свойств символа @var{symbol}
в свойство @var{property}, заменяя любое предыдущее значение свойства.
Функция @code{put} возвращает значение @var{value}.

@example
(put 'fly 'verb 'transitive)
     @result{}'transitive
(put 'fly 'noun '(a buzzing little bug))
     @result{} (a buzzing little bug)
(get 'fly 'verb)
     @result{} transitive
(symbol-plist 'fly)
     @result{} (verb transitive noun (a buzzing little bug))
@end example
@end defun

@defun symbol-plist symbol
Функция возвращает список свойств  символа @var{symbol}.
@end defun

@defun setplist symbol plist
Функция устанавливает символу @var{symbol} список свойств @var{plist}.
Обычно список свойств @var{plist} должен быть хорошо сформированый список, но
это не является обязанельным.  Возвращаемое значение - @var{plist}.

@example
(setplist 'foo '(a 1 b (2 3) c nil))
     @result{} (a 1 b (2 3) c nil)
(symbol-plist 'foo)
     @result{} (a 1 b (2 3) c nil)
@end example

Для символов состоящих в специальных obarrays, которые не используются для
обычных целей, может иметь смысл использовать компоненту символа с ячейкой
списка свойств нестандартным образом; на самом деле, механизм сокращений
использует это (@pxref{Abbrevs}).

Можно определить @code{put} в терминах @code{setplist} и @code{plist-put}
следующим образом:

@example
(defun put (symbol prop value)
  (setplist symbol
            (plist-put (symbol-plist symbol) prop value)))
@end example
@end defun

@defun function-get symbol property &optional autoload
Функция идентична @code{get}, за исключением того, что если @var{symbol}
носит имя псевдонима функции, просматривается список свойств символа в поиске
имени реальной функции. @xref{Defining Functions}.  Если необязательный аргумент @var{autoload} установлен в не-@code{nil} и @var{symbol} является
автоматически загружаемым, функция будет пытаться выполнить автозагрузку его,
так как может установить свойства @var{property} у загруженного символа
@var{symbol}.  Если символ @var{symbol} представляет собой @code{макрос} и
@var{autoload} установлен в не-@code{nil}, производится попытка автозагрузки,
если @var{symbol} является автоматически загружаемым макросом.
(ВопросSymbol493)
@end defun

@defun function-put function property value
Функция устанавливает функции @var{function} свойству @var{property}
значение @var{value}.  Аргумент @var{function} должен быть символом.  Вызов
этой функции является предпочтительнее вызова @code{put} для настройки
свойств функции, потому что это позволяет осуществить переназначение старых
значений свойств в новые.(ВопросSymbol502)
@end defun

@node Standard Properties
@subsection Стандартные Свойства Символа

  Здесь перечисляются свойства символов, которые используются для специальных
  целей в Emacs.  В следующей таблице, когда написано ``именуемая функция'',
  это означает, что функция, чье имя является соответствующим печатным именем
  символа; аналогично для ``именуемая переменная'' и т.д.

@table @code
@item :advertised-binding
Свойство определяет предпочтительную привязку клавиш, при вызове показа
документации, для именуемой.  @xref{Keys in Documentation}.

@item char-table-extra-slots
Значение, если установлено в не-@code{nil}, определяет количество
дополнительных слотов в указаном типе символ-таблицы.  @xref{Char-Tables}.

@item customized-face
@itemx face-defface-spec
@itemx saved-face
@itemx theme-face
Эти свойства используются для записи стандартных, сохраняемых, настраеваемых
и тематических характеристик лица.  Не устанавливаются непосредственно; они
управляются @code{defface} и связанных с этим функциями.
@xref{Defining Faces}. (ВопросSymbol529 ? Баян какой-то, какие ещё лица?)
 
@item customized-value
@itemx saved-value
@itemx standard-value
@itemx theme-value
Эти свойства используются для записи стандартного значения настраиваемой
переменной, сохраненного значения, настроенного, но несохраненного значения и
тематических значений. Не устанавливайте их непосредственно; они управляются
@code{defcustom} и связанных с этим функциями(ВопросSymbols538 баян
продолжается).  @xref{Variable Definitions}.

@item disabled
Если значение свойства не-@code{nil}, именованная функция отключена как
команда.  @xref{Disabling Commands}.

@item face-documentation
Значение свойства хранит строку документации названного лица.  Это
устанавливается автоматически @code{defface}(ВопросSymbol547).
@xref{Defining Faces}.

@item history-length
Установленное значение свойства в не-@code{nil}, определяет максимальную
длину истории Минибуфера для именованной переменнойо списка истории.
@xref{Minibuffer History}.

@item interactive-form
Значение свойства представляет собой интерактивную форму для именованной
функции.  Как правило, не должно устанавливаться непосредственно;
использовать вместо этого специальную форму @code{interactive}.
@xref{Interactive Call}.

@item menu-enable
Значение свойства определяет выражение для определения того, следует ли
указанный пункт меню буть включен в меню.  @xref{Simple Menu Items}.

@item mode-class
Если значение свойства установленно в @code{special}, указанный основной
режим является особенным.  @xref{Major Mode Conventions}.

@item permanent-local
Если значение установленно в не-@code{nil}, именованная переменная является
локальной переменной буфера, значение которой не должно быть сброшено при
изменении основных режимов.  @xref{Creating Buffer-Local}.

@item permanent-local-hook
Если значение свойства установленно в не-@code{nil}, именованная функция не
должна быть удалена из значения локальной переменной-ловушки при изменении
основных режимов.  @xref{Setting Hooks}.

@item pure
@cindex @code{pure} property
Если значение установленно в не-@code{nil}, именованная функция считается
чистой (@pxref{What Is a Function}).  Вызовы с постоянными аргументами могут
быть оценены во время компиляции.  Это может сместить ошибки времени
выполнения на время компиляции.  Не следует путать с чистым хранилищем
(@pxref{Pure Storage}). (ВопросSymbols585)

@item risky-local-variable
Если значение свойства установленно в не-@code{nil}, именованная переменная
считается как опаснвя локальная переменная файла.
@xref{File Local Variables}.

@item safe-function
Если значение свойства установлено в не-@code{nil}, именованная функция
считается в целом безопасной для оценки.  @xref{Function Safety}.

@item safe-local-eval-function
Если значение свойства установленно в не-@code{nil}, именованная функция
безопасна для вызова в формах локального файла для оценки.
@xref{File Local Variables}.

@item safe-local-variable
Значение свойства определяет функцию для определения безопасных имён
переменных локального файла.  @xref{File Local Variables}.

@item side-effect-free
@cindex @code{side-effect-free} property
Значение свойства установленное в не-@code{nil} указывает на то, что
именованная функция не создаёт побочных эффектов
(@pxref{What Is a Function}), так что байт компилятор может игнорировать
вызов, значение которого не используется.  Если значение свойства равно
@code{error-free}, байт-компилятор может даже удалить неиспользуемые такие
вызовы.  В дополнение к оптимизации байт-компилятор, это свойство также
используется для определения безопасности функции (@pxref{Function Safety}).

@item variable-documentation
Если установлено значение свойства в не-@code{nil}, это указывает строку
документации именованной переменной.  Это устанавливается автоматически
@code{defvar} и связанными с ними функциями.  @xref{Defining Faces}.
@end table
