@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998, 2001-2019 Free Software Foundation,
@c Inc.
@c See the file elisp.texi for copying conditions.
@node Macros
@chapter Макросы
@cindex macros

  @dfn{Макросы} позволяют определить новые элементы управления и другие
  функции языка. Макрос определяется так же, как функции, но вместо того,
  чтобы сообщать, как вычислить значение, он сообщает, как вычислить
  другое выражение Lisp, которое, в свою очередь вычислить значение.
  Мы называем это выражение @dfn{расширением} макроса.

  Макросы могут сделать это, потому что они оперируют неоценёнными выражениями
  для аргументов, а не значениями аргументов, как функции. Таким образом,
  они могут создать расширение, содержащее эти выражения
  аргументов или их части.

  Если вы используете макрос, для выполнения чего-то, что могла сделать обычная
  функция, только ради скорости, рассмотрите возможность использования вместо
  этого встроенной функции.  @xref{Inline Functions}.

@menu
* Simple Macro::            Простой пример.
* Expansion::               Как, когда и почему макросы расширяются.
* Compiling Macros::        Как макросы расширяются компилятором.
* Defining Macros::         Как написать определение макроса.
* Problems with Macros::    Не оценивайте аргументы макроса слишком много раз.
                              Не скрывайте переменные пользователя.
* Indenting Macros::        Определение отступа при вызовах макросов.
@end menu

@node Simple Macro
@section Простой пример макроса

  Предположим, что мы хотели бы определить конструкцию Lisp для увеличения
  значения переменной, так же, как оператор @code{++} в C@. Мы хотели бы
  написать @code{(inc x)} и получить эффект @code{(setq x (1+ x))}.
  Вот определение макроса, который делает свою работу:

@findex inc
@example
@group
(defmacro inc (var)
   (list 'setq var (list '1+ var)))
@end group
@end example

  Когда вызывается @code{(inc x)}, аргумент @var{var} символ
  @code{x}---@emph{не}  @emph{значение} @code{x}, как это было
  бы в функции. В теле макроса это используется для построения расширения,
  в данном случае @code{(setq x (1+ x))}. Как только определение макроса
  возвращает это расширение, Lisp оценить его, таким образом, увеличив
  @code{x}.

@defun macrop object
Этот предикат проверяет является ли аргумент макросом, и возвращает @code{t}
если да, и @code{nil} если иначе.
@end defun

@node Expansion
@section Расширение Вызова Макроса
@cindex expansion of macros
@cindex macro call

  Вызов макроса выглядит так же, как вызов функции, поскольку это список,
  который начинается с именем макроса. Остальные элементы списка
  являются аргументами макроса.

  Оценка вызова макроса начинается так же, как оценки вызова функции,
  за исключением одного существенного различия: аргументы макроса -
  это фактические выражения, появляющиеся в вызове макроса. Они не
  не оцениваются до того, как будут переданы в определение макроса.
  Напротив, аргументы функции - это результаты оценки элементов
  списка вызова функции.

  Получив аргументы, Lisp вызывает определение макроса так же, как
  вызывает определение функции.  Аргументы макроса связаны со
  значениями переменных аргументов вызова макроса, или с их
  списком в случае @code{&rest} аргумента. Тело макроса выполняется
  и возвращается его значение как тело функции.

  Второе решающее различие между макросами и функциями является то,
  что значение, возвращаемое телом макроса является альтернативным
  выражением Lisp, также известное как @dfn{расширение} макроса.
  Интерпретатор Lisp переходит к оценки расширения, как только оно
  возвращается из макроса.

  Поскольку расширение оценивается обычным образом, оно может содержать
  вызовы других макросов. Это может быть даже вызов того же макроса,
  хотя это выглядит необычно.

  Обратите внимание, что Emacs пытается расширять макросы при загрузке
  некомпилированного файла Lisp. Это выполняется не всегда, но если это
  происходит, это ускоряет последующее выполнение.
  @xref{How Programs Do Loading}.

  Вы можете увидеть расширение нужного макроса вызвав @code{macroexpand}.

@defun macroexpand form &optional environment
@cindex macro expansion
Эта функция расширяет @var{form}, если это вызов макроса. Если результатом
является еще один вызов макроса, он, в свою очередь, расширяется до тех пор,
пока не будет получен результат, не являющийся вызовом макроса. Это и будет
значение, возвращаемое @code{macroexpand}. Если @var{form} не вызов макроса,
возвращается такая же @var{form} как заданная.

Обратите внимание, что @code{macroexpand} не смотрит на подвыражения
@var{form} (хотя некоторые макроопределения могут сделать это).
Даже если они сами являются макросами, @code{macroexpand} не расширяет их.

Функция @code{macroexpand} не расширяет вызововы встроенных функций.
Обычно в этом нет необходимости, поскольку вызов встроенной функции
не сложнее понять, чем вызов обычной функции.

Если задана @var{среда}, она указывает ассоциативный список определений
макросов, которые перекрывают макросы, определенные в данный момент. При байт
компиляции используется эта функция.

@example
@group
(defmacro inc (var)
    (list 'setq var (list '1+ var)))
@end group

@group
(macroexpand '(inc r))
     @result{} (setq r (1+ r))
@end group

@group
(defmacro inc2 (var1 var2)
    (list 'progn (list 'inc var1) (list 'inc var2)))
@end group

@group
(macroexpand '(inc2 r s))
     @result{} (progn (inc r) (inc s))  ; @r{@code{inc} не расширяется здесь.}
@end group
@end example
@end defun


@defun macroexpand-all form &optional environment
@code{macroexpand-all} расширяет макросы, как @code{macroexpand}, но будет
искать и расширять все макросы в @var{form}, а не только на высшем уровне.
Если никаких макросов не будет расширено, возвращаемое значение
@code{eq} @var{form}.

Повторяя пример, используемый для @code{macroexpand} выше для @code{macroexpand-all},
мы видим, что @code{macroexpand-all} @emph{действительно} расширяют встроенные
вызовы на @code{inc}:

@example
(macroexpand-all '(inc2 r s))
     @result{} (progn (setq r (1+ r)) (setq s (1+ s)))
@end example

@end defun

@defun macroexpand-1 form &optional environment
Эта функция расширяет макросы, как @code{macroexpand}, но она выполняет
только один шаг расширения: если результатом является другой вызов макроса,
@code{macroexpand-1} не будет расширять его.
@end defun

@node Compiling Macros
@section Макросы и Байт Компиляцмя
@cindex byte-compiling macros

  Вы можете спросить, почему мы берём на себя труд вычислить расширение
  для макроса, а затем оценить расширение. Почему бы не сделать так,
  чтобы тело макроса напрямую не давало желаемых результатов?
  Причина связана с компиляцией.

  Когда в компилируемой программе Lisp появляется вызов макроса, Lisp
  компилятор вызывает определение макроса точно также как интерпретатор,
  и получает расширение. Но вместо того, чтобы оценить это расширение,
  он компилирует расширение, как если бы оно появилось непосредственно
  в программе. В результате скомпилированный код создаёт значение и
  побочные эффекты, предназначенные для макроса, но выполняется на
  полной скорости компиляции. Это не будет работать, если тело макроса
  вычисляет значения и использует побочные эффекты --- они будут
  вычислены во время компиляции, а при выполнении является бесполезными.

  Чтобы компиляция вызовов макросов работала, макросы уже должны быть
  определены в Lisp, когда вызовы к ним компилируются. У Компилятора
  есть специальная функция, которая поможет вам сделать это: если
  компилируемый файл содержит форму @code{defmacro}, макрос определяется
  временно для остальной части компиляции этого файла.

  При байт-компиляции файла также выполняются любые @code{require} вызовы
  на верхнем уровне файла, поэтому вы должны гарантировать, что
  необходимые определения макросов доступны во время компиляции,
  предоставляя файлы, которые определяют их (@pxref{Named Features}).
  Чтобы избежать загрузки файлов определения макросов, когда кто-то
  @emph{запускает} скомпилированную программу, напишите
  @code{eval-when-compile} вокруг @code{require} вызовов
  (@pxref{Eval During Compile}).

@node Defining Macros
@section Определение Макросов
@cindex defining macros
@cindex macro, how to define

  В Lisp макро объект это список, чей @sc{car} является @code{macro},
  и @sc{cdr} является функцией. Расширение макроса работает путем применения
  функции (к @code{apply}) к списку @emph{неоценённых} аргументов
  из вызова макроса.

  Можно использовать анонимный макрос Lisp так же, как анонимную функцию,
  но это никогда не делается, потому что это не имеет смысла, передавать
  анонимный макрос функциям, таким как @code{mapcar}. На практике
  все макросы Lisp имеют имена, и они почти всегда определяется с помощью
  @code{defmacro} макроса.

@defmac defmacro name args [doc] [declare] body@dots{}
@code{defmacro} определяет имя @var{name} символа (которое не следует
заключать в кавычки) как макрос, который выглядит следующим образом:

@example
(macro lambda @var{args} . @var{body})
@end example

(Обратите внимание, что @sc{cdr} этого списка является лямбда-выражение.)
Этот объект макроса сохраняется в функциональной ячейки @var{name}.
Значение @var{args} такое же, как в функции, а также ключевые слова
@code{&rest} и @code{&optional} могут быть использованы
(@pxref{Argument List}). Ни @var{name}, ни @var{args} не должны быть
заключенены в кавычки. Возвращаемое значение @code{defmacro} не определено.

@var{doc}, если он присутствует, должен быть строкой, определяющей
строку документации макроса. @var{declare}, если она присутствует,
должна быть форма @code{declare} определяющая метаданные для макроса.
(@pxref{Declare Form}). Обратите внимание, что макросы не могут
иметь интерактивных объявлений, так как они не могут быть вызваны
в интерактивном режиме.
@end defmac

  Макросы часто нуждаются в создании структур списков из смеси
  констант и переменных частей.  Чтобы упростить это, используйте
  синтаксис @samp{`} (@pxref{Backquote}). Например:

@example
@example
@group
(defmacro t-becomes-nil (variable)
  `(if (eq ,variable t)
       (setq ,variable nil)))
@end group

@group
(t-becomes-nil foo)
     @equiv{} (if (eq foo t) (setq foo nil))
@end group
@end example
@end example

@node Problems with Macros
@section Общие Проблемы Использования Макросов
@cindex macro caveats

  Расширение макросов может иметь в последствии противоречия. В этом
  разделе описываются некоторые важные последствия, которые могут
  привести к неприятностям, и правила, которым нужно следовать,
  чтобы избежать неприятностей.

@menu
* Wrong Time::             Работайте в расширении, а не в макросе.
* Argument Evaluation::    В расширение следует оценивать каждый АРГУМЕНТ макроса один раз.
* Surprising Local Vars::  Привязки локальных переменных в расширенни требуют особой осторожности.
* Eval During Expansion::  Не оценивать их; поместите их в расширении.
* Repeated Expansion::     Избегайте зависимости от того, сколько раз выполняется расширение.
@end menu

@node Wrong Time
@subsection Оценка не в то Время

  Наиболее распространенная проблема в написании макросов заключается в
  преждевременном выполнении некоторой реальной работы---при расширении
  макроса, а не в самом расширении. Например, у одного реального пакета
  было это определение макроса:

@example
(defmacro my-set-buffer-multibyte (arg)
  (if (fboundp 'set-buffer-multibyte)
      (set-buffer-multibyte arg)))
@end example

С этим ошибочным определением макроса программа работала нормально при
интерпретации, но не выполнялась при компиляции. Это определение
макроса вызвало @code{set-buffer-multibyte} во время компиляции, что не
нужно было, а затем ничего не делало, когда скомпилированный пакет был
запущен. Определение, которое программист действительно хотел это:

@example
(defmacro my-set-buffer-multibyte (arg)
  (if (fboundp 'set-buffer-multibyte)
      `(set-buffer-multibyte ,arg)))
@end example

@noindent
Этот макрос расширяется, в случае необходимости, до вызова
@code{set-buffer-multibyte}, который будет выполняться при
фактическом запуске скомпилированной программы.

@node Argument Evaluation
@subsection Повторная Оценка Аргументов Макроса

  При определении макроса необходимо обратить внимание на то,
  сколько раз аргументы будут оценеваться при выполнении расширения.
  Следующий макрос (используется для облегчения итерации)
  иллюстрирует проблему. Этот макрос позволяет нам написать
  конструкцию цикла @code{for}.

@findex for
@example
@group
(defmacro for (var from init to final do &rest body)
  "Выполнить простой \"for\" цикл.
Для примера, (for i from 1 to 10 do (print i))."
  (list 'let (list (list var init))
        (cons 'while
              (cons (list '<= var final)
                    (append body (list (list 'inc var)))))))
@end group

@group
(for i from 1 to 3 do
   (setq square (* i i))
   (princ (format "\n%d %d" i square)))
@expansion{}
@end group
@group
(let ((i 1))
  (while (<= i 3)
    (setq square (* i i))
    (princ (format "\n%d %d" i square))
    (inc i)))
@end group
@group

     @print{}1       1
     @print{}2       4
     @print{}3       9
@result{} nil
@end group
@end example

@noindent
Аргументы @code{from}, @code{to}, и @code{do} в этом макросе
являются синтаксическим сахаром; они полностью игнорируются. Идея
заключается в том, что вы будете писать заданные слова
(например, @code{from}, @code{to}, и @code{do}) в нужных позициях,
при вызове макроса.

Вот эквивалентное определение, упрощённое за счёт использования
обратной кавычки:

@example
@group
(defmacro for (var from init to final do &rest body)
  "Выполните простой цикл \"for\".
Для примера, (for i from 1 to 10 do (print i))."
  `(let ((,var ,init))
     (while (<= ,var ,final)
       ,@@body
       (inc ,var))))
@end group
@end example

Обе формы этого определения (с обратной кавычки и без) страдают
от недостатка, заключающегося в том, что @var{final} вычисляется
на каждой итерации. Если @var{final} является константой, это
не проблема. Если это более сложная форма, скажем
@code{(long-complex-calculation x)}, это может значительно замедлить
выполнение. Если @var{final} имеет побочные эффекты, оценка его
более одного раза, вероятно, неправильно.

@cindex macro argument evaluation
Хорошо спроектированное определение макроса предпринимает шаги, чтобы
избежать этой проблемы, создавая расширение, которое вычисляет
выражения аргументов ровно один раз, если повторное вычисление не
является частью предполагаемой цели макроса. Вот правильное
расширение для @code{for} макроса:

@example
@group
(let ((i 1)
      (max 3))
  (while (<= i max)
    (setq square (* i i))
    (princ (format "%d      %d" i square))
    (inc i)))
@end group
@end example

Вот определение макроса, который создает это расширение:

@example
@group
(defmacro for (var from init to final do &rest body)
  "Выполнить простой цикл @code{for}: (for i from 1 to 10 do (print i))."
  `(let ((,var ,init)
         (max ,final))
     (while (<= ,var max)
       ,@@body
       (inc ,var))))
@end group
@end example

  К сожалению, это исправление представляет еще одну проблему,
  описанную в следующем разделе.

@node Surprising Local Vars
@subsection Локальные Переменные в Расширениях Макросов

@ifnottex
  В предыдущем разделе, определение @code{for} было исправлено следующим
  образом, чтобы расширение оценивало аргументы макроса нужное количество раз:

@example
@group
(defmacro for (var from init to final do &rest body)
  "Выполнить простой цикл @code{for}: (for i from 1 to 10 do (print i))."
@end group
@group
  `(let ((,var ,init)
         (max ,final))
     (while (<= ,var max)
       ,@@body
       (inc ,var))))
@end group
@end example
@end ifnottex

  Новое определение @code{for} имеет новую проблему: оно вводит
  локальную переменную с именем @code{max}, которую пользователь
  не ожидает. Это вызывает проблемы в следующих примерах:

@example
@group
(let ((max 0))
  (for x from 0 to 10 do
    (let ((this (frob x)))
      (if (< max this)
          (setq max this)))))
@end group
@end example

@noindent
Ссылки на @code{max} внутри тела @code{for}, которые, как предполагается,
относятся к привязке пользователя @code{max}, действительно
обращаются к привязке созданной @code{for}.

Способ исправить это использовать неинтернированный символ вместо @code{max}
(@pxref{Creating Symbols}).  Неинтернированный символ может быть связан и
на него можно ссылаться так же, как и на любой другой символ, но так как
он создан @code{for}, мы знаем, что он уже не может появиться в программе
пользователя. Так как он не интернирован, пользователь не может поместить
его в программу позже. Она никогда не появится нигде,кроме как там,
где положено @code{for}. Вот определение того @code{for}, который
работает следующим образом:

@example
@group
(defmacro for (var from init to final do &rest body)
  "Выполнить простой цикл @code{for}: (for i from 1 to 10 do (print i))."
  (let ((tempvar (make-symbol "max")))
    `(let ((,var ,init)
           (,tempvar ,final))
       (while (<= ,var ,tempvar)
         ,@@body
         (inc ,var)))))
@end group
@end example

@noindent
Это создает неинтернированный символ с именем @code{max} и помещает
его в расширении вместо обычного интернированного символа @code{max},
который обычно появляется в выражениях.

@node Eval During Expansion
@subsection Оценка Аргументов Макроса в Расширении

  Еще одна проблема может возникнуть, если само определение макроса
  оценивает любое из выражений аргументов макроса, например, путем
  вызова @code{eval} (@pxref{Eval}).  Если предполагается, что аргумент
  относится к пользовательским переменным, могут возникнуть проблемы,
  если пользователь использует переменную с тем же именем, что и один из
  аргументов макроса. Внутри тела макроса привязка аргумента макроса,
  является самой локальной привязкой этой переменной, поэтому любые
  ссылки внутри оцениваемой формы действительно ссылаются на неё.
  Вот пример:

@example
@group
(defmacro foo (a)
  (list 'setq (eval a) t))
@end group
@group
(setq x 'b)
(foo x) @expansion{} (setq b t)
     @result{} t                  ; @r{и @code{b} был установлен.}
;; @r{but}
(setq a 'c)
(foo a) @expansion{} (setq a t)
     @result{} t                  ; @r{но этот набор @code{a}, не @code{c}.}

@end group
@end example

  Имеет значение, имеет ли переменная пользователя имя @code{a} или @code{x},
  потому что @code{a} конфликтует с переменной аргумента макроса @code{a}.

  Еще одна проблема, с вызовом @code{eval} в определении макроса заключается
  в том, что оно, вероятно, не будет делать то, что вы намереваетесь
  откомпилировать в программе. Байт компилятор запускает определения
  макросов во время компиляции программы, когда собственные вычисления
  программы (к которым вы, возможно, хотели получить доступ с @code{eval})
  не происходит, и привязки её локальных переменных не существуют.

  Чтобы избежать этих проблем, @strong{не оценивайте выражение аргумента
  при вычислении расширения макроса}. Вместо этого подставьте выражение
  в расширение макроса, чтобы его значение было вычислено как часть
  выполнения расширения. Вот как работают другие примеры в этой главе.

@node Repeated Expansion
@subsection Во Сколько Раз Увеличен Макрос?

  Иногда проблемы связаны с тем, что вызов макроса расширяется каждый раз,
  когда он оценивается в интерпретируемой функции, но расширяется только
  один раз (во время компиляции) для скомпилированной функции. Если
  определение макроса имеет побочные эффекты, они будут работать по-разному
  в зависимости от того, сколько раз расширяется макрос.

  Поэтому следует избегать побочных эффектов при вычислении макроса,
  если вы действительно не знаете, что вы делаете.

  Нельзя избежать одного особого вида побочного эффекта: конструирования
  объектов Lisp.  Почти все расширения макросов включают построенные
  списки; в этом есть весь смысл большинства макросов. Это, как правило,
  безопасно; есть только один случай, когда вы должны быть осторожны:
  когда создаваемый вами объект в расширении макроса является частью
  указанной в кавычках константой.

  Если макрос расширяется только один раз, во время компиляции, то объект
  строится только один раз, во время компиляции. Но при интерпритируемом
  выполнении, макрос расширяется каждый раз, когда макрос вызывается,
  и это означает, что новый объект строится каждый раз.

  В самом чистом коде Lisp, эта разница не имеет значения. Это может иметь
  значение только при выполнении побочных эффектов для объектов, построенных
  с помощью определения макроса. Таким образом, чтобы избежать неприятностей,
  @strong{избегайте побочных эффектов для объектов, созданных определениями
  макросов}. Вот пример того, как такие побочные эффекты
  могут вовлечь вас в неприятности:

@lisp
@group
(defmacro empty-object ()
  (list 'quote (cons nil nil)))
@end group

@group
(defun initialize (condition)
  (let ((object (empty-object)))
    (if condition
        (setcar object condition))
    object))
@end group
@end lisp

@noindent
Если @code{initialize} интерпретируется, новый список @code{(nil)}
строится каждый раз при вызове @code{initialize}.  Таким образом,
между вызовами побочные эффекты не сохраняются.  Если @code{initialize}
скомпилирована, то макрос @code{empty-object} расширяется во время компиляции,
создавая единственную константу @code{(nil)}, которая используется повторно
и изменяется каждый раз при вызове @code{initialize}.

Один из способов избежать таких патологических случаев - рассматривать
@code{empty-object} как забавную константу, а не как конструкцию выделения
памяти. Вы бы не стали использовать в @code{setcar} такую константу как
@code{'(nil)}, поэтому, естественно, вы не будете использовать её
в @code{(empty-object)}.

@node Indenting Macros
@section Indenting Macros

  В определении макроса вы можете использовать @code{declare} форму
  (@pxref{Defining Macros}), чтобы указать, как @key{TAB} должна
  создавать отступ в записи определения макроса.
  Спецификация отступа пишется так:

@example
(declare (indent @var{indent-spec}))
@end example

@noindent
@cindex @code{lisp-indent-function} property
В результате для @code{lisp-indent-function} имени макроса
устанавливается свойство @code{indent-spec}.

@noindent
Вот возможности @var{indent-spec}:

@table @asis
@item @code{nil}
Это то же самое, как и отсутствие свойства---использовать стандартный шаблон отступа.
@item @code{defun}
Обрабатывайте эту функцию как @samp{def} конструкцию:
Рассматривать вторую строку как начало тела @dfn{body}.
@item an integer, @var{number}
Первые аргументы @var{number} функций являются @dfn{выделенными} аргументами;
остальные рассматриваются как тело выражения. Строка в выражении имеет отступ
в зависимости от того, выделен ли в ней первый аргумент.  Если аргумент
является частью тела, то строка имеет @code{lisp-body-indent} больший
отступ столбцов, чем открывающая скобка, начиная содержащее выражение. Если
аргумент выделяется и является либо первым или вторым аргументом, он имеет
отступ @emph{вдвое} больше, чем количество дополнительных столбцов. Если
выделяется ни первый, ни второй аргумент, в строке используется стандартный
шаблон.
@item a symbol, @var{symbol}
@var{symbol} должен быть именем функции; Эта функция вызывается для
вычисления отступа строки в пределах этого выражения. Функция
принимает два аргумента:

@table @asis
@item @var{pos}
Позиция, в которой начинается строка с отступом.
@item @var{state}
Значение, возвращаемое @code{parse-partial-sexp} (Lisp примитив для
вычисления отступов и вложенности) при синтаксическом анализе до начала
этой строки.
@end table

@noindent
Он должен возвращать либо число, которое равно количеству столбцов отступа
для этой строки, либо список, чей @code{car} является таким числом. Разница
между возвратом числа и возвратом списка, состоит в том, что число означает,
что все последующие строки на том же уровне вложенности должны иметь
такой же отступ, как и эта строка; в списке указано, что следующие строки
могут требовать разных отступов. Это имеет значение, когда отступы
вычисляются с помощью @kbd{C-M-q}; если значение является числом,
@kbd{C-M-q} нет необходимости пересчитывать отступ для следующих строк
до конца списка.
@end table
