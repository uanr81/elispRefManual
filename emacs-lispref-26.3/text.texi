@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-2019 Free Software Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Text
@chapter Текст
@cindex text

  В этой главе описаны функции, которые работают с текстом в буфере.
Большинство из них проверяют, вставляют или удаляют текст в текущем буфере,
часто работая с точкой или с текстом, смежным с точкой.  Многие из них
интерактивны.  Все функции, изменяющие текст, предусматривают отмену
изменений (@pxref{Undo}).

  Многие связанные с текстом функции работают с областью текста,
определяемой двумя позициями буфера, переданными в аргументах с именем
@var{start} и @var{end}.  Эти аргументы должны быть либо маркерами
(@pxref{Markers}), либо числовыми позициями символов (@pxref{Positions}).
Порядок этих аргументов не имеет значения; допустимо, чтобы @var{start} было
концом области, а @var{end} - началом.  Например,
@code{(delete-region 1 10)} и @code{(delete-region 10 1)} эквивалентно.  Об
ошибке @code{args-out-of-range} сообщается, если @var{start} или @var{end}
находятся за пределами доступной части буфера.  В интерактивном вызове для
этих аргументов используются точка и метка.

@cindex buffer contents
  В этой главе ``text'' относится к символам в буфере вместе с их свойствами
(если это необходимо).  Иметь в виду, что точка всегда находится между двумя
символами, а курсор появляется на символе после точки.

@menu
* Near Point::       Изучение текста в непосредственной близости от точки.
* Buffer Contents::  Изучение текста в общем виде.
* Comparing Text::   Сравнение подстрок буферов.
* Insertion::        Добавление нового текста в буфер.
* Commands for Insertion::  Команды пользовательского уровня для
                               вставки текста.
* Deletion::         Удаление текста из буфера.
* User-Level Deletion::     Команды уровня пользователя для удаления текста.
* The Kill Ring::    Где удаленный текст иногда сохраняется для
                        дальнейшего использования.
* Undo::             Отмена изменений текста буфера.
* Maintaining Undo:: Как включить и отключить информацию об отмене.
                        Как контролировать объем хранимой информации.
* Filling::          Функции для явного заполнения.
* Margins::          Как указать поля для команд заполнения.
* Adaptive Fill::    В режиме адаптивной заливки префикс заливки
                        выбирается из контекста.
* Auto Filling::     Как реализован режим автозаполнения для разрыва строк.
* Sorting::          Функции для сортировки частей буфера.
* Columns::          Вычисление горизонтальных положений и их использование.
* Indentation::      Функции для вставки или корректировки отступа.
* Case Changes::     Преобразование регистров частей буфера.
* Text Properties::  Назначение списков свойств Lisp текстовым символам.
* Substitution::     Замена данного символа везде, где он появляется.
* Registers::        Как реализуются регистры.  Доступ к тексту или позиции,
                        хранящейся в регистре.
* Transposition::    Обмен двух частей буфера.
* Replacing::        Замена текста одного буфера текстом другого буфера.
* Decompression::    Работа со сжатыми данными.
* Base 64::          Преобразование в кодировку base 64 или из нее.
* Checksum/Hash::    Вычисление криптографических хэшей.
* GnuTLS Cryptography:: Криптографические алгоритмы, импортированные
                           из GnuTLS.
* Parsing HTML/XML:: Разбор HTML и XML.
* Atomic Changes::   Атомарная установка нескольких изменений буфера.
* Change Hooks::     Предоставление функций, запускаемых при
                        изменении текста.
@end menu

@node Near Point
@section Изучение Текста Рядом с Точкой
@cindex text near point

  Many functions are provided to look at the characters around point.
Several simple functions are described here.  Смотреть также
@code{looking-at} в @ref{Regexp Search}.

В следующих четырех функциях ``beginning'' или ``end'' буфера относятся к
началу или концу доступной части.

@defun char-after &optional position
Функция возвращает символ в текущем буфере в (то есть сразу после) позиции
@var{position}.  Если @var{position} выходит за пределы допустимого
диапазона для этой цели, либо до начала буфера, либо в конце или за его
пределами, тогда значение будет @code{nil}.  Значение по умолчанию для
@var{position} - точка.

В следующем примере предположим, что первый символ в буфере - @samp{@@}:

@example
@group
(string (char-after 1))
     @result{} "@@"
@end group
@end example
@end defun

@defun char-before &optional position
Функция возвращает символ в текущем буфере непосредственно перед позицией
@var{position}.  Если @var{position} выходит за пределы допустимого
диапазона, либо в начале буфера, либо перед ним, либо за его
пределами, тогда значение равно @code{nil}.  Значение по умолчанию для
@var{position} - точка.
@end defun

@defun following-char
Функция возвращает символ, следующий за точкой в текущем буфере.  Это похоже
на @code{(char-after (point))}.  Однако, если точка находится в конце
буфера, @code{following-char} возвращает 0.

Помнить, что точка всегда находится между символами, и курсор обычно
появляется над символом, следующим за точкой.  Следовательно, символ,
возвращаемый @code{following-char}, - это символ, над которым находится
курсор.

В этом примере точка находится между @samp{a} и @samp{c}.

@example
@group
---------- Buffer: foo ----------
Gentlemen may cry ``Pea@point{}ce! Peace!,''
but there is no peace.
---------- Buffer: foo ----------
@end group

@group
(string (preceding-char))
     @result{} "a"
(string (following-char))
     @result{} "c"
@end group
@end example
@end defun

@defun preceding-char
Функция возвращает символ, предшествующий точке в текущем буфере.  Смотреть
пример выше, в разделе @code{following-char}.  Если точка находится в начале
буфера, @code{preceding-char} возвращает 0.
@end defun

@defun bobp
Функция возвращает @code{t}, если точка находится в начале буфера.  Если
действует сужение, это означает начало доступной части текста.  Смотреть
также @code{point-min} в @ref{Point}.
@end defun

@defun eobp
Функция возвращает @code{t}, если точка находится в конце буфера.  Если
действует сужение, это означает конец доступной части текста.  Смотреть
также @code{point-max} в @xref{Point}.
@end defun

@defun bolp
Функция возвращает @code{t}, если точка находится в начале строки.
@xref{Text Lines}.  Начало буфера (или его доступной части) всегда считается
началом строки.
@end defun

@defun eolp
Функция возвращает @code{t}, если точка находится в конце строки.  Конец
буфера (или его доступной части) всегда считается концом строки.
@end defun

@node Buffer Contents
@section Изучение Содержимого Буфера
@cindex buffer portion as string

  В этом разделе описаны функции, которые позволяют программе на Lisp
преобразовывать любую часть текста буфера в строку.

@defun buffer-substring start end
Функция возвращает строку, содержащую копию текста области, определенной
позициями @var{start} и @var{end} в текущем буфере.  Если аргументы не
являются позициями в доступной части буфера, @code{buffer-substring}
сигнализирует об ошибке @code{args-out-of-range}.

Вот пример, который предполагает, что режим Font-Lock не включен:

@example
@group
---------- Buffer: foo ----------
This is the contents of buffer foo

---------- Buffer: foo ----------
@end group

@group
(buffer-substring 1 10)
     @result{} "This is t"
@end group
@group
(buffer-substring (point-max) 10)
     @result{} "he contents of buffer foo\n"
@end group
@end example

Если копируемый текст имеет какие-либо текстовые свойства, они копируются в
строку вместе с символами, которым они принадлежат.  @xref{Text Properties}.
Однако наложения (@pxref{Overlays}) в буфере и их свойства игнорируются, а
не копируются.

Например, если включен режим Font-Lock, можно получить такие результаты:

@example
@group
(buffer-substring 1 10)
     @result{} #("This is t" 0 1 (fontified t) 1 9 (fontified t))
@end group
@end example
@end defun

@defun buffer-substring-no-properties start end
Похоже на @code{buffer-substring}, за исключением того, что не
копируются свойства текста, а только сами символы.  @xref{Text Properties}.
@end defun

@defun buffer-string
Функция возвращает содержимое всей доступной части текущего буфера в виде
строки.
@end defun

  Если нужно убедиться, что результирующая строка при копировании в другое
место не изменит свой внешний вид из-за переупорядочения двунаправленного
текста, использовать функцию @code{buffer-substring-with-bidi-context}
(@pxref{Bidirectional Display, buffer-substring-with-bidi-context}).

@defun filter-buffer-substring start end &optional delete
Функция фильтрует текст буфера между @var{start} и @var{end}, используя
функцию, заданную переменной @code{filter-buffer-substring-function}, и
возвращает результат.

Функция фильтра по умолчанию обращается к устаревшей ловушке оболочки
@code{filter-buffer-substring-functions} (подробные сведения об этой
устаревшей возможности смотреть в строке документации макроса
@code{with-wrapper-hook}) и информацию к устаревшей переменной
@code{buffer-substring-filters}.  Если обе из них - @code{nil}, возвращается
неизмененный текст из буфера, то есть то, что вернет
@code{buffer-substring}.

Если @var{delete} установленно в non-@code{nil}, функция удаляет текст между
@var{start} и @var{end} после его копирования, как
@code{delete-and-extract-region}.

Код на Лиспе должен использовать эту функцию вместо @code{buffer-substring},
@code{buffer-substring-no-properties} или @code{delete-and-extract-region}
при копировании в доступные пользователю структуры данных, такие как
kill-ring, X-буфер обмена и регистры.  Основные и второстепенные режимы
могут изменять @code{filter-buffer-substring-function} для изменения такого
текста, когда он копируется из буфера.
@end defun

@defvar filter-buffer-substring-function
Значение этой переменной - это функция, которую
@code{filter-buffer-substring} будет вызывать для выполнения фактической
работы.  Функция получает три аргумента, такие же, как у
@code{filter-buffer-substring}, которые должна обрабатывать в соответствии с
документацией этой функции.  Должен вернуться отфильтрованный текст (и, при
необходимости, удалиться исходный текст).
@end defvar

@noindent The following two variables are obsoleted by
@code{filter-buffer-substring-function}, но по-прежнему поддерживаются для
обратной совместимости.

@defvar filter-buffer-substring-functions
Эта устаревшая переменная представляет собой ловушку-оболочку, членами
которой должны быть функции, принимающие четыре аргумента: @var{fun},
@var{start}, @var{end} и @var{delete}.  @var{fun} - это функция, которая
принимает три аргумента (@var{start}, @var{end} и @var{delete}) и возвращает
строку.  В обоих случаях аргументы @var{start}, @var{end} и @var{delete}
такие же, как и аргументы @code{filter-buffer-substring}.

Первой функции-ловушке передается @var{fun}, что эквивалентно операции по
умолчанию @code{filter-buffer-substring}, то есть возвращается подстрока
буфера между @var{start} и @var{end} (обрабатывается любым
@code{buffer-substring-filters}) и при необходимости удаляется исходный
текст из буфера.  В большинстве случаев функция ловушки вызывает @var{fun}
один раз, а затем выполняет свою собственную обработку результата.
Следующая функция ловушки получает эквивалент @var{fun} и так далее.
Фактическое возвращаемое значение - это результат последовательного действия
всех функций ловушки.
@end defvar

@defvar buffer-substring-filters
Значение этой устаревшей переменной должно быть списком функций, которые
принимают один строковый аргумент и возвращают другую строку.  Функция
@code{filter-buffer-substring} по умолчанию передает подстроку буфера первой
функции в этом списке, а возвращаемое значение каждой функции передается
следующей функции.  Возвращаемое значение последней функции передается
@code{filter-buffer-substring-functions}.
@end defvar

@defun current-word &optional strict really-word
Функция возвращает символ (или слово) в точке или рядом с ней в виде строки.
Возвращаемое значение не содержит текстовых свойств.

Если необязательный аргумент @var{really-word} - non-@code{nil}, находится
слово; в противном случае находится символ (который включает как символы
слова, так и символы, составляющие символ).

Если необязательный аргумент @var{strict} - не-@code{nil}, то точка должна
находиться внутри или рядом с символом или словом --- если нет символа или
слова, функция возвращает @code{nil}.  В противном случае можно использовать
ближайший символ или слово в той же строке.
@end defun

@defun thing-at-point thing &optional no-properties
Вернуть @var{thing} вокруг точки или рядом с ней в виде строки.

Аргумент @var{thing} - это символ, определяющий вид синтаксической сущности.
Возможности включают @code{symbol}, @code{list}, @code{sexp}, @code{defun},
@code{filename}, @code{url}, @code{word}, @code{sentence},
@code{whitespace}, @code{line}, @code{page} и другие.

Когда необязательный аргумент @var{no-properties} равен не-@code{nil}, эта
функция удаляет текстовые свойства из возвращаемого значения.

@example
---------- Buffer: foo ----------
Gentlemen may cry ``Pea@point{}ce! Peace!,''
but there is no peace.
---------- Buffer: foo ----------

(thing-at-point 'word)
     @result{} "Peace"
(thing-at-point 'line)
     @result{} "Gentlemen may cry ``Peace! Peace!,''\n"
(thing-at-point 'whitespace)
     @result{} nil
@end example
@end defun

@node Comparing Text
@section Сравнение Текста
@cindex comparing buffer text

  Функция позволяет сравнивать части текста в буфере без предварительного
копирования их в строки.

@defun compare-buffer-substrings buffer1 start1 end1 buffer2 start2 end2
Функция позволяет сравнивать две подстроки одного и того же буфера или два
разных буфера.  Первые три аргумента определяют одну подстроку, задающую
буфер (или имя буфера) и две позиции в буфере.  Последние три аргумента
точно так же определяют другую подстроку.  Можно использовать @code{nil} для
@var{buffer1}, @var{buffer2} или оба для обозначения текущего буфера.

Значение отрицательное, если первая подстрока меньше, положительное, если
первая больше, и ноль, если они равны.  Абсолютное значение результата равно
единице плюс индекс первых различных символов в подстроках.

Функция игнорирует регистр при сравнении символов, если
@code{case-fold-search} равен не-@code{nil}.  Всегда игнорируются свойства
текста.

Предположим, есть текст @w{@samp{foobarbar haha!rara!}} в текущем буфере;
то в этом примере две подстроки - @samp{rbar } и @samp{rara!}.  Значение
равно 2, потому что первая подстрока больше второго символа.

@example
(compare-buffer-substrings nil 6 11 nil 16 21)
     @result{} 2
@end example
@end defun

@node Insertion
@section Вставка Текста
@cindex insertion of text
@cindex text insertion

@cindex insertion before point
@cindex before point, insertion
  @dfn{Вставка текста} означает добавление нового текста в буфер.
Вставленный текст находится в точке --- между символом перед точкой и
символом после точки.  Некоторые функции вставки оставляют точку перед
вставленным текстом, в то время как другие функции оставляют ее после.
Называется первая вставка @dfn{после точки}, а вторую - @dfn{перед точкой}.

  Вставка перемещает маркеры, расположенные в позициях после точки вставки,
так, чтобы они оставались с окружающим текстом (@pxref{Markers}).  Когда
маркер указывает на место вставки, вставка может перемещать или не
перемещать маркер, в зависимости от типа вставки маркера
(@pxref{Marker Insertion Types}).  Некоторые специальные функции, такие как
@code{insert-before-markers}, перемещают все такие маркеры так, чтобы они
указывали после вставленного текста, независимо от типа вставки маркеров.

  Функции вставки сигнализируют об ошибке, если текущий буфер доступен
только для чтения (@pxref{Read Only Buffers}) или если они вставляются в
текст (@pxref{Special Properties}), доступный только для чтения.

  Эти функции копируют текстовые символы из строк и буферов вместе с их
свойствами.  Вставленные символы имеют точно такие же свойства, как и
символы, из которых они были скопированы.  Напротив, символы, указанные как
отдельные аргументы, а не часть строки или буфера, наследуют свои текстовые
свойства от соседнего текста.

  Функции вставки преобразуют текст из однобайтового в многобайтовый, чтобы
вставить в многобайтовый буфер, и наоборот - если текст поступает из строки
или из буфера.  Однако они не преобразуют коды однобайтовых символов от 128
до 255 в многобайтовые символы, даже если текущий буфер является
многобайтовым.  @xref{Converting Representations}.

@defun insert &rest args
Функция вставляет строки и/или символы @var{args} в текущий буфер в точке,
перемещая точку вперед.  Другими словами, вставляется текст перед точкой.
Сигнализируется об ошибке, если все @var{args} не являются строками или
символами.  Возвращаемое значение @code{nil}.
@end defun

@defun insert-before-markers &rest args
Функция вставляет строки и/или символы @var{args} в текущий буфер в точке,
перемещая точку вперед.  Сигнализируется об ошибке, если все @var{args} не
являются строками или символами.  Возвращаемое значение @code{nil}.

Функция отличается от других функций вставки тем, что перемещает маркеры,
изначально указывающие на точку вставки, чтобы они указывали после
вставленного текста.  Если наложение начинается с точки вставки, вставленный
текст выходит за пределы наложения; если непустое наложение заканчивается в
точке вставки, вставленный текст попадает внутрь этого наложения.
@end defun

@deffn Command insert-char character &optional count inherit
Команда вставляет экземпляры @var{count} объекта @var{character} в текущий
буфер перед точкой.  Аргумент @var{count} должен быть целым числом, а
@var{character} должен быть символом.

При интерактивном вызове команда запрашивает @var{character}, используя его
имя в Юникоде или его кодовую точку.
@xref{Inserting Text,,, emacs, The GNU Emacs Manual}.

Функция не преобразует коды однобайтовых символов от 128 до 255 в
многобайтовые символы, даже если текущий буфер является многобайтовым.
@xref{Converting Representations}.

Если @var{inherit} равен не-@code{nil}, вставленные символы наследуют
свойства закрепленного текста от двух символов до и после точки вставки.
@xref{Sticky Properties}.
@end deffn

@defun insert-buffer-substring from-buffer-or-name &optional start end
Функция вставляет часть буфера @var{from-buffer-or-name} в текущий буфер
перед точкой.  Вставленный текст - это область между @var{start}
(включая) и @var{end} (исключая).  (По умолчанию эти аргументы относятся к
началу и концу доступной части этого буфера.)  Функция возвращает
@code{nil}.

В этом примере форма выполняется с буфером @samp{bar} в качестве текущего
буфера.  Предполагается, что буфер @samp{bar} изначально пуст.

@example
@group
---------- Buffer: foo ----------
We hold these truths to be self-evident, that all
---------- Buffer: foo ----------
@end group

@group
(insert-buffer-substring "foo" 1 20)
     @result{} nil

---------- Buffer: bar ----------
We hold these truth@point{}
---------- Buffer: bar ----------
@end group
@end example
@end defun

@defun insert-buffer-substring-no-properties from-buffer-or-name &optional start end
Это похоже на @code{insert-buffer-substring}, за исключением того, что
не копируется никаких текстовых свойств.
@end defun

  @xref{Sticky Properties}, для других функций вставки, которые наследуют
свойства текста от ближайшего текста в дополнение к его вставке.  Пробелы,
вставленные функциями отступа, также наследуют свойства текста.

@node Commands for Insertion
@section Команды Вставки на Уровне Пользователя

  В этом разделе описаны команды более высокого уровня для вставки текста,
команды, предназначенные в первую очередь для пользователя, но также
полезные и в программах Lisp.

@deffn Command insert-buffer from-buffer-or-name
Команда вставляет все доступное содержимое @var{from-buffer-or-name}
(которое должно существовать) в текущий буфер после точки.  Оставляет
отметку после вставленного текста.  Возвращаемое значение @code{nil}.
@end deffn

@deffn Command self-insert-command count
@cindex character insertion
@cindex self-insertion
Команда вставляет последний набранный символ; делает это @var{count} раз
перед точкой и возвращает @code{nil}.  С этой командой связано большинство
печатных символов.  В повседневном использовании @code{self-insert-command}
является наиболее часто вызываемой функцией в Emacs, но программы редко
используют ее, за исключением установки в ключевой карте.

В интерактивном вызове @var{count} - это числовой префиксный аргумент.

@c FIXME: Эта переменная устарела, так как 23.1.
Самовставка переводит введенный символ через
@code{translation-table-for-input}.  @xref{Translation of Characters}.

Команда вызывает @code{auto-fill-function} всякий раз, когда это
не-@code{nil}, а вставленный символ находится в таблице
@code{auto-fill-chars} (@pxref{Auto Filling}).

@c Перефразированы перекрестные ссылки для предотвращения переполнения
@c бокса.  --rjc 15mar92
Команда выполняет расширение аббревиатуры, если включен режим аббревиатуры и
у вставленного символа нет синтаксиса, составляющего слово.  (@xref{Abbrevs}
и @ref{Syntax Class Table}.)  Также отвечает за вызов
@code{blink-paren-function}, когда вставленный символ имеет синтаксис
закрывающих скобок (@pxref{Blinking}).

@vindex post-self-insert-hook
@vindex self-insert-uses-region-functions
Последнее, что делает эта команда, - запускает ловушку
@code{post-self-insert-hook}.  Можно использовать это, например, для
автоматического изменения отступов текста при его вводе.  Если какая-либо
функция в этой ловушке должна воздействовать на область
(@pxref{The Region}), нужна уверенность, что режим удаления выделения
(@pxref{Using Region, Delete Selection, , emacs, The GNU Emacs Manual}) не
удаляет область до вызова функций @code{post-self-insert-hook}.  Для этого
нужно добавить функцию, которая возвращает @code{nil} в
@code{self-insert-uses-region-functions}, специальной ловушки, которая
сообщает режиму удаления выделения, что не требуется удалять область.

Не пытайться заменить стандартное определение @code{self-insert-command}
своим собственным.  Цикл команд редактора обрабатывает эту функцию особым
образом.
@end deffn

@deffn Command newline &optional number-of-newlines
Команда вставляет символы новой строки в текущий буфер перед точкой.  Если
указан @var{number-of-newlines}, будет вставлено много символов новой
строки.

@cindex newline and Auto Fill mode
Функция вызывает @code{auto-fill-function}, если текущий номер столбца
больше, чем значение @code{fill-column}, а @var{number-of-newlines} -
@code{nil}.  Обычно @code{auto-fill-function} вставляет новую строку; таким
образом, общий результат в этом случае - вставить два символа новой строки в
разных местах: один в точке, а другой в начале строки.  @code{newline} не
заполняется автоматически, если @var{number-of-newlines} равен
не-@code{nil}.

Команда делает отступ до левого поля, если он не равен нулю.
@xref{Margins}.

Возвращаемое значение - @code{nil}.  В интерактивном вызове @var{count}
является аргументом числового префикса.
@end deffn

@defvar overwrite-mode
Переменная определяет, действует ли режим перезаписи.  Значение должно быть
@code{overwrite-mode-textual}, @code{overwrite-mode-binary} или @code{nil}.
@code{overwrite-mode-textual} определяет режим текстовой перезаписи
(обрабатывает символы новой строки и табуляции специально), а
@code{overwrite-mode-binary} определяет режим двоичной перезаписи
(обрабатывает символы новой строки и табуляции как любые другие символы).
@end defvar

@node Deletion
@section Удаление Текста
@cindex text deletion

@cindex deleting text vs killing
  Удаление означает удаление части текста в буфере без сохранения его в
списке уничтожений (@pxref{The Kill Ring}).  Удаленный текст не может быть
восстановлен, но может быть повторно вставлен с помощью механизма отмены
(@pxref{Undo}).  Некоторые функции удаления сохраняют текст в списке
уничтожений в некоторых особых случаях.

  Все функции удаления работают с текущим буфером.

@deffn Command erase-buffer
Aункция удаляет весь текст текущего буфера (@emph{не} только доступную
часть), оставляя его пустым.  Если буфер доступен только для чтения, это
сигнализирует об ошибке @code{buffer-read-only}; если часть текста в нем
предназначена только для чтения, это сигнализирует об ошибке
@code{text-read-only}.  В противном случае удаляется текст без запроса
подтверждения.  Возвращается @code{nil}.

Обычно удаление большого количества текста из буфера запрещает дальнейшее
автосохранение этого буфера, поскольку он уменьшился.  Однако
@code{erase-buffer} этого не делает, поскольку идея состоит в том, что
будущий текст на самом деле не связан с предыдущим текстом, и его размер не
следует сравнивать с размером предыдущего текста.
@end deffn

@deffn Command delete-region start end
Команда удаляет текст между позициями @var{start} и @var{end} в текущем
буфере и возвращает @code{nil}.  Если точка находилась внутри удаленной
области, ее значение после этого будет @var{start}.  В противном случае
точка перемещается вместе с окружающим текстом, как и маркеры.
@end deffn

@defun delete-and-extract-region start end
Функция удаляет текст между позициями @var{start} и @var{end} в текущем
буфере и возвращает строку, содержащую только что удаленный текст.

Если точка находилась внутри удаленной области, ее значение после этого
будет @var{start}.  В противном случае точка перемещается вместе с
окружающим текстом, как и маркеры.
@end defun

@deffn Command delete-char count &optional killp
Команда удаляет символы @var{count} непосредственно после точки или перед
точкой, если значение @var{count} отрицательное.  Если @var{killp} равен
не-@code{nil}, то удаленные символы сохраняются в списке уничтожений.

В интерактивном вызове @var{count} - это числовой префиксный аргумент, а
@var{killp} - это необработанный префиксный аргумент.  Следовательно, если
указан префиксный аргумент, текст сохраняется в списке уничтожений.  Если
аргумент префикса не указан, то один символ удаляется, но не сохраняется в
списке уничтожений.

Возвращаемое значение всегда @code{nil}.
@end deffn

@deffn Command delete-backward-char count &optional killp
@cindex deleting previous char
Команда удаляет символы @var{count} непосредственно перед точкой или после
точки, если значение @var{count} отрицательное.  Если @var{killp} равен
не-@code{nil}, то удаленные символы сохраняются в списке уничтожений.

В интерактивном вызове @var{count} - это числовой префиксный аргумент, а
@var{killp} - это необработанный префиксный аргумент.  Следовательно, если
указан префиксный аргумент, текст сохраняется в списке уничтожений.  Если
аргумент префикса не указан, то один символ удаляется, но не сохраняется в
списке уничтожений.

Возвращаемое значение всегда @code{nil}.
@end deffn

@deffn Command backward-delete-char-untabify count &optional killp
@cindex tab deletion
Команда удаляет символы @var{count} назад, заменяя табуляцию пробелами.
Когда следующим удаляемым символом является табуляция, сначала заменяется
надлежащим количеством пробелов для сохранения выравнивания, а затем один из
этих пробелов удаляется вместо табуляции.  Если @var{killp} равен
не-@code{nil}, то команда сохраняет удаленные символы в списке уничтожений.

Преобразование табуляции в пробелы происходит, только если @var{count}
положительно.  Если отрицательно, удаляются ровно @minus{}@var{count}
символов после точки.

В интерактивном вызове @var{count} - это числовой префиксный аргумент, а
@var{killp} - это необработанный префиксный аргумент.  Следовательно, если
указан префиксный аргумент, текст сохраняется в списке уничтожений.  Если
аргумент префикса не указан, то один символ удаляется, но не сохраняется в
списке уничтожений.

Возвращаемое значение всегда @code{nil}.
@end deffn

@defopt backward-delete-char-untabify-method
Опция определяет, как @code{backward-delete-char-untabify} должно
обрабатывать пробелы.  Возможные значения включают @code{untabify}, значение
по умолчанию, что означает преобразование табуляции во множество пробелов и
удаление одного; @code{hungry}, то есть удалить все табуляции и пробелы
перед точкой с помощью одной команды; @code{all} означает удалить все
табуляции, пробелы и символы новой строки перед точкой, а @code{nil}
означает, что ничего особенного не делать для пробельных символов.
@end defopt

@node User-Level Deletion
@section Команды Удаления Уровня Пользователя

  В этом разделе описаны команды более высокого уровня для удаления текста,
команды, предназначенные в первую очередь для пользователя, но также
полезные в программах на Lisp.

@deffn Command delete-horizontal-space &optional backward-only
@cindex deleting whitespace
Функция удаляет все пробелы и табуляции вокруг точки.
Возвращает @code{nil}.

Если @var{backward-only} равен не-@code{nil}, функция удаляет пробелы и
табуляции перед точкой, но не после точки.

В следующих примерах вызывается @code{delete-horizontal-space} четыре раза,
по одному в каждой строке, каждый раз ставится точка между вторым и третьим
символами в строке.

@example
@group
---------- Buffer: foo ----------
I @point{}thought
I @point{}     thought
We@point{} thought
Yo@point{}u thought
---------- Buffer: foo ----------
@end group

@group
(delete-horizontal-space)   ; @r{Четыре раза.}
     @result{} nil

---------- Buffer: foo ----------
Ithought
Ithought
Wethought
You thought
---------- Buffer: foo ----------
@end group
@end example
@end deffn

@deffn Command delete-indentation &optional join-following-p
Функция соединяет точку на предыдущей строке, удаляя любые пробелы в
соединении и в некоторых случаях заменяя их одним пробелом.  Если
@var{join-following-p} равен не-@code{nil}, вместо этого
@code{delete-indentation} присоединяет эту строку к следующей.  Функция
возвращает @code{nil}.

Если есть префикс заполнения, и вторая из соединяемых строк начинается с
префикса, то @code{delete-indentation} удаляет префикс заполнения перед
объединением строк.  @xref{Margins}.

В приведенном ниже примере точка находится в строке, начинающейся с
@samp{events}, и не имеет значения, есть ли в предыдущей строке завершающие
пробелы.

@smallexample
@group
---------- Buffer: foo ----------
When in the course of human
@point{}    events, it becomes necessary
---------- Buffer: foo ----------
@end group

(delete-indentation)
     @result{} nil

@group
---------- Buffer: foo ----------
When in the course of human@point{} events, it becomes necessary
---------- Buffer: foo ----------
@end group
@end smallexample

После соединения строк функция @code{fixup-whitespace} отвечает за решение,
оставлять ли место на стыке.
@end deffn

@deffn Command fixup-whitespace
Функция заменяет все горизонтальные пробелы вокруг точки либо одним
пробелом, либо оставляет без пробела, в зависимости от контекста.
Возвращает @code{nil}.

В начале или в конце строки подходящее количество пробелов убирается.
Перед символом с синтаксисом закрывающей круглой скобки, или после символа
с синтаксисом открытой круглой скобки или перед выражением с синтаксисом
префикса также убирается пробел.  В противном случае оставляется один
пробел.  @xref{Syntax Class Table}.

В приведенном ниже примере @code{fixup-whitespace} вызывается первый раз с
точкой перед словом @samp{spaces} в первой строке.  При втором вызове точка
находится сразу после @samp{(}.

@smallexample
@group
---------- Buffer: foo ----------
This has too many     @point{}spaces
This has too many spaces at the start of (@point{}   this list)
---------- Buffer: foo ----------
@end group

@group
(fixup-whitespace)
     @result{} nil
(fixup-whitespace)
     @result{} nil
@end group

@group
---------- Buffer: foo ----------
This has too many spaces
This has too many spaces at the start of (this list)
---------- Buffer: foo ----------
@end group
@end smallexample
@end deffn

@deffn Command just-one-space &optional n
@comment !!Исходный файл simple.el
Команда заменяет любые пробелы и табуляцию вокруг точки одним пробелом или
@var{n} пробелами, если указан @var{n}.  Возвращается @code{nil}.
@end deffn

@c Также существует интервал между циклами, но я не вижу, чтобы он был
@c полезен в программах Lisp, поэтому здесь он не упоминается.

@deffn Command delete-blank-lines
Функция удаляет пустые строки, окружающие точку.  Если точка находится в
пустой строке с одной или несколькими пустыми строками до или после нее, то
все, кроме одной строки, удаляются.  Если точка находится на изолированной
пустой строке, она удаляется.  Если точка находится на непустой строке,
команда удаляет все пустые строки, следующие сразу за ней.

Пустая строка определяется как строка, содержащая только табуляции и
пробелы.
@c и символ новой строки?

@code{delete-blank-lines} возвращает @code{nil}.
@end deffn

@deffn Command delete-trailing-whitespace &optional start end
Удалить завершающие пробелы в области, определенной @var{start} и @var{end}.

Команда удаляет пробельные символы после последнего непробельного символа в
каждой строке в регионе.

Если команда воздействует на весь буфер (т.е. если вызывается интерактивно с
неактивной меткой или вызывается из Lisp с помощью @var{end} @code{nil}),
она также удаляет все завершающие строки в конце буфера, если переменная
@code{delete-trailing-lines} имеет значение не-@code{nil}.
@end deffn

@node The Kill Ring
@section Кольцо Уничтожения
@cindex kill ring

  @dfn{Функции уничтожения} удаляют текст, как функции удаления, но
сохраняют его, чтобы пользователь мог повторно вставить его с помощью
@dfn{аннулирования}.  В названии большинства этих функций есть
@samp{kill-}.  Напротив, функции, имена которых начинаются с @samp{delete-},
обычно не сохраняют текст для восстановления (хотя их все еще можно
отменить); это функции удаления.

  Большинство команд уничтожения предназначены в первую очередь для
интерактивного использования и здесь не описываются.  Описываются функции,
предназначенные для использования при написании таких команд.  Можно
использовать эти функции для написания команд для уничтожения текста.  Когда
нужно удалить текст для внутренних целей в функции Lisp, обычно потребуется
использовать функции удаления, чтобы не нарушать содержимое кольца
уничтожения.  @xref{Deletion}.

  Уничтоженный текст сохраняется для последующего восстановления в
@dfn{кольце уничтожения}.  Это список, который содержит количество недавних
уничтожений, а не только последнее текстовое уничтожение.  Называется это
``кольцо'', потому что при восстановлении это рассматривается как элементы в
циклическом порядке.  Список хранится в переменной @code{kill-ring}, и с ним
можно работать с обычными функциями для списков; есть также
специализированные функции, описанные в этом разделе, которые обрабатывают
его как кольцо.

  Некоторые люди думают, что такое использование слова ``уничтожение''
неудачно, так как оно относится к операциям, которые, в частности,
@emph{не} уничтожают сущности.  Это резко контрастирует с обычной жизнью, в
которой уничтожение постоянно, а уничтоженные сущности не возвращаются к
жизни.  Поэтому были предложены другие метафоры.  Например, термин
``вырезанное кольцо'' имеет смысл для людей, которые в докомпьютерные
времена использовали ножницы и пасту, чтобы разрезать и переставлять
рукописи.  Однако изменить терминологию сейчас будет сложно.

@menu
* Kill Ring Concepts::     Как выглядит текст в списке уничтожений.
* Kill Functions::         Функции, уничтожающие текст.
* Yanking::                Как делается аннулирование.
* Yank Commands::          Команды, которые обращаются к списку уничтожений.
* Low-Level Kill Ring::    Функции и переменные для доступа к
                              кольцу уничтожения.
* Internals of Kill Ring:: Переменные, которые содержат данные
                              аннулирования.
@end menu

@node Kill Ring Concepts
@subsection Концепции Кольца Уничтожения

  Кольцо уничтожения записывает уничтоженный текст в виде строк в списке,
начиная с самого последнего.  Например, короткое кольцо уничтожений может
выглядеть так:

@example
("some text" "a different piece of text" "even older text")
@end example

@noindent
Когда список достигает длины @code{kill-ring-max} записей, добавление новой
записи автоматически удаляет последнюю запись.

  Когда команды уничтожения переплетаются с другими командами, каждая
команда уничтожения создает новую запись в списке уничтожений.  Несколько
последовательных команд уничтожения создают одну запись в кольце
уничтожения, которая будет извлечена как единое целое; вторая и последующие
последовательные команды уничтожения добавляют текст к записи, сделанной
первой.

  Для аннулирования одна запись в кольце уничтожения обозначается передней
частью кольца.  Некоторые команды аннулирования вращают кольцо, обозначая
другой элемент как передний.  Но это виртуальное вращение не меняет сам
список--- самая последняя запись всегда идет первой в списке.

@node Kill Functions
@subsection Функции Уничтожения

  @code{kill-region} - обычная подпрограмма для уничтожения текста.  Любая
команда, вызывающая эту функцию, является командой уничтожения (и, вероятно,
должна иметь в своем имени @samp{kill}).  @code{kill-region} помещает только
что уничтоженный текст в новый элемент в начале списка уничтожений или
добавляет его к самому последнему элементу.  Автоматически определяется (с
помощью @code{last-command}), была ли предыдущая команда командой kill, и,
если да, добавляется убитый текст к самой последней записи.

@cindex filtering killed text
  Команды, описанные ниже, могут фильтровать уничтоженный текст перед
сохранением его в списке уничтожений.  Они вызывают
@code{filter-buffer-substring} (@pxref{Buffer Contents}) для выполнения
фильтрации.  По умолчанию фильтрация отсутствует, но основные и
второстепенные режимы и функции перехватчики могут настраивать фильтрацию,
так что текст, сохраненный в списке уничтожений, отличается от того, что
было в буфере.

@deffn Command kill-region start end &optional region
Функция уничтожает фрагмент текста между @var{start} и @var{end}; но если
необязательный аргумент @var{region} - не-@code{nil}, игнорируются
@var{start} и @var{end} и вместо этого уничтожается текст в текущей области.
Текст удаляется, но сохраняется в списке уничтожений вместе с его свойствами
текста.  Возвращаемое значение всегда @code{nil}.

В интерактивном вызове @var{start} and @var{end} - это точка и метка, а
@var{region} - всегда не-@code{nil}, поэтому команда всегда уничтожает текст
в текущей области.

Если буфер или текст доступны только для чтения, @code{kill-region} точно
так же изменяет список уничтожений, а затем сигнализирует об ошибке без
изменения буфера.  Это удобно, потому что позволяет пользователю
использовать серию команд уничтожения для копирования текста из буфера
только для чтения в список уничтожения.
@end deffn

@defopt kill-read-only-ok
Если опция - не-@code{nil}, @code{kill-region} не сигнализирует об ошибке,
если буфер или текст доступны только для чтения.  Вместо этого просто
возвращается значение, обновляется список уничтожений, но не изменяется
буфер.
@end defopt

@deffn Command copy-region-as-kill start end &optional region
Функция сохраняет фрагмент текста между @var{start} и @var{end} в списке
уничтожений (включая свойства текста), но не удаляет текст из буфера.
Однако, если необязательный аргумент @var{region} равен не-@code{nil},
функция игнорирует @var{start} and @var{end} и вместо этого сохраняет
текущий регион.  Всегда возвращается @code{nil}.

В интерактивном вызове @var{start} and @var{end} - это точка и метка, а
@var{region} - всегда не-@code{nil}, поэтому команда всегда сохраняет текст
в текущей области.

Команда не устанавливает @code{this-command} в @code{kill-region}, поэтому
последующая команда kill не добавляется к той же записи кольца уничтожения.
@end deffn

@node Yanking
@subsection Восстановление

  Восстановление означает вставку текста из списка уничтожений, но не
вслепую.  Команда @code{yank} и связанные с ней команды используют
@code{insert-for-yank} для специальной обработки текста перед его вставкой.

@defun insert-for-yank string
Функция работает так же, как @code{insert}, за исключением того, что она
обрабатывает текст в @var{string} в соответствии со свойством текста
@code{yank-handler}, а также переменные @code{yank-handled-properties} и
@code{yank-excluded-properties} (смотреть ниже) перед вставкой результата в
текущий буфер.
@end defun

@defun insert-buffer-substring-as-yank buf &optional start end
Функция похожа на @code{insert-buffer-substring}, за исключением того, что
обрабатывает текст в соответствии с @code{yank-handled-properties} и
@code{yank-excluded-properties}.  (Не обрабатывает свойство
@code{yank-handler}, которое в любом случае обычно не встречается в тексте
буфера.)
@end defun

@c FIXME: Добавить индекс для yank-handler.
  Если поместить текстовое свойство @code{yank-handler} на всю строку или ее
часть, это изменит способ вставки строки @code{insert-for-yank}.  Если
разные части строки имеют разные значения @code{yank-handler} (сравнение
выполняется с @code{eq}), каждая подстрока обрабатывается отдельно.
Значение свойства должно быть списком от одного до четырех элементов в
следующем формате (где элементы после первого могут быть опущены):

@example
(@var{function} @var{param} @var{noexclude} @var{undo})
@end example

  Вот что делают элементы:

@table @var
@item function
Когда @var{function} равен не-@code{nil}, это вызывается вместо
@code{insert} для вставки строки с одним аргументом - строкой для вставки.

@item param
Если присутствует @var{param} и установлено в не-@code{nil}, это заменяет
@var{string} (или обрабатываемую подстроку @var{string}) как объект,
переданный в @var{function} (или @code{insert}).  Например, если
@var{function} установленно в @code{yank-rectangle}, @var{param} должен быть
списком строк, которые нужно вставить в виде прямоугольника.

@item noexclude
Если присутствует @var{noexclude} и установленно в не-@code{nil}, это
отключает нормальное действие @code{yank-handled-properties} и
@code{yank-excluded-properties} на вставленную строку.

@item undo
Если присутствует @var{undo} и установленно в не-@code{nil}, это функция,
которая будет вызываться @code{yank-pop} для отмены вставки текущего
объекта.  Вызывается с двумя аргументами: началом и концом текущего региона.
@var{function} может установить @code{yank-undo-function}, чтобы
переопределить значение @var{undo}.
@end table

@cindex yanking and text properties
@defopt yank-handled-properties
Переменная определяет специальные условия обработки свойств текста для
извлеченного текста.  Вступает в силу после того, как текст был вставлен
(обычно или через свойство @code{yank-handler}), но до того, как
@code{yank-excluded-properties} вступит в силу.

Значение должно быть списком элементов @code{(@var{prop} . @var{fun})}.
Каждый элемент этого ассоциативного списка обрабатывается по порядку.
Вставленный текст сканируется на предмет фрагментов текста, имеющих
текстовые свойства от @code{eq} до @var{prop}; для каждого такого растяжения
вызывается @var{fun} с тремя аргументами: значением свойства, а также
начальной и конечной позициями текста.
@end defopt

@defopt yank-excluded-properties
Значение этой переменной - это список свойств, которые нужно удалить из
вставленного текста.  Её значение по умолчанию содержит свойства, которые
могут привести к неприятным результатам, например, заставить текст
реагировать на мышь или указать привязки ключей.  Вступает в силу после
@code{yank-handled-properties}.
@end defopt


@node Yank Commands
@subsection Функции для Восстановления

  В этом разделе описаны высокоуровневые команды для восстановления, которые
предназначены в первую очередь для пользователя, но полезны также в
программах на Lisp.  Обе @code{yank} и @code{yank-pop} учитывают переменную
@code{yank-excluded-properties} и текстовое свойство @code{yank-handler}
(@pxref{Yanking}).

@deffn Command yank &optional arg
@cindex inserting killed text
Команда вставляет текст перед точкой в начале списка уничтожений.
Устанавливает метку в начале этого текста, используя @code{push-mark}
(@pxref{The Mark}), и ставит точку в конце.

Если @var{arg} - это список не-@code{nil} (который появляется в
интерактивном режиме, когда пользователь вводит @kbd{C-u} без цифр), то
@code{yank} вставляет текст, как описано выше, но ставит точку перед
извлеченным текстом и устанавливает метку после него.

Если @var{arg} - это число, то @code{yank} вставляет последний @var{arg}
уничтоженный текст - @var{arg} аргумента из списка кольца уничтожения,
циклически отсчитываемый спереди, который затем считается первым элементом
для этой цели.

@code{yank} не изменяет содержимое списка уничтожений, если только не
используется текст, предоставленный другой программой, и в этом случае
помещается этот текст в список уничтожений.  Однако, если @var{arg} - целое
число, отличное от единицы, это проворачивает кольцо уничтожения, чтобы
поместить извлеченную строку впереди.

@code{yank} возвращает @code{nil}.
@end deffn

@deffn Command yank-pop &optional arg
Команда заменяет только что извлеченную запись из списка уничтожений другой
записью из списка уничтожений.

Это разрешено только сразу после @code{yank} или другого @code{yank-pop}.  В
это время в регионе содержится текст, который был вставлен восстановлением.
@code{yank-pop} удаляет этот текст и вставляет на его место другой фрагмент
уничтоженного текста.  Не добавляется удаленный текст в список уничтожений,
поскольку он уже находится где-то в списке уничтожений.  Тем не менее,
проворачивается кольцо уничтожений, чтобы поместить недавно восстановленную
строку впереди.

Если @var{arg} равен @code{nil}, то текст замены - это предыдущий элемент
списка уничтожений.  Если @var{arg} является числовым, заменой является
предыдущее уничтожение @var{arg}.  Если @var{arg} отрицательно, заменой
является более недавнее уничтожение.

Последовательность уничтожений в кольце уничтожений повторяется так, что
после самого старого идет самое новое, а перед самого нового - самое старое.

Возвращаемое значение всегда @code{nil}.
@end deffn

@defvar yank-undo-function
Если эта переменная - не-@code{nil}, функция @code{yank-pop} использует ее
значение вместо @code{delete-region} для удаления текста, вставленного
предыдущей командой @code{yank} или @code{yank-pop}.  Значение должно быть
функцией двух аргументов, начала и конца текущей области.

Функция @code{insert-for-yank} автоматически устанавливает эту переменную в
соответствии с элементом @var{undo} текстового свойства @code{yank-handler},
если оно есть.
@end defvar

@node Low-Level Kill Ring
@subsection Кольцо Уничтожения Низкого Уровня

  Эти функции и переменные обеспечивают доступ к списку уничтожений на более
низком уровне, но по-прежнему удобны для использования в программах на Lisp,
потому что они заботятся о взаимодействии с выбором оконной системы
(@pxref{Window System Selections}).

@defun current-kill n &optional do-not-move
Функция @code{current-kill} поворачивает указатель восстановления, который
обозначает переднюю часть кольца уничтожений, на @var{n} мест (от новых
уничтожений к более старым) и возвращает текст в этом месте кольца.

Если необязательный второй аргумент @var{do-not-move} - не-@code{nil}, то
@code{current-kill} не изменяет указатель восстановления; просто
возвращается @var{n}-е уничтожение, считая от текущего указателя
восстановления.

Если @var{n} равен нулю, что указывает на запрос последнего уничтожения,
@code{current-kill} вызывает значение @code{interprogram-paste-function}
(задокументировано ниже) перед обращением к кольцу уничтожений.  Если это
значение является функцией и при ее вызове возвращается строка или список из
нескольких строк, @code{current-kill} помещает строки в список уничтожений и
возвращает первую строку.  Также устанавливает указатель восстановления так,
чтобы он указывал на запись аннулирования первой строки, возвращаемой
@code{interprogram-paste-function}, независимо от значения
@var{do-not-move}.  В противном случае @code{current-kill} не обрабатывает
нулевое значение для @var{n} специально: возвращает запись, на которую
указывает указатель восстановления, и не перемещает указатель
восстановления.
@end defun

@defun kill-new string &optional replace
Функция помещает текст @var{string} в список уничтожений и заставляет
указатель восстановления указывать на него.  При необходимости отбрасывает
самую старую запись.  Также вызывает значения
@code{interprogram-paste-function} (в зависимости от пользовательской опции
@code{save-interprogram-paste-before-kill}) и
@code{interprogram-cut-function} (смотреть ниже).

Если @var{replace} равен не-@code{nil}, то @code{kill-new} заменяет первый
элемент списка уничтожений на @var{string}, а не помещает @var{string} в
список уничтожений.
@end defun

@defun kill-append string before-p
Функция добавляет текст @var{string} к первой записи в списке уничтожений и
заставляет указатель восстановления указывать на комбинированную запись.
Обычно @var{string} идет в конце записи, но если @var{before-p} равен
не-@code{nil}, тогда идёт в начале.  Функция вызывает @code{kill-new} как
подпрограмму, вызывая тем самым вызов значений
@code{interprogram-cut-function} и, возможно,
@code{interprogram-paste-function} (смотреть ниже) по расширению.
@end defun

@defvar interprogram-paste-function
Переменная обеспечивает способ передачи уничтоженного текста из других
программ, когда используется оконная система.  Её значение должно быть
@code{nil} или функцией без аргументов.

Если значение является функцией, @code{current-kill} вызывает ее, чтобы
получить самое последнее уничтожение.  Если функция возвращает значение
не-@code{nil}, то это значение используется как последнее уничтожение.  Если
возвращается @code{nil}, то используется передняя часть кольца уничтожения.

Чтобы облегчить поддержку оконных систем, которые поддерживают множественный
выбор, эта функция также может возвращать список строк.  В этом случае
первая строка используется как самое последнее уничтожение, а все остальные
строки помещаются в список уничтожений для облегчения доступа с помощью
@code{yank-pop}.

Обычное использование этой функции - получить буфер обмена оконной системы
как последнее уничтожение, даже если выбор принадлежит другому приложению.
@xref{Window System Selections}.  Однако, если содержимое буфера обмена
поступает из текущего сеанса Emacs, эта функция должна вернуть @code{nil}.
@end defvar

@defvar interprogram-cut-function
Переменная обеспечивает способ передачи уничтоженного текста другим
программам, когда используется оконная система.  Её значение должно быть
@code{nil} или функцией одного обязательного аргумента.

Если значение является функцией, @code{kill-new} и @code{kill-append}
вызывает ее с новым первым элементом списка уничтожений в качестве
аргумента.

Обычно эта функция используется для помещения недавно убитого текста в буфер
обмена оконной системы.  @xref{Window System Selections}.
@end defvar

@node Internals of Kill Ring
@subsection Устройство Кольца Уничтожений

  Переменная @code{kill-ring} хранит содержимое списка уничтожений в виде
списка строк.  Последнее уничтожение всегда находится в начале списка.

  Переменная @code{kill-ring-yank-pointer} указывает на ссылку в списке
списка уничтожений, @sc{car} которого - текст, который нужно скопировать
следующим.  Говорится, что идентифицируется передняя часть кольца.
Перемещение @code{kill-ring-yank-pointer} на другую ссылку называется
@dfn{ротация кольца уничтожений}.  Называется список уничтожений ``кольцо'',
потому что функции, которые перемещают указатель восстановления,
перемещаются от конца списка к началу или наоборот.  Вращение кольца
уничтожения является виртуальным; это не меняет значение @code{kill-ring}.

  Обе переменные @code{kill-ring} и @code{kill-ring-yank-pointer} являются
переменными Lisp, значения которых обычно являются списками.  Слово
``pointer'' в имени @code{kill-ring-yank-pointer} указывает, что цель
переменной - идентифицировать один элемент списка для использования
следующей командой восстановления.

  Значение @code{kill-ring-yank-pointer} всегда равно @code{eq} к одной из
ссылок в списке уничтожения.  Идентифицируемый элемент - это @sc{car} этой
ссылки.  Команды уничтожения, которые изменяют список уничтожений, также
устанавливают для этой переменной значение @code{kill-ring}.  Эффект состоит
в том, чтобы провернуть кольцо так, чтобы только что уничтоженный текст
оказался впереди.

  Вот диаграмма, которая показывает переменную
@code{kill-ring-yank-pointer}, указывающую на вторую запись в списке
уничтожений
@code{("some text" "a different piece of text" "yet older text")}.

@example
@group
kill-ring                  ---- kill-ring-yank-pointer
  |                       |
  |                       v
  |     --- ---          --- ---      --- ---
   --> |   |   |------> |   |   |--> |   |   |--> nil
        --- ---          --- ---      --- ---
         |                |            |
         |                |            |
         |                |             -->"yet older text"
         |                |
         |                 --> "a different piece of text"
         |
          --> "some text"
@end group
@end example

@noindent
Такое положение вещей может произойти после @kbd{C-y} (@code{yank}), сразу
за которым следует @kbd{M-y} (@code{yank-pop}).

@defvar kill-ring
Переменная содержит список уничтоженных текстовых последовательностей,
которые были уничтожены первыми.
@end defvar

@defvar kill-ring-yank-pointer
Значение этой переменной указывает, какой элемент кольца уничтожения
находится в передней части кольца для восстановления.  Точнее, значение -
это хвост значения @code{kill-ring}, а его @sc{car} - это строка
уничтожения, которую @kbd{C-y} должен восстановить.
@end defvar

@defopt kill-ring-max
Значение этой переменной - максимальная длина, до которой может вырасти
список уничтожений, прежде чем элементы будут выброшены в конце.  Значение
по умолчанию для @code{kill-ring-max} - 60.
@end defopt

@node Undo
@section Отмена
@cindex redo

  Большинство буферов имеют @dfn{лист отмены}, который записывает все
изменения, внесенные в текст буфера, чтобы их можно было отменить.  (Буферы,
у которых его нет, обычно являются буферами специального назначения, для
которых Emacs предполагает, что отмена бесполезна.  В частности, для любого
буфера, имя которого начинается с пробела, запись отмены по умолчанию
отключена; смотреть @ref{Buffer Names}.)  Все примитивы, которые изменяют
текст в буфере, автоматически добавляют элементы в начало списка отмены,
который находится в переменной @code{buffer-undo-list}.

@defvar buffer-undo-list
Значение этой локальной переменной буфера является списком отмены текущего
буфера.  Значение @code{t} отключает запись информации отмены.
@end defvar

Вот типы элементов, которые может иметь список отмены:

@table @code
@item @var{position}
Этот тип элемента записывает предыдущее значение точки; отмена этого
элемента перемещает точку на @var{position}.  Обычное движение курсора не
вызывает никаких записей отмены, но операции удаления используют эти записи
для записи того места, где находилась точка перед командой.

@item (@var{beg} . @var{end})
Этот тип элемента указывает, как удалить вставленный текст.  После вставки
текст будет занимать в буфере диапазон @var{beg}--@var{end}.

@item (@var{text} . @var{position})
Этот тип элемента указывает, как повторно вставить удаленный текст.  Сам
удаленный текст представляет собой строку @var{text}.  Место для повторной
вставки - @code{(abs @var{position})}.  Если @var{position} положительно,
точка была в начале удаленного текста, в противном случае - в конце.  Сразу
после этого элемента следуют ноль или более элементов
(@var{marker} . @var{adjustment}).

@item (t . @var{time-flag})
Этот тип элемента указывает на то, что неизмененный буфер стал измененным.
@var{time-flag} формы
@code{(@var{sec-high} @var{sec-low} @var{microsec} @var{picosec})}
представляет время изменения посещенного файла с момента его предыдущего
посещения или сохранения, используя тот же формат, что и
@code{current-time}; смотреть @ref{Time of Day}.  Значение 0 для
@var{time-flag} означает, что буфер не соответствует ни одному файлу;
@minus{}1 означает, что ранее посещенный файл не существовал.
@code{primitive-undo} использует эти значения, чтобы определить, следует ли
снова пометить буфер как немодифицированный; это происходит только в том
случае, если статус файла совпадает со статусом @var{time-flag}

@item (nil @var{property} @var{value} @var{beg} . @var{end})
Этот тип элемента регистрирует изменение свойства текста.  Вот как можно
отменить изменение:

@example
(put-text-property @var{beg} @var{end} @var{property} @var{value})
@end example

@item (@var{marker} . @var{adjustment})
Этот тип элемента фиксирует тот факт, что маркер @var{marker} был перемещен
из-за удаления окружающего текста, и что он переместил позиции символа
@var{adjustment}.  Если положение маркера соответствует элементу
(@var{text} . @var{position}), предшествующему ему в списке отмены, то при
отмене этого элемента перемещаются символы @var{marker} @minus{}
@var{adjustment}.

@item (apply @var{funname} . @var{args})
Это расширяемый элемент отмены, который отменяется вызовом @var{funname} с
аргументами @var{args}.

@item (apply @var{delta} @var{beg} @var{end} @var{funname} . @var{args})
Это расширяемый элемент отмены, который записывает изменение, ограниченное
диапазоном от @var{beg} до @var{end}, что увеличивает размер буфера на
символы @var{delta}.  Это отменяется вызовом @var{funname} с аргументами
@var{args}.

Этот тип элемента позволяет отменить, ограниченную областью, чтобы
определить, относится ли элемент к этой области.

@item nil
Этот элемент является границей.  Элементы между двумя границами называются
@dfn{сменой группы}; обычно каждая группа изменений соответствует одной
клавиатурной команде, а команды отмены обычно отменяют всю группу как
единое целое.
@end table

@defun undo-boundary
Функция помещает граничный элемент в список отмены.  Команда отмены
останавливается на такой границе, а последующие команды отмены отменяются до
более ранней границы.  Функция возвращает @code{nil}.

Явный вызов этой функции полезен для разделения эффектов команды на более
чем одну единицу.  Например, @code{query-replace} вызывает
@code{undo-boundary} после каждой замены, чтобы пользователь мог отменить
отдельные замены одну за другой.

Однако в большинстве случаев эта функция вызывается автоматически в
подходящее время.
@end defun

@defun undo-auto-amalgamate
@cindex amalgamating commands, and undo
Командный цикл редактора автоматически вызывает @code{undo-boundary}
непосредственно перед выполнением каждой последовательности ключей, так что
каждая отмена обычно отменяет действие одной команды.  Несколько
исключительных команд @dfn{слияния}: эти команды обычно вызывают небольшие
изменения в буферах, поэтому с ними граница вставляется только каждую 20-ю
команду, что позволяет отменять изменения как группу.  По умолчанию команды
@code{self-insert-command}, производящие самовставляющиеся входные символы
(@pxref{Commands for Insertion}), и @code{delete-char}, удаляющие символы
(@pxref{Deletion}), объединяются.  Если команда влияет на содержимое
нескольких буферов, как это может случиться, например, когда функция в
@code{post-command-hook} влияет на буфер, отличный от @code{current-buffer},
тогда @code{undo-boundary} будет вызываться в каждом из затронутых буферов.
@end defun

@defvar undo-auto-current-boundary-timer
Некоторые буферы, такие как буферы процессов, могут изменяться, даже если
никакие команды не выполняются.  В этих случаях @code{undo-boundary} обычно
периодически вызывается таймером в этой переменной.  Установка этой
переменной в не-@code{nil} предотвращает такое поведение.
@end defvar

@defvar undo-in-progress
Обычно это переменная @code{nil}, но команды отмены связывают ее с @code{t}.
Это сделано для того, чтобы различные виды перехватчиков изменений могли
определить, когда они вызываются ради отмены.
@end defvar

@defun primitive-undo count list
Это основная функция для отмены элементов списка отмены.  Отменяет первых
@var{count} элементов @var{list}, возвращая остальную часть @var{list}.

@code{primitive-undo} добавляет элементы в список отмены буфера при
изменении буфера.  Команды отмены позволяют избежать путаницы, сохраняя
значение списка отмены в начале последовательности операций отмены.  Затем
операции отмены используют и обновляют сохраненное значение.  Новые
элементы, добавленные при отмене, не являются частью этого сохраненного
значения, поэтому они не мешают продолжению отмены.

Функция не связывает @code{undo-in-progress}.
@end defun

@node Maintaining Undo
@section Ведение Списков Отмены

  В этом разделе описывается, как включать и отключать информацию отмены для
данного буфера.  Также объясняется, как список отмены автоматически
усекается, чтобы не становиться слишком большим.

  Запись информации об отмене во вновь созданный буфер обычно разрешена для
начала; но если имя буфера начинается с пробела, отмена записи изначально
отключена.  Можно явно включить или отключить запись отмены с помощью
следующих двух функций или самостоятельно установив @code{buffer-undo-list}.

@deffn Command buffer-enable-undo &optional buffer-or-name
Команда включает запись информации об отмене для буфера
@var{buffer-or-name}, чтобы можно было отменить последующие изменения.  Если
аргумент не указан, используется текущий буфер.  Функция ничего не делает,
если в буфере уже включена отмена записи.  Возвращается @code{nil}.

В интерактивном вызове @var{buffer-or-name} - это текущий буфер.  Не
получится указать какой-либо другой буфер.
@end deffn

@deffn Command buffer-disable-undo &optional buffer-or-name
@cindex disabling undo
Функция отменяет список отмены @var{buffer-or-name} и отключает дальнейшую
запись информации отмены.  В результате больше невозможно отменить ни
предыдущие изменения, ни любые последующие изменения.  Если список отмены
@var{buffer-or-name} уже отключен, функция не действует.

В интерактивном вызове BUFFER-OR-NAME - это текущий буфер.  Не выйдет
указать какой-либо другой буфер.  Функция возвращает @code{nil}.
@end deffn

  По мере продолжения редактирования списки отмены становятся все длиннее и
длиннее.  Чтобы они не использовали все доступное пространство памяти,
сборка мусора обрезает их до установленных ограничений по размеру.  (Для
этой цели размер списка отмены измеряет cons-ячейки, составляющие список,
плюс строки удаленного текста.)  Диапазон допустимых размеров регулируется
тремя переменными: @code{undo-limit}, @code{undo-strong-limit} и
@code{undo-outer-limit}.  В этих переменных размер рассчитывается как
количество занятых байтов, которое включает как сохраненный текст, так и
другие данные.

@defopt undo-limit
Это мягкий предел допустимого размера списка отмены.  Группа изменений, в
которой превышен этот размер, остается последней.
@end defopt

@defopt undo-strong-limit
Это верхний предел допустимого размера списка отмены.  Группа изменений, в
которой этот размер превышен, отбрасывается сама (вместе со всеми более
ранними группами изменений).  Есть одно исключение: самая последняя группа
изменений отбрасывается, только если она превышает @code{undo-outer-limit}.
@end defopt

@defopt undo-outer-limit
Если во время сборки мусора информация об отмене для текущей команды
превышает этот предел, Emacs отбрасывает информацию и отображает
предупреждение.  Это последний предел для предотвращения переполнения
памяти.
@end defopt

@defopt undo-ask-before-discard
Если эта переменная - не-@code{nil}, когда информация об отмене превышает
@code{undo-outer-limit}, Emacs спрашивает в эхо-области, следует ли
отбросить информацию.  Значение по умолчанию - @code{nil}, что означает его
автоматическое удаление.

Эта опция в основном предназначена для отладки.  Сборка мусора запрещена,
пока задается вопрос, а это означает, что Emacs может вызвать утечку памяти,
если пользователь слишком долго ждет, прежде чем ответить на вопрос.
@end defopt

@node Filling
@section Заполнение
@cindex filling text

  @dfn{Заполнение} означает настройку длины строк (путем перемещения
разрывов строк) так, чтобы они были почти (но не больше) указанной
максимальной ширины.  Кроме того, строки могут иметь @dfn{оправданный}
формат, что означает вставку пробелов для точного выравнивания левого и/или
правого полей.  Ширина регулируется переменной @code{fill-column}.  Для
удобства чтения строки не должны быть длиннее 70 или около того столбцов.

  Можно использовать режим Auto Fill (@pxref{Auto Filling}) для
автоматического заполнения текста по мере его вставки, но изменения в
существующем тексте могут привести к его неправильному заполнению.  Затем
потребуется заполнить текст явно.

  Большинство команд в этом разделе возвращают значения, которые не имеют
смысла.  Все функции, выполняющие заполнение, принимают во внимание текущее
левое поле, текущее правое поле и текущий стиль выравнивания
(@pxref{Margins}).  Если текущий стиль выравнивания - @code{none}, функции
заполнения фактически ничего не делают.

  Некоторые функции заполнения имеют аргумент @var{justify}.  Если устанолен
в не-@code{nil}, требуется какое-то обоснование.  Это может быть
@code{left}, @code{right}, @code{full}, или @code{center}, чтобы запросить
конкретный стиль обоснования.  Если аргумент установлен в @code{t}, это
означает, что для этой части текста используется текущий стиль выравнивания
(смотреть @code{current-justification}, ниже).  Любое другое значение
рассматривается как @code{full}.

  Когда вызываются функции заполнения в интерактивном режиме, использование
префиксного аргумента подразумевает значение @code{full} для @var{justify}.

@deffn Command fill-paragraph &optional justify region
Команда заполняет абзац в точке или после нее.  Если @var{justify} равен
не-@code{nil}, каждая строка также выравнивается.  Используются обычные
команды перемещения абзаца для поиска границ абзаца.
@xref{Paragraphs,,, emacs, The GNU Emacs Manual}.

Если @var{region} равен не-@code{nil}, и если включен режим Transient Mark
с активной меткой, команда вызывает @code{fill-region} для заполнения всех
абзацев в области вместо заполнения только текущего абзаца.  Когда команда
вызывается в интерактивном режиме, @var{region} становится @code{t}.
@end deffn

@deffn Command fill-region start end &optional justify nosqueeze to-eop
Команда заполняет каждый абзац в области от @var{start} до @var{end}.  Это
также оправдывает, если @var{justify} равен не-@code{nil}.

Если @var{nosqueeze} равен не-@code{nil}, это означает, что пробелы, кроме
разрывов строк, должны оставаться нетронутыми.  Если @var{to-eop} -
не-@code{nil}, это означает, что нужно продолжать заполнение до конца абзаца
--- или до следующего жесткого перехода на новую строку, если
@code{use-hard-newlines} включен (смотреть ниже).

Переменная @code{paragraph-separate} определяет, как различать абзацы.
@xref{Standard Regexps}.
@end deffn

@deffn Command fill-individual-paragraphs start end &optional justify citation-regexp
Эта команда заполняет каждый абзац в области в соответствии с его
индивидуальным префиксом заливки.  Таким образом, если строки абзаца имеют
отступ с пробелами, заполненный абзац останется с таким же отступом.

Первые два аргумента @var{start} и @var{end} - это начало и конец области
для заполнения.  Третий и четвертый аргументы @var{justify} и
@var{citation-regexp} необязательны.  Если @var{justify} установлен в
не-@code{nil}, абзацы выравниваются и заполняются.  Если
@var{citation-regexp} - не-@code{nil}, это означает, что функция работает с
почтовым сообщением и, следовательно, не должна заполнять строки заголовка.
Если @var{citation-regexp} - строка, она используется как регулярное
выражение; если совпадает с началом строки, эта строка рассматривается как
маркер цитирования.

@c FIXME:"Этот режим" сбивает с толку. Это не основной/второстепенный режим.
Обычно @code{fill-individual-paragraphs} рассматривает каждое изменение
отступа как начало нового абзаца.  Если
@code{fill-individual-varying-indent} равен не-@code{nil}, то абзацы
разделяются только линиями-разделителями.  Этот режим может обрабатывать
абзацы с дополнительным отступом в первой строке.
@end deffn

@defopt fill-individual-varying-indent
Переменная изменяет действие @code{fill-individual-paragraphs}, как описано
выше.
@end defopt

@deffn Command fill-region-as-paragraph start end &optional justify nosqueeze squeeze-after
Команда рассматривает область текста как один абзац и заполняет его.  Если
область состояла из множества абзацев, пустые строки между абзацами
удаляются.  Функция оправдывает, как и заливку, когда @var{justify} равно
не-@code{nil}.

Если @var{nosqueeze} равен не-@code{nil}, это означает, что пробелы, кроме
разрывов строк, должны оставаться нетронутыми.  Если @var{squeeze-after}
равен не-@code{nil}, указывается позиция в регионе и означает, что не
следует канонизировать пробелы перед этой позицией.

В режиме адаптивной заливки эта команда вызывает @code{fill-context-prefix}
для выбора префикса заливки по умолчанию.  @xref{Adaptive Fill}.
@end deffn

@deffn Command justify-current-line &optional how eop nosqueeze
Команда вставляет пробелы между словами текущей строки, так что строка
заканчивается точно на @code{fill-column}.  Возвращается @code{nil}.

Аргумент @var{how}, если не-@code{nil} явно указывает стиль выравнивания.
Это может быть @code{left}, @code{right}, @code{full}, @code{center} или
@code{none}.  Если это @code{t}, это означает, что нужно следовать
указанному стилю выравнивания (смотреть @code{current-justification}, ниже).
@code{nil} означает полное обоснование.

Если @var{eop} равен не-@code{nil}, это означает, что выравнивание
выполняется только по левому краю, если @code{current-justification}
указывает полное выравнивание.  Используется для последней строки абзаца;
даже если абзац полностью выровнен по ширине, последней строки быть не
должно.

Если @var{nosqueeze} равен не-@code{nil}, это означает, что внутренние
пробелы не меняются.
@end deffn

@defopt default-justification
Значение переменной определяет стиль выравнивания текста, который не задает
стиль со свойством текста.  Возможные значения: @code{left}, @code{right},
@code{full}, @code{center} или @code{none}.  Значение по умолчанию -
@code{left}.
@end defopt

@defun current-justification
Функция возвращает правильный стиль выравнивания, используемый для
заполнения текста вокруг точки.

Возвращается значение текстового свойства @code{justification} в точке или
переменную @code{default-justification}, если такого текстового свойства
нет.  Однако возвращается @code{nil}, а не @code{none}, что означает
``не оправдывать''.
@end defun

@defopt sentence-end-double-space
@anchor{Definition of sentence-end-double-space}
Если переменная - не-@code{nil}, точка, за которой следует только один
пробел, не считается концом предложения, а функции заполнения избегают
разрыва строки в таком месте.
@end defopt

@defopt sentence-end-without-period
Если переменная - не-@code{nil}, предложение может заканчиваться без точки.
Это используется для таких языков, как тайский, где предложения
заканчиваются двойным пробелом, но без точки.
@end defopt

@defopt sentence-end-without-space
Если переменная - не-@code{nil}, это должна быть строка символов, которая
может заканчивать предложение без следующих пробелов.
@end defopt

@defopt fill-separate-heterogeneous-words-with-space
Если переменная - не-@code{nil}, два слова разного типа (например,
английское и CJK) будут разделены пробелом при объединении одного, которое
находится в конце строки, и другого, которое находится в начале следующей
строки для заполнения.
@end defopt

@defvar fill-paragraph-function
Переменная позволяет переопределить заполнение абзацев.  Если её значение -
не-@code{nil}, @code{fill-paragraph} вызывает эту функцию для выполнения
работы.  Если функция возвращает значение не-@code{nil},
@code{fill-paragraph} предполагает, что работа выполнена, и немедленно
возвращается это значение.

Обычно функция используется для заполнения комментариев в режимах языка
программирования.  Если функции необходимо заполнить абзац обычным способом,
это можно сделать следующим образом:

@example
(let ((fill-paragraph-function nil))
  (fill-paragraph arg))
@end example
@end defvar

@defvar fill-forward-paragraph-function
Переменная позволяет переопределить способ перехода функций заполнения,
таких как @code{fill-region} и @code{fill-paragraph}, к следующему абзацу.
Её значением должна быть функция, которая вызывается с одним аргументом
@var{n}, количеством абзацев, которые нужно переместить, и должна возвращать
разницу между @var{n} и количеством фактически перемещенных абзацев.
Значение по умолчанию для этой переменной - @code{forward-paragraph}.
@xref{Paragraphs,,, emacs, GNU Emacs Руководство}.
@end defvar

@defvar use-hard-newlines
Если переменная - не-@code{nil}, функции заполнения не удаляют символы новой
строки, имеющие текстовое свойство @code{hard}.  Эти жесткие символы новой
строки действуют как разделители абзацев.
@xref{Hard and Soft Newlines,, Hard and Soft Newlines, emacs, GNU Emacs Руководство}.
@end defvar

@node Margins
@section Поля для Заливки
@cindex margins, filling

@defopt fill-prefix
Эта локальная в буфере переменная, если не-@code{nil}, определяет строку
текста, которая появляется в начале обычных текстовых строк и должна
игнорироваться при их заполнении.  Любая строка, которая не начинается с
префикса заполнения, считается началом абзаца; то же самое можно сказать о
любой строке, которая начинается с префикса заполнения, за которым следует
дополнительный пробел.  Строки, начинающиеся с префикса заполнения, но без
дополнительных пробелов, являются обычными текстовыми строками, которые
можно заполнять вместе.  Результирующие закрашенные линии также начинаются с
префикса заливки.

Префикс заполнения следует за пробелом левого поля, если таковой имеется.
@end defopt

@defopt fill-column
Локальная в буфере переменная определяет максимальную ширину заполненных
линий.  Его значение должно быть целым числом, которое представляет собой
количество столбцов.  Переменная влияет на все команды заливки, выравнивания
и центрирования, включая режим Auto Fill (@pxref{Auto Filling}).

На практике, если пишется текст для чтения другими людьми, следует
установить @code{fill-column} не более 70.  В противном случае строка будет
слишком длинной, чтобы люди могли читать с комфортом, и это может сделать
текст неуклюжим.

Значение по умолчанию для @code{fill-column} - 70.
@end defopt

@deffn Command set-left-margin from to margin
Это устанавливает свойство @code{left-margin} текста от @var{from} до
@var{to} в значение @var{margin}.  Если включен режим Auto Fill, эта команда
также заполняет область, чтобы она соответствовала новому полю.
@end deffn

@deffn Command set-right-margin from to margin
Это устанавливает свойство @code{right-margin} текста от @var{from} до
@var{to} в значение @var{margin}.  Если включен режим Auto Fill, эта команда
также заполняет область, чтобы она соответствовала новому полю.
@end deffn

@defun current-left-margin
Функция возвращает правильное значение левого поля, используемое для
заполнения текста вокруг точки.  Значение представляет собой сумму свойства
@code{left-margin} символа в начале текущей строки (или нуля, если его нет)
и значения переменной @code{left-margin}.
@end defun

@defun current-fill-column
Функция возвращает правильное значение столбца заполнения, используемое для
заполнения текста вокруг точки.  Значение - это значение переменной
@code{fill-column} за вычетом значения свойства @code{right-margin} символа
после точки.
@end defun

@deffn Command move-to-left-margin &optional n force
Функция перемещает точку к левому краю текущей строки.  Перемещаемый столбец
определяется вызовом функции @code{current-left-margin}.  Если аргумент
@var{n} - не-@code{nil}, @code{move-to-left-margin} сначала перемещает
вперед строки на @var{n}@minus{}1.

Если @var{force} равен не-@code{nil}, это говорит о том, что нужно исправить
отступ строки, если он не соответствует значению левого поля.
@end deffn

@defun delete-to-left-margin &optional from to
Функция удаляет отступ левого края текста между @var{from} и @var{to}.
Величина удаляемого отступа определяется вызовом @code{current-left-margin}.
Ни в коем случае эта функция не удаляет непробельные символы.  Если
@var{from} и @var{to} опущены, по умолчанию используется весь буфер.
@end defun

@defun indent-to-left-margin
Функция регулирует отступ в начале текущей строки до значения, указанного
переменной @code{left-margin}.  (Это может включать в себя вставку или
удаление пробелов.)  Функция является значением @code{indent-line-function}
в режиме текста с отступом от абзаца.
@end defun

@defopt left-margin
Переменная определяет базовый столбец левого поля.  В основном режиме
@key{RET} отступает от этого столбца.  Переменная автоматически становится
локальной в буфере, если она установлена любым способом.
@end defopt

@defopt fill-nobreak-predicate
Переменная дает основным режимам возможность указать, чтобы строка не
разрывалась в определенных местах.  Её значением должен быть список функций.
Каждый раз, когда при заполнении рассматривается разрыв строки в
определенном месте в буфере, вызывается каждая из этих функций без
аргументов и с точкой, расположенной в этом месте.  Если какая-либо из
функций вернет не-@code{nil}, то строка там не разорвется.
@end defopt

@node Adaptive Fill
@section Адаптивный Режим Заливки
@c @cindex Did you mean: Adaptive Fill mode of 0 is adjacent.
Режим адаптивной заливки "adaptive-fill-mode" находится рядом.

  Когда @dfn{Adaptive Fill Mode} включен, Emacs автоматически определяет
префикс заполнения по тексту в каждом заполняемом абзаце, а не по заранее
заданному значению.  Во время заполнения этот префикс заполнения вставляется
в начало второй и последующих строк абзаца, как описано в @ref{Filling} и
@ref{Auto Filling}.

@defopt adaptive-fill-mode
Режим адаптивного заполнения включается, если эта переменная имеет значение
не-@code{nil}.  По умолчанию установлена в @code{t}.
@end defopt

@defun fill-context-prefix from to
Функция реализует суть режима адаптивной заливки; он выбирает префикс
заполнения на основе текста между @var{from} и @var{to}, обычно это начало и
конец абзаца.  Это делается путем просмотра первых двух строк абзаца на
основе переменных, описанных ниже.
@c Необязательный аргумент first-line-regexp не задокументирован,
@c потому что он существует для внутренних целей и может быть исключен
@c в будущем.

Обычно функция возвращает префикс заполнения, строку.  Однако перед этим
функция выполняет окончательную проверку (отдельно не упоминается ниже),
того что строка, начинающаяся с этого префикса, не будет выглядеть как
начало абзаца.  В этом случае функция сигнализирует об аномалии, вместо
этого возвращая @code{nil}.

Подробно @code{fill-context-prefix} делает это:

@enumerate
@item
Берёт кандидата на префикс заполнения из первой строки - сначала пробует
функцию из @code{adaptive-fill-function} (если есть), затем регулярное
выражение @code{adaptive-fill-regexp} (смотреть ниже).  Первый результат
не-@code{nil} из них или пустая строка, если они оба @code{nil}, становится
кандидатом на первую строку.
@item
Если в абзаце пока только одна строка, функция проверяет действительность
только что найденного кандидата на префикс.  Затем функция возвращает
кандидата, если он действителен, или строку пробелов в противном случае.
(смотреть описание @code{adaptive-fill-first-line-regexp} ниже).
@item
Когда в абзаце уже есть две строки, функция затем ищет кандидата на префикс
во второй строке, точно так же, как и для первой строки.  Если не находит,
возвращается @code{nil}.
@item
Теперь функция эвристически сравнивает два префикса-кандидата: если
непробельные символы в кандидате на строку 2 встречаются в том же порядке в
кандидате на строку 1, функция возвращает кандидата на строку 2.  В
противном случае он возвращает самую большую начальную подстроку, которая
является общей для обоих кандидатов (которая может быть пустой строкой).
@end enumerate
@end defun

@defopt adaptive-fill-regexp
Режим адаптивной заливки сопоставляет это регулярное выражение с текстом,
начинающимся после левого пробела (если есть) в строке; символы, которым он
соответствует, являются кандидатом этой строки на префикс заполнения.

Значение по умолчанию совпадает с пробелами с некоторыми перемешанными
знаками пунктуации.
@end defopt

@defopt adaptive-fill-first-line-regexp
Используемое только в однострочных абзацах, это регулярное выражение
действует как дополнительная проверка допустимости одного доступного
префикса заполнения кандидата: кандидат должен соответствовать этому
регулярному выражению или соответствовать @code{comment-start-skip}.  В
противном случае @code{fill-context-prefix} заменяет кандидата строкой
пробелов той же ширины, что и он.


Значение по умолчанию для этой переменной - @w{@code{"\\`[ \t]*\\'"}}, что
соответствует только строке пробелов.  Эффект от этого значения по умолчанию
состоит в том, что префиксы заполнения в однострочных абзацах всегда должны
быть чистыми пробелами.
@end defopt

@defopt adaptive-fill-function
Можно указать более сложные способы автоматического выбора префикса заливки,
установив эту переменную в функцию.  Функция вызывается с точкой после
левого края (если есть) строки, и она должна сохранять точку.  Должна
возвращать либо префикс заполнения этой строки, либо @code{nil}, что
означает, что не вышло определить префикс.
@end defopt

@node Auto Filling
@section Автозаполнение
@cindex filling, automatic
@cindex Auto Fill mode

Режим автозаполнения - это второстепенный режим, при котором строки
заполняются автоматически при вставке текста.
@xref{Auto Fill,,, emacs, Руководство GNU Emacs}.  В этом разделе описаны
некоторые переменные, используемые в режиме автозаполнения.  Описание
функций, которые можно вызывать явно для заполнения и выравнивания
существующего текста, смотреть @ref{Filling}.

  Режим автоматического заполнения также включает функции, которые изменяют
поля и стиль выравнивания для заполнения частей текста.  @xref{Margins}.

@defvar auto-fill-function
Значение этой локальной переменной в буфере должно быть функцией (без
аргументов), которая будет вызываться после самостоятельной вставки символа
из таблицы @code{auto-fill-chars}, смотреть ниже.  Это может быть
@code{nil}, в этом случае ничего собственно не делается.

Значение @code{auto-fill-function} равно @code{do-auto-fill}, когда включен
режим Auto Fill.  Это функция, единственная цель которой - реализовать
обычную стратегию разрыва строки.
@end defvar

@defvar normal-auto-fill-function
Переменная определяет функцию, которая будет использоваться для
@code{auto-fill-function}, если и когда включено Автозаполнение.  Основные
режимы могут устанавливать для этой переменной локальные значения буфера,
чтобы изменить работу автозаполнения.
@end defvar

@defvar auto-fill-chars
Таблица символов, которая вызывает @code{auto-fill-function} при
самостоятельной вставке --- пробел и новая строка в большинстве языковых
средах.  У них в таблице есть запись @code{t}.
@end defvar

@defopt comment-auto-fill-only-comments
Переменная, если не-@code{nil}, означает автоматическое заполнение строк
только в комментариях.  Точнее, это означает, что если синтаксис комментария
был определен для текущего буфера, то самовставка символа вне комментария не
вызовет @code{auto-fill-function}.
@end defopt


@node Sorting
@section Сортировка Текста
@cindex sorting text

  Все функции сортировки, описанные в этом разделе, переупорядочивают текст
в буфере.  В этом отличие от функции @code{sort}, которая меняет порядок
элементов списка (@pxref{Rearrangement}).  Значения, возвращаемые этими
функциями, не имеют смысла.

@defun sort-subr reverse nextrecfun endrecfun &optional startkeyfun endkeyfun predicate
Функция представляет собой обычную процедуру сортировки текста, которая
разделяет буфер на записи, а затем сортирует их.  Большинство команд в этом
разделе используют эту функцию.

Чтобы понять, как работает @code{sort-subr}, рассмотреть всю доступную часть
буфера как разделенную на непересекающиеся части, называемые
@dfn{сортировочные записи}.  Записи могут быть или не быть смежными, но они
не должны перекрываться.  Часть каждой записи сортировки (возможно, вся она)
обозначается как ключ сортировки.  При сортировке записи упорядочиваются по
их ключам сортировки.

Обычно записи располагаются в порядке возрастания ключа сортировки.  Если
первым аргументом функции @code{sort-subr}, @var{reverse}, является
не-@code{nil}, записи сортировки меняются в порядке убывания ключа
сортировки.

Следующие четыре аргумента @code{sort-subr} - это функции, которые
вызываются для перемещения точки по записи сортировки.  Они вызываются много
раз изнутри @code{sort-subr}.

@enumerate
@item
@var{nextrecfun} вызывается с точкой в конце записи.  Функция перемещает
точку в начало следующей записи.  Предполагается, что первая запись
начинается с позиции точки при вызове @code{sort-subr}.  Поэтому перед
вызовом @code{sort-subr} обычно следует переместить точку в начало буфера.

Функция может указать, что записей сортировки больше нет, оставив точку в
конце буфера.

@item
@var{endrecfun} вызывается с точкой внутри записи.  Перемещает точку в конец
записи.

@item
@var{startkeyfun} вызывается для перемещения точки из начала записи в начало
ключа сортировки.  Этот аргумент не является обязательным; если он опущен,
вся запись является ключом сортировки.  Если задано, функция должна либо
вернуть значение не-@code{nil}, которое будет использоваться в качестве
ключа сортировки, либо вернуть @code{nil}, чтобы указать, что ключ
сортировки находится в буфере, начиная с точки.  В последнем случае
вызывается @var{endkeyfun}, чтобы найти конец ключа сортировки.

@item
@var{endkeyfun} вызывается для перемещения точки из начала ключа сортировки
в конец ключа сортировки.  Это необязательный аргумент.  Если
@var{startkeyfun} возвращает @code{nil} и этот аргумент опущен (или
@code{nil}), то ключ сортировки распространяется до конца записи.  Нет
необходимости в @var{endkeyfun}, если @var{startkeyfun} возвращает значение
не-@code{nil}.
@end enumerate

Аргумент @var{predicate} - это функция, используемая для сравнения ключей.
Если ключи - числа, по умолчанию используется @code{<}; в противном случае
по умолчанию используется @code{string<}.

В качестве примера @code{sort-subr}, вот полное определение функции для
@code{sort-lines}:

@example
@group
;; @r{Обратить внимание, что первые две строки строки документа}
;; @r{ фактически являются одной строкой при просмотре пользователем.}
(defun sort-lines (reverse beg end)
  "Сортировать строки в регионе по алфавиту;\
 аргумент означает порядок убывания.
Вызывается из программы, есть три аргумента:
@end group
@group
REVERSE (не-nil означает обратный порядок),\
 BEG и END (регион для сортировки).
Переменная `sort-fold-case' определяет,\
влияет ли алфавитный регистр на порядок сортировки."
@end group
@group
  (interactive "P\nr")
  (save-excursion
    (save-restriction
      (narrow-to-region beg end)
      (goto-char (point-min))
      (let ((inhibit-field-text-motion t))
        (sort-subr reverse 'forward-line 'end-of-line)))))
@end group
@end example

Здесь @code{forward-line} перемещает точку в начало следующей записи, а
@code{end-of-line} перемещает точку в конец записи.  Не передаются аргументы
@var{startkeyfun} и @var{endkeyfun}, потому что вся запись используется как
ключ сортировки.

Функция очень похожа на @code{sort-paragraphs}, за исключением того, что ее
вызов @code{sort-subr} выглядит так:

@example
@group
(sort-subr reverse
           (function
            (lambda ()
              (while (and (not (eobp))
                          (looking-at paragraph-separate))
                (forward-line 1))))
           'forward-paragraph)
@end group
@end example

Маркеры, указывающие на любые записи сортировки, остаются без полезной
позиции после возврата @code{sort-subr}.
@end defun

@defopt sort-fold-case
Если эта переменная - не-@code{nil}, @code{sort-subr} и другие функции
сортировки буфера игнорируют регистр при сравнении строк.
@end defopt

@deffn Command sort-regexp-fields reverse record-regexp key-regexp start end
Команда сортирует область между @var{start} и @var{end} в алфавитном
порядке, как указано в @var{record-regexp} и @var{key-regexp}.  Если
@var{reverse} - отрицательное целое число, сортировка выполняется в обратном
порядке.

Алфавитная сортировка означает, что два ключа сортировки сравниваются,
сравнивая первые символы каждого, вторые символы каждого и так далее.  Если
обнаружено несоответствие, это означает, что ключи сортировки неравны; ключ
сортировки, символ которого меньше в точке первого несовпадения, является
меньшим ключом сортировки.  Отдельные символы сравниваются в соответствии с
их числовыми кодами символов в наборе символов Emacs.

Значение аргумента @var{record-regexp} указывает, как разделить буфер на
записи сортировки.  В конце каждой записи выполняется поиск этого
регулярного выражения, и соответствующий ему текст принимается в качестве
следующей записи.  Например, регулярное выражение @samp{^.+$}, которое
соответствует строкам с хотя бы одним символом помимо новой строки,
превратит каждую такую строку в запись сортировки.
@xref{Regular Expressions}, для описания синтаксиса и значения регулярных
выражений.

Значение аргумента @var{key-regexp} указывает, какая часть каждой записи является ключом сортировки.  @var{key-regexp} может соответствовать всей записи
или только ее части.  В последнем случае остальная часть записи не влияет на
порядок сортировки записей, но переносится, когда запись перемещается в
новую позицию.

Аргумент @var{key-regexp} может относиться к тексту, соответствующему
подвыражению @var{record-regexp}, или может быть самостоятельным регулярным
выражением.

Если @var{key-regexp} равно:

@table @asis 
@item @samp{\@var{digit}}
тогда текст, соответствующий группировке скобок @var{digit} @samp{\(...\)}
в @var{record-regexp}, является ключом сортировки.

@item @samp{\&}
тогда вся запись является ключом сортировки.

@item a regular expression
затем @code{sort-regexp-fields} ищет совпадение с регулярным выражением в
записи.  Если такое совпадение найдено, это ключ сортировки.  Если в записи
нет совпадения для @var{key-regexp}, эта запись игнорируется, что означает,
что ее положение в буфере не изменяется.  (Другие записи могут перемещаться
по нему.)
@end table

Например, если планируется сортировать все строки в регионе по первому слову
в каждой строке, начинающейся с буквы @samp{f}, потребуется установить
@var{record-regexp} на @samp{^.*$} и установить @var{key-regexp} в
@samp{\<f\w*\>}.  Результирующее выражение выглядит так:

@example
@group
(sort-regexp-fields nil "^.*$" "\\<f\\w*\\>"
                    (region-beginning)
                    (region-end))
@end group
@end example

Если вызывается @code{sort-regexp-fields} в интерактивном режиме,
запрашивается @var{record-regexp} и @var{key-regexp} в минибуфере.
@end deffn

@deffn Command sort-lines reverse start end
Команда в алфавитном порядке сортирует строки в области между @var{start} и
@var{end}.  Если @var{reverse} установленно в не-@code{nil}, сортировка
выполняется в обратном порядке.
@end deffn

@deffn Command sort-paragraphs reverse start end
Команда сортирует абзацы в алфавитном порядке в диапазоне между @var{start}
и @var{end}.  Если @var{reverse} установленно в не-@code{nil}, сортировка
выполняется в обратном порядке.
@end deffn

@deffn Command sort-pages reverse start end
Команда сортирует страницы в алфавитном порядке в диапазоне между
@var{start} и @var{end}.  Если @var{reverse} установленно в не-@code{nil},
сортировка выполняется в обратном порядке.
@end deffn

@deffn Command sort-fields field start end
Команда сортирует строки в области между @var{start} и @var{end}, сравнивая
их в алфавитном порядке по полю @var{field} каждой строки.  Поля разделяются
пробелами и нумеруются, начиная с 1.  Если @var{field} отрицательно,
сортировка производится по полю @w{@minus{}@var{field}} от конца строки.
Команда полезна для сортировки таблиц.
@end deffn

@deffn Command sort-numeric-fields field start end
Команда сортирует строки в области между @var{start} and @var{end},
сравнивая их численно по полю @var{field} каждой строки.  Поля разделяются
пробелом и нумеруются, начиная с 1.  Указанное поле должно содержать номер в
каждой строке региона.  Числа, начинающиеся с 0, обрабатываются как
восьмеричные, а числа, начинающиеся с @samp{0x}, как шестнадцатеричные.

Если @var{field} отрицательно, сортировка производится по полю
@w{@minus{}@var{field}} с конца строки.  Команда полезна для сортировки
таблиц.
@end deffn

@defopt sort-numeric-base
Переменная определяет систему счисления по умолчанию для
@code{sort-numeric-fields} при анализе чисел.
@end defopt

@deffn Command sort-columns reverse &optional beg end
Команда сортирует строки в области между @var{beg} и @var{end}, сравнивая их
в алфавитном порядке по определенному диапазону столбцов.  Позиции столбцов
@var{beg} и @var{end} ограничивают диапазон столбцов для сортировки.

Если @var{reverse} равен не-@code{nil}, сортировка выполняется в обратном
порядке.

Одна необычная особенность этой команды заключается в том, что вся строка,
содержащая позицию @var{beg}, и вся строка, содержащая позицию @var{end},
включаются в отсортированный регион.

Обратить внимание, что @code{sort-columns} отклоняет текст, содержащий
табуляцию, потому что табуляция может быть разделена по указанным столбцам.
Использовать @kbd{M-x untabify} для преобразования табуляции в пробелы
перед сортировкой.

Когда это возможно, команда фактически работает, вызывая служебную программу
@code{sort}.
@end deffn

@node Columns
@section Подсчет Столбцов
@cindex columns
@cindex counting columns
@cindex horizontal position

  Функции столбца преобразуют позицию символа (подсчет символов с начала
буфера) и позицию столбца (подсчет экранных символов с начала строки).

  Эти функции подсчитывают каждый символ в соответствии с количеством
столбцов, которые он занимает на экране.  Это означает, что управляющие
символы считаются занимающими 2 или 4 столбца, в зависимости от значения
@code{ctl-arrow}, а табуляция считается занимающей количество столбцов,
которое зависит от значения @code{tab-width} и столбца, с которого
начинается табуляция.  @xref{Usual Display}.

  При вычислении количества столбцов игнорируется ширина окна и количество
горизонтальной прокрутки.  Следовательно, значение столбца может быть
произвольно большим.  Первый (или крайний левый) столбец имеет номер 0.
Также игнорируются наложения и свойства текста, за исключением невидимости.

@defun current-column
Функция возвращает положение точки по горизонтали, измеренное в столбцах,
начиная с 0 на левом поле.  Положение столбца - это сумма ширины всех
отображаемых представлений символов между началом текущей строки и точкой.
@end defun

@deffn Command move-to-column column &optional force
Функция перемещает точку на @var{column} в текущей строке.  При вычислении
@var{column} учитывается ширина отображаемых представлений символов между
началом строки и точкой.

При интерактивном вызове @var{column} является значением числового
префиксного аргумента.  Если @var{column} не является целым числом, выдается
сообщение об ошибке.

@c Это поведение документировалось до 2013/08.
@ignore
Если столбец @var{column} находится за концом строки, точка перемещается в
конец строки.  Если @var{column} отрицательно, точка перемещается в начало
 строки.
@end ignore

Если невозможно перейти в столбец @var{column}, потому что он находится в
середине многоколоночного символа, такого как табуляция, точка перемещается
в конец этого символа.  Однако, если @var{force} установленно в
не-@code{nil}, а @var{column} находится в середине табуляции, то
@code{move-to-column} либо преобразует табуляцию в пробелы (когда
@code{indent-tabs-mode} имеет значение @code{nil}), либо вставляет
достаточно пробелов перед ней (в противном случае), чтобы точка могла
перемещаться точно в столбец @var{column}.  Другие многоколоночные символы
могут вызывать аномалии, несмотря на @var{force}, поскольку их невозможно
разделить.

Аргумент @var{force} также действует, если длина строки недостаточна для
достижения столбца @var{column}; если это @code{t}, это означает добавление
пробела в конце строки для достижения этого столбца.

Возвращаемое значение - номер фактически перемещенного столбца.
@end deffn

@node Indentation
@section Отступ
@cindex indentation

  Функции отступа используются для проверки, перемещения и изменения
пробелов в начале строки.  Некоторые функции также могут изменять пробелы в
другом месте строки.  Столбцы и отступы отсчитываются от нуля на левом поле.

@menu
* Primitive Indent::  Функции, используемые для подсчета и вставки отступов.
* Mode-Specific Indent::  Настройте отступ для разных режимов.
* Region Indent::         Создать отступ для всех строк в регионе.
* Relative Indent::       Отступ текущей строки на основе предыдущих строк.
* Indent Tabs::      Регулируемые позиции табуляции, как на пишущей машинке.
* Motion by Indent::      Перейти к первому непустому символу.
@end menu

@node Primitive Indent
@subsection Примитивы Отступа

  В этом разделе описаны примитивные функции, используемые для подсчета и
вставки отступов.  Эти примитивы используются в функциях в следующих
разделах.  @xref{Size of Displayed Text}, для связанных функций.

@defun current-indentation
@comment !!Тип Примитивная функция
@comment !!ИсходныйФайл indent.c
Функция возвращает отступ текущей строки, который является горизонтальной
позицией первого непустого символа.  Если содержимое полностью пустое, то
это горизонтальное положение конца строки.
@end defun

@deffn Command indent-to column &optional minimum
@comment !!Тип Примитивная функция
@comment !!ИсходныйФайл indent.c
Функция делает отступ от точки табуляцией и пробелами до достижения
@var{column}.  Если указано @var{minimum} и оно установленно в
не-@code{nil}, то будет вставлено как минимум такое количество пробелов,
даже если для этого потребуется выйти за пределы @var{column}.  В противном
случае функция ничего не делает, если точка уже находится за пределами
@var{column}.  Значение - это столбец, на котором заканчивается вставленный
отступ.

Вставленные пробельные символы наследуют свойства текста от окружающего
текста (обычно только от предыдущего текста).  @xref{Sticky Properties}.
@end deffn

@defopt indent-tabs-mode
@comment !!ИсходныйФайл indent.c
Если эта переменная - не-@code{nil}, функции отступа могут вставлять как
табуляцию, так и пробелы.  В противном случае вставляются только пробелы.
Установка этой переменной автоматически делает ее локальной в текущем
буфере.
@end defopt

@node Mode-Specific Indent
@subsection Отступ, Контролируемый Основным Режимом

  Важной функцией каждого основного режима является настройка клавиши
@key{TAB} для правильного отступа для редактируемого языка.  В этом разделе
описывается механизм ключа @key{TAB} и способы управления им.  Функции в
этом разделе возвращают непредсказуемые значения.

@deffn Command indent-for-tab-command &optional rigid
Команда, привязанная к @key{TAB} в большинстве режимов редактирования.  Её
обычное действие - сделать отступ для текущей строки, но в качестве
альтернативы может вставить символ табуляции или сделать отступ для области.

Вот что делает:

@itemize
@item
Во-первых, проверяет, включен ли режим Transient Mark и активна ли область.
Если это так, вызывается @code{indent-region} для отступа всего текста в
области (@pxref{Region Indent}).

@item
В противном случае, если функция отступа указанная в
@code{indent-line-function} - @code{indent-to-left-margin} (тривиальная
команда, которая вставляет символ табуляции) или если переменная
@code{tab-always-indent} указывает, что должен быть вставлен символ
табуляции (смотреть ниже), то вставляется символ табуляции.

@item
В противном случае делается отступ для текущей строки; это делается путем
вызова функции указанной в @code{indent-line-function}.  Если строка уже
имеет отступ, а значение @code{tab-always-indent} равно @code{complete}
(смотреть ниже), проводится попытка завершить текст в точке.
@end itemize

Если @var{rigid} - не-@code{nil} (интерактивно, с префиксным аргументом), то
после того, как эта команда делает отступ для строки или вставляет
табуляцию, она также жестко отступает от всего сбалансированного выражения,
которое начинается в начале текущей строки, чтобы отразить новый отступ.
Этот аргумент игнорируется, если команда делает отступ в области.
@end deffn

@defvar indent-line-function
Значение переменной - функция, которая будет использоваться
@code{indent-for-tab-command} и различными другими командами отступа для
отступа текущей строки.  Обычно назначается основным режимом; например,
режим Lisp устанавливает её в @code{lisp-indent-line}, режим C устанавливает
её в @code{c-indent-line} и так далее.  Значение по умолчанию -
@code{indent-relative}.  @xref{Auto-Indentation}.
@end defvar

@deffn Command indent-according-to-mode
Команда вызывает функцию в @code{indent-line-function}, чтобы сделать отступ
в текущей строке подходящим для текущего основного режима.
@end deffn

@deffn Command newline-and-indent
Функция вставляет новую строку, а затем делает отступ для новой строки
(следующей за только что вставленной новой строкой) в соответствии с
основным режимом.  Выполняется отступ, вызовом
@code{indent-according-to-mode}.
@end deffn

@deffn Command reindent-then-newline-and-indent
Команда повторно делает отступ в текущей строке, вставляет новую строку в
точку, а затем делает отступ для новой строки (той, которая следует за
только что вставленной новой строкой).  Делается отступ в обеих строках,
вызовом @code{indent-according-to-mode}.
@end deffn

@defopt tab-always-indent
Переменную можно использовать для настройки поведения команды @key{TAB}
(@code{indent-for-tab-command}).  Если значение установленно в @code{t} (по
умолчанию), команда обычно просто отступает от текущей строки.  Если
значение равно @code{nil}, команда делает отступ текущей строки только в том
случае, если точка находится на левом поле или в отступе строки; в противном
случае вставляется символ табуляции.  Если значение равно @code{complete},
команда сначала пытается сделать отступ для текущей строки, а если строка
уже была с отступом, вызывается @code{completion-at-point} для завершения
текста в точке (@pxref{Completion in Buffers}).
@end defopt

@cindex literate programming
@cindex multi-mode indentation
  Некоторые основные режимы должны поддерживать встроенные области текста,
синтаксис которых принадлежит другому основному режиму.  Примеры включают
исходные файлы @dfn{грамотное программирование}, которые объединяют
документацию и фрагменты исходного кода, программы Yacc/Bison, которые
включают фрагменты кода Python или JS и так далее.  Для правильного отступа
встроенных фрагментов в основном режиме необходимо делегировать отступ
механизму отступов другого режима (например, вызовом @code{js-indent-line}
для кода JS или @code{python-indent-line} для Python), предоставив ему
некоторый контекст для управления отступом.  В свою очередь, основные режимы
должны избегать использования @code{widen} в коде отступов и подчиняться
@code{prog-first-column}.

@defvar prog-indentation-context
Переменная, когда указывает на не-@code{nil}, содержит контекст отступа для
механизма отступов подрежима, предоставляемый вышестоящим основным режимом.
Значение должно быть списком вида @code{(@var{first-column}. @var{rest}}.
Члены списка имеют следующее значение:

@table @var
@item first-column
Столбец, который будет использоваться для конструкций верхнего уровня.  Это
заменяет значение по умолчанию столбца верхнего уровня, используемое
подрежимом, обычно нулевое.
@item rest
Значение в настоящее время не используется.
@end table
@end defvar

Следующая удобная функция должна использоваться механизмом отступов
основного режима для поддержки вызовов в качестве подрежимов другого
основного режима.

@defun prog-first-column
Вызвать эту функцию вместо использования буквального значения (обычно нуля)
номера столбца для отступов программных конструкций верхнего уровня.
Значение функции - это номер столбца, используемый для конструкций верхнего
уровня.  Если вышестоящий режим не действует, эта функция возвращает ноль.
@end defun


@node Region Indent
@subsection Отступ для Всей Области

  В этом разделе описаны команды, которые делают отступы для всех строк в
регионе.  Возвращают непредсказуемые значения.

@deffn Command indent-region start end &optional to-column
Команда делает отступ для каждой непустой строки, начиная с @var{start}
(включительно) и @var{end} (исключительно).  Если @var{to-column}
установленно в @code{nil}, @code{indent-region} делает отступ для каждой
непустой строки, вызовом функции отступа текущего режима, со значением
@code{indent-line-function}.

Если @var{to-column} установленно в не-@code{nil}, это должно быть целое
число, определяющее количество столбцов отступа; тогда функция дает каждой
строке ровно такой же отступ, добавляя или удаляя пробелы.

Если есть префикс заполнения, @code{indent-region} делает отступ для каждой
строки, заставляя ее начинаться с префикса заполнения.
@end deffn

@defvar indent-region-function
Значение переменной - функция, которую @code{indent-region} может
использовать как сокращение.  Принимается два аргумента: начало и конец
области.  Потребуется спроектировать функцию так, чтобы она давала те же
результаты, что и отступы строк области одна за другой, но,
предположительно, быстрее.

Если значение равно @code{nil}, сокращенного пути нет, то
@code{indent-region} фактически работает построчно.

Функция быстрого доступа полезна в таких режимах, как режим C и режим Lisp,
где @code{indent-line-function} должен сканировать с начала определения
функции: применение её к каждой строке будет квадратичным по времени.  Ярлык
может обновлять информацию о сканировании при перемещении по строкам,
отступающим от них; это занимает линейное время.  В режиме, когда
индивидуальный отступ строки выполняется быстро, нет необходимости в
сокращении.

@code{indent-region} с аргументом не-@code{nil} @var{to-column} имеет другое
значение и не использует эту переменную.
@end defvar

@deffn Command indent-rigidly start end count
Функция сдвигает все строки, начинающиеся между @var{start} (включительно) и
@var{end} (исключительно), в бок на @var{count} столбцов.  Это сохраняет
форму обработанной области, перемещая ее как жесткую единицу.

Полезно не только для отступов областей текста без отступов, но также для
отступов областей форматированного кода.  Например, если @var{count} равно
3, команда добавляет 3 столбца отступа к каждой строке, которая начинается в
указанной области.

При интерактивном вызове без префиксного аргумента команда вызывает
переходный режим для жесткой настройки отступа.
@xref{Indentation Commands,,, emacs, Руководство GNU Emacs Manual}.
@end deffn

@deffn Command indent-code-rigidly start end columns &optional nochange-regexp
Похоже на @code{indent-rigidly}, за исключением того, что не изменяются
строки, начинающиеся внутри строк или комментариев.

Кроме того, не изменяется строка, если @var{nochange-regexp} совпадает с
началом строки (если @var{nochange-regexp} установленно в не-@code{nil}).
@end deffn

@node Relative Indent
@subsection Отступ Относительно Предыдущих Строк

  В этом разделе описаны две команды, которые изменяют отступ текущей строки
на основе содержимого предыдущих строк.

@deffn Command indent-relative &optional unindented-ok
Команда вставляет пробел в точку, расширяясь до того же столбца, что и
следующий @dfn{точка отступа} предыдущей непустой строки.  Точка отступа -
это непробельный символ, следующий за пробелом.  Следующая точка отступа -
это первая точка в столбце, большем, чем текущий столбец точки.  Например,
если точка находится под и слева от первого непустого символа строки текста,
она перемещается в этот столбец, вставляя пробел.

Если у предыдущей непустой строки нет следующей точки отступа (то есть нет в
достаточно большой позиции столбца), @code{indent-relative} либо ничего не
делает (если @var{unindented-ok} равен не-@code{nil}), либо вызывает
@code{tab-to-tab-stop}.  Таким образом, если точка находится под и справа от
последнего столбца короткой строки текста, эта команда обычно перемещает
точку на следующую позицию табуляции, вставляя пробел.

Возвращаемое значение @code{indent-relative} непредсказуемо.

В следующем примере точка находится в начале второй строки:

@example
@group
            This line is indented twelve spaces.
@point{}The quick brown fox jumped.
@end group
@end example

@noindent
Оценка выражения @code{(indent-relative nil)} дает следующее:

@example
@group
            This line is indented twelve spaces.
            @point{}The quick brown fox jumped.
@end group
@end example

  В следующем примере точка находится между @samp{m} и @samp{p} в
@samp{jumped}:

@example
@group
            This line is indented twelve spaces.
The quick brown fox jum@point{}ped.
@end group
@end example

@noindent
Оценка выражения @code{(indent-relative nil)} дает следующее:

@example
@group
            This line is indented twelve spaces.
The quick brown fox jum  @point{}ped.
@end group
@end example
@end deffn

@deffn Command indent-relative-first-indent-point
@comment !!ИсходныйФайл indent.el
Команда делает отступ для текущей строки, как и для предыдущей непустой
строки, вызывая @code{indent-relative} с @code{t} в качестве аргумента
@var{first-only}.  Возвращаемое значение непредсказуемо.

Если в предыдущей непустой строке нет точек отступа за пределами текущего
столбца, эта команда ничего не делает.
@end deffn

@node Indent Tabs
@subsection Регулируемые Упоры для Табуляции
@cindex tabs stops for indentation

  В этом разделе объясняется механизм для указанных пользователем позиций
табуляции, а также механизмы, которые их используют и устанавливают.  Имя
``табуляция'' используется потому, что функция аналогична функциям табуляции
на пишущей машинке.  Эта функция работает путем вставки соответствующего
количества пробелов и символов табуляции для перехода к следующему столбцу с
табуляцией; не влияет на отображение символов табуляции в буфере
(@pxref{Usual Display}).  Обратить внимание, что символ @key{TAB} в качестве
входных данных использует эту функцию табуляции только в нескольких основных
режимах, таких как текстовый режим.
@xref{Tab Stops,,, emacs, The GNU Emacs Manual}.

@deffn Command tab-to-tab-stop
Команда вставляет пробелы или табуляцию перед точкой до следующего столбца
табуляции, определяемого @code{tab-stop-list}.
@end deffn

@defopt tab-stop-list
Переменная определяет столбцы табуляции, используемые
@code{tab-to-tab-stop}.  Это должно быть либо @code{nil}, либо список
возрастающих целых чисел, которые не должны быть равномерно распределены.
Список неявно расширяется до бесконечности путем повторения интервала между
последним и предпоследним элементами (или @code{tab-width}, если в списке
меньше двух элементов).  Значение @code{nil} означает табуляцию в каждом
столбце @code{tab-width}.

Использовать @kbd{M-x edit-tab-stops} для интерактивного редактирования
расположения позиций табуляции.
@end defopt

@node Motion by Indent
@subsection Команды Движения на Основе Отступов

  Эти команды, в первую очередь для интерактивного использования, действуют
на основе отступов в тексте.

@deffn Command back-to-indentation
@comment !!ИсходныйФайл simple.el
Команда перемещает точку к первому непробельному символу в текущей строке
(которая является строкой, в которой расположена точка).  Возвращается
@code{nil}.
@end deffn

@deffn Command backward-to-indentation &optional arg
@comment !!ИсходныйФайл simple.el
Команда перемещает точку назад по строкам @var{arg}, а затем к первому
непустому символу в этой строке.  Возвращается @code{nil}.  Если @var{arg}
опущен или @code{nil}, по умолчанию используется 1.
@end deffn

@deffn Command forward-to-indentation &optional arg
@comment !!ИсходныйФайл simple.el
Команда перемещает точку вперед по строкам @var{arg}, а затем к первому
непустому символу в этой строке.  Возвращается @code{nil}.  Если @var{arg}
опущен или @code{nil}, по умолчанию используется 1.
@end deffn

@node Case Changes
@section Изменения Регистра
@cindex case conversion in buffers

  Команды изменения регистра, описанные здесь, работают с текстом в текущем
буфере.  @xref{Case Conversion} для функций преобразования регистра, которые
работают со строками и символами.  @xref{Case Tables}, о том, как настроить,
какие символы должны быть в верхнем или нижнем регистре и как их
преобразовать.

@deffn Command capitalize-region start end
Функция использует все слова в области, определенной @var{start} и
@var{end}, с заглавной буквы.  Использование заглавных букв означает
преобразование первого символа каждого слова в верхний регистр и
преобразование остальной части каждого слова в нижний регистр.  Функция
возвращает @code{nil}.

Если один конец области находится в середине слова, часть слова внутри
области рассматривается как целое слово.

Когда @code{capitalize-region} вызывается интерактивно, @var{start} и
@var{end} - это точка и метка, начиная с наименьшей.

@example
@group
---------- Buffer: foo ----------
This is the contents of the 5th foo.
---------- Buffer: foo ----------
@end group

@group
(capitalize-region 1 37)
@result{} nil

---------- Buffer: foo ----------
This Is The Contents Of The 5th Foo.
---------- Buffer: foo ----------
@end group
@end example
@end deffn

@deffn Command downcase-region start end
Функция преобразует все буквы в области, определенной @var{start} и
@var{end}, в нижний регистр.  Функция возвращает @code{nil}.

Когда @code{downcase-region} вызывается интерактивно, @var{start} и
@var{end} - это точка и метка, начиная с наименьшей.
@end deffn

@deffn Command upcase-region start end
Функция преобразует все буквы в области, определенной @var{start} и
@var{end}, в верхний регистр.  Функция возвращает @code{nil}.

Когда @code{upcase-region} вызывается интерактивно, @var{start} и @var{end}
- это точка и метка, начиная с наименьшей.
@end deffn

@deffn Command capitalize-word count
Функция вводит слова @var{count} после точки с заглавной буквы, перемещая
точку при этом.  Использование заглавных букв означает преобразование
первого символа каждого слова в верхний регистр и преобразование остальной
части каждого слова в нижний регистр.  Если @var{count} отрицательно,
функция использует предыдущие слова @minus{}@var{count} с заглавной буквы,
но не перемещает точку.  Возвращается значение @code{nil}.

Если точка находится в середине слова, при движении вперед часть слова перед
точкой игнорируется.  Остальное рассматривается как целое слово.

Когда @code{capitalize-word} вызывается интерактивно, @var{count}
устанавливается как префиксный числовой аргумент.
@end deffn

@deffn Command downcase-word count
Функция преобразует слова @var{count} после точки во все строчные буквы,
перемещая точку при этом.  Если @var{count} отрицательно, преобразуются
предыдущие слова @minus{}@var{count}, но не перемещается точка. Возвращаемое
значение @code{nil}.

Когда @code{downcase-word} вызывается интерактивно, @var{count}
устанавливается как префиксный числовой аргумент.
@end deffn

@deffn Command upcase-word count
Функция преобразует слова @var{count} после точки в верхний регистр,
перемещая точку при этом.  Если @var{count} отрицательно, преобразует
предыдущие слова @minus{}@var{count}, но не перемещает точку.  Возвращаемое
значение @code{nil}.

Когда @code{upcase-word} вызывается в интерактивном режиме, @var{count}
устанавливается числовым префиксным аргументом.
@end deffn

@node Text Properties
@section Свойства Текста
@cindex text properties
@cindex attributes of text
@cindex properties of text

  Каждая позиция символа в буфере или строке может иметь
@dfn{список свойств текста}, что очень похоже на список свойств символа
(@pxref{Property Lists}).  Свойства принадлежат конкретному символу в
определенном месте, например, букве @samp{С} в начале этого предложения или
первому @samp{o} в @samp{foo} --- если один и тот же символ встречается в
двух разных местах, два вхождения обычно имеют разные характеристики.

  У каждого свойства есть имя и значение.  Оба они могут быть любым объектом
Lisp, но имя обычно является символом.  Обычно каждый символ имени свойства
используется для определенной цели; например, текстовое свойство @code{face}
определяет вид для отображения символа (@pxref{Special Properties}).
Обычный способ получить доступ к списку свойств - указать имя и спросить,
какое значение ему соответствует.

  Если у символа есть свойство @code{категория}, называется это
@dfn{категория свойств} символа.  Это должно быть символ.  Свойства символа
служат по умолчанию для свойств символа.

  Копирование текста между строками и буферами сохраняет свойства вместе с
символами; сюда входят такие разнообразные функции, как @code{substring},
@code{insert} и @code{buffer-substring}.

@menu
* Examining Properties::   Глядя на свойства одного символа.
* Changing Properties::    Установка свойств диапазона текста.
* Property Search::        Поиск места изменения значения свойства.
* Special Properties::     Особые свойства со специальными значениями.
* Format Properties::      Свойства для представления форматирования текста.
* Sticky Properties::      Как вставленный текст получает свойства от
                              соседнего текста.
* Lazy Properties::        Вычисление свойств текста ленивым способом только
                              при проверке текста.
* Clickable Text::         Использование свойств текста, чтобы области
                              текста что-то делали, когда происходит
                              нажатие на них.
* Fields::                 Свойство @code{field} определяет поля в буфере.
* Not Intervals::          Почему текстовые свойства не используют видимые
                              в Lisp текстовые интервалы.
@end menu

@node Examining Properties
@subsection Изучение Свойств Текста
@cindex examining text properties
@cindex text properties, examining

  Самый простой способ проверить свойства текста - это спросить значение
определенного свойства конкретного символа.  Для этого использовать
@code{get-text-property}.  Использовать @code{text-properties-at}, чтобы
получить полный список свойств символа.  @xref{Property Search}, чтобы
функции проверяли свойства сразу нескольких символов.

  Функции обрабатывают как строки, так и буферы.  Имейте в виду, что позиции
в строке начинаются с 0, а позиции в буфере - с 1.

@defun get-text-property pos prop &optional object
Функция возвращает значение свойства @var{prop} символа после позиции
@var{pos} в @var{object} (буфер или строка).  Аргумент @var{object} является
необязательным и по умолчанию соответствует текущему буферу.

Если, строго говоря, нет свойства @var{prop}, но у символа есть категория
свойств, которая является символом, то @code{get-text-property} возвращает
свойство @var{prop} этого символа.
@end defun

@defun get-char-property position prop &optional object
Функция похожа на @code{get-text-property}, за исключением того, что сначала
проверяет наложения, а затем свойства текста.  @xref{Overlays}.

Аргумент @var{object} может быть строкой, буфером или окном.  Если это окно,
то буфер, отображаемый в этом окне, используется для свойств текста и
наложений, но учитываются только наложения, активные для этого окна.  Если
@var{object} является буфером, то сначала рассматриваются наложения в этом
буфере в порядке убывания приоритета, а затем свойства текста.  Если
@var{object} является строкой, учитываются только текстовые свойства,
поскольку строки никогда не имеют наложений.
@end defun

@defun get-pos-property position prop &optional object
Функция похожа на @code{get-char-property}, за исключением того, что она
обращает внимание на закрепление свойств и настройки продвижения наложения,
а не на свойство символа в (то есть сразу после) @var{position}.
@end defun

@defun get-char-property-and-overlay position prop &optional object
Похоже на @code{get-char-property}, но дает дополнительную информацию о
наложении, из которого происходит значение свойства.

Его значением является cons-ячейка, @sc{car} которой является значением
свойства, то же значение @code{get-char-property} вернет с теми же
аргументами.  Его @sc{cdr} - это наложение, в котором свойство было найдено
или @code{nil}, если оно было найдено как текстовое свойство или не найдено
вообще.

Если @var{position} стоит в конце @var{object}, @sc{car} и @sc{cdr} значения
будут @code{nil}.
@end defun

@defvar char-property-alias-alist
Переменная содержит список, который сопоставляет имена свойств со списком
альтернативных имен свойств.  Если символ не указывает прямое значение
свойства, альтернативные имена свойств просматриваются по порядку;
используется первое значение не-@code{nil}.  Эта переменная имеет приоритет
над @code{default-text-properties} и @code{category}, свойства имеют
приоритет над этой переменной.
@end defvar

@defun text-properties-at position &optional object
Функция возвращает весь список свойств символа по адресу @var{position} в
строке или буфере @var{object}.  Если @var{object} равен @code{nil}, по
умолчанию используется текущий буфер.
@end defun

@defvar default-text-properties
Переменная содержит список свойств, содержащий значения по умолчанию для
свойств текста.  Всякий раз, когда символ не указывает значение свойства ни
напрямую, ни через символ категории, ни через
@code{char-property-alias-alist}, вместо него используется значение,
хранящееся в этом списке.  Вот пример:

@example
(setq default-text-properties '(foo 69)
      char-property-alias-alist nil)
;; @r{Убедится, что символ 1 не имеет собственных свойств.}
(set-text-properties 1 2 nil)
;; @r{Когда спрашивается, получается значение по умолчанию.}
(get-text-property 1 'foo)
     @result{} 69
@end example
@end defvar

@node Changing Properties
@subsection Изменение Свойств Текста
@cindex changing text properties
@cindex text properties, changing

  Примитивы для изменения свойств применяются к указанному диапазону текста
в буфере или строке.  Функция @code{set-text-properties} (смотреть конец
раздела) устанавливает весь список свойств текста в этом диапазоне; чаще
бывает полезно добавлять, изменять или удалять только определенные свойства,
указанные по имени.

  Поскольку текстовые свойства считаются частью содержимого буфера (или
строки) и могут влиять на то, как буфер выглядит на экране, любое изменение
свойств текста буфера помечает буфер как измененный.  Изменения свойств
текста буфера отменяются также (@pxref{Undo}).  Позиции в строке начинаются
с 0, тогда как позиции в буфере начинаются с 1.

@defun put-text-property start end prop value &optional object
Функция устанавливает для свойства @var{prop} значение @var{value} для
текста между @var{start} и @var{end} в строке или буфере @var{object}.  Если
@var{object} равен @code{nil}, по умолчанию используется текущий буфер.
@end defun

@defun add-text-properties start end props &optional object
Функция добавляет или отменяет свойства текста для текста между @var{start}
и @var{end} в строке или буфере @var {object}. Если @var{object} равен
@code{nil}, по умолчанию используется текущий буфер.

Аргумент @var{props} указывает, какие свойства нужно добавить.  Должен иметь
форму списка свойств (@pxref{Property Lists}): список, элементы которого
включают имена свойств, за которыми поочередно следуют соответствующие
значения.

Возвращаемое значение - @code{t}, если функция действительно изменила
значение некоторого свойства; @code{nil} в противном случае (если
@var{props} равен @code{nil} или его значения соответствуют значениям в
тексте).

Например, вот как установить свойства @code{comment} и @code{face} для
диапазона текста:

@example
(add-text-properties @var{start} @var{end}
                     '(comment t face highlight))
@end example
@end defun

@defun remove-text-properties start end props &optional object
Функция удаляет указанные свойства текста из текста между @var{start} и
@var{end} в строке или в буфере @var{object}.  Если @var{object} равен
@code{nil}, по умолчанию используется текущий буфер.

Аргумент @var{props} указывает, какие свойства нужно удалить.  Должен иметь
форму списка свойств (@pxref{Property Lists}): список, элементами которого
являются имена свойств, чередующиеся с соответствующими значениями.  Но
имеют значение только имена - значения, сопровождающие их, игнорируются.
Например, вот как удалить свойство @code{face}.

@example
(remove-text-properties @var{start} @var{end} '(face nil))
@end example

Возвращаемое значение - @code{t}, если функция действительно изменила
значение некоторого свойства; @code{nil} в противном случае (если
@var{props} имеет значение @code{nil} или ни один символ в указанном тексте
не имеет этих свойств).

Чтобы удалить все свойства текста из определенного текста, использовать
@code{set-text-properties} и указать @code{nil} для нового списка свойств.
@end defun

@defun remove-list-of-text-properties start end list-of-properties &optional object
Подобно @code{remove-text-properties}, за исключением того, что
@var{list-of-properties} - это только список имен свойств, а не чередующийся
список имен и значений свойств.
@end defun

@defun set-text-properties start end props &optional object
Функция полностью заменяет список свойств текста для текста между
@var{start} и @var{end} в строке или буфере @var{object}.  Если @var{object}
равен @code{nil}, по умолчанию используется текущий буфер.

Аргумент @var{props} - это новый список свойств.  Должен быть список,
элементами которого являются имена свойств, чередующиеся с соответствующими
значениями.

После возврата @code{set-text-properties} все символы в указанном диапазоне
имеют идентичные свойства.

Если @var{props} равен @code{nil}, эффект состоит в том, чтобы избавиться от
всех свойств из указанного диапазона текста. Вот пример:

@example
(set-text-properties @var{start} @var{end} nil)
@end example

Не полагаться на возвращаемое значение этой функции.
@end defun

@defun add-face-text-property start end face &optional appendp object
Функция работает с текстом между @var{start} and @var{end}, добавляя вид
@var{face} к свойству текста @code{face}.  @var{face} должно быть допустимым
значением для свойства @code{face} (@pxref{Special Properties}), например
именем вода отображения или анонимным видом (@pxref{Faces}).

Если какой-либо текст в области уже имеет свойство не-@code{nil}
@code{face}, эти коррективы сохраняются.  Функция устанавливает свойство
@code{face} для списка видов, с @var{face} в качестве первого элемента (по
умолчанию) и ранее существовавших видов в качестве оставшихся элементов.
Если необязательный аргумент @var{appendp} - не-@code{nil}, вместо этого в
конец списка добавляется @var{face}.  Обратить внимание, что в списке видов
первое встречающееся значение для каждого атрибута имеет приоритет.

Например, в следующем коде текст между @var{start} и @var{end} будет
выделен зеленым курсивом:

@example
(add-face-text-property @var{start} @var{end} 'italic)
(add-face-text-property @var{start} @var{end} '(:foreground "red"))
(add-face-text-property @var{start} @var{end} '(:foreground "green"))
@end example

Необязательный аргумент @var{object}, если не-@code{nil}, указывает буфер
или строку, с которой нужно работать, а не текущий буфер.  Если @var{object}
- строка, то @var{start} и @var{end} - это индексы строки с отсчетом от
нуля.
@end defun

  Самый простой способ создать строку с текстовыми свойствами - использовать
@code{propertize}:

@defun propertize string &rest properties
Функция возвращает копию @var{string} с добавленными текстовыми свойствами
@var{properties}.  Эти свойства применяются ко всем символам в возвращаемой
строке.  Вот пример, который создает строку со свойством @code{face} и
@code{mouse-face}:

@smallexample
(propertize "foo" 'face 'italic
            'mouse-face 'bold-italic)
     @result{} #("foo" 0 3 (mouse-face bold-italic face italic))
@end smallexample

Чтобы присвоить разные свойства различным частям строки, можно построить
каждую часть с помощью @code{propertize}, а затем объединить их с
@code{concat}.:

@smallexample
(concat
 (propertize "foo" 'face 'italic
             'mouse-face 'bold-italic)
 " and "
 (propertize "bar" 'face 'italic
             'mouse-face 'bold-italic))
     @result{} #("foo and bar"
                 0 3 (face italic mouse-face bold-italic)
                 3 8 nil
                 8 11 (face italic mouse-face bold-italic))
@end smallexample
@end defun

  @xref{Buffer Contents}, для функции @code{buffer-substring-no-properties},
которая копирует текст из буфера, но не копирует его свойства.

@findex with-silent-modifications
  Если требуется добавить текстовые свойства в буфер или удалить их, не
отмечая буфер как измененный, можно заключить приведенные выше вызовы в
макрос @code{with-silent-modifications}.  @xref{Buffer Modification}.

@node Property Search
@subsection Функции Поиска Текстовых Свойств
@cindex searching text properties
@cindex text properties, searching

  При типичном использовании текстовых свойств большую часть времени
несколько или много последовательных символов имеют одно и то же значение
для свойства.  Вместо того, чтобы писать свои программы для изучения
символов по одному, гораздо быстрее обрабатывать фрагменты текста с
одинаковым значением свойства.

  Вот функции, которые можно использовать для этого.  Они используют
@code{eq} для сравнения значений свойств.  Во всех случаях @var{object} по
умолчанию соответствует текущему буферу.

  Для хорошей производительности очень важно использовать аргумент
@var{limit} для этих функций, особенно для тех, которые ищут одно свойство -
иначе они могут потратить много времени на сканирование до конца буфера,
если это свойство вас интересует тогда аргумент не используется.

  Эти функции не перемещают точку; вместо этого они возвращают позицию (или
@code{nil}).  Помнить, что позиция всегда находится между двумя символами;
позиция, возвращаемая этими функциями, находится между двумя символами с
разными свойствами.

@defun next-property-change pos &optional object limit
Функция просматривает текст вперед от позиции @var{pos} в строке или буфере
@var{object} до тех пор, пока не обнаружит изменение в некотором свойстве
текста, а затем возвращает позицию изменения.  Другими словами, возвращается
позиция первого символа после @var{pos}, свойства которого не идентичны
свойствам символа сразу после @var{pos}.

Если @var{limit} равен не-@code{nil}, то сканирование заканчивается на
позиции @var{limit}.  Если до этого момента не было изменений свойств, эта
функция возвращает @var{limit}.

Значение @code{nil}, если свойства остаются неизменными до конца
@var{object}, а @var{limit} - @code{nil}.  Если значение равно
не-@code{nil}, это позиция больше или равна @var{pos}.  Значение равно
@var{pos} только тогда, когда @var{limit} равно @var{pos}.

Вот пример того, как сканировать буфер фрагментами текста, в котором все
свойства постоянны:

@smallexample
(while (not (eobp))
  (let ((plist (text-properties-at (point)))
        (next-change
         (or (next-property-change (point) (current-buffer))
             (point-max))))
    @r{Обработать текст от точки до @var{next-change}@dots{}}
    (goto-char next-change)))
@end smallexample
@end defun

@defun previous-property-change pos &optional object limit
Это похоже на @code{next-property-change}, но сканирует назад от @var{pos},
а не вперед.  Если значение равно не-@code{nil}, тогда позиция меньше или
равна @var{pos}; равняется @var{pos}, только если @var{limit} равен
@var{pos}.
@end defun

@defun next-single-property-change pos prop &optional object limit
Функция сканирует текст на предмет изменения свойства @var{prop}, а затем
возвращает позицию изменения.  Сканирование идет вперед с позиции @var{pos}
в строке или буфере @var{object}.  Другими словами, функция возвращает
позицию первого символа после @var{pos}, свойство @var{prop} которого
отличается от свойства символа сразу после @var{pos}.

Если @var{limit} равен не-@code{nil}, то сканирование заканчивается на
позиции @var{limit}.  Если до этой точки не было изменений свойств,
@code{next-single-property-change} возвращает @var{limit}.

Значение @code{nil}, если свойство остается неизменным до конца @var{object}
и @var{limit} @code{nil}.  Если значение равно не-@code{nil}, тогда позиция
больше или равна @var{pos}; и равна @var{pos}, только если @var{limit}
равняется @var{pos}.
@end defun

@defun previous-single-property-change pos prop &optional object limit
Это похоже на @code{next-single-property-change}, но сканирует назад от
@var{pos}, а не вперед.  Если значение равно не-@code{nil}, тогда позиция
меньше или равна @var{pos}; равняется @var{pos}, только если @var{limit}
равняется @var{pos}.
@end defun

@defun next-char-property-change pos &optional limit
Это похоже на @code{next-property-change}, за исключением того, что он
учитывает свойства наложения, а также свойства текста, и, если не обнаружено
никаких изменений до конца буфера, возвращается максимальная позиция буфера,
а не @code{nil} (в этом смысле напоминает соответствующую функцию наложения
@code{next-overlay-change} , а не @code{next-property-change}).  Операнда
@var{object} нет, потому что эта функция работает только с текущим буфером.
Возвращается следующий адрес, по которому изменяется любой вид свойства.
@end defun

@defun previous-char-property-change pos &optional limit
Это похоже на @code{next-char-property-change}, но сканируется назад от
@var{pos}, а не вперед, и возвращается минимальная позиция в буфере, если
изменений не обнаружено.
@end defun

@defun next-single-char-property-change pos prop &optional object limit
Это похоже на @code{next-single-property-change}, за исключением того, что
учитываются свойства наложения, а также свойства текста, и если не
обнаружено никаких изменений до конца @var{object}, возвращается максимально
допустимая позиция в @var{object}, а не @code{nil}.  В отличие от
@code{next-char-property-change}, эта функция @emph{использует} операнд
@var{object}; если @var{object} не является буфером, рассматриваются только
свойства текста.
@end defun

@defun previous-single-char-property-change pos prop &optional object limit
Это похоже на @code{next-single-char-property-change}, но сканируется назад
от @var{pos}, а не вперед, и возвращается минимальная допустимая позиция в
@var{object}, если никаких изменений не обнаружено.
@end defun

@defun text-property-any start end prop value &optional object
Функция возвращает не-@code{nil}, если хотя бы один символ между @var{start}
и @var{end} имеет свойство @var{prop}, значение которого равно @var{value}.
Точнее, возвращается позиция первого такого символа.  В противном случае
возвращает @code{nil}.

Необязательный пятый аргумент @var{object} указывает строку или буфер для
сканирования.  Позиции относительно @var{object}.  По умолчанию для
@var{object} используется текущий буфер.
@end defun

@defun text-property-not-all start end prop value &optional object
Функция возвращает не-@code{nil}, если хотя бы один символ между @var{start}
и @var{end} не имеет свойства @var{prop} со значением @var{value}.  Точнее,
возвращается позиция первого такого символа.  В противном случае
возвращается @code{nil}.

Необязательный пятый аргумент @var{object} указывает строку или буфер для
сканирования.  Позиции относительно @var{object}.  По умолчанию для
@var{object} используется текущий буфер.
@end defun

@node Special Properties
@subsection Свойства с Особым Значением

  Вот таблица имен текстовых свойств, которые имеют специальные встроенные
значения.  В следующих разделах перечислены несколько дополнительных имен
специальных свойств, которые управляют заполнением и наследованием свойств.
Все остальные имена не имеют стандартного значения, и можно использовать их
по своему усмотрению.

  Примечание: свойства @code{composition}, @code{display}, @code{invisible}
и @code{intangible} также могут вызывать перемещение точки в приемлемое
место после каждой команды Emacs.  @xref{Adjusting Point}.

@table @code
@cindex property category of text character
@c FIXME: Не @kindex для клавиатурных команд?
@kindex category @r{(свойства текста)}
@item category
Если у символа есть свойство @code{category}, называется оно
@dfn{категория свойств} символа.  Это должно быть символом.  Свойства этого
символа служат по умолчанию для свойств символа.

@item face
@cindex face codes of text
@kindex face @r{(свойство текста)}
Свойство @code{face} управляет внешним видом символа (@pxref{Faces}).
Оценка свойства может быть следующей:

@itemize @bullet
@item
Имя вида (символ или строка).

@item
Анонимный вид: список свойств в форме
@code{(@var{keyword} @var{value} @dots{})}, где каждый @var{keyword} - это
имя атрибута вида, а @var{value} - значение этого атрибута.

@item
Список видов.  Каждый элемент списка должен быть либо именем вида, либо
анонимным видом.  Это определяет вид, который является совокупностью
атрибутов каждого из перечисленных видов.  Виды представления, встречающиеся
раньше в списке, имеют более высокий приоритет.

@item
Конс-ячейка вида @code{(foreground-color . @var{color-name})} или
@code{(background-color . @var{color-name})}.  Определяет цвет переднего
плана или фона, аналогично @code{(:foreground @var{color-name})} или
@code{(:background @var{color-name})}.  Эта форма поддерживается только для
обратной совместимости, и ее следует избегать.
@end itemize

Режим блокировки шрифта (@pxref{Font Lock Mode}) работает в большинстве
буферов, динамически обновляя свойство @code{face} символов в зависимости от
контекста.

Функция @code{add-face-text-property} предоставляет удобный способ
установить это свойство текста.  @xref{Changing Properties}.

@item font-lock-face
@kindex font-lock-face @r{(текстовое свойство)}
Свойство определяет значение свойства @code{face}, которое режим Font Lock
должен применять к базовому тексту.  Это один из методов фонирования,
используемых в режиме Font Lock, и полезен для специальных режимов, которые
реализуют собственное выделение.  @xref{Precalculated Fontification}.  Когда
режим Font Lock отключен, @code{font-lock-face} не действует.

@item mouse-face
@kindex mouse-face @r{(текстовое свойство)}
Cвойство используется вместо @code{face}, когда указатель мыши находится на
символе или рядом с ним.  Для этого «возле» означает, что весь текст между
символом и местом, где находится мышь, имеет одинаковое значение свойства
@code{mouse-face}.

Emacs игнорирует все атрибуты вида из свойства @code{mouse-face}, которые
изменяют размер текста (например, @code{:height}, @code{:weight} и
@code{:slant}).  Эти атрибуты всегда такие же, как и для невыделенного
текста.

@item fontified
@kindex fontified @r{(текстовое свойство)}
Свойство сообщает, готов ли текст к отображению.  Если @code{nil}, процедура
повторного отображения Emacs вызывает функции в
@code{fontification-functions} (@pxref{Auto Faces}) для подготовки этой
части буфера перед ее отображением.  Используется внутри кода своевременной
блокировки шрифтов.

@item display
Свойство активирует различные функции, которые изменяют способ отображения
текста.  Например, с его помощью текст может казаться выше или короче, выше
или ниже, шире или уже или заменяться изображением.
@xref{Display Property}.

@item help-echo
@kindex help-echo @r{(текстовое свойство)}
@cindex tooltip for help strings
@anchor{Text help-echo}
Если текст имеет строку в качестве свойства @code{help-echo}, тогда, когда
наводится указатель мыши на этот текст, Emacs отображает эту строку в
эхо-области или в окне всплывающей подсказки (@pxref{Tooltips}).

Если значением свойства @code{help-echo} является функция, эта функция
вызывается с тремя аргументами, @var{window}, @var{object} и @var{pos}, и
возвращает строку справки или @code{nil}, если справки нет.  Первый аргумент
@var{window} - это окно, в котором была найдена справка.  Второй,
@var{object}, представляет собой буфер, оверлей или строку, имеющую свойство
@code{help-echo}.  Аргумент @var{pos} выглядит следующим образом:

@itemize @bullet{}
@item
Если @var{object} - буфер, @var{pos} - позиция в буфере.
@item
Если @var{object} - наложение, имеет свойство
@code{help-echo}, а @var{pos} - позиция в буфере наложения.
@item
Если @var{object} - строка (строка наложения или строка, отображаемая
со свойством @code{display}), @var{pos} - позиция в этой строке.
@end itemize

Если значение свойства @code{help-echo} не является ни функцией, ни строкой,
оно оценивается для получения строки справки.

Можно изменить способ отображения текста справки, установив переменную
@code{show-help-function} (@pxref{Help display}).

Функция используется в строке режима и для другого активного текста.

@item keymap
@cindex keymap of character
@kindex keymap @r{(текстовое свойство)}
Свойство @code{ключевая карта} определяет дополнительную карту для команд.
Когда применяется эта карта, она используется для поиска ключей перед
картами вспомогательного режима и перед локальной картой буфера.
@xref{Active Keymaps}.  Если значением свойства является символ, определение
функции символа используется в качестве ключевой карты.

Значение свойства для символа перед точкой применяется, если оно
не-@code{nil} и наследуется сзади, и значение свойства для символа после
точки применяется, если это не-@code{nil} и наследуется спереди.  (Для
щелчков мышью вместо положения точки используется позиция щелчка.)

@item local-map
@kindex local-map @r{(текстовое свойство)}
Свойство работает так же, как @code{keymap}, за исключением того,
что оно указывает таблицу ключей для использования @emph{вместо} локальной
карты буфера.  Для большинства целей (возможно, для всех) лучше использовать
свойство @code{keymap}.

@item syntax-table
Свойство @code{syntax-table} отменяет то, что таблица синтаксиса сообщает об
этом конкретном символе.  @xref{Syntax Properties}.

@item read-only
@cindex read-only character
@kindex read-only @r{(свойство текста)}
Если у символа есть свойство @code{read-only}, то изменение этого символа не
допускается.  Любая команда, которая это сделает, получит ошибку
@code{text-read-only}.  Если значение свойства является строкой, эта строка
используется как сообщение об ошибке.

Вставка рядом с символом, доступным только для чтения, является ошибкой,
если вставка обычного текста туда унаследует свойство @code{read-only} из-за
липкости.  Таким образом, вы можете контролировать разрешение на вставку
рядом с текстом, доступным только для чтения, контролируя закрепление.
@xref{Sticky Properties}.

Поскольку изменение свойств считается изменением буфера, невозможно удалить
свойство @code{read-only}, если не знать специальный трюк: привязать
@code{inhibit-read-only} к значению не-@code{nil}, а затем удалить свойство.
@xref{Read Only Buffers}.

@item inhibit-read-only
@kindex inhibit-read-only @r{(свойство текста)}
Символы со свойством @code{inhibit-read-only} можно редактировать даже в
буферах только для чтения.  @xref{Read Only Buffers}.

@item invisible
@kindex invisible @r{(свойство текста)}
Свойство не-@code{nil} @code{invisible} может сделать символ невидимым на
экране.  @xref{Invisible Text}, для деталей.

@item intangible
@kindex intangible @r{(свойство текста)}
Если группа последовательных символов имеет свойства equal и не-@code{nil}
@code{intangible}, то не выйдет разместить между ними точку.  Если
попытаться переместить точку в группу, точка фактически переместится в конец
группы.  Если попытаться переместить точку назад в группу, точка фактически
переместится в начало группы.

Если последовательные символы имеют неодинаковые свойства не-@code{nil}
@code{intangible}, они принадлежат отдельным группам; каждая группа
обрабатывается отдельно, как описано выше.

Когда переменная @code{inhibit-point-motion-hooks} равна не-@code{nil} (как
по умолчанию), свойство @code{intangible} игнорируется.

Осторожно: свойство работает на очень низком уровне и неожиданным образом
влияет на большой объем кода.  Поэтому использовать его с особой
осторожностью.  Распространенное неправильное использование - наложение
неотображаемого свойства на невидимый текст, что на самом деле не нужно,
поскольку цикл команд в любом случае перемещает точку за пределы невидимого
текста в конце каждой команды.  @xref{Adjusting Point}.  По этим причинам
это свойство устарело; вместо этого использовать свойство
@code{cursor-intangible}.

@item cursor-intangible
@kindex cursor-intangible @r{(text property)}
@findex cursor-intangible-mode
Когда включен второстепенный режим @code{cursor-intangible-mode}, точка
перемещается из любой позиции, имеющей свойство не-@code{nil}
@code{cursor-intangible}, непосредственно перед повторным отображением.

@vindex cursor-sensor-inhibit
Когда переменная @code{cursor-sensor-inhibit} равна не-@code{nil}, свойства
@code{cursor-intangible} и @code{cursor-sensor-functions} (описанные ниже)
игнорируются.

@item field
@kindex field @r{(свойство текста)}
Последовательные символы с одним и тем же свойством @code{field} составляют
@dfn{поле}.  Некоторые функции движения, включая @code{forward-word} и
@code{beginning-of-line}, преостанавливают движение на границе поля.
@xref{Fields}.

@item cursor
@kindex cursor @r{(свойство текста)}
Обычно курсор отображается в начале или в конце любых строк свойств
наложения и текста, присутствующих в текущей позиции буфера.  Можно
поместить курсор на любой желаемый символ этих строк, присвоив этому символу
текстовое свойство @code{cursor} в не-@code{nil}.  Кроме того, если значение
свойства @code{cursor} является целым числом, оно определяет количество
позиций символа буфера, начиная с позиции, где начинается наложение или
свойство @code{display}, для которого курсор должен отображаться на этом
символе.  В частности, если значением свойства символа @code{cursor}
является число @var{n}, курсор будет отображаться на этом символе для любой
позиции буфера в диапазоне @code{[@var{ovpos}..@var{ovpos}+@var{n})}, где
@var{ovpos} - начальная позиция наложения, заданная @code{overlay-start}
(@pxref{Managing Overlays}), или позиция, в которой текстовое свойство
@code{display} начинается в буфере.

Другими словами, строковый символ со свойством @code{cursor} установленным в
не-@code{nil} - означает символ, на котором отображается курсор.  Значение
свойства говорит, для каких позиций в буфере нужно отображать курсор.  Если
значение является целым числом @var{n}, курсор отображается там, когда точка
находится где-то между началом наложения или свойства @code{display} и
позициями @var{n} после этого.  Если значение равно любому другому и
не-@code{nil}, курсор отображается там только тогда, когда точка находится в
начале свойства @code{display} или в @code{overlay-start}.

@cindex cursor position for @code{display} properties and overlays
Когда в буфере есть много строк с наложением (например,
@pxref{Overlay Properties, before-string}), которые скрывают некоторый текст
буфера или свойства @code{display}, которые являются строками, рекомендуется
использовать свойство @code{cursor} для этих строк, чтобы указать на дисплее
Emacs места, где нужно поместить курсор при перемещении по этим строкам.
Это напрямую сообщает механизму отображения, где программа на Lisp хочет
поместить курсор или где пользователь ожидает курсор, когда точка находится
в некоторой позиции буфера, которая является ``покрытой'' строкой
отображения или наложения.

@item pointer
@kindex pointer @r{(свойство текста)}
Определяет конкретную форму указателя, когда указатель мыши находится над
этим текстом или изображением.  @xref{Pointer Shape}, для возможных форм
указателя.

@item line-spacing
@kindex line-spacing @r{(свойство текста)}
Новая строка может иметь текст @code{line-spacing} или свойство наложения,
которое управляет высотой отображаемой строки, заканчивающейся этой новой
строкой.  Значение свойства переопределяет межстрочный интервал между
кадрами по умолчанию и локальную переменную @code{line-spacing} буфера.
@xref{Line Height}.

@item line-height
@kindex line-height @r{(свойство текста)}
Новая строка может иметь текст @code{line-height} или свойство наложения,
которое управляет общей высотой отображаемой строки, заканчивающейся этой
новой строкой.  @xref{Line Height}.

@item wrap-prefix
Если текст имеет свойство @code{wrap-prefix}, префикс, который определяет,
будет добавлен во время отображения в начало каждой строки продолжения из-за
переноса текста (поэтому, если строки усекаются, префикс переноса никогда не
используется).  Это может быть строка или изображение
(@pxref{Other Display Specs}), или отрезок пробелов, например, указанный в
свойствах отображения @code{:width} или @code{:align-to}
(@pxref{Specified Space}).

Также можно указать префикс переноса для всего буфера, используя локальную
переменную @code{wrap-prefix} в буфере (однако текстовое свойство
@code{wrap-prefix} имеет приоритет над значением переменной
@code{wrap-prefix}).  @xref{Truncation}.

@item line-prefix
Если текст имеет свойство @code{line-prefix}, префикс, который он
определяет, будет добавлен во время отображения в начало каждой строки, не
являющейся продолжением.  Это может быть строка или изображение
(@pxref{Other Display Specs}), или отрезок пробелов, например, указанный в
свойствах отображения @code{:width} или @code{:align-to}
(@pxref{Specified Space}).

Префикс строки также может быть указан для всего буфера с помощью локальной
переменной @code{line-prefix} в буфере (однако текстовое свойство
@code{line-prefix} имеет приоритет над значением переменной
@code{line-prefix}).  @xref{Truncation}.

@item modification-hooks
@cindex change hooks for a character
@cindex hooks for changing a character
@kindex modification-hooks @r{(text property)}
Если у символа есть свойство @code{modification-hooks}, то его значением
должен быть список функций; изменение этого символа вызывает все эти функции
перед фактическим изменением.  Каждая функция получает два аргумента: начало
и конец изменяемой части буфера.  Обратить внимание: если конкретная функция
перехвата модификации появляется на нескольких символах, изменяемых одним
примитивом, не получится предсказать, сколько раз функция будет вызываться.
Кроме того, вставка не изменит какой-либо существующий символ, поэтому эта
ловушка будет запускаться только при удалении некоторых символов, замене их
другими или изменении их текстовых свойств.

Если эти функции модифицируют буфер, должны привязать
@code{inhibit-modification-hooks} к @code{t} вокруг этого, чтобы избежать
путаницы во внутреннем механизме, вызывающем эти перехватчики.

Наложения также поддерживают свойство @code{modification-hooks}, но детали
несколько отличаются от (@pxref{Overlay Properties}).

@item insert-in-front-hooks
@itemx insert-behind-hooks
@kindex insert-in-front-hooks @r{(свойство текста)}
@kindex insert-behind-hooks @r{(свойство текста)}
Операция вставки текста в буфер также вызывает функции, перечисленные в
свойстве @code{insert-in-front-hooks} следующего символа и в свойстве
@code{insert-behind-hooks} предыдущего символа.  Эти функции получают два
аргумента: начало и конец вставленного текста.  Функции вызываются
@emph{после}, и происходит фактическая вставка.

Смотреть также @ref{Change Hooks}, чтобы узнать о других перехватчиках,
которые вызываются при изменении текста в буфере.

@item point-entered
@itemx point-left
@cindex hooks for motion of point
@kindex point-entered @r{(свойство текста)}
@kindex point-left @r{(свойство текста)}
Специальные свойства @code{point-entered} и @code{point-left} записывают
функции перехвата, сообщающие о движении точки.  Каждый раз, когда точка
перемещается, Emacs сравнивает эти два значения свойств:

@itemize @bullet
@item
свойство @code{point-left} символа после старого местоположения и
@item
свойство @code{point-entered} символа после нового местоположения.
@end itemize

@noindent
Если эти два значения различаются, каждое из них вызывается (если не
@code{nil}) с двумя аргументами: старым значением точки и новым.

Такое же сравнение проводится для символов до старой и новой локаций.
Результатом может быть выполнение двух функций @code{point-left} (которые
могут быть одной и той же функцией) и/или двух функций @code{point-entered}
(которые могут быть одной и той же функцией).  В любом случае сначала
вызываются все функции @code{point-left}, а затем все функции
@code{point-entered}.

Можно использовать @code{char-after} для проверки символов в различных
позициях буфера, не перемещая точку в эти позиции.  Эти функции-перехватчики
запускаются только при фактическом изменении значения точки.

Переменная @code{inhibit-point-motion-hooks} по умолчанию запрещает запуск
перехватчиков @code{point-left} и @code{point-entered}, смотреть
@ref{Inhibit point motion hooks}.

Эти свойства устарели; использовать вместо этого
@code{cursor-sensor-functions}.

@item cursor-sensor-functions
@kindex cursor-sensor-functions @r{(свойство текста)}
@findex cursor-sensor-mode
Специальное свойство записывает список функций, которые реагируют на
движение курсора.  Каждая функция в списке вызывается непосредственно перед
повторным отображением с 3 аргументами: затронутым окном, предыдущей
известной позицией курсора и одним из символов @code{entered} или
@code{left}, в зависимости от того, вводит ли курсор текст, имеющий это
свойство или нет.  Функции вызываются только при включенном второстепенном
режиме @code{cursor-sensor-mode}.

Когда переменная @code{cursor-sensor-inhibit} равна не-@code{nil}, свойство
@code{cursor-sensor-functions} игнорируется.

@item composition
@kindex composition @r{(свойство текста)}
Текстовое свойство используется для отображения последовательности символов
в виде единого глифа, состоящего из компонентов.  Но значение самого
свойства является полностью внутренним для Emacs и не должно напрямую
изменяться, например, @code{put-text-property}.

@end table

@defvar inhibit-point-motion-hooks
@anchor{Inhibit point motion hooks} Когда эта устаревшая переменная -
не-@code{nil}, перехватчики @code{point-left} и @code{point-entered} не
запускаются, и свойство @code{intangible} не действует.  Не устанавливать
эту переменную глобально; привязать его с помощью @code{let}.  Поскольку
затронутые свойства устарели, значение этой переменной по умолчанию -
@code{t}, чтобы эффективно их отключить.
@end defvar

@defvar show-help-function
@anchor{Help display} Если эта переменная - не-@code{nil}, она определяет
функцию, вызываемую для отображения строк справки.  Это могут быть свойства
@code{help-echo}, строки справки меню (@pxref{Simple Menu Items},
@pxref{Extended Menu Items}) или строки справки панели инструментов
(@pxref{Tool Bar}).  Указанная функция вызывается с одним аргументом -
отображаемой строкой справки, которая передается через
@code{substitute-command-keys} перед передачей в функцию; смотреть
@ref{Keys in Documentation}.  В режиме всплывающей подсказки в
(@pxref{Tooltips,,, emacs, The GNU Emacs Manual}) приведен пример.
@end defvar

@node Format Properties
@subsection Свойства Форматированного Текста

  Эти текстовые свойства влияют на поведение команд заливки.  Они
используются для представления форматированного текста.  @xref{Filling} и
@ref{Margins}.

@table @code
@item hard
Если символ новой строки имеет это свойство, это ``жесткий'' перевод строки.
Команды заполнения не изменяют жесткие символы новой строки и не перемещают
слова по ним.  Однако это свойство действует только в том случае, если
включен второстепенный режим @code{use-hard-newlines}.  @xref{Hard and Soft
Newlines,, Hard and Soft Newlines, emacs, The GNU Emacs Manual}.

@item right-margin
Cвойство определяет дополнительное правое поле для заполнения этой части
текста.

@item left-margin
Cвойство определяет дополнительное левое поле для заполнения этой части
текста.

@item justification
Cвойство определяет стиль выравнивания для заполнения этой части текста.
@end table

@node Sticky Properties
@subsection Стабильность Cвойств Текста
@cindex sticky text properties
@cindex inheritance, text property

  Самовставляющиеся символы, те, которые вставляются в буфер, когда
пользователь вводит их (@pxref{Commands for Insertion}), обычно приобретают
те же свойства, что и предыдущий символ.  Это называется @dfn{наследование}
свойств.

  Напротив, программа на Lisp может выполнять вставку с наследованием или
без, в зависимости от выбора примитива вставки.  Обычные функции вставки
текста, такие как @code{вставить}, не наследуют никаких свойств.  Они
вставляют текст с точно такими же свойствами вставляемой строки и никакими
другими.  Это верно для программ, которые копируют текст из одного контекста
в другой - например, в список уничтожений или из него.  Для вставки с
наследованием использовать специальные примитивы, описанные в этом разделе.
Самовставляющиеся символы наследуют свойства, потому что они работают с
этими примитивами.

  Когда выполняется вставка с наследованием, свойства @emph{которое}
наследуются, это зависит от того откуда и какие свойства являются
@dfn{наследуемыми}.  Вставка после символа наследует те из его свойств, которые являются @dfn{наследуемыми сзади}.  Вставка перед символом наследует те
его свойства, которые являются @dfn{наследуемыми спереди}.  Когда обе
стороны предлагают разные наследуемые значения для одного и того же
свойства, значение предыдущего символа имеет приоритет.

  По умолчанию свойство текста наследуется сзади, но не наследуется
спереди; таким образом, по умолчанию наследуются все свойства предыдущего
символа и ничего от следующего символа.

  Можно управлять закреплением различных свойств текста с помощью двух
конкретных свойств текста: @code{front-sticky} и @code{rear-nonsticky} и
переменной @code{text-property-default-nonsticky}.  Можно использовать
переменную, чтобы указать другое значение по умолчанию для данного свойства.
Можно использовать эти два свойства текста, чтобы сделать любые определенные
свойства наследуемыми или ненаследуемыми в любой конкретной части текста.

  Если свойство @code{front-sticky} символа - @code{t}, то все его свойства
наследуются спереди.  Если свойство @code{front-sticky} является списком, то
наследуемые свойства символа - это те, чьи имена находятся в списке.
Например, если у символа есть свойство @code{front-sticky}, значение
которого равно @code{(face read-only)}, то вставка перед символом может
унаследовать его свойство @code{face} и свойство @code{read-only}, но
никакие другие.

  Свойство @code{rear-nonsticky} работает наоборот.  По умолчанию
большинство свойств наследуются сзади, поэтому свойство
@code{rear-nonsticky} указывает, какие свойства @emph{не} наследуются сзади.
Если свойство @code{rear-nonsticky} символа - @code{t}, то ни одно из его
свойств не является наследуемым.  Если свойство @code{rear-nonsticky}
является списком, свойства наследуются сзади @emph{пока не} находятся их
имена в списке.

@defvar text-property-default-nonsticky
Эта переменная содержит список, который определяет заднее наследуемость по
умолчанию для различных свойств текста.  Каждый элемент имеет форму
@code{(@var{property} . @var{nonstickiness})}, и определяет закрепление
определенного свойства текста, @var{property}.

Если @var{nonstickiness} равен не-@code{nil}, это означает, что свойство
@var{property} по умолчанию не наследуется сзади.  Поскольку все свойства по
умолчанию не наследуемые, это делает @var{property} по умолчанию не
наследуемым в обоих направлениях.

Текстовые свойства @code{front-sticky} и @code{rear-nonsticky} при их
использовании имеют приоритет над @var{nonstickiness} по умолчанию,
указанным в @code{text-property-default-nonsticky}.
@end defvar

  Вот функции, которые вставляют текст с наследованием свойств:

@defun insert-and-inherit &rest strings
Вставить строки @var{strings}, как в функции @code{insert}, но унаследовать
любые наследуемые свойства от смежного текста.
@end defun

@defun insert-before-markers-and-inherit &rest strings
Вставить строки @var{strings}, как с функцией @code{insert-before-markers},
но унаследовать любые наследуемые свойства от смежного текста.
@end defun

  @xref{Insertion}, для обычных функций вставки, которые не наследуются.

@node Lazy Properties
@subsection Ленивое Вычисление Свойств Текста

  Вместо вычисления свойств текста для всего текста в буфере можно
организовать вычисление свойств текста для частей текста, когда и если от
них что-то зависит.

  Примитивом, который извлекает текст из буфера вместе со своими свойствами,
является @code{buffer-substring}.  Перед исследованием свойств эта функция
запускает ненормальную ловушку @code{buffer-access-fontify-functions}.

@defvar buffer-access-fontify-functions
Переменная содержит список функций для вычисления свойств текста.  Прежде
чем @code{buffer-substring} скопирует текст и свойства текста для части
буфера, вызываются все функции в этом списке.  Каждая из функций получает
два аргумента, определяющих диапазон доступного буфера.  (Сам буфер всегда
является текущим буфером.)
@end defvar

  Функция @code{buffer-substring-no-properties} не вызывает эти функции, так
как в любом случае игнорирует свойства текста.

  Чтобы функции ловушки не вызывались более одного раза для одной и той же
части буфера, можно использовать переменную
@code{buffer-access-fontified-property}.

@defvar buffer-access-fontified-property
Если значение этой переменной - не-@code{nil}, это символ, который
используется в качестве имени текстового свойства.  Значение не-@code{nil}
для этого текстового свойства означает, что другие текстовые свойства для
этого символа уже вычислены.

Если все символы в диапазоне, указанном для @code{buffer-substring}, имеют
значение не-@code{nil} для этого свойства, @code{buffer-substring} не
вызывает функции @code{buffer-access-fontify-functions}.  Предполагается,
что эти символы уже имеют нужные текстовые свойства, и просто копируются те
свойства, которые у них уже есть.

Обычный способ использования этой функции состоит в том, что функции
@code{buffer-access-fontify-functions} добавляют это свойство, а также
другие свойства к символам, с которыми они работают.  Таким образом, они
избегают многократных повторений одного и того же текста.
@end defvar

@node Clickable Text
@subsection Определение Интерактивного Текста
@cindex clickable text
@cindex follow links
@cindex mouse-1

  @dfn{Clickable text} - это текст, по которому можно щелкнуть мышью или
используя клавиатурную команду для получения определенного результата.  Во
многих основных режимах для реализации текстовых гиперссылок используется
интерактивный текст, или сокращенно @dfn{ссылки}.

  Самый простой способ вставлять ссылки и манипулировать ими - использовать
пакет @code{button}.  @xref{Buttons}.  В этом разделе объясняется, как
вручную настроить интерактивный текст в буфере, используя свойства текста.
Для простоты называется интерактивный текст @dfn{ссылка}.

  Реализация ссылки включает три отдельных шага: (1) указание кликабельности
при перемещении мыши по ссылке; (2) заставить @key{RET} или @kbd{mouse-2} по
этой ссылке что-то делать; и (3) установка условия @code{follow-link}, чтобы
ссылка подчинялась @code{mouse-1-click-follows-link}.

  Чтобы указать интерактивность, добавляется текстовое свойство
@code{mouse-face} к тексту ссылки; тогда Emacs будет выделять ссылку при
наведении на нее мыши.  Кроме того, потребуется определить всплывающую
подсказку или сообщение эхо-области, используя текстовое свойство
@code{help-echo}.  @xref{Special Properties}.  Например, вот как Dired
указывает, что имена файлов кликабельны:

@smallexample
 (if (dired-move-to-filename)
     (add-text-properties
       (point)
       (save-excursion
         (dired-move-to-end-of-filename)
         (point))
       '(mouse-face highlight
         help-echo "mouse-2: visit this file in other window")))
@end smallexample

  Чтобы ссылка была интерактивной, привязывается @key{RET} и @kbd{mouse-2} к
командам, выполняющим желаемое действие.  Каждая команда должна проверять,
вызывалась ли она по ссылке, и действовать соответствующим образом.
Например, карта основного режима Dired связывает @kbd{mouse-2} со следующей
командой:

@smallexample
(defun dired-mouse-find-file-other-window (event)
  "В Dired перейти к файлу или каталогу, по которому произведен щелчок."
  (interactive "e")
  (let ((window (posn-window (event-end event)))
        (pos (posn-point (event-end event)))
        file)
    (if (not (windowp window))
        (error "No file chosen"))
    (with-current-buffer (window-buffer window)
      (goto-char pos)
      (setq file (dired-get-file-for-visit)))
    (if (file-directory-p file)
        (or (and (cdr dired-subdir-alist)
                 (dired-goto-subdir file))
            (progn
              (select-window window)
              (dired-other-window file)))
      (select-window window)
      (find-file-other-window (file-name-sans-versions file t)))))
@end smallexample

@noindent
Команда использует функции @code{posn-window} и @code{posn-point}, чтобы
определить, где произошел щелчок, и @code{dired-get-file-for-visit}, чтобы
определить, какой файл посетить.

  Вместо привязки команды мыши к карте основного режима ее можно привязать к
тексту ссылки, используя текстовое свойство @code{keymap}
(@pxref{Special Properties}).  Например:

@example
(let ((map (make-sparse-keymap)))
  (define-key map [mouse-2] 'operate-this-button)
  (put-text-property link-start link-end 'keymap map))
@end example

@noindent
С помощью этого метода можно легко определить разные команды для разных
ссылок.  Более того, глобальное определение @key{RET} и @kbd{mouse-2}
остается доступным для остального текста в буфере.

@vindex mouse-1-click-follows-link
  Основная команда Emacs для щелчка по ссылкам - @kbd{mouse-2}.  Однако для
совместимости с другими графическими приложениями Emacs также распознает
щелчки @kbd{mouse-1} по ссылкам при условии, что пользователь щелкает ссылку
быстро, не перемещая мышь.  Это поведение контролируется пользовательской
опцией @code{mouse-1-click-follows-link}.
@xref{Mouse References,,, emacs, The GNU Emacs Manual}.

@kindex follow-link @r{(text or overlay property)}
  Чтобы настроить ссылку таким образом, чтобы она подчинялась
@code{mouse-1-click-follows-link}, потребуется либо (1) применить свойство
@code{follow-link} текста или наложение к тексту ссылки, либо (2) привязать
событие @code{follow-link} к ключевой карте (которая может быть картой
основного режима или локальной картой, указанной через текстовое свойство
@code{keymap}).  Значение свойства @code{follow-link} или привязка для
события @code{follow-link} действует как условие для действия ссылки.  Это
условие сообщает Emacs две вещи: обстоятельства, при которых щелчок
@kbd{mouse-1} должен рассматриваться как происходящий внутри ссылки, и как
вычислить код действия, который говорит, во что переводить щелчок
@kbd{mouse-1}.  Условие действия ссылки может быть одним из следующих:

@table @asis
@item @code{mouse-face}
Если условием является символ @code{mouse-face}, позиция находится внутри
ссылки, если в этой позиции есть свойство не-@code{nil} @code{mouse-face}.
Код действия всегда @code{t}.

Например, вот как режим info обрабатывает @key{mouse-1}:

@smallexample
(define-key Info-mode-map [follow-link] 'mouse-face)
@end smallexample

@item a function
Если условие является функцией @var{func}, тогда позиция @var{pos} находится
внутри ссылки, если @code{(@var{func} @var{pos})} оценивается как
не-@code{nil}.  Значение, возвращаемое @var{func}, служит кодом действия.

Например, вот как pcvs позволяет @kbd{mouse-1} переходить по ссылкам только
по именам файлов:

@smallexample
(define-key map [follow-link]
  (lambda (pos)
    (eq (get-char-property pos 'face) 'cvs-filename-face)))
@end smallexample

@item anything else
Если значение условия - любое другое, то позиция находится внутри ссылки, а
само условие является кодом действия. Ясно, что вы должны указывать этот вид
условия только при применении условия через текст или наложение свойств в
тексте ссылки (чтобы оно не применялось ко всему буферу).
@end table

@noindent
Код действия сообщает @kbd{mouse-1}, как перейти по ссылке:

@table @asis
@item a string or vector
Если код действия является строкой или вектором, событие @kbd{mouse-1}
транслируется в первый элемент строки или вектора; то есть действие щелчка
@kbd{mouse-1} является локальной или глобальной привязкой этого символа.
Таким образом, если код действия - @code{"foo"}, @kbd{mouse-1} преобразуется
в @kbd{f}.  Если это @code{[foo]}, @kbd{mouse-1} переводится в @key{foo}.

@item anything else
Для любого другого кода действия не-@code{nil} событие @kbd{mouse-1}
транслируется в событие @kbd{mouse-2} в той же позиции.
@end table

  Чтобы определить @kbd{mouse-1} для активации кнопки, определенной с помощью @code{define-button-type}, присвойте кнопке свойство @code{follow-link}. Значение свойства должно быть условием действия ссылки, как описано выше. @xref{Buttons}. Например, вот как режим справки обрабатывает @kbd{mouse-1}:

@smallexample
(define-button-type 'help-xref
  'follow-link t
  'action #'help-button-action)
@end smallexample

  Чтобы определить @kbd{mouse-1} для виджета, определенного с помощью
@code{define-widget}, присваивается виджету свойство @code{:follow-link}.
Значение свойства должно быть условием действия ссылки, как описано выше.
Например, вот как виджет @code{link} указывает, что клик @key{mouse-1}
переводится в @key{RET}:

@smallexample
(define-widget 'link 'item
  "Встроенная ссылка."
  :button-prefix 'widget-link-prefix
  :button-suffix 'widget-link-suffix
  :follow-link "\C-m"
  :help-echo "Follow the link."
  :format "%[%t%]")
@end smallexample

@defun mouse-on-link-p pos
Функция возвращает не-@code{nil}, если позиция @var{pos} в текущем буфере
находится на ссылке.  @var{pos} также может быть местоположением события
мыши, возвращаемым @code{event-start} (@pxref{Accessing Mouse}).
@end defun

@node Fields
@subsection Определение и Использование Полей
@cindex fields

  Поле - это диапазон последовательных символов в буфере, которые
идентифицируются по тому же значению (по сравнению с @code{eq}) свойства
@code{field} (либо текстовые свойства, либо свойства наложения).  В этом
разделе описаны специальные функции, доступные для работы с полями.

  Указывается поле с буферной позицией @var{pos}.  Предпологается, что
каждое поле содержит диапазон позиций буфера, поэтому указанная позиция
соответствует полю, содержащему эту позицию.

  Когда символы до и после @var{pos} являются частью одного и того же поля,
нет сомнений в том, какое поле содержит @var{pos}: то, которому принадлежат
оба этих символа.  Когда @var{pos} находится на границе между полями, то
какому полю он принадлежит, зависит от наследования свойств @code{field}
двух окружающих символов (@pxref{Sticky Properties}).  Поле, свойство
которого будет унаследовано текстом, вставленным в @var{pos}, - это поле,
содержащее @var{pos}.

  Существует аномальный случай, когда вновь вставленный текст в @var{pos} не
наследует свойство @code{field} ни с одной стороны.  Это происходит, если
свойство @code{field} предыдущего символа не является наследуемым сзади, а
свойство @code{field} следующего символа не является наследуемым спереди. В
этом случае @var{pos} не принадлежит ни предыдущему, ни следующему полю;
функции поля рассматривают его как принадлежащее пустому полю, начало и
конец которого находятся в @var{pos}.

  Во всех этих функциях, если @var{pos} опущен или @code{nil}, значение
точки используется по умолчанию.  Если действует сужение, то @var{pos}
должен попадать в доступную часть.  @xref{Narrowing}.

@defun field-beginning &optional pos escape-from-edge limit
Эта функция возвращает начало поля, указанного в @var{pos}.

Если @var{pos} находится в начале своего поля, а @var{escape-from-edge} -
не-@code{nil}, то возвращаемое значение всегда является началом предыдущего
поля, которое @emph{заканчивается} в @var{pos}, независимо от наследуемых
свойств @code{field} вокруг @var{pos}.

Если @var{limit} равен не-@code{nil}, это позиция буфера; если начало поля
перед @var{limit}, то вместо этого @var{limit} будет возвращено.
@end defun

@defun field-end &optional pos escape-from-edge limit
Эта функция возвращает конец поля, указанного в @var{pos}.

Если @var{pos} находится в конце своего поля, а @var{escape-from-edge} -
не-@code{nil}, то возвращаемое значение всегда является концом следующего
поля, которое @emph{начинается} в @var{pos}, независимо от наследуемых
свойств @code{field} вокруг @var{pos}.

Если @var{limit} равен не-@code{nil}, это позиция буфера; если конец поля
находится после @var{limit}, вместо этого будет возвращено @var{limit}.
@end defun

@defun field-string &optional pos
Функция возвращает содержимое поля, указанного в @var{pos}, в виде строки.
@end defun

@defun field-string-no-properties &optional pos
Функция возвращает содержимое поля, указанного в @var{pos}, в виде строки,
отбрасывая текстовые свойства.
@end defun

@defun delete-field &optional pos
Функция удаляет текст поля, указанного в @var{pos}.
@end defun

@defun constrain-to-field new-pos old-pos &optional escape-from-edge only-in-line inhibit-capture-property
Функция ограничивает @var{new-pos} полем, которому принадлежит @var{old-pos}
- другими словами, возвращает позицию, ближайшую к @var{new-pos}, которая
находится в том же поле, что и @var{old-pos}.

Если @var{new-pos} равен @code{nil}, тогда @code{constrain-to-field}
использует вместо этого значение point и перемещает точку в результирующую
позицию в дополнение к возврату этой позиции.

Если @var{old-pos} находится на границе двух полей, то приемлемые конечные
позиции зависят от аргумента @var{escape-from-edge}.  Если
@var{escape-from-edge} равен @code{nil}, то @var{new-pos} должен находиться
в поле, свойство @code{field} которого унаследовано для новых символов,
вставленных в @var{old-pos}.  (Это зависит от закрепления свойства
@code{field} для символов до и после @var{old-pos}.)  Если
@var{escape-from-edge} имеет значение не-@code{nil}, @var{new-pos} может
быть где угодно в двух соседних полях.  Кроме того, если два поля разделены
другим полем со специальным значением @code{boundary}, то любая точка в этом
специальном поле также считается находящейся на границе.

Команды вроде @kbd{C-a} без аргументов, которые обычно возвращаются в
определенное место и остаются там, вероятно, должны указывать @code{nil} для
@var{escape-from-edge}.  Другие команды движения, которые проверяют поля,
вероятно, должны передавать @code{t}.

Если необязательный аргумент @var{only-in-line} - не-@code{nil}, ограничение
@var{new-pos} обычным способом переместит его на другую строку,
@var{new-pos} возвращается без ограничений.  Это используется в командах,
перемещающихся по строкам, таких как @code{next-line} и
@code{beginning-of-line}, так что они соблюдают границы поля только в том
случае, если они все еще могут перемещаться на правую строку.

Если необязательный аргумент @var{inhibit-capture-property} - не-@code{nil},
а @var{old-pos} имеет свойство не-@code{nil} с таким именем, то любые
границы поля игнорируются.

Можно заставить @code{constrain-to-field} игнорировать все границы поля (и
поэтому никогда ничего не ограничивать), привязав переменную
@code{inhibit-field-text-motion} к значению не-@code{nil}.
@end defun

@node Not Intervals
@subsection Почему Свойства Текста не Являются Интервалами
@cindex intervals

  Некоторые редакторы, поддерживающие добавление атрибутов к тексту в
буфере, делают это, позволяя пользователю указывать интервалы в тексте и
добавляя свойства к интервалам.  Эти редакторы позволяют пользователю или
программисту определять, где начинаются и заканчиваются отдельные интервалы.
Сознательно предоставлен в Emacs Lisp интерфейс другого типа, чтобы избежать
определенного парадоксального поведения, связанного с модификацией текста.

  Если фактическое разделение на интервалы имеет смысл, это означает, что
можно различать буфер, который представляет собой всего один интервал с
определенным свойством, и буфер, содержащий тот же текст, разделенный на два
интервала, оба из которых имеют это свойство.

  Предпологается, берется буфер всего с одним интервалом и убивается часть
текста.  Текст, оставшийся в буфере, составляет один интервал, а копия в
списке уничтожения (и списке отмены) становится отдельным интервалом.
Затем, если возвращается убитый текст и получается два интервала с
одинаковыми свойствами.  Таким образом, редактирование не сохраняет различия
между одним интервалом и двумя.

  Предпологается решение этой проблемы, объединяя два интервала при вставке
текста.  Это нормально работает, если буфер изначально был одним интервалом.
Но предположим, что вместо этого есть два соседних интервала с одинаковыми
свойствами, и уничтожается текст одного интервала и возвращается обратно.
Та же самая функция слияния интервалов, которая спасает другой случай,
вызывает проблемы в этом случае: после восстановления у остается только один
интервал.  Еще раз, редактирование не сохраняет различия между одним
интервалом и двумя.

  Вставка текста на границе между интервалами также вызывает вопросы, на
которые нет удовлетворительного ответа.

  Тем не менее, легко организовать последовательное редактирование для
вопросов формы ``Каковы свойства текста в этом буфере или позиции строки?''.
Итак, решается, что это единственные вопросы, которые имеют смысл; не
реализована возможность задавать вопросы о том, где начинаются или
заканчиваются интервалы.

  На практике обычно можно использовать функции поиска текстовых свойств
вместо явных границ интервала.  Можно думать о них как о нахождении границ
интервалов, предполагая, что интервалы всегда объединяются, когда это
возможно.  @xref{Property Search}.

  Emacs также предоставляет явные интервалы в качестве функции
представления; смотреть @ref{Overlays}.

@node Substitution
@section Замена Кода Символа
@cindex replace characters in region
@cindex substitute characters

  Следующие функции заменяют символы в указанной области на основе их кодов
символов.

@defun subst-char-in-region start end old-char new-char &optional noundo
@cindex replace characters
Функция заменяет все вхождения символа @var{old-char} на символ
@var{new-char} в области текущего буфера, определяемой @var{start} и
@var{end}.

@cindex undo avoidance
Если @var{noundo} равен не-@code{nil}, то @code{subst-char-in-region} не
записывает изменение для отмены и не отмечает буфер как измененный.  Это
было полезно для управления старой функцией выборочного отображения
(@pxref{Selective Display}).

@code{subst-char-in-region} не перемещает точку и возвращает @code{nil}.

@example
@group
---------- Buffer: foo ----------
This is the contents of the buffer before.
---------- Buffer: foo ----------
@end group

@group
(subst-char-in-region 1 20 ?i ?X)
     @result{} nil

---------- Buffer: foo ----------
ThXs Xs the contents of the buffer before.
---------- Buffer: foo ----------
@end group
@end example
@end defun

@deffn Command translate-region start end table
Функция применяет таблицу трансляции к символам в буфере между позициями
@var{start} и @var{end}.

Таблица трансляции @var{table} - это строка или таблица символов;
@code{(aref @var{table} @var{ochar})} дает переведенный символ,
соответствующий @var{ochar}.  Если @var{table} является строкой, любые
символы с кодами, превышающими длину @var{table}, не изменяются при
трансляции.

Возвращаемое значение @code{translate-region} - это количество символов,
которые были фактически изменены трансляцией.  При этом не учитываются
символы, которые были сопоставлены сами с собой в таблице транслирования.
@end deffn

@node Registers
@section Регистры
@cindex registers

  Регистр - это своего рода переменная, используемая при редактировании
Emacs, которая может содержать множество различных типов значений.  Каждый
регистр назван одним символом.  Все символы @acronym{ASCII} и их мета
варианты (но за исключением @kbd{C-g}) могут использоваться для именования
регистров.  Таким образом, существует 255 возможных регистров.  Регистр
обозначается в Emacs Lisp символом, который является его именем.

@defvar register-alist
Переменная представляет собой список элементов вида
@code{(@var{name} . @var{contents})}.  Обычно на каждый использованный
регистр Emacs приходится по одному элементу.

Объект @var{name} - это символ (целое число), идентифицирующий регистр.
@end defvar

  @var{contents} реестра может иметь несколько возможных типов:

@table @asis
@item a number
Число означает само себя.  Если @code{insert-register} находит число в
регистре, преобразуется число в десятичное.

@item a marker
Маркер представляет позицию буфера, к которой нужно перейти.

@item a string
Строка - это текст, сохраненный в регистре.

@item a rectangle
@cindex rectangle, as contents of a register
Прямоугольник представлен списком строк.

@item @code{(@var{window-configuration} @var{position})}
Представляет конфигурацию окна для восстановления в одном кадре и позицию
для перехода в текущем буфере.

@c FIXME: Упомяните здесь набор фреймов.
@item @code{(@var{frame-configuration} @var{position})}
Представляет конфигурацию кадра для восстановления и позицию для перехода в
текущем буфере.

@item (file @var{filename})
Представляет собой файл для посещения; переход на это значение обращается к
файлу @var{filename}.

@item (file-query @var{filename} @var{position})
Представляет собой файл для посещения и позицию в нем; переход на это
значение после обращения к файлу @var{filename} в буферную позицию
@var{position}.  При восстановлении позиции этого типа у пользователя
сначала запрашивается подтверждение.
@end table

  Функции в этом разделе возвращают непредсказуемые значения, если не
указано иное.

@defun get-register reg
Функция возвращает содержимое регистра @var{reg} или @code{nil}, если в нем
нет содержимого.
@end defun

@defun set-register reg value
Функция устанавливает содержимое регистра @var{reg} в @var{value}.  Регистру
можно присвоить любое значение, но другие функции регистра ожидают только
определенных типов данных.  Возвращаемое значение - @var{value}.
@end defun

@deffn Command view-register reg
Команда отображает то, что содержится в регистре @var{reg}.
@end deffn

@deffn Command insert-register reg &optional beforep
Команда вставляет содержимое регистра @var{reg} в текущий буфер.

Обычно команда ставит точку перед вставленным текстом, а метку - после него.
Однако, если необязательный второй аргумент @var{beforep} - не-@code{nil},
ставится метка перед и точку после.

При интерактивном вызове команда по умолчанию ставит точку после текста, а
префиксный аргумент инвертирует это поведение.

Если регистр содержит прямоугольник, то этот прямоугольник вставляется так,
чтобы его верхний левый угол находился в точке.  Это означает, что текст
вставляется в текущую строку и под ней в последующих строках.

Если регистр содержит что-то кроме сохраненного текста (строки) или
прямоугольника (списка), в настоящее время происходят бесполезные вещи.  Это
может быть изменено в будущем.
@end deffn

@defun register-read-with-preview prompt
@cindex register preview
Функция считывает и возвращает имя регистра, запрашивая @var{prompt} и,
возможно, показывая предварительный просмотр существующих регистров и их
содержимого.  Предварительный просмотр отображается во временном окне после
задержки, заданной пользовательской опцией @code{register-preview-delay},
если его значение и @code{register-alist} оба равны не-@code{nil}.
Предварительный просмотр также отображается, если пользователь запрашивает
помощь (например, вводя символ справки).  Рекомендуется, чтобы все
интерактивные команды, считывающие имена регистров, использовали эту
функцию.
@end defun

@node Transposition
@section Транспонирование Текста

  Эта функция может использоваться для транспонирования фрагментов текста:

@defun transpose-regions start1 end1 start2 end2 &optional leave-markers
Функция меняет местами две неперекрывающиеся части буфера (если они
перекрываются, функция сигнализирует об ошибке).  Аргументы @var{start1} и
@var{end1} определяют границы одной части, а аргументы @var{start2} и
@var{end2} определяют границы другой части.

Обычно @code{transpose-regions} перемещает маркеры с транспонированным
текстом; маркер, ранее помещенный в одну из двух транспонированных частей,
перемещается вместе с этой частью, таким образом, оставаясь между теми же
двумя символами в их новой позиции.  Однако, если @var{leave-markers}
установленно в не-@code{nil}, @code{transpose-regions} не делает этого -
оставляет все маркеры нерасположенными.
@end defun

@node Replacing
@section Замена Текста в Буфере

  Можно использовать следующую функцию для замены текста одного буфера
текстом другого буфера:

@deffn Command replace-buffer-contents source
Функция заменяет доступную часть текущего буфера доступной частью буфера
@var{source}.  @var{source} может быть либо объектом буфера, либо именем
буфера.  Когда @code{replace-buffer-contents} завершается успешно, текст
доступной части текущего буфера будет равен тексту доступной части буфера
@var{source}.  Функция пытается сохранить точку, маркеры, свойства текста и
наложения в текущем буфере без изменений.  Один из возможных случаев, когда
такое поведение полезно, - это программы форматирования внешнего кода: они
обычно записывают переформатированный текст во временный буфер или файл, а
использование @code{delete-region} и @code{insert-buffer-substring}
уничтожит эти свойства.  Однако последняя комбинация обычно быстрее.
@xref{Deletion} и @ref{Insertion}.
@end deffn

@node Decompression
@section Работа со Сжатыми Данными

Когда включен @code{auto-compression-mode}, Emacs автоматически
распаковывает сжатые файлы, когда они посещаются и автоматически повторно
сжимает их, если они изменяются и сохраняются.
@xref{Compressed Files,,, emacs, GNU Emacs Руководство}.

Вышеупомянутая функция работает путем вызова внешнего исполняемого файла
(например, @command{gzip}).  Emacs также может быть скомпилирован с
поддержкой встроенной декомпрессии с использованием библиотеки zlib, что
быстрее, чем вызов внешней программы.

@defun zlib-available-p
Функция возвращает не-@code{nil}, если доступна встроенная распаковка zlib.
@end defun

@defun zlib-decompress-region start end
Функция распаковывает область между @var{start} и @var{end}, используя
встроенную декомпрессию zlib.  Область должна содержать данные, сжатые с
помощью gzip или zlib.  В случае успеха функция заменяет содержимое области
распакованными данными.  В случае неудачи функция оставляет регион без
изменений и возвращает @code{nil}.  Функция может быть вызвана только в
однобайтовых буферах.
@end defun


@node Base 64
@section Base 64 Кодирование
@cindex base 64 encoding

  Код Base 64 используется в электронной почте для кодирования
последовательности 8-битных байтов как более длинной последовательности
графических символов @acronym{ASCII}.  Определяется в Internet RFC@footnote{
RFC, аббревиатура от @dfn{Запрос Комментариев}, представляет собой
пронумерованный информационный документ в Интернете, описывающий стандарт.
RFC обычно пишутся техническими экспертами, действующими по собственной
инициативе, и традиционно пишутся в прагматичной манере, основанной на
опыте.}2045.  В этом разделе описаны функции преобразования в этот код и
обратно.

@deffn Command base64-encode-region beg end &optional no-line-break
Функция преобразует область от @var{beg} до @var{end} в код base 64.
Возвращает длину закодированного текста.  Ошибка сигнализируется, если
символ в области является многобайтовым, т.е. в многобайтовом буфере область
должна содержать только символы из кодировок @code{ascii},
@code{eight-bit-control} и @code{eight-bit-graphic}.

Обычно функция вставляет символы новой строки в закодированный текст, чтобы
избежать слишком длинных строк.  Однако, если необязательный аргумент
@var{no-line-break} - не-@code{nil}, эти символы новой строки не
добавляются, поэтому на выходе получается только одна длинная строка.
@end deffn

@defun base64-encode-string string &optional no-line-break
Функция преобразует строку @var{string} в код base 64.  Возвращает строку,
содержащую закодированный текст.  Что касается @code{base64-encode-region},
ошибка выдается, если символ в строке многобайтовый.

Обычно функция вставляет символы новой строки в закодированный текст, чтобы
избежать слишком длинных строк.  Однако, если необязательный аргумент
@var{no-line-break} - не-@code{nil}, эти новые строки не добавляются,
поэтому строка результата представляет собой единственную длинную строку.
@end defun

@deffn Command base64-decode-region beg end
Функция преобразует область от @var{beg} до @var{end} из кода base 64 в
соответствующий декодированный текст.  Возвращает длину декодированного
текста.

Функции декодирования игнорируют символы новой строки в закодированном
тексте.
@end deffn

@defun base64-decode-string string
Функция преобразует строку @var{string} из кода base 64 в соответствующий
декодированный текст.  Возвращается однобайтная строка, содержащая
декодированный текст.

Функции декодирования игнорируют символы новой строки в закодированном
тексте.
@end defun

@node Checksum/Hash
@section Контрольная Сумма/Хэш
@cindex MD5 checksum
@cindex SHA hash
@cindex hash, cryptographic
@cindex cryptographic hash

  Emacs имеет встроенную поддержку вычисления @dfn{криптографических хешей}.
Криптографический хеш или @dfn{checksum} - это цифровой отпечаток фрагмента
данных (например, блока текста), который можно использовать для проверки
наличия неизмененной копии этих данных.

@cindex message digest
  Emacs поддерживает несколько распространенных алгоритмов
криптографического хеширования: MD5, SHA-1, SHA-2, SHA-224, SHA-256, SHA-384
и SHA-512.  MD5 является самым старым из этих алгоритмов и обычно
используется в @dfn{дайджестах сообщений} для проверки целостности
сообщений, передаваемых по сети.  MD5 не устойчив к коллизиям (то есть можно
намеренно создавать разные фрагменты данных с одинаковым хешем MD5), поэтому
не нужно использовать его для чего-либо, связанного с безопасностью.
Аналогичная теоретическая слабость существует и в SHA-1.  Следовательно, для
приложений, связанных с безопасностью, потребуется использовать другие типы
хешей, такие как SHA-2.

@defun secure-hash-algorithms
Функция возвращает список символов, представляющих алгоритмы, которые может
использовать @code{secure-hash}.
@end defun

@defun secure-hash algorithm object &optional start end binary
Функция возвращает хеш для @var{object}.  Аргумент @var{algorithm} - это
символ, указывающий, какой хэш вычислить: один из @code{md5}, @code{sha1},
@code{sha224}, @code{sha256}, @code{sha384} или @code{sha512}.  Аргумент
@var{object} должен быть буфером или строкой.

Необязательные аргументы @var{start} и @var{end} - это позиции символов,
определяющие часть @var{object}, для которой вычисляется дайджест сообщения.
Если они равны @code{nil} или опущены, хеш вычисляется для всего
@var{object}.

Если аргумент @var{binary} опущен или @code{nil}, функция возвращает
@dfn{текстовую форму} хэша как обычную строку Lisp.  Если @var{binary} -
не-@code{nil}, возвращаетcz хэш в @dfn{двоичной формы} как
последовательность байтов, хранящуюся в однобайтовой строке.

Функция не вычисляет хэш непосредственно из внутреннего представления
текста @var{object} (@pxref{Text Representations}).  Вместо этого кодируется
текст, используя систему кодирования (@pxref{Coding Systems}), и вычисляет
хэш из этого закодированного текста.  Если @var{object} является буфером,
используется система кодирования, которая будет выбрана по умолчанию для
записи текста в файл.  Если @var{object} является строкой, используется
предпочитаемая пользователем система кодирования
(@pxref{Recognize Coding,,, emacs, Руководство GNU Emacs}).
@end defun

@defun md5 object &optional start end coding-system noerror
Функция возвращает хеш MD5.  Он наполовину устарел, поскольку для
большинства целей он эквивалентен вызову @code{secure-hash} с @code{md5} в
качестве аргумента @var{algorithm}.  Аргументы @var{object}, @var{start} и
@var{end} имеют то же значение, что и в @code{secure-hash}.

Если @var{coding-system} - не-@code{nil}, он указывает систему кодирования,
используемую для кодирования текста; если опущен или @code{nil},
используется система кодирования по умолчанию, как в @code{secure-hash}.

Обычно @code{md5} сигнализирует об ошибке, если текст не может быть
закодирован с использованием указанной или выбранной системы кодирования.
Однако, если @var{noerror} равен не-@code{nil}, вместо этого используется
кодировка @code{raw-text}.
@end defun

@defun buffer-hash &optional buffer-or-name
Возвращается хеш @var{buffer-or-name}.  Если @code{nil}, по умолчанию
используется текущий буфер.  В отличие от @code{secure-hash}, эта функция
вычисляет хэш на основе внутреннего представления буфера, игнорируя
какие-либо системы кодирования.  Поэтому это полезно только при сравнении
двух буферов, работающих в одном и том же Emacs, и не гарантируется возврат
одного и того же хэша между разными версиями Emacs.  Должно быть несколько
более эффективным для буферов большего размера, чем @code{secure-hash}, и
не должно выделяться больше памяти.
@c Обратить внимание, что не документируется, какая хеширующая функция
@c используется или, даже если это криптографический хеш, поскольку это
@c может измениться в зависимости от того, что считается полезным.
@end defun

@node GnuTLS Cryptography
@section Криптография GnuTLS
@cindex MD5 checksum
@cindex SHA hash
@cindex hash, cryptographic
@cindex cryptographic hash
@cindex AEAD cipher
@cindex cipher, AEAD
@cindex symmetric cipher
@cindex cipher, symmetric

Если Emacs скомпилирован с помощью GnuTLS, он предлагает встроенную
криптографическую поддержку.  Следуя терминологии API GnuTLS, доступными
инструментами являются дайджесты, MAC-адреса, симметричные шифры и шифры
AEAD.

Используемые здесь термины, такие как IV (вектор инициализации), требуют
некоторого знакомства с криптографией и не будут определяться подробно.
Обратиться к @uref{https://www.gnutls.org/} для получения конкретной
документации, которая может помочь понять терминологию и структуру
библиотеки GnuTLS.

@menu
* Format of GnuTLS Cryptography Inputs::
* GnuTLS Cryptographic Functions::
@end menu

@node Format of GnuTLS Cryptography Inputs
@subsection Формат Входных Данных Криптографии GnuTLS
@cindex format of gnutls cryptography inputs
@cindex gnutls cryptography inputs format

Входные данные для криптографических функций GnuTLS могут быть указаны
несколькими способами, как в виде примитивных типов Emacs Lisp, так и в
виде списков.

Форма списка в настоящее время похожа на то, как работают @code{md5} и
@code{secure-hash}.

@table @code
@item @var{buffer}
Простая передача буфера в качестве ввода означает, что следует использовать
весь буфер.

@item @var{string}
Строка в качестве ввода будет использоваться напрямую.  Может быть изменено
функцией (в отличие от большинства других функций Emacs Lisp), чтобы
уменьшить вероятность раскрытия конфиденциальных данных после того, как
функция выполнит свою работу.

@item (@var{buffer-or-string} @var{start} @var{end} @var{coding-system} @var{noerror})
Определяет буфер или строку, как описано выше, но необязательный диапазон
может быть указан с помощью @var{start} и @var{end}.

Кроме того, при необходимости можно указать необязательный
@var{coding-system}.

Последний необязательный элемент, @var{noerror}, отменяет обычную ошибку,
когда текст не может быть закодирован с использованием указанной или
выбранной системы кодирования.  Когда @var{noerror} равен не-@code{nil}, эта
функция вместо этого использует кодировку @code{raw-text}.

@item (@code{iv-auto} @var{length})
Это сгенерирует IV (вектор инициализации) указанной длины с помощью
генератора GnuTLS @code{GNUTLS_RND_NONCE} и передаст его функции.  Это
гарантирует, что IV будет непредсказуемым и вряд ли будет повторно
использован в том же сеансе.  Фактическое значение IV возвращается функцией,
как описано ниже.

@end table

@node GnuTLS Cryptographic Functions
@subsection Криптографические Функции GnuTLS
@cindex gnutls cryptographic functions

@defun gnutls-digests
Эта функция возвращает список алгоритмов дайджеста GnuTLS.

У каждой записи есть ключ, который представляет алгоритм, за которым следует
список с внутренними деталями алгоритма.  Список будет иметь
@code{:type gnutls-digest-algorithm} и ключ
@code{:digest-algorithm-length 64} для указания размера в байтах
результирующего дайджеста.

Существует параллель имен между GnuTLS MAC и алгоритмами дайджеста, но они
внутренне разные и не должны смешиваться.
@end defun

@defun gnutls-hash-digest digest-method input
@var{digest-method} может быть целым списком из @code{gnutls-digests}, или
только ключом символа, или строкой с именем этого символа.

@var{input} можно указать как буфер, строку или другими способами
(@pxref{Format of GnuTLS Cryptography Inputs}).

Функция возвращает @code{nil} при ошибке и сигнализирует об ошибке Lisp,
если @var{digest-method} или @var{input} недопустимы.  В случае успеха он
возвращает список из двоичной строки (выход) и использованного IV.
@end defun

@defun gnutls-macs
Функция возвращает список алгоритмов MAC GnuTLS.

У каждой записи есть ключ, который представляет алгоритм, за которым следует
список с внутренними деталями алгоритма.  Список будет иметь
@code{:type gnutls-mac-algorithm}, а также ключи
@code{:mac-algorithm-length} @code{:mac-algorithm-keysize}
@code{:mac-algorithm-noncesize}, чтобы указать размер в байтах
результирующего хэша, ключа и одноразового номера соответственно.

Одноразовый номер в настоящее время не используется, и только некоторые
MAC-адреса поддерживают его.

Существует параллель имен между GnuTLS MAC и алгоритмами дайджеста, но они
внутренне разные и не должны смешиваться.
@end defun

@defun gnutls-hash-mac hash-method key input
@var{hash-method} может быть целым списком из @code{gnutls-macs}, или только
ключом символа, или строкой с именем этого символа.

@var{key} можно указать как буфер, строку или другими способами
(@pxref{Format of GnuTLS Cryptography Inputs}).  @var{key} будет удален
после использования, если это строка.

@var{input} можно указать как буфер, строку или другими способами
(@pxref{Format of GnuTLS Cryptography Inputs}).

Функция возвращает @code{nil} при ошибке и сигнализирует об ошибке Lisp,
если @var{hash-method}, @var{key} или @var{input} недопустимы.

В случае успеха возвращается список из двоичной строки (выход) и
использованного IV.
@end defun

@defun gnutls-ciphers
Функция возвращает список шифров GnuTLS.

Каждая запись имеет ключ, представляющий шифр, за которым следует список с
внутренними подробностями об алгоритме.  Plist будет иметь
@code{:type gnutls-symmetric-cipher}, а также ключи
@code{:cipher-aead-capable} будут иметь значение @code{nil} или @code{t},
чтобы указать возможность AEAD; и @code{:cipher-tagsize}
@code{:cipher-blocksize} @code{:cipher-keysize} @code{:cipher-ivsize} для
указания размера тега в байтах, размера блока результирующих данных, ключа и
IV соответственно.
@end defun

@defun gnutls-symmetric-encrypt cipher key iv input &optional aead_auth
@var{cipher} может быть целым списком из @code{gnutls-ciphers}, или только
ключом символа, или строкой с именем этого символа.

@var{key} можно указать как буфер, строку или другими способами
(@pxref{Format of GnuTLS Cryptography Inputs}).  @var{key} будет удален
после использования, если это строка.

@var{iv} и @var{input} и необязательный @var{aead_auth} можно указать как
буфер, строку или другими способами
(@pxref{Format of GnuTLS Cryptography Inputs}).

@var{aead_auth} проверяется только с шифрами AEAD, то есть шифрами, у
которых в plist есть @code{:cipher-aead-capable t}.  В противном случае
игнорируется.

Функция возвращает @code{nil} в случае ошибки и сигнализирует об ошибке
Lisp, если @var{cipher} или @var{key}, @var{iv} или @var{input} недопустимы,
или если @var{aead_auth} был указан с шифром AEAD и был недопустимым.

В случае успеха он возвращает список двоичной строки (вывод) и
используемого IV.
@end defun

@defun gnutls-symmetric-decrypt cipher key iv input &optional aead_auth
@var{cipher} может быть целым списком из @code{gnutls-ciphers}, или только
ключом символа, или строкой с именем этого символа.

@var{key} можно указать как буфер, строку или другими способами
(@pxref{Format of GnuTLS Cryptography Inputs}).  @var{key} будет удален
после использования, если это строка.

@var{iv} и @var{input} и необязательный @var{aead_auth} можно указать как
буфер, строку или другими способами
(@pxref{Format of GnuTLS Cryptography Inputs}).

@var{aead_auth} проверяется только с шифрами AEAD, то есть шифрами, у
которых в plist есть @code{:cipher-aead-capable t}.  В противном случае
игнорируется.

Эта функция возвращает @code{nil} при ошибке дешифрования и сигнализирует
об ошибке Lisp, если @var{cipher} или @var{key}, @var{iv} или @var{input}
недопустимы, или если @var{aead_auth} был указан с шифром AEAD и был
недопустимым.

В случае успеха он возвращает список из двоичной строки (выход) и
использованного IV.
@end defun

@node Parsing HTML/XML
@section Разбор HTML и XML
@cindex parsing html

Когда Emacs скомпилирован с поддержкой libxml2, доступны следующие функции
для синтаксического анализа текста HTML или XML в деревьях объектов Lisp.

@defun libxml-parse-html-region start end &optional base-url discard-comments
Функция анализирует текст между @var{start} и @var{end} как HTML и
возвращает список, представляющий @dfn{дерево синтаксического анализа} HTML.
Пытается обрабатывать реальный HTML, надежно исправляя синтаксические
ошибки.

Необязательный аргумент @var{base-url}, если не-@code{nil}, должен быть
строкой, определяющей базовый URL для относительных URL-адресов,
встречающихся в ссылках.

Если необязательный аргумент @var{discard-comments} - не-@code{nil}, то
дерево синтаксического анализа создается без комментариев.

В дереве синтаксического анализа каждый узел HTML представлен списком, в
котором первый элемент является символом, представляющим имя узла, второй
элемент - списком атрибутов узла, а остальные элементы - подузлами.

Следующий пример демонстрирует это. Учитывая этот (искаженный) документ
HTML:

@example
<html><head></head><body width=101><div class=thing>Foo<div>Yes
@end example

@noindent
Вызов @code{libxml-parse-html-region} возвращает этот @acronym{DOM}
(объектную модель документа):

@example
(html nil
 (head nil)
 (body ((width . "101"))
  (div ((class . "thing"))
   "Foo"
   (div nil
    "Yes"))))
@end example
@end defun

@cindex rendering html
@defun shr-insert-document dom
Функция отображает проанализированный HTML в @var{dom} в текущий буфер.
Аргумент @var{dom} должен быть списком, сгенерированным
@code{libxml-parse-html-region}.  Эту функцию, например, использует
@ref{Top, EWW,, eww, The Emacs Web Wowser Manual}.
@end defun

@cindex parsing xml
@defun libxml-parse-xml-region start end &optional base-url discard-comments
Функция аналогична @code{libxml-parse-html-region}, за исключением того, что
она анализирует текст как XML, а не как HTML (так что синтаксис здесь
строже).
@end defun

@menu
* Document Object Model:: Доступ, управление и поиск в @acronym{DOM}.
@end menu

@node Document Object Model
@subsection Объектная Модель Документа
@cindex HTML DOM
@cindex XML DOM
@cindex DOM
@cindex Document Object Model

@acronym{DOM}, возвращаемый @code{libxml-parse-html-region} (и другими
функциями синтаксического анализа @acronym{XML}), представляет собой
древовидную структуру, в которой каждый узел имеет имя узла (называемое
@dfn{тег}) и необязательный список ключей/значений @dfn{атрибутов}, а затем
список @dfn{дочерних узлов}.  Дочерние узлы являются либо строками, либо
объектами @acronym{DOM}.

@example
(body ((width . "101"))
 (div ((class . "thing"))
  "Foo"
  (div nil
   "Yes")))
@end example

@defun dom-node tag &optional attributes &rest children
Функция создает узел @acronym{DOM} типа @var{tag}.  Если задан,
@var{attributes} должен быть списком пар ключ/значение.  Если задано,
@var{children} должно быть узлами @acronym{DOM}.
@end defun

Следующие функции могут использоваться для работы с этой структурой.  Каждая
функция принимает узел @acronym{DOM} или список узлов.  В последнем случае
используется только первый узел в списке.

Простые аксессуары:

@table @code
@item dom-tag @var{node}
Вернуть @dfn{tag} (также называемый ``имя узла'') узла.

@item dom-attr @var{node} @var{attribute}
Вернуть значение @var{attribute} в узле.  Обычное использование было бы:

@lisp
(dom-attr img 'href)
=> "https://fsf.org/logo.png"
@end lisp

@item dom-children @var{node}
Вернуть все дочерние узлы узла.

@item dom-non-text-children @var{node}
Вернуть все дочерние элементы узла, не являющиеся строковыми.

@item dom-attributes @var{node}
Вернуть список пар ключ/значение атрибутов узла.

@item dom-text @var{node}
Вернуть все текстовые элементы узла в виде объединенной строки.

@item dom-texts @var{node}
Рекурсивно вернуть все текстовые элементы узла, а также текстовые элементы
всех дочерних узлов узла в виде объединенной строки.  Эта функция также
принимает дополнительный разделитель, который нужно вставить между
текстовыми элементами.

@item dom-parent @var{dom} @var{node}
Вернуть родительский объект @var{node} в @var{dom}.

@item dom-remove @var{dom} @var{node}
Убрать @var{node} из @var{dom}.
@end table

Ниже приведены функции для изменения файла @acronym{DOM}.

@table @code
@item dom-set-attribute @var{node} @var{attribute} @var{value}
Установить @var{attribute} узла в @var{value}.

@item dom-append-child @var{node} @var{child}
Добавить @var{child} в качестве последнего потомка @var{node}.

@item dom-add-child-before @var{node} @var{child} @var{before}
Добавить @var{child} в дочерний список @var{node} перед узлом @var{before}.
Если @var{before} - это @code{nil}, сделать @var{child} первым дочерним
элементом.

@item dom-set-attributes @var{node} @var{attributes}
Заменить все атрибуты узла новым списком ключей/значений.
@end table

Ниже приведены функции для поиска элементов в файле @acronym{DOM}.  Все они
возвращают списки совпадающих узлов.

@table @code
@item dom-by-tag @var{dom} @var{tag}
Вернуть все узлы в @var{dom}, которые имеют тип @var{tag}.  Типичное
использование было бы:

@lisp
(dom-by-tag dom 'td)
=> '((td ...) (td ...) (td ...))
@end lisp

@item dom-by-class @var{dom} @var{match}
Вернуть все узлы в @var{dom}, имена классов которых соответствуют
@var{match}, что является регулярным выражением.

@item dom-by-style @var{dom} @var{style}
Вернуть все узлы в @var{dom}, стили которых соответствуют @var{match},
что является регулярным выражением.

@item dom-by-id @var{dom} @var{style}
Вернуть все узлы в @var{dom}, идентификаторы которых совпадают с
@var{match}, что является регулярным выражением.

@item dom-strings @var{dom}
Вернуть все строки в @var{dom}.

@end table

Служебные функции:

@table @code
@item dom-pp @var{dom} &optional @var{remove-empty}
Довольно-напечатать @var{dom} в точке.  Если @var{remove-empty}, не
печатать текстовые узлы, которые просто содержат пробелы.
@end table


@node Atomic Changes
@section Группы Атомарных Изменений
@cindex atomic changes

  В терминологии базы данных @dfn{атомарное} изменение является неделимым
изменением - оно может быть успешным или полностью неудачным, но не может
быть частично успешным.  Программа на Lisp может вносить серию изменений в
один или несколько буферов как @dfn{группу атомарных изменений}, что
означает, что либо вся серия изменений будет установлена в их буферы, либо,
в случае ошибки, ни одно из них не будет установлено.

  Чтобы сделать это для одного буфера, уже текущего, просто пишется вызов
@code{atomic-change-group} вокруг кода, который вносит изменения, например:

@example
(atomic-change-group
  (insert foo)
  (delete-region x y))
@end example

@noindent
Если ошибка (или другой нелокальный выход) происходит внутри тела
@code{atomic-change-group}, отменяются все изменения в этом буфере, которые
были во время выполнения тела.  Такая группа изменений не влияет на другие
буферы - любые такие изменения остаются.

  Если требуется что-то более сложное, например, чтобы внести изменения в
различные буферы, составляющие одну атомарную группу, потребуется напрямую
вызывать функции нижнего уровня, которые использует
@code{atomic-change-group}.

@defun prepare-change-group &optional buffer
Функция устанавливает группу изменений для буфера @var{buffer}, который по
умолчанию равен текущему буферу.  Возвращается дескриптор, представляющий
группу изменений.  Требуется использовать этот дескриптор, чтобы
активировать группу изменений и впоследствии завершить ее.
@end defun

  Чтобы использовать группу изменений, потребуется @dfn{активировать} её.
Нужно сделать это перед тем, как вносить какие-либо изменения в текст
@var{buffer}.

@defun activate-change-group handle
This function activates the change group that @var{handle} designates.
@end defun

  После активации группы изменений любые изменения, которые вносятся в этот
буфер, становятся ее частью.  После того, как внесены все желаемые изменения
в буфер, требуется @dfn{финализировать} группу изменений.  Это можно сделать
двумя способами: можно либо принять (и завершить) все изменения, либо
отменить их все.

@defun accept-change-group handle
Функция принимает все изменения в группе изменений, указанной @var{handle},
делая их завершенными.
@end defun

@defun cancel-change-group handle
Функция отменяет все изменения в группе изменений, указанной @var{handle}.
@end defun

  Код должен использовать @code{unwind-protect}, чтобы группа всегда была
завершенной.  Вызов @code{activate-change-group} должен находиться внутри
@code{unwind-protect}, на случай, если пользователь наберет @kbd{C-g} сразу
после его запуска.  (Это одна из причин, по которой
@code{prepare-change-group} и @code{activate-change-group} являются
отдельными функциями, потому что обычно вызывается
@code{prepare-change-group} перед началом этого @code{unwind-protect}.)
После завершения группы не использовать дескриптор снова - в частности, не
пытаться дважды завершить одну и ту же группу.

  Чтобы создать группу изменения мультибуфера, вызвать
@code{prepare-change-group} один раз для каждого буфера, который требуется
охватить, затем использовать @code{nconc} для объединения возвращаемых
значений, как здеся:

@example
(nconc (prepare-change-group buffer-1)
       (prepare-change-group buffer-2))
@end example

Затем можно активировать группу изменения мультибуфера одним вызовом
@code{activate-change-group} и завершить его одним вызовом
@code{accept-change-group} или @code{cancel-change-group}.

  Вложенное использование нескольких групп изменений для одного и того же
буфера работает, как и следовало ожидать.  Использование невложенных групп
изменений для одного и того же буфера запутает Emacs, так что не позволять
этому случиться; первая группа изменений, которая запускается для любого
заданного буфера, должна быть последней завершенной.

@node Change Hooks
@section Изменение Перехватчиков
@cindex change hooks
@cindex hooks for text changes

  Эти переменные-ловушки позволяют отслеживать изменения в буферах (или в
конкретном буфере, если сделать их локальными для буфера).  Смотреть также
@ref{Special Properties}, чтобы узнать, как обнаружить изменения в
определенных частях текста.

  Функции, которые используются в этих перехватчиках, должны сохранять и
восстанавливать данные соответствия, если они делают что-либо, использующее
регулярные выражения; в противном случае они будут причудливым образом
вмешиваться в вызывающие их операции редактирования.

@defvar before-change-functions
Переменная содержит список функций, вызываемых, когда Emacs собирается
изменить буфер.  Каждая функция получает два аргумента: начало и конец
области, которая собирается измениться, представленных в виде целых чисел.
Буфер, который собирается измениться, всегда является текущим буфером при
вызове функции.
@end defvar

@defvar after-change-functions
Переменная содержит список функций, вызываемых после того, как Emacs
модифицирует буфер.  Каждая функция получает три аргумента: начало и конец
только что измененной области и длину текста, существовавшего до изменения.
Все три аргумента являются целыми числами.  Буфер, который был изменен,
всегда является текущим буфером при вызове функции.

Длина старого текста - это разница между позициями буфера до и после этого
текста, как это было до изменения.  Что касается измененного текста, его
длина - это просто разница между первыми двумя аргументами.
@end defvar

  Вывод сообщений в буфер @file{*Messages*} не вызывает эти функции, как и
некоторые изменения внутреннего буфера, такие как изменения в буферах,
созданных внутри Emacs для определенных заданий, которые не должны быть
видны программам на Lisp.

Подавляющее большинство примитивов изменения буфера будут вызывать
@code{before-change-functions} и @code{after-change-functions} в
сбалансированных парах, по одному разу для каждого изменения, где аргументы
этих перехватчиков точно ограничивают вносимое изменение.  Тем не менее,
функции-перехватчики не должны полагаться на это всегда, потому что
некоторые сложные примитивы вызывают @code{before-change-functions} один раз
перед внесением изменений, а затем вызывают @code{after-change-functions}
ноль или более раз, в зависимости от того, сколько отдельных изменений
вносит примитив.  Когда это произойдет, аргументы
@code{before-change-functions} будут заключать в себя область, в которой
производятся отдельные изменения, но не обязательно будет минимальной такой
областью, и аргументы для каждого последующего вызова
@code{after-change-functions} будут точно ограничивать изменяемую часть
текста.  В общем, советуется использовать перехватчики до или после смены,
но не одновременно.

@defmac combine-after-change-calls body@dots{}
Макрос обычно выполняет @var{body}, но организует вызов функций после
изменения только один раз для серии из нескольких изменений - если это
кажется безопасным.

Если программа вносит несколько изменений текста в одну и ту же область
буфера, использование макроса @code{combine-after-change-calls} вокруг этой
части программы может значительно ускорить ее выполнение при использовании
перехватчиков после изменения.  Когда в конечном итоге вызываются
перехватчики после изменения, аргументы определяют часть буфера, включая все
изменения, сделанные в теле @code{combine-after-change-calls}.

@strong{Предупреждение:} Не требуется изменять значения
@code{after-change-functions} в теле формы
@code{combine-after-change-calls}.

@strong{Предупреждение:} если изменения, которые объединяются, происходят в
сильно разбросанных частях буфера, это все равно будет работать, но это не
рекомендуется, потому что это может привести к неэффективному поведению
некоторых функций ловушки изменений.
@end defmac

@defvar first-change-hook
Переменная - обычная ловушка, которая запускается всякий раз, когда
изменяется буфер, который ранее находился в неизмененном состоянии.
@end defvar

@defvar inhibit-modification-hooks
Если переменная - не-@code{nil}, все перехватчики изменений отключены; никто
из них не вызывется.  Это влияет на все переменные ловушки, описанные выше в
этом разделе, а также на ловушки, прикрепленные к определенным специальным
свойствам текста (@pxref{Special Properties}) и свойствам наложения
(@pxref{Overlay Properties}).

Кроме того, эта переменная привязана к не-@code{nil} при запуске тех же
переменных ловушки, так что по умолчанию изменение буфера из ловушки
модификации не вызывает запуск других ловушек модификации.  Если
действительно требуется, чтобы обработчики модификации запускались в
конкретном фрагменте кода, который сам запускается из обработчика
модификации, то локально повторно привязать
@code{inhibit-modification-hooks} к @code{nil}.
@end defvar
