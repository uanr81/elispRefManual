@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-2019 Free Software Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Text
@chapter Текст
@cindex text

  В этой главе описаны функции, которые работают с текстом в буфере.
Большинство из них проверяют, вставляют или удаляют текст в текущем буфере,
часто работая с точкой или с текстом, смежным с точкой.  Многие из них
интерактивны.  Все функции, изменяющие текст, предусматривают отмену
изменений (@pxref{Undo}).

  Многие связанные с текстом функции работают с областью текста,
определяемой двумя позициями буфера, переданными в аргументах с именем
@var{start} и @var{end}.  Эти аргументы должны быть либо маркерами
(@pxref{Markers}), либо числовыми позициями символов (@pxref{Positions}).
Порядок этих аргументов не имеет значения; допустимо, чтобы @var{start} было
концом области, а @var{end} - началом.  Например,
@code{(delete-region 1 10)} и @code{(delete-region 10 1)} эквивалентно.  Об
ошибке @code{args-out-of-range} сообщается, если @var{start} или @var{end}
находятся за пределами доступной части буфера.  В интерактивном вызове для
этих аргументов используются точка и метка.

@cindex buffer contents
  В этой главе ``text'' относится к символам в буфере вместе с их свойствами
(если это необходимо).  Иметь в виду, что точка всегда находится между двумя
символами, а курсор появляется на символе после точки.

@menu
* Near Point::       Изучение текста в непосредственной близости от точки.
* Buffer Contents::  Изучение текста в общем виде.
* Comparing Text::   Сравнение подстрок буферов.
* Insertion::        Добавление нового текста в буфер.
* Commands for Insertion::  Команды пользовательского уровня для
                               вставки текста.
* Deletion::         Удаление текста из буфера.
* User-Level Deletion::     Команды уровня пользователя для удаления текста.
* The Kill Ring::    Где удаленный текст иногда сохраняется для
                        дальнейшего использования.
* Undo::             Отмена изменений текста буфера.
* Maintaining Undo:: Как включить и отключить информацию об отмене.
                        Как контролировать объем хранимой информации.
* Filling::          Функции для явного заполнения.
* Margins::          Как указать поля для команд заполнения.
* Adaptive Fill::    В режиме адаптивной заливки префикс заливки
                        выбирается из контекста.
* Auto Filling::     Как реализован режим автозаполнения для разрыва строк.
* Sorting::          Функции для сортировки частей буфера.
* Columns::          Вычисление горизонтальных положений и их использование.
* Indentation::      Функции для вставки или корректировки отступа.
* Case Changes::     Преобразование регистров частей буфера.
* Text Properties::  Назначение списков свойств Lisp текстовым символам.
* Substitution::     Замена данного символа везде, где он появляется.
* Registers::        Как реализуются регистры.  Доступ к тексту или позиции,
                        хранящейся в регистре.
* Transposition::    Обмен двух частей буфера.
* Replacing::        Замена текста одного буфера текстом другого буфера.
* Decompression::    Работа со сжатыми данными.
* Base 64::          Преобразование в кодировку base 64 или из нее.
* Checksum/Hash::    Вычисление криптографических хэшей.
* GnuTLS Cryptography:: Криптографические алгоритмы, импортированные
                           из GnuTLS.
* Parsing HTML/XML:: Разбор HTML и XML.
* Atomic Changes::   Атомарная установка нескольких изменений буфера.
* Change Hooks::     Предоставление функций, запускаемых при
                        изменении текста.
@end menu

@node Near Point
@section Изучение Текста Рядом с Точкой
@cindex text near point

  Many functions are provided to look at the characters around point.
Several simple functions are described here.  Смотреть также
@code{looking-at} в @ref{Regexp Search}.

В следующих четырех функциях ``beginning'' или ``end'' буфера относятся к
началу или концу доступной части.

@defun char-after &optional position
Функция возвращает символ в текущем буфере в (то есть сразу после) позиции
@var{position}.  Если @var{position} выходит за пределы допустимого
диапазона для этой цели, либо до начала буфера, либо в конце или за его
пределами, тогда значение будет @code{nil}.  Значение по умолчанию для
@var{position} - точка.

В следующем примере предположим, что первый символ в буфере - @samp{@@}:

@example
@group
(string (char-after 1))
     @result{} "@@"
@end group
@end example
@end defun

@defun char-before &optional position
Функция возвращает символ в текущем буфере непосредственно перед позицией
@var{position}.  Если @var{position} выходит за пределы допустимого
диапазона, либо в начале буфера, либо перед ним, либо за его
пределами, тогда значение равно @code{nil}.  Значение по умолчанию для
@var{position} - точка.
@end defun

@defun following-char
Функция возвращает символ, следующий за точкой в текущем буфере.  Это похоже
на @code{(char-after (point))}.  Однако, если точка находится в конце
буфера, @code{following-char} возвращает 0.

Помнить, что точка всегда находится между символами, и курсор обычно
появляется над символом, следующим за точкой.  Следовательно, символ,
возвращаемый @code{following-char}, - это символ, над которым находится
курсор.

В этом примере точка находится между @samp{a} и @samp{c}.

@example
@group
---------- Buffer: foo ----------
Gentlemen may cry ``Pea@point{}ce! Peace!,''
but there is no peace.
---------- Buffer: foo ----------
@end group

@group
(string (preceding-char))
     @result{} "a"
(string (following-char))
     @result{} "c"
@end group
@end example
@end defun

@defun preceding-char
Функция возвращает символ, предшествующий точке в текущем буфере.  Смотреть
пример выше, в разделе @code{following-char}.  Если точка находится в начале
буфера, @code{preceding-char} возвращает 0.
@end defun

@defun bobp
Функция возвращает @code{t}, если точка находится в начале буфера.  Если
действует сужение, это означает начало доступной части текста.  Смотреть
также @code{point-min} в @ref{Point}.
@end defun

@defun eobp
Функция возвращает @code{t}, если точка находится в конце буфера.  Если
действует сужение, это означает конец доступной части текста.  Смотреть
также @code{point-max} в @xref{Point}.
@end defun

@defun bolp
Функция возвращает @code{t}, если точка находится в начале строки.
@xref{Text Lines}.  Начало буфера (или его доступной части) всегда считается
началом строки.
@end defun

@defun eolp
Функция возвращает @code{t}, если точка находится в конце строки.  Конец
буфера (или его доступной части) всегда считается концом строки.
@end defun

@node Buffer Contents
@section Изучение Содержимого Буфера
@cindex buffer portion as string

  В этом разделе описаны функции, которые позволяют программе на Lisp
преобразовывать любую часть текста буфера в строку.

@defun buffer-substring start end
Функция возвращает строку, содержащую копию текста области, определенной
позициями @var{start} и @var{end} в текущем буфере.  Если аргументы не
являются позициями в доступной части буфера, @code{buffer-substring}
сигнализирует об ошибке @code{args-out-of-range}.

Вот пример, который предполагает, что режим Font-Lock не включен:

@example
@group
---------- Buffer: foo ----------
This is the contents of buffer foo

---------- Buffer: foo ----------
@end group

@group
(buffer-substring 1 10)
     @result{} "This is t"
@end group
@group
(buffer-substring (point-max) 10)
     @result{} "he contents of buffer foo\n"
@end group
@end example

Если копируемый текст имеет какие-либо текстовые свойства, они копируются в
строку вместе с символами, которым они принадлежат.  @xref{Text Properties}.
Однако наложения (@pxref{Overlays}) в буфере и их свойства игнорируются, а
не копируются.

Например, если включен режим Font-Lock, можно получить такие результаты:

@example
@group
(buffer-substring 1 10)
     @result{} #("This is t" 0 1 (fontified t) 1 9 (fontified t))
@end group
@end example
@end defun

@defun buffer-substring-no-properties start end
Похоже на @code{buffer-substring}, за исключением того, что не
копируются свойства текста, а только сами символы.  @xref{Text Properties}.
@end defun

@defun buffer-string
Функция возвращает содержимое всей доступной части текущего буфера в виде
строки.
@end defun

  Если нужно убедиться, что результирующая строка при копировании в другое
место не изменит свой внешний вид из-за переупорядочения двунаправленного
текста, использовать функцию @code{buffer-substring-with-bidi-context}
(@pxref{Bidirectional Display, buffer-substring-with-bidi-context}).

@defun filter-buffer-substring start end &optional delete
Функция фильтрует текст буфера между @var{start} и @var{end}, используя
функцию, заданную переменной @code{filter-buffer-substring-function}, и
возвращает результат.

Функция фильтра по умолчанию обращается к устаревшей ловушке оболочки
@code{filter-buffer-substring-functions} (подробные сведения об этой
устаревшей возможности смотреть в строке документации макроса
@code{with-wrapper-hook}) и информацию к устаревшей переменной
@code{buffer-substring-filters}.  Если обе из них - @code{nil}, возвращается
неизмененный текст из буфера, то есть то, что вернет
@code{buffer-substring}.

Если @var{delete} установленно в non-@code{nil}, функция удаляет текст между
@var{start} и @var{end} после его копирования, как
@code{delete-and-extract-region}.

Код на Лиспе должен использовать эту функцию вместо @code{buffer-substring},
@code{buffer-substring-no-properties} или @code{delete-and-extract-region}
при копировании в доступные пользователю структуры данных, такие как
kill-ring, X-буфер обмена и регистры.  Основные и второстепенные режимы
могут изменять @code{filter-buffer-substring-function} для изменения такого
текста, когда он копируется из буфера.
@end defun

@defvar filter-buffer-substring-function
Значение этой переменной - это функция, которую
@code{filter-buffer-substring} будет вызывать для выполнения фактической
работы.  Функция получает три аргумента, такие же, как у
@code{filter-buffer-substring}, которые должна обрабатывать в соответствии с
документацией этой функции.  Должен вернуться отфильтрованный текст (и, при
необходимости, удалиться исходный текст).
@end defvar

@noindent The following two variables are obsoleted by
@code{filter-buffer-substring-function}, но по-прежнему поддерживаются для
обратной совместимости.

@defvar filter-buffer-substring-functions
Эта устаревшая переменная представляет собой ловушку-оболочку, членами
которой должны быть функции, принимающие четыре аргумента: @var{fun},
@var{start}, @var{end} и @var{delete}.  @var{fun} - это функция, которая
принимает три аргумента (@var{start}, @var{end} и @var{delete}) и возвращает
строку.  В обоих случаях аргументы @var{start}, @var{end} и @var{delete}
такие же, как и аргументы @code{filter-buffer-substring}.

Первой функции-ловушке передается @var{fun}, что эквивалентно операции по
умолчанию @code{filter-buffer-substring}, то есть возвращается подстрока
буфера между @var{start} и @var{end} (обрабатывается любым
@code{buffer-substring-filters}) и при необходимости удаляется исходный
текст из буфера.  В большинстве случаев функция ловушки вызывает @var{fun}
один раз, а затем выполняет свою собственную обработку результата.
Следующая функция ловушки получает эквивалент @var{fun} и так далее.
Фактическое возвращаемое значение - это результат последовательного действия
всех функций ловушки.
@end defvar

@defvar buffer-substring-filters
Значение этой устаревшей переменной должно быть списком функций, которые
принимают один строковый аргумент и возвращают другую строку.  Функция
@code{filter-buffer-substring} по умолчанию передает подстроку буфера первой
функции в этом списке, а возвращаемое значение каждой функции передается
следующей функции.  Возвращаемое значение последней функции передается
@code{filter-buffer-substring-functions}.
@end defvar

@defun current-word &optional strict really-word
Функция возвращает символ (или слово) в точке или рядом с ней в виде строки.
Возвращаемое значение не содержит текстовых свойств.

Если необязательный аргумент @var{really-word} - non-@code{nil}, находится
слово; в противном случае находится символ (который включает как символы
слова, так и символы, составляющие символ).

Если необязательный аргумент @var{strict} - не-@code{nil}, то точка должна
находиться внутри или рядом с символом или словом --- если нет символа или
слова, функция возвращает @code{nil}.  В противном случае можно использовать
ближайший символ или слово в той же строке.
@end defun

@defun thing-at-point thing &optional no-properties
Вернуть @var{thing} вокруг точки или рядом с ней в виде строки.

Аргумент @var{thing} - это символ, определяющий вид синтаксической сущности.
Возможности включают @code{symbol}, @code{list}, @code{sexp}, @code{defun},
@code{filename}, @code{url}, @code{word}, @code{sentence},
@code{whitespace}, @code{line}, @code{page} и другие.

Когда необязательный аргумент @var{no-properties} равен не-@code{nil}, эта
функция удаляет текстовые свойства из возвращаемого значения.

@example
---------- Buffer: foo ----------
Gentlemen may cry ``Pea@point{}ce! Peace!,''
but there is no peace.
---------- Buffer: foo ----------

(thing-at-point 'word)
     @result{} "Peace"
(thing-at-point 'line)
     @result{} "Gentlemen may cry ``Peace! Peace!,''\n"
(thing-at-point 'whitespace)
     @result{} nil
@end example
@end defun

@node Comparing Text
@section Сравнение Текста
@cindex comparing buffer text

  Функция позволяет сравнивать части текста в буфере без предварительного
копирования их в строки.

@defun compare-buffer-substrings buffer1 start1 end1 buffer2 start2 end2
Функция позволяет сравнивать две подстроки одного и того же буфера или два
разных буфера.  Первые три аргумента определяют одну подстроку, задающую
буфер (или имя буфера) и две позиции в буфере.  Последние три аргумента
точно так же определяют другую подстроку.  Можно использовать @code{nil} для
@var{buffer1}, @var{buffer2} или оба для обозначения текущего буфера.

Значение отрицательное, если первая подстрока меньше, положительное, если
первая больше, и ноль, если они равны.  Абсолютное значение результата равно
единице плюс индекс первых различных символов в подстроках.

Функция игнорирует регистр при сравнении символов, если
@code{case-fold-search} равен не-@code{nil}.  Всегда игнорируются свойства
текста.

Предположим, есть текст @w{@samp{foobarbar haha!rara!}} в текущем буфере;
то в этом примере две подстроки - @samp{rbar } и @samp{rara!}.  Значение
равно 2, потому что первая подстрока больше второго символа.

@example
(compare-buffer-substrings nil 6 11 nil 16 21)
     @result{} 2
@end example
@end defun

@node Insertion
@section Вставка Текста
@cindex insertion of text
@cindex text insertion

@cindex insertion before point
@cindex before point, insertion
  @dfn{Вставка текста} означает добавление нового текста в буфер.
Вставленный текст находится в точке --- между символом перед точкой и
символом после точки.  Некоторые функции вставки оставляют точку перед
вставленным текстом, в то время как другие функции оставляют ее после.
Называется первая вставка @dfn{после точки}, а вторую - @dfn{перед точкой}.

  Вставка перемещает маркеры, расположенные в позициях после точки вставки,
так, чтобы они оставались с окружающим текстом (@pxref{Markers}).  Когда
маркер указывает на место вставки, вставка может перемещать или не
перемещать маркер, в зависимости от типа вставки маркера
(@pxref{Marker Insertion Types}).  Некоторые специальные функции, такие как
@code{insert-before-markers}, перемещают все такие маркеры так, чтобы они
указывали после вставленного текста, независимо от типа вставки маркеров.

  Функции вставки сигнализируют об ошибке, если текущий буфер доступен
только для чтения (@pxref{Read Only Buffers}) или если они вставляются в
текст (@pxref{Special Properties}), доступный только для чтения.

  Эти функции копируют текстовые символы из строк и буферов вместе с их
свойствами.  Вставленные символы имеют точно такие же свойства, как и
символы, из которых они были скопированы.  Напротив, символы, указанные как
отдельные аргументы, а не часть строки или буфера, наследуют свои текстовые
свойства от соседнего текста.

  Функции вставки преобразуют текст из однобайтового в многобайтовый, чтобы
вставить в многобайтовый буфер, и наоборот - если текст поступает из строки
или из буфера.  Однако они не преобразуют коды однобайтовых символов от 128
до 255 в многобайтовые символы, даже если текущий буфер является
многобайтовым.  @xref{Converting Representations}.

@defun insert &rest args
Функция вставляет строки и/или символы @var{args} в текущий буфер в точке,
перемещая точку вперед.  Другими словами, вставляется текст перед точкой.
Сигнализируется об ошибке, если все @var{args} не являются строками или
символами.  Возвращаемое значение @code{nil}.
@end defun

@defun insert-before-markers &rest args
Функция вставляет строки и/или символы @var{args} в текущий буфер в точке,
перемещая точку вперед.  Сигнализируется об ошибке, если все @var{args} не
являются строками или символами.  Возвращаемое значение @code{nil}.

Функция отличается от других функций вставки тем, что перемещает маркеры,
изначально указывающие на точку вставки, чтобы они указывали после
вставленного текста.  Если наложение начинается с точки вставки, вставленный
текст выходит за пределы наложения; если непустое наложение заканчивается в
точке вставки, вставленный текст попадает внутрь этого наложения.
@end defun

@deffn Command insert-char character &optional count inherit
Команда вставляет экземпляры @var{count} объекта @var{character} в текущий
буфер перед точкой.  Аргумент @var{count} должен быть целым числом, а
@var{character} должен быть символом.

При интерактивном вызове команда запрашивает @var{character}, используя его
имя в Юникоде или его кодовую точку.
@xref{Inserting Text,,, emacs, The GNU Emacs Manual}.

Функция не преобразует коды однобайтовых символов от 128 до 255 в
многобайтовые символы, даже если текущий буфер является многобайтовым.
@xref{Converting Representations}.

Если @var{inherit} равен не-@code{nil}, вставленные символы наследуют
свойства закрепленного текста от двух символов до и после точки вставки.
@xref{Sticky Properties}.
@end deffn

@defun insert-buffer-substring from-buffer-or-name &optional start end
Функция вставляет часть буфера @var{from-buffer-or-name} в текущий буфер
перед точкой.  Вставленный текст - это область между @var{start}
(включая) и @var{end} (исключая).  (По умолчанию эти аргументы относятся к
началу и концу доступной части этого буфера.)  Функция возвращает
@code{nil}.

В этом примере форма выполняется с буфером @samp{bar} в качестве текущего
буфера.  Предполагается, что буфер @samp{bar} изначально пуст.

@example
@group
---------- Buffer: foo ----------
We hold these truths to be self-evident, that all
---------- Buffer: foo ----------
@end group

@group
(insert-buffer-substring "foo" 1 20)
     @result{} nil

---------- Buffer: bar ----------
We hold these truth@point{}
---------- Buffer: bar ----------
@end group
@end example
@end defun

@defun insert-buffer-substring-no-properties from-buffer-or-name &optional start end
Это похоже на @code{insert-buffer-substring}, за исключением того, что
не копируется никаких текстовых свойств.
@end defun

  @xref{Sticky Properties}, для других функций вставки, которые наследуют
свойства текста от ближайшего текста в дополнение к его вставке.  Пробелы,
вставленные функциями отступа, также наследуют свойства текста.

@node Commands for Insertion
@section Команды Вставки на Уровне Пользователя

  В этом разделе описаны команды более высокого уровня для вставки текста,
команды, предназначенные в первую очередь для пользователя, но также
полезные и в программах Lisp.

@deffn Command insert-buffer from-buffer-or-name
Команда вставляет все доступное содержимое @var{from-buffer-or-name}
(которое должно существовать) в текущий буфер после точки.  Оставляет
отметку после вставленного текста.  Возвращаемое значение @code{nil}.
@end deffn

@deffn Command self-insert-command count
@cindex character insertion
@cindex self-insertion
Команда вставляет последний набранный символ; делает это @var{count} раз
перед точкой и возвращает @code{nil}.  С этой командой связано большинство
печатных символов.  В повседневном использовании @code{self-insert-command}
является наиболее часто вызываемой функцией в Emacs, но программы редко
используют ее, за исключением установки в ключевой карте.

В интерактивном вызове @var{count} - это числовой префиксный аргумент.

@c FIXME: Эта переменная устарела, так как 23.1.
Самовставка переводит введенный символ через
@code{translation-table-for-input}.  @xref{Translation of Characters}.

Команда вызывает @code{auto-fill-function} всякий раз, когда это
не-@code{nil}, а вставленный символ находится в таблице
@code{auto-fill-chars} (@pxref{Auto Filling}).

@c Перефразированы перекрестные ссылки для предотвращения переполнения
@c бокса.  --rjc 15mar92
Команда выполняет расширение аббревиатуры, если включен режим аббревиатуры и
у вставленного символа нет синтаксиса, составляющего слово.  (@xref{Abbrevs}
и @ref{Syntax Class Table}.)  Также отвечает за вызов
@code{blink-paren-function}, когда вставленный символ имеет синтаксис
закрывающих скобок (@pxref{Blinking}).

@vindex post-self-insert-hook
@vindex self-insert-uses-region-functions
Последнее, что делает эта команда, - запускает ловушку
@code{post-self-insert-hook}.  Можно использовать это, например, для
автоматического изменения отступов текста при его вводе.  Если какая-либо
функция в этой ловушке должна воздействовать на область
(@pxref{The Region}), нужна уверенность, что режим удаления выделения
(@pxref{Using Region, Delete Selection, , emacs, The GNU Emacs Manual}) не
удаляет область до вызова функций @code{post-self-insert-hook}.  Для этого
нужно добавить функцию, которая возвращает @code{nil} в
@code{self-insert-uses-region-functions}, специальной ловушки, которая
сообщает режиму удаления выделения, что не требуется удалять область.

Не пытайться заменить стандартное определение @code{self-insert-command}
своим собственным.  Цикл команд редактора обрабатывает эту функцию особым
образом.
@end deffn

@deffn Command newline &optional number-of-newlines
Команда вставляет символы новой строки в текущий буфер перед точкой.  Если
указан @var{number-of-newlines}, будет вставлено много символов новой
строки.

@cindex newline and Auto Fill mode
Функция вызывает @code{auto-fill-function}, если текущий номер столбца
больше, чем значение @code{fill-column}, а @var{number-of-newlines} -
@code{nil}.  Обычно @code{auto-fill-function} вставляет новую строку; таким
образом, общий результат в этом случае - вставить два символа новой строки в
разных местах: один в точке, а другой в начале строки.  @code{newline} не
заполняется автоматически, если @var{number-of-newlines} равен
не-@code{nil}.

Команда делает отступ до левого поля, если он не равен нулю.
@xref{Margins}.

Возвращаемое значение - @code{nil}.  В интерактивном вызове @var{count}
является аргументом числового префикса.
@end deffn

@defvar overwrite-mode
Переменная определяет, действует ли режим перезаписи.  Значение должно быть
@code{overwrite-mode-textual}, @code{overwrite-mode-binary} или @code{nil}.
@code{overwrite-mode-textual} определяет режим текстовой перезаписи
(обрабатывает символы новой строки и табуляции специально), а
@code{overwrite-mode-binary} определяет режим двоичной перезаписи
(обрабатывает символы новой строки и табуляции как любые другие символы).
@end defvar

@node Deletion
@section Удаление Текста
@cindex text deletion

@cindex deleting text vs killing
  Удаление означает удаление части текста в буфере без сохранения его в
списке уничтожений (@pxref{The Kill Ring}).  Удаленный текст не может быть
восстановлен, но может быть повторно вставлен с помощью механизма отмены
(@pxref{Undo}).  Некоторые функции удаления сохраняют текст в списке
уничтожений в некоторых особых случаях.

  Все функции удаления работают с текущим буфером.

@deffn Command erase-buffer
Aункция удаляет весь текст текущего буфера (@emph{не} только доступную
часть), оставляя его пустым.  Если буфер доступен только для чтения, это
сигнализирует об ошибке @code{buffer-read-only}; если часть текста в нем
предназначена только для чтения, это сигнализирует об ошибке
@code{text-read-only}.  В противном случае удаляется текст без запроса
подтверждения.  Возвращается @code{nil}.

Обычно удаление большого количества текста из буфера запрещает дальнейшее
автосохранение этого буфера, поскольку он уменьшился.  Однако
@code{erase-buffer} этого не делает, поскольку идея состоит в том, что
будущий текст на самом деле не связан с предыдущим текстом, и его размер не
следует сравнивать с размером предыдущего текста.
@end deffn

@deffn Command delete-region start end
Команда удаляет текст между позициями @var{start} и @var{end} в текущем
буфере и возвращает @code{nil}.  Если точка находилась внутри удаленной
области, ее значение после этого будет @var{start}.  В противном случае
точка перемещается вместе с окружающим текстом, как и маркеры.
@end deffn

@defun delete-and-extract-region start end
Функция удаляет текст между позициями @var{start} и @var{end} в текущем
буфере и возвращает строку, содержащую только что удаленный текст.

Если точка находилась внутри удаленной области, ее значение после этого
будет @var{start}.  В противном случае точка перемещается вместе с
окружающим текстом, как и маркеры.
@end defun

@deffn Command delete-char count &optional killp
Команда удаляет символы @var{count} непосредственно после точки или перед
точкой, если значение @var{count} отрицательное.  Если @var{killp} равен
не-@code{nil}, то удаленные символы сохраняются в списке уничтожений.

В интерактивном вызове @var{count} - это числовой префиксный аргумент, а
@var{killp} - это необработанный префиксный аргумент.  Следовательно, если
указан префиксный аргумент, текст сохраняется в списке уничтожений.  Если
аргумент префикса не указан, то один символ удаляется, но не сохраняется в
списке уничтожений.

Возвращаемое значение всегда @code{nil}.
@end deffn

@deffn Command delete-backward-char count &optional killp
@cindex deleting previous char
Команда удаляет символы @var{count} непосредственно перед точкой или после
точки, если значение @var{count} отрицательное.  Если @var{killp} равен
не-@code{nil}, то удаленные символы сохраняются в списке уничтожений.

В интерактивном вызове @var{count} - это числовой префиксный аргумент, а
@var{killp} - это необработанный префиксный аргумент.  Следовательно, если
указан префиксный аргумент, текст сохраняется в списке уничтожений.  Если
аргумент префикса не указан, то один символ удаляется, но не сохраняется в
списке уничтожений.

Возвращаемое значение всегда @code{nil}.
@end deffn

@deffn Command backward-delete-char-untabify count &optional killp
@cindex tab deletion
Команда удаляет символы @var{count} назад, заменяя табуляцию пробелами.
Когда следующим удаляемым символом является табуляция, сначала заменяется
надлежащим количеством пробелов для сохранения выравнивания, а затем один из
этих пробелов удаляется вместо табуляции.  Если @var{killp} равен
не-@code{nil}, то команда сохраняет удаленные символы в списке уничтожений.

Преобразование табуляции в пробелы происходит, только если @var{count}
положительно.  Если отрицательно, удаляются ровно @minus{}@var{count}
символов после точки.

В интерактивном вызове @var{count} - это числовой префиксный аргумент, а
@var{killp} - это необработанный префиксный аргумент.  Следовательно, если
указан префиксный аргумент, текст сохраняется в списке уничтожений.  Если
аргумент префикса не указан, то один символ удаляется, но не сохраняется в
списке уничтожений.

Возвращаемое значение всегда @code{nil}.
@end deffn

@defopt backward-delete-char-untabify-method
Опция определяет, как @code{backward-delete-char-untabify} должно
обрабатывать пробелы.  Возможные значения включают @code{untabify}, значение
по умолчанию, что означает преобразование табуляции во множество пробелов и
удаление одного; @code{hungry}, то есть удалить все табуляции и пробелы
перед точкой с помощью одной команды; @code{all} означает удалить все
табуляции, пробелы и символы новой строки перед точкой, а @code{nil}
означает, что ничего особенного не делать для пробельных символов.
@end defopt

@node User-Level Deletion
@section Команды Удаления Уровня Пользователя

  В этом разделе описаны команды более высокого уровня для удаления текста,
команды, предназначенные в первую очередь для пользователя, но также
полезные в программах на Lisp.

@deffn Command delete-horizontal-space &optional backward-only
@cindex deleting whitespace
Функция удаляет все пробелы и табуляции вокруг точки.
Возвращает @code{nil}.

Если @var{backward-only} равен не-@code{nil}, функция удаляет пробелы и
табуляции перед точкой, но не после точки.

В следующих примерах вызывается @code{delete-horizontal-space} четыре раза,
по одному в каждой строке, каждый раз ставится точка между вторым и третьим
символами в строке.

@example
@group
---------- Buffer: foo ----------
I @point{}thought
I @point{}     thought
We@point{} thought
Yo@point{}u thought
---------- Buffer: foo ----------
@end group

@group
(delete-horizontal-space)   ; @r{Четыре раза.}
     @result{} nil

---------- Buffer: foo ----------
Ithought
Ithought
Wethought
You thought
---------- Buffer: foo ----------
@end group
@end example
@end deffn

@deffn Command delete-indentation &optional join-following-p
Функция соединяет точку на предыдущей строке, удаляя любые пробелы в
соединении и в некоторых случаях заменяя их одним пробелом.  Если
@var{join-following-p} равен не-@code{nil}, вместо этого
@code{delete-indentation} присоединяет эту строку к следующей.  Функция
возвращает @code{nil}.

Если есть префикс заполнения, и вторая из соединяемых строк начинается с
префикса, то @code{delete-indentation} удаляет префикс заполнения перед
объединением строк.  @xref{Margins}.

В приведенном ниже примере точка находится в строке, начинающейся с
@samp{events}, и не имеет значения, есть ли в предыдущей строке завершающие
пробелы.

@smallexample
@group
---------- Buffer: foo ----------
When in the course of human
@point{}    events, it becomes necessary
---------- Buffer: foo ----------
@end group

(delete-indentation)
     @result{} nil

@group
---------- Buffer: foo ----------
When in the course of human@point{} events, it becomes necessary
---------- Buffer: foo ----------
@end group
@end smallexample

После соединения строк функция @code{fixup-whitespace} отвечает за решение,
оставлять ли место на стыке.
@end deffn

@deffn Command fixup-whitespace
Функция заменяет все горизонтальные пробелы вокруг точки либо одним
пробелом, либо оставляет без пробела, в зависимости от контекста.
Возвращает @code{nil}.

В начале или в конце строки подходящее количество пробелов убирается.
Перед символом с синтаксисом закрывающей круглой скобки, или после символа
с синтаксисом открытой круглой скобки или перед выражением с синтаксисом
префикса также убирается пробел.  В противном случае оставляется один
пробел.  @xref{Syntax Class Table}.

В приведенном ниже примере @code{fixup-whitespace} вызывается первый раз с
точкой перед словом @samp{spaces} в первой строке.  При втором вызове точка
находится сразу после @samp{(}.

@smallexample
@group
---------- Buffer: foo ----------
This has too many     @point{}spaces
This has too many spaces at the start of (@point{}   this list)
---------- Buffer: foo ----------
@end group

@group
(fixup-whitespace)
     @result{} nil
(fixup-whitespace)
     @result{} nil
@end group

@group
---------- Buffer: foo ----------
This has too many spaces
This has too many spaces at the start of (this list)
---------- Buffer: foo ----------
@end group
@end smallexample
@end deffn

@deffn Command just-one-space &optional n
@comment !!Исходный файл simple.el
Команда заменяет любые пробелы и табуляцию вокруг точки одним пробелом или
@var{n} пробелами, если указан @var{n}.  Возвращается @code{nil}.
@end deffn

@c Также существует интервал между циклами, но я не вижу, чтобы он был
@c полезен в программах Lisp, поэтому здесь он не упоминается.

@deffn Command delete-blank-lines
Функция удаляет пустые строки, окружающие точку.  Если точка находится в
пустой строке с одной или несколькими пустыми строками до или после нее, то
все, кроме одной строки, удаляются.  Если точка находится на изолированной
пустой строке, она удаляется.  Если точка находится на непустой строке,
команда удаляет все пустые строки, следующие сразу за ней.

Пустая строка определяется как строка, содержащая только табуляции и
пробелы.
@c и символ новой строки?

@code{delete-blank-lines} возвращает @code{nil}.
@end deffn

@deffn Command delete-trailing-whitespace &optional start end
Удалить завершающие пробелы в области, определенной @var{start} и @var{end}.

Команда удаляет пробельные символы после последнего непробельного символа в
каждой строке в регионе.

Если команда воздействует на весь буфер (т.е. если вызывается интерактивно с
неактивной меткой или вызывается из Lisp с помощью @var{end} @code{nil}),
она также удаляет все завершающие строки в конце буфера, если переменная
@code{delete-trailing-lines} имеет значение не-@code{nil}.
@end deffn

@node The Kill Ring
@section Кольцо Уничтожения
@cindex kill ring

  @dfn{Функции уничтожения} удаляют текст, как функции удаления, но
сохраняют его, чтобы пользователь мог повторно вставить его с помощью
@dfn{аннулирования}.  В названии большинства этих функций есть
@samp{kill-}.  Напротив, функции, имена которых начинаются с @samp{delete-},
обычно не сохраняют текст для восстановления (хотя их все еще можно
отменить); это функции удаления.

  Большинство команд уничтожения предназначены в первую очередь для
интерактивного использования и здесь не описываются.  Описываются функции,
предназначенные для использования при написании таких команд.  Можно
использовать эти функции для написания команд для уничтожения текста.  Когда
нужно удалить текст для внутренних целей в функции Lisp, обычно потребуется
использовать функции удаления, чтобы не нарушать содержимое кольца
уничтожения.  @xref{Deletion}.

  Уничтоженный текст сохраняется для последующего восстановления в
@dfn{кольце уничтожения}.  Это список, который содержит количество недавних
уничтожений, а не только последнее текстовое уничтожение.  Называется это
``кольцо'', потому что при восстановлении это рассматривается как элементы в
циклическом порядке.  Список хранится в переменной @code{kill-ring}, и с ним
можно работать с обычными функциями для списков; есть также
специализированные функции, описанные в этом разделе, которые обрабатывают
его как кольцо.

  Некоторые люди думают, что такое использование слова ``уничтожение''
неудачно, так как оно относится к операциям, которые, в частности,
@emph{не} уничтожают сущности.  Это резко контрастирует с обычной жизнью, в
которой уничтожение постоянно, а уничтоженные сущности не возвращаются к
жизни.  Поэтому были предложены другие метафоры.  Например, термин
``вырезанное кольцо'' имеет смысл для людей, которые в докомпьютерные
времена использовали ножницы и пасту, чтобы разрезать и переставлять
рукописи.  Однако изменить терминологию сейчас будет сложно.

@menu
* Kill Ring Concepts::     Как выглядит текст в списке уничтожений.
* Kill Functions::         Функции, уничтожающие текст.
* Yanking::                Как делается аннулирование.
* Yank Commands::          Команды, которые обращаются к списку уничтожений.
* Low-Level Kill Ring::    Функции и переменные для доступа к
                              кольцу уничтожения.
* Internals of Kill Ring:: Переменные, которые содержат данные
                              аннулирования.
@end menu

@node Kill Ring Concepts
@subsection Концепции Кольца Уничтожения

  Кольцо уничтожения записывает уничтоженный текст в виде строк в списке,
начиная с самого последнего.  Например, короткое кольцо уничтожений может
выглядеть так:

@example
("some text" "a different piece of text" "even older text")
@end example

@noindent
Когда список достигает длины @code{kill-ring-max} записей, добавление новой
записи автоматически удаляет последнюю запись.

  Когда команды уничтожения переплетаются с другими командами, каждая
команда уничтожения создает новую запись в списке уничтожений.  Несколько
последовательных команд уничтожения создают одну запись в кольце
уничтожения, которая будет извлечена как единое целое; вторая и последующие
последовательные команды уничтожения добавляют текст к записи, сделанной
первой.

  Для аннулирования одна запись в кольце уничтожения обозначается передней
частью кольца.  Некоторые команды аннулирования вращают кольцо, обозначая
другой элемент как передний.  Но это виртуальное вращение не меняет сам
список--- самая последняя запись всегда идет первой в списке.

@node Kill Functions
@subsection Функции Уничтожения

  @code{kill-region} - обычная подпрограмма для уничтожения текста.  Любая
команда, вызывающая эту функцию, является командой уничтожения (и, вероятно,
должна иметь в своем имени @samp{kill}).  @code{kill-region} помещает только
что уничтоженный текст в новый элемент в начале списка уничтожений или
добавляет его к самому последнему элементу.  Автоматически определяется (с
помощью @code{last-command}), была ли предыдущая команда командой kill, и,
если да, добавляется убитый текст к самой последней записи.

@cindex filtering killed text
  Команды, описанные ниже, могут фильтровать уничтоженный текст перед
сохранением его в списке уничтожений.  Они вызывают
@code{filter-buffer-substring} (@pxref{Buffer Contents}) для выполнения
фильтрации.  По умолчанию фильтрация отсутствует, но основные и
второстепенные режимы и функции перехватчики могут настраивать фильтрацию,
так что текст, сохраненный в списке уничтожений, отличается от того, что
было в буфере.

@deffn Command kill-region start end &optional region
Функция уничтожает фрагмент текста между @var{start} и @var{end}; но если
необязательный аргумент @var{region} - не-@code{nil}, игнорируются
@var{start} и @var{end} и вместо этого уничтожается текст в текущей области.
Текст удаляется, но сохраняется в списке уничтожений вместе с его свойствами
текста.  Возвращаемое значение всегда @code{nil}.

В интерактивном вызове @var{start} and @var{end} - это точка и метка, а
@var{region} - всегда не-@code{nil}, поэтому команда всегда уничтожает текст
в текущей области.

Если буфер или текст доступны только для чтения, @code{kill-region} точно
так же изменяет список уничтожений, а затем сигнализирует об ошибке без
изменения буфера.  Это удобно, потому что позволяет пользователю
использовать серию команд уничтожения для копирования текста из буфера
только для чтения в список уничтожения.
@end deffn

@defopt kill-read-only-ok
Если опция - не-@code{nil}, @code{kill-region} не сигнализирует об ошибке,
если буфер или текст доступны только для чтения.  Вместо этого просто
возвращается значение, обновляется список уничтожений, но не изменяется
буфер.
@end defopt

@deffn Command copy-region-as-kill start end &optional region
Функция сохраняет фрагмент текста между @var{start} и @var{end} в списке
уничтожений (включая свойства текста), но не удаляет текст из буфера.
Однако, если необязательный аргумент @var{region} равен не-@code{nil},
функция игнорирует @var{start} and @var{end} и вместо этого сохраняет
текущий регион.  Всегда возвращается @code{nil}.

В интерактивном вызове @var{start} and @var{end} - это точка и метка, а
@var{region} - всегда не-@code{nil}, поэтому команда всегда сохраняет текст
в текущей области.

Команда не устанавливает @code{this-command} в @code{kill-region}, поэтому
последующая команда kill не добавляется к той же записи кольца уничтожения.
@end deffn

@node Yanking
@subsection Восстановление

  Восстановление означает вставку текста из списка уничтожений, но не
вслепую.  Команда @code{yank} и связанные с ней команды используют
@code{insert-for-yank} для специальной обработки текста перед его вставкой.

@defun insert-for-yank string
Функция работает так же, как @code{insert}, за исключением того, что она
обрабатывает текст в @var{string} в соответствии со свойством текста
@code{yank-handler}, а также переменные @code{yank-handled-properties} и
@code{yank-excluded-properties} (смотреть ниже) перед вставкой результата в
текущий буфер.
@end defun

@defun insert-buffer-substring-as-yank buf &optional start end
Функция похожа на @code{insert-buffer-substring}, за исключением того, что
обрабатывает текст в соответствии с @code{yank-handled-properties} и
@code{yank-excluded-properties}.  (Не обрабатывает свойство
@code{yank-handler}, которое в любом случае обычно не встречается в тексте
буфера.)
@end defun

@c FIXME: Добавить индекс для yank-handler.
  Если поместить текстовое свойство @code{yank-handler} на всю строку или ее
часть, это изменит способ вставки строки @code{insert-for-yank}.  Если
разные части строки имеют разные значения @code{yank-handler} (сравнение
выполняется с @code{eq}), каждая подстрока обрабатывается отдельно.
Значение свойства должно быть списком от одного до четырех элементов в
следующем формате (где элементы после первого могут быть опущены):

@example
(@var{function} @var{param} @var{noexclude} @var{undo})
@end example

  Вот что делают элементы:

@table @var
@item function
Когда @var{function} равен не-@code{nil}, это вызывается вместо
@code{insert} для вставки строки с одним аргументом - строкой для вставки.

@item param
Если присутствует @var{param} и установлено в не-@code{nil}, это заменяет
@var{string} (или обрабатываемую подстроку @var{string}) как объект,
переданный в @var{function} (или @code{insert}).  Например, если
@var{function} установленно в @code{yank-rectangle}, @var{param} должен быть
списком строк, которые нужно вставить в виде прямоугольника.

@item noexclude
Если присутствует @var{noexclude} и установленно в не-@code{nil}, это
отключает нормальное действие @code{yank-handled-properties} и
@code{yank-excluded-properties} на вставленную строку.

@item undo
Если присутствует @var{undo} и установленно в не-@code{nil}, это функция,
которая будет вызываться @code{yank-pop} для отмены вставки текущего
объекта.  Вызывается с двумя аргументами: началом и концом текущего региона.
@var{function} может установить @code{yank-undo-function}, чтобы
переопределить значение @var{undo}.
@end table

@cindex yanking and text properties
@defopt yank-handled-properties
Переменная определяет специальные условия обработки свойств текста для
извлеченного текста.  Вступает в силу после того, как текст был вставлен
(обычно или через свойство @code{yank-handler}), но до того, как
@code{yank-excluded-properties} вступит в силу.

Значение должно быть списком элементов @code{(@var{prop} . @var{fun})}.
Каждый элемент этого ассоциативного списка обрабатывается по порядку.
Вставленный текст сканируется на предмет фрагментов текста, имеющих
текстовые свойства от @code{eq} до @var{prop}; для каждого такого растяжения
вызывается @var{fun} с тремя аргументами: значением свойства, а также
начальной и конечной позициями текста.
@end defopt

@defopt yank-excluded-properties
Значение этой переменной - это список свойств, которые нужно удалить из
вставленного текста.  Её значение по умолчанию содержит свойства, которые
могут привести к неприятным результатам, например, заставить текст
реагировать на мышь или указать привязки ключей.  Вступает в силу после
@code{yank-handled-properties}.
@end defopt


@node Yank Commands
@subsection Функции для Восстановления

  В этом разделе описаны высокоуровневые команды для восстановления, которые
предназначены в первую очередь для пользователя, но полезны также в
программах на Lisp.  Обе @code{yank} и @code{yank-pop} учитывают переменную
@code{yank-excluded-properties} и текстовое свойство @code{yank-handler}
(@pxref{Yanking}).

@deffn Command yank &optional arg
@cindex inserting killed text
Команда вставляет текст перед точкой в начале списка уничтожений.
Устанавливает метку в начале этого текста, используя @code{push-mark}
(@pxref{The Mark}), и ставит точку в конце.

Если @var{arg} - это список не-@code{nil} (который появляется в
интерактивном режиме, когда пользователь вводит @kbd{C-u} без цифр), то
@code{yank} вставляет текст, как описано выше, но ставит точку перед
извлеченным текстом и устанавливает метку после него.

Если @var{arg} - это число, то @code{yank} вставляет последний @var{arg}
уничтоженный текст - @var{arg} аргумента из списка кольца уничтожения,
циклически отсчитываемый спереди, который затем считается первым элементом
для этой цели.

@code{yank} не изменяет содержимое списка уничтожений, если только не
используется текст, предоставленный другой программой, и в этом случае
помещается этот текст в список уничтожений.  Однако, если @var{arg} - целое
число, отличное от единицы, это проворачивает кольцо уничтожения, чтобы
поместить извлеченную строку впереди.

@code{yank} возвращает @code{nil}.
@end deffn

@deffn Command yank-pop &optional arg
Команда заменяет только что извлеченную запись из списка уничтожений другой
записью из списка уничтожений.

Это разрешено только сразу после @code{yank} или другого @code{yank-pop}.  В
это время в регионе содержится текст, который был вставлен восстановлением.
@code{yank-pop} удаляет этот текст и вставляет на его место другой фрагмент
уничтоженного текста.  Не добавляется удаленный текст в список уничтожений,
поскольку он уже находится где-то в списке уничтожений.  Тем не менее,
проворачивается кольцо уничтожений, чтобы поместить недавно восстановленную
строку впереди.

Если @var{arg} равен @code{nil}, то текст замены - это предыдущий элемент
списка уничтожений.  Если @var{arg} является числовым, заменой является
предыдущее уничтожение @var{arg}.  Если @var{arg} отрицательно, заменой
является более недавнее уничтожение.

Последовательность уничтожений в кольце уничтожений повторяется так, что
после самого старого идет самое новое, а перед самого нового - самое старое.

Возвращаемое значение всегда @code{nil}.
@end deffn

@defvar yank-undo-function
Если эта переменная - не-@code{nil}, функция @code{yank-pop} использует ее
значение вместо @code{delete-region} для удаления текста, вставленного
предыдущей командой @code{yank} или @code{yank-pop}.  Значение должно быть
функцией двух аргументов, начала и конца текущей области.

Функция @code{insert-for-yank} автоматически устанавливает эту переменную в
соответствии с элементом @var{undo} текстового свойства @code{yank-handler},
если оно есть.
@end defvar

@node Low-Level Kill Ring
@subsection Кольцо Уничтожения Низкого Уровня

  Эти функции и переменные обеспечивают доступ к списку уничтожений на более
низком уровне, но по-прежнему удобны для использования в программах на Lisp,
потому что они заботятся о взаимодействии с выбором оконной системы
(@pxref{Window System Selections}).

@defun current-kill n &optional do-not-move
Функция @code{current-kill} поворачивает указатель восстановления, который
обозначает переднюю часть кольца уничтожений, на @var{n} мест (от новых
уничтожений к более старым) и возвращает текст в этом месте кольца.

Если необязательный второй аргумент @var{do-not-move} - не-@code{nil}, то
@code{current-kill} не изменяет указатель восстановления; просто
возвращается @var{n}-е уничтожение, считая от текущего указателя
восстановления.

Если @var{n} равен нулю, что указывает на запрос последнего уничтожения,
@code{current-kill} вызывает значение @code{interprogram-paste-function}
(задокументировано ниже) перед обращением к кольцу уничтожений.  Если это
значение является функцией и при ее вызове возвращается строка или список из
нескольких строк, @code{current-kill} помещает строки в список уничтожений и
возвращает первую строку.  Также устанавливает указатель восстановления так,
чтобы он указывал на запись аннулирования первой строки, возвращаемой
@code{interprogram-paste-function}, независимо от значения
@var{do-not-move}.  В противном случае @code{current-kill} не обрабатывает
нулевое значение для @var{n} специально: возвращает запись, на которую
указывает указатель восстановления, и не перемещает указатель
восстановления.
@end defun

@defun kill-new string &optional replace
Функция помещает текст @var{string} в список уничтожений и заставляет
указатель восстановления указывать на него.  При необходимости отбрасывает
самую старую запись.  Также вызывает значения
@code{interprogram-paste-function} (в зависимости от пользовательской опции
@code{save-interprogram-paste-before-kill}) и
@code{interprogram-cut-function} (смотреть ниже).

Если @var{replace} равен не-@code{nil}, то @code{kill-new} заменяет первый
элемент списка уничтожений на @var{string}, а не помещает @var{string} в
список уничтожений.
@end defun

@defun kill-append string before-p
Функция добавляет текст @var{string} к первой записи в списке уничтожений и
заставляет указатель восстановления указывать на комбинированную запись.
Обычно @var{string} идет в конце записи, но если @var{before-p} равен
не-@code{nil}, тогда идёт в начале.  Функция вызывает @code{kill-new} как
подпрограмму, вызывая тем самым вызов значений
@code{interprogram-cut-function} и, возможно,
@code{interprogram-paste-function} (смотреть ниже) по расширению.
@end defun

@defvar interprogram-paste-function
Переменная обеспечивает способ передачи уничтоженного текста из других
программ, когда используется оконная система.  Её значение должно быть
@code{nil} или функцией без аргументов.

Если значение является функцией, @code{current-kill} вызывает ее, чтобы
получить самое последнее уничтожение.  Если функция возвращает значение
не-@code{nil}, то это значение используется как последнее уничтожение.  Если
возвращается @code{nil}, то используется передняя часть кольца уничтожения.

Чтобы облегчить поддержку оконных систем, которые поддерживают множественный
выбор, эта функция также может возвращать список строк.  В этом случае
первая строка используется как самое последнее уничтожение, а все остальные
строки помещаются в список уничтожений для облегчения доступа с помощью
@code{yank-pop}.

Обычное использование этой функции - получить буфер обмена оконной системы
как последнее уничтожение, даже если выбор принадлежит другому приложению.
@xref{Window System Selections}.  Однако, если содержимое буфера обмена
поступает из текущего сеанса Emacs, эта функция должна вернуть @code{nil}.
@end defvar

@defvar interprogram-cut-function
Переменная обеспечивает способ передачи уничтоженного текста другим
программам, когда используется оконная система.  Её значение должно быть
@code{nil} или функцией одного обязательного аргумента.

Если значение является функцией, @code{kill-new} и @code{kill-append}
вызывает ее с новым первым элементом списка уничтожений в качестве
аргумента.

Обычно эта функция используется для помещения недавно убитого текста в буфер
обмена оконной системы.  @xref{Window System Selections}.
@end defvar

@node Internals of Kill Ring
@subsection Устройство Кольца Уничтожений

  Переменная @code{kill-ring} хранит содержимое списка уничтожений в виде
списка строк.  Последнее уничтожение всегда находится в начале списка.

  Переменная @code{kill-ring-yank-pointer} указывает на ссылку в списке
списка уничтожений, @sc{car} которого - текст, который нужно скопировать
следующим.  Говорится, что идентифицируется передняя часть кольца.
Перемещение @code{kill-ring-yank-pointer} на другую ссылку называется
@dfn{ротация кольца уничтожений}.  Называется список уничтожений ``кольцо'',
потому что функции, которые перемещают указатель восстановления,
перемещаются от конца списка к началу или наоборот.  Вращение кольца
уничтожения является виртуальным; это не меняет значение @code{kill-ring}.

  Обе переменные @code{kill-ring} и @code{kill-ring-yank-pointer} являются
переменными Lisp, значения которых обычно являются списками.  Слово
``pointer'' в имени @code{kill-ring-yank-pointer} указывает, что цель
переменной - идентифицировать один элемент списка для использования
следующей командой восстановления.

  Значение @code{kill-ring-yank-pointer} всегда равно @code{eq} к одной из
ссылок в списке уничтожения.  Идентифицируемый элемент - это @sc{car} этой
ссылки.  Команды уничтожения, которые изменяют список уничтожений, также
устанавливают для этой переменной значение @code{kill-ring}.  Эффект состоит
в том, чтобы провернуть кольцо так, чтобы только что уничтоженный текст
оказался впереди.

  Вот диаграмма, которая показывает переменную
@code{kill-ring-yank-pointer}, указывающую на вторую запись в списке
уничтожений
@code{("some text" "a different piece of text" "yet older text")}.

@example
@group
kill-ring                  ---- kill-ring-yank-pointer
  |                       |
  |                       v
  |     --- ---          --- ---      --- ---
   --> |   |   |------> |   |   |--> |   |   |--> nil
        --- ---          --- ---      --- ---
         |                |            |
         |                |            |
         |                |             -->"yet older text"
         |                |
         |                 --> "a different piece of text"
         |
          --> "some text"
@end group
@end example

@noindent
Такое положение вещей может произойти после @kbd{C-y} (@code{yank}), сразу
за которым следует @kbd{M-y} (@code{yank-pop}).

@defvar kill-ring
Переменная содержит список уничтоженных текстовых последовательностей,
которые были уничтожены первыми.
@end defvar

@defvar kill-ring-yank-pointer
Значение этой переменной указывает, какой элемент кольца уничтожения
находится в передней части кольца для восстановления.  Точнее, значение -
это хвост значения @code{kill-ring}, а его @sc{car} - это строка
уничтожения, которую @kbd{C-y} должен восстановить.
@end defvar

@defopt kill-ring-max
Значение этой переменной - максимальная длина, до которой может вырасти
список уничтожений, прежде чем элементы будут выброшены в конце.  Значение
по умолчанию для @code{kill-ring-max} - 60.
@end defopt

@node Undo
@section Отмена
@cindex redo

  Большинство буферов имеют @dfn{лист отмены}, который записывает все
изменения, внесенные в текст буфера, чтобы их можно было отменить.  (Буферы,
у которых его нет, обычно являются буферами специального назначения, для
которых Emacs предполагает, что отмена бесполезна.  В частности, для любого
буфера, имя которого начинается с пробела, запись отмены по умолчанию
отключена; смотреть @ref{Buffer Names}.)  Все примитивы, которые изменяют
текст в буфере, автоматически добавляют элементы в начало списка отмены,
который находится в переменной @code{buffer-undo-list}.

@defvar buffer-undo-list
Значение этой локальной переменной буфера является списком отмены текущего
буфера.  Значение @code{t} отключает запись информации отмены.
@end defvar

Вот типы элементов, которые может иметь список отмены:

@table @code
@item @var{position}
Этот тип элемента записывает предыдущее значение точки; отмена этого
элемента перемещает точку на @var{position}.  Обычное движение курсора не
вызывает никаких записей отмены, но операции удаления используют эти записи
для записи того места, где находилась точка перед командой.

@item (@var{beg} . @var{end})
Этот тип элемента указывает, как удалить вставленный текст.  После вставки
текст будет занимать в буфере диапазон @var{beg}--@var{end}.

@item (@var{text} . @var{position})
Этот тип элемента указывает, как повторно вставить удаленный текст.  Сам
удаленный текст представляет собой строку @var{text}.  Место для повторной
вставки - @code{(abs @var{position})}.  Если @var{position} положительно,
точка была в начале удаленного текста, в противном случае - в конце.  Сразу
после этого элемента следуют ноль или более элементов
(@var{marker} . @var{adjustment}).

@item (t . @var{time-flag})
Этот тип элемента указывает на то, что неизмененный буфер стал измененным.
@var{time-flag} формы
@code{(@var{sec-high} @var{sec-low} @var{microsec} @var{picosec})}
представляет время изменения посещенного файла с момента его предыдущего
посещения или сохранения, используя тот же формат, что и
@code{current-time}; смотреть @ref{Time of Day}.  Значение 0 для
@var{time-flag} означает, что буфер не соответствует ни одному файлу;
@minus{}1 означает, что ранее посещенный файл не существовал.
@code{primitive-undo} использует эти значения, чтобы определить, следует ли
снова пометить буфер как немодифицированный; это происходит только в том
случае, если статус файла совпадает со статусом @var{time-flag}

@item (nil @var{property} @var{value} @var{beg} . @var{end})
Этот тип элемента регистрирует изменение свойства текста.  Вот как можно
отменить изменение:

@example
(put-text-property @var{beg} @var{end} @var{property} @var{value})
@end example

@item (@var{marker} . @var{adjustment})
Этот тип элемента фиксирует тот факт, что маркер @var{marker} был перемещен
из-за удаления окружающего текста, и что он переместил позиции символа
@var{adjustment}.  Если положение маркера соответствует элементу
(@var{text} . @var{position}), предшествующему ему в списке отмены, то при
отмене этого элемента перемещаются символы @var{marker} @minus{}
@var{adjustment}.

@item (apply @var{funname} . @var{args})
Это расширяемый элемент отмены, который отменяется вызовом @var{funname} с
аргументами @var{args}.

@item (apply @var{delta} @var{beg} @var{end} @var{funname} . @var{args})
Это расширяемый элемент отмены, который записывает изменение, ограниченное
диапазоном от @var{beg} до @var{end}, что увеличивает размер буфера на
символы @var{delta}.  Это отменяется вызовом @var{funname} с аргументами
@var{args}.

Этот тип элемента позволяет отменить, ограниченную областью, чтобы
определить, относится ли элемент к этой области.

@item nil
Этот элемент является границей.  Элементы между двумя границами называются
@dfn{сменой группы}; обычно каждая группа изменений соответствует одной
клавиатурной команде, а команды отмены обычно отменяют всю группу как
единое целое.
@end table

@defun undo-boundary
Функция помещает граничный элемент в список отмены.  Команда отмены
останавливается на такой границе, а последующие команды отмены отменяются до
более ранней границы.  Функция возвращает @code{nil}.

Явный вызов этой функции полезен для разделения эффектов команды на более
чем одну единицу.  Например, @code{query-replace} вызывает
@code{undo-boundary} после каждой замены, чтобы пользователь мог отменить
отдельные замены одну за другой.

Однако в большинстве случаев эта функция вызывается автоматически в
подходящее время.
@end defun

@defun undo-auto-amalgamate
@cindex amalgamating commands, and undo
Командный цикл редактора автоматически вызывает @code{undo-boundary}
непосредственно перед выполнением каждой последовательности ключей, так что
каждая отмена обычно отменяет действие одной команды.  Несколько
исключительных команд @dfn{слияния}: эти команды обычно вызывают небольшие
изменения в буферах, поэтому с ними граница вставляется только каждую 20-ю
команду, что позволяет отменять изменения как группу.  По умолчанию команды
@code{self-insert-command}, производящие самовставляющиеся входные символы
(@pxref{Commands for Insertion}), и @code{delete-char}, удаляющие символы
(@pxref{Deletion}), объединяются.  Если команда влияет на содержимое
нескольких буферов, как это может случиться, например, когда функция в
@code{post-command-hook} влияет на буфер, отличный от @code{current-buffer},
тогда @code{undo-boundary} будет вызываться в каждом из затронутых буферов.
@end defun

@defvar undo-auto-current-boundary-timer
Некоторые буферы, такие как буферы процессов, могут изменяться, даже если
никакие команды не выполняются.  В этих случаях @code{undo-boundary} обычно
периодически вызывается таймером в этой переменной.  Установка этой
переменной в не-@code{nil} предотвращает такое поведение.
@end defvar

@defvar undo-in-progress
Обычно это переменная @code{nil}, но команды отмены связывают ее с @code{t}.
Это сделано для того, чтобы различные виды перехватчиков изменений могли
определить, когда они вызываются ради отмены.
@end defvar

@defun primitive-undo count list
Это основная функция для отмены элементов списка отмены.  Отменяет первых
@var{count} элементов @var{list}, возвращая остальную часть @var{list}.

@code{primitive-undo} добавляет элементы в список отмены буфера при
изменении буфера.  Команды отмены позволяют избежать путаницы, сохраняя
значение списка отмены в начале последовательности операций отмены.  Затем
операции отмены используют и обновляют сохраненное значение.  Новые
элементы, добавленные при отмене, не являются частью этого сохраненного
значения, поэтому они не мешают продолжению отмены.

Функция не связывает @code{undo-in-progress}.
@end defun

@node Maintaining Undo
@section Ведение Списков Отмены

  В этом разделе описывается, как включать и отключать информацию отмены для
данного буфера.  Также объясняется, как список отмены автоматически
усекается, чтобы не становиться слишком большим.

  Запись информации об отмене во вновь созданный буфер обычно разрешена для
начала; но если имя буфера начинается с пробела, отмена записи изначально
отключена.  Можно явно включить или отключить запись отмены с помощью
следующих двух функций или самостоятельно установив @code{buffer-undo-list}.

@deffn Command buffer-enable-undo &optional buffer-or-name
Команда включает запись информации об отмене для буфера
@var{buffer-or-name}, чтобы можно было отменить последующие изменения.  Если
аргумент не указан, используется текущий буфер.  Функция ничего не делает,
если в буфере уже включена отмена записи.  Возвращается @code{nil}.

В интерактивном вызове @var{buffer-or-name} - это текущий буфер.  Не
получится указать какой-либо другой буфер.
@end deffn

@deffn Command buffer-disable-undo &optional buffer-or-name
@cindex disabling undo
Функция отменяет список отмены @var{buffer-or-name} и отключает дальнейшую
запись информации отмены.  В результате больше невозможно отменить ни
предыдущие изменения, ни любые последующие изменения.  Если список отмены
@var{buffer-or-name} уже отключен, функция не действует.

В интерактивном вызове BUFFER-OR-NAME - это текущий буфер.  Не выйдет
указать какой-либо другой буфер.  Функция возвращает @code{nil}.
@end deffn

  По мере продолжения редактирования списки отмены становятся все длиннее и
длиннее.  Чтобы они не использовали все доступное пространство памяти,
сборка мусора обрезает их до установленных ограничений по размеру.  (Для
этой цели размер списка отмены измеряет cons-ячейки, составляющие список,
плюс строки удаленного текста.)  Диапазон допустимых размеров регулируется
тремя переменными: @code{undo-limit}, @code{undo-strong-limit} и
@code{undo-outer-limit}.  В этих переменных размер рассчитывается как
количество занятых байтов, которое включает как сохраненный текст, так и
другие данные.

@defopt undo-limit
Это мягкий предел допустимого размера списка отмены.  Группа изменений, в
которой превышен этот размер, остается последней.
@end defopt

@defopt undo-strong-limit
Это верхний предел допустимого размера списка отмены.  Группа изменений, в
которой этот размер превышен, отбрасывается сама (вместе со всеми более
ранними группами изменений).  Есть одно исключение: самая последняя группа
изменений отбрасывается, только если она превышает @code{undo-outer-limit}.
@end defopt

@defopt undo-outer-limit
Если во время сборки мусора информация об отмене для текущей команды
превышает этот предел, Emacs отбрасывает информацию и отображает
предупреждение.  Это последний предел для предотвращения переполнения
памяти.
@end defopt

@defopt undo-ask-before-discard
Если эта переменная - не-@code{nil}, когда информация об отмене превышает
@code{undo-outer-limit}, Emacs спрашивает в эхо-области, следует ли
отбросить информацию.  Значение по умолчанию - @code{nil}, что означает его
автоматическое удаление.

Эта опция в основном предназначена для отладки.  Сборка мусора запрещена,
пока задается вопрос, а это означает, что Emacs может вызвать утечку памяти,
если пользователь слишком долго ждет, прежде чем ответить на вопрос.
@end defopt

@node Filling
@section Заполнение
@cindex filling text

  @dfn{Заполнение} означает настройку длины строк (путем перемещения
разрывов строк) так, чтобы они были почти (но не больше) указанной
максимальной ширины.  Кроме того, строки могут иметь @dfn{оправданный}
формат, что означает вставку пробелов для точного выравнивания левого и/или
правого полей.  Ширина регулируется переменной @code{fill-column}.  Для
удобства чтения строки не должны быть длиннее 70 или около того столбцов.

  Можно использовать режим Auto Fill (@pxref{Auto Filling}) для
автоматического заполнения текста по мере его вставки, но изменения в
существующем тексте могут привести к его неправильному заполнению.  Затем
потребуется заполнить текст явно.

  Большинство команд в этом разделе возвращают значения, которые не имеют
смысла.  Все функции, выполняющие заполнение, принимают во внимание текущее
левое поле, текущее правое поле и текущий стиль выравнивания
(@pxref{Margins}).  Если текущий стиль выравнивания - @code{none}, функции
заполнения фактически ничего не делают.

  Некоторые функции заполнения имеют аргумент @var{justify}.  Если устанолен
в не-@code{nil}, требуется какое-то обоснование.  Это может быть
@code{left}, @code{right}, @code{full}, или @code{center}, чтобы запросить
конкретный стиль обоснования.  Если аргумент установлен в @code{t}, это
означает, что для этой части текста используется текущий стиль выравнивания
(смотреть @code{current-justification}, ниже).  Любое другое значение
рассматривается как @code{full}.

  Когда вызываются функции заполнения в интерактивном режиме, использование
префиксного аргумента подразумевает значение @code{full} для @var{justify}.

@deffn Command fill-paragraph &optional justify region
Команда заполняет абзац в точке или после нее.  Если @var{justify} равен
не-@code{nil}, каждая строка также выравнивается.  Используются обычные
команды перемещения абзаца для поиска границ абзаца.
@xref{Paragraphs,,, emacs, The GNU Emacs Manual}.

Если @var{region} равен не-@code{nil}, и если включен режим Transient Mark
с активной меткой, команда вызывает @code{fill-region} для заполнения всех
абзацев в области вместо заполнения только текущего абзаца.  Когда команда
вызывается в интерактивном режиме, @var{region} становится @code{t}.
@end deffn

@deffn Command fill-region start end &optional justify nosqueeze to-eop
Команда заполняет каждый абзац в области от @var{start} до @var{end}.  Это
также оправдывает, если @var{justify} равен не-@code{nil}.

Если @var{nosqueeze} равен не-@code{nil}, это означает, что пробелы, кроме
разрывов строк, должны оставаться нетронутыми.  Если @var{to-eop} -
не-@code{nil}, это означает, что нужно продолжать заполнение до конца абзаца
--- или до следующего жесткого перехода на новую строку, если
@code{use-hard-newlines} включен (смотреть ниже).

Переменная @code{paragraph-separate} определяет, как различать абзацы.
@xref{Standard Regexps}.
@end deffn

@deffn Command fill-individual-paragraphs start end &optional justify citation-regexp
Эта команда заполняет каждый абзац в области в соответствии с его
индивидуальным префиксом заливки.  Таким образом, если строки абзаца имеют
отступ с пробелами, заполненный абзац останется с таким же отступом.

Первые два аргумента @var{start} и @var{end} - это начало и конец области
для заполнения.  Третий и четвертый аргументы @var{justify} и
@var{citation-regexp} необязательны.  Если @var{justify} установлен в
не-@code{nil}, абзацы выравниваются и заполняются.  Если
@var{citation-regexp} - не-@code{nil}, это означает, что функция работает с
почтовым сообщением и, следовательно, не должна заполнять строки заголовка.
Если @var{citation-regexp} - строка, она используется как регулярное
выражение; если совпадает с началом строки, эта строка рассматривается как
маркер цитирования.

@c FIXME:"Этот режим" сбивает с толку. Это не основной/второстепенный режим.
Обычно @code{fill-individual-paragraphs} рассматривает каждое изменение
отступа как начало нового абзаца.  Если
@code{fill-individual-varying-indent} равен не-@code{nil}, то абзацы
разделяются только линиями-разделителями.  Этот режим может обрабатывать
абзацы с дополнительным отступом в первой строке.
@end deffn

@defopt fill-individual-varying-indent
Переменная изменяет действие @code{fill-individual-paragraphs}, как описано
выше.
@end defopt

@deffn Command fill-region-as-paragraph start end &optional justify nosqueeze squeeze-after
Команда рассматривает область текста как один абзац и заполняет его.  Если
область состояла из множества абзацев, пустые строки между абзацами
удаляются.  Функция оправдывает, как и заливку, когда @var{justify} равно
не-@code{nil}.

Если @var{nosqueeze} равен не-@code{nil}, это означает, что пробелы, кроме
разрывов строк, должны оставаться нетронутыми.  Если @var{squeeze-after}
равен не-@code{nil}, указывается позиция в регионе и означает, что не
следует канонизировать пробелы перед этой позицией.

В режиме адаптивной заливки эта команда вызывает @code{fill-context-prefix}
для выбора префикса заливки по умолчанию.  @xref{Adaptive Fill}.
@end deffn

@deffn Command justify-current-line &optional how eop nosqueeze
Команда вставляет пробелы между словами текущей строки, так что строка
заканчивается точно на @code{fill-column}.  Возвращается @code{nil}.

Аргумент @var{how}, если не-@code{nil} явно указывает стиль выравнивания.
Это может быть @code{left}, @code{right}, @code{full}, @code{center} или
@code{none}.  Если это @code{t}, это означает, что нужно следовать
указанному стилю выравнивания (смотреть @code{current-justification}, ниже).
@code{nil} означает полное обоснование.

Если @var{eop} равен не-@code{nil}, это означает, что выравнивание
выполняется только по левому краю, если @code{current-justification}
указывает полное выравнивание.  Используется для последней строки абзаца;
даже если абзац полностью выровнен по ширине, последней строки быть не
должно.

Если @var{nosqueeze} равен не-@code{nil}, это означает, что внутренние
пробелы не меняются.
@end deffn

@defopt default-justification
Значение переменной определяет стиль выравнивания текста, который не задает
стиль со свойством текста.  Возможные значения: @code{left}, @code{right},
@code{full}, @code{center} или @code{none}.  Значение по умолчанию -
@code{left}.
@end defopt

@defun current-justification
Функция возвращает правильный стиль выравнивания, используемый для
заполнения текста вокруг точки.

Возвращается значение текстового свойства @code{justification} в точке или
переменную @code{default-justification}, если такого текстового свойства
нет.  Однако возвращается @code{nil}, а не @code{none}, что означает
``не оправдывать''.
@end defun

@defopt sentence-end-double-space
@anchor{Definition of sentence-end-double-space}
Если переменная - не-@code{nil}, точка, за которой следует только один
пробел, не считается концом предложения, а функции заполнения избегают
разрыва строки в таком месте.
@end defopt

@defopt sentence-end-without-period
Если переменная - не-@code{nil}, предложение может заканчиваться без точки.
Это используется для таких языков, как тайский, где предложения
заканчиваются двойным пробелом, но без точки.
@end defopt

@defopt sentence-end-without-space
Если переменная - не-@code{nil}, это должна быть строка символов, которая
может заканчивать предложение без следующих пробелов.
@end defopt

@defopt fill-separate-heterogeneous-words-with-space
Если переменная - не-@code{nil}, два слова разного типа (например,
английское и CJK) будут разделены пробелом при объединении одного, которое
находится в конце строки, и другого, которое находится в начале следующей
строки для заполнения.
@end defopt

@defvar fill-paragraph-function
Переменная позволяет переопределить заполнение абзацев.  Если её значение -
не-@code{nil}, @code{fill-paragraph} вызывает эту функцию для выполнения
работы.  Если функция возвращает значение не-@code{nil},
@code{fill-paragraph} предполагает, что работа выполнена, и немедленно
возвращается это значение.

Обычно функция используется для заполнения комментариев в режимах языка
программирования.  Если функции необходимо заполнить абзац обычным способом,
это можно сделать следующим образом:

@example
(let ((fill-paragraph-function nil))
  (fill-paragraph arg))
@end example
@end defvar

@defvar fill-forward-paragraph-function
Переменная позволяет переопределить способ перехода функций заполнения,
таких как @code{fill-region} и @code{fill-paragraph}, к следующему абзацу.
Её значением должна быть функция, которая вызывается с одним аргументом
@var{n}, количеством абзацев, которые нужно переместить, и должна возвращать
разницу между @var{n} и количеством фактически перемещенных абзацев.
Значение по умолчанию для этой переменной - @code{forward-paragraph}.
@xref{Paragraphs,,, emacs, GNU Emacs Руководство}.
@end defvar

@defvar use-hard-newlines
Если переменная - не-@code{nil}, функции заполнения не удаляют символы новой
строки, имеющие текстовое свойство @code{hard}.  Эти жесткие символы новой
строки действуют как разделители абзацев.
@xref{Hard and Soft Newlines,, Hard and Soft Newlines, emacs, GNU Emacs Руководство}.
@end defvar

@node Margins
@section Поля для Заливки
@cindex margins, filling

@defopt fill-prefix
Эта локальная в буфере переменная, если не-@code{nil}, определяет строку
текста, которая появляется в начале обычных текстовых строк и должна
игнорироваться при их заполнении.  Любая строка, которая не начинается с
префикса заполнения, считается началом абзаца; то же самое можно сказать о
любой строке, которая начинается с префикса заполнения, за которым следует
дополнительный пробел.  Строки, начинающиеся с префикса заполнения, но без
дополнительных пробелов, являются обычными текстовыми строками, которые
можно заполнять вместе.  Результирующие закрашенные линии также начинаются с
префикса заливки.

Префикс заполнения следует за пробелом левого поля, если таковой имеется.
@end defopt

@defopt fill-column
Локальная в буфере переменная определяет максимальную ширину заполненных
линий.  Его значение должно быть целым числом, которое представляет собой
количество столбцов.  Переменная влияет на все команды заливки, выравнивания
и центрирования, включая режим Auto Fill (@pxref{Auto Filling}).

На практике, если пишется текст для чтения другими людьми, следует
установить @code{fill-column} не более 70.  В противном случае строка будет
слишком длинной, чтобы люди могли читать с комфортом, и это может сделать
текст неуклюжим.

Значение по умолчанию для @code{fill-column} - 70.
@end defopt

@deffn Command set-left-margin from to margin
Это устанавливает свойство @code{left-margin} текста от @var{from} до
@var{to} в значение @var{margin}.  Если включен режим Auto Fill, эта команда
также заполняет область, чтобы она соответствовала новому полю.
@end deffn

@deffn Command set-right-margin from to margin
Это устанавливает свойство @code{right-margin} текста от @var{from} до
@var{to} в значение @var{margin}.  Если включен режим Auto Fill, эта команда
также заполняет область, чтобы она соответствовала новому полю.
@end deffn

@defun current-left-margin
Функция возвращает правильное значение левого поля, используемое для
заполнения текста вокруг точки.  Значение представляет собой сумму свойства
@code{left-margin} символа в начале текущей строки (или нуля, если его нет)
и значения переменной @code{left-margin}.
@end defun

@defun current-fill-column
Функция возвращает правильное значение столбца заполнения, используемое для
заполнения текста вокруг точки.  Значение - это значение переменной
@code{fill-column} за вычетом значения свойства @code{right-margin} символа
после точки.
@end defun

@deffn Command move-to-left-margin &optional n force
Функция перемещает точку к левому краю текущей строки.  Перемещаемый столбец
определяется вызовом функции @code{current-left-margin}.  Если аргумент
@var{n} - не-@code{nil}, @code{move-to-left-margin} сначала перемещает
вперед строки на @var{n}@minus{}1.

Если @var{force} равен не-@code{nil}, это говорит о том, что нужно исправить
отступ строки, если он не соответствует значению левого поля.
@end deffn

@defun delete-to-left-margin &optional from to
Функция удаляет отступ левого края текста между @var{from} и @var{to}.
Величина удаляемого отступа определяется вызовом @code{current-left-margin}.
Ни в коем случае эта функция не удаляет непробельные символы.  Если
@var{from} и @var{to} опущены, по умолчанию используется весь буфер.
@end defun

@defun indent-to-left-margin
Функция регулирует отступ в начале текущей строки до значения, указанного
переменной @code{left-margin}.  (Это может включать в себя вставку или
удаление пробелов.)  Функция является значением @code{indent-line-function}
в режиме текста с отступом от абзаца.
@end defun

@defopt left-margin
Переменная определяет базовый столбец левого поля.  В основном режиме
@key{RET} отступает от этого столбца.  Переменная автоматически становится
локальной в буфере, если она установлена любым способом.
@end defopt

@defopt fill-nobreak-predicate
Переменная дает основным режимам возможность указать, чтобы строка не
разрывалась в определенных местах.  Её значением должен быть список функций.
Каждый раз, когда при заполнении рассматривается разрыв строки в
определенном месте в буфере, вызывается каждая из этих функций без
аргументов и с точкой, расположенной в этом месте.  Если какая-либо из
функций вернет не-@code{nil}, то строка там не разорвется.
@end defopt

@node Adaptive Fill
@section Адаптивный Режим Заливки
@c @cindex Did you mean: Adaptive Fill mode of 0 is adjacent.
Режим адаптивной заливки "adaptive-fill-mode" находится рядом.

  Когда @dfn{Adaptive Fill Mode} включен, Emacs автоматически определяет
префикс заполнения по тексту в каждом заполняемом абзаце, а не по заранее
заданному значению.  Во время заполнения этот префикс заполнения вставляется
в начало второй и последующих строк абзаца, как описано в @ref{Filling} и
@ref{Auto Filling}.

@defopt adaptive-fill-mode
Режим адаптивного заполнения включается, если эта переменная имеет значение
не-@code{nil}.  По умолчанию установлена в @code{t}.
@end defopt

@defun fill-context-prefix from to
Функция реализует суть режима адаптивной заливки; он выбирает префикс
заполнения на основе текста между @var{from} и @var{to}, обычно это начало и
конец абзаца.  Это делается путем просмотра первых двух строк абзаца на
основе переменных, описанных ниже.
@c Необязательный аргумент first-line-regexp не задокументирован,
@c потому что он существует для внутренних целей и может быть исключен
@c в будущем.

Обычно функция возвращает префикс заполнения, строку.  Однако перед этим
функция выполняет окончательную проверку (отдельно не упоминается ниже),
того что строка, начинающаяся с этого префикса, не будет выглядеть как
начало абзаца.  В этом случае функция сигнализирует об аномалии, вместо
этого возвращая @code{nil}.

Подробно @code{fill-context-prefix} делает это:

@enumerate
@item
Берёт кандидата на префикс заполнения из первой строки - сначала пробует
функцию из @code{adaptive-fill-function} (если есть), затем регулярное
выражение @code{adaptive-fill-regexp} (смотреть ниже).  Первый результат
не-@code{nil} из них или пустая строка, если они оба @code{nil}, становится
кандидатом на первую строку.
@item
Если в абзаце пока только одна строка, функция проверяет действительность
только что найденного кандидата на префикс.  Затем функция возвращает
кандидата, если он действителен, или строку пробелов в противном случае.
(смотреть описание @code{adaptive-fill-first-line-regexp} ниже).
@item
Когда в абзаце уже есть две строки, функция затем ищет кандидата на префикс
во второй строке, точно так же, как и для первой строки.  Если не находит,
возвращается @code{nil}.
@item
Теперь функция эвристически сравнивает два префикса-кандидата: если
непробельные символы в кандидате на строку 2 встречаются в том же порядке в
кандидате на строку 1, функция возвращает кандидата на строку 2.  В
противном случае он возвращает самую большую начальную подстроку, которая
является общей для обоих кандидатов (которая может быть пустой строкой).
@end enumerate
@end defun

@defopt adaptive-fill-regexp
Режим адаптивной заливки сопоставляет это регулярное выражение с текстом,
начинающимся после левого пробела (если есть) в строке; символы, которым он
соответствует, являются кандидатом этой строки на префикс заполнения.

Значение по умолчанию совпадает с пробелами с некоторыми перемешанными
знаками пунктуации.
@end defopt

@defopt adaptive-fill-first-line-regexp
Используемое только в однострочных абзацах, это регулярное выражение
действует как дополнительная проверка допустимости одного доступного
префикса заполнения кандидата: кандидат должен соответствовать этому
регулярному выражению или соответствовать @code{comment-start-skip}.  В
противном случае @code{fill-context-prefix} заменяет кандидата строкой
пробелов той же ширины, что и он.


Значение по умолчанию для этой переменной - @w{@code{"\\`[ \t]*\\'"}}, что
соответствует только строке пробелов.  Эффект от этого значения по умолчанию
состоит в том, что префиксы заполнения в однострочных абзацах всегда должны
быть чистыми пробелами.
@end defopt

@defopt adaptive-fill-function
Можно указать более сложные способы автоматического выбора префикса заливки,
установив эту переменную в функцию.  Функция вызывается с точкой после
левого края (если есть) строки, и она должна сохранять точку.  Должна
возвращать либо префикс заполнения этой строки, либо @code{nil}, что
означает, что не вышло определить префикс.
@end defopt

@node Auto Filling
@section Автозаполнение
@cindex filling, automatic
@cindex Auto Fill mode

Режим автозаполнения - это второстепенный режим, при котором строки
заполняются автоматически при вставке текста.
@xref{Auto Fill,,, emacs, Руководство GNU Emacs}.  В этом разделе описаны
некоторые переменные, используемые в режиме автозаполнения.  Описание
функций, которые можно вызывать явно для заполнения и выравнивания
существующего текста, смотреть @ref{Filling}.

  Режим автоматического заполнения также включает функции, которые изменяют
поля и стиль выравнивания для заполнения частей текста.  @xref{Margins}.

@defvar auto-fill-function
Значение этой локальной переменной в буфере должно быть функцией (без
аргументов), которая будет вызываться после самостоятельной вставки символа
из таблицы @code{auto-fill-chars}, смотреть ниже.  Это может быть
@code{nil}, в этом случае ничего собственно не делается.

Значение @code{auto-fill-function} равно @code{do-auto-fill}, когда включен
режим Auto Fill.  Это функция, единственная цель которой - реализовать
обычную стратегию разрыва строки.
@end defvar

@defvar normal-auto-fill-function
Переменная определяет функцию, которая будет использоваться для
@code{auto-fill-function}, если и когда включено Автозаполнение.  Основные
режимы могут устанавливать для этой переменной локальные значения буфера,
чтобы изменить работу автозаполнения.
@end defvar

@defvar auto-fill-chars
Таблица символов, которая вызывает @code{auto-fill-function} при
самостоятельной вставке --- пробел и новая строка в большинстве языковых
средах.  У них в таблице есть запись @code{t}.
@end defvar

@defopt comment-auto-fill-only-comments
Переменная, если не-@code{nil}, означает автоматическое заполнение строк
только в комментариях.  Точнее, это означает, что если синтаксис комментария
был определен для текущего буфера, то самовставка символа вне комментария не
вызовет @code{auto-fill-function}.
@end defopt


@node Sorting
@section Сортировка Текста
@cindex sorting text

  Все функции сортировки, описанные в этом разделе, переупорядочивают текст
в буфере.  В этом отличие от функции @code{sort}, которая меняет порядок
элементов списка (@pxref{Rearrangement}).  Значения, возвращаемые этими
функциями, не имеют смысла.

@defun sort-subr reverse nextrecfun endrecfun &optional startkeyfun endkeyfun predicate
Функция представляет собой обычную процедуру сортировки текста, которая
разделяет буфер на записи, а затем сортирует их.  Большинство команд в этом
разделе используют эту функцию.

Чтобы понять, как работает @code{sort-subr}, рассмотреть всю доступную часть
буфера как разделенную на непересекающиеся части, называемые
@dfn{сортировочные записи}.  Записи могут быть или не быть смежными, но они
не должны перекрываться.  Часть каждой записи сортировки (возможно, вся она)
обозначается как ключ сортировки.  При сортировке записи упорядочиваются по
их ключам сортировки.

Обычно записи располагаются в порядке возрастания ключа сортировки.  Если
первым аргументом функции @code{sort-subr}, @var{reverse}, является
не-@code{nil}, записи сортировки меняются в порядке убывания ключа
сортировки.

Следующие четыре аргумента @code{sort-subr} - это функции, которые
вызываются для перемещения точки по записи сортировки.  Они вызываются много
раз изнутри @code{sort-subr}.

@enumerate
@item
@var{nextrecfun} вызывается с точкой в конце записи.  Функция перемещает
точку в начало следующей записи.  Предполагается, что первая запись
начинается с позиции точки при вызове @code{sort-subr}.  Поэтому перед
вызовом @code{sort-subr} обычно следует переместить точку в начало буфера.

Функция может указать, что записей сортировки больше нет, оставив точку в
конце буфера.

@item
@var{endrecfun} вызывается с точкой внутри записи.  Перемещает точку в конец
записи.

@item
@var{startkeyfun} вызывается для перемещения точки из начала записи в начало
ключа сортировки.  Этот аргумент не является обязательным; если он опущен,
вся запись является ключом сортировки.  Если задано, функция должна либо
вернуть значение не-@code{nil}, которое будет использоваться в качестве
ключа сортировки, либо вернуть @code{nil}, чтобы указать, что ключ
сортировки находится в буфере, начиная с точки.  В последнем случае
вызывается @var{endkeyfun}, чтобы найти конец ключа сортировки.

@item
@var{endkeyfun} вызывается для перемещения точки из начала ключа сортировки
в конец ключа сортировки.  Это необязательный аргумент.  Если
@var{startkeyfun} возвращает @code{nil} и этот аргумент опущен (или
@code{nil}), то ключ сортировки распространяется до конца записи.  Нет
необходимости в @var{endkeyfun}, если @var{startkeyfun} возвращает значение
не-@code{nil}.
@end enumerate

Аргумент @var{predicate} - это функция, используемая для сравнения ключей.
Если ключи - числа, по умолчанию используется @code{<}; в противном случае
по умолчанию используется @code{string<}.

В качестве примера @code{sort-subr}, вот полное определение функции для
@code{sort-lines}:

@example
@group
;; @r{Обратить внимание, что первые две строки строки документа}
;; @r{ фактически являются одной строкой при просмотре пользователем.}
(defun sort-lines (reverse beg end)
  "Сортировать строки в регионе по алфавиту;\
 аргумент означает порядок убывания.
Вызывается из программы, есть три аргумента:
@end group
@group
REVERSE (не-nil означает обратный порядок),\
 BEG и END (регион для сортировки).
Переменная `sort-fold-case' определяет,\
влияет ли алфавитный регистр на порядок сортировки."
@end group
@group
  (interactive "P\nr")
  (save-excursion
    (save-restriction
      (narrow-to-region beg end)
      (goto-char (point-min))
      (let ((inhibit-field-text-motion t))
        (sort-subr reverse 'forward-line 'end-of-line)))))
@end group
@end example

Здесь @code{forward-line} перемещает точку в начало следующей записи, а
@code{end-of-line} перемещает точку в конец записи.  Не передаются аргументы
@var{startkeyfun} и @var{endkeyfun}, потому что вся запись используется как
ключ сортировки.

Функция очень похожа на @code{sort-paragraphs}, за исключением того, что ее
вызов @code{sort-subr} выглядит так:

@example
@group
(sort-subr reverse
           (function
            (lambda ()
              (while (and (not (eobp))
                          (looking-at paragraph-separate))
                (forward-line 1))))
           'forward-paragraph)
@end group
@end example

Маркеры, указывающие на любые записи сортировки, остаются без полезной
позиции после возврата @code{sort-subr}.
@end defun

@defopt sort-fold-case
Если эта переменная - не-@code{nil}, @code{sort-subr} и другие функции
сортировки буфера игнорируют регистр при сравнении строк.
@end defopt

@deffn Command sort-regexp-fields reverse record-regexp key-regexp start end
Команда сортирует область между @var{start} и @var{end} в алфавитном
порядке, как указано в @var{record-regexp} и @var{key-regexp}.  Если
@var{reverse} - отрицательное целое число, сортировка выполняется в обратном
порядке.

Алфавитная сортировка означает, что два ключа сортировки сравниваются,
сравнивая первые символы каждого, вторые символы каждого и так далее.  Если
обнаружено несоответствие, это означает, что ключи сортировки неравны; ключ
сортировки, символ которого меньше в точке первого несовпадения, является
меньшим ключом сортировки.  Отдельные символы сравниваются в соответствии с
их числовыми кодами символов в наборе символов Emacs.

Значение аргумента @var{record-regexp} указывает, как разделить буфер на
записи сортировки.  В конце каждой записи выполняется поиск этого
регулярного выражения, и соответствующий ему текст принимается в качестве
следующей записи.  Например, регулярное выражение @samp{^.+$}, которое
соответствует строкам с хотя бы одним символом помимо новой строки,
превратит каждую такую строку в запись сортировки.
@xref{Regular Expressions}, для описания синтаксиса и значения регулярных
выражений.

Значение аргумента @var{key-regexp} указывает, какая часть каждой записи является ключом сортировки.  @var{key-regexp} может соответствовать всей записи
или только ее части.  В последнем случае остальная часть записи не влияет на
порядок сортировки записей, но переносится, когда запись перемещается в
новую позицию.

Аргумент @var{key-regexp} может относиться к тексту, соответствующему
подвыражению @var{record-regexp}, или может быть самостоятельным регулярным
выражением.

Если @var{key-regexp} равно:

@table @asis 
@item @samp{\@var{digit}}
тогда текст, соответствующий группировке скобок @var{digit} @samp{\(...\)}
в @var{record-regexp}, является ключом сортировки.

@item @samp{\&}
тогда вся запись является ключом сортировки.

@item a regular expression
затем @code{sort-regexp-fields} ищет совпадение с регулярным выражением в
записи.  Если такое совпадение найдено, это ключ сортировки.  Если в записи
нет совпадения для @var{key-regexp}, эта запись игнорируется, что означает,
что ее положение в буфере не изменяется.  (Другие записи могут перемещаться
по нему.)
@end table

Например, если планируется сортировать все строки в регионе по первому слову
в каждой строке, начинающейся с буквы @samp{f}, потребуется установить
@var{record-regexp} на @samp{^.*$} и установить @var{key-regexp} в
@samp{\<f\w*\>}.  Результирующее выражение выглядит так:

@example
@group
(sort-regexp-fields nil "^.*$" "\\<f\\w*\\>"
                    (region-beginning)
                    (region-end))
@end group
@end example

Если вызывается @code{sort-regexp-fields} в интерактивном режиме,
запрашивается @var{record-regexp} и @var{key-regexp} в минибуфере.
@end deffn

@deffn Command sort-lines reverse start end
Команда в алфавитном порядке сортирует строки в области между @var{start} и
@var{end}.  Если @var{reverse} установленно в не-@code{nil}, сортировка
выполняется в обратном порядке.
@end deffn

@deffn Command sort-paragraphs reverse start end
Команда сортирует абзацы в алфавитном порядке в диапазоне между @var{start}
и @var{end}.  Если @var{reverse} установленно в не-@code{nil}, сортировка
выполняется в обратном порядке.
@end deffn

@deffn Command sort-pages reverse start end
Команда сортирует страницы в алфавитном порядке в диапазоне между
@var{start} и @var{end}.  Если @var{reverse} установленно в не-@code{nil},
сортировка выполняется в обратном порядке.
@end deffn

@deffn Command sort-fields field start end
Команда сортирует строки в области между @var{start} и @var{end}, сравнивая
их в алфавитном порядке по полю @var{field} каждой строки.  Поля разделяются
пробелами и нумеруются, начиная с 1.  Если @var{field} отрицательно,
сортировка производится по полю @w{@minus{}@var{field}} от конца строки.
Команда полезна для сортировки таблиц.
@end deffn

@deffn Command sort-numeric-fields field start end
Команда сортирует строки в области между @var{start} and @var{end},
сравнивая их численно по полю @var{field} каждой строки.  Поля разделяются
пробелом и нумеруются, начиная с 1.  Указанное поле должно содержать номер в
каждой строке региона.  Числа, начинающиеся с 0, обрабатываются как
восьмеричные, а числа, начинающиеся с @samp{0x}, как шестнадцатеричные.

Если @var{field} отрицательно, сортировка производится по полю
@w{@minus{}@var{field}} с конца строки.  Команда полезна для сортировки
таблиц.
@end deffn

@defopt sort-numeric-base
Переменная определяет систему счисления по умолчанию для
@code{sort-numeric-fields} при анализе чисел.
@end defopt

@deffn Command sort-columns reverse &optional beg end
Команда сортирует строки в области между @var{beg} и @var{end}, сравнивая их
в алфавитном порядке по определенному диапазону столбцов.  Позиции столбцов
@var{beg} и @var{end} ограничивают диапазон столбцов для сортировки.

Если @var{reverse} равен не-@code{nil}, сортировка выполняется в обратном
порядке.

Одна необычная особенность этой команды заключается в том, что вся строка,
содержащая позицию @var{beg}, и вся строка, содержащая позицию @var{end},
включаются в отсортированный регион.

Обратить внимание, что @code{sort-columns} отклоняет текст, содержащий
табуляцию, потому что табуляция может быть разделена по указанным столбцам.
Использовать @kbd{M-x untabify} для преобразования табуляции в пробелы
перед сортировкой.

Когда это возможно, команда фактически работает, вызывая служебную программу
@code{sort}.
@end deffn

@node Columns
@section Подсчет Столбцов
@cindex columns
@cindex counting columns
@cindex horizontal position

  Функции столбца преобразуют позицию символа (подсчет символов с начала
буфера) и позицию столбца (подсчет экранных символов с начала строки).

  Эти функции подсчитывают каждый символ в соответствии с количеством
столбцов, которые он занимает на экране.  Это означает, что управляющие
символы считаются занимающими 2 или 4 столбца, в зависимости от значения
@code{ctl-arrow}, а табуляция считается занимающей количество столбцов,
которое зависит от значения @code{tab-width} и столбца, с которого
начинается табуляция.  @xref{Usual Display}.

  При вычислении количества столбцов игнорируется ширина окна и количество
горизонтальной прокрутки.  Следовательно, значение столбца может быть
произвольно большим.  Первый (или крайний левый) столбец имеет номер 0.
Также игнорируются наложения и свойства текста, за исключением невидимости.

@defun current-column
Функция возвращает положение точки по горизонтали, измеренное в столбцах,
начиная с 0 на левом поле.  Положение столбца - это сумма ширины всех
отображаемых представлений символов между началом текущей строки и точкой.
@end defun

@deffn Command move-to-column column &optional force
Функция перемещает точку на @var{column} в текущей строке.  При вычислении
@var{column} учитывается ширина отображаемых представлений символов между
началом строки и точкой.

При интерактивном вызове @var{column} является значением числового
префиксного аргумента.  Если @var{column} не является целым числом, выдается
сообщение об ошибке.

@c Это поведение документировалось до 2013/08.
@ignore
Если столбец @var{column} находится за концом строки, точка перемещается в
конец строки.  Если @var{column} отрицательно, точка перемещается в начало
 строки.
@end ignore

Если невозможно перейти в столбец @var{column}, потому что он находится в
середине многоколоночного символа, такого как табуляция, точка перемещается
в конец этого символа.  Однако, если @var{force} установленно в
не-@code{nil}, а @var{column} находится в середине табуляции, то
@code{move-to-column} либо преобразует табуляцию в пробелы (когда
@code{indent-tabs-mode} имеет значение @code{nil}), либо вставляет
достаточно пробелов перед ней (в противном случае), чтобы точка могла
перемещаться точно в столбец @var{column}.  Другие многоколоночные символы
могут вызывать аномалии, несмотря на @var{force}, поскольку их невозможно
разделить.

Аргумент @var{force} также действует, если длина строки недостаточна для
достижения столбца @var{column}; если это @code{t}, это означает добавление
пробела в конце строки для достижения этого столбца.

Возвращаемое значение - номер фактически перемещенного столбца.
@end deffn

@node Indentation
@section Отступ
@cindex indentation

  Функции отступа используются для проверки, перемещения и изменения
пробелов в начале строки.  Некоторые функции также могут изменять пробелы в
другом месте строки.  Столбцы и отступы отсчитываются от нуля на левом поле.

@menu
* Primitive Indent::  Функции, используемые для подсчета и вставки отступов.
* Mode-Specific Indent::  Настройте отступ для разных режимов.
* Region Indent::         Создать отступ для всех строк в регионе.
* Relative Indent::       Отступ текущей строки на основе предыдущих строк.
* Indent Tabs::      Регулируемые позиции табуляции, как на пишущей машинке.
* Motion by Indent::      Перейти к первому непустому символу.
@end menu

@node Primitive Indent
@subsection Примитивы Отступа

  В этом разделе описаны примитивные функции, используемые для подсчета и
вставки отступов.  Эти примитивы используются в функциях в следующих
разделах.  @xref{Size of Displayed Text}, для связанных функций.

@defun current-indentation
@comment !!Тип Примитивная функция
@comment !!ИсходныйФайл indent.c
Функция возвращает отступ текущей строки, который является горизонтальной
позицией первого непустого символа.  Если содержимое полностью пустое, то
это горизонтальное положение конца строки.
@end defun

@deffn Command indent-to column &optional minimum
@comment !!Тип Примитивная функция
@comment !!ИсходныйФайл indent.c
Функция делает отступ от точки табуляцией и пробелами до достижения
@var{column}.  Если указано @var{minimum} и оно установленно в
не-@code{nil}, то будет вставлено как минимум такое количество пробелов,
даже если для этого потребуется выйти за пределы @var{column}.  В противном
случае функция ничего не делает, если точка уже находится за пределами
@var{column}.  Значение - это столбец, на котором заканчивается вставленный
отступ.

Вставленные пробельные символы наследуют свойства текста от окружающего
текста (обычно только от предыдущего текста).  @xref{Sticky Properties}.
@end deffn

@defopt indent-tabs-mode
@comment !!ИсходныйФайл indent.c
Если эта переменная - не-@code{nil}, функции отступа могут вставлять как
табуляцию, так и пробелы.  В противном случае вставляются только пробелы.
Установка этой переменной автоматически делает ее локальной в текущем
буфере.
@end defopt

@node Mode-Specific Indent
@subsection Отступ, Контролируемый Основным Режимом

  Важной функцией каждого основного режима является настройка клавиши
@key{TAB} для правильного отступа для редактируемого языка.  В этом разделе
описывается механизм ключа @key{TAB} и способы управления им.  Функции в
этом разделе возвращают непредсказуемые значения.

@deffn Command indent-for-tab-command &optional rigid
Команда, привязанная к @key{TAB} в большинстве режимов редактирования.  Её
обычное действие - сделать отступ для текущей строки, но в качестве
альтернативы может вставить символ табуляции или сделать отступ для области.

Вот что делает:

@itemize
@item
Во-первых, проверяет, включен ли режим Transient Mark и активна ли область.
Если это так, вызывается @code{indent-region} для отступа всего текста в
области (@pxref{Region Indent}).

@item
В противном случае, если функция отступа указанная в
@code{indent-line-function} - @code{indent-to-left-margin} (тривиальная
команда, которая вставляет символ табуляции) или если переменная
@code{tab-always-indent} указывает, что должен быть вставлен символ
табуляции (смотреть ниже), то вставляется символ табуляции.

@item
В противном случае делается отступ для текущей строки; это делается путем
вызова функции указанной в @code{indent-line-function}.  Если строка уже
имеет отступ, а значение @code{tab-always-indent} равно @code{complete}
(смотреть ниже), проводится попытка завершить текст в точке.
@end itemize

Если @var{rigid} - не-@code{nil} (интерактивно, с префиксным аргументом), то
после того, как эта команда делает отступ для строки или вставляет
табуляцию, она также жестко отступает от всего сбалансированного выражения,
которое начинается в начале текущей строки, чтобы отразить новый отступ.
Этот аргумент игнорируется, если команда делает отступ в области.
@end deffn

@defvar indent-line-function
Значение переменной - функция, которая будет использоваться
@code{indent-for-tab-command} и различными другими командами отступа для
отступа текущей строки.  Обычно назначается основным режимом; например,
режим Lisp устанавливает её в @code{lisp-indent-line}, режим C устанавливает
её в @code{c-indent-line} и так далее.  Значение по умолчанию -
@code{indent-relative}.  @xref{Auto-Indentation}.
@end defvar

@deffn Command indent-according-to-mode
Команда вызывает функцию в @code{indent-line-function}, чтобы сделать отступ
в текущей строке подходящим для текущего основного режима.
@end deffn

@deffn Command newline-and-indent
Функция вставляет новую строку, а затем делает отступ для новой строки
(следующей за только что вставленной новой строкой) в соответствии с
основным режимом.  Выполняется отступ, вызовом
@code{indent-according-to-mode}.
@end deffn

@deffn Command reindent-then-newline-and-indent
Команда повторно делает отступ в текущей строке, вставляет новую строку в
точку, а затем делает отступ для новой строки (той, которая следует за
только что вставленной новой строкой).  Делается отступ в обеих строках,
вызовом @code{indent-according-to-mode}.
@end deffn

@defopt tab-always-indent
Переменную можно использовать для настройки поведения команды @key{TAB}
(@code{indent-for-tab-command}).  Если значение установленно в @code{t} (по
умолчанию), команда обычно просто отступает от текущей строки.  Если
значение равно @code{nil}, команда делает отступ текущей строки только в том
случае, если точка находится на левом поле или в отступе строки; в противном
случае вставляется символ табуляции.  Если значение равно @code{complete},
команда сначала пытается сделать отступ для текущей строки, а если строка
уже была с отступом, вызывается @code{completion-at-point} для завершения
текста в точке (@pxref{Completion in Buffers}).
@end defopt

@cindex literate programming
@cindex multi-mode indentation
  Некоторые основные режимы должны поддерживать встроенные области текста,
синтаксис которых принадлежит другому основному режиму.  Примеры включают
исходные файлы @dfn{грамотное программирование}, которые объединяют
документацию и фрагменты исходного кода, программы Yacc/Bison, которые
включают фрагменты кода Python или JS и так далее.  Для правильного отступа
встроенных фрагментов в основном режиме необходимо делегировать отступ
механизму отступов другого режима (например, вызовом @code{js-indent-line}
для кода JS или @code{python-indent-line} для Python), предоставив ему
некоторый контекст для управления отступом.  В свою очередь, основные режимы
должны избегать использования @code{widen} в коде отступов и подчиняться
@code{prog-first-column}.

@defvar prog-indentation-context
Переменная, когда указывает на не-@code{nil}, содержит контекст отступа для
механизма отступов подрежима, предоставляемый вышестоящим основным режимом.
Значение должно быть списком вида @code{(@var{first-column}. @var{rest}}.
Члены списка имеют следующее значение:

@table @var
@item first-column
Столбец, который будет использоваться для конструкций верхнего уровня.  Это
заменяет значение по умолчанию столбца верхнего уровня, используемое
подрежимом, обычно нулевое.
@item rest
Значение в настоящее время не используется.
@end table
@end defvar

Следующая удобная функция должна использоваться механизмом отступов
основного режима для поддержки вызовов в качестве подрежимов другого
основного режима.

@defun prog-first-column
Вызвать эту функцию вместо использования буквального значения (обычно нуля)
номера столбца для отступов программных конструкций верхнего уровня.
Значение функции - это номер столбца, используемый для конструкций верхнего
уровня.  Если вышестоящий режим не действует, эта функция возвращает ноль.
@end defun


@node Region Indent
@subsection Отступ для Всей Области

  В этом разделе описаны команды, которые делают отступы для всех строк в
регионе.  Возвращают непредсказуемые значения.

@deffn Command indent-region start end &optional to-column
Команда делает отступ для каждой непустой строки, начиная с @var{start}
(включительно) и @var{end} (исключительно).  Если @var{to-column}
установленно в @code{nil}, @code{indent-region} делает отступ для каждой
непустой строки, вызовом функции отступа текущего режима, со значением
@code{indent-line-function}.

Если @var{to-column} установленно в не-@code{nil}, это должно быть целое
число, определяющее количество столбцов отступа; тогда функция дает каждой
строке ровно такой же отступ, добавляя или удаляя пробелы.

Если есть префикс заполнения, @code{indent-region} делает отступ для каждой
строки, заставляя ее начинаться с префикса заполнения.
@end deffn

@defvar indent-region-function
Значение переменной - функция, которую @code{indent-region} может
использовать как сокращение.  Принимается два аргумента: начало и конец
области.  Потребуется спроектировать функцию так, чтобы она давала те же
результаты, что и отступы строк области одна за другой, но,
предположительно, быстрее.

Если значение равно @code{nil}, сокращенного пути нет, то
@code{indent-region} фактически работает построчно.

Функция быстрого доступа полезна в таких режимах, как режим C и режим Lisp,
где @code{indent-line-function} должен сканировать с начала определения
функции: применение её к каждой строке будет квадратичным по времени.  Ярлык
может обновлять информацию о сканировании при перемещении по строкам,
отступающим от них; это занимает линейное время.  В режиме, когда
индивидуальный отступ строки выполняется быстро, нет необходимости в
сокращении.

@code{indent-region} с аргументом не-@code{nil} @var{to-column} имеет другое
значение и не использует эту переменную.
@end defvar

@deffn Command indent-rigidly start end count
Функция сдвигает все строки, начинающиеся между @var{start} (включительно) и
@var{end} (исключительно), в бок на @var{count} столбцов.  Это сохраняет
форму обработанной области, перемещая ее как жесткую единицу.

Полезно не только для отступов областей текста без отступов, но также для
отступов областей форматированного кода.  Например, если @var{count} равно
3, команда добавляет 3 столбца отступа к каждой строке, которая начинается в
указанной области.

При интерактивном вызове без префиксного аргумента команда вызывает
переходный режим для жесткой настройки отступа.
@xref{Indentation Commands,,, emacs, Руководство GNU Emacs Manual}.
@end deffn

@deffn Command indent-code-rigidly start end columns &optional nochange-regexp
Похоже на @code{indent-rigidly}, за исключением того, что не изменяются
строки, начинающиеся внутри строк или комментариев.

Кроме того, не изменяется строка, если @var{nochange-regexp} совпадает с
началом строки (если @var{nochange-regexp} установленно в не-@code{nil}).
@end deffn

@node Relative Indent
@subsection Indentation Relative to Previous Lines

  This section describes two commands that indent the current line
based on the contents of previous lines.

@deffn Command indent-relative &optional unindented-ok
This command inserts whitespace at point, extending to the same
column as the next @dfn{indent point} of the previous nonblank line.  An
indent point is a non-whitespace character following whitespace.  The
next indent point is the first one at a column greater than the current
column of point.  For example, if point is underneath and to the left of
the first non-blank character of a line of text, it moves to that column
by inserting whitespace.

If the previous nonblank line has no next indent point (i.e., none at a
great enough column position), @code{indent-relative} either does
nothing (if @var{unindented-ok} is не-@code{nil}) or calls
@code{tab-to-tab-stop}.  Thus, if point is underneath and to the right
of the last column of a short line of text, this command ordinarily
moves point to the next tab stop by inserting whitespace.

The return value of @code{indent-relative} is unpredictable.

In the following example, point is at the beginning of the second
line:

@example
@group
            This line is indented twelve spaces.
@point{}The quick brown fox jumped.
@end group
@end example

@noindent
Evaluation of the expression @code{(indent-relative nil)} produces the
following:

@example
@group
            This line is indented twelve spaces.
            @point{}The quick brown fox jumped.
@end group
@end example

  In this next example, point is between the @samp{m} and @samp{p} of
@samp{jumped}:

@example
@group
            This line is indented twelve spaces.
The quick brown fox jum@point{}ped.
@end group
@end example

@noindent
Evaluation of the expression @code{(indent-relative nil)} produces the
following:

@example
@group
            This line is indented twelve spaces.
The quick brown fox jum  @point{}ped.
@end group
@end example
@end deffn

@deffn Command indent-relative-first-indent-point
@comment !!SourceFile indent.el
This command indents the current line like the previous nonblank line,
by calling @code{indent-relative} with @code{t} as the
@var{first-only} argument.  The return value is unpredictable.

If the previous nonblank line has no indent points beyond the current
column, this command does nothing.
@end deffn

@node Indent Tabs
@subsection Adjustable Tab Stops
@cindex tabs stops for indentation

  This section explains the mechanism for user-specified tab stops
and the mechanisms that use and set them.  The name ``tab stops'' is
used because the feature is similar to that of the tab stops on a
typewriter.  The feature works by inserting an appropriate number of
spaces and tab characters to reach the next tab stop column; it does not
affect the display of tab characters in the buffer (@pxref{Usual
Display}).  Note that the @key{TAB} character as input uses this tab
stop feature only in a few major modes, such as Text mode.
@xref{Tab Stops,,, emacs, The GNU Emacs Manual}.

@deffn Command tab-to-tab-stop
This command inserts spaces or tabs before point, up to the next tab
stop column defined by @code{tab-stop-list}.
@end deffn

@defopt tab-stop-list
This variable defines the tab stop columns used by @code{tab-to-tab-stop}.
It should be either @code{nil}, or a list of increasing integers,
which need not be evenly spaced.  The list is implicitly
extended to infinity through repetition of the interval between the
last and penultimate elements (or @code{tab-width} if the list has
fewer than two elements).  A value of @code{nil} means a tab stop
every @code{tab-width} columns.

Use @kbd{M-x edit-tab-stops} to edit the location of tab stops interactively.
@end defopt

@node Motion by Indent
@subsection Indentation-Based Motion Commands

  These commands, primarily for interactive use, act based on the
indentation in the text.

@deffn Command back-to-indentation
@comment !!SourceFile simple.el
This command moves point to the first non-whitespace character in the
current line (which is the line in which point is located).  It returns
@code{nil}.
@end deffn

@deffn Command backward-to-indentation &optional arg
@comment !!SourceFile simple.el
This command moves point backward @var{arg} lines and then to the
first nonblank character on that line.  It returns @code{nil}.
If @var{arg} is omitted or @code{nil}, it defaults to 1.
@end deffn

@deffn Command forward-to-indentation &optional arg
@comment !!SourceFile simple.el
This command moves point forward @var{arg} lines and then to the first
nonblank character on that line.  It returns @code{nil}.
If @var{arg} is omitted or @code{nil}, it defaults to 1.
@end deffn

@node Case Changes
@section Case Changes
@cindex case conversion in buffers

  The case change commands described here work on text in the current
buffer.  @xref{Case Conversion}, for case conversion functions that work
on strings and characters.  @xref{Case Tables}, for how to customize
which characters are upper or lower case and how to convert them.

@deffn Command capitalize-region start end
This function capitalizes all words in the region defined by
@var{start} and @var{end}.  To capitalize means to convert each word's
first character to upper case and convert the rest of each word to lower
case.  The function returns @code{nil}.

If one end of the region is in the middle of a word, the part of the
word within the region is treated as an entire word.

When @code{capitalize-region} is called interactively, @var{start} and
@var{end} are point and the mark, with the smallest first.

@example
@group
---------- Buffer: foo ----------
This is the contents of the 5th foo.
---------- Buffer: foo ----------
@end group

@group
(capitalize-region 1 37)
@result{} nil

---------- Buffer: foo ----------
This Is The Contents Of The 5th Foo.
---------- Buffer: foo ----------
@end group
@end example
@end deffn

@deffn Command downcase-region start end
This function converts all of the letters in the region defined by
@var{start} and @var{end} to lower case.  The function returns
@code{nil}.

When @code{downcase-region} is called interactively, @var{start} and
@var{end} are point and the mark, with the smallest first.
@end deffn

@deffn Command upcase-region start end
This function converts all of the letters in the region defined by
@var{start} and @var{end} to upper case.  The function returns
@code{nil}.

When @code{upcase-region} is called interactively, @var{start} and
@var{end} are point and the mark, with the smallest first.
@end deffn

@deffn Command capitalize-word count
This function capitalizes @var{count} words after point, moving point
over as it does.  To capitalize means to convert each word's first
character to upper case and convert the rest of each word to lower case.
If @var{count} is negative, the function capitalizes the
@minus{}@var{count} previous words but does not move point.  The value
is @code{nil}.

If point is in the middle of a word, the part of the word before point
is ignored when moving forward.  The rest is treated as an entire word.

When @code{capitalize-word} is called interactively, @var{count} is
set to the numeric prefix argument.
@end deffn

@deffn Command downcase-word count
This function converts the @var{count} words after point to all lower
case, moving point over as it does.  If @var{count} is negative, it
converts the @minus{}@var{count} previous words but does not move point.
The value is @code{nil}.

When @code{downcase-word} is called interactively, @var{count} is set
to the numeric prefix argument.
@end deffn

@deffn Command upcase-word count
This function converts the @var{count} words after point to all upper
case, moving point over as it does.  If @var{count} is negative, it
converts the @minus{}@var{count} previous words but does not move point.
The value is @code{nil}.

When @code{upcase-word} is called interactively, @var{count} is set to
the numeric prefix argument.
@end deffn

@node Text Properties
@section Text Properties
@cindex text properties
@cindex attributes of text
@cindex properties of text

  Each character position in a buffer or a string can have a @dfn{text
property list}, much like the property list of a symbol (@pxref{Property
Lists}).  The properties belong to a particular character at a
particular place, such as, the letter @samp{T} at the beginning of this
sentence or the first @samp{o} in @samp{foo}---if the same character
occurs in two different places, the two occurrences in general have
different properties.

  Each property has a name and a value.  Both of these can be any Lisp
object, but the name is normally a symbol.  Typically each property
name symbol is used for a particular purpose; for instance, the text
property @code{face} specifies the faces for displaying the character
(@pxref{Special Properties}).  The usual way to access the property
list is to specify a name and ask what value corresponds to it.

  If a character has a @code{category} property, we call it the
@dfn{property category} of the character.  It should be a symbol.  The
properties of the symbol serve as defaults for the properties of the
character.

  Copying text between strings and buffers preserves the properties
along with the characters; this includes such diverse functions as
@code{substring}, @code{insert}, and @code{buffer-substring}.

@menu
* Examining Properties::   Looking at the properties of one character.
* Changing Properties::    Setting the properties of a range of text.
* Property Search::        Searching for where a property changes value.
* Special Properties::     Particular properties with special meanings.
* Format Properties::      Properties for representing formatting of text.
* Sticky Properties::      How inserted text gets properties from
                             neighboring text.
* Lazy Properties::        Computing text properties in a lazy fashion
                             only when text is examined.
* Clickable Text::         Using text properties to make regions of text
                             do something when you click on them.
* Fields::                 The @code{field} property defines
                             fields within the buffer.
* Not Intervals::          Why text properties do not use
                             Lisp-visible text intervals.
@end menu

@node Examining Properties
@subsection Examining Text Properties
@cindex examining text properties
@cindex text properties, examining

  The simplest way to examine text properties is to ask for the value of
a particular property of a particular character.  For that, use
@code{get-text-property}.  Use @code{text-properties-at} to get the
entire property list of a character.  @xref{Property Search}, for
functions to examine the properties of a number of characters at once.

  These functions handle both strings and buffers.  Keep in mind that
positions in a string start from 0, whereas positions in a buffer start
from 1.

@defun get-text-property pos prop &optional object
This function returns the value of the @var{prop} property of the
character after position @var{pos} in @var{object} (a buffer or
string).  The argument @var{object} is optional and defaults to the
current buffer.

If there is no @var{prop} property strictly speaking, but the character
has a property category that is a symbol, then @code{get-text-property} returns
the @var{prop} property of that symbol.
@end defun

@defun get-char-property position prop &optional object
This function is like @code{get-text-property}, except that it checks
overlays first and then text properties.  @xref{Overlays}.

The argument @var{object} may be a string, a buffer, or a window.  If
it is a window, then the buffer displayed in that window is used for
text properties and overlays, but only the overlays active for that
window are considered.  If @var{object} is a buffer, then overlays in
that buffer are considered first, in order of decreasing priority,
followed by the text properties.  If @var{object} is a string, only
text properties are considered, since strings never have overlays.
@end defun

@defun get-pos-property position prop &optional object
This function is like @code{get-char-property}, except that it pays
attention to properties' stickiness and overlays' advancement settings
instead of the property of the character at (i.e., right after)
@var{position}.
@end defun

@defun get-char-property-and-overlay position prop &optional object
This is like @code{get-char-property}, but gives extra information
about the overlay that the property value comes from.

Its value is a cons cell whose @sc{car} is the property value, the
same value @code{get-char-property} would return with the same
arguments.  Its @sc{cdr} is the overlay in which the property was
found, or @code{nil}, if it was found as a text property or not found
at all.

If @var{position} is at the end of @var{object}, both the @sc{car} and
the @sc{cdr} of the value are @code{nil}.
@end defun

@defvar char-property-alias-alist
This variable holds an alist which maps property names to a list of
alternative property names.  If a character does not specify a direct
value for a property, the alternative property names are consulted in
order; the first не-@code{nil} value is used.  This variable takes
precedence over @code{default-text-properties}, and @code{category}
properties take precedence over this variable.
@end defvar

@defun text-properties-at position &optional object
This function returns the entire property list of the character at
@var{position} in the string or buffer @var{object}.  If @var{object} is
@code{nil}, it defaults to the current buffer.
@end defun

@defvar default-text-properties
This variable holds a property list giving default values for text
properties.  Whenever a character does not specify a value for a
property, neither directly, through a category symbol, or through
@code{char-property-alias-alist}, the value stored in this list is
used instead.  Here is an example:

@example
(setq default-text-properties '(foo 69)
      char-property-alias-alist nil)
;; @r{Make sure character 1 has no properties of its own.}
(set-text-properties 1 2 nil)
;; @r{What we get, when we ask, is the default value.}
(get-text-property 1 'foo)
     @result{} 69
@end example
@end defvar

@node Changing Properties
@subsection Changing Text Properties
@cindex changing text properties
@cindex text properties, changing

  The primitives for changing properties apply to a specified range of
text in a buffer or string.  The function @code{set-text-properties}
(see end of section) sets the entire property list of the text in that
range; more often, it is useful to add, change, or delete just certain
properties specified by name.

  Since text properties are considered part of the contents of the
buffer (or string), and can affect how a buffer looks on the screen,
any change in buffer text properties marks the buffer as modified.
Buffer text property changes are undoable also (@pxref{Undo}).
Positions in a string start from 0, whereas positions in a buffer
start from 1.

@defun put-text-property start end prop value &optional object
This function sets the @var{prop} property to @var{value} for the text
between @var{start} and @var{end} in the string or buffer @var{object}.
If @var{object} is @code{nil}, it defaults to the current buffer.
@end defun

@defun add-text-properties start end props &optional object
This function adds or overrides text properties for the text between
@var{start} and @var{end} in the string or buffer @var{object}.  If
@var{object} is @code{nil}, it defaults to the current buffer.

The argument @var{props} specifies which properties to add.  It should
have the form of a property list (@pxref{Property Lists}): a list whose
elements include the property names followed alternately by the
corresponding values.

The return value is @code{t} if the function actually changed some
property's value; @code{nil} otherwise (if @var{props} is @code{nil} or
its values agree with those in the text).

For example, here is how to set the @code{comment} and @code{face}
properties of a range of text:

@example
(add-text-properties @var{start} @var{end}
                     '(comment t face highlight))
@end example
@end defun

@defun remove-text-properties start end props &optional object
This function deletes specified text properties from the text between
@var{start} and @var{end} in the string or buffer @var{object}.  If
@var{object} is @code{nil}, it defaults to the current buffer.

The argument @var{props} specifies which properties to delete.  It
should have the form of a property list (@pxref{Property Lists}): a list
whose elements are property names alternating with corresponding values.
But only the names matter---the values that accompany them are ignored.
For example, here's how to remove the @code{face} property.

@example
(remove-text-properties @var{start} @var{end} '(face nil))
@end example

The return value is @code{t} if the function actually changed some
property's value; @code{nil} otherwise (if @var{props} is @code{nil} or
if no character in the specified text had any of those properties).

To remove all text properties from certain text, use
@code{set-text-properties} and specify @code{nil} for the new property
list.
@end defun

@defun remove-list-of-text-properties start end list-of-properties &optional object
Like @code{remove-text-properties} except that
@var{list-of-properties} is a list of property names only, not an
alternating list of property names and values.
@end defun

@defun set-text-properties start end props &optional object
This function completely replaces the text property list for the text
between @var{start} and @var{end} in the string or buffer @var{object}.
If @var{object} is @code{nil}, it defaults to the current buffer.

The argument @var{props} is the new property list.  It should be a list
whose elements are property names alternating with corresponding values.

After @code{set-text-properties} returns, all the characters in the
specified range have identical properties.

If @var{props} is @code{nil}, the effect is to get rid of all properties
from the specified range of text.  Here's an example:

@example
(set-text-properties @var{start} @var{end} nil)
@end example

Do not rely on the return value of this function.
@end defun

@defun add-face-text-property start end face &optional appendp object
This function acts on the text between @var{start} and @var{end},
adding the face @var{face} to the @code{face} text property.
@var{face} should be a valid value for the @code{face} property
(@pxref{Special Properties}), such as a face name or an anonymous face
(@pxref{Faces}).

If any text in the region already has a не-@code{nil} @code{face} property,
those face(s) are retained.  This function sets the @code{face}
property to a list of faces, with @var{face} as the first element (by
default) and the pre-existing faces as the remaining elements.  If the
optional argument @var{appendp} is не-@code{nil}, @var{face} is
appended to the end of the list instead.  Note that in a face list,
the first occurring value for each attribute takes precedence.

For example, the following code would assign an italicized green face
to the text between @var{start} and @var{end}:

@example
(add-face-text-property @var{start} @var{end} 'italic)
(add-face-text-property @var{start} @var{end} '(:foreground "red"))
(add-face-text-property @var{start} @var{end} '(:foreground "green"))
@end example

The optional argument @var{object}, if не-@code{nil}, specifies a
buffer or string to act on, rather than the current buffer.  If
@var{object} is a string, then @var{start} and @var{end} are
zero-based indices into the string.
@end defun

  The easiest way to make a string with text properties is with
@code{propertize}:

@defun propertize string &rest properties
This function returns a copy of @var{string} with the text properties
@var{properties} added.  These properties apply to all the characters
in the string that is returned.  Here is an example that constructs a
string with a @code{face} property and a @code{mouse-face} property:

@smallexample
(propertize "foo" 'face 'italic
            'mouse-face 'bold-italic)
     @result{} #("foo" 0 3 (mouse-face bold-italic face italic))
@end smallexample

To put different properties on various parts of a string, you can
construct each part with @code{propertize} and then combine them with
@code{concat}:

@smallexample
(concat
 (propertize "foo" 'face 'italic
             'mouse-face 'bold-italic)
 " and "
 (propertize "bar" 'face 'italic
             'mouse-face 'bold-italic))
     @result{} #("foo and bar"
                 0 3 (face italic mouse-face bold-italic)
                 3 8 nil
                 8 11 (face italic mouse-face bold-italic))
@end smallexample
@end defun

  @xref{Buffer Contents}, for the function
@code{buffer-substring-no-properties}, which copies text from the
buffer but does not copy its properties.

@findex with-silent-modifications
  If you wish to add text properties to a buffer or remove them
without marking the buffer as modified, you can wrap the calls above
in the @code{with-silent-modifications} macro.  @xref{Buffer
Modification}.

@node Property Search
@subsection Text Property Search Functions
@cindex searching text properties
@cindex text properties, searching

  In typical use of text properties, most of the time several or many
consecutive characters have the same value for a property.  Rather than
writing your programs to examine characters one by one, it is much
faster to process chunks of text that have the same property value.

  Here are functions you can use to do this.  They use @code{eq} for
comparing property values.  In all cases, @var{object} defaults to the
current buffer.

  For good performance, it's very important to use the @var{limit}
argument to these functions, especially the ones that search for a
single property---otherwise, they may spend a long time scanning to the
end of the buffer, if the property you are interested in does not change.

  These functions do not move point; instead, they return a position (or
@code{nil}).  Remember that a position is always between two characters;
the position returned by these functions is between two characters with
different properties.

@defun next-property-change pos &optional object limit
The function scans the text forward from position @var{pos} in the
string or buffer @var{object} until it finds a change in some text
property, then returns the position of the change.  In other words, it
returns the position of the first character beyond @var{pos} whose
properties are not identical to those of the character just after
@var{pos}.

If @var{limit} is не-@code{nil}, then the scan ends at position
@var{limit}.  If there is no property change before that point, this
function returns @var{limit}.

The value is @code{nil} if the properties remain unchanged all the way
to the end of @var{object} and @var{limit} is @code{nil}.  If the value
is не-@code{nil}, it is a position greater than or equal to @var{pos}.
The value equals @var{pos} only when @var{limit} equals @var{pos}.

Here is an example of how to scan the buffer by chunks of text within
which all properties are constant:

@smallexample
(while (not (eobp))
  (let ((plist (text-properties-at (point)))
        (next-change
         (or (next-property-change (point) (current-buffer))
             (point-max))))
    @r{Process text from point to @var{next-change}@dots{}}
    (goto-char next-change)))
@end smallexample
@end defun

@defun previous-property-change pos &optional object limit
This is like @code{next-property-change}, but scans back from @var{pos}
instead of forward.  If the value is не-@code{nil}, it is a position
less than or equal to @var{pos}; it equals @var{pos} only if @var{limit}
equals @var{pos}.
@end defun

@defun next-single-property-change pos prop &optional object limit
The function scans text for a change in the @var{prop} property, then
returns the position of the change.  The scan goes forward from
position @var{pos} in the string or buffer @var{object}.  In other
words, this function returns the position of the first character
beyond @var{pos} whose @var{prop} property differs from that of the
character just after @var{pos}.

If @var{limit} is не-@code{nil}, then the scan ends at position
@var{limit}.  If there is no property change before that point,
@code{next-single-property-change} returns @var{limit}.

The value is @code{nil} if the property remains unchanged all the way to
the end of @var{object} and @var{limit} is @code{nil}.  If the value is
не-@code{nil}, it is a position greater than or equal to @var{pos}; it
equals @var{pos} only if @var{limit} equals @var{pos}.
@end defun

@defun previous-single-property-change pos prop &optional object limit
This is like @code{next-single-property-change}, but scans back from
@var{pos} instead of forward.  If the value is не-@code{nil}, it is a
position less than or equal to @var{pos}; it equals @var{pos} only if
@var{limit} equals @var{pos}.
@end defun

@defun next-char-property-change pos &optional limit
This is like @code{next-property-change} except that it considers
overlay properties as well as text properties, and if no change is
found before the end of the buffer, it returns the maximum buffer
position rather than @code{nil} (in this sense, it resembles the
corresponding overlay function @code{next-overlay-change}, rather than
@code{next-property-change}).  There is no @var{object} operand
because this function operates only on the current buffer.  It returns
the next address at which either kind of property changes.
@end defun

@defun previous-char-property-change pos &optional limit
This is like @code{next-char-property-change}, but scans back from
@var{pos} instead of forward, and returns the minimum buffer
position if no change is found.
@end defun

@defun next-single-char-property-change pos prop &optional object limit
This is like @code{next-single-property-change} except that it
considers overlay properties as well as text properties, and if no
change is found before the end of the @var{object}, it returns the
maximum valid position in @var{object} rather than @code{nil}.  Unlike
@code{next-char-property-change}, this function @emph{does} have an
@var{object} operand; if @var{object} is not a buffer, only
text-properties are considered.
@end defun

@defun previous-single-char-property-change pos prop &optional object limit
This is like @code{next-single-char-property-change}, but scans back
from @var{pos} instead of forward, and returns the minimum valid
position in @var{object} if no change is found.
@end defun

@defun text-property-any start end prop value &optional object
This function returns не-@code{nil} if at least one character between
@var{start} and @var{end} has a property @var{prop} whose value is
@var{value}.  More precisely, it returns the position of the first such
character.  Otherwise, it returns @code{nil}.

The optional fifth argument, @var{object}, specifies the string or
buffer to scan.  Positions are relative to @var{object}.  The default
for @var{object} is the current buffer.
@end defun

@defun text-property-not-all start end prop value &optional object
This function returns не-@code{nil} if at least one character between
@var{start} and @var{end} does not have a property @var{prop} with value
@var{value}.  More precisely, it returns the position of the first such
character.  Otherwise, it returns @code{nil}.

The optional fifth argument, @var{object}, specifies the string or
buffer to scan.  Positions are relative to @var{object}.  The default
for @var{object} is the current buffer.
@end defun

@node Special Properties
@subsection Properties with Special Meanings

  Here is a table of text property names that have special built-in
meanings.  The following sections list a few additional special property
names that control filling and property inheritance.  All other names
have no standard meaning, and you can use them as you like.

  Note: the properties @code{composition}, @code{display},
@code{invisible} and @code{intangible} can also cause point to move to
an acceptable place, after each Emacs command.  @xref{Adjusting
Point}.

@table @code
@cindex property category of text character
@c FIXME: Isn't @kindex for keyboard commands?
@kindex category @r{(text property)}
@item category
If a character has a @code{category} property, we call it the
@dfn{property category} of the character.  It should be a symbol.  The
properties of this symbol serve as defaults for the properties of the
character.

@item face
@cindex face codes of text
@kindex face @r{(text property)}
The @code{face} property controls the appearance of the character
(@pxref{Faces}).  The value of the property can be the following:

@itemize @bullet
@item
A face name (a symbol or string).

@item
An anonymous face: a property list of the form @code{(@var{keyword}
@var{value} @dots{})}, where each @var{keyword} is a face attribute
name and @var{value} is a value for that attribute.

@item
A list of faces.  Each list element should be either a face name or an
anonymous face.  This specifies a face which is an aggregate of the
attributes of each of the listed faces.  Faces occurring earlier in
the list have higher priority.

@item
A cons cell of the form @code{(foreground-color . @var{color-name})}
or @code{(background-color . @var{color-name})}.  This specifies the
foreground or background color, similar to @code{(:foreground
@var{color-name})} or @code{(:background @var{color-name})}.  This
form is supported for backward compatibility only, and should be
avoided.
@end itemize

Font Lock mode (@pxref{Font Lock Mode}) works in most buffers by
dynamically updating the @code{face} property of characters based on
the context.

The @code{add-face-text-property} function provides a convenient way
to set this text property.  @xref{Changing Properties}.

@item font-lock-face
@kindex font-lock-face @r{(text property)}
This property specifies a value for the @code{face} property that Font
Lock mode should apply to the underlying text.  It is one of the
fontification methods used by Font Lock mode, and is useful for
special modes that implement their own highlighting.
@xref{Precalculated Fontification}.  When Font Lock mode is disabled,
@code{font-lock-face} has no effect.

@item mouse-face
@kindex mouse-face @r{(text property)}
This property is used instead of @code{face} when the mouse is on or
near the character.  For this purpose, ``near'' means that all text
between the character and where the mouse is have the same
@code{mouse-face} property value.

Emacs ignores all face attributes from the @code{mouse-face} property
that alter the text size (e.g., @code{:height}, @code{:weight}, and
@code{:slant}).  Those attributes are always the same as for the
unhighlighted text.

@item fontified
@kindex fontified @r{(text property)}
This property says whether the text is ready for display.  If
@code{nil}, Emacs's redisplay routine calls the functions in
@code{fontification-functions} (@pxref{Auto Faces}) to prepare this
part of the buffer before it is displayed.  It is used internally by
the just-in-time font locking code.

@item display
This property activates various features that change the
way text is displayed.  For example, it can make text appear taller
or shorter, higher or lower, wider or narrow, or replaced with an image.
@xref{Display Property}.

@item help-echo
@kindex help-echo @r{(text property)}
@cindex tooltip for help strings
@anchor{Text help-echo}
If text has a string as its @code{help-echo} property, then when you
move the mouse onto that text, Emacs displays that string in the echo
area, or in the tooltip window (@pxref{Tooltips}).

If the value of the @code{help-echo} property is a function, that
function is called with three arguments, @var{window}, @var{object} and
@var{pos} and should return a help string or @code{nil} for
none.  The first argument, @var{window} is the window in which
the help was found.  The second, @var{object}, is the buffer, overlay or
string which had the @code{help-echo} property.  The @var{pos}
argument is as follows:

@itemize @bullet{}
@item
If @var{object} is a buffer, @var{pos} is the position in the buffer.
@item
If @var{object} is an overlay, that overlay has a @code{help-echo}
property, and @var{pos} is the position in the overlay's buffer.
@item
If @var{object} is a string (an overlay string or a string displayed
with the @code{display} property), @var{pos} is the position in that
string.
@end itemize

If the value of the @code{help-echo} property is neither a function nor
a string, it is evaluated to obtain a help string.

You can alter the way help text is displayed by setting the variable
@code{show-help-function} (@pxref{Help display}).

This feature is used in the mode line and for other active text.

@item keymap
@cindex keymap of character
@kindex keymap @r{(text property)}
The @code{keymap} property specifies an additional keymap for
commands.  When this keymap applies, it is used for key lookup before
the minor mode keymaps and before the buffer's local map.
@xref{Active Keymaps}.  If the property value is a symbol, the
symbol's function definition is used as the keymap.

The property's value for the character before point applies if it is
не-@code{nil} and rear-sticky, and the property's value for the
character after point applies if it is не-@code{nil} and
front-sticky.  (For mouse clicks, the position of the click is used
instead of the position of point.)

@item local-map
@kindex local-map @r{(text property)}
This property works like @code{keymap} except that it specifies a
keymap to use @emph{instead of} the buffer's local map.  For most
purposes (perhaps all purposes), it is better to use the @code{keymap}
property.

@item syntax-table
The @code{syntax-table} property overrides what the syntax table says
about this particular character.  @xref{Syntax Properties}.

@item read-only
@cindex read-only character
@kindex read-only @r{(text property)}
If a character has the property @code{read-only}, then modifying that
character is not allowed.  Any command that would do so gets an error,
@code{text-read-only}.  If the property value is a string, that string
is used as the error message.

Insertion next to a read-only character is an error if inserting
ordinary text there would inherit the @code{read-only} property due to
stickiness.  Thus, you can control permission to insert next to
read-only text by controlling the stickiness.  @xref{Sticky Properties}.

Since changing properties counts as modifying the buffer, it is not
possible to remove a @code{read-only} property unless you know the
special trick: bind @code{inhibit-read-only} to a не-@code{nil} value
and then remove the property.  @xref{Read Only Buffers}.

@item inhibit-read-only
@kindex inhibit-read-only @r{(text property)}
Characters that have the property @code{inhibit-read-only} can be
edited even in read-only buffers.  @xref{Read Only Buffers}.

@item invisible
@kindex invisible @r{(text property)}
A не-@code{nil} @code{invisible} property can make a character invisible
on the screen.  @xref{Invisible Text}, for details.

@item intangible
@kindex intangible @r{(text property)}
If a group of consecutive characters have equal and не-@code{nil}
@code{intangible} properties, then you cannot place point between them.
If you try to move point forward into the group, point actually moves to
the end of the group.  If you try to move point backward into the group,
point actually moves to the start of the group.

If consecutive characters have unequal не-@code{nil}
@code{intangible} properties, they belong to separate groups; each
group is separately treated as described above.

When the variable @code{inhibit-point-motion-hooks} is не-@code{nil}
(as it is by default), the @code{intangible} property is ignored.

Beware: this property operates at a very low level, and affects a lot of code
in unexpected ways.  So use it with extreme caution.  A common misuse is to put
an intangible property on invisible text, which is actually unnecessary since
the command loop will move point outside of the invisible text at the end of
each command anyway.  @xref{Adjusting Point}.  For these reasons, this
property is obsolete; use the @code{cursor-intangible} property instead.

@item cursor-intangible
@kindex cursor-intangible @r{(text property)}
@findex cursor-intangible-mode
When the minor mode @code{cursor-intangible-mode} is turned on, point
is moved away from any position that has a не-@code{nil}
@code{cursor-intangible} property, just before redisplay happens.

@vindex cursor-sensor-inhibit
When the variable @code{cursor-sensor-inhibit} is не-@code{nil}, the
@code{cursor-intangible} property and the
@code{cursor-sensor-functions} property (described below) are ignored.

@item field
@kindex field @r{(text property)}
Consecutive characters with the same @code{field} property constitute a
@dfn{field}.  Some motion functions including @code{forward-word} and
@code{beginning-of-line} stop moving at a field boundary.
@xref{Fields}.

@item cursor
@kindex cursor @r{(text property)}
Normally, the cursor is displayed at the beginning or the end of any
overlay and text property strings present at the current buffer
position.  You can place the cursor on any desired character of these
strings by giving that character a не-@code{nil} @code{cursor} text
property.  In addition, if the value of the @code{cursor} property is
an integer, it specifies the number of buffer's character
positions, starting with the position where the overlay or the
@code{display} property begins, for which the cursor should be
displayed on that character.  Specifically, if the value of the
@code{cursor} property of a character is the number @var{n}, the
cursor will be displayed on this character for any buffer position in
the range @code{[@var{ovpos}..@var{ovpos}+@var{n})}, where @var{ovpos}
is the overlay's starting position given by @code{overlay-start}
(@pxref{Managing Overlays}), or the position where the @code{display}
text property begins in the buffer.

In other words, the string character with the @code{cursor} property
of any не-@code{nil} value is the character where to display the
cursor.  The value of the property says for which buffer positions to
display the cursor there.  If the value is an integer @var{n},
the cursor is displayed there when point is anywhere between the
beginning of the overlay or @code{display} property and @var{n}
positions after that.  If the value is anything else and
не-@code{nil}, the cursor is displayed there only when point is at
the beginning of the @code{display} property or at
@code{overlay-start}.

@cindex cursor position for @code{display} properties and overlays
When the buffer has many overlay strings (e.g., @pxref{Overlay
Properties, before-string}) that conceal some of the buffer text or
@code{display} properties that are strings, it is a good idea to use
the @code{cursor} property on these strings to cue the Emacs display
about the places where to put the cursor while traversing these
strings.  This directly communicates to the display engine where the
Lisp program wants to put the cursor, or where the user would expect
the cursor, when point is located on some buffer position that is
``covered'' by the display or overlay string.

@item pointer
@kindex pointer @r{(text property)}
This specifies a specific pointer shape when the mouse pointer is over
this text or image.  @xref{Pointer Shape}, for possible pointer
shapes.

@item line-spacing
@kindex line-spacing @r{(text property)}
A newline can have a @code{line-spacing} text or overlay property that
controls the height of the display line ending with that newline.  The
property value overrides the default frame line spacing and the buffer
local @code{line-spacing} variable.  @xref{Line Height}.

@item line-height
@kindex line-height @r{(text property)}
A newline can have a @code{line-height} text or overlay property that
controls the total height of the display line ending in that newline.
@xref{Line Height}.

@item wrap-prefix
If text has a @code{wrap-prefix} property, the prefix it defines will
be added at display time to the beginning of every continuation line
due to text wrapping (so if lines are truncated, the wrap-prefix is
never used).  It may be a string or an image (@pxref{Other Display
Specs}), or a stretch of whitespace such as specified by the
@code{:width} or @code{:align-to} display properties (@pxref{Specified
Space}).

A wrap-prefix may also be specified for an entire buffer using the
@code{wrap-prefix} buffer-local variable (however, a
@code{wrap-prefix} text-property takes precedence over the value of
the @code{wrap-prefix} variable).  @xref{Truncation}.

@item line-prefix
If text has a @code{line-prefix} property, the prefix it defines will
be added at display time to the beginning of every non-continuation
line.  It may be a string or an image (@pxref{Other Display
Specs}), or a stretch of whitespace such as specified by the
@code{:width} or @code{:align-to} display properties (@pxref{Specified
Space}).

A line-prefix may also be specified for an entire buffer using the
@code{line-prefix} buffer-local variable (however, a
@code{line-prefix} text-property takes precedence over the value of
the @code{line-prefix} variable).  @xref{Truncation}.

@item modification-hooks
@cindex change hooks for a character
@cindex hooks for changing a character
@kindex modification-hooks @r{(text property)}
If a character has the property @code{modification-hooks}, then its
value should be a list of functions; modifying that character calls
all of those functions before the actual modification.  Each function
receives two arguments: the beginning and end of the part of the
buffer being modified.  Note that if a particular modification hook
function appears on several characters being modified by a single
primitive, you can't predict how many times the function will
be called.
Furthermore, insertion will not modify any existing character, so this
hook will only be run when removing some characters, replacing them
with others, or changing their text-properties.

If these functions modify the buffer, they should bind
@code{inhibit-modification-hooks} to @code{t} around doing so, to
avoid confusing the internal mechanism that calls these hooks.

Overlays also support the @code{modification-hooks} property, but the
details are somewhat different (@pxref{Overlay Properties}).

@item insert-in-front-hooks
@itemx insert-behind-hooks
@kindex insert-in-front-hooks @r{(text property)}
@kindex insert-behind-hooks @r{(text property)}
The operation of inserting text in a buffer also calls the functions
listed in the @code{insert-in-front-hooks} property of the following
character and in the @code{insert-behind-hooks} property of the
preceding character.  These functions receive two arguments, the
beginning and end of the inserted text.  The functions are called
@emph{after} the actual insertion takes place.

See also @ref{Change Hooks}, for other hooks that are called
when you change text in a buffer.

@item point-entered
@itemx point-left
@cindex hooks for motion of point
@kindex point-entered @r{(text property)}
@kindex point-left @r{(text property)}
The special properties @code{point-entered} and @code{point-left}
record hook functions that report motion of point.  Each time point
moves, Emacs compares these two property values:

@itemize @bullet
@item
the @code{point-left} property of the character after the old location,
and
@item
the @code{point-entered} property of the character after the new
location.
@end itemize

@noindent
If these two values differ, each of them is called (if not @code{nil})
with two arguments: the old value of point, and the new one.

The same comparison is made for the characters before the old and new
locations.  The result may be to execute two @code{point-left} functions
(which may be the same function) and/or two @code{point-entered}
functions (which may be the same function).  In any case, all the
@code{point-left} functions are called first, followed by all the
@code{point-entered} functions.

It is possible to use @code{char-after} to examine characters at various
buffer positions without moving point to those positions.  Only an
actual change in the value of point runs these hook functions.

The variable @code{inhibit-point-motion-hooks} by default inhibits
running the @code{point-left} and @code{point-entered} hooks, see
@ref{Inhibit point motion hooks}.

These properties are obsolete; please use
@code{cursor-sensor-functions} instead.

@item cursor-sensor-functions
@kindex cursor-sensor-functions @r{(text property)}
@findex cursor-sensor-mode
This special property records a list of functions that react to cursor
motion.  Each function in the list is called, just before redisplay,
with 3 arguments: the affected window, the previous known position of
the cursor, and one of the symbols @code{entered} or @code{left},
depending on whether the cursor is entering the text that has this
property or leaving it.  The functions are called only when the minor
mode @code{cursor-sensor-mode} is turned on.

When the variable @code{cursor-sensor-inhibit} is не-@code{nil}, the
@code{cursor-sensor-functions} property is ignored.

@item composition
@kindex composition @r{(text property)}
This text property is used to display a sequence of characters as a
single glyph composed from components.  But the value of the property
itself is completely internal to Emacs and should not be manipulated
directly by, for instance, @code{put-text-property}.

@end table

@defvar inhibit-point-motion-hooks
@anchor{Inhibit point motion hooks} When this obsolete variable is
не-@code{nil}, @code{point-left} and @code{point-entered} hooks are
not run, and the @code{intangible} property has no effect.  Do not set
this variable globally; bind it with @code{let}.  Since the affected
properties are obsolete, this variable's default value is @code{t}, to
effectively disable them.
@end defvar

@defvar show-help-function
@anchor{Help display} If this variable is не-@code{nil}, it specifies a
function called to display help strings.  These may be @code{help-echo}
properties, menu help strings (@pxref{Simple Menu Items},
@pxref{Extended Menu Items}), or tool bar help strings (@pxref{Tool
Bar}).  The specified function is called with one argument, the help
string to display, which is passed through
@code{substitute-command-keys} before being given to the function; see
@ref{Keys in Documentation}.  Tooltip mode (@pxref{Tooltips,,, emacs,
The GNU Emacs Manual}) provides an example.
@end defvar

@node Format Properties
@subsection Formatted Text Properties

  These text properties affect the behavior of the fill commands.  They
are used for representing formatted text.  @xref{Filling}, and
@ref{Margins}.

@table @code
@item hard
If a newline character has this property, it is a ``hard'' newline.
The fill commands do not alter hard newlines and do not move words
across them.  However, this property takes effect only if the
@code{use-hard-newlines} minor mode is enabled.  @xref{Hard and Soft
Newlines,, Hard and Soft Newlines, emacs, The GNU Emacs Manual}.

@item right-margin
This property specifies an extra right margin for filling this part of the
text.

@item left-margin
This property specifies an extra left margin for filling this part of the
text.

@item justification
This property specifies the style of justification for filling this part
of the text.
@end table

@node Sticky Properties
@subsection Stickiness of Text Properties
@cindex sticky text properties
@cindex inheritance, text property

  Self-inserting characters, the ones that get inserted into a buffer
when the user types them (@pxref{Commands for Insertion}), normally
take on the same properties as the preceding character.  This is
called @dfn{inheritance} of properties.

  By contrast, a Lisp program can do insertion with inheritance or without,
depending on the choice of insertion primitive.  The ordinary text
insertion functions, such as @code{insert}, do not inherit any
properties.  They insert text with precisely the properties of the
string being inserted, and no others.  This is correct for programs
that copy text from one context to another---for example, into or out
of the kill ring.  To insert with inheritance, use the special
primitives described in this section.  Self-inserting characters
inherit properties because they work using these primitives.

  When you do insertion with inheritance, @emph{which} properties are
inherited, and from where, depends on which properties are @dfn{sticky}.
Insertion after a character inherits those of its properties that are
@dfn{rear-sticky}.  Insertion before a character inherits those of its
properties that are @dfn{front-sticky}.  When both sides offer different
sticky values for the same property, the previous character's value
takes precedence.

  By default, a text property is rear-sticky but not front-sticky; thus,
the default is to inherit all the properties of the preceding character,
and nothing from the following character.

  You can control the stickiness of various text properties with two
specific text properties, @code{front-sticky} and @code{rear-nonsticky},
and with the variable @code{text-property-default-nonsticky}.  You can
use the variable to specify a different default for a given property.
You can use those two text properties to make any specific properties
sticky or nonsticky in any particular part of the text.

  If a character's @code{front-sticky} property is @code{t}, then all
its properties are front-sticky.  If the @code{front-sticky} property is
a list, then the sticky properties of the character are those whose
names are in the list.  For example, if a character has a
@code{front-sticky} property whose value is @code{(face read-only)},
then insertion before the character can inherit its @code{face} property
and its @code{read-only} property, but no others.

  The @code{rear-nonsticky} property works the opposite way.  Most
properties are rear-sticky by default, so the @code{rear-nonsticky}
property says which properties are @emph{not} rear-sticky.  If a
character's @code{rear-nonsticky} property is @code{t}, then none of its
properties are rear-sticky.  If the @code{rear-nonsticky} property is a
list, properties are rear-sticky @emph{unless} their names are in the
list.

@defvar text-property-default-nonsticky
This variable holds an alist which defines the default rear-stickiness
of various text properties.  Each element has the form
@code{(@var{property} . @var{nonstickiness})}, and it defines the
stickiness of a particular text property, @var{property}.

If @var{nonstickiness} is не-@code{nil}, this means that the property
@var{property} is rear-nonsticky by default.  Since all properties are
front-nonsticky by default, this makes @var{property} nonsticky in both
directions by default.

The text properties @code{front-sticky} and @code{rear-nonsticky}, when
used, take precedence over the default @var{nonstickiness} specified in
@code{text-property-default-nonsticky}.
@end defvar

  Here are the functions that insert text with inheritance of properties:

@defun insert-and-inherit &rest strings
Insert the strings @var{strings}, just like the function @code{insert},
but inherit any sticky properties from the adjoining text.
@end defun

@defun insert-before-markers-and-inherit &rest strings
Insert the strings @var{strings}, just like the function
@code{insert-before-markers}, but inherit any sticky properties from the
adjoining text.
@end defun

  @xref{Insertion}, for the ordinary insertion functions which do not
inherit.

@node Lazy Properties
@subsection Lazy Computation of Text Properties

  Instead of computing text properties for all the text in the buffer,
you can arrange to compute the text properties for parts of the text
when and if something depends on them.

  The primitive that extracts text from the buffer along with its
properties is @code{buffer-substring}.  Before examining the properties,
this function runs the abnormal hook @code{buffer-access-fontify-functions}.

@defvar buffer-access-fontify-functions
This variable holds a list of functions for computing text properties.
Before @code{buffer-substring} copies the text and text properties for a
portion of the buffer, it calls all the functions in this list.  Each of
the functions receives two arguments that specify the range of the
buffer being accessed.  (The buffer itself is always the current
buffer.)
@end defvar

  The function @code{buffer-substring-no-properties} does not call these
functions, since it ignores text properties anyway.

  In order to prevent the hook functions from being called more than
once for the same part of the buffer, you can use the variable
@code{buffer-access-fontified-property}.

@defvar buffer-access-fontified-property
If this variable's value is не-@code{nil}, it is a symbol which is used
as a text property name.  A не-@code{nil} value for that text property
means the other text properties for this character have already been
computed.

If all the characters in the range specified for @code{buffer-substring}
have a не-@code{nil} value for this property, @code{buffer-substring}
does not call the @code{buffer-access-fontify-functions} functions.  It
assumes these characters already have the right text properties, and
just copies the properties they already have.

The normal way to use this feature is that the
@code{buffer-access-fontify-functions} functions add this property, as
well as others, to the characters they operate on.  That way, they avoid
being called over and over for the same text.
@end defvar

@node Clickable Text
@subsection Defining Clickable Text
@cindex clickable text
@cindex follow links
@cindex mouse-1

  @dfn{Clickable text} is text that can be clicked, with either the
mouse or via a keyboard command, to produce some result.  Many major
modes use clickable text to implement textual hyper-links, or
@dfn{links} for short.

  The easiest way to insert and manipulate links is to use the
@code{button} package.  @xref{Buttons}.  In this section, we will
explain how to manually set up clickable text in a buffer, using text
properties.  For simplicity, we will refer to the clickable text as a
@dfn{link}.

  Implementing a link involves three separate steps: (1) indicating
clickability when the mouse moves over the link; (2) making @key{RET}
or @kbd{mouse-2} on that link do something; and (3) setting up a
@code{follow-link} condition so that the link obeys
@code{mouse-1-click-follows-link}.

  To indicate clickability, add the @code{mouse-face} text property to
the text of the link; then Emacs will highlight the link when the
mouse moves over it.  In addition, you should define a tooltip or echo
area message, using the @code{help-echo} text property.  @xref{Special
Properties}.  For instance, here is how Dired indicates that file
names are clickable:

@smallexample
 (if (dired-move-to-filename)
     (add-text-properties
       (point)
       (save-excursion
         (dired-move-to-end-of-filename)
         (point))
       '(mouse-face highlight
         help-echo "mouse-2: visit this file in other window")))
@end smallexample

  To make the link clickable, bind @key{RET} and @kbd{mouse-2} to
commands that perform the desired action.  Each command should check
to see whether it was called on a link, and act accordingly.  For
instance, Dired's major mode keymap binds @kbd{mouse-2} to the
following command:

@smallexample
(defun dired-mouse-find-file-other-window (event)
  "In Dired, visit the file or directory name you click on."
  (interactive "e")
  (let ((window (posn-window (event-end event)))
        (pos (posn-point (event-end event)))
        file)
    (if (not (windowp window))
        (error "No file chosen"))
    (with-current-buffer (window-buffer window)
      (goto-char pos)
      (setq file (dired-get-file-for-visit)))
    (if (file-directory-p file)
        (or (and (cdr dired-subdir-alist)
                 (dired-goto-subdir file))
            (progn
              (select-window window)
              (dired-other-window file)))
      (select-window window)
      (find-file-other-window (file-name-sans-versions file t)))))
@end smallexample

@noindent
This command uses the functions @code{posn-window} and
@code{posn-point} to determine where the click occurred, and
@code{dired-get-file-for-visit} to determine which file to visit.

  Instead of binding the mouse command in a major mode keymap, you can
bind it within the link text, using the @code{keymap} text property
(@pxref{Special Properties}).  For instance:

@example
(let ((map (make-sparse-keymap)))
  (define-key map [mouse-2] 'operate-this-button)
  (put-text-property link-start link-end 'keymap map))
@end example

@noindent
With this method, you can easily define different commands for
different links.  Furthermore, the global definition of @key{RET} and
@kbd{mouse-2} remain available for the rest of the text in the buffer.

@vindex mouse-1-click-follows-link
  The basic Emacs command for clicking on links is @kbd{mouse-2}.
However, for compatibility with other graphical applications, Emacs
also recognizes @kbd{mouse-1} clicks on links, provided the user
clicks on the link quickly without moving the mouse.  This behavior is
controlled by the user option @code{mouse-1-click-follows-link}.
@xref{Mouse References,,, emacs, The GNU Emacs Manual}.

@kindex follow-link @r{(text or overlay property)}
  To set up the link so that it obeys
@code{mouse-1-click-follows-link}, you must either (1) apply a
@code{follow-link} text or overlay property to the link text, or (2)
bind the @code{follow-link} event to a keymap (which can be a major
mode keymap or a local keymap specified via the @code{keymap} text
property).  The value of the @code{follow-link} property, or the
binding for the @code{follow-link} event, acts as a condition for
the link action.  This condition tells Emacs two things: the
circumstances under which a @kbd{mouse-1} click should be regarded as
occurring inside the link, and how to compute an action code
that says what to translate the @kbd{mouse-1} click into.  The link
action condition can be one of the following:

@table @asis
@item @code{mouse-face}
If the condition is the symbol @code{mouse-face}, a position is inside
a link if there is a не-@code{nil} @code{mouse-face} property at that
position.  The action code is always @code{t}.

For example, here is how Info mode handles @key{mouse-1}:

@smallexample
(define-key Info-mode-map [follow-link] 'mouse-face)
@end smallexample

@item a function
If the condition is a function, @var{func}, then a position @var{pos}
is inside a link if @code{(@var{func} @var{pos})} evaluates to
не-@code{nil}.  The value returned by @var{func} serves as the action
code.

For example, here is how pcvs enables @kbd{mouse-1} to follow links on
file names only:

@smallexample
(define-key map [follow-link]
  (lambda (pos)
    (eq (get-char-property pos 'face) 'cvs-filename-face)))
@end smallexample

@item anything else
If the condition value is anything else, then the position is inside a
link and the condition itself is the action code.  Clearly, you should
specify this kind of condition only when applying the condition via a
text or property overlay on the link text (so that it does not apply
to the entire buffer).
@end table

@noindent
The action code tells @kbd{mouse-1} how to follow the link:

@table @asis
@item a string or vector
If the action code is a string or vector, the @kbd{mouse-1} event is
translated into the first element of the string or vector; i.e., the
action of the @kbd{mouse-1} click is the local or global binding of
that character or symbol.  Thus, if the action code is @code{"foo"},
@kbd{mouse-1} translates into @kbd{f}.  If it is @code{[foo]},
@kbd{mouse-1} translates into @key{foo}.

@item anything else
For any other не-@code{nil} action code, the @kbd{mouse-1} event is
translated into a @kbd{mouse-2} event at the same position.
@end table

  To define @kbd{mouse-1} to activate a button defined with
@code{define-button-type}, give the button a @code{follow-link}
property.  The property value should be a link action condition, as
described above.  @xref{Buttons}.  For example, here is how Help mode
handles @kbd{mouse-1}:

@smallexample
(define-button-type 'help-xref
  'follow-link t
  'action #'help-button-action)
@end smallexample

  To define @kbd{mouse-1} on a widget defined with
@code{define-widget}, give the widget a @code{:follow-link} property.
The property value should be a link action condition, as described
above.  For example, here is how the @code{link} widget specifies that
a @key{mouse-1} click shall be translated to @key{RET}:

@smallexample
(define-widget 'link 'item
  "An embedded link."
  :button-prefix 'widget-link-prefix
  :button-suffix 'widget-link-suffix
  :follow-link "\C-m"
  :help-echo "Follow the link."
  :format "%[%t%]")
@end smallexample

@defun mouse-on-link-p pos
This function returns не-@code{nil} if position @var{pos} in the
current buffer is on a link.  @var{pos} can also be a mouse event
location, as returned by @code{event-start} (@pxref{Accessing Mouse}).
@end defun

@node Fields
@subsection Defining and Using Fields
@cindex fields

  A field is a range of consecutive characters in the buffer that are
identified by having the same value (comparing with @code{eq}) of the
@code{field} property (either a text-property or an overlay property).
This section describes special functions that are available for
operating on fields.

  You specify a field with a buffer position, @var{pos}.  We think of
each field as containing a range of buffer positions, so the position
you specify stands for the field containing that position.

  When the characters before and after @var{pos} are part of the same
field, there is no doubt which field contains @var{pos}: the one those
characters both belong to.  When @var{pos} is at a boundary between
fields, which field it belongs to depends on the stickiness of the
@code{field} properties of the two surrounding characters (@pxref{Sticky
Properties}).  The field whose property would be inherited by text
inserted at @var{pos} is the field that contains @var{pos}.

  There is an anomalous case where newly inserted text at @var{pos}
would not inherit the @code{field} property from either side.  This
happens if the previous character's @code{field} property is not
rear-sticky, and the following character's @code{field} property is not
front-sticky.  In this case, @var{pos} belongs to neither the preceding
field nor the following field; the field functions treat it as belonging
to an empty field whose beginning and end are both at @var{pos}.

  In all of these functions, if @var{pos} is omitted or @code{nil}, the
value of point is used by default.  If narrowing is in effect, then
@var{pos} should fall within the accessible portion.  @xref{Narrowing}.

@defun field-beginning &optional pos escape-from-edge limit
This function returns the beginning of the field specified by @var{pos}.

If @var{pos} is at the beginning of its field, and
@var{escape-from-edge} is не-@code{nil}, then the return value is
always the beginning of the preceding field that @emph{ends} at @var{pos},
regardless of the stickiness of the @code{field} properties around
@var{pos}.

If @var{limit} is не-@code{nil}, it is a buffer position; if the
beginning of the field is before @var{limit}, then @var{limit} will be
returned instead.
@end defun

@defun field-end &optional pos escape-from-edge limit
This function returns the end of the field specified by @var{pos}.

If @var{pos} is at the end of its field, and @var{escape-from-edge} is
не-@code{nil}, then the return value is always the end of the following
field that @emph{begins} at @var{pos}, regardless of the stickiness of
the @code{field} properties around @var{pos}.

If @var{limit} is не-@code{nil}, it is a buffer position; if the end
of the field is after @var{limit}, then @var{limit} will be returned
instead.
@end defun

@defun field-string &optional pos
This function returns the contents of the field specified by @var{pos},
as a string.
@end defun

@defun field-string-no-properties &optional pos
This function returns the contents of the field specified by @var{pos},
as a string, discarding text properties.
@end defun

@defun delete-field &optional pos
This function deletes the text of the field specified by @var{pos}.
@end defun

@defun constrain-to-field new-pos old-pos &optional escape-from-edge only-in-line inhibit-capture-property
This function constrains @var{new-pos} to the field that
@var{old-pos} belongs to---in other words, it returns the position
closest to @var{new-pos} that is in the same field as @var{old-pos}.

If @var{new-pos} is @code{nil}, then @code{constrain-to-field} uses
the value of point instead, and moves point to the resulting position
in addition to returning that position.

If @var{old-pos} is at the boundary of two fields, then the acceptable
final positions depend on the argument @var{escape-from-edge}.  If
@var{escape-from-edge} is @code{nil}, then @var{new-pos} must be in
the field whose @code{field} property equals what new characters
inserted at @var{old-pos} would inherit.  (This depends on the
stickiness of the @code{field} property for the characters before and
after @var{old-pos}.)  If @var{escape-from-edge} is не-@code{nil},
@var{new-pos} can be anywhere in the two adjacent fields.
Additionally, if two fields are separated by another field with the
special value @code{boundary}, then any point within this special
field is also considered to be on the boundary.

Commands like @kbd{C-a} with no argument, that normally move backward
to a specific kind of location and stay there once there, probably
should specify @code{nil} for @var{escape-from-edge}.  Other motion
commands that check fields should probably pass @code{t}.

If the optional argument @var{only-in-line} is не-@code{nil}, and
constraining @var{new-pos} in the usual way would move it to a different
line, @var{new-pos} is returned unconstrained.  This used in commands
that move by line, such as @code{next-line} and
@code{beginning-of-line}, so that they respect field boundaries only in
the case where they can still move to the right line.

If the optional argument @var{inhibit-capture-property} is
не-@code{nil}, and @var{old-pos} has a не-@code{nil} property of that
name, then any field boundaries are ignored.

You can cause @code{constrain-to-field} to ignore all field boundaries
(and so never constrain anything) by binding the variable
@code{inhibit-field-text-motion} to a не-@code{nil} value.
@end defun

@node Not Intervals
@subsection Why Text Properties are not Intervals
@cindex intervals

  Some editors that support adding attributes to text in the buffer do
so by letting the user specify intervals within the text, and adding
the properties to the intervals.  Those editors permit the user or the
programmer to determine where individual intervals start and end.  We
deliberately provided a different sort of interface in Emacs Lisp to
avoid certain paradoxical behavior associated with text modification.

  If the actual subdivision into intervals is meaningful, that means you
can distinguish between a buffer that is just one interval with a
certain property, and a buffer containing the same text subdivided into
two intervals, both of which have that property.

  Suppose you take the buffer with just one interval and kill part of
the text.  The text remaining in the buffer is one interval, and the
copy in the kill ring (and the undo list) becomes a separate interval.
Then if you yank back the killed text, you get two intervals with the
same properties.  Thus, editing does not preserve the distinction
between one interval and two.

  Suppose we attempt to fix this problem by coalescing the two intervals when
the text is inserted.  That works fine if the buffer originally was a
single interval.  But suppose instead that we have two adjacent
intervals with the same properties, and we kill the text of one interval
and yank it back.  The same interval-coalescence feature that rescues
the other case causes trouble in this one: after yanking, we have just
one interval.  Once again, editing does not preserve the distinction
between one interval and two.

  Insertion of text at the border between intervals also raises
questions that have no satisfactory answer.

  However, it is easy to arrange for editing to behave consistently
for questions of the form, ``What are the properties of text at this
buffer or string position?''  So we have decided these are the only
questions that make sense; we have not implemented asking questions
about where intervals start or end.

  In practice, you can usually use the text property search functions in
place of explicit interval boundaries.  You can think of them as finding
the boundaries of intervals, assuming that intervals are always
coalesced whenever possible.  @xref{Property Search}.

  Emacs also provides explicit intervals as a presentation feature; see
@ref{Overlays}.

@node Substitution
@section Substituting for a Character Code
@cindex replace characters in region
@cindex substitute characters

  The following functions replace characters within a specified region
based on their character codes.

@defun subst-char-in-region start end old-char new-char &optional noundo
@cindex replace characters
This function replaces all occurrences of the character @var{old-char}
with the character @var{new-char} in the region of the current buffer
defined by @var{start} and @var{end}.

@cindex undo avoidance
If @var{noundo} is не-@code{nil}, then @code{subst-char-in-region} does
not record the change for undo and does not mark the buffer as modified.
This was useful for controlling the old selective display feature
(@pxref{Selective Display}).

@code{subst-char-in-region} does not move point and returns
@code{nil}.

@example
@group
---------- Buffer: foo ----------
This is the contents of the buffer before.
---------- Buffer: foo ----------
@end group

@group
(subst-char-in-region 1 20 ?i ?X)
     @result{} nil

---------- Buffer: foo ----------
ThXs Xs the contents of the buffer before.
---------- Buffer: foo ----------
@end group
@end example
@end defun

@deffn Command translate-region start end table
This function applies a translation table to the characters in the
buffer between positions @var{start} and @var{end}.

The translation table @var{table} is a string or a char-table;
@code{(aref @var{table} @var{ochar})} gives the translated character
corresponding to @var{ochar}.  If @var{table} is a string, any
characters with codes larger than the length of @var{table} are not
altered by the translation.

The return value of @code{translate-region} is the number of
characters that were actually changed by the translation.  This does
not count characters that were mapped into themselves in the
translation table.
@end deffn

@node Registers
@section Registers
@cindex registers

  A register is a sort of variable used in Emacs editing that can hold a
variety of different kinds of values.  Each register is named by a
single character.  All @acronym{ASCII} characters and their meta variants
(but with the exception of @kbd{C-g}) can be used to name registers.
Thus, there are 255 possible registers.  A register is designated in
Emacs Lisp by the character that is its name.

@defvar register-alist
This variable is an alist of elements of the form @code{(@var{name} .
@var{contents})}.  Normally, there is one element for each Emacs
register that has been used.

The object @var{name} is a character (an integer) identifying the
register.
@end defvar

  The @var{contents} of a register can have several possible types:

@table @asis
@item a number
A number stands for itself.  If @code{insert-register} finds a number
in the register, it converts the number to decimal.

@item a marker
A marker represents a buffer position to jump to.

@item a string
A string is text saved in the register.

@item a rectangle
@cindex rectangle, as contents of a register
A rectangle is represented by a list of strings.

@item @code{(@var{window-configuration} @var{position})}
This represents a window configuration to restore in one frame, and a
position to jump to in the current buffer.

@c FIXME: Mention frameset here.
@item @code{(@var{frame-configuration} @var{position})}
This represents a frame configuration to restore, and a position
to jump to in the current buffer.

@item (file @var{filename})
This represents a file to visit; jumping to this value visits file
@var{filename}.

@item (file-query @var{filename} @var{position})
This represents a file to visit and a position in it; jumping to this
value visits file @var{filename} and goes to buffer position
@var{position}.  Restoring this type of position asks the user for
confirmation first.
@end table

  The functions in this section return unpredictable values unless
otherwise stated.

@defun get-register reg
This function returns the contents of the register
@var{reg}, or @code{nil} if it has no contents.
@end defun

@defun set-register reg value
This function sets the contents of register @var{reg} to @var{value}.
A register can be set to any value, but the other register functions
expect only certain data types.  The return value is @var{value}.
@end defun

@deffn Command view-register reg
This command displays what is contained in register @var{reg}.
@end deffn

@deffn Command insert-register reg &optional beforep
This command inserts contents of register @var{reg} into the current
buffer.

Normally, this command puts point before the inserted text, and the
mark after it.  However, if the optional second argument @var{beforep}
is не-@code{nil}, it puts the mark before and point after.

When called interactively, the command defaults to putting point after
text, and a prefix argument inverts this behavior.

If the register contains a rectangle, then the rectangle is inserted
with its upper left corner at point.  This means that text is inserted
in the current line and underneath it on successive lines.

If the register contains something other than saved text (a string) or
a rectangle (a list), currently useless things happen.  This may be
changed in the future.
@end deffn

@defun register-read-with-preview prompt
@cindex register preview
This function reads and returns a register name, prompting with
@var{prompt} and possibly showing a preview of the existing registers
and their contents.  The preview is shown in a temporary window, after
the delay specified by the user option @code{register-preview-delay},
if its value and @code{register-alist} are both не-@code{nil}.  The
preview is also shown if the user requests help (e.g., by typing the
help character).  We recommend that all interactive commands which
read register names use this function.
@end defun

@node Transposition
@section Transposition of Text

  This function can be used to transpose stretches of text:

@defun transpose-regions start1 end1 start2 end2 &optional leave-markers
This function exchanges two nonoverlapping portions of the buffer (if
they overlap, the function signals an error).  Arguments @var{start1}
and @var{end1} specify the bounds of one portion and arguments
@var{start2} and @var{end2} specify the bounds of the other portion.

Normally, @code{transpose-regions} relocates markers with the transposed
text; a marker previously positioned within one of the two transposed
portions moves along with that portion, thus remaining between the same
two characters in their new position.  However, if @var{leave-markers}
is не-@code{nil}, @code{transpose-regions} does not do this---it leaves
all markers unrelocated.
@end defun

@node Replacing
@section Replacing Buffer Text

  You can use the following function to replace the text of one buffer
with the text of another buffer:

@deffn Command replace-buffer-contents source
This function replaces the accessible portion of the current buffer
with the accessible portion of the buffer @var{source}.  @var{source}
may either be a buffer object or the name of a buffer.  When
@code{replace-buffer-contents} succeeds, the text of the accessible
portion of the current buffer will be equal to the text of the
accessible portion of the @var{source} buffer.  This function attempts
to keep point, markers, text properties, and overlays in the current
buffer intact.  One potential case where this behavior is useful is
external code formatting programs: they typically write the
reformatted text into a temporary buffer or file, and using
@code{delete-region} and @code{insert-buffer-substring} would destroy
these properties.  However, the latter combination is typically
faster.  @xref{Deletion}, and @ref{Insertion}.
@end deffn

@node Decompression
@section Dealing With Compressed Data

When @code{auto-compression-mode} is enabled, Emacs automatically
uncompresses compressed files when you visit them, and automatically
recompresses them if you alter and save them.  @xref{Compressed
Files,,, emacs, The GNU Emacs Manual}.

The above feature works by calling an external executable (e.g.,
@command{gzip}).  Emacs can also be compiled with support for built-in
decompression using the zlib library, which is faster than calling an
external program.

@defun zlib-available-p
This function returns не-@code{nil} if built-in zlib decompression is
available.
@end defun

@defun zlib-decompress-region start end
This function decompresses the region between @var{start} and
@var{end}, using built-in zlib decompression.  The region should
contain data that were compressed with gzip or zlib.  On success, the
function replaces the contents of the region with the decompressed
data.  On failure, the function leaves the region unchanged and
returns @code{nil}.  This function can be called only in unibyte
buffers.
@end defun


@node Base 64
@section Base 64 Encoding
@cindex base 64 encoding

  Base 64 code is used in email to encode a sequence of 8-bit bytes as
a longer sequence of @acronym{ASCII} graphic characters.  It is defined in
Internet RFC@footnote{
An RFC, an acronym for @dfn{Request for Comments}, is a numbered
Internet informational document describing a standard.  RFCs are
usually written by technical experts acting on their own initiative,
and are traditionally written in a pragmatic, experience-driven
manner.
}2045.  This section describes the functions for
converting to and from this code.

@deffn Command base64-encode-region beg end &optional no-line-break
This function converts the region from @var{beg} to @var{end} into base
64 code.  It returns the length of the encoded text.  An error is
signaled if a character in the region is multibyte, i.e., in a
multibyte buffer the region must contain only characters from the
charsets @code{ascii}, @code{eight-bit-control} and
@code{eight-bit-graphic}.

Normally, this function inserts newline characters into the encoded
text, to avoid overlong lines.  However, if the optional argument
@var{no-line-break} is не-@code{nil}, these newlines are not added, so
the output is just one long line.
@end deffn

@defun base64-encode-string string &optional no-line-break
This function converts the string @var{string} into base 64 code.  It
returns a string containing the encoded text.  As for
@code{base64-encode-region}, an error is signaled if a character in the
string is multibyte.

Normally, this function inserts newline characters into the encoded
text, to avoid overlong lines.  However, if the optional argument
@var{no-line-break} is не-@code{nil}, these newlines are not added, so
the result string is just one long line.
@end defun

@deffn Command base64-decode-region beg end
This function converts the region from @var{beg} to @var{end} from base
64 code into the corresponding decoded text.  It returns the length of
the decoded text.

The decoding functions ignore newline characters in the encoded text.
@end deffn

@defun base64-decode-string string
This function converts the string @var{string} from base 64 code into
the corresponding decoded text.  It returns a unibyte string containing the
decoded text.

The decoding functions ignore newline characters in the encoded text.
@end defun

@node Checksum/Hash
@section Checksum/Hash
@cindex MD5 checksum
@cindex SHA hash
@cindex hash, cryptographic
@cindex cryptographic hash

  Emacs has built-in support for computing @dfn{cryptographic hashes}.
A cryptographic hash, or @dfn{checksum}, is a digital fingerprint
of a piece of data (e.g., a block of text) which can be used to check
that you have an unaltered copy of that data.

@cindex message digest
  Emacs supports several common cryptographic hash algorithms: MD5,
SHA-1, SHA-2, SHA-224, SHA-256, SHA-384 and SHA-512.  MD5 is the
oldest of these algorithms, and is commonly used in @dfn{message
digests} to check the integrity of messages transmitted over a
network.  MD5 is not collision resistant (i.e., it is possible to
deliberately design different pieces of data which have the same MD5
hash), so you should not used it for anything security-related.  A
similar theoretical weakness also exists in SHA-1.  Therefore, for
security-related applications you should use the other hash types,
such as SHA-2.

@defun secure-hash-algorithms
This function returns a list of symbols representing algorithms that
@code{secure-hash} can use.
@end defun

@defun secure-hash algorithm object &optional start end binary
This function returns a hash for @var{object}.  The argument
@var{algorithm} is a symbol stating which hash to compute: one of
@code{md5}, @code{sha1}, @code{sha224}, @code{sha256}, @code{sha384}
or @code{sha512}.  The argument @var{object} should be a buffer or a
string.

The optional arguments @var{start} and @var{end} are character
positions specifying the portion of @var{object} to compute the
message digest for.  If they are @code{nil} or omitted, the hash is
computed for the whole of @var{object}.

If the argument @var{binary} is omitted or @code{nil}, the function
returns the @dfn{text form} of the hash, as an ordinary Lisp string.
If @var{binary} is не-@code{nil}, it returns the hash in @dfn{binary
form}, as a sequence of bytes stored in a unibyte string.

This function does not compute the hash directly from the internal
representation of @var{object}'s text (@pxref{Text Representations}).
Instead, it encodes the text using a coding system (@pxref{Coding
Systems}), and computes the hash from that encoded text.  If
@var{object} is a buffer, the coding system used is the one which
would be chosen by default for writing the text into a file.  If
@var{object} is a string, the user's preferred coding system is used
(@pxref{Recognize Coding,,, emacs, GNU Emacs Manual}).
@end defun

@defun md5 object &optional start end coding-system noerror
This function returns an MD5 hash.  It is semi-obsolete, since for
most purposes it is equivalent to calling @code{secure-hash} with
@code{md5} as the @var{algorithm} argument.  The @var{object},
@var{start} and @var{end} arguments have the same meanings as in
@code{secure-hash}.

If @var{coding-system} is не-@code{nil}, it specifies a coding system
to use to encode the text; if omitted or @code{nil}, the default
coding system is used, like in @code{secure-hash}.

Normally, @code{md5} signals an error if the text can't be encoded
using the specified or chosen coding system.  However, if
@var{noerror} is не-@code{nil}, it silently uses @code{raw-text}
coding instead.
@end defun

@defun buffer-hash &optional buffer-or-name
Return a hash of @var{buffer-or-name}.  If @code{nil}, this defaults
to the current buffer.  As opposed to @code{secure-hash}, this
function computes the hash based on the internal representation of the
buffer, disregarding any coding systems.  It's therefore only useful
when comparing two buffers running in the same Emacs, and is not
guaranteed to return the same hash between different Emacs versions.
It should be somewhat more efficient on larger buffers than
@code{secure-hash} is, and should not allocate more memory.
@c Note that we do not document what hashing function we're using, or
@c even whether it's a cryptographic hash, since that may change
@c according to what we find useful.
@end defun

@node GnuTLS Cryptography
@section GnuTLS Cryptography
@cindex MD5 checksum
@cindex SHA hash
@cindex hash, cryptographic
@cindex cryptographic hash
@cindex AEAD cipher
@cindex cipher, AEAD
@cindex symmetric cipher
@cindex cipher, symmetric

If compiled with GnuTLS, Emacs offers built-in cryptographic support.
Following the GnuTLS API terminology, the available tools are digests,
MACs, symmetric ciphers, and AEAD ciphers.

The terms used herein, such as IV (Initialization Vector), require
some familiarity with cryptography and will not be defined in detail.
Please consult @uref{https://www.gnutls.org/} for specific
documentation which may help you understand the terminology and
structure of the GnuTLS library.

@menu
* Format of GnuTLS Cryptography Inputs::
* GnuTLS Cryptographic Functions::
@end menu

@node Format of GnuTLS Cryptography Inputs
@subsection Format of GnuTLS Cryptography Inputs
@cindex format of gnutls cryptography inputs
@cindex gnutls cryptography inputs format

The inputs to GnuTLS cryptographic functions can be specified in
several ways, both as primitive Emacs Lisp types or as lists.

The list form is currently similar to how @code{md5} and
@code{secure-hash} operate.

@table @code
@item @var{buffer}
Simply passing a buffer as input means the whole buffer should be used.

@item @var{string}
A string as input will be used directly.  It may be modified by the
function (unlike most other Emacs Lisp functions) to reduce the chance
of exposing sensitive data after the function does its work.

@item (@var{buffer-or-string} @var{start} @var{end} @var{coding-system} @var{noerror})
This specifies a buffer or a string as described above, but an
optional range can be specified with @var{start} and @var{end}.

In addition an optional @var{coding-system} can be specified if needed.

The last optional item, @var{noerror}, overrides the normal error when
the text can't be encoded using the specified or chosen coding system.
When @var{noerror} is не-@code{nil}, this function silently uses
@code{raw-text} coding instead.

@item (@code{iv-auto} @var{length})
This will generate an IV (Initialization Vector) of the specified
length using the GnuTLS @code{GNUTLS_RND_NONCE} generator and pass it
to the function.  This ensures that the IV is unpredictable and
unlikely to be reused in the same session.  The actual value of the IV
is returned by the function as described below.

@end table

@node GnuTLS Cryptographic Functions
@subsection GnuTLS Cryptographic Functions
@cindex gnutls cryptographic functions

@defun gnutls-digests
This function returns the alist of the GnuTLS digest algorithms.

Each entry has a key which represents the algorithm, followed by a
plist with internal details about the algorithm.  The plist will have
@code{:type gnutls-digest-algorithm} and also will have the key
@code{:digest-algorithm-length 64} to indicate the size, in bytes, of
the resulting digest.

There is a name parallel between GnuTLS MAC and digest algorithms but
they are separate things internally and should not be mixed.
@end defun

@defun gnutls-hash-digest digest-method input
The @var{digest-method} can be the whole plist from
@code{gnutls-digests}, or just the symbol key, or a string with the
name of that symbol.

The @var{input} can be specified as a buffer or string or in other
ways (@pxref{Format of GnuTLS Cryptography Inputs}).

This function returns @code{nil} on error, and signals a Lisp error if
the @var{digest-method} or @var{input} are invalid.  On success, it
returns a list of a binary string (the output) and the IV used.
@end defun

@defun gnutls-macs
This function returns the alist of the GnuTLS MAC algorithms.

Each entry has a key which represents the algorithm, followed by a
plist with internal details about the algorithm.  The plist will have
@code{:type gnutls-mac-algorithm} and also will have the keys
@code{:mac-algorithm-length} @code{:mac-algorithm-keysize}
@code{:mac-algorithm-noncesize} to indicate the size, in bytes, of the
resulting hash, the key, and the nonce respectively.

The nonce is currently unused and only some MACs support it.

There is a name parallel between GnuTLS MAC and digest algorithms but
they are separate things internally and should not be mixed.
@end defun

@defun gnutls-hash-mac hash-method key input
The @var{hash-method} can be the whole plist from
@code{gnutls-macs}, or just the symbol key, or a string with the
name of that symbol.

The @var{key} can be specified as a buffer or string or in other ways
(@pxref{Format of GnuTLS Cryptography Inputs}).  The @var{key} will be
wiped after use if it's a string.

The @var{input} can be specified as a buffer or string or in other
ways (@pxref{Format of GnuTLS Cryptography Inputs}).

This function returns @code{nil} on error, and signals a Lisp error if
the @var{hash-method} or @var{key} or @var{input} are invalid.

On success, it returns a list of a binary string (the output) and the
IV used.
@end defun

@defun gnutls-ciphers
This function returns the alist of the GnuTLS ciphers.

Each entry has a key which represents the cipher, followed by a plist
with internal details about the algorithm.  The plist will have
@code{:type gnutls-symmetric-cipher} and also will have the keys
@code{:cipher-aead-capable} set to @code{nil} or @code{t} to indicate
AEAD capability; and @code{:cipher-tagsize} @code{:cipher-blocksize}
@code{:cipher-keysize} @code{:cipher-ivsize} to indicate the size, in
bytes, of the tag, block size of the resulting data, the key, and the
IV respectively.
@end defun

@defun gnutls-symmetric-encrypt cipher key iv input &optional aead_auth
The @var{cipher} can be the whole plist from
@code{gnutls-ciphers}, or just the symbol key, or a string with the
name of that symbol.

The @var{key} can be specified as a buffer or string or in other ways
(@pxref{Format of GnuTLS Cryptography Inputs}).  The @var{key} will be
wiped after use if it's a string.

The @var{iv} and @var{input} and the optional @var{aead_auth} can be
specified as a buffer or string or in other ways (@pxref{Format of
GnuTLS Cryptography Inputs}).

@var{aead_auth} is only checked with AEAD ciphers, that is, ciphers whose
plist has @code{:cipher-aead-capable t}.  Otherwise it's ignored.

This function returns @code{nil} on error, and signals a Lisp error if
the @var{cipher} or @var{key}, @var{iv}, or @var{input} are invalid,
or if @var{aead_auth} was specified with an AEAD cipher and was
invalid.

On success, it returns a list of a binary string (the output) and the
IV used.
@end defun

@defun gnutls-symmetric-decrypt cipher key iv input &optional aead_auth
The @var{cipher} can be the whole plist from
@code{gnutls-ciphers}, or just the symbol key, or a string with the
name of that symbol.

The @var{key} can be specified as a buffer or string or in other ways
(@pxref{Format of GnuTLS Cryptography Inputs}).  The @var{key} will be
wiped after use if it's a string.

The @var{iv} and @var{input} and the optional @var{aead_auth} can be
specified as a buffer or string or in other ways (@pxref{Format of
GnuTLS Cryptography Inputs}).

@var{aead_auth} is only checked with AEAD ciphers, that is, ciphers whose
plist has @code{:cipher-aead-capable t}.  Otherwise it's ignored.

This function returns @code{nil} on decryption error, and signals a
Lisp error if the @var{cipher} or @var{key}, @var{iv}, or @var{input}
are invalid, or if @var{aead_auth} was specified with an AEAD cipher
and was invalid.

On success, it returns a list of a binary string (the output) and the
IV used.
@end defun

@node Parsing HTML/XML
@section Parsing HTML and XML
@cindex parsing html

When Emacs is compiled with libxml2 support, the following functions
are available to parse HTML or XML text into Lisp object trees.

@defun libxml-parse-html-region start end &optional base-url discard-comments
This function parses the text between @var{start} and @var{end} as
HTML, and returns a list representing the HTML @dfn{parse tree}.  It
attempts to handle real-world HTML by robustly coping with syntax
mistakes.

The optional argument @var{base-url}, if не-@code{nil}, should be a
string specifying the base URL for relative URLs occurring in links.

If the optional argument @var{discard-comments} is не-@code{nil},
then the parse tree is created without any comments.

In the parse tree, each HTML node is represented by a list in which
the first element is a symbol representing the node name, the second
element is an alist of node attributes, and the remaining elements are
the subnodes.

The following example demonstrates this.  Given this (malformed) HTML
document:

@example
<html><head></head><body width=101><div class=thing>Foo<div>Yes
@end example

@noindent
A call to @code{libxml-parse-html-region} returns this @acronym{DOM}
(document object model):

@example
(html nil
 (head nil)
 (body ((width . "101"))
  (div ((class . "thing"))
   "Foo"
   (div nil
    "Yes"))))
@end example
@end defun

@cindex rendering html
@defun shr-insert-document dom
This function renders the parsed HTML in @var{dom} into the current
buffer.  The argument @var{dom} should be a list as generated by
@code{libxml-parse-html-region}.  This function is, e.g., used by
@ref{Top, EWW,, eww, The Emacs Web Wowser Manual}.
@end defun

@cindex parsing xml
@defun libxml-parse-xml-region start end &optional base-url discard-comments
This function is the same as @code{libxml-parse-html-region}, except
that it parses the text as XML rather than HTML (so it is stricter
about syntax).
@end defun

@menu
* Document Object Model:: Access, manipulate and search the @acronym{DOM}.
@end menu

@node Document Object Model
@subsection Document Object Model
@cindex HTML DOM
@cindex XML DOM
@cindex DOM
@cindex Document Object Model

The @acronym{DOM} returned by @code{libxml-parse-html-region} (and the
other @acronym{XML} parsing functions) is a tree structure where each
node has a node name (called a @dfn{tag}), and optional key/value
@dfn{attribute} list, and then a list of @dfn{child nodes}.  The child
nodes are either strings or @acronym{DOM} objects.

@example
(body ((width . "101"))
 (div ((class . "thing"))
  "Foo"
  (div nil
   "Yes")))
@end example

@defun dom-node tag &optional attributes &rest children
This function creates a @acronym{DOM} node of type @var{tag}.  If
given, @var{attributes} should be a key/value pair list.
If given, @var{children} should be @acronym{DOM} nodes.
@end defun

The following functions can be used to work with this structure.  Each
function takes a @acronym{DOM} node, or a list of nodes.  In the
latter case, only the first node in the list is used.

Simple accessors:

@table @code
@item dom-tag @var{node}
Return the @dfn{tag} (also called ``node name'') of the node.

@item dom-attr @var{node} @var{attribute}
Return the value of @var{attribute} in the node.  A common usage
would be:

@lisp
(dom-attr img 'href)
=> "https://fsf.org/logo.png"
@end lisp

@item dom-children @var{node}
Return all the children of the node.

@item dom-non-text-children @var{node}
Return all the non-string children of the node.

@item dom-attributes @var{node}
Return the key/value pair list of attributes of the node.

@item dom-text @var{node}
Return all the textual elements of the node as a concatenated string.

@item dom-texts @var{node}
Return all the textual elements of the node, as well as the textual
elements of all the children of the node, recursively, as a
concatenated string.  This function also takes an optional separator
to be inserted between the textual elements.

@item dom-parent @var{dom} @var{node}
Return the parent of @var{node} in @var{dom}.

@item dom-remove @var{dom} @var{node}
Remove @var{node} from @var{dom}.
@end table

The following are functions for altering the @acronym{DOM}.

@table @code
@item dom-set-attribute @var{node} @var{attribute} @var{value}
Set the @var{attribute} of the node to @var{value}.

@item dom-append-child @var{node} @var{child}
Append @var{child} as the last child of @var{node}.

@item dom-add-child-before @var{node} @var{child} @var{before}
Add @var{child} to @var{node}'s child list before the @var{before}
node.  If @var{before} is @code{nil}, make @var{child} the first child.

@item dom-set-attributes @var{node} @var{attributes}
Replace all the attributes of the node with a new key/value list.
@end table

The following are functions for searching for elements in the
@acronym{DOM}.  They all return lists of matching nodes.

@table @code
@item dom-by-tag @var{dom} @var{tag}
Return all nodes in @var{dom} that are of type @var{tag}.  A typical
use would be:

@lisp
(dom-by-tag dom 'td)
=> '((td ...) (td ...) (td ...))
@end lisp

@item dom-by-class @var{dom} @var{match}
Return all nodes in @var{dom} that have class names that match
@var{match}, which is a regular expression.

@item dom-by-style @var{dom} @var{style}
Return all nodes in @var{dom} that have styles that match @var{match},
which is a regular expression.

@item dom-by-id @var{dom} @var{style}
Return all nodes in @var{dom} that have IDs that match @var{match},
which is a regular expression.

@item dom-strings @var{dom}
Return all strings in @var{dom}.

@end table

Utility functions:

@table @code
@item dom-pp @var{dom} &optional @var{remove-empty}
Pretty-print @var{dom} at point.  If @var{remove-empty}, don't print
textual nodes that just contain white-space.
@end table


@node Atomic Changes
@section Atomic Change Groups
@cindex atomic changes

  In database terminology, an @dfn{atomic} change is an indivisible
change---it can succeed entirely or it can fail entirely, but it
cannot partly succeed.  A Lisp program can make a series of changes to
one or several buffers as an @dfn{atomic change group}, meaning that
either the entire series of changes will be installed in their buffers
or, in case of an error, none of them will be.

  To do this for one buffer, the one already current, simply write a
call to @code{atomic-change-group} around the code that makes the
changes, like this:

@example
(atomic-change-group
  (insert foo)
  (delete-region x y))
@end example

@noindent
If an error (or other nonlocal exit) occurs inside the body of
@code{atomic-change-group}, it unmakes all the changes in that buffer
that were during the execution of the body.  This kind of change group
has no effect on any other buffers---any such changes remain.

  If you need something more sophisticated, such as to make changes in
various buffers constitute one atomic group, you must directly call
lower-level functions that @code{atomic-change-group} uses.

@defun prepare-change-group &optional buffer
This function sets up a change group for buffer @var{buffer}, which
defaults to the current buffer.  It returns a handle that
represents the change group.  You must use this handle to activate the
change group and subsequently to finish it.
@end defun

  To use the change group, you must @dfn{activate} it.  You must do
this before making any changes in the text of @var{buffer}.

@defun activate-change-group handle
This function activates the change group that @var{handle} designates.
@end defun

  After you activate the change group, any changes you make in that
buffer become part of it.  Once you have made all the desired changes
in the buffer, you must @dfn{finish} the change group.  There are two
ways to do this: you can either accept (and finalize) all the changes,
or cancel them all.

@defun accept-change-group handle
This function accepts all the changes in the change group specified by
@var{handle}, making them final.
@end defun

@defun cancel-change-group handle
This function cancels and undoes all the changes in the change group
specified by @var{handle}.
@end defun

  Your code should use @code{unwind-protect} to make sure the group is
always finished.  The call to @code{activate-change-group} should be
inside the @code{unwind-protect}, in case the user types @kbd{C-g}
just after it runs.  (This is one reason why
@code{prepare-change-group} and @code{activate-change-group} are
separate functions, because normally you would call
@code{prepare-change-group} before the start of that
@code{unwind-protect}.)  Once you finish the group, don't use the
handle again---in particular, don't try to finish the same group
twice.

  To make a multibuffer change group, call @code{prepare-change-group}
once for each buffer you want to cover, then use @code{nconc} to
combine the returned values, like this:

@example
(nconc (prepare-change-group buffer-1)
       (prepare-change-group buffer-2))
@end example

You can then activate the multibuffer change group with a single call
to @code{activate-change-group}, and finish it with a single call to
@code{accept-change-group} or @code{cancel-change-group}.

  Nested use of several change groups for the same buffer works as you
would expect.  Non-nested use of change groups for the same buffer
will get Emacs confused, so don't let it happen; the first change
group you start for any given buffer should be the last one finished.

@node Change Hooks
@section Change Hooks
@cindex change hooks
@cindex hooks for text changes

  These hook variables let you arrange to take notice of changes in
buffers (or in a particular buffer, if you make them buffer-local).
See also @ref{Special Properties}, for how to detect changes to
specific parts of the text.

  The functions you use in these hooks should save and restore the match
data if they do anything that uses regular expressions; otherwise, they
will interfere in bizarre ways with the editing operations that call
them.

@defvar before-change-functions
This variable holds a list of functions to call when Emacs is about to
modify a buffer.  Each function gets two arguments, the beginning and
end of the region that is about to change, represented as integers.
The buffer that is about to change is always the current buffer when
the function is called.
@end defvar

@defvar after-change-functions
This variable holds a list of functions to call after Emacs modifies a
buffer.  Each function receives three arguments: the beginning and end
of the region just changed, and the length of the text that existed
before the change.  All three arguments are integers.  The buffer that
has been changed is always the current buffer when the function is
called.

The length of the old text is the difference between the buffer
positions before and after that text as it was before the change.  As
for the changed text, its length is simply the difference between the
first two arguments.
@end defvar

  Output of messages into the @file{*Messages*} buffer does not call
these functions, and neither do certain internal buffer changes, such
as changes in buffers created by Emacs internally for certain jobs,
that should not be visible to Lisp programs.

The vast majority of buffer changing primitives will call
@code{before-change-functions} and @code{after-change-functions} in
balanced pairs, once for each change, where the arguments to these
hooks exactly delimit the change being made.  Yet, hook functions
should not rely on this always being the case, because some complex
primitives call @code{before-change-functions} once before making
changes, and then call @code{after-change-functions} zero or more
times, depending on how many individual changes the primitive is
making.  When that happens, the arguments to
@code{before-change-functions} will enclose a region in which the
individual changes are made, but won't necessarily be the minimal such
region, and the arguments to each successive call of
@code{after-change-functions} will then delimit the part of text being
changed exactly.  In general, we advise to use either before- or the
after-change hooks, but not both.

@defmac combine-after-change-calls body@dots{}
The macro executes @var{body} normally, but arranges to call the
after-change functions just once for a series of several changes---if
that seems safe.

If a program makes several text changes in the same area of the buffer,
using the macro @code{combine-after-change-calls} around that part of
the program can make it run considerably faster when after-change hooks
are in use.  When the after-change hooks are ultimately called, the
arguments specify a portion of the buffer including all of the changes
made within the @code{combine-after-change-calls} body.

@strong{Warning:} You must not alter the values of
@code{after-change-functions} within
the body of a @code{combine-after-change-calls} form.

@strong{Warning:} if the changes you combine occur in widely scattered
parts of the buffer, this will still work, but it is not advisable,
because it may lead to inefficient behavior for some change hook
functions.
@end defmac

@defvar first-change-hook
This variable is a normal hook that is run whenever a buffer is changed
that was previously in the unmodified state.
@end defvar

@defvar inhibit-modification-hooks
If this variable is не-@code{nil}, all of the change hooks are
disabled; none of them run.  This affects all the hook variables
described above in this section, as well as the hooks attached to
certain special text properties (@pxref{Special Properties}) and overlay
properties (@pxref{Overlay Properties}).

Also, this variable is bound to не-@code{nil} while running those
same hook variables, so that by default modifying the buffer from
a modification hook does not cause other modification hooks to be run.
If you do want modification hooks to be run in a particular piece of
code that is itself run from a modification hook, then rebind locally
@code{inhibit-modification-hooks} to @code{nil}.
@end defvar
