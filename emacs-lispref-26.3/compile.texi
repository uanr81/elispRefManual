@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1994, 2001-2019 Free Software Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Byte Compilation
@chapter Байт Компиляция
@cindex byte compilation
@cindex byte-code
@cindex compilation (Emacs Lisp)

  В Emacs Lisp есть @dfn{компилятор}, который переводит функции, написанные
на Lisp, в специальное представление, называемое @dfn{байт-код}, которое
может выполняться более эффективно.  Компилятор заменяет определения функций
Lisp байт кодом.  Когда вызывается функция байт кода, ее определение
оценивается @dfn{байт-код интерпретатором}.

  Поскольку скомпилированный в байт код оценивается интерпретатором
байт-кода, вместо того, чтобы выполняться непосредственно аппаратным
обеспечением машины (как настоящий скомпилированный код), байт-код полностью
переносится с машины на машину без перекомпиляции.  Однако это не так
быстро, как настоящий скомпилированный код.

  В общем, любая версия Emacs может запускать скомпилированный байт-код,
созданный недавними более ранними версиями Emacs, но обратное неверно.

@vindex no-byte-compile
  Если не требуется, чтобы файл Lisp компилировался, нужно поместить в него
привязку локальной переменной файла для @code{no-byte-compile}, например::

@example
;; -*-no-byte-compile: t; -*-
@end example

@menu
* Speed of Byte-Code::          Пример ускорения после байт компиляции.
* Compilation Functions::       Функции байт компиляции.
* Docs and Compilation::        Динамическая загрузка строк документации.
* Dynamic Loading::             Динамическая загрузка отдельных функций.
* Eval During Compile::         Код, который оценивается при компиляции.
* Compiler Errors::             Обработка сообщений об ошибках компилятора.
* Byte-Code Objects::           Тип данных, используемый для функций с
                                байт компиляцией.
* Disassembly::                 Дизассемблирование байт-кода; как читать
                                байт-код.
@end menu

@node Speed of Byte-Code
@section Производительность Байт-Скомпилированного Кода

  Скомпилированная в байт-код функция не так эффективна, как примитивная
функция, написанная на C, но работает намного быстрее, чем версия,
написанная на Lisp.  Вот пример:

@example
@group
(defun silly-loop (n)
  "Возвращает время в секундах для выполнения N итераций цикла."
  (let ((t1 (float-time)))
    (while (> (setq n (1- n)) 0))
    (- (float-time) t1)))
@result{} silly-loop
@end group

@group
(silly-loop 50000000)
@result{} 10.235304117202759
@end group

@group
(byte-compile 'silly-loop)
@result{} @r{[Скомпилированный код не показан]}
@end group

@group
(silly-loop 50000000)
@result{} 3.705854892730713
@end group
@end example

  В этом примере интерпретируемому коду требовалось 10 секунд для запуска,
тогда как байт-коду требовалось менее 4 секунд.  Эти результаты являются
репрезентативными, но фактические результаты могут отличаться.

@node Compilation Functions
@section Функции Байт Компиляции
@cindex compilation functions

  Можно скомпилировать отдельную функцию или определение макроса с помощью
функции @code{byte-compile}.  Можно скомпилировать целый файл с
@code{byte-compile-file} или несколько файлов с
@code{byte-recompile-directory} или @code{batch-byte-compile}.

@vindex byte-compile-debug
  Иногда байт компилятор выдает предупреждения и/или сообщения об ошибках
(подробности - @pxref{Compiler Errors}).  Эти сообщения обычно записываются
в буфер под названием @file{*Compile-Log*}, который использует режим
компиляции.  @xref{Compilation Mode,,,emacs, The GNU Emacs Manual}.  Однако,
если переменная @code{byte-compile-debug} - не-@code{nil}, сообщения об
ошибках будут сигнализироваться как ошибки Lisp вместо (@pxref{Errors}).

@cindex macro compilation
  Осторожно при записи вызовов макросов в файлы, которые собираетесь
компилировать побайтно.  Поскольку вызовы макросов раскрываются при
компиляции, макросы нужно загружать в Emacs, иначе байтовый компилятор не
будет делать правильных действий.  Обычный способ справиться с этим -
использовать формы @code{require}, которые определяют файлы, содержащие
необходимые макроопределения (@pxref{Named Features}).  Обычно байтовый
компилятор не оценивает код, который он компилирует, но он обрабатывает
формы @code{require} специально, загружая указанные библиотеки.  Чтобы
избежать загрузки файлов определения макросов, когда кто-то @emph{runs}
скомпилированную программу, напишите @code{eval-when-compile} вокруг вызовов
@code{require} (@pxref{Eval During Compile}).  Подробнее
@xref{Compiling Macros}.

  Встроенные функции (@code{defsubst}) менее хлопотны; если скомпилирован
вызов такой функции до того, как станет известно ее определение, вызов все
равно будет работать правильно, просто он будет работать медленнее.

@defun byte-compile symbol
Эта функция байт компилирует определение функции @var{symbol}, заменяя
предыдущее определение скомпилированным.  Определение функции @var{symbol}
должно быть фактическим кодом функции; @code{byte-compile} не обрабатывает
косвенное обращение к функциям.  Возвращаемое значение - это объект функции
байт кода, который является скомпилированным определением @var{symbol}
(@pxref{Byte-Code Objects}).

@example
@group
(defun factorial (integer)
  "Вычислить факториал INTEGER."
  (if (= 1 integer) 1
    (* integer (factorial (1- integer)))))
@result{} factorial
@end group

@group
(byte-compile 'factorial)
@result{}
#[(integer)
  "^H\301U\203^H^@@\301\207\302^H\303^HS!\"\207"
  [integer 1 * factorial]
  4 "Вычислить факториал INTEGER."]
@end group
@end example

Если определение @var{symbol} является объектом функции с байт кодом,
@code{byte-compile} ничего не делает и возвращает @code{nil}.  Не
компилирует определение символа снова, поскольку исходный (не
скомпилированный) код уже был заменен в функциональной ячейке символа
компилированным байт кодом.

Аргументом @code{byte-compile} также может быть выражение @code{lambda}.  В
этом случае функция возвращает соответствующий скомпилированный код, но
нигде его не сохраняет.
@end defun

@deffn Command compile-defun &optional arg
Эта команда считывает определение, содержащее точку, компилирует ее и
оценивает результат.  Если используете это в defun, что на самом деле
является определением функции, результатом будет установка скомпилированной
версии этой функции.

@code{compile-defun} обычно отображает результат оценки в эхо-области, но
если @var{arg} равен не-@code{nil}, он вставляет результат в текущий буфер
после скомпилированной формы.
@end deffn

@deffn Command byte-compile-file filename &optional load
Эта функция компилирует файл с кодом Lisp с именем @var{filename} в файл с
байт кодом.  Имя выходного файла получается изменением суффикса @samp{.el}
на @samp{.elc}; если @var{filename} не заканчивается на @samp{.el},
добавляетcz @samp{.elc} в конец @var{filename}.

Компиляция работает путем чтения входного файла по одной форме за раз.  Если
это определение функции или макроса, записывается скомпилированное
определение функции или макроса.  Остальные формы объединяются в пакеты,
затем каждый пакет компилируется и записывается так, чтобы его
скомпилированный код выполнялся при чтении файла.  Все комментарии
отбрасываются при чтении входного файла.

Эта команда возвращает @code{t}, если ошибок не было, и @code{nil} в
противном случае.  При интерактивном вызове запрашивает имя файла.

Если @var{load} равен не-@code{nil}, эта команда загружает скомпилированный
файл после его компиляции.  В интерактивном режиме @var{load} является
аргументом префикса.

@example
@group
$ ls -l push*
-rw-r--r-- 1 lewis lewis 791 Oct  5 20:31 push.el
@end group

@group
(byte-compile-file "~/emacs/push.el")
     @result{} t
@end group

@group
$ ls -l push*
-rw-r--r-- 1 lewis lewis 791 Oct  5 20:31 push.el
-rw-rw-rw- 1 lewis lewis 638 Oct  8 20:25 push.elc
@end group
@end example
@end deffn

@deffn Command byte-recompile-directory directory &optional flag force
@cindex library compilation
Эта команда перекомпилирует каждый файл @samp{.el} в @var{directory} (или
его подкаталогах), который требует перекомпиляции.  Файл требует
перекомпиляции, если файл @samp{.elc} существует, но старше файла
@samp{.el}.

Когда файл @samp{.el} не имеет соответствующего файла @samp{.elc},
@var{flag} говорит, что делать.  Если это @code{nil}, эта команда
игнорирует эти файлы.  Если @var{flag} равен 0, он их компилирует.  Если это
ни @code{nil}, ни 0, он спрашивает пользователя, компилировать ли каждый
такой файл, а также спрашивает о каждом подкаталоге.

В интерактивном режиме @code{byte-recompile-directory} запрашивает
@var{directory}, а @var{flag} - это префиксный аргумент.

Если @var{force} равен не-@code{nil}, эта команда перекомпилирует каждый
файл @samp{.el}, который имеет файл @samp{.elc}.

Возвращаемое значение непредсказуемо.
@end deffn

@defun batch-byte-compile &optional noforce
Функция запускает @code{byte-compile-file} для файлов, указанных в
командной строке.  Функция должна использоваться только при пакетном
выполнении Emacs, так как по завершении она убивает Emacs.  Ошибка в одном
файле не препятствует обработке последующих файлов, но для нее не будет
создан выходной файл, а процесс Emacs завершится с ненулевым кодом
состояния.

Если @var{noforce} - не-@code{nil}, эта функция не перекомпилирует файлы,
которые имеют обновленный файл @samp{.elc}.

@example
$ emacs -batch -f batch-byte-compile *.el
@end example
@end defun

@node Docs and Compilation
@section Строки Документации и Компиляция
@cindex dynamic loading of documentation

  Когда Emacs загружает функции и переменные из файла с байт компиляцией,
обычно не загружает их строки документации в память.  Каждая строка
документации динамически загружается из файла с байт компиляцией только при
необходимости.  Это экономит память и ускоряет загрузку за счет пропуска
обработки строк документации.

  У этой возможности есть недостаток: если удалите, переместите или измените
скомпилированный файл (например, путем компиляции новой версии), Emacs
больше не сможет получить доступ к строке документации ранее загруженных
функций или переменных.  Такая проблема обычно возникает только в том
случае, если сами собираете Emacs и случайно редактируете и/или
перекомпилируете исходные файлы Lisp.  Чтобы решить эту проблему, просто
перезагрузите каждый файл после перекомпиляции.

  Динамическая загрузка строк документации из файлов с байт компиляцией
определяется во время компиляции для каждого файла с байт компиляцией.  Его
можно отключить с помощью опции @code{byte-compile-dynamic-docstrings}.

@defopt byte-compile-dynamic-docstrings
Если это не-@code{nil}, байт компилятор генерирует скомпилированные файлы,
которые настроены для динамической загрузки строк документации.

Чтобы отключить функцию динамической загрузки для определенного файла,
установите для этого параметра значение @code{nil} в строке заголовка
(@pxref{File Variables, , Local Variables in Files, emacs, The GNU Emacs
Manual}), например:

@smallexample
-*-byte-compile-dynamic-docstrings: nil;-*-
@end smallexample

Это полезно в основном, если планируется изменить файл и требуется, чтобы
сеансы Emacs, которые уже загружены, продолжали работать при изменении
файла.
@end defopt

@cindex @samp{#@@@var{count}}
@cindex @samp{#$}
Внутри себя динамическая загрузка строк документации выполняется путем
записи скомпилированных файлов с помощью специальной конструкции Lisp
чтения, @samp{#@@@var{count}}.  Эта конструкция пропускает следующие символы
@var{count}.  Nакже использует конструкцию @samp{#$}, которая обозначает имя
этого файла в виде строки.  Не используйте эти конструкции в исходных файлах
Lisp; это они не предназначено для того, чтобы люди читали такой файл.

@node Dynamic Loading
@section Динамическая Загрузка Отдельных Функций

@cindex dynamic loading of functions
@cindex lazy loading
  При компиляции файла можно дополнительно включить функцию
@dfn{dynamic function loading} (также известную как @dfn{lazy loading}).
При динамической загрузке функций загрузка файла не полностью читает
определения функций в файле.  Вместо этого каждое определение функции
содержит заполнитель, который ссылается на файл.  При первом вызове каждой
функции она считывает полное определение из файла, чтобы заменить
заполнитель.

  Преимущество динамической загрузки функций в том, что загрузка файла
происходит намного быстрее.  Это хорошо для файла, который содержит
множество отдельных функций, вызываемых пользователем, если использование
одной из них не означает, что будут использоваться остальные.
Специализированный режим, который предоставляет множество клавиатурных
команд, часто имеет такой шаблон использования: пользователь может
активировать режим, но использовать только несколько команд, которые он
предоставляет..

  Функция динамической загрузки имеет определенные недостатки:

@itemize @bullet
@item
Если удалить или переместить скомпилированный файл после его загрузки, Emacs
больше не сможет загрузить оставшиеся определения функций, которые еще не
были загружены.

@item
Если изменён скомпилированный файл (например, путем компиляции новой
версии), то попытка загрузить любую еще не загруженную функцию обычно
приводит к бессмысленным результатам.
@end itemize

  Эти проблемы никогда не возникнут при обычных обстоятельствах с
установленными файлами Emacs.  Но они весьма вероятны с файлами Lisp,
которые изменены.  Самый простой способ предотвратить эти проблемы -
перезагружать новый скомпилированный файл сразу после каждой перекомпиляции.

  Компилятор байтов использует функцию динамической загрузки функций, если
переменная @code{byte-compile-dynamic} имеет значение не-@code{nil} во время
компиляции.  Не устанавливайте эту переменную глобально, так как
динамическая загрузка желательна только для определенных файлов.  Вместо
этого включите функцию для определенных исходных файлов с привязками
локальных переменных файла.  Например, можно сделать это, написав этот текст
в первой строке исходного файла:

@example
-*-byte-compile-dynamic: t;-*-
@end example

@defvar byte-compile-dynamic
Если это не-@code{nil}, байт компилятор генерирует скомпилированные файлы,
настроенные для динамической загрузки функций.
@end defvar

@defun fetch-bytecode function
Если @var{function} является объектом функции с байт кодом, это немедленно
завершает загрузку байт кода @var{function} из его байт скомпилированного
файла, если он еще не загружен полностью.  В противном случае ничего не
происходит.  Всегда возвращает @var{function}.
@end defun

@node Eval During Compile
@section Оценка Во Время Компиляции
@cindex eval during compilation

  Эти функции позволяют писать код, который будет оцениваться во время
компиляции программы.

@defspec eval-and-compile body@dots{}
Эта форма отмечает @var{body} для оценки как при компиляции содержащего
кода, так и при его запуске (независимо от того, скомпилирован он или нет).

Можно получить аналогичный результат, поместив @var{body} в отдельный файл и
ссылаясь на этот файл с помощью @code{require}.  Этот метод
предпочтительнее, когда @var{body} большой.  Фактически @code{require}
автоматически становится @code{eval-and-compile}, пакет загружается как при
компиляции, так и при выполнении.

@code{autoload} также эффективнее @code{eval-and-compile}.  Это распознается
при компиляции, поэтому использование такой функции не вызывает
предупреждений ``не известно, чтобы быть определенным''.

Большинство применений @code{eval-and-compile} довольно изощренно.

Если макрос имеет вспомогательную функцию для построения своего результата,
и этот макрос используется как локально, так и вне пакета, тогда
@code{eval-and-compile} следует использовать для получения помощника как
при компиляции, так и позже при запуске.

Если функции определены программно (скажем, @code{fset}), то
@code{eval-and-compile} можно использовать для выполнения этого во время
компиляции, а также во время выполнения, поэтому вызовы этих функций
проверяются (и предупреждения об ``не известно, чтобы быть определенным''
подавляются).
@end defspec

@defspec eval-when-compile body@dots{}
Эта форма отмечает @var{body} для оценки во время компиляции, но не при
загрузке скомпилированной программы.  Результат вычисления компилятором
становится константой, которая появляется в скомпилированной программе.
Если загружается исходный файл, а не компилируется, @var{body} оценивается
нормально.

@cindex compile-time constant
If you have a constant that needs some calculation to produce,
@code{eval-when-compile} can do that at compile-time.  For example,

@lisp
(defvar my-regexp
  (eval-when-compile (regexp-opt '("aaa" "aba" "abb"))))
@end lisp

@cindex macros, at compile time
If you're using another package, but only need macros from it (the
byte compiler will expand those), then @code{eval-when-compile} can be
used to load it for compiling, but not executing.  For example,

@lisp
(eval-when-compile
  (require 'my-macro-package))
@end lisp

The same sort of thing goes for macros and @code{defsubst} functions
defined locally and only for use within the file.  They are needed for
compiling the file, but in most cases they are not needed for
execution of the compiled file.  For example,

@lisp
(eval-when-compile
  (unless (fboundp 'some-new-thing)
    (defmacro 'some-new-thing ()
      (compatibility code))))
@end lisp

@noindent
This is often good for code that's only a fallback for compatibility
with other versions of Emacs.

@strong{Common Lisp Note:} At top level, @code{eval-when-compile} is analogous to the Common
Lisp idiom @code{(eval-when (compile eval) @dots{})}.  Elsewhere, the
Common Lisp @samp{#.} reader macro (but not when interpreting) is closer
to what @code{eval-when-compile} does.
@end defspec

@node Compiler Errors
@section Compiler Errors
@cindex compiler errors
@cindex byte-compiler errors

  Error and warning messages from byte compilation are printed in a
buffer named @file{*Compile-Log*}.  These messages include file names
and line numbers identifying the location of the problem.  The usual
Emacs commands for operating on compiler output can be used on these
messages.

  When an error is due to invalid syntax in the program, the byte
compiler might get confused about the error's exact location.  One way
to investigate is to switch to the buffer @w{@file{ *Compiler
Input*}}.  (This buffer name starts with a space, so it does not show
up in the Buffer Menu.)  This buffer contains the program being
compiled, and point shows how far the byte compiler was able to read;
the cause of the error might be nearby.  @xref{Syntax Errors}, for
some tips for locating syntax errors.

@cindex byte-compiler warnings
@cindex free variable, byte-compiler warning
@cindex reference to free variable, compilation warning
@cindex function not known to be defined, compilation warning
  A common type of warning issued by the byte compiler is for
functions and variables that were used but not defined.  Such warnings
report the line number for the end of the file, not the locations
where the missing functions or variables were used; to find these, you
must search the file manually.

  If you are sure that a warning message about a missing function or
variable is unjustified, there are several ways to suppress it:

@itemize @bullet
@item
You can suppress the warning for a specific call to a function
@var{func} by conditionalizing it on an @code{fboundp} test, like
this:

@example
(if (fboundp '@var{func}) ...(@var{func} ...)...)
@end example

@noindent
The call to @var{func} must be in the @var{then-form} of the
@code{if}, and @var{func} must appear quoted in the call to
@code{fboundp}.  (This feature operates for @code{cond} as well.)

@item
Likewise, you can suppress the warning for a specific use of a
variable @var{variable} by conditionalizing it on a @code{boundp}
test:

@example
(if (boundp '@var{variable}) ...@var{variable}...)
@end example

@noindent
The reference to @var{variable} must be in the @var{then-form} of the
@code{if}, and @var{variable} must appear quoted in the call to
@code{boundp}.

@item
You can tell the compiler that a function is defined using
@code{declare-function}.  @xref{Declaring Functions}.

@item
Likewise, you can tell the compiler that a variable is defined using
@code{defvar} with no initial value.  (Note that this marks the
variable as special, i.e.@: dynamically bound, but only within the
current lexical scope, or file if at top-level.)  @xref{Defining
Variables}.
@end itemize

  You can also suppress any and all compiler warnings within a certain
expression using the construct @code{with-no-warnings}:

@c This is implemented with a defun, but conceptually it is
@c a special form.

@defspec with-no-warnings body@dots{}
In execution, this is equivalent to @code{(progn @var{body}...)},
but the compiler does not issue warnings for anything that occurs
inside @var{body}.

We recommend that you use this construct around the smallest
possible piece of code, to avoid missing possible warnings other than
one you intend to suppress.
@end defspec

  Byte compiler warnings can be controlled more precisely by setting
the variable @code{byte-compile-warnings}.  See its documentation
string for details.

@vindex byte-compile-error-on-warn
  Sometimes you may wish the byte-compiler warnings to be reported
using @code{error}.  If so, set @code{byte-compile-error-on-warn} to a
non-@code{nil} value.

@node Byte-Code Objects
@section Byte-Code Function Objects
@cindex compiled function
@cindex byte-code function
@cindex byte-code object

  Byte-compiled functions have a special data type: they are
@dfn{byte-code function objects}.  Whenever such an object appears as
a function to be called, Emacs uses the byte-code interpreter to
execute the byte-code.

  Internally, a byte-code function object is much like a vector; its
elements can be accessed using @code{aref}.  Its printed
representation is like that for a vector, with an additional @samp{#}
before the opening @samp{[}.  It must have at least four elements;
there is no maximum number, but only the first six elements have any
normal use.  They are:

@table @var
@item argdesc
The descriptor of the arguments.  This can either be a list of
arguments, as described in @ref{Argument List}, or an integer encoding
the required number of arguments.  In the latter case, the value of
the descriptor specifies the minimum number of arguments in the bits
zero to 6, and the maximum number of arguments in bits 8 to 14.  If
the argument list uses @code{&rest}, then bit 7 is set; otherwise it's
cleared.

If @var{argdesc} is a list, the arguments will be dynamically bound
before executing the byte code.  If @var{argdesc} is an integer, the
arguments will be instead pushed onto the stack of the byte-code
interpreter, before executing the code.

@item byte-code
The string containing the byte-code instructions.

@item constants
The vector of Lisp objects referenced by the byte code.  These include
symbols used as function names and variable names.

@item stacksize
The maximum stack size this function needs.

@item docstring
The documentation string (if any); otherwise, @code{nil}.  The value may
be a number or a list, in case the documentation string is stored in a
file.  Use the function @code{documentation} to get the real
documentation string (@pxref{Accessing Documentation}).

@item interactive
The interactive spec (if any).  This can be a string or a Lisp
expression.  It is @code{nil} for a function that isn't interactive.
@end table

Here's an example of a byte-code function object, in printed
representation.  It is the definition of the command
@code{backward-sexp}.

@example
#[256
  "\211\204^G^@@\300\262^A\301^A[!\207"
  [1 forward-sexp]
  3
  1793299
  "^p"]
@end example

  The primitive way to create a byte-code object is with
@code{make-byte-code}:

@defun make-byte-code &rest elements
This function constructs and returns a byte-code function object
with @var{elements} as its elements.
@end defun

  You should not try to come up with the elements for a byte-code
function yourself, because if they are inconsistent, Emacs may crash
when you call the function.  Always leave it to the byte compiler to
create these objects; it makes the elements consistent (we hope).

@node Disassembly
@section Disassembled Byte-Code
@cindex disassembled byte-code

  People do not write byte-code; that job is left to the byte
compiler.  But we provide a disassembler to satisfy a cat-like
curiosity.  The disassembler converts the byte-compiled code into
human-readable form.

  The byte-code interpreter is implemented as a simple stack machine.
It pushes values onto a stack of its own, then pops them off to use them
in calculations whose results are themselves pushed back on the stack.
When a byte-code function returns, it pops a value off the stack and
returns it as the value of the function.

  In addition to the stack, byte-code functions can use, bind, and set
ordinary Lisp variables, by transferring values between variables and
the stack.

@deffn Command disassemble object &optional buffer-or-name
This command displays the disassembled code for @var{object}.  In
interactive use, or if @var{buffer-or-name} is @code{nil} or omitted,
the output goes in a buffer named @file{*Disassemble*}.  If
@var{buffer-or-name} is non-@code{nil}, it must be a buffer or the
name of an existing buffer.  Then the output goes there, at point, and
point is left before the output.

The argument @var{object} can be a function name, a lambda expression
(@pxref{Lambda Expressions}), or a byte-code object (@pxref{Byte-Code
Objects}).  If it is a lambda expression, @code{disassemble} compiles
it and disassembles the resulting compiled code.
@end deffn

  Here are two examples of using the @code{disassemble} function.  We
have added explanatory comments to help you relate the byte-code to the
Lisp source; these do not appear in the output of @code{disassemble}.

@example
@group
(defun factorial (integer)
  "Compute factorial of an integer."
  (if (= 1 integer) 1
    (* integer (factorial (1- integer)))))
     @result{} factorial
@end group

@group
(factorial 4)
     @result{} 24
@end group

@group
(disassemble 'factorial)
     @print{} byte-code for factorial:
 doc: Compute factorial of an integer.
 args: (integer)
@end group

@group
0   varref   integer      ; @r{Get the value of @code{integer} and}
                          ;   @r{push it onto the stack.}
1   constant 1            ; @r{Push 1 onto stack.}
@end group
@group
2   eqlsign               ; @r{Pop top two values off stack, compare}
                          ;   @r{them, and push result onto stack.}
@end group
@group
3   goto-if-nil 1         ; @r{Pop and test top of stack;}
                          ;   @r{if @code{nil}, go to 1, else continue.}
6   constant 1            ; @r{Push 1 onto top of stack.}
7   return                ; @r{Return the top element of the stack.}
@end group
@group
8:1 varref   integer      ; @r{Push value of @code{integer} onto stack.}
9   constant factorial    ; @r{Push @code{factorial} onto stack.}
10  varref   integer      ; @r{Push value of @code{integer} onto stack.}
11  sub1                  ; @r{Pop @code{integer}, decrement value,}
                          ;   @r{push new value onto stack.}
12  call     1            ; @r{Call function @code{factorial} using first}
                          ;   @r{(i.e., top) stack element as argument;}
                          ;   @r{push returned value onto stack.}
@end group
@group
13 mult                   ; @r{Pop top two values off stack, multiply}
                          ;   @r{them, and push result onto stack.}
14 return                 ; @r{Return the top element of the stack.}
@end group
@end example

The @code{silly-loop} function is somewhat more complex:

@example
@group
(defun silly-loop (n)
  "Return time before and after N iterations of a loop."
  (let ((t1 (current-time-string)))
    (while (> (setq n (1- n))
              0))
    (list t1 (current-time-string))))
     @result{} silly-loop
@end group

@group
(disassemble 'silly-loop)
     @print{} byte-code for silly-loop:
 doc: Return time before and after N iterations of a loop.
 args: (n)
@end group

@group
0   constant current-time-string  ; @r{Push @code{current-time-string}}
                                  ;   @r{onto top of stack.}
@end group
@group
1   call     0            ; @r{Call @code{current-time-string} with no}
                          ;   @r{argument, push result onto stack.}
@end group
@group
2   varbind  t1           ; @r{Pop stack and bind @code{t1} to popped value.}
@end group
@group
3:1 varref   n            ; @r{Get value of @code{n} from the environment}
                          ;   @r{and push the value on the stack.}
4   sub1                  ; @r{Subtract 1 from top of stack.}
@end group
@group
5   dup                   ; @r{Duplicate top of stack; i.e., copy the top}
                          ;   @r{of the stack and push copy onto stack.}
6   varset   n            ; @r{Pop the top of the stack,}
                          ;   @r{and bind @code{n} to the value.}

;; @r{(In effect, the sequence @code{dup varset} copies the top of the stack}
;; @r{into the value of @code{n} without popping it.)}
@end group

@group
7   constant 0            ; @r{Push 0 onto stack.}
8   gtr                   ; @r{Pop top two values off stack,}
                          ;   @r{test if @var{n} is greater than 0}
                          ;   @r{and push result onto stack.}
@end group
@group
9   goto-if-not-nil 1     ; @r{Goto 1 if @code{n} > 0}
                          ;   @r{(this continues the while loop)}
                          ;   @r{else continue.}
@end group
@group
12  varref   t1           ; @r{Push value of @code{t1} onto stack.}
13  constant current-time-string  ; @r{Push @code{current-time-string}}
                                  ;   @r{onto the top of the stack.}
14  call     0            ; @r{Call @code{current-time-string} again.}
@end group
@group
15  unbind   1            ; @r{Unbind @code{t1} in local environment.}
16  list2                 ; @r{Pop top two elements off stack, create a}
                          ;   @r{list of them, and push it onto stack.}
17  return                ; @r{Return value of the top of stack.}
@end group
@end example
