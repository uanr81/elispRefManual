@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1994, 2001-2019 Free Software Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Byte Compilation
@chapter Байт Компиляция
@cindex byte compilation
@cindex byte-code
@cindex compilation (Emacs Lisp)

  В Emacs Lisp есть @dfn{компилятор}, который переводит функции, написанные
на Lisp, в специальное представление, называемое @dfn{байт-код}, которое
может выполняться более эффективно.  Компилятор заменяет определения функций
Lisp байт кодом.  Когда вызывается функция байт кода, ее определение
оценивается @dfn{байт-код интерпретатором}.

  Поскольку скомпилированный в байт код оценивается интерпретатором
байт-кода, вместо того, чтобы выполняться непосредственно аппаратным
обеспечением машины (как настоящий скомпилированный код), байт-код полностью
переносится с машины на машину без перекомпиляции.  Однако это не так
быстро, как настоящий скомпилированный код.

  В общем, любая версия Emacs может запускать скомпилированный байт-код,
созданный недавними более ранними версиями Emacs, но обратное неверно.

@vindex no-byte-compile
  Если не требуется, чтобы файл Lisp компилировался, нужно поместить в него
привязку локальной переменной файла для @code{no-byte-compile}, например::

@example
;; -*-no-byte-compile: t; -*-
@end example

@menu
* Speed of Byte-Code::          Пример ускорения после байт компиляции.
* Compilation Functions::       Функции байт компиляции.
* Docs and Compilation::        Динамическая загрузка строк документации.
* Dynamic Loading::             Динамическая загрузка отдельных функций.
* Eval During Compile::         Код, который оценивается при компиляции.
* Compiler Errors::             Обработка сообщений об ошибках компилятора.
* Byte-Code Objects::           Тип данных, используемый для функций с
                                байт компиляцией.
* Disassembly::                 Дизассемблирование байт-кода; как читать
                                байт-код.
@end menu

@node Speed of Byte-Code
@section Производительность Байт-Скомпилированного Кода

  Скомпилированная в байт-код функция не так эффективна, как примитивная
функция, написанная на C, но работает намного быстрее, чем версия,
написанная на Lisp.  Вот пример:

@example
@group
(defun silly-loop (n)
  "Возвращает время в секундах для выполнения N итераций цикла."
  (let ((t1 (float-time)))
    (while (> (setq n (1- n)) 0))
    (- (float-time) t1)))
@result{} silly-loop
@end group

@group
(silly-loop 50000000)
@result{} 10.235304117202759
@end group

@group
(byte-compile 'silly-loop)
@result{} @r{[Скомпилированный код не показан]}
@end group

@group
(silly-loop 50000000)
@result{} 3.705854892730713
@end group
@end example

  В этом примере интерпретируемому коду требовалось 10 секунд для запуска,
тогда как байт-коду требовалось менее 4 секунд.  Эти результаты являются
репрезентативными, но фактические результаты могут отличаться.

@node Compilation Functions
@section Функции Байт Компиляции
@cindex compilation functions

  Можно скомпилировать отдельную функцию или определение макроса с помощью
функции @code{byte-compile}.  Можно скомпилировать целый файл с
@code{byte-compile-file} или несколько файлов с
@code{byte-recompile-directory} или @code{batch-byte-compile}.

@vindex byte-compile-debug
  Иногда байт компилятор выдает предупреждения и/или сообщения об ошибках
(подробности - @pxref{Compiler Errors}).  Эти сообщения обычно записываются
в буфер под названием @file{*Compile-Log*}, который использует режим
компиляции.  @xref{Compilation Mode,,,emacs, The GNU Emacs Manual}.  Однако,
если переменная @code{byte-compile-debug} - не-@code{nil}, сообщения об
ошибках будут сигнализироваться как ошибки Lisp вместо (@pxref{Errors}).

@cindex macro compilation
  Осторожно при записи вызовов макросов в файлы, которые собираетесь
компилировать побайтно.  Поскольку вызовы макросов раскрываются при
компиляции, макросы нужно загружать в Emacs, иначе байтовый компилятор не
будет делать правильных действий.  Обычный способ справиться с этим -
использовать формы @code{require}, которые определяют файлы, содержащие
необходимые макроопределения (@pxref{Named Features}).  Обычно байтовый
компилятор не оценивает код, который он компилирует, но он обрабатывает
формы @code{require} специально, загружая указанные библиотеки.  Чтобы
избежать загрузки файлов определения макросов, когда кто-то @emph{runs}
скомпилированную программу, напишите @code{eval-when-compile} вокруг вызовов
@code{require} (@pxref{Eval During Compile}).  Подробнее
@xref{Compiling Macros}.

  Встроенные функции (@code{defsubst}) менее хлопотны; если скомпилирован
вызов такой функции до того, как станет известно ее определение, вызов все
равно будет работать правильно, просто он будет работать медленнее.

@defun byte-compile symbol
Эта функция байт компилирует определение функции @var{symbol}, заменяя
предыдущее определение скомпилированным.  Определение функции @var{symbol}
должно быть фактическим кодом функции; @code{byte-compile} не обрабатывает
косвенное обращение к функциям.  Возвращаемое значение - это объект функции
байт кода, который является скомпилированным определением @var{symbol}
(@pxref{Byte-Code Objects}).

@example
@group
(defun factorial (integer)
  "Вычислить факториал INTEGER."
  (if (= 1 integer) 1
    (* integer (factorial (1- integer)))))
@result{} factorial
@end group

@group
(byte-compile 'factorial)
@result{}
#[(integer)
  "^H\301U\203^H^@@\301\207\302^H\303^HS!\"\207"
  [integer 1 * factorial]
  4 "Вычислить факториал INTEGER."]
@end group
@end example

Если определение @var{symbol} является объектом функции с байт кодом,
@code{byte-compile} ничего не делает и возвращает @code{nil}.  Не
компилирует определение символа снова, поскольку исходный (не
скомпилированный) код уже был заменен в функциональной ячейке символа
компилированным байт кодом.

Аргументом @code{byte-compile} также может быть выражение @code{lambda}.  В
этом случае функция возвращает соответствующий скомпилированный код, но
нигде его не сохраняет.
@end defun

@deffn Command compile-defun &optional arg
Эта команда считывает определение, содержащее точку, компилирует ее и
оценивает результат.  Если используете это в defun, что на самом деле
является определением функции, результатом будет установка скомпилированной
версии этой функции.

@code{compile-defun} обычно отображает результат оценки в эхо-области, но
если @var{arg} равен не-@code{nil}, он вставляет результат в текущий буфер
после скомпилированной формы.
@end deffn

@deffn Command byte-compile-file filename &optional load
Эта функция компилирует файл с кодом Lisp с именем @var{filename} в файл с
байт кодом.  Имя выходного файла получается изменением суффикса @samp{.el}
на @samp{.elc}; если @var{filename} не заканчивается на @samp{.el},
добавляетcz @samp{.elc} в конец @var{filename}.

Компиляция работает путем чтения входного файла по одной форме за раз.  Если
это определение функции или макроса, записывается скомпилированное
определение функции или макроса.  Остальные формы объединяются в пакеты,
затем каждый пакет компилируется и записывается так, чтобы его
скомпилированный код выполнялся при чтении файла.  Все комментарии
отбрасываются при чтении входного файла.

Эта команда возвращает @code{t}, если ошибок не было, и @code{nil} в
противном случае.  При интерактивном вызове запрашивает имя файла.

Если @var{load} равен не-@code{nil}, эта команда загружает скомпилированный
файл после его компиляции.  В интерактивном режиме @var{load} является
аргументом префикса.

@example
@group
$ ls -l push*
-rw-r--r-- 1 lewis lewis 791 Oct  5 20:31 push.el
@end group

@group
(byte-compile-file "~/emacs/push.el")
     @result{} t
@end group

@group
$ ls -l push*
-rw-r--r-- 1 lewis lewis 791 Oct  5 20:31 push.el
-rw-rw-rw- 1 lewis lewis 638 Oct  8 20:25 push.elc
@end group
@end example
@end deffn

@deffn Command byte-recompile-directory directory &optional flag force
@cindex library compilation
Эта команда перекомпилирует каждый файл @samp{.el} в @var{directory} (или
его подкаталогах), который требует перекомпиляции.  Файл требует
перекомпиляции, если файл @samp{.elc} существует, но старше файла
@samp{.el}.

Когда файл @samp{.el} не имеет соответствующего файла @samp{.elc},
@var{flag} говорит, что делать.  Если это @code{nil}, эта команда
игнорирует эти файлы.  Если @var{flag} равен 0, он их компилирует.  Если это
ни @code{nil}, ни 0, он спрашивает пользователя, компилировать ли каждый
такой файл, а также спрашивает о каждом подкаталоге.

В интерактивном режиме @code{byte-recompile-directory} запрашивает
@var{directory}, а @var{flag} - это префиксный аргумент.

Если @var{force} равен не-@code{nil}, эта команда перекомпилирует каждый
файл @samp{.el}, который имеет файл @samp{.elc}.

Возвращаемое значение непредсказуемо.
@end deffn

@defun batch-byte-compile &optional noforce
Функция запускает @code{byte-compile-file} для файлов, указанных в
командной строке.  Функция должна использоваться только при пакетном
выполнении Emacs, так как по завершении она убивает Emacs.  Ошибка в одном
файле не препятствует обработке последующих файлов, но для нее не будет
создан выходной файл, а процесс Emacs завершится с ненулевым кодом
состояния.

Если @var{noforce} - не-@code{nil}, эта функция не перекомпилирует файлы,
которые имеют обновленный файл @samp{.elc}.

@example
$ emacs -batch -f batch-byte-compile *.el
@end example
@end defun

@node Docs and Compilation
@section Строки Документации и Компиляция
@cindex dynamic loading of documentation

  Когда Emacs загружает функции и переменные из файла с байт компиляцией,
обычно не загружает их строки документации в память.  Каждая строка
документации динамически загружается из файла с байт компиляцией только при
необходимости.  Это экономит память и ускоряет загрузку за счет пропуска
обработки строк документации.

  У этой возможности есть недостаток: если удалите, переместите или измените
скомпилированный файл (например, путем компиляции новой версии), Emacs
больше не сможет получить доступ к строке документации ранее загруженных
функций или переменных.  Такая проблема обычно возникает только в том
случае, если сами собираете Emacs и случайно редактируете и/или
перекомпилируете исходные файлы Lisp.  Чтобы решить эту проблему, просто
перезагрузите каждый файл после перекомпиляции.

  Динамическая загрузка строк документации из файлов с байт компиляцией
определяется во время компиляции для каждого файла с байт компиляцией.  Его
можно отключить с помощью опции @code{byte-compile-dynamic-docstrings}.

@defopt byte-compile-dynamic-docstrings
Если это не-@code{nil}, байт компилятор генерирует скомпилированные файлы,
которые настроены для динамической загрузки строк документации.

Чтобы отключить функцию динамической загрузки для определенного файла,
установите для этого параметра значение @code{nil} в строке заголовка
(@pxref{File Variables, , Local Variables in Files, emacs, The GNU Emacs
Manual}), например:

@smallexample
-*-byte-compile-dynamic-docstrings: nil;-*-
@end smallexample

Это полезно в основном, если планируется изменить файл и требуется, чтобы
сеансы Emacs, которые уже загружены, продолжали работать при изменении
файла.
@end defopt

@cindex @samp{#@@@var{count}}
@cindex @samp{#$}
Внутри себя динамическая загрузка строк документации выполняется путем
записи скомпилированных файлов с помощью специальной конструкции Lisp
чтения, @samp{#@@@var{count}}.  Эта конструкция пропускает следующие символы
@var{count}.  Nакже использует конструкцию @samp{#$}, которая обозначает имя
этого файла в виде строки.  Не используйте эти конструкции в исходных файлах
Lisp; это они не предназначено для того, чтобы люди читали такой файл.

@node Dynamic Loading
@section Динамическая Загрузка Отдельных Функций

@cindex dynamic loading of functions
@cindex lazy loading
  При компиляции файла можно дополнительно включить функцию
@dfn{dynamic function loading} (также известную как @dfn{lazy loading}).
При динамической загрузке функций загрузка файла не полностью читает
определения функций в файле.  Вместо этого каждое определение функции
содержит заполнитель, который ссылается на файл.  При первом вызове каждой
функции она считывает полное определение из файла, чтобы заменить
заполнитель.

  Преимущество динамической загрузки функций в том, что загрузка файла
происходит намного быстрее.  Это хорошо для файла, который содержит
множество отдельных функций, вызываемых пользователем, если использование
одной из них не означает, что будут использоваться остальные.
Специализированный режим, который предоставляет множество клавиатурных
команд, часто имеет такой шаблон использования: пользователь может
активировать режим, но использовать только несколько команд, которые он
предоставляет..

  Функция динамической загрузки имеет определенные недостатки:

@itemize @bullet
@item
Если удалить или переместить скомпилированный файл после его загрузки, Emacs
больше не сможет загрузить оставшиеся определения функций, которые еще не
были загружены.

@item
Если изменён скомпилированный файл (например, путем компиляции новой
версии), то попытка загрузить любую еще не загруженную функцию обычно
приводит к бессмысленным результатам.
@end itemize

  Эти проблемы никогда не возникнут при обычных обстоятельствах с
установленными файлами Emacs.  Но они весьма вероятны с файлами Lisp,
которые изменены.  Самый простой способ предотвратить эти проблемы -
перезагружать новый скомпилированный файл сразу после каждой перекомпиляции.

  Компилятор байтов использует функцию динамической загрузки функций, если
переменная @code{byte-compile-dynamic} имеет значение не-@code{nil} во время
компиляции.  Не устанавливайте эту переменную глобально, так как
динамическая загрузка желательна только для определенных файлов.  Вместо
этого включите функцию для определенных исходных файлов с привязками
локальных переменных файла.  Например, можно сделать это, написав этот текст
в первой строке исходного файла:

@example
-*-byte-compile-dynamic: t;-*-
@end example

@defvar byte-compile-dynamic
Если это не-@code{nil}, байт компилятор генерирует скомпилированные файлы,
настроенные для динамической загрузки функций.
@end defvar

@defun fetch-bytecode function
Если @var{function} является объектом функции с байт кодом, это немедленно
завершает загрузку байт кода @var{function} из его байт скомпилированного
файла, если он еще не загружен полностью.  В противном случае ничего не
происходит.  Всегда возвращает @var{function}.
@end defun

@node Eval During Compile
@section Оценка Во Время Компиляции
@cindex eval during compilation

  Эти функции позволяют писать код, который будет оцениваться во время
компиляции программы.

@defspec eval-and-compile body@dots{}
Эта форма отмечает @var{body} для оценки как при компиляции содержащего
кода, так и при его запуске (независимо от того, скомпилирован он или нет).

Можно получить аналогичный результат, поместив @var{body} в отдельный файл и
ссылаясь на этот файл с помощью @code{require}.  Этот метод
предпочтительнее, когда @var{body} большой.  Фактически @code{require}
автоматически становится @code{eval-and-compile}, пакет загружается как при
компиляции, так и при выполнении.

@code{autoload} также эффективнее @code{eval-and-compile}.  Это распознается
при компиляции, поэтому использование такой функции не вызывает
предупреждений ``не известно, чтобы быть определенным''.

Большинство применений @code{eval-and-compile} довольно изощренно.

Если макрос имеет вспомогательную функцию для построения своего результата,
и этот макрос используется как локально, так и вне пакета, тогда
@code{eval-and-compile} следует использовать для получения помощника как
при компиляции, так и позже при запуске.

Если функции определены программно (скажем, @code{fset}), то
@code{eval-and-compile} можно использовать для выполнения этого во время
компиляции, а также во время выполнения, поэтому вызовы этих функций
проверяются (и предупреждения об ``не известно, чтобы быть определенным''
подавляются).
@end defspec

@defspec eval-when-compile body@dots{}
Эта форма отмечает @var{body} для оценки во время компиляции, но не при
загрузке скомпилированной программы.  Результат вычисления компилятором
становится константой, которая появляется в скомпилированной программе.
Если загружается исходный файл, а не компилируется, @var{body} оценивается
нормально.

@cindex compile-time constant
Если есть константа, для создания которой требуется вычисление,
@code{eval-when-compile} может сделать это во время компиляции.  Например,

@lisp
(defvar my-regexp
  (eval-when-compile (regexp-opt '("aaa" "aba" "abb"))))
@end lisp

@cindex macros, at compile time
Если используете другой пакет, но нужны только макросы из него (байт
компилятор расширит их), то @code{eval-when-compile} можно использовать для
загрузки его для компиляции, но не для выполнения.  Например,

@lisp
(eval-when-compile
  (require 'my-macro-package))
@end lisp

То же самое касается макросов и функций @code{defsubst}, определенных
локально и только для использования внутри файла.  Они нужны для компиляции
файла, но в большинстве случаев не нужны для выполнения скомпилированного
файла.  Например,

@lisp
(eval-when-compile
  (unless (fboundp 'some-new-thing)
    (defmacro 'some-new-thing ()
      (compatibility code))))
@end lisp

@noindent
Это часто хорошо для кода, который является лишь запасным вариантом для
совместимости с другими версиями Emacs.

@strong{Common Lisp Пояснение:} На верхнем уровне @code{eval-when-compile}
аналогичен идиоме Common Lisp @code{(eval-when (compile eval) @dots{})}.  В
другом месте макрос чтения Common Lisp @samp{#.} (но не при интерпретации)
ближе к тому, что делает @code{eval-when-compile}.
@end defspec

@node Compiler Errors
@section Ошибки Компилятора
@cindex compiler errors
@cindex byte-compiler errors

  Сообщения об ошибках и предупреждениях от байт компиляции печатаются в
буфере с именем @file{*Compile-Log*}.  Эти сообщения включают имена файлов и
номера строк, определяющие местонахождение проблемы.  С этими сообщениями
можно использовать обычные команды Emacs для работы с выводом компилятора.

  Когда ошибка возникает из-за недопустимого синтаксиса в программе, байт
компилятор может запутаться в точном местоположении ошибки.  Один из
способов исследования - переключиться на буфер @w{@file{ *Compiler Input*}}.
(Имя этого буфера начинается с пробела, поэтому оно не отображается в меню
буфера.)  Этот буфер содержит компилируемую программу, а точка показывает,
как далеко байт компилятор смог прочитать; причина ошибки может быть
поблизости.  @xref{Syntax Errors}, несколько советов по поиску
синтаксических ошибок.

@cindex byte-compiler warnings
@cindex free variable, byte-compiler warning
@cindex reference to free variable, compilation warning
@cindex function not known to be defined, compilation warning
  Обычный тип предупреждения, выдаваемый байт компилятором, касается функций
и переменных, которые использовались, но не были определены.  В таких
предупреждениях указывается номер строки в конце файла, а не места, где были
использованы отсутствующие функции или переменные; чтобы найти их,
потребуется искать файл вручную.

  Если есть уверенность, что предупреждающее сообщение об отсутствии функции
или переменной необоснованно, есть несколько способов подавить его:

@itemize @bullet
@item
Может подавить предупреждение о конкретном вызове функции @var{func}, задав
его условием для теста @code{fboundp}, например:

@example
(if (fboundp '@var{func}) ...(@var{func} ...)...)
@end example

@noindent
Вызов @var{func} должен находиться в @var{then-form} объекта @code{if}, а
@var{func} должен появляться в кавычках при вызове @code{fboundp}.  (Эта
функция работает и для @code{cond}.)

@item
Точно так же можно подавить предупреждение о конкретном использовании
переменной @var{variable}, поставив его условие на тест @code{boundp}:

@example
(if (boundp '@var{variable}) ...@var{variable}...)
@end example

@noindent
Ссылка на @var{variable} должна быть в @var{then-form} @code{if}, а
@var{variable} должна быть в кавычках при вызове @code{boundp}.

@item
Можно сообщить компилятору, что функция определена, используя
@code{declare-function}.  @xref{Declaring Functions}.

@item
Точно так же можно сообщить компилятору, что переменная определяется с
помощью @code{defvar} без начального значения.  (Внимание, это помечает
переменную как специальную, то есть @: динамически привязанную, но только в
пределах текущей лексической области или файла, если он находится на верхнем
уровне.)  @xref{Defining Variables}.
@end itemize

  Также можно подавить любые и все предупреждения компилятора в определенном
выражении, используя конструкцию @code{with-no-warnings}:

@c Это реализовано с помощью defun, но концептуально это особая форма.

@defspec with-no-warnings body@dots{}
При выполнении это эквивалентно @code{(progn @var{body}...)}, но компилятор
не выдает предупреждений обо всем, что происходит внутри @var{body}.

Рекомендуем использовать эту конструкцию вокруг минимально возможного
фрагмента кода, чтобы не пропустить возможные предупреждения, отличные от
того, которое требовалось подавить.
@end defspec

  Предупреждения байт компилятора можно контролировать более точно,
установив переменную @code{byte-compile-warnings}.  Подробности смотрите в
его документации.

@vindex byte-compile-error-on-warn
  Иногда может потребоваться предупреждения байт компилятора сообщать с
помощью @code{error}.  Если это так, установите
@code{byte-compile-error-on-warn} в значение не-@code{nil}.

@node Byte-Code Objects
@section Объекты Функции Байт Кода
@cindex compiled function
@cindex byte-code function
@cindex byte-code object

  Байт-скомпилированные функции имеют специальный тип данных:
@dfn{byte-code function objects}.  Каждый раз, когда такой объект появляется
как вызываемая функция, Emacs использует интерпретатор байт-кода для
выполнения байт-кода.

  Внутренне объект функции байт-кода очень похож на вектор; к его элементам
можно получить доступ с помощью @code{aref}.  Его печатное представление
похоже на представление вектора с дополнительным @samp{#} перед
открывающейся @samp{[}.  В нем должно быть не менее четырех элементов; не
существует максимального числа элементов, но только первые шесть элементов
могут использоваться нормально.  Это:

@table @var
@item argdesc
Дескриптор аргументов.  Это может быть либо список аргументов, как описано в
@ref{Argument List}, либо целое число, кодирующее необходимое количество
аргументов.  В последнем случае значение дескриптора определяет минимальное
количество аргументов в битах от нуля до 6 и максимальное количество
аргументов в битах с 8 по 14.  Если в списке аргументов используется
@code{&rest}, то устанавливается бит 7; в противном случае он очищается.

Если @var{argdesc} является списком, аргументы будут динамически связаны
перед выполнением байт кода.  Если @var{argdesc} является целым числом,
аргументы будут помещены в стек интерпретатора байт-кода перед выполнением
кода.

@item byte-code
Строка, содержащая инструкции байт-кода.

@item constants
Вектор объектов Lisp, на которые ссылается байт-код.  К ним относятся
символы, используемые в качестве имен функций и имен переменных.

@item stacksize
Максимальный размер стека, необходимый для этой функции.

@item docstring
Строка документации (если есть); в противном случае @code{nil}.  Значение
может быть числом или списком, если строка документации хранится в файле.
Используйте функцию @code{documentation}, чтобы получить настоящую строку
документации (@pxref{Accessing Documentation}).

@item interactive
Интерактивная спецификация (если есть).  Это может быть строка или выражение
Lisp.  Это @code{nil} для неинтерактивной функции.
@end table

Вот пример объекта функции с байт кодом в печатном виде.  Это определение
команды @code{backward-sexp}.

@example
#[256
  "\211\204^G^@@\300\262^A\301^A[!\207"
  [1 forward-sexp]
  3
  1793299
  "^p"]
@end example

  Примитивный способ создания объекта с байт кодом - @code{make-byte-code}:

@defun make-byte-code &rest elements
Эта функция создает и возвращает объект функции с байт кодом с
@var{elements} в качестве его элементов.
@end defun

  Не стоит пытаться придумывать элементы для функции с байт кодом
самостоятельно, потому что, если они несовместимы, Emacs может аварийно
завершить работу при вызове функции.  Всегда оставляйте создание этих
объектов байт компилятору; это делает элементы последовательными (мы
надеемся).

@node Disassembly
@section Дизассемблированный Байт-Код
@cindex disassembled byte-code

  Человек не пишет байт-код; эта работа возложена на байт компилятор.  Но
предлагается дизассемблер, чтобы удовлетворить кошачье любопытство.
Дизассемблер преобразует скомпилированный в байт код в удобочитаемую форму.

  Интерпретатор байт-кода реализован в виде простой стековой машины.  Он
помещает значения в собственный стек, а затем извлекает их для использования
в вычислениях, результаты которых сами возвращаются в стек.  Когда функция с
байт кодом возвращается, она извлекает значение из стека и возвращает его
как значение функции.

  Помимо стека, функции байт-кода могут использовать, связывать и
устанавливать обычные переменные Lisp, передавая значения между переменными
и стеком.

@deffn Command disassemble object &optional buffer-or-name
Эта команда отображает дизассемблированный код @var{object}.  При
интерактивном использовании или если @var{buffer-or-name} имеет опущенное
значение или @code{nil}, вывод помещается в буфер с именем
@file{*Disassemble*}.  Если @var{buffer-or-name} - не-@code{nil}, это должен
быть буфер или имя существующего буфера.  Затем вывод идет туда, в точку, а
точка остается перед выходом.

Аргумент @var{object} может быть именем функции, лямбда-выражением
(@pxref{Lambda Expressions}) или объектом байт кода
(@pxref{Byte-Code Objects}).  Если это лямбда-выражение, @code{disassemble}
компилирует его и дизассемблирует полученный скомпилированный код.
@end deffn

  Вот два примера использования функции @code{disassemble}.  Добавлены
пояснительные комментарии, чтобы помочь связать байт-код с источником Lisp;
они не появляются в выводе @code{disassemble}.

@example
@group
(defun factorial (integer)
  "Вычислить факториал целого числа."
  (if (= 1 integer) 1
    (* integer (factorial (1- integer)))))
     @result{} factorial
@end group

@group
(factorial 4)
     @result{} 24
@end group

@group
(disassemble 'factorial)
     @print{} byte-code for factorial:
 doc: Вычислить факториал целого числа.
 args: (integer)
@end group

@group
0   varref   integer      ; @r{Получить значение @code{integer} и}
                          ;   @r{положить это в стек.}
1   constant 1            ; @r{Поместить 1 в стек.}
@end group
@group
2   eqlsign               ; @r{Извлечь два верхних значения из стека,}
                          ;   @r{ сравнить их и поместить результат в стек.}
@end group
@group
3   goto-if-nil 1         ; @r{Извлечь и протестировать вершину стека;}
                          ;   @r{ если @code{nil}, перейти к 1, иначе}
                          ;   @r{продолжить.}
6   constant 1            ; @r{Вставьте 1 в верхнюю часть стека.}
7   return                ; @r{Вернуть верхний элемент стека.}
@end group
@group
8:1 varref   integer      ; @r{Поместить значение @code{integer} в стек.}
9   constant factorial    ; @r{Поместить @code{factorial} в стек.}
10  varref   integer      ; @r{Поместить значение @code{integer} в стек.}
11  sub1                 ;@r{Поместить @code{integer}, значение декремента,}
                          ;   @r{поместить новое значение в стек.}
12  call     1            ; @r{Вызвать функцию @code{factorial},}
                          ;   @r{используя сначала(т.е верхнего уровня)}
                          ;   @r{элемент стека как аргумент;}
                          ;   @r{поместить возвращаемое значение в стек.}
@end group
@group
13 mult                   ; @r{Вынуть два верхних значения из стека,}
                          ;   @r{ умножить их и поместить результат в стек.}
14 return                 ; @r{Вернуть верхний элемент стека.}
@end group
@end example

Функция @code{silly-loop} несколько сложнее:

@example
@group
(defun silly-loop (n)
  "Время возврата до и после N итераций цикла."
  (let ((t1 (current-time-string)))
    (while (> (setq n (1- n))
              0))
    (list t1 (current-time-string))))
     @result{} silly-loop
@end group

@group
(disassemble 'silly-loop)
     @print{} byte-code for silly-loop:
 doc: Время возврата до и после N итераций цикла.
 args: (n)
@end group

@group
0   constant current-time-string  ; @r{Поместить @code{current-time-string}}
                                  ;   @r{на вершину стека.}
@end group
@group
1   call     0            ; @r{Вызвать @code{current-time-string} без}
                          ;   @r{аргументов, поместить результат в стек.}
@end group
@group
2   varbind  t1           ; @r{Извлечь стек и привязать @code{t1} к}
                          ; @r{всплывающему значению.}
@end group
@group
3:1 varref   n            ; @r{Получить значение @code{n} из среды}
                          ;   @r{и поместить значение в стек.}
4   sub1                  ; @r{Вычесть 1 из вершины стека.}
@end group
@group
5   dup                   ; @r{Дубликат вершины стека; т.е. скопируйте}
                          ;   @r{верхнюю часть стека и поместите копию}
                          ;   @r{в стек.}
6   varset   n            ; @r{Поднять верх стека и привязать @code{n} к}
                          ;   @r{значению.}
                          
;; @r{(Фактически, последовательность @code{dup varset} копирует вершину}
;; @r{стека в значение @code{n}, не выталкивая его.)}
@end group

@group
7   constant 0            ; @r{Поместить 0 в стек.}
8   gtr                   ; @r{Извлечь два верхних значения из стека,}
                          ;   @r{проверить, если @var{n} больше 0}
                          ;   @r{и поместить результат в стек.}
@end group
@group
9   goto-if-not-nil 1     ; @r{Перейти к 1 если @code{n} > 0}
                          ;   @r{(это продолжает цикл while else)}
@end group
@group
12  varref   t1           ; @r{Помещается значение @code{t1} в стек.}
13  constant current-time-string  ; @r{Вставить @code{current-time-string}}
                                  ; @r{в верхнюю часть стека.}
14  call     0            ; @r{Снова вызвать @code{current-time-string}.}
@end group
@group
15  unbind   1            ; @r{Отключить @code{t1} в локальной среде.}
16  list2                 ; @r{Извлеките два верхних элемента из стека,}
                          ;   @r{создайте их список и поместите его в стек.}
17  return                ; @r{Возвращаемое значение вершины стека.}
@end group
@end example
