@c -*- mode: texinfo; coding: utf-8 -*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1998-1999, 2001-2019 Free Software Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Non-ASCII Characters
@chapter Не-@acronym{ASCII} Символы
@cindex multibyte characters
@cindex characters, multi-byte
@cindex non-@acronym{ASCII} characters

  В этой главе рассматриваются специальные вопросы, касающиеся символов и их
хранения в строках и буферах.

@menu
* Text Representations::    Как Emacs представляет текст.
* Disabling Multibyte::     Контроль использования многобайтовых символов.
* Converting Representations::  Преобразование юнибайта в мультибайт и
                                    наоборот.
* Selecting a Representation::  Обработка байтовой последовательности как
                                    однобайтовой или многобайтовой.
* Character Codes::         Как юнибайт и мультибайт соотносятся с кодами
                                отдельных символов.
* Character Properties::    Атрибуты символов, определяющие их поведение и
                                обращение с ними.
* Character Sets::          Пространство возможных кодов символов разделено
                                на различные наборы символов.
* Scanning Charsets::       Какие наборы символов используются в буфере?
* Translation of Characters:: Для конвертации используются таблицы
                                 трансляции.
* Coding Systems:: Системы кодирования - это преобразования для сохранения
                       файлов.
* Input Methods::           Методы ввода позволяют пользователям вводить
                                различные символы, отличные от ASCII, без
                                специальной ключевой карты.
* Locales::                 Взаимодействие с локалью POSIX.
@end menu

@node Text Representations
@section Текстовые Представления
@cindex text representation

  Буферы и строки Emacs поддерживают большой набор символов из множества
различных сценариев, позволяя пользователям вводить и отображать текст
практически на любом известном письменном языке.

@cindex character codepoint
@cindex codespace
@cindex Unicode
  Для поддержки этого множества символов и скриптов Emacs строго следует
@dfn{Стандарту Юникода}.  Стандарт Unicode присваивает каждому символу
уникальный номер, называемый @dfn{кодовая точка}.  Диапазон кодовых точек,
определенных Unicode или Unicode @dfn{кодовым пространством}, составляет
@code{0..#x10FFFF} (в шестнадцатеричной системе счисления) включительно.
Emacs расширяет этот диапазон кодовыми точками в диапазоне
@code{#x110000..#x3FFFFF}, который использует для представления символов, не
унифицированных с Unicode, и @dfn{raw 8-bit bytes}, которые не могут быть
интерпретированы как символы.  Таким образом, код символа в Emacs является
22-битным целым числом.

@cindex internal representation of characters
@cindex characters, representation in buffers and strings
@cindex multibyte text
  Для экономии памяти Emacs не хранит 22-битные числа фиксированной длины,
которые являются кодовыми точками текстовых символов в буферах и строках.
Напротив, Emacs использует внутреннее представление символов переменной
длины, в котором каждый символ хранится в виде последовательности от 1 до 5
8-битных байтов, в зависимости от величины его кодовой точки@footnote{Это
внутреннее представление основано на одной из кодировок, определенных
стандартом Unicode, называемой @dfn{UTF-8}, для представления любой кодовой
точки Unicode, но Emacs расширяет UTF-8 для представления дополнительных
кодовых точек, которые он использует для необработанных 8-битных байтов и
символов, не унифицированных с Unicode}.  Например, любой символ
@acronym{ASCII} занимает только 1 байт, символ Latin-1 занимает 2 байта и
так далее.  Называется это представлением  @dfn{многобайтного} текста.

  Вне Emacs символы могут быть представлены во многих различных кодировках,
таких как ISO-8859-1, GB-2312, Big-5 и так далее.  Emacs преобразует эти
внешние кодировки в свое внутреннее представление, когда это необходимо,
когда читается текст в буфер или строку, или когда он записывается текст в
файл на диске или передается текст другому процессу.

  Иногда Emacs необходимо хранить и обрабатывать закодированный текст или
двоичные нетекстовые данные в своих буферах или строках.  Например, когда
Emacs посещает файл, он сначала дословно считывает текст файла в буфер и
только затем преобразует его во внутреннее представление.  Перед
преобразованием в буфере хранится закодированный текст.

@cindex unibyte text
  Для Emacs закодированный текст на самом деле не является текстом, а скорее
последовательностью необработанных 8-битных байтов.  Вызываются буферы и
строки, содержащие закодированный @dfn{многобайтовые} текст, буферы и
строки, потому что Emacs обрабатывает их как последовательность отдельных
байтов.  Обычно Emacs отображаются однобайтовые буферы и строки в виде
восьмеричных кодов, таких как @code{37}.  Рекомендуется никогда не
использовать однобайтовые буферы и строки, за исключением операций с
закодированным текстом или двоичными нетекстовыми данными.

  В буфере значение локальной переменной буфера
@code{enable-multibyte-characters} определяет используемое представление.
Представление строки определяется и записывается в строке при ее построении.

@defvar enable-multibyte-characters
Переменная определяет текстовое представление текущего буфера.  Если это
не-@code{nil}, буфер содержит многобайтовый текст; в противном случае
содержится однобайтный текст или двоичные нетекстовые данные.

Не выйдет установить эту переменную напрямую; вместо этого используется
функция @code{set-buffer-multibyte}, чтобы изменить представление буфера.
@end defvar

@defun position-bytes position
Позиции буфера измеряются в символьных единицах.  Функция возвращает позицию
байта, соответствующую положению @var{position} в текущем буфере.  Это 1 в
начале буфера и увеличивается в байтах.  Если @var{position} вне допустимого
диапазона, значение @code{nil}.
@end defun

@defun byte-to-position byte-position
Возвращает позицию буфера в символьных единицах, соответствующую данному
@var{byte-position} в текущем буфере.  Если @var{byte-position} вне
допустимого диапазона, значение @code{nil}.  В многобайтовом буфере
произвольное значение @var{byte-position} может находиться не на границе
символа, а внутри многобайтовой последовательности, представляющей один
символ; в этом случае эта функция возвращает позицию в буфере символа,
многобайтовая последовательность которого включает @var{byte-position}.
Другими словами, значение не изменяется для всех позиций байтов,
принадлежащих одному и тому же символу.
@end defun

@cindex convert file byte to buffer position
@cindex convert buffer position to file byte
  Следующие две функции полезны, когда программе на Lisp необходимо
сопоставить позиции буфера с байтовыми смещениями в файле, который посещает
буфер.

@defun bufferpos-to-filepos position &optional quality coding-system
Функция похожа на @code{position-bytes}, но вместо позиции байта в текущем
буфере возвращает смещение от начала файла текущего буфера, соответствующего
данному символу @var{position} в буфере.  Для преобразования необходимо
знать, как кодируется текст в файле буфера; это то, для чего нужен аргумент
@var{coding-system}, по умолчанию значение @code{buffer-file-coding-system}.
Необязательный аргумент @var{quality} указывает, насколько точным должен
быть результат; это должно быть одно из следующих:

@table @code
@item exact
Результат должен быть точным.  Функция может нуждаться в кодировании и
декодировании большой части буфера, что дорого и может быть медленным.
@item approximate
Значение может быть приблизительным.  Функция может избежать дорогостоящей
обработки и вернуть неточный результат.
@item nil
Если точный результат требует дорогостоящей обработки, функция вернет
@code{nil}, а не приближение.  Это значение по умолчанию, если аргумент
опущен.
@end table
@end defun

@defun filepos-to-bufferpos byte &optional quality coding-system
Функция возвращает позицию в буфере, соответствующую позиции файла,
заданной параметром @var{byte}, смещением нулевого байта от начала файла.
Функция выполняет преобразование, противоположное тому, что делает
@code{bufferpos-to-filepos}.  Необязательные аргументы @var{quality} и
@var{coding-system} имеют то же значение, что и @code{bufferpos-to-filepos}.
@end defun

@defun multibyte-string-p string
Вернуть @code{t}, если @var{string} многобайтовая строка, в противном случае
- @code{nil}.  Эта функция также возвращает @code{nil}, если @var{string} -
это какой-то объект, отличный от строки.
@end defun

@defun string-bytes string
@cindex string, number of bytes
Функция возвращает количество байтов в @var{string}.  Если @var{string} -
многобайтовая строка, это может быть больше, чем
@code{(length @var{string})}.
@end defun

@defun unibyte-string &rest bytes
Функция объединяет все свои аргументы @var{bytes} и делает результат
однобайтной строкой.
@end defun

@node Disabling Multibyte
@section Отключение Многобайтовых Символов
@cindex disabling multibyte

  По умолчанию Emacs запускается в многобайтовом режиме: он сохраняет
содержимое буферов и строк, используя внутреннюю кодировку, которая
представляет символы не-@acronym{ASCII} с использованием многобайтовых
последовательностей.  Многобайтовый режим позволяет использовать все
поддерживаемые языки и скрипты без ограничений.

@cindex turn multibyte support on or off
  В особых обстоятельствах можно отключить поддержку многобайтовых символов
для определенного буфера.  Когда многобайтовые символы в буфере отключены,
это называется @dfn{однобайтовый режим}.  В однобайтовом режиме каждый
символ в буфере имеет код символа в диапазоне от 0 до 255 (0377
восьмеричный); От 0 до 127 (0177 в восьмеричной системе) представляют
символы @acronym{ASCII}, а от 128 (восьмеричной формы 0200) до 255
(восьмеричные цифры 0377) представляют символы не-@acronym{ASCII}.

  Чтобы отредактировать конкретный файл в представлении unibyte, посетить
его, используя @code{find-file-literally}.  @xref{Visiting Functions}.
Можно преобразовать многобайтовый буфер в однобайтный, сохранив его в файл,
уничтожив буфер и снова посетив файл с помощью @code{find-file-literally}.
В качестве альтернативы вы можете использовать @kbd{C-x @key{RET} c}
(@code{universal-coding-system-argument}) и указать @samp{raw-text} в
качестве системы кодирования, с помощью которой следует посещать или
сохранять файл.  @xref{Text Coding, , Specifying a Coding System for File Text, emacs, GNU Emacs Manual}.  В отличие от @code{find-file-literally},
поиск файла как @samp{raw-text} не отключает преобразование формата,
распаковку или автоматический выбор режима.

@c See https://debbugs.gnu.org/11226 из-за отсутствия всплывающей подсказки.
@vindex enable-multibyte-characters
Локальная в буфере переменная @code{enable-multibyte-characters} - это
не-@code{nil} в многобайтовых буферах и @code{nil} в однобайтовых.  Строка
режима также указывает, является ли буфер многобайтовым или нет.  При
графическом отображении в многобайтовом буфере часть строки режима, которая
указывает набор символов, имеет всплывающую подсказку, которая (среди
прочего) говорит, что буфер многобайтовый.  В однобайтовом буфере индикатор
набора символов отсутствует.  Таким образом, в однобайтовом буфере (при
использовании графического дисплея) обычно нет ничего перед указанием
соглашения о конце строки посещаемого файла (двоеточие, обратная косая черта
и так далее), если не используется метод ввода.

@findex toggle-enable-multibyte-characters
Можно отключить поддержку многобайтовых данных в определенном буфере,
вызвав команду @code{toggle-enable-multibyte-characters} в этом буфере.

@node Converting Representations
@section Преобразование Текстовых Представлений

  Emacs может преобразовывать однобайтовый текст в многобайтовый; также
может преобразовывать многобайтовый текст в однобайтный, при условии, что
многобайтовый текст содержит только @acronym{ASCII} и 8-битные
необработанные байты.  Как правило, эти преобразования происходят при
вставке текста в буфер или при объединении текста из нескольких строк в одну
строку.  Также можно явно преобразовать содержимое строки в любое
представление.

  Emacs выбирает представление строки на основе текста, из которого она
построена.  Общее правило - преобразовывать однобайтовый текст в
многобайтовый текст при объединении его с другим многобайтовым текстом,
потому что многобайтовое представление является более общим и может
содержать любые символы, которые есть в однобайтовом тексте.

  При вставке текста в буфер Emacs преобразует текст в представление буфера,
как указано в @code{enable-multibyte-characters} в этом буфере.  В
частности, когда вставляется многобайтовый текст в однобайтный буфер, Emacs
преобразует текст в однобайтный, даже если это преобразование не может в
целом сохранить все символы, которые могут быть в многобайтовом тексте.
Другая естественная альтернатива - преобразование содержимого буфера в
многобайтовое - неприемлема, поскольку представление буфера - это выбор,
сделанный пользователем, который не может быть переопределен автоматически.

  При преобразовании однобайтового текста в многобайтовый текст символы
@acronym{ASCII} остаются неизменными, а байты с кодами от 128 до 255
преобразуются в многобайтовое представление необработанных восьмибитных
байтов.

  Преобразование многобайтового текста в однобайтный преобразует все символы
@acronym{ASCII} и восьмибитные символы в их однобайтовую форму, но теряет
информацию для символов не-@acronym{ASCII}, отбрасывая все, кроме младших 8
бит кодовой точки каждого символа.  Преобразование однобайтового текста в
многобайтный и обратно в однобайтный воспроизводит исходный однобайтный
текст.

Следующие две функции либо возвращают аргумент @var{string}, либо вновь
созданную строку без текстовых свойств.

@defun string-to-multibyte string
Функция возвращает многобайтовую строку, содержащую ту же последовательность
символов, что и @var{string}.  Если @var{string} является многобайтовой
строкой, она возвращается без изменений.  Функция предполагает, что
@var{string} включает только символы @acronym{ASCII} и необработанные
8-битные байты; последние преобразуются в их многобайтовое представление,
соответствующее кодовым точкам от @code{#x3FFF80} до @code{#x3FFFFF},
включая (@pxref{Text Representations, codepoints}).
@end defun

@defun string-to-unibyte string
Функция возвращает однобайтную строку, содержащую ту же последовательность
символов, что и @var{string}.  Сигнализирует об ошибке, если @var{string}
содержит символ не-@acronym{ASCII}.  Если @var{string} - это однобайтная
строка, она возвращается без изменений.  Использовать эту функцию для
аргументов @var{string}, которые содержат только символы @acronym{ASCII} и
восьмибитные символы.
@end defun

@defun byte-to-string byte
@cindex byte to string
Функция возвращает однобайтную строку, содержащую один байт символьных
данных, @var{byte}.  Сигнализирует об ошибке, если @var{byte} не является
целым числом от 0 до 255.
@end defun

@defun multibyte-char-to-unibyte char
Преобразует многобайтовый символ @var{char} в однобайтовый символ и
возвращает этот символ.  Если @var{char} не является ни @acronym{ASCII}, ни
восьмибитным, функция возвращает @minus{}1.
@end defun

@defun unibyte-char-to-multibyte char
Преобразует однобайтный символ @var{char} в многобайтовый символ,
предполагая, что @var{char} является либо @acronym{ASCII}, либо
необработанным 8-битным байтом.
@end defun

@node Selecting a Representation
@section Выбор Представления

  Иногда полезно проверить существующий буфер или строку как многобайтовые,
если они были однобайтовыми, или наоборот.

@defun set-buffer-multibyte multibyte
Установить тип представления текущего буфера.  Если @var{multibyte} равен
не-@code{nil}, буфер становится многобайтовым.  Если @var{multibyte} равен
@code{nil}, буфер становится однобайтовым.

Функция оставляет содержимое буфера неизменным, если рассматривать его как
последовательность байтов.  Как следствие, может изменять содержимое,
рассматриваемое как символы; например, последовательность из трех байтов,
которая рассматривается как один символ в многобайтовом представлении, будет
считаться тремя символами в однобайтовом представлении.  Исключением
являются восьмибитовые символы, представляющие необработанные байты.  Они
представлены одним байтом в однобайтовом буфере, но когда буфер установлен
на многобайтовый, они преобразуются в двухбайтовые последовательности, и
наоборот.

Функция устанавливает @code{enable-multibyte-characters} для записи того,
какое представление используется.  Также регулируются различные данные в
буфере (включая наложения, свойства текста и маркеры), чтобы они покрывали
тот же текст, что и раньше.

Функция сигнализирует об ошибке, если буфер сужается, поскольку сужение
могло произойти в середине многобайтовых последовательностей символов.

Функция также сигнализирует об ошибке, если буфер является косвенным.
Косвенный буфер всегда наследует представление своего базового буфера.
@end defun

@defun string-as-unibyte string
Если @var{string} уже является строкой unibyte, эта функция сама возвращает
@var{string}.  В противном случае возвращает новую строку с теми же байтами,
что и @var{string}, но обрабатывает каждый байт как отдельный символ (так
что значение может иметь больше символов, чем @var{string}); как исключение,
каждый восьмибитовый символ, представляющий необработанный байт,
преобразуется в один байт.  Вновь созданная строка не содержит текстовых
свойств.
@end defun

@defun string-as-multibyte string
Если @var{string} - многобайтовая строка, функция сама возвращает
@var{string}.  В противном случае возвращает новую строку с теми же байтами,
что и @var{string}, но обрабатывает каждую многобайтовую последовательность
как один символ.  Это означает, что в значении может быть меньше символов,
чем в @var{string}.  Если последовательность байтов в @var{string}
недопустима как многобайтовое представление одного символа, каждый байт в
последовательности рассматривается как необработанный 8-битный байт.  Вновь
созданная строка не содержит текстовых свойств.
@end defun

@node Character Codes
@section Коды Символов
@cindex character codes

  В однобайтовых и многобайтовых текстовых представлениях используются
разные коды символов.  Допустимые коды символов для однобайтового
представления находятся в диапазоне от 0 до @code{#xFF} (255) --- значения,
которые могут поместиться в один байт.  Допустимые коды символов для
многобайтового представления варьируются от 0 до @code{#x3FFFFF}.  В этом
кодовом пространстве значения от 0 до @code{#x7F} (127) предназначены для
символов @acronym{ASCII}, а значения от @code{#x80} (128) до
@code{#x3FFF7F} (4194175) - для символов не-@acronym{ASCII}.

  Коды символов Emacs - это надмножество стандарта Unicode.  Значения от 0
до @code{#x10FFFF} (1114111) соответствуют символам Unicode той же кодовой
точки; значения @code{#x110000} (1114112) - @code{#x3FFF7F} (4194175)
представляют символы, не унифицированные с Unicode; а значения от
@code{#x3FFF80} (4194176) до @code{#x3FFFFF} (4194303) представляют собой
восьмибитовые необработанные байты.

@defun characterp charcode
Возвращает @code{t}, если @var{charcode} является допустимым символом, и
@code{nil} в противном случае.

@example
@group
(characterp 65)
     @result{} t
@end group
@group
(characterp 4194303)
     @result{} t
@end group
@group
(characterp 4194304)
     @result{} nil
@end group
@end example
@end defun

@cindex maximum value of character codepoint
@cindex codepoint, largest value
@defun max-char
Функция возвращает наибольшее значение, которое может иметь допустимый код
символа.

@example
@group
(characterp (max-char))
     @result{} t
@end group
@group
(characterp (1+ (max-char)))
     @result{} nil
@end group
@end example
@end defun

@defun char-from-name string &optional ignore-case
Функция возвращает символ, имя которого в Юникоде - @var{string}.  Если
@var{ignore-case} равен не-@code{nil}, регистр в @var{string} игнорируется.
Функция возвращает @code{nil}, если @var{string} не называет символ.

@example
;; U+03A3
(= (char-from-name "GREEK CAPITAL LETTER SIGMA") #x03A3)
     @result{} t
@end example
@end defun

@defun get-byte &optional pos string
Функция возвращает байт в позиции символа @var{pos} в текущем буфере.  Если
текущий буфер однобайтный, это буквально байт в этой позиции.  Если буфер
многобайтовый, байтовые значения символов @acronym{ASCII} совпадают с
кодовыми точками символов, тогда как восьмибитовые необработанные байты
преобразуются в свои 8-битные коды.  Функция сигнализирует об ошибке, если
символ в @var{pos} - не-@acronym{ASCII}.

Необязательный аргумент @var{string} означает получение байтового значения
из этой строки вместо текущего буфера.
@end defun

@node Character Properties
@section Свойства Символа
@cindex character properties
@dfn{Символьное свойство } - это именованный атрибут символа, который
определяет, как символ ведет себя и как с ним следует обращаться во время
обработки и отображения текста.  Таким образом, свойства символа являются
важной частью определения семантики символа.

@c FIXME: Используйте последний URI этой главы?
@c http://www.unicode.org/versions/latest/ch04.pdf
  В целом Emacs следует стандарту Unicode в реализации свойств символов.  В
частности, Emacs поддерживает @uref{http://www.unicode.org/reports/tr23/, Unicode Character Property Model}, а база данных символьных свойств Emacs
является производной от базы данных символов Unicode (@acronym{UCD}).
Подробное описание свойств символов Юникода и их значения смотреть в
@uref{http://www.unicode.org/versions/latest/ch04.pdf, Character Properties chapter of the Unicode Standard}.  В этом разделе предполагается, что уже
есть знакомство с этой главой стандарта Unicode и требуется применить эти
знания к программам Emacs Lisp.

  В Emacs каждое свойство имеет имя, которое является символом, и набор
возможных значений, типы которых зависят от свойства; если у символа нет
определенного свойства, значение будет @code{nil}.  Как правило, имена
свойств символов в Emacs создаются из соответствующих свойств Unicode путем
их перевода в нижний регистр и замены каждого символа @samp{_} на тире
@samp{-}.  Например, @code{Canonical_Combining_Class} становится
@code{canonical-combining-class}.  Однако иногда сокращаются имена, чтобы
облегчить их использование.

@cindex unassigned character codepoints
  Некоторые кодовые точки оставлены @dfn{неназначенными} в @acronym{UCD}---
они не соответствуют ни одному символу.  Стандарт Unicode определяет
значения свойств по умолчанию для таких кодовых точек; они указаны ниже для
каждого свойства.

  Вот полный список типов значений для всех свойств символов, о которых
знает Emacs:

@table @code
@item name
Соответствует свойству Unicode @code{Name}.  Значение представляет собой
строку, состоящую из заглавных латинских букв от A до Z, цифр, пробелов и
символов дефиса @samp{-}.  Для неназначенных кодовых точек значение -
@code{nil}.

@cindex unicode general category
@item general-category
Соответствует свойству Unicode @code{General_Category}.  Значение
представляет собой символ, имя которого представляет собой двухбуквенное
сокращение классификации персонажа.  Для неназначенных кодовых точек
значение - @code{Cn}.

@item canonical-combining-class
Соответствует свойству Unicode @code{Canonical_Combining_Class}.  Значение
- целое число.  Для неназначенных кодовых точек значение равно нулю.

@cindex bidirectional class of characters
@item bidi-class
Соответствует свойству Unicode @code{Bidi_Class}.  Значение представляет
собой символ, имя которого является Unicode @dfn{направленный тип} символа.
Emacs использует это свойство, когда переупорядочивает двунаправленный текст
для отображения (@pxref{Bidirectional Display}).  Для неназначенных кодовых
точек значение зависит от кодовых блоков, которым принадлежит кодовая точка:
большинство неназначенных кодовых точек получают значение @code{L} (строгий
L), но некоторые получают значения @code{AL} (арабская буква) или @code{R}
(строгий R).

@item decomposition
Соответствует свойствам Unicode @code{Decomposition_Type} и
@code{Decomposition_Value}.  Значение представляет собой список, первым
элементом которого может быть символ, представляющий тег форматирования
совместимости, например @code{small}@footnote{Спецификация Unicode
записывает эти имена тегов внутри скобок @samp{<..>}, но имена тегов в Emacs
не включают скобки; например, Unicode указывает @samp{<small>}, где Emacs
использует @samp{small}.  }; другие элементы - это символы, которые задают
последовательность декомпозиции совместимости этого символа.  Для символов,
которые не имеют последовательности декомпозиции, и для неназначенных
кодовых точек значение представляет собой список с одним членом, самим
символом.

@item decimal-digit-value
Соответствует свойству Unicode @code{Numeric_Value} для символов, у которых
@code{Numeric_Type} есть @samp{Decimal}.  Значение является целым числом или
@code{nil}, если символ не имеет десятичного значения.  Для неназначенных
кодовых точек используется значение @code{nil}, что означает @acronym{NaN}
или ``не число''.

@item digit-value
Соответствует свойству Unicode @code{Numeric_Value} для символов, у которых
@code{Numeric_Type} есть @samp{Digit}.  Значение - целое число.  Примеры
таких символов включают в себя цифры нижнего и верхнего индекса
совместимости, для которых значением является соответствующее число.  Для
символов, не имеющих числового значения, и для неназначенных кодовых точек
значение - @code{nil}, что означает @acronym{NaN}.

@item numeric-value
Соответствует свойству Unicode @code{Numeric_Value} для символов, у которых
@code{Numeric_Type} есть @samp{Numeric}.  Значение этого свойства - число.
Примеры символов, обладающих этим свойством, включают дроби, нижние индексы,
верхние индексы, римские цифры, числители валют и числа в кружках.
Например, значение этого свойства для символа U+2155 @sc{вульгарная дробь
одна пятая} - @code{0.2}.  Для символов, не имеющих числового значения, и
для неназначенных кодовых точек значение - @code{nil}, что означает
@acronym{NaN}.

@cindex mirroring of characters
@item mirrored
Соответствует свойству Unicode @code{Bidi_Mirrored}.  Значение этого
свойства - символ, либо @code{Y} или @code{N}.  Для неназначенных кодовых
точек значение - @code{N}.

@item mirroring
Соответствует свойству Unicode @code{Bidi_Mirroring_Glyph}.  Значением этого
свойства является символ, глиф которого представляет зеркальное отображение
глифа символа, или @code{nil}, если нет определенного зеркального глифа.
Все символы, у которых свойство @code{mirrored} равно @code{N}, имеют
свойство @code{mirroring} в качестве свойства @code{mirroring}; однако
некоторые символы, свойство @code{mirrored} которых имеет значение @code{Y},
также имеют @code{nil} для @code{mirroring}, потому что не существует
подходящих символов с зеркальными глифами.  Emacs использует это свойство
для отображения зеркальных отображений символов при соответствующем
(@pxref{Bidirectional Display}).  Для неназначенных кодовых точек это
значение @code{nil}.

@item paired-bracket
Соответствует свойству Unicode @code{Bidi_Paired_Bracket}.  Значение этого
свойства является кодовой точкой @dfn{paired bracket} символа или
@code{nil}, если символ не является символом скобок.  Это устанавливает
соответствие между символами, которые рассматриваются двунаправленным
алгоритмом Unicode как пары скобок; Emacs использует это свойство, когда
решает, как изменить порядок отображения скобок, фигурных скобок и других
подобных символов (@pxref{Bidirectional Display}).

@item bracket-type
Соответствует свойству Unicode @code{Bidi_Paired_Bracket_Type}.  Для
символов, у которых свойство @code{paired-bracket} равно не-@code{nil},
значением этого свойства является символ, либо @code{o} (для символов
открывающих скобок) или @code{c} (для символов закрывающих скобок).  Для
символов, у которых свойство @code{paired-bracket} равно @code{nil},
значением является символ @code{n} (Нет).  Как и @code{paired-bracket}, это
свойство используется для двунаправленного отображения.

@item old-name
Соответствует свойству Unicode @code{Unicode_1_Name}.  Значение - строка.
Для неназначенных кодовых точек и символов, не имеющих значения для этого
свойства, значение равно @code{nil}.

@item iso-10646-comment
Соответствует свойству Unicode @code{ISO_Comment}.  Значение - либо строка,
либо @code{nil}.  Для неназначенных кодовых точек значение - @code{nil}.

@item uppercase
Соответствует свойству Unicode @code{Simple_Uppercase_Mapping}.  Значение
этого свойства - один символ.  Для неназначенных кодовых точек значение
равно @code{nil}, что означает сам символ.

@item lowercase
Соответствует свойству Unicode @code{Simple_Lowercase_Mapping}.  Значение
этого свойства - один символ.  Для неназначенных кодовых точек значение
равно @code{nil}, что означает сам символ.

@item titlecase
Соответствует свойству Unicode @code{Simple_Titlecase_Mapping}.
@dfn{Title case} - это особая форма символа, используемая, когда первый
символ слова должен быть написан с заглавной буквы.  Значение этого свойства
- один символ.  Для неназначенных кодовых точек значение равно @code{nil},
что означает сам символ.

@item special-uppercase
Соответствует специальным правилам верхнего регистра, зависящим от языка
Unicode и контекста.  Значение этого свойства - строка (которая может быть
пустой).  Пример, отображение U+00DF @sc{латинская строчная резкая буква s}
- @code{"SS"}.  Для символов без специального сопоставления используется
значение @code{nil}, что означает, что вместо этого необходимо обратиться к
свойству @code{uppercase}.

@item special-lowercase
Соответствует специальным правилам для нижнего регистра, не зависящим от
языка и контекста Unicode.  Значение этого свойства - строка (которая может
быть пустой).  Например, для сопоставления U+0130
@sc{латинская заглавная буква I с точкой над ней} значение будет
@code{"i\0307"} (то есть двухсимвольная строка, состоящая из
@sc{латинская строчная буква I}, за которым следует U+0307
@sc{сочетание точки вверху}).  Для символов без специального сопоставления
используется значение @code{nil}, что означает, что вместо этого необходимо
обратиться к свойству @code{lowercase}.

@item special-titlecase
Соответствует безусловным специальным правилам Unicode для заглавных букв.
Значение этого свойства - строка (которая может быть пустой).  Например,
отображение для U + FB01 @sc{латинская строчная лигатура fi} значение
@code{"Fi"}.  Для символов без специального сопоставления используется
значение @code{nil}, что означает, что вместо этого необходимо обратиться к
свойству @code{titlecase}.
@end table

@defun get-char-code-property char propname
Функция возвращает значение свойства @var{char} @var{propname}.

@example
@group
(get-char-code-property ?\s 'general-category)
     @result{} Zs
@end group
@group
(get-char-code-property ?1 'general-category)
     @result{} Nd
@end group
@group
;; U+2084
(get-char-code-property ?\N@{SUBSCRIPT FOUR@}
                        'digit-value)
     @result{} 4
@end group
@group
;; U+2155
(get-char-code-property ?\N@{VULGAR FRACTION ONE FIFTH@}
                        'numeric-value)
     @result{} 0.2
@end group
@group
;; U+2163
(get-char-code-property ?\N@{ROMAN NUMERAL FOUR@}
                        'numeric-value)
     @result{} 4
@end group
@group
(get-char-code-property ?\( 'paired-bracket)
     @result{} 41  ;; closing parenthesis
@end group
@group
(get-char-code-property ?\) 'bracket-type)
     @result{} c
@end group
@end example
@end defun

@defun char-code-property-description prop value
Функция возвращает строку описания свойства @var{prop} @var{value} или
@code{nil}, если @var{value} не имеет описания.

@example
@group
(char-code-property-description 'general-category 'Zs)
     @result{} "Separator, Space"
@end group
@group
(char-code-property-description 'general-category 'Nd)
     @result{} "Number, Decimal Digit"
@end group
@group
(char-code-property-description 'numeric-value '1/5)
     @result{} nil
@end group
@end example
@end defun

@defun put-char-code-property char propname value
Функция сохраняет @var{value} как значение свойства @var{propname} для
символа @var{char}.
@end defun

@defvar unicode-category-table
Значением этой переменной является таблица символов (@pxref{Char-Tables}),
которая определяет для каждого символа его свойство символа Unicode
@code{General_Category}.
@end defvar

@defvar char-script-table
@cindex script symbols
Значением этой переменной является таблица символов, которая определяет для
каждого символа символ, имя которого является сценарием, которому
принадлежит символ, согласно классификации Unicode Standard пространства
кода Unicode на блоки, специфичные для сценария.  Эта таблица символов имеет
единственный дополнительный слот, значением которого является список всех
символов скрипта.
@end defvar

@defvar char-width-table
Значением этой переменной является таблица символов, которая определяет
ширину каждого символа в столбцах, которые он будет занимать на экране.
@end defvar

@defvar printable-chars
Значением этой переменной является таблица символов, в которой для каждого
символа указывается, можно ли его распечатать.  То есть, если оценка
@code{(aref printable-chars char)} получает @code{t}, символ печатается,
а если результатом является @code{nil}, то нет.
@end defvar

@node Character Sets
@section Наборы Символов
@cindex character sets

@cindex charset
@cindex coded character set
Emacs @dfn{character set} или @dfn{charset} - это набор символов, в котором
каждому символу назначена числовая кодовая точка.  (Стандарт Unicode
называет это @dfn{кодированный набор символов}.)  Каждая кодировка Emacs
имеет имя, которое является символом.  Один символ может принадлежать к
любому количеству разных наборов символов, но, как правило, он будет иметь
разные кодовые точки в каждой кодировке.  Примеры наборов символов включают
@code{ascii}, @code{iso-8859-1}, @code{greek-iso8859-7} и
@code{windows-1255}.  Кодовая точка, присвоенная символу в кодировке, обычно
отличается от ее кодовой точки, используемой в буферах и строках Emacs.

@cindex @code{emacs}, a charset
@cindex @code{unicode}, a charset
@cindex @code{eight-bit}, a charset
  Emacs определяет несколько специальных наборов символов.  Набор символов
@code{unicode} включает все символы, чьи кодовые точки Emacs находятся в
диапазоне @code{0..#x10FFFF}.  Набор символов @code{emacs} включает все
символы @acronym{ASCII} и не-@acronym{ASCII}.  Наконец, кодировка
@code{eight-bit} включает 8-битные необработанные байты; Emacs использует
её для представления необработанных байтов, встречающихся в тексте.

@defun charsetp object
Возвращает @code{t}, если @var{object} является символом, который называет
набор символов, и @code{nil} в противном случае.
@end defun

@defvar charset-list
Значение представляет собой список всех определенных имен наборов символов.
@end defvar

@defun charset-priority-list &optional highestp
Функция возвращает список всех определенных наборов символов, упорядоченных
по их приоритету.  Если @var{highestp} равен не-@code{nil}, функция
возвращает один набор символов с наивысшим приоритетом.
@end defun

@defun set-charset-priority &rest charsets
Функция делает @var{charsets} набором символов с наивысшим приоритетом.
@end defun

@defun char-charset character &optional restriction
Функция возвращает имя набора символов с наивысшим приоритетом, которому
принадлежит @var{character}.  Символы @acronym{ASCII} являются исключением:
для них эта функция всегда возвращает @code{ascii}.

Если @var{restriction} - не-@code{nil}, это должен быть список кодировок для
поиска.  В качестве альтернативы, это может быть система кодирования, и в
этом случае возвращаемая кодировка должна поддерживаться этой системой
кодирования (@pxref{Coding Systems}).
@end defun

@c TODO: Объясните здесь свойства и добавьте индексы, например
@c 'свойство charset'.
@defun charset-plist charset
Функция возвращает список свойств набора символов @var{charset}.  Хотя
@var{charset} является символом, это не то же самое, что список свойств
этого символа.  Свойства набора символов включают важную информацию о
кодировке, такую как строка документации, краткое имя и так далее.
@end defun

@defun put-charset-property charset propname value
Функция устанавливает свойство @var{propname} объекта @var{charset} равным
данному @var{value}.
@end defun

@defun get-charset-property charset propname
Функция возвращает значение свойства @var{charset} @var{propname}.
@end defun

@deffn Command list-charset-chars charset
Команда отображает список символов в наборе символов @var{charset}.
@end deffn

  Emacs может конвертировать между своим внутренним представлением символа и
его кодовой точкой в определенной кодировке.  Следующие две функции
поддерживают эти преобразования.

@c FIXME: decode-char и encode-char принимает и игнорирует дополнительный
@c аргумент @var{restriction}.  Когда этот аргумент действительно имеет
@c значение, он должен быть задокументирован здесь.
@defun decode-char charset code-point
Функция декодирует символ, которому назначен @var{code-point} в
@var{charset}, который соответствует символу Emacs и возвращает его.  Если
@var{charset} не содержит символа этой кодовой точки, значение будет
@code{nil}.  Если @var{code-point} не помещается в целое число
(@pxref{Integer Basics, most-positive-fixnum}) Lisp, его можно указать как
cons-ячейку @code{(@var{high} . @var{low})}, где @var{low} - младшие 16 бит
значения, а @var{high} - старшие 16 бит.
@end defun

@defun encode-char char charset
Функция возвращает кодовую точку, присвоенную символу @var{char} в
@var{charset}.  Если результат не соответствует целому числу Lisp,
возвращается cons-ячейка @code{(@var{high} . @var{low})}, которая
соответствует второму аргументу @code{decode-char} выше.  Если @var{charset}
не имеет кода для @var{char}, значение будет @code{nil}.
@end defun

  Следующая функция пригодится для применения определенной функции ко всем
или части символов в кодировке:

@defun map-charset-chars function charset &optional arg from-code to-code
Вызов @var{function} для символов в @var{charset}.  @var{function}
вызывается с двумя аргументами.  Первый - это cons-ячейка
@code{(@var{from} .  @var{to})}, где @var{from} и @var{to} обозначают
диапазон символов, содержащихся в кодировке.  Второй аргумент, передаваемый
@var{function}, - @var{arg}.

По умолчанию диапазон кодовых точек, переданных в @var{function}, включает
все символы в @var{charset}, но необязательные аргументы @var{from-code} и
@var{to-code} ограничивают это диапазоном символов между этими двумя
кодовыми точками @var{charset}.  Если любой из них - @code{nil}, по
умолчанию используется первая или последняя кодовая точка @var{charset}
соответственно.
@end defun

@node Scanning Charsets
@section Сканирование Наборов Символов
@cindex scanning for character sets
@cindex character set, searching

  Иногда бывает полезно узнать, к какому набору символов принадлежит
конкретный символ.  Одно из применений этого - определение того, какие
системы кодирования (@pxref{Coding Systems}) способны представить весь
рассматриваемый текст; другой - определить шрифт (ы) для отображения этого
текста.

@defun charset-after &optional pos
Функция возвращает кодировку с наивысшим приоритетом, содержащую символ в
позиции @var{pos} в текущем буфере. Если @var{pos} опущен или @code{nil}, по
умолчанию используется текущее значение точки. Если @var{pos} вне
допустимого диапазона, значение будет @code{nil}.
@end defun

@defun find-charset-region beg end &optional translation
Функция возвращает список наборов символов с наивысшим приоритетом, которые
содержат символы в текущем буфере между позициями @var{beg} и @var{end}.

Необязательный аргумент @var{translation} указывает таблицу трансляции,
используемую для сканирования текста (@pxref{Translation of Characters}).
Если это не-@code{nil}, то каждый символ в регионе транслируется через эту
таблицу, а возвращаемое значение описывает переведенные символы, а не
символы, фактически находящиеся в буфере.
@end defun

@defun find-charset-string string &optional translation
Функция возвращает список наборов символов с наивысшим приоритетом, которые
содержат символы в @var{string}.  Это похоже на @code{find-charset-region},
за исключением того, что применяется к содержимому @var{string}, а не к
части текущего буфера.
@end defun

@node Translation of Characters
@section Трансляция Символов
@cindex character translation tables
@cindex translation tables

  @dfn{Таблица трансляции} - это таблица символов (@pxref{Char-Tables}),
которая определяет отображение символов в символы.  Эти таблицы используются
при кодировании и декодировании, а также для других целей.  Некоторые
системы кодирования определяют свои собственные таблицы трансляции; есть
также таблицы трансляции по умолчанию, которые применяются ко всем остальным
системам кодирования.

  В таблице трансляции есть два дополнительных слота.  Первый - это либо
@code{nil}, либо таблица перевода, выполняющая обратное преобразование;
второй - максимальное количество символов, которое нужно найти для
преобразования последовательностей символов (смотреть описание
@code{make-translation-table-from-alist} ниже).

@defun make-translation-table &rest translations
Функция возвращает таблицу трансляции на основе аргумента
@var{translations}.  Каждый элемент @var{translations} должен быть списком
элементов вида @code{(@var{from} . @var{to})}; это говорит о трансляции
символа @var{from} в @var{to}.

Аргументы и формы в каждом аргументе обрабатываются по порядку, и если
предыдущая форма уже переводит @var{to} в какой-либо другой символ,
допустить, в @var{to-alt}, @var{from} также переводится в @var{to-alt}.
@end defun

  Во время декодирования таблицы трансляция применяется к символам,
полученным в результате обычного декодирования.  Если система кодирования
имеет свойство @code{:decode-translation-table}, которое указывает таблицу
преобразования, которую нужно использовать, или список таблиц
преобразования, которые следует применять последовательно.  (Это свойство
системы кодирования, возвращаемое @code{coding-system-get}, а не свойство
символа, являющегося именем системы кодирования.
@xref{Coding System Basics,, Basic Concepts of Coding Systems}.)  Наконец,
если @code{standard-translation-table-for-decode} равен не-@code{nil},
полученные символы переводятся этой таблицей.

  Во время трансляции таблицы трансляция применяются к символам в буфере, и
результат трансляции фактически кодируется.  Если система кодирования имеет
свойство @code{:encode-translation-table}, которое указывает таблицу
преобразования, которую нужно использовать, или список таблиц
преобразования, применяемых последовательно.  Кроме того, если переменная
@code{standard-translation-table-for-encode} имеет значение не-@code{nil},
она указывает таблицу преобразования, которая будет использоваться для
преобразования результата.

@defvar standard-translation-table-for-decode
Таблица перевода по умолчанию для декодирования.  Если система кодирования
определяет свои собственные таблицы трансляции, таблица, которая является
значением этой переменной, если не-@code{nil}, применяется после них.
@end defvar

@defvar standard-translation-table-for-encode
Таблица перевода по умолчанию для кодирования.  Если система кодирования
определяет свои собственные таблицы перевода, таблица, которая является
значением этой переменной, если не-@code{nil}, применяется после них.
@end defvar

@c FIXME: Эта переменная устарела с 23.1. Мы должны упомянуть
@c здесь, или просто удалить эту defvar.  --xfq
@defvar translation-table-for-input
Самовставляющиеся символы переводятся через эту таблицу трансляции перед
вставкой.  Команды поиска также транслируют свой ввод через эту таблицу,
поэтому они могут более надежно сравнивать с тем, что находится в буфере.

При установке эта переменная автоматически становится локальной для буфера.
@end defvar

@defun make-translation-table-from-vector vec
Функция возвращает таблицу преобразования, созданную из @var{vec}, которая
представляет собой массив из 256 элементов для сопоставления байтов
(значения от 0 до #xFF) с символами.  Элементы могут быть @code{nil} для
непереведенных байтов.  Возвращенная таблица содержит таблицу трансляции для
обратного отображения в первом дополнительном слоте и значение @code{1} во
втором дополнительном слоте.

Функция обеспечивает простой способ создания частной системы кодирования,
которая отображает каждый байт на определенный символ. Вы можете указать
возвращаемую таблицу и таблицу обратного преобразования, используя свойства
@code{:decode-translation-table} и @code{:encode-translation-table}
соответственно в аргументе @var{props} для @code{define-coding-system}.
@end defun

@defun make-translation-table-from-alist alist
Функция похожа на @code{make-translation-table}, но возвращает сложную
таблицу преобразования, а не простое взаимно-однозначное сопоставление.
Каждый элемент @var{alist} имеет форму @code{(@var{from} . @var{to})}, где
@var{from} и @var{to} - символы или векторы, определяющие последовательность
символов.  Если @var{from} является символом, этот символ преобразуется в
@var{to} (то есть в символ или последовательность символов).  Если
@var{from} - это вектор символов, эта последовательность преобразуется в
@var{to}.  Возвращенная таблица содержит таблицу трансляции для обратного
отображения в первом дополнительном слоте и максимальную длину всех
последовательностей символов @var{from} во втором дополнительном слоте.
@end defun

@node Coding Systems
@section Системы Кодирования

@cindex coding system
  Когда Emacs читает или записывает файл, и когда Emacs отправляет текст в
подпроцесс или получает текст из подпроцесса, он обычно выполняет
преобразование кода символов и преобразование конца строки, как указано в
конкретной @dfn{кодовой системе}.

  Как определить систему кодирования - непонятный вопрос, который здесь не
описывается.

@menu
* Coding System Basics::        Базовые концепции.
* Encoding and I/O::            Как функции файлового ввода-вывода
                                    обрабатывают системы кодирования.
* Lisp and Coding Systems:: Функции для работы с именами систем кодирования.
* User-Chosen Coding Systems::  Спросить пользователя выбрать систему
                                    кодирования.
* Default Coding Systems::      Управление выбором по умолчанию.
* Specifying Coding Systems::   Запрос конкретной системы кодирования для
                                    одной файловой операции.
* Explicit Encoding:: Кодирование или декодирование текста без ввода-вывода.
* Terminal I/O Encoding::       Использование кодировки для терминального
                                    ввода/вывода.
@end menu

@node Coding System Basics
@subsection Основные Концепции Систем Кодирования

@cindex character code conversion
  @dfn{Преобразование кода символа} включает преобразование между внутренним
представлением символов, используемых внутри Emacs, и некоторой другой
кодировкой.  Emacs поддерживает множество различных кодировок в том смысле,
что он может конвертировать в них и из них.  Например, может преобразовывать
текст в кодировки, такие как Latin 1, Latin 2, Latin 3, Latin 4, Latin 5 и
несколько вариантов ISO 2022, или наоборот.  В некоторых случаях Emacs
поддерживает несколько альтернативных кодировок для одних и тех же символов;
Например, для кириллического (русского) алфавита существует три системы
кодирования: ISO, Альтернативный и KOI8.

@vindex undecided@r{ coding system}
@vindex prefer-utf-8@r{ coding system}
  Каждая система кодирования определяет конкретный набор преобразований кода
символов, но система кодирования @code{undecided} является особенной: она
оставляет выбор без указания, который нужно выбирать эвристически для
каждого файла на основе данных файла.  Система кодирования
@code{prefer-utf-8} похожа на @code{undecided}, но по возможности
предпочитает выбирать @code{utf-8}.

  В общем, система кодирования не гарантирует двустороннюю идентичность:
декодирование последовательности байтов с использованием системы кодирования
с последующим кодированием результирующего текста в той же системе
кодирования может дать другую последовательность байтов.  Но некоторые
системы кодирования действительно гарантируют, что последовательность байтов
будет такой же, как та, которая изначально декодировалась.  Вот несколько
примеров:

@quotation
iso-8859-1, utf-8, big5, shift_jis, euc-jp
@end quotation

  Кодирование текста в буфере и последующее декодирование результата также
могут не воспроизвести исходный текст.  Например, если кодируется символ с
помощью системы кодирования, которая не поддерживает этот символ, результат
будет непредсказуемым, и поэтому его декодирование с использованием той же
системы кодирования может дать другой текст.  В настоящее время Emacs не
может сообщать об ошибках, возникающих в результате кодирования
неподдерживаемых символов.

@cindex EOL conversion
@cindex end-of-line conversion
@cindex line end conversion
  @dfn{Конверсия в конце строки} обрабатывает три различных соглашения,
используемых в различных системах для представления конца строки в файлах.
Соглашение Unix, используемое в системах GNU и Unix, заключается в
использовании символа перевода строки (также называемого новой строкой).
Соглашение DOS, используемое в системах MS-Windows и MS-DOS, заключается в
использовании возврата каретки и перевода строки в конце строки.  Соглашение
Mac заключается в использовании только возврата каретки.  (Это соглашение
использовалось в классической Mac OS.)

@cindex base coding system
@cindex variant coding system
  @dfn{Базовые системы кодирования}, например @code{latin-1}, оставляет
преобразование конца строки неопределенным, чтобы его можно было выбрать на
основе данных.  @dfn{Вариантные системы кодирования}, например
@code{latin-1-unix}, @code{latin-1-dos} и @code{latin-1-mac}, также явно
указывают преобразование конца строки.  Большинство базовых систем
кодирования имеют три соответствующих варианта, имена которых образованы
добавлением @samp{-unix}, @samp{-dos} и @samp{-mac}.

@vindex raw-text@r{ coding system}
  Система кодирования @code{raw-text} особенная в том, что она предотвращает
преобразование кода символов и заставляет буфер, посещаемый этой системой
кодирования, быть однобайтовым буфером. По историческим причинам с помощью
этой системы кодирования можно сохранять как однобайтовый, так и
многобайтовый текст.  Когда используетя @code{raw-text} для кодирования
многобайтового текста, выполняется преобразование кода одного символа:
преобразуются восьмибитные символы в их однобайтовое внешнее представление.
@code{raw-text} не определяет преобразование конца строки, что позволяет
определять его как обычно по данным, и имеет три обычных варианта,
определяющих преобразование конца строки.

@vindex no-conversion@r{ coding system}
@vindex binary@r{ coding system}
  @code{no-conversion} (и его псевдоним @code{binary}) эквивалентен
@code{raw-text-unix}: не определяет преобразования ни кодов символов, ни
конца строки. 

@vindex emacs-internal@r{ coding system}
@vindex utf-8-emacs@r{ coding system}
  Система кодирования @code{utf-8-emacs} указывает, что данные представлены
во внутренней кодировке Emacs (@pxref{Text Representations}).  Это похоже на
@code{raw-text} в том, что преобразование кода не происходит, но отличается
тем, что результатом являются многобайтовые данные.  Имя
@code{emacs-internal} - это псевдоним @code{utf-8-emacs-unix} (поэтому он не
вызывает преобразования конца строки, в отличие от @code{utf-8-emacs},
который может декодировать все 3 вида соглашений о конце строки).

@defun coding-system-get coding-system property
Функция возвращает указанное свойство системы кодирования
@var{coding-system}.  Большинство свойств системы кодирования существуют для
внутренних целей, но одно из них может оказаться полезным -
@code{:mime-charset}. Значение этого свойства - это имя, используемое в MIME
для кодировки символов, которую эта система кодирования может читать и
записывать.  Примеры:

@example
(coding-system-get 'iso-latin-1 :mime-charset)
     @result{} iso-8859-1
(coding-system-get 'iso-2022-cn :mime-charset)
     @result{} iso-2022-cn
(coding-system-get 'cyrillic-koi8 :mime-charset)
     @result{} koi8-r
@end example

Значение свойства @code{:mime-charset} также определяется как псевдоним для
системы кодирования.
@end defun

@cindex alias, for coding systems
@defun coding-system-aliases coding-system
Функция возвращает список псевдонимов @var{coding-system}.
@end defun

@node Encoding and I/O
@subsection Декодирование и I/O

  Основная цель систем кодирования - использование для чтения и записи
файлов.  Функция @code{insert-file-contents} использует систему кодирования
для декодирования данных файла, а @code{write-region} использует ее для
кодирования содержимого буфера.

  Можно указать систему кодирования для использования либо явно
(@pxref{Specifying Coding Systems}), либо неявно с использованием механизма
по умолчанию (@pxref{Default Coding Systems}).  Но эти методы могут не
указывать полностью, что делать.  Например, могут выбрать систему
кодирования, такую как @code{undecided}, в которой преобразование кода
символа будет определяться на основе данных.  В этих случаях операция
ввода-вывода завершает работу по выбору системы кодирования.  Очень часто
впоследствии требуется узнать, какая система кодирования была выбрана.

@defvar buffer-file-coding-system
Эта локальная в буфере переменная записывает систему кодирования,
используемую для сохранения буфера и для записи части буфера с помощью
@code{write-region}.  Если записываемый текст не может быть безопасно
закодирован с использованием системы кодирования, указанной в этой
переменной, эти операции выбирают альтернативную кодировку, вызывая функцию
@code{select-safe-coding-system} (@pxref{User-Chosen Coding Systems}).  Если
для выбора другой кодировки требуется попросить пользователя указать систему
кодирования, @code{buffer-file-coding-system} обновляется до вновь выбранной
системы кодирования.

@code{buffer-file-coding-system} @emph{не} влияет на отправку текста в
подпроцесс.
@end defvar

@defvar save-buffer-coding-system
Переменная определяет систему кодирования для сохранения буфера (путем
переопределения @code{buffer-file-coding-system}).  Обратить внимание, что
она не используется для @code{write-region}.

Когда команда для сохранения буфера начинает использовать
@code{buffer-file-coding-system} (или @code{save-buffer-coding-system}), и
эта система кодирования не может обработать фактический текст в буфере,
команда просит пользователя выбрать другую систему кодирования (путем вызова
@code{select-safe-coding-system}).  После этого команда также обновляет
@code{buffer-file-coding-system}, чтобы представить систему кодирования,
указанную пользователем.
@end defvar

@defvar last-coding-system-used
Операции ввода-вывода для файлов и подпроцессов устанавливают в этой
переменной имя системы кодирования, которое использовалось.  Его также
устанавливают функции явного кодирования и декодирования
(@pxref{Explicit Encoding}).

@strong{Предупреждение:} Поскольку получение вывода подпроцесса
устанавливает эту переменную, она может изменяться всякий раз, когда Emacs
ожидает; поэтому потребуется скопировать значение вскоре после вызова
функции, в которой хранится интересующее значение.
@end defvar

  Переменная @code{selection-coding-system} указывает, как кодировать выбор
для оконной системы.  @xref{Window System Selections}.

@defvar file-name-coding-system
Переменная @code{file-name-coding-system} указывает систему кодирования,
используемую для кодирования имен файлов.  Emacs кодирует имена файлов,
используя эту систему кодирования для всех операций с файлами.  Если
@code{file-name-coding-system} равен @code{nil}, Emacs использует систему
кодирования по умолчанию, определяемую выбранной языковой средой.  В
языковой среде по умолчанию любые символы не-@acronym{ASCII} в именах файлов
специально не кодируются; они появляются в файловой системе с использованием
внутреннего представления Emacs.
@end defvar

  @strong{Предупреждение:} если изменить @code{file-name-coding-system} (или
языковую среду) в середине сеанса Emacs, могут возникнуть проблемы, если уже
посещены файлы, имена которых были закодированы с использованием более
ранней системы кодирования и обрабатываются по-другому в новой системе
кодирования.  Если попытаться сохранить один из этих буферов под именем
посещенного файла, при сохранении может использоваться неправильное имя
файла или может возникнуть ошибка.  Если возникает такая проблема,
используется @kbd{C-x C-w}, чтобы указать новое имя файла для этого буфера.

@cindex file-name encoding, MS-Windows
  В Windows 2000 и более поздних версиях Emacs по умолчанию использует API
Unicode для передачи имен файлов в ОС, поэтому значение
@code{file-name-coding-system} в основном игнорируется.  Приложения Lisp,
которым необходимо кодировать или декодировать имена файлов на уровне Lisp,
должны использовать систему кодирования @code{utf-8}, когда
@code{system-type} имеет значение @code{windows-nt}; преобразование имен
файлов в кодировке UTF-8 в кодировку, подходящую для взаимодействия с ОС,
выполняется внутри Emacs.

@node Lisp and Coding Systems
@subsection Системы Кодирования в Lisp

  Вот возможности Lisp для работы с системами кодирования:

@cindex list all coding systems
@defun coding-system-list &optional base-only
Функция возвращает список всех имен (символов) систем кодирования.  Если
@var{base-only} равен не-@code{nil}, значение включает только базовые
системы кодирования.  В противном случае он также включает системы
псевдонимов и вариантного кодирования.
@end defun

@defun coding-system-p object
Функция возвращает @code{t}, если @var{object} - имя системы кодирования,
или @code{nil}.
@end defun

@cindex validity of coding system
@cindex coding system, validity check
@defun check-coding-system coding-system
Функция проверяет правильность @var{coding-system}.  Если это действительно
так, возвращается @var{coding-system}.  Если @var{coding-system} равно
@code{nil}, функция возвращает @code{nil}.  Для любых других значений
сигнализируется об ошибке, когда @code{error-symbol} установленно в
@code{coding-system-error} (@pxref{Signaling Errors, signal}).
@end defun

@cindex eol type of coding system
@defun coding-system-eol-type coding-system
Функция возвращает тип преобразования конца строки (также известный как @:
@dfn{eol}), используемый @var{coding-system}.  Если @var{coding-system}
задает определенное преобразование eol, возвращаемое значение будет целым
числом 0, 1 или 2, обозначающим @code{unix}, @code{dos} and @code{mac},
соответственно.  Если @var{coding-system} не указывает явно преобразование
eol, возвращаемое значение представляет собой вектор систем кодирования,
каждая из которых имеет один из возможных типов преобразования eol, как это:

@lisp
(coding-system-eol-type 'latin-1)
     @result{} [latin-1-unix latin-1-dos latin-1-mac]
@end lisp

@noindent
Если функция возвращает вектор, Emacs решит, как часть процесса кодирования
или декодирования текста, какое преобразование eol использовать.  Для
декодирования формат конца строки текста определяется автоматически, и
преобразование eol устанавливается в соответствии с ним (например, формат
CRLF в стиле DOS будет подразумевать преобразование eol в @code{dos}).  Для
кодирования преобразование eol берется из соответствующей системы
кодирования по умолчанию (например, значение по умолчанию
@code{buffer-file-coding-system} для @code{buffer-file-coding-system}) или
из преобразования eol по умолчанию, подходящего для базовой платформы.
@end defun

@cindex eol conversion of coding system
@defun coding-system-change-eol-conversion coding-system eol-type
Функция возвращает систему кодирования, которая похожа на
@var{coding-system}, за исключением преобразования eol, которое задается
@code{eol-type}.  @var{eol-type} должно быть @code{unix}, @code{dos},
@code{mac} или @code{nil}.  Если это @code{nil}, возвращенная система
кодирования определяет преобразование конца строки из данных.

@var{eol-type} также может быть 0, 1 или 2, что означает @code{unix},
@code{dos} и @code{mac} соответственно.
@end defun

@cindex text conversion of coding system
@defun coding-system-change-text-conversion eol-coding text-coding
Функция возвращает систему кодирования, которая использует преобразование
конца строки @var{eol-coding} и преобразование текста @var{text-coding}.
Если @var{text-coding} равен @code{nil}, он возвращает @code{undecided} или
один из его вариантов согласно @var{eol-coding}.
@end defun

@cindex safely encode region
@cindex coding systems for encoding region
@defun find-coding-systems-region from to
Функция возвращает список систем кодирования, которые можно использовать для
кодирования текста между @var{from} и @var{to}.  Все системы кодирования в
списке могут безопасно кодировать любые многобайтовые символы в этой части
текста.

Если в тексте нет многобайтовых символов, функция возвращает список
@code{(undecided)}.
@end defun

@cindex safely encode a string
@cindex coding systems for encoding a string
@defun find-coding-systems-string string
Функция возвращает список систем кодирования, которые можно использовать для
кодирования текста @var{string}.  Все системы кодирования в списке могут
безопасно кодировать любые многобайтовые символы в @var{string}.  Если текст
не содержит многобайтовых символов, возвращается список @code{(undecided)}.
@end defun

@cindex charset, coding systems to encode
@cindex safely encode characters in a charset
@defun find-coding-systems-for-charsets charsets
Функция возвращает список систем кодирования, которые можно использовать для
кодирования всех наборов символов в списке @var{charsets}.
@end defun

@defun check-coding-systems-region start end coding-system-list
Функция проверяет, могут ли системы кодирования в списке
@code{coding-system-list} кодировать все символы в области между @var{start}
и @var{end}.  Если все системы кодирования в списке могут кодировать
указанный текст, функция возвращает @code{nil}.  Если некоторые системы
кодирования не могут кодировать некоторые символы, значение представляет
собой список, каждый элемент которого имеет форму
@code{(@var{coding-system1} @var{pos1} @var{pos2} @dots{})}, что означает,
что @var{coding-system1} не может кодировать символы в позициях буфера
@var{pos1}, @var{pos2}, @enddots{}.

@var{start} может быть строкой, и в этом случае @var{end} игнорируется, а
возвращаемое значение ссылается на строковые индексы, а не на позиции
буфера.
@end defun

@defun detect-coding-region start end &optional highest
Функция выбирает правдоподобную систему кодирования для декодирования текста
от @var{start} до @var{end}.  Этот текст должен быть байтовой
последовательностью, то есть однобайтовым или многобайтовым текстом,
состоящим только из символов @acronym{ASCII} и восьмибитных символов
(@pxref{Explicit Encoding}).

Обычно функция возвращает список систем кодирования, которые могут
обрабатывать декодирование отсканированного текста.  Перечислены они в
порядке убывания приоритета.  Но если @var{highest} равен не-@code{nil}, то
возвращаемое значение - это всего лишь одна система кодирования, имеющая
наивысший приоритет.

Если область содержит только символы @acronym{ASCII}, за исключением таких
управляющих символов ISO-2022 ISO-2022, как @code{ESC}, значение будет
@code{undecided} или @code{(undecided)}, или вариант, определяющий
преобразование конца строки, если это можно вывести из текста.

Если область содержит нулевые байты, значение будет @code{no-conversion},
даже если область содержит текст, закодированный в какой-либо системе
кодирования.
@end defun

@defun detect-coding-string string &optional highest
Функция похожа на @code{detect-coding-region}, за исключением того, что она
работает с содержимым @var{string}, а не с байтами в буфере.
@end defun

@cindex null bytes, and decoding text
@defvar inhibit-null-byte-detection
Если эта переменная имеет значение не-@code{nil}, нулевые байты игнорируются
при обнаружении кодировки области или строки.  Это позволяет правильно
определять кодировку текста, содержащего нулевые байты, например, файлов
Info с узлами индекса.
@end defvar

@defvar inhibit-iso-escape-detection
Если переменная имеет значение не-@code{nil}, escape-последовательности
ISO-2022 игнорируются при обнаружении кодировки области или строки.  В
результате никакой текст никогда не распознается как закодированный в
некоторой кодировке ISO-2022, и все escape-последовательности становятся
видимыми в буфере.
@strong{Предупреждение:} @emph{Использовать эту переменную с особой
осторожностью, потому что многие файлы в дистрибутиве Emacs используют
кодировку ISO-2022.}
@end defvar

@cindex charsets supported by a coding system
@defun coding-system-charset-list coding-system
Функция возвращает список наборов символов (@pxref{Character Sets}),
поддерживаемых @var{coding-system}.  Некоторые системы кодирования, которые
поддерживают слишком много наборов символов, чтобы перечислить их все, дают
специальные значения.:
@itemize @bullet
@item
Если @var{coding-system} поддерживает все символы Emacs, значение равно
@code{(emacs)}.
@item
Если @var{coding-system} поддерживает все символы Unicode, значение равно
@code{(unicode)}.
@item
Если @var{coding-system} поддерживает все кодировки ISO-2022, значение будет
@code{iso-2022}.
@item
Если @var{coding-system} поддерживает все символы во внутренней системе
кодирования, используемой Emacs версии 21 (до реализации внутренней
поддержки Unicode), значение равно @code{emacs-mule}.
@end itemize
@end defun

  @xref{Coding systems for a subprocess,, Process Information}, в частности,
описание функций @code{process-coding-system} и
@code{set-process-coding-system}, как проверять или устанавливать системы
кодирования, используемые для ввода-вывода для подпроцесса.

@node User-Chosen Coding Systems
@subsection Системы Кодирования по Выбору Пользователя

@cindex select safe coding system
@defun select-safe-coding-system from to &optional default-coding-system accept-default-p file
Функция выбирает систему кодирования для кодирования указанного текста,
предлагая пользователю выбрать при необходимости.  Обычно указанный текст -
это текст в текущем буфере между @var{from} и @var{to}.  Если @var{from}
является строкой, строка указывает текст для кодирования, а @var{to}
игнорируется.

Если указанный текст включает необработанные байты
(@pxref{Text Representations}), @code{select-safe-coding-system} предлагает
@code{raw-text} для его кодировки.

Если @var{default-coding-system} равен не-@code{nil}, это первая система
кодирования, которую следует попробовать; если может обработаться текст,
@code{select-safe-coding-system} вернет эту систему кодирования.  Это также
может быть список систем кодирования; затем функция пробует каждый из них по
очереди.  После проверки всех из них затем пробуется текущее значение буфера
@code{buffer-file-coding-system} (если это не @code{undecided}), затем
значение по умолчанию @code{buffer-file-coding-system} и, наконец, наиболее
предпочтительную систему кодирования пользователя, которую пользователь
может установить с помощью команды @code{prefer-coding-system}
(@pxref{Recognize Coding,, Recognizing Coding Systems, emacs, The GNU Emacs Manual}).

Если одна из этих систем кодирования может безопасно закодировать весь
указанный текст, @code{select-safe-coding-system} выбирает его и возвращает.
В противном случае спрашивается пользоватль о выборе из списка систем
кодирования, которые могут кодировать весь текст, и возвращается выбор
пользователя.

@var{default-coding-system} также может быть списком, первым элементом
которого является @code{t}, а другими элементами являются системы
кодирования.  Затем, если никакая система кодирования в списке не может
обработать текст, @code{select-safe-coding-system} немедленно запрашивает
пользователя, не пробуя ни одну из трех альтернатив, описанных выше.  Это
удобно для проверки только систем кодирования в списке.

Необязательный аргумент @var{accept-default-p} определяет, приемлема ли
система кодирования, выбранная без взаимодействия с пользователем.  Если
опущен или @code{nil}, такой тихий выбор всегда приемлем.  Если это
не-@code{nil}, это должна быть функция; @code{select-safe-coding-system}
вызывается эта функция с одним аргументом, базовой системой кодирования
выбранной системы кодирования.  Если функция возвращает @code{nil},
@code{select-safe-coding-system} отклоняет автоматически выбранную систему
кодирования и просит пользователя выбрать систему кодирования из списка
возможных кандидатов.

@vindex select-safe-coding-system-accept-default-p
Если переменная @code{select-safe-coding-system-accept-default-p} -
не-@code{nil}, это должна быть функция, принимающая единственный аргумент.
Он используется вместо @var{accept-default-p}, переопределяя любое значение,
указанное для этого аргумента.

В качестве последнего шага, перед возвратом выбранной системы кодирования,
@code{select-safe-coding-system} проверяет, согласуется ли эта система
кодирования с тем, что было бы выбрано, если бы содержимое области было
прочитано из файла.  (В противном случае это может привести к повреждению
данных в файле, который впоследствии будет повторно посещен и
отредактирован.)  Обычно @code{select-safe-coding-system} использует
@code{buffer-file-name} в качестве файла для этой цели, но если @var{file}
имеет значение не-@code{nil}, используется этот файл (это может быть
актуально для @code{write-region} и аналогичным функциям).  Если
обнаруживается явное несоответствие, @code{select-safe-coding-system}
запрашивает пользователя перед выбором системы кодирования.
@end defun

@defvar select-safe-coding-system-function
Переменная именует функцию, которая должна быть вызвана, чтобы попросить
пользователя выбрать правильную систему кодирования для кодирования текста,
когда система кодирования по умолчанию для операции вывода не может
безопасно кодировать этот текст.  Значение по умолчанию для этой переменной
- @code{select-safe-coding-system}.  Примитивы Emacs, которые записывают
текст в файлы, такие как @code{write-region}, или отправляют текст в другие
процессы, такие как @code{process-send-region}, обычно используют значение
этой переменной, если @code{coding-system-for-write} не привязан к значению
не-@code{nil} (@pxref{Specifying Coding Systems}).
@end defvar

  Вот две функции, которые можно использовать, чтобы позволить пользователю
указать систему кодирования с завершением.  @xref{Completion}.

@defun read-coding-system prompt &optional default
Функция считывает систему кодирования с помощью минибуфера, запрашивая
строку @var{prompt}, и возвращает имя системы кодирования в виде символа.
Если пользователь вводит нулевой ввод, @var{default} указывает, какую
систему кодирования нужно вернуть. Это должен быть символ или строка.
@end defun

@defun read-non-nil-coding-system prompt
Функция считывает систему кодирования с помощью минибуфера, запрашивая
строку @var{prompt}, и возвращает имя системы кодирования в виде символа.
Если пользователь пытается ввести нулевой ввод, он просит пользователя
повторить попытку.  @xref{Coding Systems}.
@end defun

@node Default Coding Systems
@subsection Системы Кодирования по Умолчанию
@cindex default coding system
@cindex coding system, automatically determined

  В этом разделе описываются переменные, которые определяют систему
кодирования по умолчанию для определенных файлов или при выполнении
определенных подпрограмм, а также функции, которые операции ввода-вывода
используют для доступа к ним.

  Идея этих переменных заключается в том, что устанавлены они раз и
устанавливают значения по умолчанию, которые требуются, а затем больше не
меняются.  Чтобы указать конкретную систему кодирования для конкретной
операции в программе на Lisp, не изменять эти переменные; вместо этого
переопределить их, используя @code{coding-system-for-read} и
@code{coding-system-for-write} (@pxref{Specifying Coding Systems}).

@cindex file contents, and default coding system
@defopt auto-coding-regexp-alist
Переменная представляет собой список текстовых шаблонов и соответствующих
систем кодирования.  Каждый элемент имеет вид
@code{(@var{regexp} . @var{coding-system})}; файл, первые несколько
килобайт которого совпадают с @var{regexp}, декодируется с помощью
@var{coding-system}, когда его содержимое считывается в буфер.  Настройки в
этом списке имеют приоритет над тегами @code{coding:} в файлах и содержимым
@code{file-coding-system-alist} (смотреть ниже) значение по умолчанию
установлено так, что Emacs автоматически распознает почтовые файлы в формате
Babyl и читает их без преобразования кода.
@end defopt

@cindex file name, and default coding system
@defopt file-coding-system-alist
Переменная представляет собой список, который определяет системы
кодирования, используемые для чтения и записи определенных файлов.  Каждый
элемент имеет форму @code{(@var{pattern} . @var{coding})}, где @var{pattern}
- регулярное выражение, которое соответствует определенным именам файлов.
Элемент применяется к именам файлов, которые соответствуют @var{pattern}.

@sc{cdr} элемента @var{coding} должен быть либо системой кодирования,
cons-ячейкой, содержащей две системы кодирования, либо именем функции
(символ с определением функции).  Если @var{coding} - это система
кодирования, эта система кодирования используется как для чтения файла, так
и для его записи.  Если @var{coding} - это cons-ячейка, содержащая две
системы кодирования, ее @sc{car} задает систему кодирования для
декодирования, а ее @sc{cdr} указывает систему кодирования для кодирования.

Если @var{coding} - это имя функции, функция должна принимать один аргумент,
список всех аргументов, переданных в @code{find-operation-coding-system}.
Она должена возвращать систему кодирования или cons-ячейку, содержащую две
системы кодирования.  Это значение имеет то же значение, что описано выше.

Если @var{coding} (или то, что возвращает вышеуказанная функция) -
@code{undecided}, выполняется обычное определение кода.
@end defopt

@defopt auto-coding-alist
Переменная представляет собой список, который определяет системы
кодирования, используемые для чтения и записи определенных файлов.  По форме
она похожа на @code{file-coding-system-alist}, но, в отличие от последней,
эта переменная имеет приоритет над любыми тегами @code{coding:} в файле.
@end defopt

@cindex program name, and default coding system
@defvar process-coding-system-alist
Переменная представляет собой список, определяющий, какие системы
кодирования использовать для подпроцесса, в зависимости от того, какая
программа выполняется в подпроцессе.  Работает как
@code{file-coding-system-alist}, за исключением того, что @var{pattern}
сопоставляется с именем программы, используемым для запуска подпроцесса.
Система или системы кодирования, указанные в этом списке, используются для
инициализации систем кодирования, используемых для ввода-вывода, для
подпроцесса, но можно указать другие системы кодирования позже, используя
@code{set-process-coding-system}.
@end defvar

  @strong{Предупреждение:} Системы кодирования, такие как @code{undecided},
которые определяют систему кодирования по данным, не работают полностью
надежно с асинхронным выводом подпроцесса.  Это потому, что Emacs
обрабатывает вывод асинхронного подпроцесса пакетами по мере поступления.
Если система кодирования оставляет неопределенным преобразование кода
символа или оставляет неопределенным преобразование конца строки, Emacs
должен попытаться определить правильное преобразование одного пакета за раз,
а это не всегда работает.

  Следовательно, с асинхронным подпроцессом, если это вообще возможно,
использовать систему кодирования, которая определяет как преобразование кода
символа, так и преобразование конца строки, то есть такую, как
@code{latin-1-unix}, а не @code{undecided} или @code{latin-1}.

@cindex port number, and default coding system
@cindex network service name, and default coding system
@defvar network-coding-system-alist
Переменная представляет собой список, который указывает систему кодирования,
используемую для сетевых потоков.  Работает так же, как
@code{file-coding-system-alist}, с той разницей, что @var{pattern} в
элементе может быть либо номером порта, либо регулярным выражением.  Если
это регулярное выражение, оно сопоставляется с именем сетевой службы,
используемым для открытия сетевого потока.
@end defvar

@defvar default-process-coding-system
Переменная определяет системы кодирования, используемые для ввода и вывода
подпроцесса (и сетевого потока), когда ничто другое не указывает, что
делать.

Значение должно быть cons-ячейкой вида
@code{(@var{input-coding} . @var{output-coding})}.  Здесь @var{input-coding}
применяется к вводу из подпроцесса, а @var{output-coding} применяется к
выводу в него.
@end defvar

@cindex default coding system, functions to determine
@defopt auto-coding-functions
Переменная содержит список функций, которые пытаются определить систему
кодирования файла на основе его недекодированного содержимого.

Каждая функция в этом списке должна быть написана для просмотра текста в
текущем буфере, но не должна изменять его каким-либо образом.  Буфер будет
содержать текст частей файла.  Каждая функция должна принимать один аргумент
@var{size}, который сообщает, сколько символов нужно искать, начиная с
точки.  Если функции удается определить систему кодирования для файла, 
возвращается эта систему кодирования.  В противном случае возвращается
@code{nil}.

Функции в этом списке могут быть вызваны либо при посещении файла, и Emacs
хочет декодировать его содержимое, и/или когда буфер файла собирается быть
сохраненным, и Emacs хочет определить, как кодировать его содержимое.

Если файл имеет тег @samp{coding:}, он имеет приоритет, поэтому эти функции
не будут вызываться.
@end defopt

@defun find-auto-coding filename size
Функция пытается определить подходящую систему кодирования для
@var{filename}.  Проверяется буфер, обращающийся к названному файлу,
используя последовательно задокументированные выше переменные, пока не
найдет соответствие одному из правил, заданных этими переменными.  Затем
возвращается cons-ячейка вида @code{(@var{coding} . @var{source})}, где
@var{coding} - это используемая система кодирования, а @var{source} - это
символ, один из @code{auto-coding-alist}, @code{auto-coding-regexp-alist},
@code{:coding} или @code{auto-coding-functions}, указывающий, какой из них
предоставил правило сопоставления.  Значение @code{:coding} означает, что
система кодирования была указана тегом @code{coding:} в файле
(@pxref{Specify Coding,, coding tag, emacs, The GNU Emacs Manual}).  Порядок
поиска правила соответствия: сначала @code{auto-coding-alist}, затем
@code{auto-coding-regexp-alist}, затем тег @code{coding:} и, наконец,
@code{auto-coding-functions}.  Если подходящего правила не найдено, функция
возвращает @code{nil}.

Второй аргумент @var{size} - это размер текста в символах после точки.
Функция проверяет текст только в пределах @var{size} символов после точки.
Обычно при вызове этой функции буфер должен располагаться в начале, потому
что одно из мест для тега @code{coding:} - это первые одна или две строки
файла; в этом случае @var{size} должен быть размером буфера.
@end defun

@defun set-auto-coding filename size
Функция возвращает подходящую систему кодирования для файла @var{filename}.
Используется @code{find-auto-coding} для поиска системы кодирования.  Если
система кодирования не может быть определена, функция возвращает @code{nil}.
Смысл аргумента @var{size} аналогичен аргументу @code{find-auto-coding}.
@end defun

@defun find-operation-coding-system operation &rest arguments
Функция возвращает систему кодирования, используемую (по умолчанию) для
выполнения @var{operation} с @var{arguments}.  Значение имеет такую форму:

@example
(@var{decoding-system} . @var{encoding-system})
@end example

Первый элемент, @var{decoding-system}, - это система кодирования,
используемая для декодирования (в случае, если @var{operation} выполняет
декодирование), а @var{encoding-system} - это система кодирования для
кодирования (в случае, если @var{operation} выполняет кодирование).

Аргумент @var{operation} - символ; это должно быть одно из
@code{write-region}, @code{start-process}, @code{call-process},
@code{call-process-region}, @code{insert-file-contents} или
@code{open-network-stream}.  Это имена примитивов ввода-вывода Emacs,
которые могут выполнять преобразование символьного кода и eol.

Остальные аргументы должны быть теми же аргументами, которые могут быть
переданы соответствующему примитиву ввода-вывода.  В зависимости от
примитива один из этих аргументов выбирается как @dfn{target}.  Например,
если @var{operation} выполняет файловый ввод-вывод, любой аргумент,
указывающий имя файла, является целью.  Для примитивов подпроцесса целью
является имя процесса.  Для @code{open-network-stream} целью является имя
службы или номер порта.

В зависимости от @var{operation} эта функция ищет цель в
@code{file-coding-system-alist}, @code{process-coding-system-alist}, или
@code{network-coding-system-alist}.  Если цель найдена в списке,
@code{find-operation-coding-system} возвращает ее ассоциацию в списке; в
противном случае возвращается @code{nil}.

Если @var{operation} равнятся @code{insert-file-contents}, аргумент,
соответствующий цели, может быть cons-ячейкой формы
@code{(@var{filename} . @var{buffer})}.  В этом случае @var{filename} - это
имя файла для поиска в @code{file-coding-system-alist}, а @var{buffer} - это
буфер, содержащий содержимое файла (еще не декодированное).  Если
@code{file-coding-system-alist} указывает функцию, вызываемую для этого
файла, и эта функция должна проверять содержимое файла (как обычно), она
должна проверять содержимое @var{buffer} вместо чтения файла.
@end defun

@node Specifying Coding Systems
@subsection Указание Системы Кодирования для Одной Операции
@cindex specify coding system
@cindex force coding system for operation
@cindex coding system for operation

  Можно указать систему кодирования для конкретной операции, привязав
переменные @code{coding-system-for-read} и/или
@code{coding-system-for-write}.

@defvar coding-system-for-read
Если эта переменная - не-@code{nil}, она указывает систему кодирования,
используемую для чтения файла или для ввода из синхронного подпроцесса.

Это также применимо к любому асинхронному подпроцессу или сетевому потоку,
но по-другому: значение @code{coding-system-for-read}, когда запускается
подпроцесс или открывается сетевой поток, определяется метод декодирования
входных данных для этого подпроцесса или сетевого потока.  Это остается в
использовании для этого подпроцесса или сетевого потока до тех пор, пока не
будет отменено.

Правильный способ использования этой переменной - связать ее с @code{let}
для конкретной операции ввода-вывода.  Её глобальное значение обычно
@code{nil}, и не нужно глобально устанавливать для неё какое-либо другое
значение.  Вот пример правильного использования переменной:

@example
;; @r{Прочитать файл без преобразования кода символа.}
(let ((coding-system-for-read 'no-conversion))
  (insert-file-contents filename))
@end example

Когда ее значение - не-@code{nil}, переменная имеет приоритет над всеми
другими методами определения системы кодирования, используемой для ввода,
включая @code{file-coding-system-alist}, @code{process-coding-system-alist}
и @code{network-coding-system-alist}.
@end defvar

@defvar coding-system-for-write
Это работает так же, как @code{coding-system-for-read}, за исключением того,
что применяется к выводу, а не к вводу.  Влияет на запись в файлы, а также
на отправку вывода в подпроцессы и сетевые соединения.  Это также применимо
к кодированию аргументов командной строки, с которыми Emacs вызывает
подпроцессы.

Когда одна операция выполняет и ввод, и вывод, как и
@code{call-process-region} и @code{start-process}, на нее влияют оба
@code{coding-system-for-read} и @code{coding-system-for-write}.
@end defvar

@defvar coding-system-require-warning
Привязка @code{coding-system-for-write} к значению не-@code{nil}
предотвращает вызов выходных примитивов функции, указанной
@code{select-safe-coding-system-function}
(@pxref{User-Chosen Coding Systems}).  Это потому, что @kbd{C-x @key{RET} c}
(@code{universal-coding-system-argument}) работает путем связывания
@code{coding-system-for-write}, а Emacs должен подчиняться выбору
пользователя.  Если программа на Lisp связывает
@code{coding-system-for-write} со значением, которое может быть небезопасным
для кодирования записываемого текста, также может привязаться
@code{coding-system-require-warning} к значению не-@code{nil}, что заставит
выходные примитивы проверять кодировку, вызывая значение
@code{select-safe-coding-system-function}, даже если
@code{coding-system-for-write} - это не-@code{nil}.  В качестве альтернативы
вызывается @code{select-safe-coding-system} явно перед использованием
указанной кодировки.
@end defvar

@defopt inhibit-eol-conversion
Когда эта переменная - не-@code{nil}, преобразование конца строки не
выполняется, независимо от того, какая система кодирования указана.  Это
относится ко всем примитивам ввода-вывода и подпроцесса Emacs, а также к
функциям явного кодирования и декодирования (@pxref{Explicit Encoding}).
@end defopt

@cindex priority order of coding systems
@cindex coding systems, priority
  Иногда требуется предпочесть несколько систем кодирования для какой-либо
операции, а не исправлять одну.  Emacs позволяет указать порядок приоритета
для использования систем кодирования.  Этот порядок влияет на сортировку
списков систем кодирования, возвращаемых такими функциями, как
@code{find-coding-systems-region} (@pxref{Lisp and Coding Systems}).

@defun coding-system-priority-list &optional highestp
Функция возвращает список систем кодирования в порядке их текущих
приоритетов.  Необязательный аргумент @var{highestp}, если не-@code{nil},
означает возврат только системы кодирования с наивысшим приоритетом.
@end defun

@defun set-coding-system-priority &rest coding-systems
Функция помещает @var{coding-systems} в начало списка приоритетов для систем
кодирования, тем самым делая их приоритет выше всех остальных.
@end defun

@defmac with-coding-priority coding-systems &rest body@dots{}
Этот макрос выполняет @var{body}, как @code{progn} выполняет
(@pxref{Sequencing, progn}), с @var{coding-systems} в начале списка
приоритетов для систем кодирования.  @var{coding-systems} должно быть
списком систем кодирования, которые следует предпочесть при выполнении
@var{body}.
@end defmac

@node Explicit Encoding
@subsection Явное Кодирование и Декодирование
@cindex encoding in coding systems
@cindex decoding in coding systems

  Все операции по передаче текста в Emacs и из него могут использовать
систему кодирования для кодирования или декодирования текста.  Также можно
явно кодировать и декодировать текст, используя функции в этом разделе.

  Результат кодирования и вход для декодирования - это не обычный текст.
Логически состоят из серии байтовых значений; то есть серия из
@acronym{ASCII} и восьмибитных символов.  В однобайтовых буферах и строках
эти символы имеют коды в диапазоне от 0 до #xFF (255).  В многобайтовом
буфере или строке восьмибитные символы имеют коды символов выше, чем
#xFF (@pxref{Text Representations}), но Emacs прозрачно преобразует их в их
однобайтовые значения, когда кодируется или декодируется такой текст.

  Обычный способ прочитать файл в буфер как последовательность байтов, для
явного декодирования содержимого, - это
@code{insert-file-contents-literally} (@pxref{Reading from Files}); в
качестве альтернативы указывается аргумент не-@code{nil} @var{rawfile} при
обращении к файлу с @code{find-file-noselect}.  Эти методы приводят к
созданию однобайтового буфера.

  Обычный способ использования байтовой последовательности, полученной в
результате явного кодирования текста, - это скопировать ее в файл или
процесс, например, записать ее с помощью @code{write-region}
(@pxref{Writing to Files}) и подавить кодирование путем привязки
@code{coding-system-for-write} к @code{no-conversion}.

  Вот функции для выполнения явного кодирования или декодирования.  Функции
кодирования создают последовательности байтов; функции декодирования
предназначены для работы с последовательностями байтов.  Все эти функции
отбрасывают свойства текста.  Они также установливают
@code{last-coding-system-used} в точную систему кодирования, которую они
использовали.

@deffn Command encode-coding-region start end coding-system &optional destination
Команда кодирует текст от @var{start} до @var{end} в соответствии с системой
кодирования @var{coding-system}.  Обычно закодированный текст заменяет
исходный текст в буфере, но необязательный аргумент @var{destination} может
это изменить.  Если @var{destination} является буфером, закодированный текст
вставляется в этот буфер после точки (точка не перемещается); если это
@code{t}, команда возвращает закодированный текст как однобайтную строку, не
вставляя ее.

Если закодированный текст вставлен в некоторый буфер, эта команда возвращает
длину закодированного текста.

Результатом кодирования логически является последовательность байтов, но
буфер остается многобайтовым, если до этого он был многобайтовым, и любые
8-битные байты преобразуются в их многобайтовое представление
(@pxref{Text Representations}).

@cindex @code{undecided} coding-system, when encoding
Использовать @emph{не} @code{undecided} вместо @var{coding-system} при
кодировании текста, так как это может привести к неожиданным результатам.
Вместо этого используйте @code{select-safe-coding-system}
(@pxref{User-Chosen Coding Systems, select-safe-coding-system}), чтобы
предложить подходящую кодировку, если нет очевидного подходящего значения
для @var{coding-system}.
@end deffn

@defun encode-coding-string string coding-system &optional nocopy buffer
Функция кодирует текст в @var{string} в соответствии с системой кодирования
@var{coding-system}.  Возвращается новая строка, содержащая закодированный
текст, за исключением случая, когда @var{nocopy} имеет значение
не-@code{nil}, и в этом случае функция может вернуть @var{string} сама, если
операция кодирования тривиальна.  Результатом кодирования является
однобайтная строка.
@end defun

@deffn Command decode-coding-region start end coding-system &optional destination
Команда декодирует текст от @var{start} до @var{end} в соответствии с
системой кодирования @var{coding-system}.  Чтобы сделать явное декодирование
полезным, текст перед декодированием должен быть последовательностью
байтовых значений, но допустимы как многобайтовые, так и однобайтовые буферы
(в многобайтовом случае необработанные байтовые значения должны быть
представлены в виде восьмибитных символов).  Обычно декодированный текст
заменяет исходный текст в буфере, но необязательный аргумент
@var{destination} может это изменить.  Если @var{destination} является
буфером, декодированный текст вставляется в этот буфер после точки (точка не
перемещается); если это @code{t}, команда возвращает декодированный текст
как многобайтовую строку, не вставляя ее.

Если декодированный текст вставлен в некоторый буфер, эта команда возвращает
длину декодированного текста.  Если этот буфер представляет собой
однобайтный буфер (@pxref{Selecting a Representation}), внутреннее
представление декодированного текста (@pxref{Text Representations})
вставляется в буфер как отдельные байты.

Команда помещает текстовое свойство @code{charset} в декодированный текст.
Значение свойства указывает набор символов, используемый для декодирования
исходного текста.
@end deffn

@defun decode-coding-string string coding-system &optional nocopy buffer
Функция декодирует текст в @var{string} согласно @var{coding-system}.
Возвращается новая строка, содержащая декодированный текст, за исключением
случаев, когда @var{nocopy} имеет значение не-@code{nil}, и в этом случае
функция может вернуть @var{string} сама, если операция декодирования
тривиальна.  Чтобы сделать явное декодирование полезным, содержимое
@var{string} должно быть однобайтной строкой с последовательностью байтовых
значений, но также допустима и многобайтовая строка (при условии, что она
содержит 8-битные байты в их многобайтовой форме).

Если необязательный аргумент @var{buffer} указывает буфер, декодированный
текст вставляется в этот буфер после точки (точка не перемещается).  В этом
случае возвращаемое значение - длина декодированного текста.  Если этот
буфер является однобайтовым буфером, внутреннее представление
декодированного текста вставляется в него как отдельные байты.

@cindex @code{charset}, text property
Функция помещает текстовое свойство @code{charset} в декодированный текст.
Значение свойства указывает набор символов, используемый для декодирования
исходного текста:

@example
@group
(decode-coding-string "Gr\374ss Gott" 'latin-1)
     @result{} #("Grüss Gott" 0 9 (charset iso-8859-1))
@end group
@end example
@end defun

@defun decode-coding-inserted-region from to filename &optional visit beg end replace
Функция декодирует текст от @var{from} до @var{to}, как если бы он читался
из файла @var{filename} с использованием @code{insert-file-contents},
используя остальные предоставленные аргументы.

Обычно эту функцию можно использовать после чтения текста из файла без
декодирования, если решается, что предпочительнее бы его декодировать.
Вместо удаления текста и его повторного чтения, на этот раз с
декодированием, можно вызвать эту функцию.
@end defun

@node Terminal I/O Encoding
@subsection Кодирование Ввода/Вывода Терминала

  Emacs может использовать системы кодирования для декодирования ввода с
клавиатуры и кодирования вывода терминала.  Это полезно для терминалов,
которые передают или отображают текст с использованием определенной
кодировки, например Latin-1.  Emacs не устанавливает
@code{last-coding-system-used} при кодировании или декодировании
терминального ввода-вывода.

@defun keyboard-coding-system &optional terminal
Функция возвращает систему кодирования, используемую для декодирования ввода
с клавиатуры из @var{terminal}.  Значение @code{no-conversion} означает, что
декодирование не выполняется.  Если @var{terminal} опущен или @code{nil},
это означает, что выбранный фрейм терминал.  @xref{Multiple Terminals}.
@end defun

@deffn Command set-keyboard-coding-system coding-system &optional terminal
Команда указывает @var{coding-system} как систему кодирования, используемую
для декодирования ввода с клавиатуры из @var{terminal}.  Если
@var{coding-system} равен @code{nil}, это означает, что ввод с клавиатуры не
декодируется.  Если @var{terminal} - это фрейм, это означает, что это
терминал фрейма; если это @code{nil}, это означает терминал текущего
выбранного фрейма.  @xref{Multiple Terminals}.
@end deffn

@defun terminal-coding-system &optional terminal
Функция возвращает систему кодирования, которая используется для кодирования
вывода терминала из @var{terminal}.  Значение @code{no-conversion} означает,
что кодирование не выполняется.  Если @var{terminal} - это фрейм, это
означает, что это терминал фрейма; если это @code{nil}, это означает
терминал текущего выбранного фрейма.
@end defun

@deffn Command set-terminal-coding-system coding-system &optional terminal
Команда указывает @var{coding-system} как систему кодирования, используемую
для кодирования вывода терминала из @var{terminal}.
Если @var{coding-system} равен @code{nil}, это означает, что вывод терминала
не кодируется.  Если @var{terminal} - это фрейм, это означает, что это
терминал фрейма; если это @code{nil}, это означает терминал текущего
выбранного фрейма.
@end deffn

@node Input Methods
@section Методы Ввода
@cindex input methods

  @dfn{Метод ввода} предоставляет удобный способ ввода символов
не-@acronym{ASCII} с клавиатуры.  В отличие от систем кодирования, которые
переводят символы не-@acronym{ASCII} в кодировки, предназначенные для чтения
программами, и обратно, методы ввода предоставляют удобные для человека
команды.  (@xref{Input Methods,,, emacs, The GNU Emacs Manual}, для
информации о том, как пользователи используют методы ввода для ввода
текста.)  Как определять методы ввода, еще не описано в этом руководстве, но
здесь описывается, как их использовать.

  У каждого метода ввода есть имя, которое в настоящее время является
строкой; в будущем символы могут также использоваться в качестве имен
методов ввода.

@defvar current-input-method
Переменная содержит имя метода ввода, который теперь активен в текущем
буфере.  (Она автоматически становится локальной в каждом буфере, если
установлена любым способом.)  @code{nil}, если в данный момент в буфере
не активен ни один метод ввода.
@end defvar

@defopt default-input-method
Переменная содержит метод ввода по умолчанию для команд, выбирающих метод
ввода.  В отличие от @code{current-input-method}, эта переменная обычно
глобальная.
@end defopt

@deffn Command set-input-method input-method
Команда активирует метод ввода @var{input-method} для текущего буфера.
Также устанавливает @code{default-input-method} в @var{input-method}.  Если
@var{input-method} - @code{nil}, эта команда деактивирует любой метод ввода
для текущего буфера.
@end deffn

@defun read-input-method-name prompt &optional default inhibit-null
Функция считывает имя метода ввода с помощью минибуфера, запрашивая
@var{prompt}.  Если @var{default} равен не-@code{nil}, оно возвращается по
умолчанию, если пользователь вводит пустой ввод.  Однако, если
@var{inhibit-null} равен не-@code{nil}, пустой ввод сигнализирует об ошибке.

Возвращаемое значение - строка.
@end defun

@defvar input-method-alist
Переменная определяет все поддерживаемые методы ввода.  Каждый элемент
определяет один метод ввода и должен иметь форму:

@example
(@var{input-method} @var{language-env} @var{activate-func}
 @var{title} @var{description} @var{args}...)
@end example

Здесь @var{input-method} - имя метода ввода, строка; @var{language-env} -
другая строка, имя языковой среды, для которой рекомендуется этот метод
ввода.  (Это служит только для целей документации.)

@var{activate-func} - это функция, вызываемая для активации этого метода.
@var{args}, если есть, передаются в качестве аргументов в
@var{activate-func}.  В общем, аргументами @var{activate-func} являются
@var{input-method} и @var{args}.

@var{title} - это строка, отображаемая в строке режима, пока этот метод
активен.  @var{description} - строка, описывающая этот метод и его
назначение.
@end defvar

  Основной интерфейс к методам ввода - через переменную
@code{input-method-function}.  @xref{Reading One Event} и
@ref{Invoking the Input Method}.

@node Locales
@section Локали
@cindex locale

  В POSIX языковые стандарты определяют, какой язык использовать в языковых
функциях.  Эти переменные Emacs управляют тем, как Emacs взаимодействует с
этими функциями.

@defvar locale-coding-system
@cindex keyboard input decoding on X
Переменная определяет систему кодирования, которая будет использоваться для
декодирования системных сообщений об ошибках и --- только в системе X Window
--- ввод с клавиатуры, для отправки пакетного вывода в стандартный поток
вывода и ошибок, для кодирования аргумента формата в
@code{format-time-string} и для декодирование возвращаемого значения
@code{format-time-string}.
@end defvar

@defvar system-messages-locale
Переменная определяет языковой стандарт, который будет использоваться для
создания сообщений об ошибках системы.  Изменение языкового стандарта может
привести к тому, что сообщения будут выводиться на другом языке или в другой
орфографии.  Если переменная - @code{nil}, локаль определяется переменными
среды обычным способом POSIX.
@end defvar

@defvar system-time-locale
Переменная определяет языковой стандарт, используемый для форматирования
значений времени.  Изменение языкового стандарта может привести к тому, что
сообщения будут отображаться в соответствии с соглашениями на другом языке.
Если переменная - @code{nil}, локаль определяется переменными среды обычным
способом POSIX.
@end defvar

@defun locale-info item
Функция возвращает данные языкового стандарта @var{item} для текущего
языкового стандарта POSIX, если они доступны.  @var{item} должен быть одним
из этих символов:

@table @code
@item codeset
Вернуть набор символов в виде строки (элемент локали @code{CODESET}).

@item days
Возвращает 7-элементный вектор названий дней (элементы локали от
@code{DAY_1} до @code{DAY_7});

@item months
Возвращает вектор из 12 элементов с названиями месяцев (элементы локали от
@code{MON_1} до @code{MON_12}).

@item paper
Возвращает список @code{(@var{width} @var{height})} для размера бумаги по
умолчанию, измеряемого в миллиметрах (элементы локали @code{PAPER_WIDTH} и
@code{PAPER_HEIGHT}).
@end table

Если система не может предоставить запрошенную информацию или @var{item} не
является одним из этих символов, значение будет @code{nil}.  Все строки в
возвращаемом значении декодируются с помощью @code{locale-coding-system}.
@xref{Locales,,, libc, The GNU Libc Manual}, для получения дополнительной
информации о локали и элементах локали.
@end defun
