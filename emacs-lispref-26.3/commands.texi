@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2019 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Command Loop
@chapter Командный Цикл
@cindex editor command loop
@cindex command loop

  Когда запускается Emacs, он почти сразу же попадает в
@dfn{редактор командного цикла}.  Этот цикл считывает ключевые
последовательности, выполняет их определения и отображает результаты.  В
этой главе описывается, как это делается, и подпрограммы, которые позволяют
программам на Lisp это делать.

@menu
* Command Overview::    Как цикл команд читает команды.
* Defining Commands::   Определение, как функция должна читать аргументы.
* Interactive Call::    Вызов команды для чтения аргументов.
* Distinguish Interactive:: Различие выполнения интерактивного вызова команды.
* Command Loop Info::   Переменные, задаваемые командным циклом, которые можно проверить.
* Adjusting Point::     Управление точкой после команды.
* Input Events::        Как выглядит ввод, когда его читают.
* Reading Input::       Как читать события ввода с клавиатуры или мыши.
* Special Events::      События обрабатываются немедленно и индивидуально.
* Waiting::             Ожидание ввода пользователя или истекание времени.
* Quitting::            Как работает @kbd{C-g}.  Как поймать или отложить выход.
* Prefix Command Arguments::    Как работают команды для установки префиксного аргумента.
* Recursive Editing::   Ввод рекурсивного редактирования и почему обычно
                               этого не следует делать.
* Disabling Commands::  Как цикл команд обрабатывает отключенные команды.
* Command History::     Как настраивается история команд и как к ней можно
                               получить доступ.
* Keyboard Macros::     Как реализованы макросы клавиатуры.
@end menu

@node Command Overview
@section Командный Цикл Обзор

  Первое, что должен сделать командный цикл, - это прочитать
последовательность ключей, которая представляет собой последовательность
событий ввода, которая преобразуется в команду.  Это делается путем вызова
функции @code{read-key-sequence}.  Программы на Lisp также могут вызывать
эту функцию (@pxref{Key Sequence Input}).  Они также могут читать ввод на
более низком уровне с помощью @code{read-key} или @code{read-event}
(@pxref{Reading One Event}) или отклонять ожидающий ввод с помощью
@code{discard-input} (@pxref{Event Input Misc}).

  Последовательность ключей преобразуется в команду через текущие активные
ключевые карты.  @xref{Key Lookup}, чтобы узнать, как это делается.
Результатом должен быть макрос клавиатуры или интерактивно вызываемая
функция.  Если ключ - @kbd{M-x}, он считывает имя другой команды, которую
затем вызывает.  Делается это командой @code{execute-extended-command}
(@pxref{Interactive Call}).

  Перед выполнением команды Emacs запускает @code{undo-boundary} для
создания границы отмены.  @xref{Maintaining Undo}.

  Чтобы выполнить команду, Emacs сначала читает ее аргументы, вызывая
@code{command-execute} (@pxref{Interactive Call}).  Для команд, написанных
на Lisp, спецификация @code{interactive} говорит, как читать аргументы.  Это
может использовать префиксный аргумент (@pxref{Prefix Command Arguments})
или может читаться с подсказкой в минибуфере (@pxref{Minibuffers}).
Например, команда @code{find-file} имеет спецификацию @code{interactive}, в
которой говорится, что имя файла следует читать с помощью минибуфера.  Тело
функции @code{find-file} не использует минибуфер, поэтому, если вызывается
@code{find-file} как функция из кода Lisp, потребуется предоставить строку
имени файла как обычный аргумент функции Lisp.

  Если команда является макросом клавиатуры (т. е. строкой или вектором),
Emacs выполняет ее, используя @code{execute-kbd-macro} (@pxref{Keyboard Macros}).

@defvar pre-command-hook
Этот нормальный перехватчик запускается редактором командного цикла перед
выполнением каждой команды.  В это время @code{this-command} содержит
команду, которая будет запущена, а @code{last-command} описывает предыдущую
команду.  @xref{Command Loop Info}.
@end defvar

@defvar post-command-hook
Эта обычная ловушка запускается редактором командного цикла после выполнения
каждой команды (включая команды, преждевременно завершенные из-за выхода или
из-за ошибок).  В то время @code{this-command} относится к только что
запущенной команде, а @code{last-command} относится к команде до этого.

Эта ловушка также запускается, когда Emacs впервые входит в командный цикл
(в этот момент оба объекта @code{this-command} and @code{last-command} равны
@code{nil}).
@end defvar

  Выход подавляется во время работы @code{pre-command-hook} и
@code{post-command-hook}.  Если при выполнении одной из этих ловушек
возникает ошибка, выполнение ловушки не прекращается; вместо этого ошибка
заглушается, а функция, в которой возникла ошибка, удаляется из ловушки.

  Запрос, поступающий на сервер Emacs
(@pxref{Emacs Server,,, emacs, The GNU Emacs Manual}), запускает эти два
перехватчика так же, как и клавиатурная команда.

@node Defining Commands
@section Определение Команд
@cindex defining commands
@cindex commands, defining
@cindex functions, making them interactive
@cindex interactive function

  Специальная форма @code{interactive} превращает функцию Lisp в команду.
Форма @code{interactive} должна располагаться на верхнем уровне в теле
функции, обычно как первая форма в теле; это относится как к
лямбда-выражением (@pxref{Lambda Expressions}), так и к @code{defun} формам
(@pxref{Defining Functions}).  Эта форма ничего не делает во время
фактического выполнения функции; его присутствие служит флагом, сообщающим
командному циклу Emacs, что функция может быть вызвана интерактивно.
Аргумент формы @code{interactive} указывает, как следует читать аргументы
интерактивного вызова.

@cindex @code{interactive-form} property
  В качестве альтернативы, форма @code{interactive} может быть указана в
свойстве @code{interactive-form} символа функции.  Значение не-@code{nil}
для этого свойства имеет приоритет над любой формой @code{interactive} в
теле функции.  Эта функция используется редко.

@anchor{The interactive-only property}
@cindex @code{interactive-only} property
  Иногда функция предназначена только для интерактивного вызова, а не для
прямого вызова из Lisp.  В этом случае присваивается функции свойство
не-@code{nil} @code{interactive-only} либо напрямую, либо через
@code{declare} (@pxref{Declare Form}).  Это заставляет байт компилятор
предупреждать, если команда вызывается из Lisp.  Вывод
@code{describe-function} будет включать аналогичную информацию.  Значением
свойства может быть: строка, которую байт компилятор будет использовать
непосредственно в своем предупреждении (она должна заканчиваться точкой, и
не начинаться с заглавной буквы, например,
@code{"use (system-name) instead."}); @code{t}; любой другой символ, который
должен быть альтернативой функция для использования в коде Lisp.

Универсальные функции (@pxref{Generic Functions}) нельзя превратить в
команды, добавив к ним форму @code{interactive}.

@menu
* Using Interactive::     Общие правила для @code{interactive}.
* Interactive Codes::     Стандартные буквенные коды для чтения аргументов
                            различными способами.
* Interactive Examples::  Примеры того, как читать интерактивные аргументы.
* Generic Commands::      Выберите среди альтернативных команд.
@end menu

@node Using Interactive
@subsection Использование @code{interactive}
@cindex arguments, interactive entry
@cindex interactive spec, using

  В этом разделе описывается, как написать форму @code{interactive}, которая
делает функцию Lisp интерактивно вызываемой командой, и как исследовать
форму @code{interactive} команды.

@defspec interactive arg-descriptor
Эта специальная форма объявляет, что функция является командой, и поэтому
она может вызываться интерактивно (через @kbd{M-x} или путем ввода связанной
с ней последовательности ключей).  Аргумент @var{arg-descriptor} объявляет,
как вычислять аргументы команды, когда команда вызывается в интерактивном
режиме.

Команду можно вызывать из программ на Lisp, как и любую другую функцию, но
тогда вызывающий предоставляет аргументы, и @var{arg-descriptor} не имеет
никакого эффекта.

@cindex @code{interactive-form}, symbol property
Форма @code{interactive} должна располагаться на верхнем уровне в теле
функции или в свойстве (@pxref{Symbol Properties}) символа функции
(@pxref{Symbol Properties}).  Это имеет свой эффект, потому что командный
цикл ищет его перед вызовом функции (@pxref{Interactive Call}).  После
вызова функции выполняются все ее формы тела; в это время, если форма
@code{interactive} встречается в теле, форма просто возвращает @code{nil},
даже не оценивая свой аргумент.

По соглашению требуется поместить форму @code{interactive} в тело функции
как первую форму верхнего уровня.  Если есть форма @code{interactive} и в
свойстве символа @code{interactive-form}, и в теле функции, первое имеет
приоритет.  Свойство символа @code{interactive-form} можно использовать для
добавления интерактивной формы к существующей функции или изменения способа
интерактивной обработки ее аргументов без переопределения функции.
@end defspec

Есть три возможности для аргумента @var{arg-descriptor}:

@itemize @bullet
@item
Может быть опущено или @code{nil}; тогда команда вызывается без аргументов.
Это быстро приводит к ошибке, если команде требуется один или несколько
аргументов.

@item
Это может быть строка; его содержимое представляет собой последовательность
элементов, разделенных символами новой строки, по одному для каждого
аргумента @footnote{Некоторые элементы фактически предоставляют два
аргумента.}.  Каждый элемент состоит из кодового символа
(@pxref{Interactive Codes}), за которым может следовать подсказка (которую
некоторые символы кода используют, а некоторые игнорируют). Вот пример:

@smallexample
(interactive "P\nbFrobnicate buffer: ")
@end smallexample

@noindent
Кодовая буква @samp{P} устанавливает в качестве первого аргумента команды
необработанный префикс команды (@pxref{Prefix Command Arguments}).
@samp{bFrobnicate buffer: } предлагает пользователю с помощью
@samp{Frobnicate buffer: } ввести имя существующего буфера, которое
становится вторым и последним аргументом.

Строка приглашения может использовать @samp{%} для включения в подсказку
значений предыдущих аргументов (начиная с первого аргумента).  Это делается
с помощью @code{format-message} (@pxref{Formatting Strings}).  Например, вот
как прочитать имя существующего буфера, за которым следует новое имя,
которое нужно дать этому буферу.:

@smallexample
@group
(interactive "bBuffer to rename: \nsRename buffer %s to: ")
@end group
@end smallexample

@cindex @samp{*} in @code{interactive}
@cindex read-only buffers in interactive
Если @samp{*} появляется в начале строки, то выдается сигнал об ошибке, если
буфер доступен только для чтения.

@cindex @samp{@@} in @code{interactive}
Если @samp{@@} появляется в начале строки и если последовательность ключей,
используемая для вызова команды, включает какие-либо события мыши, то перед
запуском команды выбирается окно, связанное с первым из этих событий.

@cindex @samp{^} in @code{interactive}
@cindex shift-selection, and @code{interactive} spec
Если @samp{^} появляется в начале строки, и если команда была вызвана через
@dfn{shift-translation}, устанавливается метка и временно активируется
область или расширяется уже активная область до запуска команды.  Если
команда была вызвана без @dfn{shift-translation}, а область временно
активна, деактивируется область перед выполнением команды.  @dfn{shift-translation} управляется на уровне пользователя с помощью
@code{shift-select-mode}; смотреть
@ref{Shift Selection,,, emacs, The GNU Emacs Manual}.

Можно использовать @samp{*}, @samp{@@}, и @code{^} вместе; порядок не имеет
значения.  Фактическое чтение аргументов контролируется остальной частью
строки приглашения (начиная с первого символа, который не является @samp{*},
@samp{@@}, или @samp{^}).

@item
Это может быть выражение Lisp, которое не является строкой; тогда это должна
быть форма, которая оценивается, чтобы получить список аргументов для
передачи команде.  Обычно эта форма вызывает различные функции для чтения
ввода от пользователя, чаще всего через минибуфер (@pxref{Minibuffers}) или
непосредственно с клавиатуры (@pxref{Reading Input}).

Предоставление точки или метки в качестве значения аргумента также является
обычным явлением, но если делается этот ввод для чтения @emph{и} (независимо
от того, используете ли он минибуфер или нет), следует убедиться, что
получены целые значения точки или метки после чтения.  Текущий буфер может
получать выходные данные подпроцесса; если выходные данные подпроцесса
поступают, пока команда ожидает ввода, это может переместить точку и метку.

Вот пример того, что @emph{не} нужно делать:

@smallexample
(interactive
 (list (region-beginning) (region-end)
       (read-string "Foo: " nil 'my-history)))
@end smallexample

@noindent
Вот как избежать этой проблемы, изучив точку и метку после чтения ввода
с клавиатуры:

@smallexample
(interactive
 (let ((string (read-string "Foo: " nil 'my-history)))
   (list (region-beginning) (region-end) string)))
@end smallexample

@strong{Предупреждение:} значения аргументов не должны включать какие-либо
типы данных, которые нельзя распечатать, а затем прочитать.  Некоторые
средства сохраняют @code{command-history} в файл для чтения в последующих
сессиях; если аргументы команды содержат тип данных, который печатается с
использованием синтаксиса @samp{#<@dots{}>}, эти средства не будут работать.

Однако есть несколько исключений: можно использовать ограниченный набор
выражений, таких как @code{(point)}, @code{(mark)},
@code{(region-beginning)}, и @code{(region-end)}, поскольку Emacs распознает
их специально и помещает выражение (а не его значение) в историю команд.
Чтобы узнать, является ли написанное вами выражение одним из этих
исключений, запустите команду, затем проверьте @code{(car command-history)}.
@end itemize

@cindex examining the @code{interactive} form
@defun interactive-form function
Эта функция возвращает @code{interactive} форму @var{function}.  Если
@var{function} является интерактивно вызываемой функцией
(@pxref{Interactive Call}), значением является команда @code{interactive} в
форме @code{(interactive @var{spec})}, которая указывает, как вычислять ее
аргументы.  В противном случае значение @code{nil}.  Если @var{function} -
это символ, используется определение его функции.
@end defun

@node Interactive Codes
@subsection Кодовые Символы для @code{interactive}
@cindex interactive code description
@cindex description for interactive codes
@cindex codes, interactive, description of
@cindex characters for interactive codes

  Приведенные ниже описания кодовых символов содержат ряд ключевых слов,
определяемых здесь следующим образом:

@table @b
@item Completion
@cindex interactive completion
Обеспечить завершение.  @key{TAB}, @key{SPC}, и @key{RET} выполняет
завершение имени, потому что аргумент читается с использованием
@code{completing-read} (@pxref{Completion}).  @kbd{?} отображает список
возможных доработок.

@item Existing
Требовать имя существующего объекта.  Недействительное имя не принимается;
команды выхода из минибуфера не сработают, если текущий ввод недействителен.

@item Default
@cindex default argument string
Если пользователь не вводит текст в минибуфер, используется какое-то
значение по умолчанию.  Значение по умолчанию зависит от символа кода.

@item No I/O
Эта кодовая буква вычисляет аргумент без чтения ввода.  Следовательно, не
используется строка подсказки, и любая строка подсказки, которая вводится,
игнорируется.

Несмотря на то, что кодовая буква не использует строку приглашения,
потребуется начать за ней с новой строки, если это не последний кодовый
символ в строке.

@item Prompt
Подсказка следует сразу за кодом символа.  Приглашение заканчивается концом
строки или новой строкой.

@item Special
Этот кодовый символ имеет смысл только в начале интерактивной строки и не
ищет подсказку или новую строку.  Это единый, изолированный символ.
@end table

@cindex reading interactive arguments
  Вот описания символов кода для использования с @code{interactive}:

@table @samp
@item *
Сообщается об ошибке, если текущий буфер доступен только для чтения.
Специальный.

@item @@
Выберается окно, упомянутое в первом событии мыши в последовательности
коючей, которое вызвало эту команду.  Специальный.

@item ^
Если команда была вызвана через shift-translation, установить метку и
временно активировать область или расширьте уже активную область перед
выполнением команды.  Если команда была вызвана без shift-translation, а
область временно активна, деактивируется область перед выполнением команды.
Специальный.

@item a
Имя функции (т. е. Символ, удовлетворяющий @code{fboundp}).  Существующий,
Завершение, Подсказка.

@item b
Имя существующего буфера.  По умолчанию используется имя текущего буфера
(@pxref{Buffers}).  Существующий, Завершение, По умолчанию, Запрос.

@item B
Имя буфера.  Буфер может не существовать.  По умолчанию использует имя
недавно использованного буфера, отличное от текущего.  Завершение,
По умолчанию, Подсказка.

@item c
Символ.  Курсор не перемещается в эхо-область.  Незамедлительный.

@item C
Имя команды (т. е. Символ, удовлетворяющий @code{commandp}).  Существующий,
Завершение, Подсказка.

@item d
@cindex position argument
Положение точки в виде целого числа (@pxref{Point}).  Нет ввода/вывода.

@item D
Каталог.  По умолчанию это текущий каталог по умолчанию для текущего буфера,
@code{default-directory} (@pxref{File Name Expansion}).  Существующий,
Завершение, По умолчанию, Запрос.

@item e
Первое или следующее событие, не связанное с клавиатурой, в
последовательности ключей, вызвавшее команду.  Точнее, @samp{e} получает
события в виде списков, поэтому можно просматривать данные в списках.
@xref{Input Events}.  Нет ввода/вывода.

Используется @samp{e} для событий мыши и для специальных системных событий
(@pxref{Misc Events}).  Список событий, который получает команда, зависит от
события.  @xref{Input Events}, который описывает формы списка для каждого
события в соответствующих подразделах.

Можно использовать @samp{e} более одного раза в интерактивной спецификации
одной команды.  Если последовательность ключей, вызвавшая команду, имеет
@var{n} событий, которые являются списками, @var{n} @samp{e} предоставляет
такое событие @var{n}.  События, не входящие в списки, такие как
функциональные ключи и символы @acronym{ASCII}, не учитываются в случае
@samp{e}.

@item f
Имя существующего файла (@pxref{File Names}).  Каталог по умолчанию -
@code{default-directory}.  Существующий, Завершение, По умолчанию, Запрос.

@item F
Имя файла.  Файл не должен существовать.
Завершение, По умолчанию, Подсказка.

@item G
Имя файла.  Файл не должен существовать.  Если пользователь вводит только
имя каталога, тогда значением будет просто имя этого каталога без добавления
имени файла в этом каталоге.  Завершение, По умолчанию, Подсказка.

@item i
Неуместный аргумент.  Этот код всегда предоставляет @code{nil} в качестве
значения аргумента.  Нет ввода/вывода.

@item k
Последовательность ключей (@pxref{Key Sequences}).  Это продолжает считывать
события, пока команда (или неопределенная команда) не будет найдена в
текущих ключевых картах.  Аргумент ключевой последовательности представлен в
виде строки или вектора.  Курсор не перемещается в эхо-область.
Незамедлительный.

Если @samp{k} считывается последовательность ключей, которая заканчивается
событием down, также считывается и отбрасывается следующее событие up.
Можно получить доступ к этому up-событию с помощью символа кода @samp{U}.

Этот тип ввода используется такими командами, как @code{describe-key} и
@code{global-set-key}.

@item K
Ключевая последовательность, определение которой потребовалося изменить.
Это работает как @samp{k}, за исключением того, что подавляется для
последнего события ввода в последовательности ключей преобразования, которые
обычно используются (при необходимости) для преобразования неопределенного
ключа в определенный.

@item m
@cindex marker argument
Положение метки в виде целого числа.  Нет ввода/вывода.

@item M
Произвольный текст, читаемый в минибуфере с использованием метода ввода
текущего буфера и возвращаемый в виде строки
(@pxref{Input Methods,,, emacs, The GNU Emacs Manual}).  Незамедлительный.

@item n
Число, считываемое с помощью минибуфера.  Если введено не число,
пользователь должен повторить попытку.  @samp{n} никогда не использует
аргумент префикса.  Незамедлительный.

@item N
Аргумент числового префикса; но если аргумента префикса нет, считается
число, как с @kbd{n}.  Значение всегда является числом.
@xref{Prefix Command Arguments}.  Незамедлительный.

@item p
@cindex numeric prefix argument usage
Аргумент числового префикса.  (Обратить внимание, что @samp{p} в нижнем
регистре).  Нет ввода-вывода.

@item P
@cindex raw prefix argument usage
Аргумент необработанного префикса.  (Обратить внимание, что @samp{P} в
верхнем регистре).  Нет ввода-вывода.

@item r
@cindex region argument
Точка и метка в виде двух числовых аргументов, наименьший первым.  Это
единственная кодовый символ, который указывает два последовательных
аргумента, а не один.  Сигнализируется об ошибке, если метка не установлена
в буфере, который является текущим при вызове команды.  Нет ввода/вывода.

@item s
Произвольный текст, читается в минибуфере и возвращается в виде строки
(@pxref{Text from Minibuffer}).  Завершается ввод с помощью @kbd{C-j} или
@key{RET}.  (@kbd{C-q} может использоваться для включения любого из этих
символов во входные данные).  Подсказка.

@item S
Интернированный символ, имя которого читается в минибуфере.  Завершите ввод
с помощью @kbd{C-j} или @key{RET}.  Другие символы, которые обычно завершают
символ (например, пробелы, круглые и квадратные скобки), здесь не
используются.  Незамедлительный.

@item U
Последовательность ключей или @code{nil}.  Может использоваться после
аргумента @samp{k} или @samp{K} для получения события up, которое было
отброшено (если оно было) после того, как @samp{k} или @samp{K} прочитано
событие down.  Если ни одно событие up не было отброшено, @samp{U}
предоставляет в качестве аргумента @code{nil}.  Нет ввода/вывода.

@item v
Переменная, объявленная как пользовательская опция (т. е. удовлетворяющая
предикату @code{custom-variable-p}).  Читается переменная с помощью
@code{read-variable}.  @xref{Definition of read-variable}.  Существующий,
Завершение, Подсказка.

@item x
Объект Lisp, заданный синтаксисом чтения, завершается @kbd{C-j} или
@key{RET}.  Объект не оценивается.  @xref{Object from Minibuffer}.
Незамедлительный.

@item X
@cindex evaluated expression argument
Значение формы Lisp.  @samp{X} читает, как @samp{x}, затем оценивает форму,
так что ее значение становится аргументом для команды.  Незамедлительный.

@item z
Название системы кодирования (символ).  Если пользователь вводит пустой
ввод, значение аргумента - @code{nil}.  @xref{Coding Systems}.  Завершение,
Существующее, Подсказка.

@item Z
Имя системы кодирования (символ) --- но только если эта команда имеет
аргумент префикса.  Без аргумента префикса @samp{Z} предоставляет @code{nil}
в качестве значения аргумента.  Завершение, Существующее, Подсказка.
@end table

@node Interactive Examples
@subsection Примеры Использования @code{interactive}
@cindex examples of using @code{interactive}
@cindex @code{interactive}, examples of using

  Вот несколько примеров @code{interactive}:

@example
@group
(defun foo1 ()              ; @r{@code{foo1} не принимает аргументов,}
    (interactive)           ;   @r{просто перемещает вперед на два слова.}
    (forward-word 2))
     @result{} foo1
@end group

@group
(defun foo2 (n)             ; @r{@code{foo2} принимает один аргумент -}
    (interactive "^p")      ;   @r{числовой префикс.}
                            ; @r{по средствам @code{shift-select-mode},}
                            ;   @r{активируется или расширяется регион.}
    (forward-word (* 2 n)))
     @result{} foo2
@end group

@group
(defun foo3 (n)             ; @r{@code{foo3} принимает один аргумент,}
    (interactive "nCount:") ;   @r{ который читается с помощью минибуфера.}
    (forward-word (* 2 n)))
     @result{} foo3
@end group

@group
(defun three-b (b1 b2 b3)
  "Выберите три существующих буфера.
Поместите их в три окна, выбрав последнее."
@end group
    (interactive "bБуфер1:\nbБуфер2:\nbБуфер3:")
    (delete-other-windows)
    (split-window (selected-window) 8)
    (switch-to-buffer b1)
    (other-window 1)
    (split-window (selected-window) 8)
    (switch-to-buffer b2)
    (other-window 1)
    (switch-to-buffer b3))
     @result{} three-b
@group
(three-b "*scratch*" "declarations.texi" "*mail*")
     @result{} nil
@end group
@end example

@node Generic Commands
@subsection Выбор Среди Альтернативных Команд
@cindex generic commands
@cindex alternatives, defining

Макрос @code{define-alternatives} может использоваться для определения
@dfn{generic commands}.  Это интерактивные функции, реализация которых может
быть выбрана из нескольких альтернатив по желанию пользователя.

@defmac define-alternatives command &rest customizations
Определить новую команду @var{command}, символ.

Когда пользователь запускает @kbd{M-x @var{command} @key{RET}} в первый раз,
Emacs запрашивает, какую реальную форму команды использовать, и записывает
выбор с помощью пользовательской переменной.  Использование аргумента
префикса повторяет этот процесс выбора альтернативы.

Переменная @code{@var{command}-alternatives} должна содержать список
альтернативных реализаций @var{command}.  Пока эта переменная не
установлена, @code{define-alternatives} не действует.

Если @var{customizations} установлено в не-@code{nil}, должно состоять из
чередующихся ключевых слов @code{defcustom} (обычно @code{:group} и
@code{:version}) и значений, добавляемых к объявлению
@code{@var{command}-alternatives}.
@end defmac

@node Interactive Call
@section Интерактивный Вызов
@cindex interactive call

  После того, как командный цикл преобразовал последовательность ключей в
команду, вызывается эта команда, используя функцию @code{command-execute}.
Если команда является функцией, @code{command-execute} вызывает
@code{call-interactively}, которой считываются аргументы и вызывается
команда.  Также можете вызвать эти функции самостоятельно.

  Обратить внимание, что термин ``command'' в этом контексте относится к
интерактивно вызываемой функции (или объекту, подобному функции), или
макросу клавиатуры.  Это не относится к последовательности ключей,
используемой для вызова команды (@pxref{Keymaps}).

@defun commandp object &optional for-call-interactively
Эта функция возвращает @code{t}, если @var{object} - команда.  В противном
случае возвращается @code{nil}.

Команды включают строки и векторы (которые рассматриваются как макросы
клавиатуры), лямбда-выражения, содержащие форму @code{interactive} верхнего
уровня (@pxref{Using Interactive}), объекты функций байт кода, созданные из
таких лямбда-выражений, объекты автозагрузки, объявленные как интерактивные
(четвертый аргумент не-@code{nil} для @code{autoload} ) и некоторые
примитивные функции.  Кроме того, символ считается командой, если он имеет
свойство не-@code{nil} @code{interactive-form} или если его определение
функции удовлетворяет @code{commandp}.

Если @var{for-call-interactively} равен не-@code{nil}, тогда @code{commandp}
возвращает @code{t} только для объектов, которые может вызывать
@code{call-interactively} --- таким образом, не для макросов клавиатуры.

Смотреть @code{documentation} в @ref{Accessing Documentation}, для
реалистичного примера использования @code{commandp}.
@end defun

@defun call-interactively command &optional record-flag keys
Функция вызывает интерактивно вызываемую функцию @var{command}, предоставляя
аргументы в соответствии со спецификациями интерактивного вызова.
Возвращается все, что возвращается @var{command}.

Если, например, есть функция со следующей спецификацией:

@example
(defun foo (begin end)
  (interactive "r")
  ...)
@end example

затем производя

@example
(call-interactively 'foo)
@end example

вызовет @code{foo} с регионом (@code{point} и @code{mark}) в качестве
аргументов.

Об ошибке сообщается, если @var{command} не является функцией или если не
может быть вызвана интерактивно (то есть не является командой).  Обратить
внимание, что макросы клавиатуры (строки и векторы) не принимаются, даже
если считаются командами, поскольку не являются функциями.  Если
@var{command} - символ, тогда @code{call-interactively} использует
определение своей функции.

@cindex record command history
Если @var{record-flag} равен не-@code{nil}, то эта команда и ее аргументы
безоговорочно добавляются в список @code{command-history}.  В противном
случае команда добавляется, только если она использует минибуфер для чтения
аргумента.  @xref{Command History}.

Аргумент @var{keys}, если он задан, должен быть вектором, который определяет
последовательность событий, которые необходимо предоставить, если команда
запрашивает, какие события использовались для ее вызова.  Если @var{keys} не
указан или @code{nil}, по умолчанию возвращается значение
@code{this-command-keys-vector}.
@xref{Definition of this-command-keys-vector}.
@end defun

@defun funcall-interactively function &rest arguments
Функция работает как @code{funcall} (@pxref{Calling Functions}), но
делается вызов похожим на интерактивный вызов: вызов
@code{called-interactively-p} внутри @var{function} вернет @code{t}.  Если
@var{function} не является командой, вызывается без сообщения об ошибке.
@end defun

@defun command-execute command &optional record-flag keys special
@cindex keyboard macro execution
Функция выполняет @var{command}.  Аргумент @var{command} должен
удовлетворять предикату @code{commandp}; т.е. это должна быть интерактивно
вызываемая функция или клавиатурный макрос.

Строка или вектор как @var{command} выполняется с @code{execute-kbd-macro}.
Функция передается в @code{call-interactively} (смотреть выше) вместе с
аргументами @var{record-flag} и @var{keys}.

Если @var{command} является символом, вместо него используется определение
его функции.  Символ с определением @code{autoload} считается командой, если
он был объявлен как обозначающий интерактивно вызываемую функцию.  Такое
определение обрабатывается путем загрузки указанной библиотеки и повторной
проверки определения символа.

Аргумент @var{special}, если он задан, означает игнорировать аргумент
префикса и не очищать его.  Используется для выполнения специальных событий
(@pxref{Special Events}).
@end defun

@deffn Command execute-extended-command prefix-argument
@cindex read command name
Функция считывает имя команды из минибуфера с помощью @code{completing-read}
(@pxref{Completion}).  Затем используется @code{command-execute} для вызова
указанной команды.  Все, что возвращает эта команда, становится значением
@code{execute-extended-command}.

@cindex execute with prefix argument
Если команда запрашивает аргумент префикса, получает значение
@var{prefix-argument}.  Если @code{execute-extended-command} вызывается
интерактивно, текущий необработанный аргумент префикса используется для
@var{prefix-argument} и, таким образом, передается любой запущенной команде.

@c !!! Если это будет @kindex?
@cindex @kbd{M-x}
@code{execute-extended-command} - обычное определение @kbd{M-x}, поэтому в
качестве подсказки используется строка @w{@samp{M-x }}.  (Было бы лучше
брать подсказку из событий, используемых для вызова
@code{execute-extended-command}, но это болезненно реализовать).  Описание
значения аргумента префикса, если таковое имеется, также становится частью
подсказки.

@example
@group
(execute-extended-command 3)
---------- Buffer: Minibuffer ----------
3 M-x forward-word @key{RET}
---------- Buffer: Minibuffer ----------
     @result{} t
@end group
@end example
@end deffn

@node Distinguish Interactive
@section Отличия Интерактивных Вызовов
@cindex distinguish interactive calls
@cindex is this call interactive

  Иногда команда должна отображать дополнительную визуальную обратную связь
(например, информативное сообщение в эхо-области) только для интерактивных
вызовов.  Это можно сделать тремя способами.  Рекомендуемый способ
проверить, была ли функция вызвана с помощью @code{call-interactively} -
дать ей необязательный аргумент @code{print-message} и использовать
спецификацию @code{interactive}, чтобы сделать ее не-@code{nil} в
интерактивных вызовах.  Вот пример:

@example
(defun foo (&optional print-message)
  (interactive "p")
  (when print-message
    (message "foo")))
@end example

@noindent
Используется @code{"p"}, потому что аргумент числового префикса никогда не
равен @code{nil}.  Определенная таким образом функция отображает сообщение
при вызове из макроса клавиатуры.

  Вышеупомянутый метод с дополнительным аргументом обычно лучше, потому что
позволяет вызывающим абонентам сказать ``рассматривать этот вызов как
интерактивный''.  Но также можно выполнить эту работу, протестировав
@code{called-interactively-p}.

@defun called-interactively-p kind
Функция возвращает @code{t}, когда вызывающая функция была вызвана с
использованием @code{call-interactively}.

Аргумент @var{kind} должен быть либо символом @code{interactive}, либо
символом @code{any}.  Если это @code{interactive}, то
@code{called-interactively-p} возвращает @code{t} только в том случае, если
вызов был сделан непосредственно пользователем --- например, если
пользователь набрал последовательность ключей, связанную с вызывающей
функцией, но @emph{не} если пользователь запустил макрос клавиатуры, который
вызвал функцию (@pxref{Keyboard Macros}).  Если @var{kind} равен @code{any},
@code{called-interactively-p}, возвращает @code{t} для любого интерактивного
вызова, включая макросы клавиатуры.

В случае сомнений используется @code{any}; единственное известное правильное
использование @code{interactive} - это если требуется решить, отображать ли
полезное сообщение во время работы функции.

Функция никогда не считается вызываемой интерактивно, если она была вызвана
посредством вычисления Lisp (или с помощью @code{apply} или @code{funcall}).
@end defun

@noindent
Вот пример использования @code{called-interactively-p}:

@example
@group
(defun foo ()
  (interactive)
  (when (called-interactively-p 'any)
    (message "Interactive!")
    'foo-called-interactively))
@end group

@group
;; @r{Набрать @kbd{M-x foo}.}
     @print{} Interactive!
@end group

@group
(foo)
     @result{} nil
@end group
@end example

@noindent
Вот еще один пример, который противопоставляет прямые и косвенные вызовы
@code{called-interactively-p}.

@example
@group
(defun bar ()
  (interactive)
  (message "%s" (list (foo) (called-interactively-p 'any))))
@end group

@group
;; @r{Набрать @kbd{M-x bar}.}
     @print{} (nil t)
@end group
@end example

@node Command Loop Info
@section Информация из Командного Цикла
@cindex command loop variables

Редоктор командного цикла устанавливает несколько переменных Lisp для
хранения записей состояния для себя и для выполняемых команд.  За
исключением @code{this-command} и @code{last-command}, обычно плохая идея
изменять любую из этих переменных в программе на Lisp.

@defvar last-command
Переменная записывает имя предыдущей команды, выполненной командным циклом
(той, которая была перед текущей командой).  Обычно значение представляет
собой символ с определением функции, но это не гарантируется.

Значение копируется из @code{this-command}, когда команда возвращается в
командный цикл, за исключением случаев, когда команда задала аргумент
префикса для следующей команды.

Переменная всегда является локальной для текущего терминала и не может быть
локальной для буфера.  @xref{Multiple Terminals}.
@end defvar

@defvar real-last-command
Переменная устанавливается Emacs точно так же, как @code{last-command}, но
никогда не изменяется программами Lisp.
@end defvar

@defvar last-repeatable-command
В переменной хранится последняя выполненная команда, которая не была частью
входного события.  Это команда @code{repeat} попытается повторить,
@xref{Repeating,,, emacs, The GNU Emacs Manual}.
@end defvar

@defvar this-command
@cindex current command
Переменная записывает имя команды, которая теперь выполняется в цикле команд
редактора.  Как и @code{last-command}, это обычно символ с определением
функции.

Цикл команд устанавливает эту переменную непосредственно перед запуском
команды и копирует ее значение в @code{last-command}, когда команда
завершается (если команда не указала аргумент префикса для следующей
команды).

@cindex kill command repetition
Некоторые команды устанавливают эту переменную во время своего выполнения в
качестве флага для следующей команды.  В частности, функции для уничтожения
текста устанавливают @code{this-command} в @code{kill-region}, чтобы любые
команды уничтожения, следующие сразу же, знали, что нужно добавить
уничтоженный текст к предыдущему уничтожению.
@end defvar

Если не требуется, чтобы определенная команда распознавалась как предыдущая
в случае ошибки, потребуется закодировать эту команду, чтобы предотвратить
это.  Один из способов - установить @code{this-command} в @code{t} в начале
команды и вернуть @code{this-command} обратно в правильное значение в конце,
как здеся:

@example
(defun foo (args@dots{})
  (interactive @dots{})
  (let ((old-this-command this-command))
    (setq this-command t)
    @r{@dots{}выполнять работу@dots{}}
    (setq this-command old-this-command)))
@end example

@noindent
Не связывается @code{this-command} с @code{let}, потому что это восстановит
старое значение в случае ошибки - особенность @code{let}, которая в данном
случае делает именно то, чего требуется избежать.

@defvar this-original-command
Имеет то же значение, что и @code{this-command}, за исключением случаев,
когда выполняется переназначение команд (@pxref{Remapping Commands}).  В
этом случае @code{this-command} дает команду, фактически выполняемую
(результат переназначения), а @code{this-original-command} дает команду,
которая была указана для выполнения, но переназначена в другую команду.
@end defvar

@defun this-command-keys
Функция возвращает строку или вектор, содержащий последовательность ключей,
которая вызвала текущую команду, плюс любые предыдущие команды, которые
сгенерировали аргумент префикса для этой команды.  Любые события,
прочитанные командой, использующей @code{read-event}, без тайм-аута,
прикрепляются к концу.

Однако, если команда вызвала @code{read-key-sequence}, возвращается
последняя прочитанная последовательность ключей.  @xref{Key Sequence Input}.
Значение является строкой, если все события в последовательности были
символами, которые помещаются в строку.  @xref{Input Events}.

@example
@group
(this-command-keys)
;; @r{Теперь использовать @kbd{C-u C-x C-e} чтобы оценить это.}
     @result{} "^U^X^E"
@end group
@end example
@end defun

@defun this-command-keys-vector
@anchor{Definition of this-command-keys-vector}
Подобно @code{this-command-keys}, за исключением того, что всегда
возвращается события в векторе, поэтому потребуется иметь дело со
сложностями хранения входных событий в строке (@pxref{Strings of Events}).
@end defun

@defun clear-this-command-keys &optional keep-record
Функцией очищается таблица событий для возврата @code{this-command-keys}.
Если @var{keep-record} не не-@code{nil}, также очищаются записи, которые
функция @code{recent-keys} (@pxref{Recording Input}) впоследствии вернет.
Это полезно после прочтения пароля, чтобы предотвратить случайное эхо пароля
в некоторых случаях как часть следующей команды.
@end defun

@defvar last-nonmenu-event
Переменная содержит последнее входное событие, считанное как часть
последовательности ключей, не считая событий, происходящих из меню мыши.

Одно из применений этой переменной - указать @code{x-popup-menu}, где
открыть всплывающее меню. Также используется внутри @code{y-or-n-p}
(@pxref{Yes-or-No Queries}).
@end defvar

@defvar last-command-event
Переменная устанавливается на последнее событие ввода, которое было
прочитано командным циклом как часть команды.  В основном эта переменная
используется в @code{self-insert-command}, которая использует ее, чтобы
решить, какой символ вставить.

@example
@group
last-command-event
;; @r{Теперь используйте @kbd{C-u C-x C-e}, чтобы оценить это.}
     @result{} 5
@end group
@end example

@noindent
Значение равно 5, потому что это код @acronym{ASCII} для @kbd{C-e}.
@end defvar

@defvar last-event-frame
Переменная записывает, в какой кадр было направлено последнее входное
событие.  Обычно это кадр, который был выбран при создании события, но если
этот кадр перенаправил фокус ввода на другой кадр, значением является кадр,
на который было перенаправлено событие.
@xref{Input Focus}.

Если последнее событие пришло из макроса клавиатуры, значение будет
@code{macro}.
@end defvar

@node Adjusting Point
@section Управление Расположением Точки После Команд
@cindex adjusting point
@cindex invisible/intangible text, and point
@cindex @code{display} property, and point display
@cindex @code{composition} property, and point display

  Emacs не может отображать курсор, когда точка находится в середине
последовательности текста, имеющего свойство @code{display} или
@code{composition}, или когда точка невидима.  Следовательно, после того,
как команда завершается и возвращается в командный цикл, если точка
находится в такой последовательности, командный цикл обычно перемещает точку
к краю последовательности, что делает эту последовательность фактически
неосязаемой.

  Команда может запретить эту функцию, установив переменную
@code{disable-point-adjustment}:

@defvar disable-point-adjustment
Если эта переменная - не-@code{nil}, когда команда возвращается в командный
цикл, то командный цикл не проверяет эти текстовые свойства и не перемещает
точку из последовательности в которой она находится.

Цикл команд устанавливает для этой переменной значение @code{nil} перед
каждой командой, поэтому, если команда устанавливает ее, эффект применяется
только к этой команде.
@end defvar

@defvar global-disable-point-adjustment
Если установить для этой переменной значение не-@code{nil}, функция
перемещения точки из текстовых последовательностей полностью отключится.
@end defvar

@node Input Events
@section Входные События
@cindex events
@cindex input events

Цикл команд Emacs читает последовательность @dfn{входных событий}, которая
представляет активность клавиатуры или мыши или системных событий,
отправленные в Emacs.  Событиями для активности клавиатуры являются клавиши
или символы; другие события всегда списки.  В этом разделе подробно
описывается представление и значение входных событий.

@defun eventp object
Функция возвращает не-@code{nil}, если @var{object} является входным
событием или типом события.

Обратить внимание, что любой символ может использоваться как событие или
тип события.  @code{eventp} не может определить, предназначен ли символ для
использования в коде Lisp в качестве события.  Вместо этого определяется,
действительно ли символ использовался в событии, считанном как ввод в
текущем сеансе Emacs.  Если символ еще не использовался, @code{eventp}
возвращает @code{nil}.
@end defun

@menu
* Keyboard Events::             Обычные символы - клавиши с символами на них.
* Function Keys::               Функциональные клавиши - клавиши с именами, а не символами.
* Mouse Events::                Обзор событий мыши.
* Click Events::                Нажатие и отпускание кнопки мыши.
* Drag Events::                 Перемещение мыши перед отпусканием кнопки.
* Button-Down Events::          Была нажата кнопка, но еще не отпущена.
* Repeat Events::               Два или три щелчка (перетаскивание, вниз).
* Motion Events::               Просто движение мышью, не нажимая кнопку.
* Focus Events::                Перемещение мыши между фреймами.
* Misc Events::                 Другие события, генерируемые системой.
* Event Examples::              Примеры списков событий мыши.
* Classifying Events::          Поиск клавиш-модификаторов в символе события.
                                Типы событий.
* Accessing Mouse::             Функции извлечения информации из событий мыши.
* Accessing Scroll::            Функции для получения информации о событиях полосы прокрутки.
* Strings of Events::           Особые рекомендации по помещению событий символов клавиатуры в строку.
@end menu

@node Keyboard Events
@subsection События Клавиатуры
@cindex keyboard events

@cindex character event
Есть два типа ввода, которые можно получить с клавиатуры: обычные ключи и
функциональные ключи.  Обычные ключи соответствуют (возможно, измененным)
символам; генерируемые ими события представлены в Lisp как символы.  Тип
события @dfn{символьное событие} - это сам символ (целое число), для
которого могут быть установлены некоторые биты модификатора; смотреть
@ref{Classifying Events}.

@cindex modifier bits (of input character)
@cindex basic code (of input character)
Событие входного символа состоит из @dfn{базового кода} от 0 до 524287,
плюс любой или всё из этого @dfn{биты модификатора}:

@table @asis
@item meta

@tex
@math{2^{27}}
@end tex
@ifnottex
2**27
@end ifnottex
бит в коде символа указывает символ, набранный с нажатой мета-клавишей.

@item control

@tex
@math{2^{26}}
@end tex
@ifnottex
2**26
@end ifnottex
бит в коде символа указывает управляющий не-@acronym{ASCII} символ.

Управляющие символы @sc{ascii}, такие как @kbd{C-a}, имеют собственные
специальные базовые коды, поэтому Emacs не нуждается в специальных битах для
их обозначения.  Таким образом, код для @kbd{C-a} равен 1.

Но если вводится комбинация элементов управления не в @acronym{ASCII},
например @kbd{%}, с помощью клавиш управления, числовое значение, которое
получится, будет кодом для @kbd{%} плюс
@tex
@math{2^{26}}
@end tex
@ifnottex
2**26
@end ifnottex
(предполагается, что терминал поддерживает управляющие не-@acronym{ASCII}
символы), т.е. @: с установленным 27-м битом.

@item shift

@tex
@math{2^{25}}
@end tex
@ifnottex
2**25
@end ifnottex
бит (26-й бит) в символьном коде события указывает на управляющий символ
@acronym{ASCII}, набранный с зажатой клавишей Shift.

Для букв сам основной код указывает верхний регистр или нижний регистр; для
цифр и знаков препинания клавиша Shift выбирает совершенно другой символ с
другим базовым кодом.  Чтобы по возможности придерживаться набора символов
@acronym{ASCII}, Emacs избегает использования
@tex
@math{2^{25}}
@end tex
@ifnottex
2**25
@end ifnottex
немного для символьных событий.

Однако @acronym{ASCII} не дает возможности отличить @kbd{C-A} от @kbd{C-a},
поэтому Emacs использует
@tex
@math{2^{25}}
@end tex
@ifnottex
2**25
@end ifnottex
бит в @kbd{C-A}, а не в
@kbd{C-a}.

@item hyper

@tex
@math{2^{24}}
@end tex
@ifnottex
2**24
@end ifnottex
бит в символьном коде события указывает символ, набранный с нажатой
гипер-клавишей.

@item super

@tex
@math{2^{23}}
@end tex
@ifnottex
2**23
@end ifnottex
бит в символьном коде события указывает символ, набранный с зажатой
супер-клавишей.

@item alt

@tex
@math{2^{22}}
@end tex
@ifnottex
2**22
@end ifnottex
бит в символьном коде события указывает символ, набранный с нажатой клавишей
alt.  (Ключ с пометкой @key{Alt} на большинстве клавиатур фактически
рассматривается как мета-ключ, а не alt.)
@end table

  Лучше избегать упоминания конкретных номеров битов в программе.  Чтобы
проверить биты модификатора символа, используется функция
@code{event-modifiers} (@pxref{Classifying Events}).  При привязке ключей
можно использовать синтаксис чтения для символов с битами модификатора
(@samp{\C-}, @samp{\M-} и т. д.).  Для привязки ключей с помощью
@code{define-key} можно использовать списки, такие как
@code{(control hyper ?x)}, чтобы указать символы
(@pxref{Changing Key Bindings}).  Функция @code{event-convert-list}
преобразует такой список в тип события (@pxref{Classifying Events}).

@node Function Keys
@subsection Функциональные Ключи

@cindex function keys
На большинстве клавиатур также есть клавиши @dfn{функциональный ключ} ---,
имена или символы которых не являются символами.  Функциональные клавиши
представлены в Emacs Lisp как символы; имя символа - это подпись
функциональной клавиши в нижнем регистре.  Например, нажатие клавиши
@key{F1} генерирует событие ввода, представленное символом @code{f1}.

Тип события события функциональной клавиши - это сам символ события.
@xref{Classifying Events}.

Вот несколько особых случаев в соглашении об именах символов для
функциональных клавиш:

@table @asis
@item @code{backspace}, @code{tab}, @code{newline}, @code{return}, @code{delete}
Эти клавиши соответствуют обычным управляющим символам @acronym{ASCII},
которые имеют специальные клавиши на большинстве клавиатур.

В @acronym{ASCII}, @kbd{C-i} и @key{TAB} такие же символы.  Если терминал
может различать их, Emacs передает это различие программам на Lisp,
представляя первое как целое число 9, а второе как символ @code{tab}.

В большинстве случаев различать их нецелесообразно.  Так что обычно
@code{local-function-key-map} (@pxref{Translation Keymaps}) настроен для
отображения @code{tab} в 9.  Таким образом, привязка ключа для кода символа
9 (символ @kbd{C-i}) также применяется к @code{tab}.  То же самое и с
другими символами в этой группе.  Функция @code{read-char} также преобразует
эти события в символы.

В @acronym{ASCII}, @key{BS} действительно есть @kbd{C-h}.  Но
@code{backspace} преобразует в код символа 127 (@key{DEL}), а не в код 8
(@key{BS}).  Это то, что предпочитает большинство пользователей.

@item @code{left}, @code{up}, @code{right}, @code{down}
Клавиши курсора со стрелками
@item @code{kp-add}, @code{kp-decimal}, @code{kp-divide}, @dots{}
Клавиши клавиатуры (справа от обычной клавиатуры).
@item @code{kp-0}, @code{kp-1}, @dots{}
Клавиши клавиатуры с цифрами.
@item @code{kp-f1}, @code{kp-f2}, @code{kp-f3}, @code{kp-f4}
Клавиатура PF клавиш.
@item @code{kp-home}, @code{kp-left}, @code{kp-up}, @code{kp-right}, @code{kp-down}
Клавиши со стрелками на клавиатуре.  Emacs обычно переводит их в
соответствующие клавиши без клавиатуры @code{home}, @code{left}, @dots{}
@item @code{kp-prior}, @code{kp-next}, @code{kp-end}, @code{kp-begin}, @code{kp-insert}, @code{kp-delete}
Дополнительные дубликаты клавиш клавиатуры, которые обычно можно найти в
других местах.  Emacs обычно переводит их в одноименные клавиши без
клавиатуры.
@end table

Можно использовать клавиши-модификаторы @key{ALT}, @key{CTRL}, @key{HYPER},
@key{META}, @key{SHIFT}, и @key{SUPER} с функциональными клавишами.  Их
можно представить с помощью префиксов в имени символа:

@table @samp
@item A-
Модификатор alt.
@item C-
Модификатор управления.
@item H-
Гипермодификатор.
@item M-
Мета-модификатор.
@item S-
Модификатор сдвига.
@item s-
Супер модификатор.
@end table

Таким образом, символ для клавиши @key{F3} с нажатой клавишей @key{META}
будет @code{M-f3}.  Если используется более одного префикса, рекомендуется
писать их в алфавитном порядке; но порядок не имеет значения в аргументах
функций поиска и модификации привязки ключей.

@node Mouse Events
@subsection События Мыши

Emacs поддерживает четыре типа событий мыши: события щелчка, события
перетаскивания, события нажатия кнопки и события движения.  Все события мыши
представлены в виде списков.  @sc{car} списка - тип события; это указывает,
какая кнопка мыши была задействована, и какие клавиши-модификаторы
использовались с ней.  По типу события также можно различать двойное или
тройное нажатие кнопки (@pxref{Repeat Events}).  Остальные элементы списка
предоставляют информацию о положении и времени.

Для поиска ключа имеет значение только тип события: два события одного типа
обязательно запускают одну и ту же команду.  Команда может получить доступ к
полным значениям этих событий с помощью интерактивного кода @samp{e}.
@xref{Interactive Codes}.

Последовательность ключей, которая начинается с события мыши, считывается с
использованием ключевых карт буфера в окне, в котором находилась мышь, а не
текущего буфера.  Это не означает, что щелчок в окне выбирает это окно или
его буфер, который полностью находится под контролем привязки команды
последовательности ключей.

@node Click Events
@subsection События Нажатия
@cindex click event
@cindex mouse click event

Когда пользователь нажимает кнопку мыши и отпускает ее в том же месте,
генерируется событие @dfn{щелчок}.  Все события щелчка мыши имеют один и тот
же формат:

@example
(@var{event-type} @var{position} @var{click-count})
@end example

@table @asis
@item @var{event-type}
Символ, указывающий, какая кнопка мыши была использована.  Это один из
символов @code{mouse-1}, @code{mouse-2}, @dots{}, где кнопки нумеруются
слева направо.

Также можно использовать префиксы @samp{A-}, @samp{C-}, @samp{H-},
@samp{M-}, @samp{S-} и @samp{s-} для модификаторов alt, control, hyper,
meta, shift и super, как и с функциональными клавишами.

Этот символ также служит типом события.  Привязки ключей описывают события
по их типам; таким образом, если есть привязка ключа для @code{mouse-1},
эта привязка будет применяться ко всем событиям, у которых @var{event-type}
есть @code{mouse-1}.

@item @var{position}
@cindex mouse position list
Это @dfn{mouse position list}, указывающий, где произошел щелчок мышью;
подробности смотреть ниже.

@item @var{click-count}
Это количество частых повторных нажатий одной и той же кнопки мыши до сих
пор.  @xref{Repeat Events}.
@end table

  Чтобы получить доступ к содержимому списка позиций мыши в слоте
@var{position} события щелчка, обычно потребуется использовать функции,
описанные в @ref{Accessing Mouse}.  Явный формат списка зависит от того, где
произошел щелчок.  Для щелчков в текстовой области, строке режима, строке
заголовка или в краевых или маргинальных областях список позиций мыши имеет
вид

@example
(@var{window} @var{pos-or-area} (@var{x} . @var{y}) @var{timestamp}
 @var{object} @var{text-pos} (@var{col} . @var{row})
 @var{image} (@var{dx} . @var{dy}) (@var{width} . @var{height}))
@end example

@noindent
Значения этих элементов списка следующие:

@table @asis
@item @var{window}
Окно, в котором произошел щелчок.

@item @var{pos-or-area}
Положение в буфере символа, по которому щелкнули в текстовой области; или,
если щелчок произошел за пределами текстовой области, область окна, в
которой он произошел.  Это один из символов @code{mode-line},
@code{header-line}, @code{vertical-line}, @code{left-margin},
@code{right-margin}, @code{left-fringe}, или @code{right-fringe}.

В одном частном случае @var{pos-or-area} - это список, содержащий символ
(один из символов, перечисленных выше), а не только символ.  Это происходит
после того, как Emacs регистрирует воображаемые префиксные ключи для
события.  @xref{Key Sequence Input}.

@item @var{x}, @var{y}
Относительные пиксельные координаты щелчка.  Для щелчков в текстовой области
окна за начало координат @code{(0 . 0)} берется верхний левый угол текстовойобласти.  @xref{Window Sizes}.  Для щелчков в строке режима или строке
заголовка источником координат является верхний левый угол самого окна.  Для
полос, полей и вертикальной границы @var{x} не имеет значимых данных.  Для
бахромы и полей @var{y} отсчитывается относительно нижнего края строки
заголовка.  Во всех случаях координаты @var{x} и @var{y} увеличиваются
вправо и вниз соответственно.

@item @var{timestamp}
Время, в которое произошло событие, в виде целого числа миллисекунд с
системно-зависимого начального времени.

@item @var{object}
Либо @code{nil}, что означает, что щелчок произошел по тексту буфера, либо
cons-ячейка формы @w{(@var{string} . @var{string-pos})}, если есть строка из
текстового свойства или наложение в позиции щелчка.

@table @asis
@item @var{string}
Строка, по которой был выполнен щелчок, включая любые свойства.

@item @var{string-pos}
Позиция в строке, где произошел щелчок.
@end table

@item @var{text-pos}
Для щелчков по маргинальной области или по краю это буферная позиция первого
видимого символа в соответствующей строке в окне.  Для щелчков по строке
режима или строке заголовка это @code{nil}.  Для других событий это позиция
буфера, ближайшая к щелчку.

@item @var{col}, @var{row}
Это фактические координаты столбца и строки глифа под позицией @var{x},
@var{y}.  Если @var{x} лежит за пределами последнего столбца фактического
текста в своей строке, @var{col} сообщается путем добавления вымышленных
дополнительных столбцов с шириной символа по умолчанию.  Строка 0 считается
строкой заголовка, если она есть в окне, или самой верхней строкой текстовой
области в противном случае.  Столбец 0 считается крайним левым столбцом
текстовой области для щелчков в текстовой области окна или крайней левой
строкой режима или столбцом строки заголовка для щелчков в этой области.
Для щелчков по краям или вертикальным границам они не имеют значимых данных.
Для щелчков по полям @var{col} измеряется от левого края области полей, а
@var{row} - от верха области полей.

@item @var{image}
Если в месте щелчка есть изображение, это объект изображения, возвращенный
@code{find-image} (@pxref{Defining Images}); в противном случае это
@code{nil}.

@item @var{dx}, @var{dy}
Это пиксельные координаты щелчка относительно верхнего левого угла
@var{object}, который равен @code{(0 . 0)}.  Если @var{object} равно
@code{nil}, что означает буфер, координаты отсчитываются относительно левого
верхнего угла глифа символа, на котором щелкнули мышью.

@item @var{width}, @var{height}
Это ширина и высота в пикселях @var{object} или, если это @code{nil},
пиксели глифа, по которому щелкнули.
@end table

Для щелчков по полосе прокрутки @var{position} имеет такую форму:

@example
(@var{window} @var{area} (@var{portion} . @var{whole}) @var{timestamp} @var{part})
@end example

@table @asis
@item @var{window}
Окно, полоса прокрутки которого была нажата.

@item @var{area}
Это символ @code{vertical-scroll-bar}.

@item @var{portion}
Количество пикселей от верха полосы прокрутки до позиции щелчка.  В
некоторых наборах инструментов, включая GTK+, Emacs не может извлечь эти
данные, поэтому значение всегда равно @code{0}.

@item @var{whole}
Общая длина полосы прокрутки в пикселях.  В некоторых инструментах, включая
GTK+, Emacs не может извлечь эти данные, поэтому значение всегда @code{0}.

@item @var{timestamp}
Время, когда произошло событие, в миллисекундах.  В некоторых наборах
инструментов, включая GTK+, Emacs не может извлечь эти данные, поэтому
значение всегда равно @code{0}.

@item @var{part}
Часть полосы прокрутки, по которой произошел щелчок.  Это один из символов
@code{handle} (маркер полосы прокрутки), @code{above-handle} (область над
маркером), @code{below-handle} (область под маркером), @code{up} (стрелка
вверх на одном конце полосы прокрутки) или @code{down} (стрелка вниз на
одном конце полосы прокрутки).
@c The 'top', 'bottom', and 'end-scroll' codes don't seem to be used.
@end table


@node Drag Events
@subsection Событие Перетаскивания
@cindex drag event
@cindex mouse drag event

С Emacs можно провести событие перетаскивания, даже не приготавливаясь.
@dfn{Событие перетаскивания} происходит каждый раз, когда пользователь
нажимает кнопку мыши, а затем перемещает мышь в другую позицию символа перед
тем, как отпустить кнопку.  Как и все события мыши, события перетаскивания
представлены в Lisp в виде списков.  В списках записывается как начальная,
так и конечная позиция мыши, например:

@example
(@var{event-type}
 (@var{window1} START-POSITION)
 (@var{window2} END-POSITION))
@end example

Для события перетаскивания имя символа @var{event-type} содержит префикс
@samp{drag-}.  Например, перетаскивание мыши с нажатой кнопкой 2 генерирует
событие @code{drag-mouse-2}.  Второй и третий элементы события задают
начальную и конечную позицию перетаскивания, так как положение мыши
перечисляет (@pxref{Click Events}).  Таким же образом можно получить доступ
ко второму элементу любого события мыши.  Однако событие перетаскивания
может закончиться за пределами изначально выбранного кадра.  В этом случае
список позиций третьего элемента содержит этот фрейм вместо окна.

Префикс @samp{drag-} следует за префиксом ключа-модификатора, например
@samp{C-} и @samp{M-}.

Если @code{read-key-sequence} получает событие перетаскивания, которое не
имеет привязки к ключам, и соответствующее событие щелчка имеет привязку,
изменяется событие перетаскивания на событие щелчка в начальной позиции
перетаскивания.  Это означает, что не требуется различать события щелчка и
перетаскивания, если этого не нужно.

@node Button-Down Events
@subsection События при Нажатии Кнопки
@cindex button-down event

События щелчка и перетаскивания происходят, когда пользователь отпускает
кнопку мыши.  Они не могут произойти раньше, потому что нет возможности
отличить щелчок от перетаскивания, пока кнопка не будет отпущена.

Если трбуется действовать, как только кнопка нажата, нужно обработать
событие @dfn{нажатие кнопки}.@footnote{Нажатие кнопки - это консервативная
противоположность перетаскиванию.}  Это происходит, как только нажимается
кнопка.  Представлены списками, которые выглядят точно так же, как события
щелчка (@pxref{Click Events}), за исключением того, что имя символа
@var{event-type} содержит префикс @samp{down-}.  Префикс @samp{down-}
следует за префиксом клавиш-модификаторов, например @samp{C-} и @samp{M-}.

Функция @code{read-key-sequence} игнорирует любые события нажатия кнопки,
для которых нет привязки команд; поэтому цикл команд Emacs их тоже
игнорирует.  Это означает, что не нужно беспокоиться об определении событий
нажатия кнопки, если не нужно, чтобы они что-то делали.  Обычная причина для
определения события нажатия кнопки состоит в том, чтобы можно было
отслеживать движение мыши (считывая события движения), пока кнопка не будет
отпущена.
@xref{Motion Events}.

@node Repeat Events
@subsection Повторение События
@cindex repeat events
@cindex double-click events
@cindex triple-click events
@cindex mouse events, repeated

Если нажимать одну и ту же кнопку мыши более одного раза в быстрой
последовательности, не перемещая мышь, Emacs сгенерирует специальные события
мыши @dfn{repeat} для второго и последующих нажатий.

Наиболее частыми повторяющимися событиями являются события
@dfn{(двойной-щелчок) double-click}.  Emacs генерирует событие двойного
щелчка, когда дважды щелкается кнопка; событие происходит, когда отпускается
кнопка (как обычно для всех событий щелчка).

Тип события для события двойного щелчка содержит префикс @samp{double-}.
Таким образом, двойной щелчок по второй кнопке мыши с зажатой @key{meta}
переходит в программу Lisp как @code{M-double-mouse-2}.  Если событие
двойного щелчка не имеет привязки, для его выполнения используется привязка
соответствующего обычного события щелчка.  Таким образом, не нужно обращать
внимание на функцию двойного щелчка, если действительно этого не нужно.

Когда пользователь выполняет двойной щелчок, Emacs сначала генерирует
обычное событие щелчка, а затем событие двойного щелчка.  Следовательно,
потребуется спроектировать привязку команды для события двойного щелчка, что
бы предполагать, что команда одиночного щелчка уже была запущена.  Это будет
давать желаемые результаты двойного щелчка, начиная с результатов одного
щелчка.

Это удобно, если значение двойного щелчка каким-то образом основывается на
значении одиночного щелчка - что рекомендуется для разработки
пользовательского интерфейса при двойном щелчке.

Если нажимается кнопка, затем снова нажмается и начинается перемещение мыши,
с удерживанием нажатой кнопки, получается событие
@dfn{двойное перетаскивание}, когда в конечном итоге отпустите кнопку.  Его
тип события содержит @samp{двойное перетаскивание}, а не только
@samp{перетаскивание}.  Если событие двойного перетаскивания не имеет
привязки, Emacs ищет альтернативную привязку, как если бы событие было
обычным перетаскиванием.

Перед событием двойного щелчка или двойного перетаскивания Emacs генерирует
событие @dfn{двойное нажатие}, когда пользователь нажимает кнопку во второй
раз.  Его тип события содержит @samp{double-down}, а не только
@samp{нажатие}.  Если событие двойного нажатия не имеет привязки, Emacs
ищет альтернативную привязку, как если бы событие было обычным событием
нажатия кнопки.  Если и в этом случае привязка не обнаруживается, событие
удвоения игнорируется.

Подводя итог, когда щёлкается кнопка, а затем сразу же нажимается снова,
Emacs генерирует событие нажатия и событие щелчка для первого щелчка,
событие двойного нажатия при повторном нажатии кнопки и, наконец, либо
двойной щелчок, либо событие двойного перетаскивания.

Если дважды нажмется кнопка, а затем снова быстрое нажатие, Emacs
сгенерирует событие @dfn{тройное нажатие}, за которым следует
@dfn{тройной щелчок} или @dfn{тройное перетаскивание}.  Типы событий этих
событий содержат @samp{тройной} вместо @samp{двойной}.  Если какое-либо
тройное событие не имеет привязки, Emacs использует привязку, которую он
использовал бы для соответствующего двойного события.

Если нажмете кнопку три или более раз, а затем нажмете ее снова, все события
для нажатий после третьего будут тройными.  В Emacs нет отдельных типов
событий для четверных, пятикратных и т.д. @: событий.  Однако можно
посмотреть список событий, чтобы точно узнать, сколько раз была нажата
кнопка.

@defun event-click-count event
Функция возвращает количество последовательных нажатий кнопок, которые
привели к @var{event}.  Если @var{event} является событием двойного нажатия,
двойного щелчка или двойного перетаскивания, значение равно 2.  Если
@var{event} - тройное событие, значение равно 3 или больше.  Если
@var{event} - обычное событие мыши (не повторение), значение равно 1.
@end defun

@defopt double-click-fuzz
Чтобы генерировать повторяющиеся события, последовательные нажатия кнопок
мыши должны происходить примерно в одном и том же положении на экране.
Значение @code{double-click-fuzz} указывает максимальное количество
пикселей, на которое мышь может быть перемещена (по горизонтали или
вертикали) между двумя последовательными щелчками, чтобы сделать двойной
щелчок.

Эта переменная также является порогом, при котором движение мыши считается
перетаскиванием.
@end defopt

@defopt double-click-time
Для генерации повторяющихся событий количество миллисекунд между
последовательными нажатиями кнопок должно быть меньше значения
@code{double-click-time}.  Установка @code{double-click-time} в @code{nil}
полностью отключает обнаружение множественного щелчка.  Установка @code{t}
снимает ограничение по времени; Emacs затем обнаруживает множественные
щелчки только по позиции.
@end defopt

@node Motion Events
@subsection События Движения
@cindex motion event
@cindex mouse motion events

Emacs иногда генерирует события @dfn{движение мыши} для описания движения
мыши без каких-либо действий кнопок.  События движения мыши представлены
списками, которые выглядят следующим образом:

@example
(mouse-movement POSITION)
@end example

@noindent
@var{position} - это список позиций мыши (@pxref{Click Events}),
определяющий текущую позицию курсора мыши.  Как и в случае с конечной
позицией события перетаскивания, этот список позиций может представлять
местоположение за пределами границ первоначально выбранного кадра, и в этом
случае список содержит этот кадр вместо окна.

Специальная форма @code{track-mouse} позволяет генерировать события движения
внутри своего тела.  Вне форм @code{track-mouse} Emacs не генерирует события
для простого движения мыши, и эти события не появляются.
@xref{Mouse Tracking}.

@node Focus Events
@subsection Событие Фокуса
@cindex focus event

Оконные системы предоставляют пользователю общие способы управления окном,
получающим ввод с клавиатуры.  Этот выбор окна называется @dfn{focus}.
Когда пользователь что-то делает для переключения между кадрами Emacs,
генерируется @dfn{focus event}.  Обычное определение события фокуса в
глобальной таблице ключей - это выбрать новый фрейм в Emacs, как и ожидал
пользователь.  @xref{Input Focus}, который также описывает ловушки,
связанные с событиями фокуса.

События фокуса представлены в Lisp в виде списков, которые выглядят
следующим образом:

@example
(switch-frame @var{new-frame})
@end example

@noindent
где @var{new-frame} - это кадр, на который переключился.

Некоторые диспетчеры окон X настроены так, что достаточно просто переместить
мышь в окно, чтобы установить там фокус.  Обычно программе на Lisp нет
необходимости знать об изменении фокуса до тех пор, пока не поступит
какой-либо другой тип ввода.  Emacs генерирует событие фокуса только тогда,
когда пользователь фактически набирает клавишу клавиатуры или нажимает
кнопку мыши в новом кадре; простое перемещение мыши между кадрами не
приводит к возникновению события фокуса.

Событие фокуса в середине ключевой последовательности искажает
последовательность.  Таким образом, Emacs никогда не генерирует событие
фокуса в середине ключевой последовательности.  Если пользователь меняет
фокус в середине последовательности ключей - то есть после префиксного ключа
- то Emacs переупорядочивает события так, чтобы событие фокуса происходило
либо до, либо после последовательности ключей с несколькими событиями, а не
внутри.

@node Misc Events
@subsection Разные Системные События

Несколько других типов событий представляют собой события в системе.

@table @code
@cindex @code{delete-frame} event
@item (delete-frame (@var{frame}))
Событие такого типа указывает на то, что пользователь дал оконному менеджеру
команду на удаление определенного окна, которое оказывается фреймом Emacs.

Стандартное определение события @code{delete-frame} - удалить @var{frame}.

@cindex @code{iconify-frame} event
@item (iconify-frame (@var{frame}))
Этот вид событий указывает на то, что пользователь сделал значок @var{frame}
иконкой с помощью оконного менеджера.  Его стандартное определение -
@code{ignore}; поскольку фрейм уже обозначен значком, Emacs не может ничего
сделать.  Назначение этого типа событий состоит в том, чтобы иметь
возможность отслеживать такие события, если хотите.

@cindex @code{make-frame-visible} event
@item (make-frame-visible (@var{frame}))
Событие такого типа указывает на то, что пользователь деактивировал
@var{frame} с помощью оконного менеджера.  Его стандартное определение -
@code{ignore}; поскольку фрейм уже стал видимым, Emacs не может ничего
сделать.

@cindex @code{wheel-up} event
@cindex @code{wheel-down} event
@item (wheel-up @var{position})
@itemx (wheel-down @var{position})
События такого типа генерируются при перемещении колеса мыши.  Элемент
@var{position} - это список положений мыши (@pxref{Click Events}),
определяющий положение курсора мыши, когда произошло событие.

@vindex mouse-wheel-up-event
@vindex mouse-wheel-down-event
Подобные события генерируются только в определённых системах.  В некоторых
системах вместо него используется @code{mouse-4} и @code{mouse-5}.  Для
переносимости кода используютсяе переменные @code{mouse-wheel-up-event} и
@code{mouse-wheel-down-event}, определенные в @file{mwheel.el}, чтобы
определить, какие типы событий ожидать от колеса мыши.

@cindex @code{drag-n-drop} event
@item (drag-n-drop @var{position} @var{files})
Этот тип событий генерируется, когда группа файлов выбирается в приложении
вне Emacs, а затем перетаскивается на фрейм Emacs.

Элемент @var{position} - это список, описывающий позицию события, в том же
формате, что и в событии щелчка мышью (@pxref{Click Events}), и @var{files},
представляет собой список имен файлов, которые были перетащены.  Обычный
способ обработать это событие - посетить эти файлы.

В настоящее время такого рода события генерируются только в некоторых типах
систем.

@cindex @code{help-echo} event
@item help-echo
Событие такого типа генерируется, когда указатель мыши перемещается на часть
текста буфера, имеющую текстовое свойство @code{help-echo}.  Сгенерированное
событие имеет такую форму:

@example
(help-echo @var{frame} @var{help} @var{window} @var{object} @var{pos})
@end example

@noindent
Точное значение параметров события и способ использования этих параметров
для отображения текста эхо-справки описаны в @ref{Text help-echo}.

@cindex @code{sigusr1} event
@cindex @code{sigusr2} event
@cindex user signals
@item sigusr1
@itemx sigusr2
Эти события генерируются, когда процесс Emacs получает сигналы
@code{SIGUSR1} и @code{SIGUSR2}.  Они не содержат дополнительных данных,
поскольку сигналы не несут дополнительной информации.  Они могут быть
полезны для отладки (@pxref{Error Debugging}).

Чтобы поймать пользовательский сигнал, привяжите соответствующее событие к
интерактивной команде в @code{special-event-map} (@pxref{Active Keymaps}).
Команда вызывается без аргументов, а конкретное сигнальное событие доступно
в @code{last-input-event}. Например:

@smallexample
(defun sigusr-handler ()
  (interactive)
  (message "Caught signal %S" last-input-event))

(define-key special-event-map [sigusr1] 'sigusr-handler)
@end smallexample

Чтобы проверить обработчик сигнала, можно заставить Emacs посылать сигнал
самому себе:

@smallexample
(signal-process (emacs-pid) 'sigusr1)
@end smallexample

@cindex @code{language-change} event
@item language-change
Событие такого типа генерируется в MS-Windows при изменении языка ввода.
Обычно это означает, что ключи клавиатуры будут отправлять в Emacs символы
другого языка.  Сгенерированное событие имеет такую форму:

@smallexample
(language-change @var{frame} @var{codepage} @var{language-id})
@end smallexample

@noindent
Здесь @var{frame} - это фрейм, который был текущим на момент изменения языка
ввода; @var{codepage} - номер новой кодовой страницы; @var{language-id} -
числовой идентификатор нового языка ввода.  Система кодирования
(@pxref {Coding Systems}), которая соответствует @var{codepage}, - это
@code{cp@var{codepage}} или @code{windows-@var{codepage}}.  Чтобы
преобразовать @var{language-id} в строку (например, чтобы использовать его
для различных языковых функций, таких как @code{set-language-environment}),
используйте функцию @code{w32-get-locale-info}, например:

@smallexample
;; Get the abbreviated language name, such as "ENU" for English
(w32-get-locale-info language-id)
;; Get the full English name of the language,
;; such as "English (United States)"
(w32-get-locale-info language-id 4097)
;; Get the full localized name of the language
(w32-get-locale-info language-id t)
@end smallexample
@end table

  Если одно из этих событий наступает в середине ключевой последовательности
- то есть после префиксного ключа - то Emacs переупорядочивает события так,
чтобы это событие происходило либо до, либо после многособытийной ключевой
последовательности, а не внутри неё.

@node Event Examples
@subsection Примеры Событий

Если пользователь нажимает и отпускает левую кнопку мыши в том же месте, это
генерирует последовательность событий, подобную этой:

@smallexample
(down-mouse-1 (#<window 18 on NEWS> 2613 (0 . 38) -864320))
(mouse-1      (#<window 18 on NEWS> 2613 (0 . 38) -864180))
@end smallexample

Удерживая нажатой клавишу управления, пользователь может удерживать вторую
кнопку мыши и перетаскивать мышь от одной строки к другой.  Это создает два
события, как показано здесь:

@smallexample
(C-down-mouse-2 (#<window 18 on NEWS> 3440 (0 . 27) -731219))
(C-drag-mouse-2 (#<window 18 on NEWS> 3440 (0 . 27) -731219)
                (#<window 18 on NEWS> 3510 (0 . 28) -729648))
@end smallexample

Удерживая нажатыми клавиши meta и shift, пользователь может нажать вторую
кнопку мыши на строке режима окна, а затем перетащить мышь в другое окно.
Это создает пару таких событий:

@smallexample
(M-S-down-mouse-2 (#<window 18 on NEWS> mode-line (33 . 31) -457844))
(M-S-drag-mouse-2 (#<window 18 on NEWS> mode-line (33 . 31) -457844)
                  (#<window 20 on carlton-sanskrit.tex> 161 (33 . 3)
                   -453816))
@end smallexample

Рамка с фокусом ввода может не занимать весь экран, и пользователь может
переместить мышь за пределы рамки.  Внутри специальной формы
@code{track-mouse}, которая генерирует подобное событие:

@smallexample
(mouse-movement (#<frame *ielm* 0x102849a30> nil (563 . 205) 532301936))
@end smallexample

Чтобы обработать сигнал SIGUSR1, определяется интерактивная функцию и
привязывается к последовательности событий @code{signal usr1}:

@smallexample
(defun usr1-handler ()
  (interactive)
  (message "Got USR1 signal"))
(global-set-key [signal usr1] 'usr1-handler)
@end smallexample

@node Classifying Events
@subsection Классификация Событий
@cindex event type
@cindex classifying events

  У каждого события есть @dfn{тип события}, который классифицирует событие
для целей привязки ключей.  Для события клавиатуры тип события равен
значению события; таким образом, тип события для символа - это символ, а
тип события для символа функциональной клавиши - это сам символ.  Для
событий, которые являются списками, тип события - это символ в @sc{car}
списка.  Таким образом, тип события всегда является символом или знаком.

  Два события одного типа эквивалентны в том, что касается привязки ключей;
таким образом, они всегда запускают одну и ту же команду.  Однако это не
обязательно означает, что они делают одно и то же, поскольку некоторые
команды смотрят на все событие, чтобы решить, что делать.  Например,
некоторые команды используют местоположение события мыши, чтобы решить, где
в буфере действовать.

  Иногда полезны более широкие классификации событий.  Например, можно
спросить, связано ли событие с клавишей @key{META}, независимо от того,
какая другая клавиша или кнопка мыши была использована.

  Функции @code{event-modifiers} и @code{event-basic-type} предназначены для
удобного получения такой информации.

@defun event-modifiers event
Эта функция возвращает список модификаторов, которые есть у @var{event}.
Модификаторы представляют собой символы; они включают @code{shift},
@code{control}, @code{meta}, @code{alt}, @code{hyper} и @code{super}.  Кроме
того, список модификаторов символа события мыши всегда содержит один из
@code{click}, @code{drag}, и @code{down}.  Для двойных или тройных событий
также содержит @code{double} или @code{triple}.

Аргумент @var{event} может быть целым объектом события или только типом
события.  Если @var{event} - это символ, который никогда не использовался в
событии, считанном как ввод в текущем сеансе Emacs, тогда
@code{event-modifiers} может вернуть @code{nil}, даже если @var{event}
действительно имеет модификаторы.

Вот несколько примеров:

@example
(event-modifiers ?a)
     @result{} nil
(event-modifiers ?A)
     @result{} (shift)
(event-modifiers ?\C-a)
     @result{} (control)
(event-modifiers ?\C-%)
     @result{} (control)
(event-modifiers ?\C-\S-a)
     @result{} (control shift)
(event-modifiers 'f5)
     @result{} nil
(event-modifiers 's-f5)
     @result{} (super)
(event-modifiers 'M-S-f5)
     @result{} (meta shift)
(event-modifiers 'mouse-1)
     @result{} (click)
(event-modifiers 'down-mouse-1)
     @result{} (down)
@end example

Список модификаторов для события щелчка явно содержит @code{click}, но само
имя символа события не содержит @samp{click}.  Точно так же список
модификаторов для управляющего символа @acronym{ASCII}, такого как
@samp{C-a}, содержит @code{control}, хотя чтение такого события через
@code{read-char} вернет значение 1 с удаленным битом модификатора
управления.
@end defun

@defun event-basic-type event
Эта функция возвращает ключ или кнопку мыши, которые описывает @var{event},
со всеми удаленными модификаторами.  Аргумент @var{event} такой же, как в
@code{event-modifiers}.  Например:

@example
(event-basic-type ?a)
     @result{} 97
(event-basic-type ?A)
     @result{} 97
(event-basic-type ?\C-a)
     @result{} 97
(event-basic-type ?\C-\S-a)
     @result{} 97
(event-basic-type 'f5)
     @result{} f5
(event-basic-type 's-f5)
     @result{} f5
(event-basic-type 'M-S-f5)
     @result{} f5
(event-basic-type 'down-mouse-1)
     @result{} mouse-1
@end example
@end defun

@defun mouse-movement-p object
Эта функция возвращает не-@code{nil}, если @var{object} является событием
движения мыши.  @xref{Motion Events}.
@end defun

@defun event-convert-list list
Эта функция преобразует список имен модификаторов и базовый тип события в
тип события, который определяет их все.  Базовый тип события должен быть
последним элементом списка.  Например,

@example
(event-convert-list '(control ?a))
     @result{} 1
(event-convert-list '(control meta ?a))
     @result{} -134217727
(event-convert-list '(control super f1))
     @result{} C-s-f1
@end example
@end defun

@node Accessing Mouse
@subsection Доступ к Событиям Мыши
@cindex mouse events, data in
@cindex keyboard events, data in

  В этом разделе описаны удобные функции для доступа к данным при нажатии
кнопки мыши или событии движения.  Доступ к данным событий клавиатуры можно
получить с помощью тех же функций, но элементы данных, которые не применимы
к событиям клавиатуры, равны нулю или @code{nil}.

  Следующие две функции возвращают список положения мыши
(@pxref{Click Events}), определяющий позицию события мыши.

@defun event-start event
Это возвращает начальную позицию @var{event}.

Если @var{event} является событием щелчка или нажатия кнопки, это возвращает
местоположение события.  Если @var{event} является событием перетаскивания,
это возвращает начальную позицию перетаскивания.
@end defun

@defun event-end event
Это возвращает конечную позицию @var{event}.

Если @var{event} является событием перетаскивания, это возвращает позицию, в
которой пользователь отпустил кнопку мыши.  Если @var{event} является
событием щелчка или нажатия кнопки, значение фактически является начальной
позицией, которая является единственной позицией, которую имеют такие
события.
@end defun

@defun posnp object
Функцией возвращается не-@code{nil}, если @var{object} - это список позиций
мыши, в формате, задокументированном в @ref{Click Events}); и @code{nil} в
противном случае.
@end defun

@cindex mouse position list, accessing
  Этими функциями принимается список позиций мыши в качестве аргумента и
возвращаются различные его части:

@defun posn-window position
Вернётся окно, в котором находится @var{position}. Если @var{position}
представляет место за пределами фрейма, где было инициировано событие,
возвращается этот кадр.
@end defun

@defun posn-area position
Вернуть область окна, записанную в @var{position}.  Возвращается @code{nil},
когда событие произошло в текстовой области окна; в противном случае это
символ, обозначающий область, в которой произошло событие.
@end defun

@defun posn-point position
Вернуть буферную позицию в @var{position}.  Когда событие произошло в
текстовой области окна, в области полей или на краю, это целое число,
определяющее позицию буфера.  В противном случае значение не определено.
@end defun

@defun posn-x-y position
Возвращаются пиксельные координаты x и y в @var{position} как cons-ячейка
@w{@code{(@var{x} . @var{y})}}.  Эти координаты относятся к окну
@code{posn-window}.

В этом примере показано, как преобразовать координаты относительно окна в
текстовой области окна в координаты относительно кадра:

@example
(defun frame-relative-coordinates (position)
  "Вернуть координаты относительно кадра из POSITION.
   Предполагается, что POSITION находится в текстовой области окна."
  (let* ((x-y (posn-x-y position))
         (window (posn-window position))
         (edges (window-inside-pixel-edges window)))
    (cons (+ (car x-y) (car edges))
          (+ (cdr x-y) (cadr edges)))))
@end example
@end defun

@defun posn-col-row position
Функцией возвращается cons-ячейка @w{@code{(@var{col} .  @var{row})}},
содержащая оценочный столбец и строку, соответствующие позиции в буфере,
описанной @var{position}.  Возвращаемое значение дается в единицах ширины
символа фрейма по умолчанию и высоты строки по умолчанию (включая интервал),
вычисленных из значений @var{x} и @var{y}, соответствующих @var{position}.
(Таким образом, если фактические символы имеют размер, отличный от размера
по умолчанию, фактическая строка и столбец могут отличаться от этих
вычисленных значений.)

Обратите внимание, что @var{row} отсчитывается от верха текстовой области.
Если окно, заданное параметром @var{position}, имеет строку заголовка
(@pxref{Header Lines}), оно включается в счет @var{row}.
@end defun

@defun posn-actual-col-row position
Возвращется фактическая строка и столбец в @var{position} как cons-ячейка
@w{@code{(@var{col} . @var{row})}}.  Значения представляют собой фактические
номера строк и столбцов в окне, заданном @var{position}.
@xref{Click Events}, для подробностей.  Функция возвращает @code{nil}, если
@var{position} не включает фактические значения положения; в этом случае
@code{posn-col-row} можно использовать для получения приблизительных
значений.

Обратить внимание, что эта функция не учитывает визуальную ширину
отображаемых символов, например количество визуальных столбцов, занимаемых
символом табуляции или изображением.  Если требуются координаты в
канонических символьных единицах, используется вместо них
@code{posn-col-row}.
@end defun

@defun posn-string position
Возвращается строковый объект, описанный @var{position}, либо @code{nil}
(что означает, что @var{position} описывает текст буфера), либо cons-ячейка
@w{@code{(@var{string} . @var{string-pos})}}.
@end defun

@defun posn-image position
Возвращается объект изображения в @var{position}, либо в @code{nil} (если в
@var{position} нет изображения), либо в спецификации изображения
@w{@code{(image @dots{})}}.
@end defun

@defun posn-object position
Возвращается изображение или строковый объект, описанный @var{position},
либо @code{nil} (что означает, что @var{position} описывает текст буфера),
изображение @w{@code{(image @dots{})}} или cons-ячейка
@w{@code{(@var{string} . @var{string-pos})}}.
@end defun

@defun posn-object-x-y position
Возвращаются пиксельные координаты x и y относительно верхнего левого угла
объекта, описанного @var{position}, в виде cons-ячейки
@w{@code{(@var{dx} . @var{dy})}}.  Если @var{position} описывает буферный
текст, возвращает относительные координаты символа буферного текста,
ближайшего к этой позиции.
@end defun

@defun posn-object-width-height position
Возвращается ширина и высота в пикселях объекта, описанного @var{position},
как cons-ячейка @code{(@var{width} . @var{height})}.  Если @var{position}
описывает позицию в буфере, возвращается позиция этого символа.
@end defun

@cindex timestamp of a mouse event
@defun posn-timestamp position
Вернуть метку времени в @var{position}.  Это время, в которое произошло
событие, в миллисекундах.
@end defun

  Эти функции вычисляют список позиций с учетом конкретной позиции в буфере
или на экране.  Можно получить доступ к данным в этом списке позиций с
помощью функций, описанных выше.

@defun posn-at-point &optional pos window
Эта функция возвращает список позиций для позиции @var{pos} в @var{window}.
@var{pos} по умолчанию указывает на @var{window}; @var{window} по умолчанию
используется в выбранном окне.

@code{posn-at-point} возвращается @code{nil}, если @var{pos} не отображается
в @var{window}.
@end defun

@defun posn-at-x-y x y &optional frame-or-window whole
Эта функция возвращает информацию о позиции, соответствующую координатам
пикселей @var{x} и @var{y} в указанном кадре или окне,
@var{frame-or-window}, которое по умолчанию соответствует выбранному окну.
Координаты @var{x} и @var{y} относятся к используемому фрейму или окну.
Если @var{whole} равен @code{nil}, координаты относятся к текстовой области
окна, в противном случае они относятся ко всей области окна, включая полосы
прокрутки, поля и полосы.
@end defun

@node Accessing Scroll
@subsection Доступ к Событиям Полосы Прокрутки
@cindex scroll bar events, data in

  Эти функции полезны для декодирования событий полосы прокрутки.

@defun scroll-bar-event-ratio event
Функцией возвращается дробная вертикальную позиция события полосы прокрутки
внутри полосы прокрутки.  Значение представляет собой cons-ячейку
@code{(@var{portion} . @var{whole})}, содержащую два целых числа, отношение
которых является дробной позицией.
@end defun

@defun scroll-bar-scale ratio total
Функцией умножается (фактически) @var{ratio} на @var{total}, округляется
результат до целого числа.  Аргумент @var{ratio} - это не число, а точечная
пара @code{(@var{num}. @var{denom})} --- обычно значение, возвращаемое
@code{scroll-bar-event-ratio}.

Эта функция удобна для масштабирования позиции на полосе прокрутки в
буферную позицию.  Вот как это сделать:

@example
(+ (point-min)
   (scroll-bar-scale
      (posn-x-y (event-start event))
      (- (point-max) (point-min))))
@end example

Напомнается, что события полосы прокрутки имеют два целых числа, образующих
отношение, вместо пары координат x и y.
@end defun

@node Strings of Events
@subsection Помещение Событий Клавиатуры в Строки
@cindex keyboard events in strings
@cindex strings with keyboard events

  В большинстве случаев, когда используются строки, концептуализируется
строка как содержащая текстовые символы - символы того же типа, что и в
буферах или файлах.  Иногда программы на Lisp используют строки, которые
концептуально содержат символы клавиатуры; например, это могут быть
последовательности ключей или определения макросов клавиатуры.  Однако
сохранение клавиатурных символов в строке - сложный вопрос по причинам
исторической совместимости, и это не всегда возможно.

  Рекомендуется, чтобы новые программы избегали решения этих проблем, не
сохраняя события клавиатуры в строках.  Вот как это делается:

@itemize @bullet
@item
Используются векторы вместо строк для ключевых последовательностей, если
планируется использовать их для чего-либо, кроме аргументов
@code{lookup-key} и @code{define-key}.  Например, можно использовать
@code{read-key-sequence-vector} вместо @code{read-key-sequence} и
@code{this-command-keys-vector} вместо @code{this-command-keys}.

@item
Используются векторы для записи констант последовательности ключей,
содержащих метасимволы, даже при передаче их напрямую в @code{define-key}.

@item
Когда нужно просмотреть содержимое ключевой последовательности, которая
может быть строкой, сначала используется @code{listify-key-sequence}
(@pxref{Event Input Misc}), чтобы преобразовать ее в список.
@end itemize

  Сложности проистекают из битов-модификаторов, которые могут включать
символы ввода с клавиатуры.  За исключением модификатора Meta, ни один из
этих битов модификатора не может быть включен в строку, а модификатор Meta
разрешен только в особых случаях.

  Самые ранние версии GNU Emacs представляли метасимволы в виде кодов в
диапазоне от 128 до 255.  В то время базовые коды символов варьировались от
0 до 127, поэтому все коды символов клавиатуры помещались в строку.  Многие
программы на Lisp использовали @samp{\M-} в строковых константах для
обозначения метасимволов, особенно в аргументах для @code{define-key} и
подобных функций, а последовательности клавиш и последовательности событий
всегда представлялись в виде строк.

  Когда добавилась поддержка более крупных кодов основных символов,
превышающих 127, и дополнительных битов-модификаторов, пришлось изменить
представление метасимволов.  Теперь флаг, который представляет модификатор
Мета в символе, -
@tex
@math{2^{27}}
@end tex
@ifnottex
2**27
@end ifnottex
и такие числа не могут быть включены в строку.

  Для поддержки программ с @samp{\M-} в строковых константах существуют
специальные правила для включения определенных метасимволов в строку.  Вот
правила интерпретации строки как последовательности входных символов:

@itemize @bullet
@item
Если значение символа клавиатуры находится в диапазоне от 0 до 127, оно
может оставаться в строке без изменений.

@item
Метаварианты этих символов с кодами в диапазоне от
@tex
@math{2^{27}}
@end tex
@ifnottex
2**27
@end ifnottex
до
@tex
@math{2^{27} + 127},
@end tex
@ifnottex
2**27+127,
@end ifnottex
также могут входить в строку, но потребуется изменить их числовые значения.
Также следует установить
@tex
@math{2^{7}}
@end tex
@ifnottex
2**7
@end ifnottex
бит вместо
@tex
@math{2^{27}}
@end tex
@ifnottex
2**27
@end ifnottex
бит, в результате чего получается значение от 128 до 255.  Только
однобайтная строка может включать эти коды.

@item
Не-@acronym{ASCII} символов выше 256 могут быть включены в многобайтовую
строку.

@item
Другие события символов клавиатуры не могут поместиться в строку.  Сюда
входят события клавиатуры в диапазоне от 128 до 255.
@end itemize

  Такие функции, как @code{read-key-sequence}, которые создают строки
символов ввода с клавиатуры, следуют этим правилам: они создают векторы
вместо строк, когда события не помещаются в строку.

  Когда используется синтаксис чтения @samp{\M-} в строке, создается код в
диапазоне от 128 до 255 - тот же код, который получается, если изменяется
соответствующее событие клавиатуры, чтобы поместить его в строку.  Таким
образом, мета-события в строках работают согласованно, независимо от того,
как они попадают в строки.

  Однако большинству программ следует избегать этих проблем, следуя
рекомендациям в начале этого раздела.

@node Reading Input
@section Чтение Ввода
@cindex read input
@cindex keyboard input

  Командный цикл редактора считывает последовательности клавиш с помощью
функции @code{read-key-sequence}, которая использует @code{read-event}.  Эти
и другие функции для ввода событий также доступны для использования в
программах на Lisp.  Смотреть также @code{momentary-string-display} в
@ref{Temporary Displays} и @code{sit-for} в @ref{Waiting}.
@xref{Terminal Input}, для функций и переменных для управления режимами
ввода терминала и отладки ввода терминала.

  Для устройств ввода более высокого уровня, смотреть @ref{Minibuffers}.

@menu
* Key Sequence Input::          Как читать одну ключевую последовательность.
* Reading One Event::           Как прочитать только одно событие.
* Event Mod::                  Как Emacs изменяет события по мере их чтения.
* Invoking the Input Method::   Как чтение события использует метод ввода.
* Quoted Character Input::      Просить пользователя указать символ.
* Event Input Misc::            Как перечитать или выбросить события ввода.
@end menu

@node Key Sequence Input
@subsection Ввод Последовательности Ключей
@cindex key sequence input

  Командный цикл читает ключевую последовательность за раз, вызывая
@code{read-key-sequence}.  Программы Lisp также могут вызывать эту функцию;
например, @code{describe-key} используется его для чтения описания ключа.

@defun read-key-sequence prompt &optional continue-echo dont-downcase-last switch-frame-ok command-loop
Функцией считывается ключевая последовательность ключей и возвращается она в
виде строки или вектора.  Продолжается считывание события, пока не наберется
полная ключевая последовательность; то есть достаточная, чтобы указать
команду без префикса с использованием текущих активных ключевых карт.
(Напоминание, последовательность ключей, которая начинается с события мыши,
считывается с использованием ключевых карт буфера в окне, в котором
находилась мышь, а не текущего буфера.)

Если все события представляют собой символы и все могут уместиться в строке,
то @code{read-key-sequence} возвращает строку (@pxref{Strings of Events}).
В противном случае возвращается вектор, поскольку вектор может содержать все
виды событий - символы, символы и списки.  Элементы строки или вектора - это
события в ключевой последовательности.

Чтение ключевой последовательности включает в себя перевод событий
различными способами.  @xref{Translation Keymaps}.

Аргумент @var{prompt} - это либо строка, которая должна отображаться в
эхо-области как подсказка, либо @code{nil}, означающая, что подсказка не
отображается.  Аргумент @var{continue-echo}, если не-@code{nil}, означает
вывод этого ключа как продолжение предыдущего ключа.

Обычно любое событие в верхнем регистре преобразуется в нижний регистр, если
исходное событие не определено и определен его эквивалент в нижнем регистре.
Аргумент @var{dont-downcase-last}, если не-@code{nil}, означает не
преобразовывать последнее событие в нижний регистр. Это подходит для чтения
ключевой последовательности, которую необходимо определить.

Аргумент @var{switch-frame-ok}, если не-@code{nil}, означает, что эта
функция должна обрабатывать событие @code{switch-frame}, если пользователь
переключает кадры перед тем, как что-либо печатать.  Если пользователь
переключает кадры в середине последовательности клавиш или в начале
последовательности, но @var{switch-frame-ok} имеет значение @code{nil}, то
событие будет отложено до окончания текущей последовательности клавиш.

Аргумент @var{command-loop}, если не-@code{nil}, означает, что эта
последовательность клавиш читается чем-то, что будет читать команды одну за
другой.  Это должно быть @code{nil}, если вызывающий будет читать только
одну последовательность ключей.

В следующем примере Emacs отображает приглашение @samp{?} в эхо-области, а
затем пользователь вводит @kbd{C-x C-f}.

@example
(read-key-sequence "?")

@group
---------- Echo Area ----------
?@kbd{C-x C-f}
---------- Echo Area ----------

     @result{} "^X^F"
@end group
@end example

Функция @code{read-key-sequence} подавляет завершение: @kbd{C-g}, набор
прочитанный с помощью этой функции, работает как любой другой символ и не
устанавливает @code{quit-flag}.  @xref{Quitting}.
@end defun

@defun read-key-sequence-vector prompt &optional continue-echo dont-downcase-last switch-frame-ok command-loop
Это похоже на @code{read-key-sequence}, за исключением того, что всегда
возвращается ключевая последовательность как вектор, а не как строка.
@xref{Strings of Events}.
@end defun

@cindex upper case key sequence
@cindex downcasing in @code{lookup-key}
@cindex shift-translation
Если вводимый символ имеет верхний регистр (или имеет модификатор сдвига) и
не имеет привязки ключей, а его эквивалент в нижнем регистре имеет нижний
регистр, то @code{read-key-sequence} преобразует символ в нижний регистр.
Обратить внимание, что @code{lookup-key} не выполняет преобразование
регистра таким образом.

@vindex this-command-keys-shift-translated
Когда чтение ввода приводит к такому @dfn{shift-translation}, Emacs
устанавливает для переменной @code{this-command-keys-shift-translated}
значение не-@code{nil}.  Программой на Lisp может проверятся эта переменная,
если нужно изменить свое поведение при вызове с помощью ключей с
преобразованием сдвига.  Например, функция @code{handle-shift-selection}
проверяет значение этой переменной, чтобы определить, как активировать или
деактивировать регистр.  (@pxref{The Mark, handle-shift-selection}).

Функцией @code{read-key-sequence} также преобразуются некоторые события
мыши.  Преобразуются несвязанные события перетаскивания в события щелчка и
полностью отбрасывает несвязанные события нажатия кнопки.  Также
перетасовываются события фокуса и разные события окна, чтобы они никогда не
появлялись в ключевых последовательностях с любыми другими событиями.

@cindex @code{header-line} prefix key
@cindex @code{mode-line} prefix key
@cindex @code{vertical-line} prefix key
@cindex @code{horizontal-scroll-bar} prefix key
@cindex @code{vertical-scroll-bar} prefix key
@cindex @code{menu-bar} prefix key
@cindex mouse events, in special parts of frame
Когда события мыши происходят в особых частях окна, таких как строка режима
или полоса прокрутки, тип события не показывает ничего особенного - это тот
же символ, который обычно представляет комбинацию кнопки мыши и
клавиш-модификаторов.  Информация о оконной части хранится в другом месте
события --- в координатах.  Но @code{read-key-sequence} преобразует эту
информацию в воображаемые префиксные ключи, которые являются символами:
@code{header-line}, @code{horizontal-scroll-bar}, @code{menu-bar},
@code{mode-line}, @code{vertical-line}, и @code{vertical-scroll-bar}.  Можно
определить значения щелчков мыши в специальных частях окна, задав
последовательности ключей с помощью этих воображаемых префиксных клавиш.

Например, если вызывается @code{read-key-sequence}, а затем щелкается мышь
по строке режима окна, получается два события, например:

@example
(read-key-sequence "Щелкните строку режима: ")
     @result{} [mode-line
         (mouse-1
          (#<window 6 on NEWS> mode-line
           (40 . 63) 5959987))]
@end example

@defvar num-input-keys
Значение этой переменной - это количество ключевых последовательностей,
обработанных на данный момент в этом сеансе Emacs.  Сюда входят
последовательности ключей, считываемые с терминала, и последовательности
ключей, считываемые из выполняемых макросов клавиатуры.
@end defvar

@node Reading One Event
@subsection Чтение Одного События
@cindex reading a single event
@cindex event, reading only one

  Функции самого нижнего уровня для ввода команд - @code{read-event},
@code{read-char} и @code{read-char-exclusive}.

@defun read-event &optional prompt inherit-input-method seconds
Эта функция считывает и возвращает следующее событие ввода команды, ожидая,
если необходимо, пока событие не станет доступным.

Возвращаемое событие может исходить непосредственно от пользователя или из
макроса клавиатуры.  Не декодируется системой кодирования ввода клавиатуры
(@pxref{Terminal I/O Encoding}).

Если необязательный аргумент @var{prompt} - не-@code{nil}, это должна быть
строка, отображаемая в эхо-области в качестве приглашения.  В противном
случае @code{read-event} не отображается никаких сообщений, указывающих на
то, что ожидается на ввод; вместо этого выводится подсказка в виде эха:
отображается описания событий, которые привели к текущей команде или были
прочитаны ею.  @xref{The Echo Area}.

Если @var{inherit-input-method} равен не-@code{nil}, то используется текущий
метод ввода (если есть), чтобы можно было ввести не-@acronym{ASCII} символ.
В противном случае обработка метода ввода отключена для чтения этого
события.

Если @code{cursor-in-echo-area} равен не-@code{nil}, то @code{read-event}
временно перемещает курсор в эхо-область, в конец любого отображаемого там
сообщения.  В противном случае @code{read-event} не перемещает курсор.

Если @var{seconds} равен не-@code{nil}, это должно быть число, указывающее
максимальное время ожидания ввода в секундах.  Если в течение этого времени
ввод не поступает, @code{read-event} прекращает ожидание и возвращает
@code{nil}.  @var{seconds} с плавающей запятой означает ожидание дробного
числа секунд.  Некоторые системы поддерживают только целое количество
секунд, в этих системах @var{seconds} округляется в меньшую сторону.  Если
@var{seconds} равен @code{nil}, @code{read-event} ожидает поступления ввода
столько, сколько необходимо.

Если @var{seconds} равен @code{nil}, Emacs считается бездействующим в
ожидании поступления пользовательского ввода.  Таймеры простоя - созданные с
помощью @code{run-with-idle-timer} (@pxref{Idle Timers}) - могут работать в
этот период.  Однако, если @var{seconds} равен не-@code{nil}, состояние
бездействия остается неизменным.  Если Emacs не находится в состоянии
ожидания при вызове @code{read-event}, он остается неактивным на протяжении
всей работы @code{read-event}; если Emacs простаивает (что может произойти,
если вызов происходит внутри таймера простоя), он остается бездействующим.

Если @code{read-event} получает событие, которое определяется как символ
справки, тогда в некоторых случаях @code{read-event} обрабатывает событие на
прямую, не возвращаясь.  @xref{Help Functions}.  Некоторые другие события,
называемые @dfn{special events}, также обрабатываются непосредственно в
@code{read-event} (@pxref{Special Events}).

Вот что произойдет, если вызыватется @code{read-event} и затем нажмается
функциональная клавиша со стрелкой вправо:

@example
@group
(read-event)
     @result{} right
@end group
@end example
@end defun

@defun read-char &optional prompt inherit-input-method seconds
Эта функция считывает и возвращает событие символа.  Если пользователь
генерирует событие, не являющееся символом (т.е. событие щелчка мыши или
функциональной клавиши), @code{read-char} сигнализирует об ошибке.
Аргументы работают как в @code{read-event}.

Если у события есть модификаторы, Emacs пытается разрешить их и вернуть код
соответствующего символа.  Например, если пользователь вводит @kbd{C-a},
функция возвращает 1, который является кодом @acronym{ASCII} символа
@samp{C-a}.  Если некоторые из модификаторов не могут быть отражены в коде
символа, @code{read-char} оставляет неразрешенные биты модификатора,
установленные в возвращенном событии.  Например, если пользователь вводит
@kbd{C-M-a}, функция возвращает 134217729, 8000001 в шестнадцатеричном
формате, то есть @: @samp{C-a} с установленным битом модификатора Meta.
Это значение не является допустимым символьным кодом: оно не проходит тест
@code{characterp} (@pxref{Character Codes}).  Используйте
@code{event-basic-type} (@pxref{Classifying Events}), чтобы восстановить код
символа с удаленными битами модификатора; используйте @code{event-modifiers}
для проверки модификаторов в событии символа, возвращаемом @code{read-char}.

В первом примере ниже пользователь вводит символ @kbd{1} (код
@acronym{ASCII} 49).  Во втором примере показано определение макроса
клавиатуры, которое вызывает @code{read-char} из минибуфера с помощью
@code{eval-expression}.  @code{read-char} читает следующий символ макроса
клавиатуры - @kbd{1}.  Затем @code{eval-expression} отображает возвращаемое
значение в эхо-области.

@example
@group
(read-char)
     @result{} 49
@end group

@group
;; @r{Предполагается, что здесь используется @kbd{M-:} для оценки этого.}
(symbol-function 'foo)
     @result{} "^[:(read-char)^M1"
@end group
@group
(execute-kbd-macro 'foo)
     @print{} 49
     @result{} nil
@end group
@end example
@end defun

@defun read-char-exclusive &optional prompt inherit-input-method seconds
Эта функция считывает и возвращает событие ввода символа.  Если пользователь
генерирует событие, которое не является символьным событием,
@code{read-char-exclusive} игнорирует его и читает другое событие, пока не
получит символ.  Аргументы работают как в @code{read-event}.  Возвращаемое
значение может включать биты модификатора, как в случае с @code{read-char}.
@end defun

  Ни одна из вышеперечисленных функций не подавляет выход.

@defvar num-nonmacro-input-events
Эта переменная содержит общее количество событий ввода, полученных на данный
момент от терминала, не считая событий, сгенерированных макросами
клавиатуры.
@end defvar

  Подчеркнем, что, в отличие от @code{read-key-sequence}, функции
@code{read-event}, @code{read-char}, и @code{read-char-exclusive} не
выполняют трансляции, описанные в @ref{Translation Keymaps}.  Если требуется
прочитать один ключ с учетом этих прансляций, используйте функцию
@code{read-key}:

@defun read-key &optional prompt
Эта функция считывает одну клавишу.  Это промежуточное звено между
@code{read-key-sequence} и @code{read-event}.  В отличие от первого,
считывается один ключ, а не последовательность ключей.  В отличие от
последнего, не возвращается исходное событие, а декодируется и преобразуется
ввод пользователя в соответствии с @code{input-decode-map},
@code{local-function-key-map} и @code{key-translation-map}
(@pxref{Translation Keymaps}).

Аргумент @var{prompt} - это либо строка, которая должна отображаться в
эхо-области как подсказка, либо @code{nil}, означающая, что подсказка не
отображается.
@end defun

@defun read-char-choice prompt chars &optional inhibit-quit
Эта функция использует @code{read-key} для чтения и возврата одного символа.Игнорирует любой ввод, который не является членом @var{chars}, списка
допустимых символов.  При желании также будет игнорировать события выхода с
клавиатуры, пока ожидает действительного ввода.  Если привязывать
@code{help-form} (@pxref{Help Functions}) к значению не-@code{nil} при
вызове @code{read-char-choice}, то нажатие @code{help-char} заставляет
вычислить @code{help-form} и отобразить результат.  Затем продолжается
ожидание допустимого входного символа или выхода с клавиатуры.
@end defun

@defun read-multiple-choice prompt choices
Задайте пользователю вопрос с несколькими вариантами ответов.  @var{prompt}
должно быть строкой, которая будет отображаться как приглашение.

@var{choices} - это список, в котором первый элемент в каждой записи - это
вводимый символ, второй элемент - это короткое имя записи, которая будет
отображаться при запросе (если есть место, оно может быть сокращено), а
третья, необязательная запись - более подробное объяснение, которое будет
отображаться в буфере справки, если пользователь запросит дополнительную
помощь.

Возвращаемое значение - это совпадающее значение из @var{choices}.

@lisp
(read-multiple-choice
 "Continue connecting?"
 '((?a "always" "Accept certificate for this and future sessions.")
   (?s "session only" "Accept certificate this session only.")
   (?n "no" "Refuse to use certificate, close connection.")))
@end lisp

Грань @code{read-multiple-choice-face} используется для выделения
совпадающих символов в строке имени на графических терминалах.

@end defun

@node Event Mod
@subsection Изменение и Преобразование Входных Событий
@cindex modifiers of events
@cindex translating input events
@cindex event translation

  Emacs модифицирует каждое считываемое событие в соответствии с
@code{extra-keyboard-modifiers}, затем транслирует его через
@code{keyboard-translate-table} (если применимо), прежде чем вернуть его из
@code{read-event}.

@defvar extra-keyboard-modifiers
Эта переменная позволяет программам Lisp ``press'' использовать
клавиши-модификаторы на клавиатуре.  Значение - это символ.  Имеют значение
только символьные модификаторы.  Каждый раз, когда пользователь набирает
клавишу на клавиатуре, она изменяется, как если бы эти клавиши-модификаторы
удерживались.  Например, если привязано @code{extra-keyboard-modifiers} к
@code{?\C-\M-a}, то ко всем вводимым с клавиатуры символам, набранным во
время привязки, будут применены модификаторы control и meta.  Символ
@code{?\C-@@}, эквивалентный целому числу 0, считается для этой цели не
управляющим символом, а символом без модификаторов. Таким образом, установка
@code{extra-keyboard-modifiers} в ноль отменяет любые изменения.

При использовании оконной системы программа может таким образом нажимать
любую из клавиш-модификаторов.  В противном случае виртуально можно будет
нажимать только клавиши @key{CTL} и @key{META}.

Обратить внимание, что эта переменная применяется только к событиям, которые
действительно исходят с клавиатуры, и не влияет на события мыши или любые
другие события.
@end defvar

@defvar keyboard-translate-table
Эта локальная для терминала переменная представляет собой таблицу перевода
символов клавиатуры.  Это позволяет перетасовывать клавиши на клавиатуре, не
меняя привязки команд.  Значение обычно представляет собой таблицу символов
или @code{nil}.  (Это также может быть строка или вектор, но это считается
устаревшим.)

Если @code{keyboard-translate-table} - это таблица символов
(@pxref{Char-Tables}), то каждый символ, считанный с клавиатуры, ищется в
этой таблице символов.  Если найденное значение - не-@code{nil}, то оно
используется вместо фактического входного символа.

Обратить внимание, что этот перевод - первое, что происходит с символом
после его чтения с терминала.  Функции ведения записи, такие как файлы
@code{recent-keys} и dribble, записывают символы после перевода.

Также обратить внимание, что это транслирование выполняется до того, как
символы будут переданы в методы ввода (@pxref{Input Methods}).  Использовать
@code{translation-table-for-input} (@pxref{Translation of Characters}), если
требуется транслировать символы после срабатывания методов ввода.
@end defvar

@defun keyboard-translate from to
Эта функция изменяет @code{keyboard-translate-table} для преобразования
символьного кода @var{from} в символьный код @var{to}.  При необходимости
создаётся таблица транслирования клавиатуры.
@end defun

  Вот пример использования @code{keyboard-translate-table}, чтобы @kbd{C-x},
@kbd{C-c} и @kbd{C-v} выполнял операции вырезания, копирования и вставки:

@example
(keyboard-translate ?\C-x 'control-x)
(keyboard-translate ?\C-c 'control-c)
(keyboard-translate ?\C-v 'control-v)
(global-set-key [control-x] 'kill-region)
(global-set-key [control-c] 'kill-ring-save)
(global-set-key [control-v] 'yank)
@end example

@noindent
На графическом терминале, который поддерживает расширенный ввод
@acronym{ASCII}, все равно можно получить стандартные значения Emacs одного
из этих символов, набранного с помощью клавиши Shift.  Это делает его другим
символом в том, что касается перевода с клавиатуры, но он имеет то же
обычное значение.

  @xref{Translation Keymaps}, для механизмов, транслирующих
последовательности событий на уровне @code{read-key-sequence}.

@node Invoking the Input Method
@subsection Вызов Метода Ввода
@cindex invoking input method

  Функции чтения событий вызывают текущий метод ввода, если таковой имеется
(@pxref{Input Methods}).  Если значение @code{input-method-function} равно
не-@code{nil}, это должна быть функция; когда @code{read-event} читает
печатный символ (включая @key{SPC}) без битов модификатора, он вызывает эту
функцию, передавая символ в качестве аргумента.

@defvar input-method-function
Если это не-@code{nil}, его значение определяет функцию текущего метода
ввода.

@strong{Внимание:} не связывать эту переменную с @code{let}.  Часто она
является локальной для буфера, и если привязать её к чтению ввода (а именно
тогда, когда привязывается она к @emph{было бы}), асинхронное переключение
буферов во время ожидания Emacs приведет к восстановлению значения в
не том буфере.
@end defvar

  Функция метода ввода должна возвращать список событий, которые следует
использовать в качестве ввода.  (Если список - @code{nil}, это означает, что
ввода нет, поэтому @code{read-event} ожидает другого события.).  Эти события
обрабатываются до событий в @code{unread-command-events}
(@pxref{Event Input Misc}).  События, возвращаемые функцией метода ввода, не
передаются снова в функцию метода ввода, даже если они печатают символы без
битов модификатора.

  Если функция метода ввода вызывает @code{read-event} или
@code{read-key-sequence}, она должна сначала привязать
@code{input-method-function} к @code{nil}, чтобы предотвратить рекурсию.

  Функция метода ввода не вызывается при чтении второго и последующих
событий ключевой последовательности.  Таким образом, эти символы не подлежат
обработке методом ввода.  Функция метода ввода должна проверять значения
@code{overriding-local-map} и @code{overriding-terminal-local-map}; если
одна из этих переменных - не-@code{nil}, метод ввода должен поместить свой
аргумент в список и вернуть этот список без дальнейшей обработки.

@node Quoted Character Input
@subsection Ввод Символов в Кавычках
@cindex quoted character input

  Можно использовать функцию @code{read-quoted-char}, чтобы попросить
пользователя указать символ и позволить пользователю удобно указать элемент
управления или метасимвол, буквально или как восьмеричный код символа.
Команда @code{quoted-insert} использует эту функцию.

@defun read-quoted-char &optional prompt
@cindex octal character input
@cindex control characters, reading
@cindex nonprinting characters, reading
Эта функция похожа на @code{read-char}, за исключением того, что если первый
прочитанный символ является восьмеричной цифрой (0-7), считывается любое
количество восьмеричных цифр (но останавливается, если найдена не
восьмеричная цифра), и возвращает символ, представленный этот числовой код
символа.  Если символ, завершающий последовательность восьмеричных цифр, -
@key{RET}, он отбрасывается.  Любой другой завершающий символ используется в
качестве входных данных после возврата из этой функции.

Выход подавляется при чтении первого символа, так что пользователь может
ввести @kbd{C-g}.  @xref{Quitting}.

Если указан @var{prompt}, указывается строка для запроса пользователя.
Строка приглашения всегда отображается в эхо-области, за которой следует
один @samp{-}.

В следующем примере пользователь вводит восьмеричное число 177 (то есть 127
в десятичном).

@example
(read-quoted-char "What character")

@group
---------- Echo Area ----------
What character @kbd{1 7 7}-
---------- Echo Area ----------

     @result{} 127
@end group
@end example
@end defun

@need 2000
@node Event Input Misc
@subsection Разные Функции Ввода Событий

В этом разделе описывается, как заглядывать вперед в событиях, не используя
их, как проверять ожидающие входные данные и как отбрасывать ожидающие
входные данные.  Также функцию @code{read-passwd}
(@pxref{Reading a Password}).

@defvar unread-command-events
@cindex next input
@cindex peeking at input
Эта переменная содержит список событий, ожидающих чтения в качестве ввода
команды.  События используются в том порядке, в котором они появляются в
списке, и удаляются одно за другим по мере использования.

Переменная необходима, потому что в некоторых случаях функция считывает
событие, а затем решает не использовать его.  Сохранение события в этой
переменной приводит к его нормальной обработке в цикле команд или функциями
для чтения ввода команды.

@cindex prefix argument unreading
Например, функция, реализующая аргументы числового префикса, считывает любое
количество цифр.  Когда находится нецифровое событие, оно не читается, чтобы
его можно было нормально прочитать в командном цикле.  Точно так же
инкрементный поиск использует эту функцию для непрочитанных событий, не
имеющих особого значения в поиске, потому что эти события должны выйти из
поиска и затем выполняться в обычном режиме.

Надежный и простой способ извлечь события из ключевой последовательности и
поместить их в @code{unread-command-events} - это использовать
@code{listify-key-sequence} (смотреть ниже).

Обычно добавляются события в начало этого списка, так что последние
непрочитанные события будут перечитаны первыми.

События, считываемые из этого списка, обычно не добавляются в
последовательность ключей текущей команды (как возвращается, например,
@code{this-command-keys}), поскольку события уже были добавлены один раз,
поскольку они были прочитаны в первый раз.  Элемент формы
@w{@code{(t . @var{event})}} заставляет @var{event} для добавления к
последовательности ключей текущей команды.
@end defvar

@defun listify-key-sequence key
Эта функция преобразует строку или вектор @var{key} в список отдельных
событий, которые вы можете поместить в @code{unread-command-events}.
@end defun

@defun input-pending-p &optional check-timers
@cindex waiting for command key input
Эта функция определяет, доступен ли в настоящий момент для чтения какой-либо
ввод команды.  Немедленно возвращается со значением @code{t}, если есть
доступный ввод, и @code{nil} в противном случае.  В редких случаях может
возвращать @code{t}, когда ввод недоступен.

Если необязательный аргумент @var{check-timers} равен не-@code{nil}, тогда,
если входные данные недоступны, Emacs запускает любые готовые таймеры.
@xref{Timers}.
@end defun

@defvar last-input-event
Эта переменная записывает последнее событие ввода терминала, прочитанное как
часть команды или явно программой на Lisp.

В приведенном ниже примере программа на Lisp считывает символ @kbd{1},
@acronym{ASCII} с кодом 49.  Это становится значением
@code{last-input-event}, а @kbd{C-e} (предполагается, что для вычисления
этого выражения используется команда @kbd{C-x C-e}) остается значением
@code{last-command-event}.

@example
@group
(progn (print (read-char))
       (print last-command-event)
       last-input-event)
     @print{} 49
     @print{} 5
     @result{} 49
@end group
@end example
@end defvar

@defmac while-no-input body@dots{}
Эта конструкция запускает формы @var{body} и возвращает значение последней,
но только если входных данных не поступает.  Если во время выполнения форм
@var{body} поступает какой-либо ввод, выполнение прерывается (работает так
же, как при выходе).  Форма @code{while-no-input} возвращает @code{nil},
если прервано реальным выходом, и возвращает @code{t}, если прервано
поступлением другого ввода.

Если часть @var{body} связывает @code{inhibit-quit} с не-@code{nil},
поступление ввода во время этих частей не вызовет прерывания до конца этой
части.

Если потребуется иметь возможность различать все возможные значения,
вычисленные @var{body}, от обоих типов условий прерывания, пишется такой
код:

@example
(while-no-input
  (list
    (progn . @var{body})))
@end example
@end defmac

@defvar while-no-input-ignore-events
Эта переменная позволяет установить, какие специальные события
@code{while-no-input} должны игнорироваться.  Это список символов.

@end defvar

@defun discard-input
@cindex flushing input
@cindex discarding input
@cindex keyboard macro, terminating
Эта функция сбрасывает содержимое входного буфера терминала и отменяет любой
макрос клавиатуры, который может находиться в процессе определения.
Возвращает @code{nil}.

В следующем примере пользователь может ввести некоторое количество символов
сразу после начала оценки формы.  После того, как @code{sleep-for} завершает
спящий режим, @code{discard-input} отбрасывает любые символы, введенные во
время сна.

@example
(progn (sleep-for 2)
       (discard-input))
     @result{} nil
@end example
@end defun

@node Special Events
@section Специальные События

@cindex special events
Некоторые @dfn{special events} обрабатываются на очень низком уровне - как
только они прочитаны.  Функция @code{read-event} сама обрабатывает эти
события и никогда их не возвращает.  Вместо этого продолжается ожидание
первого события, которое не является особенным, и возвращает его.

  Специальные события не отражаются, они никогда не группируются в
последовательности ключей и никогда не появляются в значении
@code{last-command-event} или @code{(this-command-keys)}.  Не отбрасывают
числовой аргумент, не могут быть прочитаны с помощью
@code{unread-command-events}, могут не появляться в макросе клавиатуры, и
они не записываются в макрос клавиатуры, пока происходит его определение.

  Однако особые события появляются в @code{last-input-event} сразу после их
чтения, и это способ определения события, чтобы найти фактическое событие.

  Типы событий @code{iconify-frame}, @code{make-frame-visible},
@code{delete-frame}, @code{drag-n-drop}, @code{language-change} и
пользовательские сигналы, такие как @code{sigusr1}, обычно обрабатываются
таким образом.  Карта ключей, которая определяет, как обрабатывать
специальные события --- и какие события являются особенными --- находится в
переменной @code{special-event-map} (@pxref{Active Keymaps}).

@node Waiting
@section Ожидание Истекшего Времени или Ввода
@cindex waiting

  Функции ожидания предназначены для ожидания, пока пройдет определенное
время или пока не будет ввода.  Например, можно сделать паузу в середине
вычисления, чтобы дать пользователю время для просмотра дисплея.
@code{sit-for} приостанавливает и обновляет экран и сразу же возвращается,
если поступает ввод, в то время как @code{sleep-for} приостанавливает работу
без обновления экрана.

@defun sit-for seconds &optional nodisp
Эта функция выполняет повторное отображение (при условии, что пользователь
не ожидает ввода), затем ожидает @var{seconds} секунд или пока ввод не
станет доступен.  Обычная цель @code{sit-for} - дать пользователю время
прочитать отображаемый текст.  Значение @code{t}, если @code{sit-for} ждал
все время без поступления ввода (@pxref{Event Input Misc}).  В противном
случае значение @code{nil}.

Аргумент @var{seconds} не обязательно должен быть целым числом.  Если это
число с плавающей точкой, @code{sit-for} ожидает дробное количество секунд.
Некоторые системы поддерживают только целое количество секунд; в этих
системах @var{seconds} округляется в меньшую сторону.

Выражение @code{(sit-for 0)} эквивалентно @code{(redisplay)}, т.е. оно
запрашивает повторное отображение без какой-либо задержки, если нет
ожидающих ввода.
@xref{Forcing Redisplay}.

Если @var{nodisp} равен не-@code{nil}, то @code{sit-for} не отображает
повторно, но все равно возвращается, как только ввод становится доступным
(или по истечении таймаута).

В пакетном режиме (@pxref{Batch Mode}), @code{sit-for} не может быть
прерван даже при вводе из стандартного дескриптора ввода.  Таким образом, он
эквивалентен @code{sleep-for}, который описан ниже.

Также можно вызвать @code{sit-for} с тремя аргументами как
@code{(sit-for @var{seconds} @var{millisec} @var{nodisp})}, но это считается
устаревшим.
@end defun

@defun sleep-for seconds &optional millisec
Функция просто приостанавливается на @var{seconds} секунд без обновления
дисплея.  Не обращает внимания на доступный ввод.  Возвращает @code{nil}.

Аргумент @var{seconds} не обязательно должен быть целым числом.  Если это
число с плавающей запятой, @code{sleep-for} ожидает дробное количество
секунд.  Некоторые системы поддерживают только целое количество секунд; в
этих системах @var{seconds} округляется в меньшую сторону.

Необязательный аргумент @var{millisec} указывает дополнительный период
ожидания, измеряемый в миллисекундах.  Это добавляет к периоду, указанному
@var{seconds}.  Если система не поддерживает ожидание долей секунды,
получится ошибка, если указано ненулевое значение @var{millisec}.

Используется @code{sleep-for}, если требуется гарантировать задержку.
@end defun

  @xref{Time of Day}, чтобы функции получали текущее время.

@node Quitting
@section Quitting
@cindex @kbd{C-g}
@cindex quitting
@cindex interrupt Lisp functions

  Ввод @kbd{C-g} во время работы функции Lisp заставляет Emacs использовать
@dfn{quit}, что бы тот ни делал.  Это означает, что управление возвращается
к самому внутреннему активному командному циклу.

  Ввод @kbd{C-g} во время ожидания командным циклом ввода с клавиатуры не
вызывает выхода; он действует как обычный вводимый символ.  В простейшем
случае не заметится разницы, потому что @kbd{C-g} обычно запускает команду
@code{keyboard-quit}, которая завершает работу.  Однако, когда @kbd{C-g}
следует за префиксным ключом, они объединяются, образуя неопределенный ключ.
Эффект состоит в том, чтобы отменить ключ префикса, а также любой аргумент
префикса.

  В минибуфере @kbd{C-g} имеет другое определение: он прерывается из
минибуфера.  Фактически это означает, что он выходит из минибуфера, а затем
завершается.  (Простой выход приведет к возврату в командный цикл
@emph{в пределах} минибуфера.)  Причина, по которой @kbd{C-g} не завершается
напрямую, когда средство чтения команд считывает ввод, заключается в том,
что его значение может быть переопределено в минибуфере.  @kbd{C-g},
следующий за префиксным ключом, не переопределяется в минибуфере и имеет
свой обычный эффект отмены префиксного ключа и аргумента префикса.  Это тоже
было бы невозможно, если бы @kbd{C-g} всегда выходил напрямую.

  Когда @kbd{C-g} действительно завершает работу, делается это, устанавкой
для переменной @code{quit-flag} значение @code{t}.  Emacs проверяет эту
переменную в подходящее время и завершает работу, если она не @code{nil}.
Установка @code{quit-flag} не-@code{nil} любым способом вызывает завершение
работы.

  На уровне кода C выход не может произойти где-нибудь; только в специальных
местах, проверяющих @code{quit-flag}.  Причина этого в том, что завершение
работы в других местах может привести к несогласованности во внутреннем
состоянии Emacs.  Поскольку выход откладывается до безопасного места,
завершение не может привести к аварийному завершению работы Emacs.

  Некоторые функции, такие как @code{read-key-sequence} или
@code{read-quoted-char}, полностью предотвращают завершение работы, даже
если они ждут ввода.  Вместо выхода, @kbd{C-g} служит запрошенным вводом.  В
случае @code{read-key-sequence} это служит для вызова особого поведения
@kbd{C-g} в командном цикле.  В случае @code{read-quoted-char} это делается
для того, чтобы @kbd {C-q} можно было использовать для цитирования
@kbd{C-g}.

@cindex preventing quitting
  Можно предотвратить завершение части функции Lisp, привязав переменную
@code{inhibit-quit} к значению не-@code{nil}.  Затем, хотя @kbd{C-g}
по-прежнему устанавливает @code{quit-flag} в @code{t}, как обычно, обычный
результат этого - выход - предотвращается.  В конце концов,
@code{inhibit-quit} снова станет @code{nil}, например, когда его привязка
вычисляется в конце формы @code{let}.  В это время, если @code{quit-flag}
все еще остается не-@code{nil}, запрошенный выход выполняется немедленно.
Такое поведение идеально, если потребуется уверенность, что выход из
критического раздела программы не произойдет.

@cindex @code{read-quoted-char} quitting
  В некоторых функциях (например, @code{read-quoted-char}) @kbd{C-g}
обрабатывается особым образом, не требующим выхода.  Это делается путем
чтения ввода с @code{inhibit-quit}, привязанного к @code{t}, и установки
@code{quit-flag} на @code{nil} до того, как @code{inhibit-quit} снова станет
@code{nil}.  Этот отрывок из определения @code{read-quoted-char} показывает,
как это делается; это также показывает, что нормальный выход разрешен после
первого символа ввода.

@example
(defun read-quoted-char (&optional prompt)
  "@dots{}@var{documentation}@dots{}"
  (let ((message-log-max nil) done (first t) (code 0) char)
    (while (not done)
      (let ((inhibit-quit first)
            @dots{})
        (and prompt (message "%s-" prompt))
        (setq char (read-event))
        (if inhibit-quit (setq quit-flag nil)))
      @r{@dots{}set the variable @code{code}@dots{}})
    code))
@end example

@defvar quit-flag
Если эта переменная - не-@code{nil}, то Emacs немедленно завершает работу,
если @code{inhibit-quit} не является не-@code{nil}.  При вводе @kbd{C-g}
обычно устанавливается @code{quit-flag} не-@code{nil}, независимо от
@code{inhibit-quit}.
@end defvar

@defvar inhibit-quit
Эта переменная определяет, должен ли Emacs завершиться, если
@code{quit-flag} установлен в значение, отличное от @code{nil}.  Если
@code{inhibit-quit} равен не-@code{nil}, то @code{quit-flag} не имеет
особого эффекта.
@end defvar

@defmac with-local-quit body@dots{}
Этот макрос выполняет формы @var{body} последовательно, но позволяет выйти,
по крайней мере локально, в пределах @var{body}, даже если
@code{inhibit-quit} был не-@code{nil} вне этой конструкции.  Возвращает
значение последней формы в @var{body}, если не завершено путем выхода, и в
этом случае возвращается @code{nil}.

Если @code{inhibit-quit} равен @code{nil} при входе в
@code{with-local-quit}, выполняется только @var{body}, а установка
@code{quit-flag} вызывает нормальный выход.  Однако, если
@code{inhibit-quit} - это не-@code{nil}, так что обычный выход
откладывается, не-@code{nil} @code{quit-flag} запускает специальный вид
локального выхода.  Это завершает выполнение @var{body} и выходит из тела
@code{with-local-quit} с @code{quit-flag} по-прежнему не-@code{nil}, так что
другой (обычный) выход произойдет, как только это будет разрешено.  Если
@code{quit-flag} уже является не-@code{nil} в начале @var{body}, локальный
выход происходит немедленно, а тело не выполняется вообще.

Этот макрос в основном полезен в функциях, которые можно вызывать из
таймеров, фильтров процессов, контрольных точек процесса,
@code{pre-command-hook}, @code{post-command-hook} и других мест, где
@code{inhibit-quit} обычно привязан к @code{t}.
@end defmac

@deffn Command keyboard-quit
Функция сигнализирует о состоянии @code{quit} с помощью
@code{(signal 'quit nil)}.  Это то же самое, что и отказ от выхода.
(Смотреть @code{signal} в @ref{Errors}.)
@end deffn

  Можно указать символ, отличный от @kbd{C-g}, который будет использоваться
для выхода.  Смотреть функцию @code{set-input-mode} в @ref{Input Modes}.

@node Prefix Command Arguments
@section Prefix Command Arguments
@cindex prefix argument
@cindex raw prefix argument
@cindex numeric prefix argument

  Большинство команд Emacs могут использовать @dfn{префиксный аргумент} -
число, указанное перед самой командой.  (Не путать префиксные аргументы с
префиксными ключами.)  Префиксный аргумент всегда представлен значением,
которое может быть @code{nil}, что означает, что префиксный аргумент
отсутствует.  Каждая команда может использовать префиксный аргумент или
игнорировать его.

  Есть два представления префиксного аргумента: @dfn{raw} и @dfn{numeric}.
Командный цикл редактора использует внутреннее необработанное представление,
как и переменные Lisp, хранящие информацию, команды могут запрашивать любое
представление.

  Вот возможные значения необработанного префиксного аргумента:

@itemize @bullet
@item
@code{nil}, что означает отсутствие префиксного аргумента.  Его числовое
значение равно 1 ,но многие команды различают @code{nil} и целое число 1.

@item
Целое число, обозначающее само себя.

@item
Список из одного элемента, который является целым числом.  Эта форма
префиксного аргумента является результатом одного или нескольких @kbd{C-u}
без цифр.  Числовое значение - это целое число в списке, но некоторые
команды определяют различие между таким списком и одним целым числом.

@item
Символ @code{-}.  Это означает, что набран @kbd{M--} или @kbd{C-u -}, без
следующих цифр.  Эквивалентное числовое значение - @minus{}1, но некоторые
команды делают различие между целым числом @minus{}1 и символом @code{-}.
@end itemize

Проиллюстрируем эти возможности, вызвав следующую функцию с различными
префиксами:

@example
@group
(defun display-prefix (arg)
  "Показать значение необработанного префикса arg."
  (interactive "P")
  (message "%s" arg))
@end group
@end example

@noindent
Вот результаты вызова @code{display-prefix} с различными необработанными
префиксными аргументами:

@example
        M-x display-prefix  @print{} nil

C-u     M-x display-prefix  @print{} (4)

C-u C-u M-x display-prefix  @print{} (16)

C-u 3   M-x display-prefix  @print{} 3

M-3     M-x display-prefix  @print{} 3      ; @r{(То же как @code{C-u 3}.)}

C-u -   M-x display-prefix  @print{} -

M--     M-x display-prefix  @print{} -      ; @r{(То же как @code{C-u -}.)}

C-u - 7 M-x display-prefix  @print{} -7

M-- 7   M-x display-prefix  @print{} -7     ; @r{(То же как @code{C-u -7}.)}
@end example

  Emacs использует две переменные для хранения префиксного аргумента:
@code{prefix-arg} и @code{current-prefix-arg}.  Такие команды, как
@code{universal-argument}, которые задают префиксные аргументы для других
команд, сохраняют их в @code{prefix-arg}.  Напротив,
@code{current-prefix-arg} передает префиксный аргумент текущей команде,
поэтому его установка не влияет на аргументы префикса для будущих команд.

  Обычно команды указывают, какое представление использовать для префиксного
аргумента, числовое или необработанное, в спецификации @code{interactive}.
(@xref{Using Interactive}.)  В качестве альтернативы функции могут смотреть
на значение префиксного аргумента непосредственно в переменной
@code{current-prefix-arg}, но это менее чисто.

@defun prefix-numeric-value arg
Функция возвращает числовое значение допустимого необработанного значения
префиксного аргумента @var{arg}.  Аргументом может быть символ, число или
список.  Если это @code{nil}, возвращается значение 1; если @code{-},
возвращается значение @minus{}1; если это число, возвращается это число;
если это список, возвращается @sc{car} этого списка (который должен быть
числом).
@end defun

@defvar current-prefix-arg
Эта переменная содержит неабработанный аргумент префикса для @emph{текущей}
команды.  Команды могут проверять его напрямую, но обычно для доступа к нему
используется @code{(interactive "P")}.
@end defvar

@defvar prefix-arg
Значение этой переменной является необработанным префиксным аргументом для
@emph{следующей} команды редактирования .  Такие команды, как
@code{universal-argument}, которые задают префиксный аргумент для следующей
команды, работают, устанавливая эту переменную.
@end defvar

@defvar last-prefix-arg
Необработанное значение префиксного аргумента, использованное предыдущей
командой.
@end defvar

  Следующие команды существуют для установки префиксных аргументов
относительно следующей команды.  Не вызывать их по какой-либо другой
причине.

@deffn Command universal-argument
Команда считывает ввод и указывает префиксный аргумент для следующей
команды.  Не вызывать эту команду самостоятельно, если не знать, что
происходит.
@end deffn

@deffn Command digit-argument arg
Команда добавляет префиксный аргумент относительно следующей команды.
Аргумент @var{arg} - это необработанный префиксный аргумент, который был до
этой команды; он используется для вычисления обновленного префиксного
аргумента.  Не вызывать эту команду самостоятельно, если не знаеть, что
происходит.
@end deffn

@deffn Command negative-argument arg
Команда добавляет числовой аргумент следующей команды.  Аргумент @var{arg} -
это необработанный префиксный аргумент, который был до этой команды; его
значение инвертируется, чтобы сформировать новый префиксный аргумент.  Не
вызывать эту команду самостоятельно, если не знаеть, что происходит.
@end deffn

@node Recursive Editing
@section Рекурсивное Редактирование
@cindex recursive command loop
@cindex recursive editing level
@cindex command loop, recursive

  Командный цикл Emacs запускается автоматически при запуске Emacs.  Этот
вызов командного цикла верхнего уровня никогда не завершается; он продолжает
работать, пока работает Emacs.  Программы Lisp также могут вызывать
командный цикл.  Поскольку это вызывает более одной активации командного
цикла, называется он @dfn{рекурсивное редактирование}.  Уровень рекурсивного
редактирования приостанавливает действие любой вызвавшей его команды и
позволяет пользователю выполнять произвольное редактирование перед
возобновлением этой команды.

  Команды, доступные во время рекурсивного редактирования, аналогичны
командам, доступным в цикле редактирования верхнего уровня и определенным в
ключевых картах.  Только несколько специальных команд выходят из уровня
рекурсивного редактирования; остальные возвращаются на уровень рекурсивного
редактирования по завершении.  (Специальные команды для выхода всегда
доступны, но они ничего не делают, когда рекурсивное редактирование не
выполняется.)

  Во всех командных циклах, включая рекурсивные, настраиваются универсальные
обработчики ошибок, так что ошибка в команде, запущенной из командного
цикла, не приведет к выходу из цикла.

@cindex minibuffer input
  Ввод в минибуфер - это особый вид рекурсивного редактирования.  У него
есть несколько особых недостатков, таких как включение отображения
минибуфера и окна минибуфера, но их меньше, чем можно предположить.
Некоторые ключи ведут себя в минибуфере по-разному, но это только из-за
локальной карты минибуфера; если переключать окна, получатся обычные команды
Emacs.

@cindex @code{throw} example
@kindex exit
@cindex exit recursive editing
@cindex aborting
  Чтобы вызвать уровень рекурсивного редактирования, вызывается функция
@code{recursive-edit}.  Эта функция содержит командный цикл; также содержит
вызов @code{catch} с тегом @code{exit}, который позволяет выйти из уровня
рекурсивного редактирования путем перехода к @code{exit}
(@pxref{Catch and Throw}).  Если выберается значение, отличное от @code{t},
то @code{recursive-edit} нормально вернется к функции, которая его вызвала.
Это делает команда @kbd{C-M-c} (@code{exit-recursive-edit}).  Выбор значения
@code{t} приводит к завершению работы @code{recursive-edit}, так что
управление возвращается в командный цикл на один уровень выше.  Это
называется @dfn{aborting} и выполняется с помощью @kbd{C-]}
(@code{abort-recursive-edit}).

  Большинство приложений не должны использовать рекурсивное редактирование,
кроме как в рамках использования минибуфера.  Обычно для пользователя более
удобно, если временно изменяется основной режим текущего буфера на
специальный основной режим, который должен иметь команду для возврата в
предыдущий режим.  (Команда @kbd{e} в Rmail использует эту технику.)  Или,
если потребуется дать пользователю другой текст для рекурсивного
редактирования, создается и выбирается новый буфер в специальном режиме.  В
этом режиме определяется команда для завершения обработки и возврата к
предыдущему буферу.  (Это делает команда @kbd{m} в Rmail.)

  Рекурсивные правки полезны при отладке.  Можно вставить вызов @code{debug}
в определение функции как своего рода точку останова, чтобы иметь
возможность осмотреться, когда функция попадает туда.  @code{debug} вызывает
рекурсивное редактирование, но также предоставляет другие функции отладчика.

  Уровни рекурсивного редактирования также используются, когда вводится
@kbd{C-r} в @code{query-replace} или используется @kbd{C-x q}
(@code{kbd-macro-query}).

@deffn Command recursive-edit
@cindex suspend evaluation
Эта функция вызывает цикл команд редактора.  Вызывается автоматически при
инициализации Emacs, чтобы пользователь мог начать редактирование.  При
вызове из программы на Lisp переходит на уровень рекурсивного
редактирования.

Если текущий буфер не совпадает с буфером выбранного окна,
@code{recursive-edit} сохраняет и восстанавливает текущий буфер.  В
противном случае, если переключить буферы, буфер, на который переключились,
будет текущим после возврата @code{recursive-edit}.

В следующем примере функция @code{simple-rec} сначала перемещает точку на
одно слово, затем переходит в рекурсивное редактирование, распечатывая
сообщение в эхо-области.  Затем пользователь может выполнить любое желаемое
редактирование, а затем ввести @kbd{C-M-c}, чтобы выйти и продолжить
выполнение @code{simple-rec}.

@example
(defun simple-rec ()
  (forward-word 1)
  (message "Выполняется рекурсивное редактирование")
  (recursive-edit)
  (forward-word 1))
     @result{} simple-rec
(simple-rec)
     @result{} nil
@end example
@end deffn

@deffn Command exit-recursive-edit
Функция выходит из самого внутреннего рекурсивного редактирования
(включая ввод минибуфера).  Её определение эффективно
@code{(throw 'exit nil)}.
@end deffn

@deffn Command abort-recursive-edit
Функция прерывает команду, которая запросила самое внутреннее рекурсивное
редактирование (включая ввод минибуфера), сигнализируя @code{quit} после
выхода из рекурсивного редактирования.  Её определение эффективно
@code{(throw 'exit t)}.  @xref{Quitting}.
@end deffn

@deffn Command top-level
Функция выходит из всех уровней рекурсивного редактирования; не возвращает
значение, так как полностью переходит из любого вычисления прямо обратно в
основной командный цикл.
@end deffn

@defun recursion-depth
Функция возвращает текущую глубину рекурсивного редактирования.  Если
рекурсивное редактирование не активно, возвращается 0.
@end defun

@node Disabling Commands
@section Отключение Команд
@cindex disabled command

  @dfn{Отключение Команд} отмечает команду как требующую подтверждения
пользователя перед выполнением.  Отключение используется для команд, которые
могут сбить с толку начинающих пользователей, чтобы предотвратить их
случайное использование команд.

@kindex disabled
  Низкоуровневый механизм отключения команды состоит в том, чтобы поместить
свойство не-@code{nil} @code{disabled} в символ Lisp для команды.  Эти
свойства обычно устанавливаются пользовательским файлом инициализации
(@pxref{Init File}) с выражениями Lisp, такими как это:

@example
(put 'upcase-region 'disabled t)
@end example

@noindent
Для некоторых команд эти свойства присутствуют по умолчанию (при желании их
можно удалить в файле инициализации).

  Если значение свойства @code{disabled} является строкой, сообщение о том,
что команда отключена и включает эту строку. Например:

@example
(put 'delete-region 'disabled
     "Текст, удаленный таким образом, нельзя вернуть!\n")
@end example

  @xref{Disabling,,, emacs, The GNU Emacs Manual}, для получения подробной
информации о том, что происходит при интерактивном вызове отключенной
команды.  Отключение команды не влияет на ее вызов как функцию из программ
на Lisp.

@deffn Command enable-command command
С этого момента разрешается выполнение @var{command} (символа) без
специального подтверждения и потребуется изменить файл инициализации
пользователя (@pxref{Init File}) так, чтобы это применимо к будущим сеансам.
@end deffn

@deffn Command disable-command command
Требовать специального подтверждения для выполнения @var{command} с этого
момента и потребуется изменить файл инициализации пользователя, чтобы это
применимо к будущим сеансам.
@end deffn

@defvar disabled-command-function
Значение этой переменной должно быть функцией.  Когда пользователь в
интерактивном режиме вызывает отключенную команду, эта функция вызывается
вместо отключенной команды.  Может использовать @code{this-command-keys},
чтобы определить, что пользователь ввел для выполнения команды, и таким
образом найти саму команду.

Значение также может быть @code{nil}.  Тогда все команды работают нормально,
даже отключенные.

По умолчанию значение - это функция, которая спрашивает пользователя,
следует ли продолжить.
@end defvar

@node Command History
@section История Команд
@cindex command history
@cindex complex command
@cindex history of commands

  Командный цикл хранит историю сложных команд, которые были выполнены,
чтобы было удобно повторять эти команды.  @dfn{сложная команда} - это то,
для чего интерактивное чтение аргументов использует минибуфер.  Это включает
любую команду @kbd{M-x}, любую команду @kbd{M-:} и любую команду,
спецификация @code{interactive} которой считывает аргумент из минибуфера.
Явное использование минибуфера во время выполнения самой команды не
приводит к тому, что команда считается сложной.

@defvar command-history
Значение этой переменной представляет собой список последних сложных команд,
каждая из которых представлена в виде формы для оценки.  Она продолжает
накапливать все сложные команды в течение сеанса редактирования, но когда
достигает максимального размера (@pxref{Minibuffer History}), самые старые
элементы удаляются по мере добавления новых.

@example
@group
command-history
@result{} ((switch-to-buffer "chistory.texi")
    (describe-key "^X^[")
    (visit-tags-table "~/emacs/src/")
    (find-tag "repeat-complex-command"))
@end group
@end example
@end defvar

  Этот список истории на самом деле является частным случаем истории
минибуфера (@pxref{Minibuffer History}) с одной особенной особенностью:
элементы являются выражениями, а не строками.

  Существует ряд команд, предназначенных для редактирования и вызова
предыдущих команд.  Команды @code{repeat-complex-command} и
@code{list-command-history} описаны в руководстве пользователя
(@pxref{Repetition,,, emacs, The GNU Emacs Manual}).  В минибуфере доступны
обычные команды истории минибуфера.

@node Keyboard Macros
@section Клавиатурные Макросы
@cindex keyboard macros

  @dfn{Клавиатурные макросы} - это стандартная последовательность событий
ввода, которую можно рассматривать как команду и определяющую ключ.
Lisp-представление макроса клавиатуры - это строка или вектор, содержащий
события.  Не путать макросы клавиатуры с макросами Lisp (@pxref{Macros}).

@defun execute-kbd-macro kbdmacro &optional count loopfunc
Функция выполняет @var{kbdmacro} как последовательность событий.  Если
@var{kbdmacro} - строка или вектор, то события в нем выполняются точно так
же, как если бы они были введены пользователем.  Предполагается, что
последовательность @emph{не} будет одной ключевой последовательностью;
обычно определение макроса клавиатуры состоит из нескольких сцепленных
последовательностей ключей.

Если @var{kbdmacro} - это символ, то вместо @var{kbdmacro} используется
определение его функции.  Если это другой символ, этот процесс повторяется.
В конечном итоге результатом должна быть строка или вектор.  Если результат
не является символом, строкой или вектором, выдается сигнал об ошибке.

Аргумент @var{count} - это счетчик повторов; @var{kbdmacro} выполняется
столько раз.  Если @var{count} не указан или @code{nil}, @var{kbdmacro}
выполняется один раз.  Если равен 0, @var{kbdmacro} выполняется снова и
снова, пока не обнаружит ошибку или неудачный поиск.

Если @var{loopfunc} равен не-@code{nil}, это функция, которая вызывается без
аргументов перед каждой итерацией макроса.  Если @var{loopfunc} возвращает
@code{nil}, то выполнение макроса останавливается.

@xref{Reading One Event}, для примера использования
@code{execute-kbd-macro}.
@end defun

@defvar executing-kbd-macro
Эта переменная содержит строку или вектор, определяющий макрос клавиатуры,
который выполняется в данный момент.  Это @code{nil}, если в данный момент
макрос не выполняется.  Команда может тестировать эту переменную, чтобы
вести себя по-другому при запуске из исполняемого макроса.  Не
устанавливайте эту переменную самостоятельно.
@end defvar

@defvar defining-kbd-macro
Эта переменная имеет значение не-@code{nil} тогда и только тогда, когда
определяется макрос клавиатуры.  Команда может проверить эту переменную,
чтобы вести себя по-другому во время определения макроса.  Значение
@code{append} добавляется к определению существующего макроса.  Команды
@code{start-kbd-macro}, @code{kmacro-start-macro} и @code{end-kbd-macro}
устанавливают эту переменную --- не устанавливать ее самостоятельно.

Переменная всегда является локальной для текущего терминала и не может быть
локальной для буфера.  @xref{Multiple Terminals}.
@end defvar

@defvar last-kbd-macro
Переменная является определением последнего определенного макроса
клавиатуры.  Её значение - строка или вектор, или @code{nil}.

Переменная всегда локальна для текущего терминала и не может быть локальной
для буфера.  @xref{Multiple Terminals}.
@end defvar

@defvar kbd-macro-termination-hook
Этот обычный обработчик запускается, когда макрос клавиатуры завершается,
независимо от того, что вызвало его завершение (достижение конца макроса или
ошибка, которая преждевременно завершила макрос).
@end defvar
