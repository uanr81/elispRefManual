@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1994, 1998-1999, 2001-2019 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Debugging
@chapter Отладка Программ на Lisp
@cindex debugging lisp programs

  Есть несколько способов найти и исследовать проблемы в программе Emacs
Lisp.

@itemize @bullet
@item
Если проблема возникает при запуске программы, можно использовать встроенный
отладчик Emacs Lisp, чтобы приостановить анализатор Lisp и проверить и/или
изменить его внутреннее состояние.

@item
Можно использовать Edebug, отладчик исходного уровня Emacs Lisp.

@item
@cindex tracing Lisp programs
Можно отслеживать выполнение функций, связанных с проблемой, используя
средства трассировки, предоставляемые пакетом @file{trace.el}.  Этот пакет
предоставляет функции @code{trace-function-foreground} и
@code{trace-function-background} для отслеживания вызовов функций и
@code{trace-values} для добавления значений выбранных переменных к
трассировке.  Подробнее смотреть документацию к этим объектам в
@file{trace.el}.

@item
Если синтаксическая проблема мешает Lisp даже прочитать программу, можно
найти ее с помощью команд редактирования Lisp.

@item
Можно просмотреть сообщения об ошибках и предупреждения, создаваемые байт
компилятором при компиляции программы.  @xref{Compiler Errors}.

@item
Можно использовать пакет Testcover для тестирования покрытия программы.

@item
Можно использовать пакет ERT для написания регрессионных тестов к программе.
@xref{Top,the ERT manual,, ert, ERT: Emacs Lisp Regression Testing}.

@item
Можно профилировать программу, чтобы получить подсказки о том, как сделать
ее более эффективной.
@end itemize

  Другими полезными инструментами для отладки проблем ввода и вывода
являются файл dribble (@pxref{Terminal Input}) и функция
@code{open-termscript} (@pxref{Terminal Output}).

@menu
* Debugger::            Отладчик для оценщика Emacs Lisp.
* Edebug::              Отладчик Emacs Lisp на уровне исходного кода.
* Syntax Errors::       Как найти синтаксические ошибки.
* Test Coverage::       Убедится, что протестированы все ветки кода.
* Profiling::           Измерение ресурсов, которые использует ваш код.
@end menu

@node Debugger
@section The Lisp Debugger
@cindex debugger for Emacs Lisp
@cindex Lisp debugger
@cindex break

  Обычный @dfn{Lisp отладчик} дает возможность приостановить оценку формы.
Пока оценка приостановлена (состояние, обычно известное как @dfn{останов}),
можно проверить стек времени выполнения, проверить значения локальных или
глобальных переменных или изменить эти значения.  Поскольку разрыв - это
рекурсивное редактирование, доступны все обычные средства редактирования
Emacs; можно запускать программы, которые будут входить в отладчик
рекурсивно.  @xref{Recursive Editing}.

@menu
* Error Debugging::       Вход в отладчик при возникновении ошибки.
* Infinite Loops::        Остановка и отладка программы, которая не завершается.
* Function Debugging::    Вход в отладчик при вызове определенной функции.
* Variable Debugging::    Вход в отладчик при изменении переменной.
* Explicit Debug::        Вход в отладчик в определенный момент в программе.
* Using Debugger::        Что делает отладчик; что видно в нём.
* Debugger Commands::     Команды, используемые в отладчике.
* Invoking the Debugger:: Как вызвать функцию @code{debug}.
* Internals of Debugger:: Подпрограммы отладчика и глобальные переменные.
@end menu

@node Error Debugging
@subsection Entering the Debugger on an Error
@cindex error debugging
@cindex debugging errors

  Самый важный момент для входа в отладчик - это когда происходит ошибка
Lisp.  Это позволяет исследовать непосредственные причины ошибки.

  Однако вход в отладчик не является нормальным следствием ошибки.  Многие
команды сигнализируют об ошибках Lisp при неправильном вызове, и во время
обычного редактирования было бы очень неудобно заходить в отладчик каждый
раз, когда это происходит.  Поэтому, если потребуется, чтобы ошибки
поступали в отладчик, установите для переменной @code{debug-on-error}
значение не-@code{nil}.  (Команда @code{toggle-debug-on-error} предоставляет
простой способ сделать это.)

@defopt debug-on-error
Эта переменная определяет, вызывается ли отладчик, когда сообщается об
ошибке, но не обрабатывается.  Если @code{debug-on-error} равен @code{t},
отладчик вызывает все виды ошибок, кроме тех, которые перечислены в
@code{debug-ignored-errors} (смотреть ниже).  Если установлено в @code{nil},
ничто не вызывает отладчик.

Значение также может быть списком условий ошибки (@pxref{Signaling Errors}).
Затем отладчик вызывается только для условий ошибки присутствующей в этом
списке (кроме тех, которые также перечислены в @code{debug-ignored-errors}).
Например, если установить @code{debug-on-error} в список
@code{(void-variable)}, отладчик будет вызываться только для ошибок,
связанных с переменной, которая не имеет значения.

Обратите внимание, что @code{eval-expression-debug-on-error} в некоторых
случаях переопределяет эту переменную; смотреть ниже.

Когда эта переменная - не-@code{nil}, Emacs не создает обработчик ошибок для
функций фильтрации процессов и сигнальных индикаторов.  Следовательно,
ошибки в этих функциях также вызывают отладчик.  @xref{Processes}.
@end defopt

@defopt debug-ignored-errors
Эта переменная определяет ошибки, которые не должны поступать в отладчик, не
зависимо от значения @code{debug-on-error}.  Её значение - это список
символов условий ошибки и/или регулярных выражений.  Если в ошибке
присутствует какой-либо из этих условных символов или если сообщение об
ошибке соответствует любому из регулярных выражений, то эта ошибка не
поступает в отладчик.

Нормальное значение этой переменной включает @code{user-error}, а также
несколько ошибок, которые часто случаются во время редактирования, но редко
являются результатом ошибок в программах на Lisp.  Однако ``rarely (редко)''
не ``never (никогда)''; если программа выдает ошибку, соответствующую этому
списку, можно попробовать изменить этот список, чтобы отладить ошибку.
Самый простой способ - установить @code{debug-ignored-errors} в @code{nil}.
@end defopt

@defopt eval-expression-debug-on-error
Если эта переменная имеет значение не-@code{nil} (по умолчанию), запуск
команды @code{eval-expression} приводит к временной привязке
@code{debug-on-error} к @code{t}.  @xref{Lisp Eval,, Evaluating Emacs-Lisp Expressions, emacs, The GNU Emacs Manual}.

Если @code{eval-expression-debug-on-error} равен @code{nil}, то значение
@code{debug-on-error} не изменяется во время @code{eval-expression}.
@end defopt

@defopt debug-on-signal
Обычно ошибки, обнаруженные @code{condition-case}, никогда не вызывают
отладчик.  @code{condition-case} получает шанс обработать ошибку до того,
как отладчик получит шанс.

Если изменить @code{debug-on-signal} на значение не-@code{nil}, отладчик
получит первую возможность при каждой ошибке, независимо от наличия
@code{condition-case}.  (Чтобы вызвать отладчик, ошибка должна
соответствовать критериям, указанным в @code{debug-on-error} и
@code{debug-ignored-errors}.)

@cindex emacsclient, getting a backtrace
@cindex backtrace from emacsclient's @option{--eval}
Например, установка этой переменной полезна для получения трассировки кода,
оцениваемого опцией emacsclient @option{--eval}.  Если код Lisp, оцениваемый
emacsclient, сигнализирует об ошибке, когда эта переменная имеет значение
не-@code{nil}, трассировка откроется в работающем Emacs.

@strong{Внимание:} Установка этой переменной в не-@code{nil} может иметь
раздражающие эффекты.  Различные части Emacs улавливают ошибки в обычном
порядке, и можно даже не осознавать, что ошибки там происходят.  Если нужно
отладить код, заключенный в @code{condition-case}, рассмотрите возможность
использования @code{condition-case-unless-debug} (@pxref{Handling Errors}).
@end defopt

@defopt debug-on-event
Если установить @code{debug-on-event} для специального события
(@pxref{Special Events}), Emacs попытается войти в отладчик, как только
получит это событие, минуя @code{special-event-map}.  В настоящее время
только поддерживаемые значения соответствуют сигналам @code{SIGUSR1} и
@code{SIGUSR2} (это значение по умолчанию).  Это может быть полезно, когда
установлен @code{inhibit-quit}, а Emacs не отвечает иначе.
@end defopt

@cindex message, finding what causes a particular message
@defvar debug-on-message
Если установить для @code{debug-on-message} регулярное выражение, Emacs
войдет в отладчик, если отобразит соответствующее сообщение в эхо-области.
Например, это может быть полезно при попытке найти причину того или иного
сообщения.
@end defvar

  Чтобы отладить ошибку, возникающую при загрузке файла инициализации,
используйте параметр @samp{--debug-init}.  Это связывает
@code{debug-on-error} с @code{t} при загрузке файла инициализации и
обходит @code{condition-case}, который обычно обнаруживает ошибки в файле
инициализации.

@node Infinite Loops
@subsection Отладка Бесконечных Циклов
@cindex infinite loops
@cindex loops, infinite
@cindex quitting from infinite loop
@cindex stopping an infinite loop

  Когда программа зацикливается бесконечно и не может вернуться, первая
проблема - остановить цикл.  В большинстве операционных систем это можно
сделать с помощью @kbd{C-g}, который вызывает @dfn{quit}.  @xref{Quitting}.

  Обычный выход не дает информации о том, почему программа зацикливалась.
Для получения дополнительной информации можно установить для переменной
@code{debug-on-quit} значение не-@code{nil}.  После того, как отладчик
запущен в середине бесконечного цикла, можно продолжить работу с отладчиком,
используя пошаговые команды.  Если пройти весь цикл, можно получить
достаточно информации для решения проблемы.

  Выход с помощью @kbd{C-g} не считается ошибкой, а @code{debug-on-error}
не влияет на обработку @kbd{C-g}.  Точно так же @code{debug-on-quit} не
влияет на ошибки.

@defopt debug-on-quit
Эта переменная определяет, вызывается ли отладчик, когда @code{quit}
сигнализируется и не обрабатывается.  Если @code{debug-on-quit} равен
не-@code{nil}, то отладчик вызывается при выходе (то есть при вводе
@kbd{C-g}).  Если @code{debug-on-quit} - @code{nil} (по умолчанию),
отладчик не вызывается при выходе.
@end defopt

@node Function Debugging
@subsection Вход в Отладчик при Вызове Функции
@cindex function call debugging
@cindex debugging specific functions

  Чтобы исследовать проблему, которая возникает в середине программы, можно
использовать один из полезных приемов - входить в отладчик при каждом вызове
определенной функции.  Можно сделать это с функцией, в которой возникает
проблема, а затем выполнить пошаговое выполнение функции, или можно сделать
это с функцией, вызываемой незадолго до возникновения проблемы, быстро
перешагнуть через вызов этой функции, а затем пройти через ее вызывающего.

@deffn Command debug-on-entry function-name
Эта функция запрашивает @var{function-name} для вызова отладчика при каждом
её вызове.

Любая функция или макрос, определенные как код Lisp, могут быть установлены
на прерывание при входе, независимо от того, является ли это
интерпретируемым кодом или скомпилированным кодом.  Если функция является
командой, она войдет в отладчик при вызове из Lisp и при интерактивном
вызове (после чтения аргументов).  Также можно установить отладку при входе
для примитивных функций (то есть написанных на C) таким образом, но это
вступит в силу только тогда, когда примитив вызывается из кода Lisp.
Отладка при входе не допускается для специальных форм.

Когда @code{debug-on-entry} вызывается в интерактивном режиме, он
запрашивает @var{function-name} в минибуфере.  Если функция уже настроена
для вызова отладчика при входе, @code{debug-on-entry} ничего не делает.
@code{debug-on-entry} всегда возвращает @var{function-name}.

Вот пример, иллюстрирующий использование этой функции:

@example
@group
(defun fact (n)
  (if (zerop n) 1
      (* n (fact (1- n)))))
     @result{} fact
@end group
@group
(debug-on-entry 'fact)
     @result{} fact
@end group
@group
(fact 3)
@end group

@group
------ Buffer: *Backtrace* ------
Debugger entered--entering a function:
* fact(3)
  eval((fact 3))
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp)
------ Buffer: *Backtrace* ------
@end group

@end example
@end deffn

@deffn Command cancel-debug-on-entry &optional function-name
Эта функция отменяет эффект @code{debug-on-entry} на @var{function-name}.
При интерактивном вызове запрашивает в минибуфере @var{function-name}.  Если
@var{function-name} опущено или @code{nil}, он отменяет прерывание при входе
для всех функций.  Вызов @code{cancel-debug-on-entry} ничего не делает для
функции, которая в настоящее время не настроена на прерывание при входе.
@end deffn

@node Variable Debugging
@subsection Вход в Отладчик при Изменении Переменной
@cindex variable write debugging
@cindex debugging changes to variables

Иногда проблема с функцией возникает из-за неправильной установки
переменной.  Настройка отладчика для срабатывания при изменении переменной -
это быстрый способ найти источник настройки.

@deffn Command debug-on-variable-change variable
Эта функция организует вызов отладчика при изменении @var{variable}.

Она реализована с использованием механизма точки наблюдения, поэтому она
наследует те же характеристики и ограничения: все псевдонимы @var{variable}
будут отслеживаться вместе, могут наблюдаться только динамические
переменные, и изменения в объектах, на которые ссылаются переменные, не
обнаруживаются.  Подробности, смотреть @ref{Watching Variables}.
@end deffn

@deffn Command cancel-debug-on-variable-change &optional variable
Эта функция отменяет эффект @code{debug-on-variable-change} на
@var{variable}.  При интерактивном вызове запрашивает в минибуфере
@var{variable}.  Если параметр @var{variable} или @code{nil} опущен,
прерывание при замене отменяется для всех переменных.  Вызов
@code{cancel-debug-on-variable-change} ничего не делает с переменной,
которая в настоящее время не настроена на прерывание при изменении.
@end deffn


@node Explicit Debug
@subsection Явный Вход в Отладчик
@cindex debugger, explicit entry
@cindex force entry to debugger

@cindex @code{eval-defun}, and explicit entry to debugger
  Можно вызвать отладчик в определенной точке вашей программы, написав в
этой точке выражение @code{(debug)}.  Для этого зайдите в исходный файл,
вставьте текст @samp{(debug)} в нужное место и введите @kbd{C-M-x}
(@code{eval-defun}, привязка ключа режима Lisp).  @strong{Внимание:}, если
сделать это для временной отладки, обязательно отмените эту вставку перед
сохранением файла!

  Место, куда вставляется @samp{(debug)}, должно быть местом, где можно
оценивать дополнительную форму и игнорировать ее значение.  (Если значение
@code{(debug)} не игнорируется, это изменит выполнение программы!).
Наиболее часто подходящие места находятся внутри @code{progn} или неявного
@code{progn}.  (@pxref{Sequencing}).

  Если знаеть точно, где в исходном коде требуется поместить оператор
отладки, но нужно отображать обратную трассировку при отображении
определенного сообщения, можно установить @code{debug-on-message} на
регулярное выражение, соответствующее желаемому сообщению.

@node Using Debugger
@subsection Использование Отладчика

  При входе в отладчик он отображает ранее выбранный буфер в одном окне и
буфер с именем @file{*Backtrace*} в другом окне.  Буфер обратной трассировки
содержит по одной строке для каждого уровня выполнения функции Lisp, которая
отрабатывает в данный момент.  В начале этого буфера находится сообщение,
описывающее причину вызова отладчика (например, сообщение об ошибке и
связанные данные, если он был вызван из-за ошибки).

@vindex debugger-bury-or-kill
  Буфер обратной трассировки доступен только для чтения и использует
специальный основной режим, режим отладчика, в котором буквы определяются
как команды отладчика.  Доступны обычные команды редактирования Emacs; таким
образом, можно переключать окна, чтобы исследовать буфер, который
редактировался во время ошибки, переключать буферы, посещать файлы или
выполнять любые другие виды редактирования.  Однако отладчик - это
рекурсивный уровень редактирования (@pxref{Recursive Editing}), и разумно
вернуться в буфер обратной трассировки и выйти из отладчика (с помощью
команды @kbd{q}), когда закончите работу с ним.  При выходе из отладчика
происходит выход из рекурсивного редактирования и прячется буфер обратной
трассировки.  (Можно настроить, что команда @kbd{q} делает с буфером
обратной трассировки, установив переменную @code{debugger-bury-or-kill}.
Например, установите для нее значение @code{kill}, если предпочитается
уничтожить буфер, а не спрятать его.  Дополнительные возможности смотреть в
документации по переменной.)

  После входа в отладчик переменная @code{debug-on-error} временно
устанавливается в соответствии с @code{eval-expression-debug-on-error}.
Если последняя переменная - не-@code{nil}, @code{debug-on-error}, будет
временно установлено в значение @code{t}.  Это означает, что любые
дальнейшие ошибки, возникающие при выполнении сеанса отладки, вызовут (по
умолчанию) другую обратную трассировку.  Если это не то, что требуется,
можно установить @code{eval-expression-debug-on-error} в @code{nil} или
@code{debug-on-error} в @code{nil} в @code{debugger-mode-hook}.

@cindex current stack frame
  Буфер трассировки показывает выполняемые функции и значения их аргументов.
Также позволяет указать кадр стека, перемещая точку на строку, описывающую
этот кадр.  (Фрейм стека - это место, где интерпретатор Lisp записывает
информацию о конкретном вызове функции.)  Фрейм, на котором находится точка
строки, считается @dfn{current frame (текущий фрейм)}.  Некоторые команды
отладчика работают с текущим фреймом.  Если строка начинается со звездочки,
это означает, что выход из этого фрейма снова вызовет отладчик.  Это полезно
для проверки возвращаемого значения функции.

  Если имя функции подчеркнуто, это означает, что отладчик знает, где
находится ее исходный код.  Можно щелкнуть мышью по этому имени или перейти
к нему и ввести @key{RET}, чтобы просмотреть исходный код.

  Сам отладчик должен быть скомпилирован побайтно, поскольку он делает
предположения о том, сколько кадров стека используется для самого отладчика.
Эти предположения неверны, если отладчик работает в интерпретации.

@node Debugger Commands
@subsection Команды Отладчика
@cindex debugger command list

  Буфер отладчика (в режиме отладчика) предоставляет специальные команды в
дополнение к обычным командам Emacs.  Наиболее важное использование команд
отладчика - пошаговое выполнение кода, чтобы видеть, как проходит
управление.  Отладчик может проходить через управляющие структуры
интерпретируемой функции, но не может этого делать в функции с байт
компиляцией.  Если требуется пройти через байт скомпилированную функцию,
замените ее интерпретированным определением той же функции.  (Для этого
посетите источник функции и введите @kbd{C-M-x} в ее определении.)  Нельзя
использовать отладчик Lisp для пошагового выполнения примитивной функции.

@c FIXME: Добавить @findex для следующих команд?  --xfq
  Вот список команд режима отладчика:

@table @kbd
@item c
Выйти из отладчика и продолжить выполнение.  Это возобновляет выполнение
программы, как если бы отладчик никогда не запускался (кроме любых побочных
эффектов, вызванных изменением значений переменных или структур данных в
отладчике).

@item d
Продолжить выполнение, но войти в отладчик при следующем вызове любой
функции Lisp.  Это позволяет проходить через подвыражения выражения, видеть,
какие значения вычисляются подвыражениями и что еще они делают.

Кадр стека, созданный для вызова функции, который таким образом поступает в
отладчик, будет автоматически помечен, чтобы отладчик вызывался снова при
выходе из кадра.  Можно использовать команду @kbd{u}, чтобы снять этот флаг.

@item b
Отметить текущий кадр, чтобы отладчик мог войти в него после выхода из
фрейма.  Помеченные таким образом кадры помечаются звездочкой в буфере
обратной трассировки.

@item u
Не входить в отладчик после выхода из текущего фрейма.  Это отменяет команду
@kbd{b} в этом кадре.  Видимый эффект состоит в том, чтобы удалить звезду
из строки в буфере обратной трассировки.

@item j
Отметить текущий кадр как @kbd{b}.  Затем продолжите выполнение, как
@kbd{c}, но временно отключите прерывание при входе для всех функций,
которые настроены для этого с помощью @code{debug-on-entry}.

@item e
Прочтите выражение Lisp в минибуфере, оцените его (с соответствующей
лексической средой, если применимо) и распечатайте значение в эхо-области.
Отладчик изменяет некоторые важные переменные и текущий буфер как часть
своей работы; @kbd{e} временно восстанавливает их значения вне отладчика,
чтобы иметь возможность проверить и изменить.  Это делает отладчик более
прозрачным.  Напротив, @kbd{M-:} не делает ничего особенного в отладчике;
он показывает вам значения переменных в отладчике.

@item R
Аналогично @kbd{e}, но также сохраняем результат вычисления в буфере
@file{*Debugger-record*}.

@item q
Завершить отлаживаемую программу; вернуться к выполнению команд Emacs
верхнего уровня.

Если отладчик был запущен с помощью @kbd{C-g}, но действительно требуется
выйти, а не выполнять отладку, используйте команду @kbd{q}.

@item r
Вернуть значение из отладчика.  Значение вычисляется путем чтения выражения
с помощью минибуфера и его оценки.

Команда @kbd{r} полезна, когда отладчик был вызван из-за выхода из кадра
вызова Lisp (в соответствии с запросом с помощью @kbd{b} или при входе в
кадр с помощью @kbd{d}); тогда значение, указанное в команде @kbd{r},
используется как значение этого кадра.  Это также полезно, если вызывается
@code{debug} и используется его возвращаемое значение.  В противном случае
@kbd{r} имеет тот же эффект, что и @kbd{c}, и указанное возвращаемое
значение не имеет значения.

Не выйдет использовать @kbd{r}, когда отладчик был введен из-за ошибки.

@item l
Отобразить список функций, которые будут вызывать отладчик при вызове.  Это
список функций, которые будут отключены при входе с помощью
@code{debug-on-entry}.

@item v
Переключить отображение локальных переменных текущего кадра стека.
@end table

@node Invoking the Debugger
@subsection Вызов Отладчика
@cindex invoking lisp debugger

  Здесь подробно описана функция @code{debug}, которая используется для
вызова отладчика.

@deffn Command debug &rest debugger-args
Эта функция входит в отладчик.  Она переключает буферы на буфер с именем
@file{*Backtrace*} (или @file{*Backtrace*<2>}, если это вторая рекурсивная
запись отладчика и т. д.) и заполняет его информацией о стеке вызовов
функций Lisp.  Затем она переходит в рекурсивное редактирование, показывая
буфер обратной трассировки в режиме отладчика.

Команды @kbd{c}, @kbd{d}, @kbd{j}, и @kbd{r} режима отладчика выходят из
рекурсивного редактирования; затем @code{debug} переключается на предыдущий
буфер и возвращается к тому, что называется @code{debug}.  Только так
функция @code{debug} может вернуться к вызывающей стороне.

Использование @var{debugger-args} заключается в том, что @code{debug}
отображает остальные свои аргументы в верхней части буфера
@file{*Backtrace*}, чтобы пользователь мог их видеть.  За исключением
случаев, описанных ниже, эти аргументы используются @emph{только} таким
образом.

Однако некоторые значения для первого аргумента @code{debug} имеют особое
значение.  (Обычно эти значения используются только внутренними компонентами
Emacs, а не программистами, вызывающими @code{debug}.)  Вот таблица этих
специальных значений:

@table @code
@item lambda
@cindex @code{lambda} in debug
Первый аргумент @code{lambda} означает, что @code{debug} был вызван из-за
входа в функцию, когда @code{debug-on-next-call} был не-@code{nil}.
Отладчик отображает @samp{Debugger entered--entering a function:} в виде
строки текста в верхней части буфера.

@item debug
@code{debug} в качестве первого аргумента означает, что @code{debug} был
вызван из-за входа в функцию, которая была настроена на отладку при входе.
Отладчик отображает строку @samp{Debugger entered--entering a function:},
как и в случае с @code{lambda}.  Он также отмечает фрейм стека для этой
функции, чтобы при выходе она вызывала отладчик.

@item t
Когда первым аргументом является @code{t}, это указывает на вызов
@code{debug} из-за оценки формы вызова функции, когда
@code{debug-on-next-call} имеет значение не-@code{nil}.  Отладчик отображает
@samp{Debugger entered--beginning evaluation of function call form:} в
верхней строке буфера.

@item exit
Когда первым аргументом является @code{exit}, это указывает на выход из
кадра стека, ранее отмеченного для вызова отладчика при выходе.  Второй
аргумент, передаваемый @code{debug} в этом случае, - это значение,
возвращаемое из кадра.  Отладчик отображает
@samp{Debugger entered--returning value:} в верхней строке буфера, за
которым следует возвращаемое значение.

@item error
@cindex @code{error} in debug
Когда первым аргументом является @code{error}, отладчик указывает, что он
вводится из-за того, что ошибка или @code{quit} была передана, но не
обработана, отображая @samp{Debugger entered--Lisp error:}, за которым
следует сообщение об ошибке и любые аргументы для @code{signal}.  Например,

@example
@group
(let ((debug-on-error t))
  (/ 1 0))
@end group

@group
------ Buffer: *Backtrace* ------
Debugger entered--Lisp error: (arith-error)
  /(1 0)
...
------ Buffer: *Backtrace* ------
@end group
@end example

Если сообщалось об ошибке, предположительно, переменная
@code{debug-on-error} - не-@code{nil}.  Если был передан сигнал @code{quit},
то предположительно переменная @code{debug-on-quit} - это не-@code{nil}.

@item nil
Используйте @code{nil} как первый из @var{debugger-args}, если требуется
явно войти в отладчик.  Остальные @var{debugger-args} печатаются в верхней
строке буфера.   Можно использовать эту функцию для отображения сообщений -
например, чтобы напомнить об условиях, при которых вызывается @code{debug}.
@end table
@end deffn

@node Internals of Debugger
@subsection Внутреннее Устройство Отладчика

  В этом разделе описаны функции и переменные, используемые внутри
отладчиком.

@defvar debugger
Значение этой переменной - это функция, которую нужно вызвать для вызова
отладчика.  Её значение должно быть функцией любого количества аргументов
или, что более типично, именем функции.  Эта функция должна вызывать
какой-то отладчик.  Значение переменной по умолчанию - @code{debug}.

Первый аргумент, который Lisp передает функции, указывает, почему она была
вызвана.  Соглашение об аргументах подробно описано в описании @code{debug}
(@pxref{Invoking the Debugger}).
@end defvar

@defun backtrace
@cindex run time stack
@cindex call stack
Эта функция печатает трассировку вызовов функций Lisp, активных в данный
момент.  Это функция, используемая @code{debug} для заполнения буфера
@file{*Backtrace*}.  Она написан на Cи, так как должна иметь доступ к стеку,
чтобы определять, какие вызовы функций активны.  Возвращаемое значение
всегда @code{nil}.

В следующем примере выражение Lisp явно вызывает @code{backtrace}.  Это
печатает обратную трассировку к потоку @code{standard-output}, который в
данном случае является буфером @samp{backtrace-output}.

Каждая строка трассировки представляет собой один вызов функции.  В строке
показаны значения аргументов функции, если все они известны; если они еще
вычисляются, об этом говорится в строке.  Аргументы специальных форм
опускаются.

@smallexample
@group
(with-output-to-temp-buffer "backtrace-output"
  (let ((var 1))
    (save-excursion
      (setq var (eval '(progn
                         (1+ var)
                         (list 'testing (backtrace))))))))

     @result{} (testing nil)
@end group

@group
----------- Buffer: backtrace-output ------------
  backtrace()
  (list ...computing arguments...)
@end group
  (progn ...)
  eval((progn (1+ var) (list (quote testing) (backtrace))))
  (setq ...)
  (save-excursion ...)
  (let ...)
  (with-output-to-temp-buffer ...)
  eval((with-output-to-temp-buffer ...))
  eval-last-sexp-1(nil)
@group
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp)
----------- Buffer: backtrace-output ------------
@end group
@end smallexample
@end defun

@defopt debugger-stack-frame-as-list
Если эта переменная - не-@code{nil}, каждый кадр стека обратной трассировки
отображается в виде списка.  Это нацелено на улучшение читаемости обратной
трассировки за счет того, что специальные формы больше не будут визуально
отличаться от обычных вызовов функций.

С @code{debugger-stack-frame-as-list} установленной в не-@code{nil}
приведенный выше пример будет выглядеть следующим образом:

@smallexample
@group
----------- Buffer: backtrace-output ------------
  (backtrace)
  (list ...computing arguments...)
@end group
  (progn ...)
  (eval (progn (1+ var) (list (quote testing) (backtrace))))
  (setq ...)
  (save-excursion ...)
  (let ...)
  (with-output-to-temp-buffer ...)
  (eval (with-output-to-temp-buffer ...))
  (eval-last-sexp-1 nil)
@group
  (eval-last-sexp nil)
  (call-interactively eval-last-sexp)
----------- Buffer: backtrace-output ------------
@end group
@end smallexample
@end defopt

@defvar debug-on-next-call
@cindex @code{eval}, and debugging
@cindex @code{apply}, and debugging
@cindex @code{funcall}, and debugging
Если эта переменная - не-@code{nil}, она говорит, что нужно вызвать отладчик
до следующего @code{eval}, @code{apply} или @code{funcall}.  Вход в отладчик
устанавливает @code{debug-on-next-call} в @code{nil}.

Команда @kbd{d} в отладчике работает, задав эту переменную.
@end defvar

@defun backtrace-debug level flag
Эта функция устанавливает флаг отладки при выходе для кадра стека
@var{level} уровней вниз по стеку, присваивая ему значение @var {flag}.
Если @var{flag} равен не-@code{nil}, это вызовет вход в отладчик при выходе
из этого кадра.  Даже нелокальный выход через этот кадр попадет в отладчик.

Эта функция используется только отладчиком.
@end defun

@defvar command-debug-status
Эта переменная записывает статус отладки текущей интерактивной команды.
Каждый раз, когда команда вызывается в интерактивном режиме, эта переменная
привязывается к @code{nil}.  Отладчик может установить эту переменную, чтобы
оставить информацию для будущих вызовов отладчика во время того же вызова
команды.

Преимущество использования этой переменной по сравнению с обычной глобальной
переменной состоит в том, что данные никогда не будут перенесены при
последующем вызове команды.

Эта переменная устарела и будет удалена в будущих версиях.
@end defvar

@defun backtrace-frame frame-number &optional base
Функция @code{backtrace-frame} предназначена для использования в отладчиках
Lisp.  Онf возвращает информацию о том, какие вычисления происходят в стеке
кадра @var{frame-number} уровней вниз.

Если этот кадр еще не оценил аргументы или является специальной формой,
значение будет @code{(nil @var{function} @var{arg-forms}@dots{})}.

Если этот фрейм уже оценил свои аргументы и вызвал свою функцию,
возвращаемое значение - @code{(t @var{function} @var{arg-values}@dots{})}.

В возвращаемом значении @var{function} - это то, что было предоставлено как
@sc{car} оцененного списка, или выражение @code{lambda} в случае вызова
макроса.  Если функция имеет аргумент @code{&rest}, это представлено как
хвост списка @var{arg-values}.  Если указан @var{base}, @var{frame-number}
считается относительно самого верхнего кадра, @var{function} которого равен
@var{base}.

Если @var{frame-number} вне допустимого диапазона, @code{backtrace-frame}
возвращает @code{nil}.
@end defun

@defun mapbacktrace function &optional base
Функция @code{mapbacktrace} вызывает @var{function} один раз для каждого
кадра в трассировке, начиная с первого кадра, функция которого - @var{base}
(или сверху, если @var{base} опущен или @code{nil}).

@var{function} вызывается с четырьмя аргументами: @var{evald}, @var{func},
@var{args}, и @var{flags}.

Если кадр еще не оценил свои аргументы или является специальной формой,
@var{evald} - это @code{nil}, а @var{args} - это список форм.

Если фрейм уже оценил свои аргументы и вызвал свою функцию, @var{evald} -
это @code{t}, а @var{args} - это список значений.  @var{flags} - это список
свойств текущего кадра: в настоящее время единственное поддерживаемое
свойство - @code{:debug-on-exit}, то есть @code{t}, если установлен флаг
@code{debug-on-exit} кадра стека.
@end defun

@include edebug.texi

@node Syntax Errors
@section Debugging Invalid Lisp Syntax
@cindex debugging invalid Lisp syntax

  Считыватель Lisp сообщает о недопустимом синтаксисе, но не может сказать,
где настоящая проблема.  Например, ошибка @samp{End of file during parsing}
при вычислении выражения указывает на избыток открытых круглых (или
квадратных скобок).  Считыватель обнаруживает этот дисбаланс в конце файла,
но не может определить, где должна была быть закрывающая скобка.
Аналогично, @samp{Invalid read syntax: ")"} указывает на лишнюю закрывающую
круглую скобку или отсутствие открытой круглой скобки, но не говорит, где
находится отсутствующая скобка.  Как же тогда найти, что нужно изменить?

  Если проблема не просто в дисбалансе круглых скобок, полезно попробовать
@kbd{C-M-e} (@code{end-of-defun},
@pxref{Moving by Defuns,,,emacs, The GNU Emacs Manual}) в начале каждого
defun и посмотреть, доходит ли он до того места, где это определение defun,
заканчивается.  Если это не так, проблема в этом конкретном defun.

@cindex unbalanced parentheses
@cindex parenthesis mismatch, debugging
  Однако несогласованные круглые скобки являются наиболее частыми
синтаксическими ошибками в Lisp, и даются дальнейшие советы для таких
случаев.  (Кроме того, простое перемещение точки по коду с включенным
режимом Show Paren может обнаружить несоответствие.)

@menu
* Excess Open::     Как найти ложное открытие или недостающее закрытие.
* Excess Close::    Как найти ложное закрытие или отсутствие открытого.
@end menu

@node Excess Open
@subsection Лишние Открытые Круглые Скобки
@cindex excess open parentheses

  Первый шаг - найти несбалансированное defun.  Если есть лишние открывающие
круглые скобки, способ сделать это - перейти в конец файла и ввести
@kbd{C-u C-M-u} (@code{backward-up-list},
@pxref{Moving by Parens,,,emacs, The GNU Emacs Manual}).  Это переместит в
начало первого несбалансированного defun.

  Следующий шаг - точно определить, что не так.  Невозможно убедиться в
этом, кроме как изучив программу, но часто существующий отступ является
ключом к тому, где должны были быть скобки.  Самый простой способ
использовать эту подсказку - это повторно сделать отметку с помощью
@kbd{C-M-q} (@code{indent-pp-sexp},
@pxref{Multi-line Indent,,,emacs, The GNU Emacs Manual}) и посмотреть, что
происходит.  @strong{Но не делай этого пока!} Сначала продолжай читать.

  Перед тем, как сделать это, проверить, что в defun достаточно закрывающих
скобок.  В противном случае @kbd{C-M-q} выдаст ошибку или изменит отступ
всей остальной части файла до конца.  Так что переместитесь в конец defun и
вставьте там закрывающую скобку.  Не используйте @kbd{C-M-e}
(@code{end-of-defun}) для перемещения туда, так как это тоже не сработает,
пока defun не будет сбалансирован.

  Теперь можно перейти к началу defun и набрать @kbd{C-M-q}.  Обычно все
строки от определенной точки до конца функции смещаются вправо.  Вероятно,
рядом с этой точкой есть недостающая закрывающая скобка или излишняя
открытая скобка.  (Однако не обязательно это правда; потребуется изучить
код, чтобы убедиться.)  Как только обнаружится несоответствие, отменяется
@kbd{C-M-q} с помощью @kbd{C-_} (@code{undo}), поскольку старый отступ,
вероятно, соответствует предполагаемым круглым скобкам.

  Если считается, что проблема устранена, снова используется @kbd{C-M-q}.
Если преждний отступ действительно соответствует предполагаемому вложению
круглых скобок, и эти скобки сбалансированы, @kbd{C-M-q} не должен ничего
менять.

@node Excess Close
@subsection Лишние Закрывающие Круглые Скобки
@cindex excess close parentheses

  Чтобы справиться с лишними закрывающими скобками, сначала проводится
переход к началу файла, затем вводится @kbd{C-u -1 C-M-u}
(@code{backward-up-list} с аргументом @minus{}1), чтобы найти конец первого
несбалансированного defun.

  Затем находится подходящая закрывающая скобка, набрав @kbd{C-M-f}
(@code{forward-sexp}, @pxref{Expressions,,,emacs, The GNU Emacs Manual}) в
начале этого определения.  Это переместит где-то недалеко от того места, где
должно закончиться defun.  Возможно, что поблизости найдётся ложная скобка.

  Если не обнаружено проблемы на этом этапе, следующее, что нужно сделать,
это ввести @kbd{C-M-q} (@code{indent-pp-sexp}) в начале defun.  Ряд строк,
вероятно, сместится влево; если да, то недостающая открывающая скобка или
ложная закрывающая скобка, вероятно, находится рядом с первой из этих строк.
(Однако не стоит полагаться, что это правда; изучить код, чтобы убедиться).
Как только обнаружится несоответствие, отменить @kbd{C-M-q} с помощью
@kbd{C-_} (@code{undo}), так как старый отступ, вероятно, соответствует
предполагаемым круглым скобкам.

  После того, как предполагается, что проблема устранена, снова используется
@kbd{C-M-q}.  Если старый отступ действительно соответствует предполагаемому
вложению круглых скобок, и вы вернуты эти скобки, @kbd{C-M-q} не должен
ничего менять.

@node Test Coverage
@section Проведение Тестов
@cindex coverage testing

@findex testcover-start
@findex testcover-mark-all
@findex testcover-next-mark
  Можно выполнить тестирование для файла кода Lisp, загрузив библиотеку
@code{testcover} и используя команду @kbd{M-x testcover-start @key{RET} @var{file} @key{RET}} для инструментирования кода.  Затем проверить код, вызвав
его один или несколько раз.  Затем использовать команду
@kbd{M-x testcover-mark-all}, чтобы отобразить цветные выделения в коде,
чтобы показать, где покрытия недостаточно.  Команда
@kbd{M-x testcover-next-mark} переместит точку вперед к следующему
выделенному месту.

  Обычно красный цвет означает, что форма никогда не была полностью оценена;
коричневая подсветка означает, что она всегда оценивается с одним и тем же
значением (это означает, что было мало проверок того, что делается с
результатом).  Однако красная подсветка пропускается для форм, которые не
могут завершить свою оценку, например @code{error}.  Коричневая подсветка
пропускается для форм, которые, как ожидается, всегда будут вычислять одно и
то же значение, например @code{(setq x 14)}.

  В сложных случаях можно добавить в свой код бездействующие макросы, чтобы
дать совет инструменту покрытия тестов.

@defmac 1value form
Вычислить @var{form} и вернуть его значение, но при тестировании покрытия
сообщить, что значение @var{form} всегда должно быть одинаковым.
@end defmac

@defmac noreturn form
Оценить @var{form}, сообщив тестированию покрытия, что @var{form} никогда
не должен возвращаться.  Если он когда-либо вернется, получится ошибка
времени выполнения.
@end defmac

  Edebug также имеет функцию тестирования покрытия
(@pxref{Coverage Testing}).  Эти функции частично дублируют друг друга, и
было бы проще их объединить.


@node Profiling
@section Профилирование
@cindex profiling
@cindex profile
@cindex performance analysis
@cindex measuring resource usage
@cindex memory usage

Если программа работает правильно, но недостаточно быстро, и требуется,
чтобы она выполнялась быстрее или эффективнее, первое, что нужно сделать, -
это @dfn{профилирование} вашего кода, чтобы знать на что тратится большая
часть времени выполнения.  Если обнаружится, что одна конкретная функция
отвечает за значительную часть времени выполнения, можно начать искать
способы оптимизации этой части.

@findex profiler-start
@findex profiler-report
@findex profiler-stop
Emacs имеет для этого встроенную поддержку.  Чтобы начать профилирование,
введите @kbd{M-x profiler-start}.  Можно выбрать профиль по использованию
процессора, памяти или по обоим параметрам.  Затем запустить код, который
требуется ускорить.  После этого вводится @kbd{M-x profiler-report}, чтобы
отобразить сводный буфер для каждого ресурса (процессора и памяти), который
выбран для профилирования.  Имена буферов отчетов включают время создания
отчетов, поэтому можно создать другой отчет позже, не стирая предыдущие
результаты.  Когда закончится профилирование, вводится
@kbd{M-x profiler-stop} (есть небольшие накладные расходы, связанные с
профилированием, поэтому не рекомендуется оставлять его активным, кроме
случаев, когда действительно запускается код, который требуется изучить).

Буфер отчета профилировщика показывает в каждой строке вызванную функцию, а
затем, сколько ресурсов (процессора или памяти) она использовала в
абсолютном и процентном выражении с момента начала профилирования.  Если
данная строка имеет символ @samp{+} с левой стороны, можно расширить эту
строку, набрав @kbd{@key{RET}}, чтобы увидеть функцию(ии), вызываемую
функцией более высокого уровня.  Используется префиксный аргумент
(@kbd{C-u @key{RET}}), чтобы увидеть все дерево вызовов под функцией.
Повторное нажатие @kbd{@key{RET}} вернет исходное состояние.

Нажать @kbd{j} или @kbd{mouse-2}, чтобы перейти к определению функции в
точке.  Нажать @kbd{d}, чтобы просмотреть документацию по функциям.  Можно
сохранить профиль в файл с помощью @kbd{C-x C-w}.  Можно сравнить два
профиля с помощью @kbd{=}.

@c От себя: обратное дерево вызовов?

@cindex @file{elp.el}
@cindex timing programs
Библиотека @file{elp} предлагает альтернативный подход, который полезен,
когда заранее известно, какие функции Lisp требуется профилировать.
Использование этой библиотеки, начинается с установки
@code{elp-function-list} в список функциональных символов - это функции,
которые требуется профилировать.  Затем вводится @w{@kbd{M-x elp-instrument-list @key{RET} nil @key{RET}}}, чтобы настроить профилирование этих функций.
После запуска кода, который нужно профилировать, вызывается
@w{@kbd{M-x elp-results}} для отображения текущих результатов.  Более
подробные инструкции смотреть в файле @file{elp.el}.  Этот подход ограничен
функциями профилирования, написанными на Lisp, он не может профилировать
примитивы Emacs.

@cindex @file{benchmark.el}
@cindex benchmarking
Можно измерить время, необходимое для оценки отдельных форм Emacs Lisp,
используя библиотеку @file{benchmark}.  Смотреть макросы
@code{benchmark-run} и @code{benchmark-run-compiled} в @file{benchmark.el}.
Также можно использовать команду @code{benchmark} для интерактивного
хронометража форм.

@c Не стоит помещать печатное руководство.
@ifnottex
@cindex --enable-profiling option of configure
Чтобы профилировать Emacs на уровне его кода Cи, можно построить его,
используя параметр @option{--enable-profiling} для @command{configure}.
Когда Emacs завершает свою работу, он генерирует файл @file{gmon.out},
который можно изучить с помощью утилиты @command{gprof}.  Эта функция в
основном полезна для отладки Emacs.  Это фактически останавливает работу
команд @kbd{M-x profiler-@dots{}} уровня Lisp, описанных выше.
@end ifnottex
