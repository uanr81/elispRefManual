@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1994, 1998-1999, 2001-2019 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Debugging
@chapter Отладка Программ на Lisp
@cindex debugging lisp programs

  Есть несколько способов найти и исследовать проблемы в программе Emacs
Lisp.

@itemize @bullet
@item
Если проблема возникает при запуске программы, можно использовать встроенный
отладчик Emacs Lisp, чтобы приостановить анализатор Lisp и проверить и/или
изменить его внутреннее состояние.

@item
Можно использовать Edebug, отладчик исходного уровня Emacs Lisp.

@item
@cindex tracing Lisp programs
Можно отслеживать выполнение функций, связанных с проблемой, используя
средства трассировки, предоставляемые пакетом @file{trace.el}.  Этот пакет
предоставляет функции @code{trace-function-foreground} и
@code{trace-function-background} для отслеживания вызовов функций и
@code{trace-values} для добавления значений выбранных переменных к
трассировке.  Подробнее смотреть документацию к этим объектам в
@file{trace.el}.

@item
Если синтаксическая проблема мешает Lisp даже прочитать программу, можно
найти ее с помощью команд редактирования Lisp.

@item
Можно просмотреть сообщения об ошибках и предупреждения, создаваемые байт
компилятором при компиляции программы.  @xref{Compiler Errors}.

@item
Можно использовать пакет Testcover для тестирования покрытия программы.

@item
Можно использовать пакет ERT для написания регрессионных тестов к программе.
@xref{Top,the ERT manual,, ert, ERT: Emacs Lisp Regression Testing}.

@item
Можно профилировать программу, чтобы получить подсказки о том, как сделать
ее более эффективной.
@end itemize

  Другими полезными инструментами для отладки проблем ввода и вывода
являются файл dribble (@pxref{Terminal Input}) и функция
@code{open-termscript} (@pxref{Terminal Output}).

@menu
* Debugger::            Отладчик для оценщика Emacs Lisp.
* Edebug::              Отладчик Emacs Lisp на уровне исходного кода.
* Syntax Errors::       Как найти синтаксические ошибки.
* Test Coverage::       Убедится, что протестированы все ветки кода.
* Profiling::           Измерение ресурсов, которые использует ваш код.
@end menu

@node Debugger
@section The Lisp Debugger
@cindex debugger for Emacs Lisp
@cindex Lisp debugger
@cindex break

  Обычный @dfn{Lisp отладчик} дает возможность приостановить оценку формы.
Пока оценка приостановлена (состояние, обычно известное как @dfn{останов}),
можно проверить стек времени выполнения, проверить значения локальных или
глобальных переменных или изменить эти значения.  Поскольку разрыв - это
рекурсивное редактирование, доступны все обычные средства редактирования
Emacs; можно запускать программы, которые будут входить в отладчик
рекурсивно.  @xref{Recursive Editing}.

@menu
* Error Debugging::       Вход в отладчик при возникновении ошибки.
* Infinite Loops::        Остановка и отладка программы, которая не завершается.
* Function Debugging::    Вход в отладчик при вызове определенной функции.
* Variable Debugging::    Вход в отладчик при изменении переменной.
* Explicit Debug::        Вход в отладчик в определенный момент в программе.
* Using Debugger::        Что делает отладчик; что видно в нём.
* Debugger Commands::     Команды, используемые в отладчике.
* Invoking the Debugger:: Как вызвать функцию @code{debug}.
* Internals of Debugger:: Подпрограммы отладчика и глобальные переменные.
@end menu

@node Error Debugging
@subsection Entering the Debugger on an Error
@cindex error debugging
@cindex debugging errors

  Самый важный момент для входа в отладчик - это когда происходит ошибка
Lisp.  Это позволяет исследовать непосредственные причины ошибки.

  Однако вход в отладчик не является нормальным следствием ошибки.  Многие
команды сигнализируют об ошибках Lisp при неправильном вызове, и во время
обычного редактирования было бы очень неудобно заходить в отладчик каждый
раз, когда это происходит.  Поэтому, если потребуется, чтобы ошибки
поступали в отладчик, установите для переменной @code{debug-on-error}
значение не-@code{nil}.  (Команда @code{toggle-debug-on-error} предоставляет
простой способ сделать это.)

@defopt debug-on-error
Эта переменная определяет, вызывается ли отладчик, когда сообщается об
ошибке, но не обрабатывается.  Если @code{debug-on-error} равен @code{t},
отладчик вызывает все виды ошибок, кроме тех, которые перечислены в
@code{debug-ignored-errors} (смотреть ниже).  Если установлено в @code{nil},
ничто не вызывает отладчик.

Значение также может быть списком условий ошибки (@pxref{Signaling Errors}).
Затем отладчик вызывается только для условий ошибки присутствующей в этом
списке (кроме тех, которые также перечислены в @code{debug-ignored-errors}).
Например, если установить @code{debug-on-error} в список
@code{(void-variable)}, отладчик будет вызываться только для ошибок,
связанных с переменной, которая не имеет значения.

Обратите внимание, что @code{eval-expression-debug-on-error} в некоторых
случаях переопределяет эту переменную; смотреть ниже.

Когда эта переменная - не-@code{nil}, Emacs не создает обработчик ошибок для
функций фильтрации процессов и сигнальных индикаторов.  Следовательно,
ошибки в этих функциях также вызывают отладчик.  @xref{Processes}.
@end defopt

@defopt debug-ignored-errors
Эта переменная определяет ошибки, которые не должны поступать в отладчик, не
зависимо от значения @code{debug-on-error}.  Её значение - это список
символов условий ошибки и/или регулярных выражений.  Если в ошибке
присутствует какой-либо из этих условных символов или если сообщение об
ошибке соответствует любому из регулярных выражений, то эта ошибка не
поступает в отладчик.

Нормальное значение этой переменной включает @code{user-error}, а также
несколько ошибок, которые часто случаются во время редактирования, но редко
являются результатом ошибок в программах на Lisp.  Однако ``rarely (редко)''
не ``never (никогда)''; если программа выдает ошибку, соответствующую этому
списку, можно попробовать изменить этот список, чтобы отладить ошибку.
Самый простой способ - установить @code{debug-ignored-errors} в @code{nil}.
@end defopt

@defopt eval-expression-debug-on-error
Если эта переменная имеет значение не-@code{nil} (по умолчанию), запуск
команды @code{eval-expression} приводит к временной привязке
@code{debug-on-error} к @code{t}.  @xref{Lisp Eval,, Evaluating Emacs-Lisp Expressions, emacs, The GNU Emacs Manual}.

Если @code{eval-expression-debug-on-error} равен @code{nil}, то значение
@code{debug-on-error} не изменяется во время @code{eval-expression}.
@end defopt

@defopt debug-on-signal
Обычно ошибки, обнаруженные @code{condition-case}, никогда не вызывают
отладчик.  @code{condition-case} получает шанс обработать ошибку до того,
как отладчик получит шанс.

Если изменить @code{debug-on-signal} на значение не-@code{nil}, отладчик
получит первую возможность при каждой ошибке, независимо от наличия
@code{condition-case}.  (Чтобы вызвать отладчик, ошибка должна
соответствовать критериям, указанным в @code{debug-on-error} и
@code{debug-ignored-errors}.)

@cindex emacsclient, getting a backtrace
@cindex backtrace from emacsclient's @option{--eval}
Например, установка этой переменной полезна для получения трассировки кода,
оцениваемого опцией emacsclient @option{--eval}.  Если код Lisp, оцениваемый
emacsclient, сигнализирует об ошибке, когда эта переменная имеет значение
не-@code{nil}, трассировка откроется в работающем Emacs.

@strong{Внимание:} Установка этой переменной в не-@code{nil} может иметь
раздражающие эффекты.  Различные части Emacs улавливают ошибки в обычном
порядке, и можно даже не осознавать, что ошибки там происходят.  Если нужно
отладить код, заключенный в @code{condition-case}, рассмотрите возможность
использования @code{condition-case-unless-debug} (@pxref{Handling Errors}).
@end defopt

@defopt debug-on-event
Если установить @code{debug-on-event} для специального события
(@pxref{Special Events}), Emacs попытается войти в отладчик, как только
получит это событие, минуя @code{special-event-map}.  В настоящее время
только поддерживаемые значения соответствуют сигналам @code{SIGUSR1} и
@code{SIGUSR2} (это значение по умолчанию).  Это может быть полезно, когда
установлен @code{inhibit-quit}, а Emacs не отвечает иначе.
@end defopt

@cindex message, finding what causes a particular message
@defvar debug-on-message
Если установить для @code{debug-on-message} регулярное выражение, Emacs
войдет в отладчик, если отобразит соответствующее сообщение в эхо-области.
Например, это может быть полезно при попытке найти причину того или иного
сообщения.
@end defvar

  Чтобы отладить ошибку, возникающую при загрузке файла инициализации,
используйте параметр @samp{--debug-init}.  Это связывает
@code{debug-on-error} с @code{t} при загрузке файла инициализации и
обходит @code{condition-case}, который обычно обнаруживает ошибки в файле
инициализации.

@node Infinite Loops
@subsection Отладка Бесконечных Циклов
@cindex infinite loops
@cindex loops, infinite
@cindex quitting from infinite loop
@cindex stopping an infinite loop

  Когда программа зацикливается бесконечно и не может вернуться, первая
проблема - остановить цикл.  В большинстве операционных систем это можно
сделать с помощью @kbd{C-g}, который вызывает @dfn{quit}.  @xref{Quitting}.

  Обычный выход не дает информации о том, почему программа зацикливалась.
Для получения дополнительной информации можно установить для переменной
@code{debug-on-quit} значение не-@code{nil}.  После того, как отладчик
запущен в середине бесконечного цикла, можно продолжить работу с отладчиком,
используя пошаговые команды.  Если пройти весь цикл, можно получить
достаточно информации для решения проблемы.

  Выход с помощью @kbd{C-g} не считается ошибкой, а @code{debug-on-error}
не влияет на обработку @kbd{C-g}.  Точно так же @code{debug-on-quit} не
влияет на ошибки.

@defopt debug-on-quit
Эта переменная определяет, вызывается ли отладчик, когда @code{quit}
сигнализируется и не обрабатывается.  Если @code{debug-on-quit} равен
не-@code{nil}, то отладчик вызывается при выходе (то есть при вводе
@kbd{C-g}).  Если @code{debug-on-quit} - @code{nil} (по умолчанию),
отладчик не вызывается при выходе.
@end defopt

@node Function Debugging
@subsection Вход в Отладчик при Вызове Функции
@cindex function call debugging
@cindex debugging specific functions

  Чтобы исследовать проблему, которая возникает в середине программы, можно
использовать один из полезных приемов - входить в отладчик при каждом вызове
определенной функции.  Можно сделать это с функцией, в которой возникает
проблема, а затем выполнить пошаговое выполнение функции, или можно сделать
это с функцией, вызываемой незадолго до возникновения проблемы, быстро
перешагнуть через вызов этой функции, а затем пройти через ее вызывающего.

@deffn Command debug-on-entry function-name
Эта функция запрашивает @var{function-name} для вызова отладчика при каждом
её вызове.

Любая функция или макрос, определенные как код Lisp, могут быть установлены
на прерывание при входе, независимо от того, является ли это
интерпретируемым кодом или скомпилированным кодом.  Если функция является
командой, она войдет в отладчик при вызове из Lisp и при интерактивном
вызове (после чтения аргументов).  Также можно установить отладку при входе
для примитивных функций (то есть написанных на C) таким образом, но это
вступит в силу только тогда, когда примитив вызывается из кода Lisp.
Отладка при входе не допускается для специальных форм.

Когда @code{debug-on-entry} вызывается в интерактивном режиме, он
запрашивает @var{function-name} в минибуфере.  Если функция уже настроена
для вызова отладчика при входе, @code{debug-on-entry} ничего не делает.
@code{debug-on-entry} всегда возвращает @var{function-name}.

Вот пример, иллюстрирующий использование этой функции:

@example
@group
(defun fact (n)
  (if (zerop n) 1
      (* n (fact (1- n)))))
     @result{} fact
@end group
@group
(debug-on-entry 'fact)
     @result{} fact
@end group
@group
(fact 3)
@end group

@group
------ Buffer: *Backtrace* ------
Debugger entered--entering a function:
* fact(3)
  eval((fact 3))
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp)
------ Buffer: *Backtrace* ------
@end group

@end example
@end deffn

@deffn Command cancel-debug-on-entry &optional function-name
Эта функция отменяет эффект @code{debug-on-entry} на @var{function-name}.
При интерактивном вызове запрашивает в минибуфере @var{function-name}.  Если
@var{function-name} опущено или @code{nil}, он отменяет прерывание при входе
для всех функций.  Вызов @code{cancel-debug-on-entry} ничего не делает для
функции, которая в настоящее время не настроена на прерывание при входе.
@end deffn

@node Variable Debugging
@subsection Вход в Отладчик при Изменении Переменной
@cindex variable write debugging
@cindex debugging changes to variables

Иногда проблема с функцией возникает из-за неправильной установки
переменной.  Настройка отладчика для срабатывания при изменении переменной -
это быстрый способ найти источник настройки.

@deffn Command debug-on-variable-change variable
Эта функция организует вызов отладчика при изменении @var{variable}.

Она реализована с использованием механизма точки наблюдения, поэтому она
наследует те же характеристики и ограничения: все псевдонимы @var{variable}
будут отслеживаться вместе, могут наблюдаться только динамические
переменные, и изменения в объектах, на которые ссылаются переменные, не
обнаруживаются.  Подробности, смотреть @ref{Watching Variables}.
@end deffn

@deffn Command cancel-debug-on-variable-change &optional variable
Эта функция отменяет эффект @code{debug-on-variable-change} на
@var{variable}.  При интерактивном вызове запрашивает в минибуфере
@var{variable}.  Если параметр @var{variable} или @code{nil} опущен,
прерывание при замене отменяется для всех переменных.  Вызов
@code{cancel-debug-on-variable-change} ничего не делает с переменной,
которая в настоящее время не настроена на прерывание при изменении.
@end deffn


@node Explicit Debug
@subsection Явный Вход в Отладчик
@cindex debugger, explicit entry
@cindex force entry to debugger

@cindex @code{eval-defun}, and explicit entry to debugger
  Можно вызвать отладчик в определенной точке вашей программы, написав в
этой точке выражение @code{(debug)}.  Для этого зайдите в исходный файл,
вставьте текст @samp{(debug)} в нужное место и введите @kbd{C-M-x}
(@code{eval-defun}, привязка ключа режима Lisp).  @strong{Внимание:}, если
сделать это для временной отладки, обязательно отмените эту вставку перед
сохранением файла!

  Место, куда вставляется @samp{(debug)}, должно быть местом, где можно
оценивать дополнительную форму и игнорировать ее значение.  (Если значение
@code{(debug)} не игнорируется, это изменит выполнение программы!).
Наиболее часто подходящие места находятся внутри @code{progn} или неявного
@code{progn}.  (@pxref{Sequencing}).

  Если знаеть точно, где в исходном коде требуется поместить оператор
отладки, но нужно отображать обратную трассировку при отображении
определенного сообщения, можно установить @code{debug-on-message} на
регулярное выражение, соответствующее желаемому сообщению.

@node Using Debugger
@subsection Использование Отладчика

  При входе в отладчик он отображает ранее выбранный буфер в одном окне и
буфер с именем @file{*Backtrace*} в другом окне.  Буфер обратной трассировки
содержит по одной строке для каждого уровня выполнения функции Lisp, которая
отрабатывает в данный момент.  В начале этого буфера находится сообщение,
описывающее причину вызова отладчика (например, сообщение об ошибке и
связанные данные, если он был вызван из-за ошибки).

@vindex debugger-bury-or-kill
  The backtrace buffer is read-only and uses a special major mode,
Debugger mode, in which letters are defined as debugger commands.  The
usual Emacs editing commands are available; thus, you can switch windows
to examine the buffer that was being edited at the time of the error,
switch buffers, visit files, or do any other sort of editing.  However,
the debugger is a recursive editing level (@pxref{Recursive Editing})
and it is wise to go back to the backtrace buffer and exit the debugger
(with the @kbd{q} command) when you are finished with it.  Exiting
the debugger gets out of the recursive edit and buries the backtrace
buffer.  (You can customize what the @kbd{q} command does with the
backtrace buffer by setting the variable @code{debugger-bury-or-kill}.
For example, set it to @code{kill} if you prefer to kill the buffer
rather than bury it.  Consult the variable's documentation for more
possibilities.)

  When the debugger has been entered, the @code{debug-on-error}
variable is temporarily set according to
@code{eval-expression-debug-on-error}.  If the latter variable is
non-@code{nil}, @code{debug-on-error} will temporarily be set to
@code{t}.  This means that any further errors that occur while doing a
debugging session will (by default) trigger another backtrace.  If
this is not what you want, you can either set
@code{eval-expression-debug-on-error} to @code{nil}, or set
@code{debug-on-error} to @code{nil} in @code{debugger-mode-hook}.

@cindex current stack frame
  The backtrace buffer shows you the functions that are executing and
their argument values.  It also allows you to specify a stack frame by
moving point to the line describing that frame.  (A stack frame is the
place where the Lisp interpreter records information about a particular
invocation of a function.)  The frame whose line point is on is
considered the @dfn{current frame}.  Some of the debugger commands
operate on the current frame.  If a line starts with a star, that means
that exiting that frame will call the debugger again.  This is useful
for examining the return value of a function.

  If a function name is underlined, that means the debugger knows
where its source code is located.  You can click with the mouse on
that name, or move to it and type @key{RET}, to visit the source code.

  The debugger itself must be run byte-compiled, since it makes
assumptions about how many stack frames are used for the debugger
itself.  These assumptions are false if the debugger is running
interpreted.

@node Debugger Commands
@subsection Debugger Commands
@cindex debugger command list

  The debugger buffer (in Debugger mode) provides special commands in
addition to the usual Emacs commands.  The most important use of
debugger commands is for stepping through code, so that you can see
how control flows.  The debugger can step through the control
structures of an interpreted function, but cannot do so in a
byte-compiled function.  If you would like to step through a
byte-compiled function, replace it with an interpreted definition of
the same function.  (To do this, visit the source for the function and
type @kbd{C-M-x} on its definition.)  You cannot use the Lisp debugger
to step through a primitive function.

@c FIXME: Add @findex for the following commands?  --xfq
  Here is a list of Debugger mode commands:

@table @kbd
@item c
Exit the debugger and continue execution.  This resumes execution of
the program as if the debugger had never been entered (aside from any
side-effects that you caused by changing variable values or data
structures while inside the debugger).

@item d
Continue execution, but enter the debugger the next time any Lisp
function is called.  This allows you to step through the
subexpressions of an expression, seeing what values the subexpressions
compute, and what else they do.

The stack frame made for the function call which enters the debugger in
this way will be flagged automatically so that the debugger will be
called again when the frame is exited.  You can use the @kbd{u} command
to cancel this flag.

@item b
Flag the current frame so that the debugger will be entered when the
frame is exited.  Frames flagged in this way are marked with stars
in the backtrace buffer.

@item u
Don't enter the debugger when the current frame is exited.  This
cancels a @kbd{b} command on that frame.  The visible effect is to
remove the star from the line in the backtrace buffer.

@item j
Flag the current frame like @kbd{b}.  Then continue execution like
@kbd{c}, but temporarily disable break-on-entry for all functions that
are set up to do so by @code{debug-on-entry}.

@item e
Read a Lisp expression in the minibuffer, evaluate it (with the
relevant lexical environment, if applicable), and print the
value in the echo area.  The debugger alters certain important
variables, and the current buffer, as part of its operation; @kbd{e}
temporarily restores their values from outside the debugger, so you can
examine and change them.  This makes the debugger more transparent.  By
contrast, @kbd{M-:} does nothing special in the debugger; it shows you
the variable values within the debugger.

@item R
Like @kbd{e}, but also save the result of evaluation in the
buffer @file{*Debugger-record*}.

@item q
Terminate the program being debugged; return to top-level Emacs
command execution.

If the debugger was entered due to a @kbd{C-g} but you really want
to quit, and not debug, use the @kbd{q} command.

@item r
Return a value from the debugger.  The value is computed by reading an
expression with the minibuffer and evaluating it.

The @kbd{r} command is useful when the debugger was invoked due to exit
from a Lisp call frame (as requested with @kbd{b} or by entering the
frame with @kbd{d}); then the value specified in the @kbd{r} command is
used as the value of that frame.  It is also useful if you call
@code{debug} and use its return value.  Otherwise, @kbd{r} has the same
effect as @kbd{c}, and the specified return value does not matter.

You can't use @kbd{r} when the debugger was entered due to an error.

@item l
Display a list of functions that will invoke the debugger when called.
This is a list of functions that are set to break on entry by means of
@code{debug-on-entry}.

@item v
Toggle the display of local variables of the current stack frame.
@end table

@node Invoking the Debugger
@subsection Invoking the Debugger
@cindex invoking lisp debugger

  Here we describe in full detail the function @code{debug} that is used
to invoke the debugger.

@deffn Command debug &rest debugger-args
This function enters the debugger.  It switches buffers to a buffer
named @file{*Backtrace*} (or @file{*Backtrace*<2>} if it is the second
recursive entry to the debugger, etc.), and fills it with information
about the stack of Lisp function calls.  It then enters a recursive
edit, showing the backtrace buffer in Debugger mode.

The Debugger mode @kbd{c}, @kbd{d}, @kbd{j}, and @kbd{r} commands exit
the recursive edit; then @code{debug} switches back to the previous
buffer and returns to whatever called @code{debug}.  This is the only
way the function @code{debug} can return to its caller.

The use of the @var{debugger-args} is that @code{debug} displays the
rest of its arguments at the top of the @file{*Backtrace*} buffer, so
that the user can see them.  Except as described below, this is the
@emph{only} way these arguments are used.

However, certain values for first argument to @code{debug} have a
special significance.  (Normally, these values are used only by the
internals of Emacs, and not by programmers calling @code{debug}.)  Here
is a table of these special values:

@table @code
@item lambda
@cindex @code{lambda} in debug
A first argument of @code{lambda} means @code{debug} was called
because of entry to a function when @code{debug-on-next-call} was
non-@code{nil}.  The debugger displays @samp{Debugger
entered--entering a function:} as a line of text at the top of the
buffer.

@item debug
@code{debug} as first argument means @code{debug} was called because
of entry to a function that was set to debug on entry.  The debugger
displays the string @samp{Debugger entered--entering a function:},
just as in the @code{lambda} case.  It also marks the stack frame for
that function so that it will invoke the debugger when exited.

@item t
When the first argument is @code{t}, this indicates a call to
@code{debug} due to evaluation of a function call form when
@code{debug-on-next-call} is non-@code{nil}.  The debugger displays
@samp{Debugger entered--beginning evaluation of function call form:}
as the top line in the buffer.

@item exit
When the first argument is @code{exit}, it indicates the exit of a
stack frame previously marked to invoke the debugger on exit.  The
second argument given to @code{debug} in this case is the value being
returned from the frame.  The debugger displays @samp{Debugger
entered--returning value:} in the top line of the buffer, followed by
the value being returned.

@item error
@cindex @code{error} in debug
When the first argument is @code{error}, the debugger indicates that
it is being entered because an error or @code{quit} was signaled and
not handled, by displaying @samp{Debugger entered--Lisp error:}
followed by the error signaled and any arguments to @code{signal}.
For example,

@example
@group
(let ((debug-on-error t))
  (/ 1 0))
@end group

@group
------ Buffer: *Backtrace* ------
Debugger entered--Lisp error: (arith-error)
  /(1 0)
...
------ Buffer: *Backtrace* ------
@end group
@end example

If an error was signaled, presumably the variable
@code{debug-on-error} is non-@code{nil}.  If @code{quit} was signaled,
then presumably the variable @code{debug-on-quit} is non-@code{nil}.

@item nil
Use @code{nil} as the first of the @var{debugger-args} when you want
to enter the debugger explicitly.  The rest of the @var{debugger-args}
are printed on the top line of the buffer.  You can use this feature to
display messages---for example, to remind yourself of the conditions
under which @code{debug} is called.
@end table
@end deffn

@node Internals of Debugger
@subsection Internals of the Debugger

  This section describes functions and variables used internally by the
debugger.

@defvar debugger
The value of this variable is the function to call to invoke the
debugger.  Its value must be a function of any number of arguments, or,
more typically, the name of a function.  This function should invoke
some kind of debugger.  The default value of the variable is
@code{debug}.

The first argument that Lisp hands to the function indicates why it
was called.  The convention for arguments is detailed in the description
of @code{debug} (@pxref{Invoking the Debugger}).
@end defvar

@defun backtrace
@cindex run time stack
@cindex call stack
This function prints a trace of Lisp function calls currently active.
This is the function used by @code{debug} to fill up the
@file{*Backtrace*} buffer.  It is written in C, since it must have access
to the stack to determine which function calls are active.  The return
value is always @code{nil}.

In the following example, a Lisp expression calls @code{backtrace}
explicitly.  This prints the backtrace to the stream
@code{standard-output}, which, in this case, is the buffer
@samp{backtrace-output}.

Each line of the backtrace represents one function call.  The line shows
the values of the function's arguments if they are all known; if they
are still being computed, the line says so.  The arguments of special
forms are elided.

@smallexample
@group
(with-output-to-temp-buffer "backtrace-output"
  (let ((var 1))
    (save-excursion
      (setq var (eval '(progn
                         (1+ var)
                         (list 'testing (backtrace))))))))

     @result{} (testing nil)
@end group

@group
----------- Buffer: backtrace-output ------------
  backtrace()
  (list ...computing arguments...)
@end group
  (progn ...)
  eval((progn (1+ var) (list (quote testing) (backtrace))))
  (setq ...)
  (save-excursion ...)
  (let ...)
  (with-output-to-temp-buffer ...)
  eval((with-output-to-temp-buffer ...))
  eval-last-sexp-1(nil)
@group
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp)
----------- Buffer: backtrace-output ------------
@end group
@end smallexample
@end defun

@defopt debugger-stack-frame-as-list
If this variable is non-@code{nil}, every stack frame of the backtrace
is displayed as a list.  This aims at improving the backtrace
readability at the cost of special forms no longer being visually
different from regular function calls.

With @code{debugger-stack-frame-as-list} non-@code{nil}, the above
example would look as follows:

@smallexample
@group
----------- Buffer: backtrace-output ------------
  (backtrace)
  (list ...computing arguments...)
@end group
  (progn ...)
  (eval (progn (1+ var) (list (quote testing) (backtrace))))
  (setq ...)
  (save-excursion ...)
  (let ...)
  (with-output-to-temp-buffer ...)
  (eval (with-output-to-temp-buffer ...))
  (eval-last-sexp-1 nil)
@group
  (eval-last-sexp nil)
  (call-interactively eval-last-sexp)
----------- Buffer: backtrace-output ------------
@end group
@end smallexample
@end defopt

@defvar debug-on-next-call
@cindex @code{eval}, and debugging
@cindex @code{apply}, and debugging
@cindex @code{funcall}, and debugging
If this variable is non-@code{nil}, it says to call the debugger before
the next @code{eval}, @code{apply} or @code{funcall}.  Entering the
debugger sets @code{debug-on-next-call} to @code{nil}.

The @kbd{d} command in the debugger works by setting this variable.
@end defvar

@defun backtrace-debug level flag
This function sets the debug-on-exit flag of the stack frame @var{level}
levels down the stack, giving it the value @var{flag}.  If @var{flag} is
non-@code{nil}, this will cause the debugger to be entered when that
frame later exits.  Even a nonlocal exit through that frame will enter
the debugger.

This function is used only by the debugger.
@end defun

@defvar command-debug-status
This variable records the debugging status of the current interactive
command.  Each time a command is called interactively, this variable is
bound to @code{nil}.  The debugger can set this variable to leave
information for future debugger invocations during the same command
invocation.

The advantage of using this variable rather than an ordinary global
variable is that the data will never carry over to a subsequent command
invocation.

This variable is obsolete and will be removed in future versions.
@end defvar

@defun backtrace-frame frame-number &optional base
The function @code{backtrace-frame} is intended for use in Lisp
debuggers.  It returns information about what computation is happening
in the stack frame @var{frame-number} levels down.

If that frame has not evaluated the arguments yet, or is a special
form, the value is @code{(nil @var{function} @var{arg-forms}@dots{})}.

If that frame has evaluated its arguments and called its function
already, the return value is @code{(t @var{function}
@var{arg-values}@dots{})}.

In the return value, @var{function} is whatever was supplied as the
@sc{car} of the evaluated list, or a @code{lambda} expression in the
case of a macro call.  If the function has a @code{&rest} argument, that
is represented as the tail of the list @var{arg-values}.

If @var{base} is specified, @var{frame-number} counts relative to
the topmost frame whose @var{function} is @var{base}.

If @var{frame-number} is out of range, @code{backtrace-frame} returns
@code{nil}.
@end defun

@defun mapbacktrace function &optional base
The function @code{mapbacktrace} calls @var{function} once for each
frame in the backtrace, starting at the first frame whose function is
@var{base} (or from the top if @var{base} is omitted or @code{nil}).

@var{function} is called with four arguments: @var{evald}, @var{func},
@var{args}, and @var{flags}.

If a frame has not evaluated its arguments yet or is a special form,
@var{evald} is @code{nil} and @var{args} is a list of forms.

If a frame has evaluated its arguments and called its function
already, @var{evald} is @code{t} and @var{args} is a list of values.
@var{flags} is a plist of properties of the current frame: currently,
the only supported property is @code{:debug-on-exit}, which is
@code{t} if the stack frame's @code{debug-on-exit} flag is set.
@end defun

@include edebug.texi

@node Syntax Errors
@section Debugging Invalid Lisp Syntax
@cindex debugging invalid Lisp syntax

  The Lisp reader reports invalid syntax, but cannot say where the real
problem is.  For example, the error @samp{End of file during parsing} in
evaluating an expression indicates an excess of open parentheses (or
square brackets).  The reader detects this imbalance at the end of the
file, but it cannot figure out where the close parenthesis should have
been.  Likewise, @samp{Invalid read syntax: ")"} indicates an excess close
parenthesis or missing open parenthesis, but does not say where the
missing parenthesis belongs.  How, then, to find what to change?

  If the problem is not simply an imbalance of parentheses, a useful
technique is to try @kbd{C-M-e} (@code{end-of-defun}, @pxref{Moving by
Defuns,,,emacs, The GNU Emacs Manual}) at the beginning of each defun,
and see if it goes to the place where that defun appears to end.  If
it does not, there is a problem in that defun.

@cindex unbalanced parentheses
@cindex parenthesis mismatch, debugging
  However, unmatched parentheses are the most common syntax errors in
Lisp, and we can give further advice for those cases.  (In addition,
just moving point through the code with Show Paren mode enabled might
find the mismatch.)

@menu
* Excess Open::     How to find a spurious open paren or missing close.
* Excess Close::    How to find a spurious close paren or missing open.
@end menu

@node Excess Open
@subsection Excess Open Parentheses
@cindex excess open parentheses

  The first step is to find the defun that is unbalanced.  If there is
an excess open parenthesis, the way to do this is to go to the end of
the file and type @kbd{C-u C-M-u} (@code{backward-up-list},
@pxref{Moving by Parens,,,emacs, The GNU Emacs Manual}).  This will
move you to the beginning of the first defun that is unbalanced.

  The next step is to determine precisely what is wrong.  There is no
way to be sure of this except by studying the program, but often the
existing indentation is a clue to where the parentheses should have
been.  The easiest way to use this clue is to reindent with @kbd{C-M-q}
(@code{indent-pp-sexp}, @pxref{Multi-line Indent,,,emacs, The GNU
Emacs Manual}) and see what moves.  @strong{But don't do this yet!}
Keep reading, first.

  Before you do this, make sure the defun has enough close parentheses.
Otherwise, @kbd{C-M-q} will get an error, or will reindent all the rest
of the file until the end.  So move to the end of the defun and insert a
close parenthesis there.  Don't use @kbd{C-M-e} (@code{end-of-defun}) to
move there, since that too will fail to work until the defun is balanced.

  Now you can go to the beginning of the defun and type @kbd{C-M-q}.
Usually all the lines from a certain point to the end of the function
will shift to the right.  There is probably a missing close parenthesis,
or a superfluous open parenthesis, near that point.  (However, don't
assume this is true; study the code to make sure.)  Once you have found
the discrepancy, undo the @kbd{C-M-q} with @kbd{C-_} (@code{undo}),
since the old indentation is probably appropriate to the intended
parentheses.

  After you think you have fixed the problem, use @kbd{C-M-q} again.  If
the old indentation actually fit the intended nesting of parentheses,
and you have put back those parentheses, @kbd{C-M-q} should not change
anything.

@node Excess Close
@subsection Excess Close Parentheses
@cindex excess close parentheses

  To deal with an excess close parenthesis, first go to the beginning
of the file, then type @kbd{C-u -1 C-M-u} (@code{backward-up-list}
with an argument of @minus{}1) to find the end of the first unbalanced
defun.

  Then find the actual matching close parenthesis by typing @kbd{C-M-f}
(@code{forward-sexp}, @pxref{Expressions,,,emacs, The GNU Emacs Manual})
at the beginning of that defun.  This will leave you somewhere short of
the place where the defun ought to end.  It is possible that you will
find a spurious close parenthesis in that vicinity.

  If you don't see a problem at that point, the next thing to do is to
type @kbd{C-M-q} (@code{indent-pp-sexp}) at the beginning of the defun.
A range of lines will probably shift left; if so, the missing open
parenthesis or spurious close parenthesis is probably near the first of
those lines.  (However, don't assume this is true; study the code to
make sure.)  Once you have found the discrepancy, undo the @kbd{C-M-q}
with @kbd{C-_} (@code{undo}), since the old indentation is probably
appropriate to the intended parentheses.

  After you think you have fixed the problem, use @kbd{C-M-q} again.  If
the old indentation actually fits the intended nesting of parentheses,
and you have put back those parentheses, @kbd{C-M-q} should not change
anything.

@node Test Coverage
@section Test Coverage
@cindex coverage testing

@findex testcover-start
@findex testcover-mark-all
@findex testcover-next-mark
  You can do coverage testing for a file of Lisp code by loading the
@code{testcover} library and using the command @kbd{M-x
testcover-start @key{RET} @var{file} @key{RET}} to instrument the
code.  Then test your code by calling it one or more times.  Then use
the command @kbd{M-x testcover-mark-all} to display colored highlights
on the code to show where coverage is insufficient.  The command
@kbd{M-x testcover-next-mark} will move point forward to the next
highlighted spot.

  Normally, a red highlight indicates the form was never completely
evaluated; a brown highlight means it always evaluated to the same
value (meaning there has been little testing of what is done with the
result).  However, the red highlight is skipped for forms that can't
possibly complete their evaluation, such as @code{error}.  The brown
highlight is skipped for forms that are expected to always evaluate to
the same value, such as @code{(setq x 14)}.

  For difficult cases, you can add do-nothing macros to your code to
give advice to the test coverage tool.

@defmac 1value form
Evaluate @var{form} and return its value, but inform coverage testing
that @var{form}'s value should always be the same.
@end defmac

@defmac noreturn form
Evaluate @var{form}, informing coverage testing that @var{form} should
never return.  If it ever does return, you get a run-time error.
@end defmac

  Edebug also has a coverage testing feature (@pxref{Coverage
Testing}).  These features partly duplicate each other, and it would
be cleaner to combine them.


@node Profiling
@section Profiling
@cindex profiling
@cindex profile
@cindex performance analysis
@cindex measuring resource usage
@cindex memory usage

If your program is working correctly, but not fast enough, and you
want to make it run more quickly or efficiently, the first thing to do
is @dfn{profile} your code so that you know where it spends most of
the execution time.  If you find that one particular function is
responsible for a significant portion of the execution time, you can
start looking for ways to optimize that piece.

@findex profiler-start
@findex profiler-report
@findex profiler-stop
Emacs has built-in support for this.  To begin profiling, type
@kbd{M-x profiler-start}.  You can choose to profile by processor
usage, memory usage, or both.  Then run the code you'd like to speed
up.  After that, type @kbd{M-x profiler-report} to display a summary
buffer for each resource (cpu and memory) that you chose to profile.
The names of the report buffers include the times at which the reports
were generated, so you can generate another report later on without
erasing previous results.  When you have finished profiling, type
@kbd{M-x profiler-stop} (there is a small overhead associated with
profiling, so we don't recommend leaving it active except when you are
actually running the code you want to examine).

The profiler report buffer shows, on each line, a function that was
called, followed by how much resources (cpu or memory) it used in
absolute and percentage terms since profiling started.  If a given
line has a @samp{+} symbol at the left-hand side, you can expand that
line by typing @kbd{@key{RET}}, in order to see the function(s) called
by the higher-level function.  Use a prefix argument (@kbd{C-u
@key{RET}}) to see the whole call tree below a function.  Pressing
@kbd{@key{RET}} again will collapse back to the original state.

Press @kbd{j} or @kbd{mouse-2} to jump to the definition of a function
at point.  Press @kbd{d} to view a function's documentation.  You can
save a profile to a file using @kbd{C-x C-w}.  You can compare two
profiles using @kbd{=}.

@c FIXME reversed calltree?

@cindex @file{elp.el}
@cindex timing programs
The @file{elp} library offers an alternative approach, which is useful
when you know in advance which Lisp function(s) you want to profile.
Using that library, you begin by setting @code{elp-function-list} to
the list of function symbols---those are the functions you want to
profile.  Then type @w{@kbd{M-x elp-instrument-list @key{RET} nil
@key{RET}}} to arrange for profiling those functions.  After running
the code you want to profile, invoke @w{@kbd{M-x elp-results}} to
display the current results.  See the file @file{elp.el} for more
detailed instructions.  This approach is limited to profiling
functions written in Lisp, it cannot profile Emacs primitives.

@cindex @file{benchmark.el}
@cindex benchmarking
You can measure the time it takes to evaluate individual Emacs Lisp
forms using the @file{benchmark} library.  See the macros
@code{benchmark-run} and @code{benchmark-run-compiled} in
@file{benchmark.el}.  You can also use the @code{benchmark} command
for timing forms interactively.

@c Not worth putting in the printed manual.
@ifnottex
@cindex --enable-profiling option of configure
To profile Emacs at the level of its C code, you can build it using the
@option{--enable-profiling} option of @command{configure}.  When Emacs
exits, it generates a file @file{gmon.out} that you can examine using
the @command{gprof} utility.  This feature is mainly useful for
debugging Emacs.  It actually stops the Lisp-level @kbd{M-x
profiler-@dots{}} commands described above from working.
@end ifnottex
